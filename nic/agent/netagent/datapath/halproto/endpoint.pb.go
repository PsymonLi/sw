// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: endpoint.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MigrationState int32

const (
	MigrationState_NONE        MigrationState = 0
	MigrationState_IN_PROGRESS MigrationState = 1
	MigrationState_SUCCESS     MigrationState = 2
	MigrationState_FAILED      MigrationState = 3
	MigrationState_ABORTED     MigrationState = 4
	MigrationState_COLD        MigrationState = 5
)

var MigrationState_name = map[int32]string{
	0: "NONE",
	1: "IN_PROGRESS",
	2: "SUCCESS",
	3: "FAILED",
	4: "ABORTED",
	5: "COLD",
}
var MigrationState_value = map[string]int32{
	"NONE":        0,
	"IN_PROGRESS": 1,
	"SUCCESS":     2,
	"FAILED":      3,
	"ABORTED":     4,
	"COLD":        5,
}

func (x MigrationState) String() string {
	return proto.EnumName(MigrationState_name, int32(x))
}
func (MigrationState) EnumDescriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{0} }

type EndpointAttributes struct {
	InterfaceKeyHandle *InterfaceKeyHandle       `protobuf:"bytes,1,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
	UsegVlan           uint32                    `protobuf:"varint,2,opt,name=useg_vlan,json=usegVlan,proto3" json:"useg_vlan,omitempty"`
	IpAddress          []*IPAddress              `protobuf:"bytes,3,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	SgKeyHandle        []*SecurityGroupKeyHandle `protobuf:"bytes,4,rep,name=sg_key_handle,json=sgKeyHandle" json:"sg_key_handle,omitempty" venice:ref`
	OldHomingHostIp    *IPAddress                `protobuf:"bytes,5,opt,name=old_homing_host_ip,json=oldHomingHostIp" json:"old_homing_host_ip,omitempty"`
	VmotionState       MigrationState            `protobuf:"varint,6,opt,name=vmotion_state,json=vmotionState,proto3,enum=endpoint.MigrationState" json:"vmotion_state,omitempty"`
}

func (m *EndpointAttributes) Reset()                    { *m = EndpointAttributes{} }
func (m *EndpointAttributes) String() string            { return proto.CompactTextString(m) }
func (*EndpointAttributes) ProtoMessage()               {}
func (*EndpointAttributes) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{0} }

func (m *EndpointAttributes) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

func (m *EndpointAttributes) GetUsegVlan() uint32 {
	if m != nil {
		return m.UsegVlan
	}
	return 0
}

func (m *EndpointAttributes) GetIpAddress() []*IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointAttributes) GetSgKeyHandle() []*SecurityGroupKeyHandle {
	if m != nil {
		return m.SgKeyHandle
	}
	return nil
}

func (m *EndpointAttributes) GetOldHomingHostIp() *IPAddress {
	if m != nil {
		return m.OldHomingHostIp
	}
	return nil
}

func (m *EndpointAttributes) GetVmotionState() MigrationState {
	if m != nil {
		return m.VmotionState
	}
	return MigrationState_NONE
}

// EndpointSpec is used to add or update an endpoint
type EndpointSpec struct {
	Meta          *delphi.ObjectMeta  `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle   *EndpointKeyHandle  `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle  *VrfKeyHandle       `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	EndpointAttrs *EndpointAttributes `protobuf:"bytes,4,opt,name=endpoint_attrs,json=endpointAttrs" json:"endpoint_attrs,omitempty"`
}

func (m *EndpointSpec) Reset()                    { *m = EndpointSpec{} }
func (m *EndpointSpec) String() string            { return proto.CompactTextString(m) }
func (*EndpointSpec) ProtoMessage()               {}
func (*EndpointSpec) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{1} }

func (m *EndpointSpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointSpec) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointSpec) GetEndpointAttrs() *EndpointAttributes {
	if m != nil {
		return m.EndpointAttrs
	}
	return nil
}

// EndpointRequestMsg is batched add or modify endpoint request
type EndpointRequestMsg struct {
	Request []*EndpointSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointRequestMsg) Reset()                    { *m = EndpointRequestMsg{} }
func (m *EndpointRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointRequestMsg) ProtoMessage()               {}
func (*EndpointRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{2} }

func (m *EndpointRequestMsg) GetRequest() []*EndpointSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Endpoint IP address information.
type EndpointIpAddress struct {
	IpAddress         *IPAddress     `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	LearnSourceDhcp   bool           `protobuf:"varint,2,opt,name=learn_source_dhcp,json=learnSourceDhcp,proto3" json:"learn_source_dhcp,omitempty"`
	LearnSourceArp    bool           `protobuf:"varint,3,opt,name=learn_source_arp,json=learnSourceArp,proto3" json:"learn_source_arp,omitempty"`
	LearnSourceRarp   bool           `protobuf:"varint,4,opt,name=learn_source_rarp,json=learnSourceRarp,proto3" json:"learn_source_rarp,omitempty"`
	LearnSourceConfig bool           `protobuf:"varint,5,opt,name=learn_source_config,json=learnSourceConfig,proto3" json:"learn_source_config,omitempty"`
	LearnStatus       *EplearnStatus `protobuf:"bytes,6,opt,name=learn_status,json=learnStatus" json:"learn_status,omitempty"`
	IpsgTblIdx        uint32         `protobuf:"varint,7,opt,name=ipsg_tbl_idx,json=ipsgTblIdx,proto3" json:"ipsg_tbl_idx,omitempty"`
}

func (m *EndpointIpAddress) Reset()                    { *m = EndpointIpAddress{} }
func (m *EndpointIpAddress) String() string            { return proto.CompactTextString(m) }
func (*EndpointIpAddress) ProtoMessage()               {}
func (*EndpointIpAddress) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{3} }

func (m *EndpointIpAddress) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointIpAddress) GetLearnSourceDhcp() bool {
	if m != nil {
		return m.LearnSourceDhcp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceArp() bool {
	if m != nil {
		return m.LearnSourceArp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceRarp() bool {
	if m != nil {
		return m.LearnSourceRarp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

func (m *EndpointIpAddress) GetLearnStatus() *EplearnStatus {
	if m != nil {
		return m.LearnStatus
	}
	return nil
}

func (m *EndpointIpAddress) GetIpsgTblIdx() uint32 {
	if m != nil {
		return m.IpsgTblIdx
	}
	return 0
}

type EndpointStatusEpd struct {
	RegMacTblIdx uint32   `protobuf:"varint,1,opt,name=reg_mac_tbl_idx,json=regMacTblIdx,proto3" json:"reg_mac_tbl_idx,omitempty"`
	RwTblIdx     []uint32 `protobuf:"varint,2,rep,packed,name=rw_tbl_idx,json=rwTblIdx" json:"rw_tbl_idx,omitempty"`
}

func (m *EndpointStatusEpd) Reset()                    { *m = EndpointStatusEpd{} }
func (m *EndpointStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatusEpd) ProtoMessage()               {}
func (*EndpointStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{4} }

func (m *EndpointStatusEpd) GetRegMacTblIdx() uint32 {
	if m != nil {
		return m.RegMacTblIdx
	}
	return 0
}

func (m *EndpointStatusEpd) GetRwTblIdx() []uint32 {
	if m != nil {
		return m.RwTblIdx
	}
	return nil
}

type EndpointStatusCpd struct {
}

func (m *EndpointStatusCpd) Reset()                    { *m = EndpointStatusCpd{} }
func (m *EndpointStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatusCpd) ProtoMessage()               {}
func (*EndpointStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{5} }

// EndpointStatus has the current status of an endpoint
// TODO: capturing aging information, if any
type EndpointStatus struct {
	Meta                        *delphi.ObjectMeta   `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle                 *EndpointKeyHandle   `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	EnicPinnedUplinkIfKeyHandle *InterfaceKeyHandle  `protobuf:"bytes,3,opt,name=enic_pinned_uplink_if_key_handle,json=enicPinnedUplinkIfKeyHandle" json:"enic_pinned_uplink_if_key_handle,omitempty" venice:ref`
	IpAddress                   []*EndpointIpAddress `protobuf:"bytes,4,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	IsEndpointLocal             bool                 `protobuf:"varint,5,opt,name=is_endpoint_local,json=isEndpointLocal,proto3" json:"is_endpoint_local,omitempty"`
	LearnSourceConfig           bool                 `protobuf:"varint,6,opt,name=learn_source_config,json=learnSourceConfig,proto3" json:"learn_source_config,omitempty"`
	// Types that are valid to be assigned to EpPdStatus:
	//	*EndpointStatus_EpdStatus
	//	*EndpointStatus_CpdStatus
	EpPdStatus isEndpointStatus_EpPdStatus `protobuf_oneof:"ep_pd_status"`
}

func (m *EndpointStatus) Reset()                    { *m = EndpointStatus{} }
func (m *EndpointStatus) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatus) ProtoMessage()               {}
func (*EndpointStatus) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{6} }

type isEndpointStatus_EpPdStatus interface {
	isEndpointStatus_EpPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndpointStatus_EpdStatus struct {
	EpdStatus *EndpointStatusEpd `protobuf:"bytes,7,opt,name=epd_status,json=epdStatus,oneof"`
}
type EndpointStatus_CpdStatus struct {
	CpdStatus *EndpointStatusCpd `protobuf:"bytes,8,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*EndpointStatus_EpdStatus) isEndpointStatus_EpPdStatus() {}
func (*EndpointStatus_CpdStatus) isEndpointStatus_EpPdStatus() {}

func (m *EndpointStatus) GetEpPdStatus() isEndpointStatus_EpPdStatus {
	if m != nil {
		return m.EpPdStatus
	}
	return nil
}

func (m *EndpointStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointStatus) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointStatus) GetEnicPinnedUplinkIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.EnicPinnedUplinkIfKeyHandle
	}
	return nil
}

func (m *EndpointStatus) GetIpAddress() []*EndpointIpAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointStatus) GetIsEndpointLocal() bool {
	if m != nil {
		return m.IsEndpointLocal
	}
	return false
}

func (m *EndpointStatus) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

func (m *EndpointStatus) GetEpdStatus() *EndpointStatusEpd {
	if x, ok := m.GetEpPdStatus().(*EndpointStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *EndpointStatus) GetCpdStatus() *EndpointStatusCpd {
	if x, ok := m.GetEpPdStatus().(*EndpointStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointStatus_OneofMarshaler, _EndpointStatus_OneofUnmarshaler, _EndpointStatus_OneofSizer, []interface{}{
		(*EndpointStatus_EpdStatus)(nil),
		(*EndpointStatus_CpdStatus)(nil),
	}
}

func _EndpointStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointStatus)
	// ep_pd_status
	switch x := m.EpPdStatus.(type) {
	case *EndpointStatus_EpdStatus:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *EndpointStatus_CpdStatus:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointStatus.EpPdStatus has unexpected type %T", x)
	}
	return nil
}

func _EndpointStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointStatus)
	switch tag {
	case 7: // ep_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointStatusEpd)
		err := b.DecodeMessage(msg)
		m.EpPdStatus = &EndpointStatus_EpdStatus{msg}
		return true, err
	case 8: // ep_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointStatusCpd)
		err := b.DecodeMessage(msg)
		m.EpPdStatus = &EndpointStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointStatus)
	// ep_pd_status
	switch x := m.EpPdStatus.(type) {
	case *EndpointStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointResponse is response to EndpointSpec
type EndpointResponse struct {
	ApiStatus      ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	EndpointStatus *EndpointStatus `protobuf:"bytes,2,opt,name=endpoint_status,json=endpointStatus" json:"endpoint_status,omitempty"`
}

func (m *EndpointResponse) Reset()                    { *m = EndpointResponse{} }
func (m *EndpointResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponse) ProtoMessage()               {}
func (*EndpointResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{7} }

func (m *EndpointResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointResponse) GetEndpointStatus() *EndpointStatus {
	if m != nil {
		return m.EndpointStatus
	}
	return nil
}

// EndpointResponseMsg is batched response to EndpointRequestMsg
type EndpointResponseMsg struct {
	Response []*EndpointResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointResponseMsg) Reset()                    { *m = EndpointResponseMsg{} }
func (m *EndpointResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponseMsg) ProtoMessage()               {}
func (*EndpointResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{8} }

func (m *EndpointResponseMsg) GetResponse() []*EndpointResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Endpoint Update message
type EndpointUpdateRequest struct {
	// key_or_handle is used to identify an endpoint uniquely
	KeyOrHandle   *EndpointKeyHandle  `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle  *VrfKeyHandle       `protobuf:"bytes,2,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	EndpointAttrs *EndpointAttributes `protobuf:"bytes,3,opt,name=endpoint_attrs,json=endpointAttrs" json:"endpoint_attrs,omitempty"`
}

func (m *EndpointUpdateRequest) Reset()                    { *m = EndpointUpdateRequest{} }
func (m *EndpointUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointUpdateRequest) ProtoMessage()               {}
func (*EndpointUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{9} }

func (m *EndpointUpdateRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointUpdateRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointUpdateRequest) GetEndpointAttrs() *EndpointAttributes {
	if m != nil {
		return m.EndpointAttrs
	}
	return nil
}

// EndpointUpdateRequestMsg is batched endpoint update request
type EndpointUpdateRequestMsg struct {
	Request []*EndpointUpdateRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointUpdateRequestMsg) Reset()         { *m = EndpointUpdateRequestMsg{} }
func (m *EndpointUpdateRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointUpdateRequestMsg) ProtoMessage()    {}
func (*EndpointUpdateRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{10}
}

func (m *EndpointUpdateRequestMsg) GetRequest() []*EndpointUpdateRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointUpdateResponseMsg is used to update a batch of Endpoints
type EndpointUpdateResponseMsg struct {
	Response []*EndpointResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointUpdateResponseMsg) Reset()         { *m = EndpointUpdateResponseMsg{} }
func (m *EndpointUpdateResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointUpdateResponseMsg) ProtoMessage()    {}
func (*EndpointUpdateResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{11}
}

func (m *EndpointUpdateResponseMsg) GetResponse() []*EndpointResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// EndpointFilter is attributes by which endpoints can be manipulated
// or queried. As the endpoint database can be huge, this is provided
// so that agent and HAL are less chatty when doing bulk deletes (e.g.
// when a L2 segment is deleted or interfae goes down etc.)
type EndpointFilter struct {
	VrfKeyHandle       *VrfKeyHandle       `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	InterfaceKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,3,opt,name=l2Segment_key_handle,json=l2SegmentKeyHandle" json:"l2Segment_key_handle,omitempty" venice:ref`
}

func (m *EndpointFilter) Reset()                    { *m = EndpointFilter{} }
func (m *EndpointFilter) String() string            { return proto.CompactTextString(m) }
func (*EndpointFilter) ProtoMessage()               {}
func (*EndpointFilter) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{12} }

func (m *EndpointFilter) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointFilter) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

func (m *EndpointFilter) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

// EndpointDeleteRequest is used to delete an endpoint
type EndpointDeleteRequest struct {
	// Types that are valid to be assigned to DeleteBy:
	//	*EndpointDeleteRequest_KeyOrHandle
	//	*EndpointDeleteRequest_Filter
	DeleteBy     isEndpointDeleteRequest_DeleteBy `protobuf_oneof:"delete_by"`
	VrfKeyHandle *VrfKeyHandle                    `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *EndpointDeleteRequest) Reset()                    { *m = EndpointDeleteRequest{} }
func (m *EndpointDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteRequest) ProtoMessage()               {}
func (*EndpointDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{13} }

type isEndpointDeleteRequest_DeleteBy interface {
	isEndpointDeleteRequest_DeleteBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndpointDeleteRequest_KeyOrHandle struct {
	KeyOrHandle *EndpointKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle,oneof"`
}
type EndpointDeleteRequest_Filter struct {
	Filter *EndpointFilter `protobuf:"bytes,2,opt,name=filter,oneof"`
}

func (*EndpointDeleteRequest_KeyOrHandle) isEndpointDeleteRequest_DeleteBy() {}
func (*EndpointDeleteRequest_Filter) isEndpointDeleteRequest_DeleteBy()      {}

func (m *EndpointDeleteRequest) GetDeleteBy() isEndpointDeleteRequest_DeleteBy {
	if m != nil {
		return m.DeleteBy
	}
	return nil
}

func (m *EndpointDeleteRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_KeyOrHandle); ok {
		return x.KeyOrHandle
	}
	return nil
}

func (m *EndpointDeleteRequest) GetFilter() *EndpointFilter {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *EndpointDeleteRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointDeleteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointDeleteRequest_OneofMarshaler, _EndpointDeleteRequest_OneofUnmarshaler, _EndpointDeleteRequest_OneofSizer, []interface{}{
		(*EndpointDeleteRequest_KeyOrHandle)(nil),
		(*EndpointDeleteRequest_Filter)(nil),
	}
}

func _EndpointDeleteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KeyOrHandle); err != nil {
			return err
		}
	case *EndpointDeleteRequest_Filter:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Filter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointDeleteRequest.DeleteBy has unexpected type %T", x)
	}
	return nil
}

func _EndpointDeleteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointDeleteRequest)
	switch tag {
	case 1: // delete_by.key_or_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointKeyHandle)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_KeyOrHandle{msg}
		return true, err
	case 2: // delete_by.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointFilter)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_Filter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointDeleteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		s := proto.Size(x.KeyOrHandle)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointDeleteRequest_Filter:
		s := proto.Size(x.Filter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointDeleteRequestMsg is batched endpoint delete request
type EndpointDeleteRequestMsg struct {
	Request []*EndpointDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointDeleteRequestMsg) Reset()         { *m = EndpointDeleteRequestMsg{} }
func (m *EndpointDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointDeleteRequestMsg) ProtoMessage()    {}
func (*EndpointDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{14}
}

func (m *EndpointDeleteRequestMsg) GetRequest() []*EndpointDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type EndpointDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *EndpointDeleteResponse) Reset()                    { *m = EndpointDeleteResponse{} }
func (m *EndpointDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteResponse) ProtoMessage()               {}
func (*EndpointDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{15} }

func (m *EndpointDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EndpointDeleteResponseMsg is used to delete a batch of Endpoints
type EndpointDeleteResponseMsg struct {
	Response []*EndpointDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointDeleteResponseMsg) Reset()         { *m = EndpointDeleteResponseMsg{} }
func (m *EndpointDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointDeleteResponseMsg) ProtoMessage()    {}
func (*EndpointDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{16}
}

func (m *EndpointDeleteResponseMsg) GetResponse() []*EndpointDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// EndpointGetRequest is used to get information about an endpoint
type EndpointGetRequest struct {
	// key_or_handle is the endpoint's identifier for retrieval
	KeyOrHandle  *EndpointKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle      `protobuf:"bytes,2,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *EndpointGetRequest) Reset()                    { *m = EndpointGetRequest{} }
func (m *EndpointGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequest) ProtoMessage()               {}
func (*EndpointGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{17} }

func (m *EndpointGetRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointGetRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// EndpointGetRequestMsg is batched GET request for endpoints
type EndpointGetRequestMsg struct {
	Request []*EndpointGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointGetRequestMsg) Reset()                    { *m = EndpointGetRequestMsg{} }
func (m *EndpointGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequestMsg) ProtoMessage()               {}
func (*EndpointGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{18} }

func (m *EndpointGetRequestMsg) GetRequest() []*EndpointGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type EndpointGetByInterfaceRequest struct {
	VrfKeyHandle       *VrfKeyHandle       `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	InterfaceKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
}

func (m *EndpointGetByInterfaceRequest) Reset()         { *m = EndpointGetByInterfaceRequest{} }
func (m *EndpointGetByInterfaceRequest) String() string { return proto.CompactTextString(m) }
func (*EndpointGetByInterfaceRequest) ProtoMessage()    {}
func (*EndpointGetByInterfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{19}
}

func (m *EndpointGetByInterfaceRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointGetByInterfaceRequest) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

// EndpointGetByInterfaceRequestMsg is used to GET endpoints by interface
type EndpointGetByInterfaceRequestMsg struct {
	Request []*EndpointGetByInterfaceRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointGetByInterfaceRequestMsg) Reset()         { *m = EndpointGetByInterfaceRequestMsg{} }
func (m *EndpointGetByInterfaceRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointGetByInterfaceRequestMsg) ProtoMessage()    {}
func (*EndpointGetByInterfaceRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{20}
}

func (m *EndpointGetByInterfaceRequestMsg) GetRequest() []*EndpointGetByInterfaceRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointGetAllRequestMsg is used to GET all the endpoints
type EndpointGetAllRequestMsg struct {
}

func (m *EndpointGetAllRequestMsg) Reset()         { *m = EndpointGetAllRequestMsg{} }
func (m *EndpointGetAllRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointGetAllRequestMsg) ProtoMessage()    {}
func (*EndpointGetAllRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{21}
}

// EndpointStats is the statistics object for each Endpoint
type EndpointStats struct {
	EpLearnStats *EplearnStats `protobuf:"bytes,1,opt,name=ep_learn_stats,json=epLearnStats" json:"ep_learn_stats,omitempty"`
}

func (m *EndpointStats) Reset()                    { *m = EndpointStats{} }
func (m *EndpointStats) String() string            { return proto.CompactTextString(m) }
func (*EndpointStats) ProtoMessage()               {}
func (*EndpointStats) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{22} }

func (m *EndpointStats) GetEpLearnStats() *EplearnStats {
	if m != nil {
		return m.EpLearnStats
	}
	return nil
}

// EndpointGetResponse captures all the information about one Endpoint
type EndpointGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *EndpointSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *EndpointStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *EndpointStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *EndpointGetResponse) Reset()                    { *m = EndpointGetResponse{} }
func (m *EndpointGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponse) ProtoMessage()               {}
func (*EndpointGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{23} }

func (m *EndpointGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointGetResponse) GetSpec() *EndpointSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EndpointGetResponse) GetStatus() *EndpointStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *EndpointGetResponse) GetStats() *EndpointStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// EndpointGetResponseMsg is batched response to EndpointGetRequestMsg
type EndpointGetResponseMsg struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*EndpointGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointGetResponseMsg) Reset()                    { *m = EndpointGetResponseMsg{} }
func (m *EndpointGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponseMsg) ProtoMessage()               {}
func (*EndpointGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{24} }

func (m *EndpointGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointGetResponseMsg) GetResponse() []*EndpointGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type MigrationResponse struct {
	Spec           *EndpointSpec  `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	MigrationState MigrationState `protobuf:"varint,2,opt,name=migration_state,json=migrationState,proto3,enum=endpoint.MigrationState" json:"migration_state,omitempty"`
}

func (m *MigrationResponse) Reset()                    { *m = MigrationResponse{} }
func (m *MigrationResponse) String() string            { return proto.CompactTextString(m) }
func (*MigrationResponse) ProtoMessage()               {}
func (*MigrationResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{25} }

func (m *MigrationResponse) GetSpec() *EndpointSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MigrationResponse) GetMigrationState() MigrationState {
	if m != nil {
		return m.MigrationState
	}
	return MigrationState_NONE
}

// Filter Spec
type FilterSpec struct {
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterSpec) Reset()                    { *m = FilterSpec{} }
func (m *FilterSpec) String() string            { return proto.CompactTextString(m) }
func (*FilterSpec) ProtoMessage()               {}
func (*FilterSpec) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{26} }

func (m *FilterSpec) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Filter Request Message
type FilterRequestMsg struct {
	Request []*FilterSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterRequestMsg) Reset()                    { *m = FilterRequestMsg{} }
func (m *FilterRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterRequestMsg) ProtoMessage()               {}
func (*FilterRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{27} }

func (m *FilterRequestMsg) GetRequest() []*FilterSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FilterStatus has the current status of an endpoint
type FilterStatus struct {
	FilterHandle uint64 `protobuf:"fixed64,1,opt,name=filter_handle,json=filterHandle,proto3" json:"filter_handle,omitempty"`
}

func (m *FilterStatus) Reset()                    { *m = FilterStatus{} }
func (m *FilterStatus) String() string            { return proto.CompactTextString(m) }
func (*FilterStatus) ProtoMessage()               {}
func (*FilterStatus) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{28} }

func (m *FilterStatus) GetFilterHandle() uint64 {
	if m != nil {
		return m.FilterHandle
	}
	return 0
}

// FilterResponse is response to FilterSpec
type FilterResponse struct {
	ApiStatus    ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	FilterStatus *FilterStatus `protobuf:"bytes,2,opt,name=filter_status,json=filterStatus" json:"filter_status,omitempty"`
}

func (m *FilterResponse) Reset()                    { *m = FilterResponse{} }
func (m *FilterResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterResponse) ProtoMessage()               {}
func (*FilterResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{29} }

func (m *FilterResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterResponse) GetFilterStatus() *FilterStatus {
	if m != nil {
		return m.FilterStatus
	}
	return nil
}

// FilterResponseMsg is batched response to FilterRequestMsg
type FilterResponseMsg struct {
	Response []*FilterResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FilterResponseMsg) Reset()                    { *m = FilterResponseMsg{} }
func (m *FilterResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterResponseMsg) ProtoMessage()               {}
func (*FilterResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{30} }

func (m *FilterResponseMsg) GetResponse() []*FilterResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FilterDeleteRequest is used to delete an filter
type FilterDeleteRequest struct {
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterDeleteRequest) Reset()                    { *m = FilterDeleteRequest{} }
func (m *FilterDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteRequest) ProtoMessage()               {}
func (*FilterDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{31} }

func (m *FilterDeleteRequest) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FilterDeleteRequestMsg is batched filter delete request
type FilterDeleteRequestMsg struct {
	Request []*FilterDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterDeleteRequestMsg) Reset()                    { *m = FilterDeleteRequestMsg{} }
func (m *FilterDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteRequestMsg) ProtoMessage()               {}
func (*FilterDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{32} }

func (m *FilterDeleteRequestMsg) GetRequest() []*FilterDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type FilterDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *FilterDeleteResponse) Reset()                    { *m = FilterDeleteResponse{} }
func (m *FilterDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteResponse) ProtoMessage()               {}
func (*FilterDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{33} }

func (m *FilterDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// FilterDeleteResponseMsg is used to delete a batch of Filters
type FilterDeleteResponseMsg struct {
	Response []*FilterDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FilterDeleteResponseMsg) Reset()                    { *m = FilterDeleteResponseMsg{} }
func (m *FilterDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteResponseMsg) ProtoMessage()               {}
func (*FilterDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{34} }

func (m *FilterDeleteResponseMsg) GetResponse() []*FilterDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FilterGetRequest is used to get information about an filter
type FilterGetRequest struct {
	// key_or_handle is the filter's identifier for retrieval
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterGetRequest) Reset()                    { *m = FilterGetRequest{} }
func (m *FilterGetRequest) String() string            { return proto.CompactTextString(m) }
func (*FilterGetRequest) ProtoMessage()               {}
func (*FilterGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{35} }

func (m *FilterGetRequest) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FilterGetRequestMsg is batched GET request for filters
type FilterGetRequestMsg struct {
	Request []*FilterGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterGetRequestMsg) Reset()                    { *m = FilterGetRequestMsg{} }
func (m *FilterGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterGetRequestMsg) ProtoMessage()               {}
func (*FilterGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{36} }

func (m *FilterGetRequestMsg) GetRequest() []*FilterGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FilterGetResponse captures all the information about one Filter
type FilterGetResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *FilterSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *FilterStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *FilterGetResponse) Reset()                    { *m = FilterGetResponse{} }
func (m *FilterGetResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterGetResponse) ProtoMessage()               {}
func (*FilterGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{37} }

func (m *FilterGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterGetResponse) GetSpec() *FilterSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *FilterGetResponse) GetStatus() *FilterStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// FilterGetResponseMsg is batched response to FilterGetRequestMsg
type FilterGetResponseMsg struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*FilterGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *FilterGetResponseMsg) Reset()                    { *m = FilterGetResponseMsg{} }
func (m *FilterGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterGetResponseMsg) ProtoMessage()               {}
func (*FilterGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{38} }

func (m *FilterGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterGetResponseMsg) GetResponse() []*FilterGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EndpointAttributes)(nil), "endpoint.EndpointAttributes")
	proto.RegisterType((*EndpointSpec)(nil), "endpoint.EndpointSpec")
	proto.RegisterType((*EndpointRequestMsg)(nil), "endpoint.EndpointRequestMsg")
	proto.RegisterType((*EndpointIpAddress)(nil), "endpoint.EndpointIpAddress")
	proto.RegisterType((*EndpointStatusEpd)(nil), "endpoint.EndpointStatusEpd")
	proto.RegisterType((*EndpointStatusCpd)(nil), "endpoint.EndpointStatusCpd")
	proto.RegisterType((*EndpointStatus)(nil), "endpoint.EndpointStatus")
	proto.RegisterType((*EndpointResponse)(nil), "endpoint.EndpointResponse")
	proto.RegisterType((*EndpointResponseMsg)(nil), "endpoint.EndpointResponseMsg")
	proto.RegisterType((*EndpointUpdateRequest)(nil), "endpoint.EndpointUpdateRequest")
	proto.RegisterType((*EndpointUpdateRequestMsg)(nil), "endpoint.EndpointUpdateRequestMsg")
	proto.RegisterType((*EndpointUpdateResponseMsg)(nil), "endpoint.EndpointUpdateResponseMsg")
	proto.RegisterType((*EndpointFilter)(nil), "endpoint.EndpointFilter")
	proto.RegisterType((*EndpointDeleteRequest)(nil), "endpoint.EndpointDeleteRequest")
	proto.RegisterType((*EndpointDeleteRequestMsg)(nil), "endpoint.EndpointDeleteRequestMsg")
	proto.RegisterType((*EndpointDeleteResponse)(nil), "endpoint.EndpointDeleteResponse")
	proto.RegisterType((*EndpointDeleteResponseMsg)(nil), "endpoint.EndpointDeleteResponseMsg")
	proto.RegisterType((*EndpointGetRequest)(nil), "endpoint.EndpointGetRequest")
	proto.RegisterType((*EndpointGetRequestMsg)(nil), "endpoint.EndpointGetRequestMsg")
	proto.RegisterType((*EndpointGetByInterfaceRequest)(nil), "endpoint.EndpointGetByInterfaceRequest")
	proto.RegisterType((*EndpointGetByInterfaceRequestMsg)(nil), "endpoint.EndpointGetByInterfaceRequestMsg")
	proto.RegisterType((*EndpointGetAllRequestMsg)(nil), "endpoint.EndpointGetAllRequestMsg")
	proto.RegisterType((*EndpointStats)(nil), "endpoint.EndpointStats")
	proto.RegisterType((*EndpointGetResponse)(nil), "endpoint.EndpointGetResponse")
	proto.RegisterType((*EndpointGetResponseMsg)(nil), "endpoint.EndpointGetResponseMsg")
	proto.RegisterType((*MigrationResponse)(nil), "endpoint.MigrationResponse")
	proto.RegisterType((*FilterSpec)(nil), "endpoint.FilterSpec")
	proto.RegisterType((*FilterRequestMsg)(nil), "endpoint.FilterRequestMsg")
	proto.RegisterType((*FilterStatus)(nil), "endpoint.FilterStatus")
	proto.RegisterType((*FilterResponse)(nil), "endpoint.FilterResponse")
	proto.RegisterType((*FilterResponseMsg)(nil), "endpoint.FilterResponseMsg")
	proto.RegisterType((*FilterDeleteRequest)(nil), "endpoint.FilterDeleteRequest")
	proto.RegisterType((*FilterDeleteRequestMsg)(nil), "endpoint.FilterDeleteRequestMsg")
	proto.RegisterType((*FilterDeleteResponse)(nil), "endpoint.FilterDeleteResponse")
	proto.RegisterType((*FilterDeleteResponseMsg)(nil), "endpoint.FilterDeleteResponseMsg")
	proto.RegisterType((*FilterGetRequest)(nil), "endpoint.FilterGetRequest")
	proto.RegisterType((*FilterGetRequestMsg)(nil), "endpoint.FilterGetRequestMsg")
	proto.RegisterType((*FilterGetResponse)(nil), "endpoint.FilterGetResponse")
	proto.RegisterType((*FilterGetResponseMsg)(nil), "endpoint.FilterGetResponseMsg")
	proto.RegisterEnum("endpoint.MigrationState", MigrationState_name, MigrationState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Endpoint service

type EndpointClient interface {
	EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error)
	EndpointUpdate(ctx context.Context, in *EndpointUpdateRequestMsg, opts ...grpc.CallOption) (*EndpointUpdateResponseMsg, error)
	EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error)
	EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error)
	// Filter
	FilterCreate(ctx context.Context, in *FilterRequestMsg, opts ...grpc.CallOption) (*FilterResponseMsg, error)
	// rpc FilterUpdate (FilterRequestMsg) returns (FilterResponseMsg) {}
	FilterDelete(ctx context.Context, in *FilterDeleteRequestMsg, opts ...grpc.CallOption) (*FilterDeleteResponseMsg, error)
	FilterGet(ctx context.Context, in *FilterGetRequestMsg, opts ...grpc.CallOption) (*FilterGetResponseMsg, error)
}

type endpointClient struct {
	cc *grpc.ClientConn
}

func NewEndpointClient(cc *grpc.ClientConn) EndpointClient {
	return &endpointClient{cc}
}

func (c *endpointClient) EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error) {
	out := new(EndpointResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointUpdate(ctx context.Context, in *EndpointUpdateRequestMsg, opts ...grpc.CallOption) (*EndpointUpdateResponseMsg, error) {
	out := new(EndpointUpdateResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error) {
	out := new(EndpointDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error) {
	out := new(EndpointGetResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterCreate(ctx context.Context, in *FilterRequestMsg, opts ...grpc.CallOption) (*FilterResponseMsg, error) {
	out := new(FilterResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterDelete(ctx context.Context, in *FilterDeleteRequestMsg, opts ...grpc.CallOption) (*FilterDeleteResponseMsg, error) {
	out := new(FilterDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterGet(ctx context.Context, in *FilterGetRequestMsg, opts ...grpc.CallOption) (*FilterGetResponseMsg, error) {
	out := new(FilterGetResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Endpoint service

type EndpointServer interface {
	EndpointCreate(context.Context, *EndpointRequestMsg) (*EndpointResponseMsg, error)
	EndpointUpdate(context.Context, *EndpointUpdateRequestMsg) (*EndpointUpdateResponseMsg, error)
	EndpointDelete(context.Context, *EndpointDeleteRequestMsg) (*EndpointDeleteResponseMsg, error)
	EndpointGet(context.Context, *EndpointGetRequestMsg) (*EndpointGetResponseMsg, error)
	// Filter
	FilterCreate(context.Context, *FilterRequestMsg) (*FilterResponseMsg, error)
	// rpc FilterUpdate (FilterRequestMsg) returns (FilterResponseMsg) {}
	FilterDelete(context.Context, *FilterDeleteRequestMsg) (*FilterDeleteResponseMsg, error)
	FilterGet(context.Context, *FilterGetRequestMsg) (*FilterGetResponseMsg, error)
}

func RegisterEndpointServer(s *grpc.Server, srv EndpointServer) {
	s.RegisterService(&_Endpoint_serviceDesc, srv)
}

func _Endpoint_EndpointCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointCreate(ctx, req.(*EndpointRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointUpdateRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointUpdate(ctx, req.(*EndpointUpdateRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointDelete(ctx, req.(*EndpointDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointGet(ctx, req.(*EndpointGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterCreate(ctx, req.(*FilterRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterDelete(ctx, req.(*FilterDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterGet(ctx, req.(*FilterGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Endpoint_serviceDesc = grpc.ServiceDesc{
	ServiceName: "endpoint.Endpoint",
	HandlerType: (*EndpointServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EndpointCreate",
			Handler:    _Endpoint_EndpointCreate_Handler,
		},
		{
			MethodName: "EndpointUpdate",
			Handler:    _Endpoint_EndpointUpdate_Handler,
		},
		{
			MethodName: "EndpointDelete",
			Handler:    _Endpoint_EndpointDelete_Handler,
		},
		{
			MethodName: "EndpointGet",
			Handler:    _Endpoint_EndpointGet_Handler,
		},
		{
			MethodName: "FilterCreate",
			Handler:    _Endpoint_FilterCreate_Handler,
		},
		{
			MethodName: "FilterDelete",
			Handler:    _Endpoint_FilterDelete_Handler,
		},
		{
			MethodName: "FilterGet",
			Handler:    _Endpoint_FilterGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "endpoint.proto",
}

func (m *EndpointAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n1, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UsegVlan != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.UsegVlan))
	}
	if len(m.IpAddress) > 0 {
		for _, msg := range m.IpAddress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SgKeyHandle) > 0 {
		for _, msg := range m.SgKeyHandle {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OldHomingHostIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.OldHomingHostIp.Size()))
		n2, err := m.OldHomingHostIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.VmotionState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VmotionState))
	}
	return i, nil
}

func (m *EndpointSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n4, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n5, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.EndpointAttrs != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointAttrs.Size()))
		n6, err := m.EndpointAttrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *EndpointRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointIpAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointIpAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.IpAddress.Size()))
		n7, err := m.IpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.LearnSourceDhcp {
		dAtA[i] = 0x10
		i++
		if m.LearnSourceDhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceArp {
		dAtA[i] = 0x18
		i++
		if m.LearnSourceArp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceRarp {
		dAtA[i] = 0x20
		i++
		if m.LearnSourceRarp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceConfig {
		dAtA[i] = 0x28
		i++
		if m.LearnSourceConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnStatus != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.LearnStatus.Size()))
		n8, err := m.LearnStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.IpsgTblIdx != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.IpsgTblIdx))
	}
	return i, nil
}

func (m *EndpointStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegMacTblIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.RegMacTblIdx))
	}
	if len(m.RwTblIdx) > 0 {
		dAtA10 := make([]byte, len(m.RwTblIdx)*10)
		var j9 int
		for _, num := range m.RwTblIdx {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *EndpointStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EndpointStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.EnicPinnedUplinkIfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EnicPinnedUplinkIfKeyHandle.Size()))
		n13, err := m.EnicPinnedUplinkIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.IpAddress) > 0 {
		for _, msg := range m.IpAddress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsEndpointLocal {
		dAtA[i] = 0x28
		i++
		if m.IsEndpointLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceConfig {
		dAtA[i] = 0x30
		i++
		if m.LearnSourceConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EpPdStatus != nil {
		nn14, err := m.EpPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *EndpointStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EpdStatus.Size()))
		n15, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *EndpointStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.CpdStatus.Size()))
		n16, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *EndpointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.EndpointStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointStatus.Size()))
		n17, err := m.EndpointStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *EndpointResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n18, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n19, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.EndpointAttrs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointAttrs.Size()))
		n20, err := m.EndpointAttrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *EndpointUpdateRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointUpdateResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n21, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n22, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.L2SegmentKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.L2SegmentKeyHandle.Size()))
		n23, err := m.L2SegmentKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *EndpointDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeleteBy != nil {
		nn24, err := m.DeleteBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n25, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *EndpointDeleteRequest_KeyOrHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n26, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *EndpointDeleteRequest_Filter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Filter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Filter.Size()))
		n27, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *EndpointDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EndpointDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n29, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *EndpointGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetByInterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetByInterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n30, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n31, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *EndpointGetByInterfaceRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetByInterfaceRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetAllRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetAllRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EndpointStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpLearnStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EpLearnStats.Size()))
		n32, err := m.EpLearnStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *EndpointGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Spec.Size()))
		n33, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Status.Size()))
		n34, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Stats.Size()))
		n35, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *EndpointGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MigrationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Spec.Size()))
		n36, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.MigrationState != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.MigrationState))
	}
	return i, nil
}

func (m *FilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n37, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *FilterRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FilterHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.FilterHandle))
		i += 8
	}
	return i, nil
}

func (m *FilterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.FilterStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.FilterStatus.Size()))
		n38, err := m.FilterStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *FilterResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *FilterDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *FilterDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n40, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *FilterGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Spec.Size()))
		n41, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Status.Size()))
		n42, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *FilterGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintEndpoint(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EndpointAttributes) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.UsegVlan != 0 {
		n += 1 + sovEndpoint(uint64(m.UsegVlan))
	}
	if len(m.IpAddress) > 0 {
		for _, e := range m.IpAddress {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if len(m.SgKeyHandle) > 0 {
		for _, e := range m.SgKeyHandle {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if m.OldHomingHostIp != nil {
		l = m.OldHomingHostIp.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VmotionState != 0 {
		n += 1 + sovEndpoint(uint64(m.VmotionState))
	}
	return n
}

func (m *EndpointSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EndpointAttrs != nil {
		l = m.EndpointAttrs.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointIpAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.LearnSourceDhcp {
		n += 2
	}
	if m.LearnSourceArp {
		n += 2
	}
	if m.LearnSourceRarp {
		n += 2
	}
	if m.LearnSourceConfig {
		n += 2
	}
	if m.LearnStatus != nil {
		l = m.LearnStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.IpsgTblIdx != 0 {
		n += 1 + sovEndpoint(uint64(m.IpsgTblIdx))
	}
	return n
}

func (m *EndpointStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.RegMacTblIdx != 0 {
		n += 1 + sovEndpoint(uint64(m.RegMacTblIdx))
	}
	if len(m.RwTblIdx) > 0 {
		l = 0
		for _, e := range m.RwTblIdx {
			l += sovEndpoint(uint64(e))
		}
		n += 1 + sovEndpoint(uint64(l)) + l
	}
	return n
}

func (m *EndpointStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EndpointStatus) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EnicPinnedUplinkIfKeyHandle != nil {
		l = m.EnicPinnedUplinkIfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if len(m.IpAddress) > 0 {
		for _, e := range m.IpAddress {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if m.IsEndpointLocal {
		n += 2
	}
	if m.LearnSourceConfig {
		n += 2
	}
	if m.EpPdStatus != nil {
		n += m.EpPdStatus.Size()
	}
	return n
}

func (m *EndpointStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.EndpointStatus != nil {
		l = m.EndpointStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointUpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EndpointAttrs != nil {
		l = m.EndpointAttrs.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointUpdateRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointUpdateResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointFilter) Size() (n int) {
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.L2SegmentKeyHandle != nil {
		l = m.L2SegmentKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.DeleteBy != nil {
		n += m.DeleteBy.Size()
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointDeleteRequest_KeyOrHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointDeleteRequest_Filter) Size() (n int) {
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	return n
}

func (m *EndpointDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetByInterfaceRequest) Size() (n int) {
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetByInterfaceRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetAllRequestMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EndpointStats) Size() (n int) {
	var l int
	_ = l
	if m.EpLearnStats != nil {
		l = m.EpLearnStats.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *MigrationResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.MigrationState != 0 {
		n += 1 + sovEndpoint(uint64(m.MigrationState))
	}
	return n
}

func (m *FilterSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterStatus) Size() (n int) {
	var l int
	_ = l
	if m.FilterHandle != 0 {
		n += 9
	}
	return n
}

func (m *FilterResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.FilterStatus != nil {
		l = m.FilterStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	return n
}

func (m *FilterDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func sovEndpoint(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEndpoint(x uint64) (n int) {
	return sovEndpoint(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EndpointAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsegVlan", wireType)
			}
			m.UsegVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsegVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, &IPAddress{})
			if err := m.IpAddress[len(m.IpAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SgKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SgKeyHandle = append(m.SgKeyHandle, &SecurityGroupKeyHandle{})
			if err := m.SgKeyHandle[len(m.SgKeyHandle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldHomingHostIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldHomingHostIp == nil {
				m.OldHomingHostIp = &IPAddress{}
			}
			if err := m.OldHomingHostIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmotionState", wireType)
			}
			m.VmotionState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmotionState |= (MigrationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointAttrs == nil {
				m.EndpointAttrs = &EndpointAttributes{}
			}
			if err := m.EndpointAttrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointIpAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointIpAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointIpAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpAddress == nil {
				m.IpAddress = &IPAddress{}
			}
			if err := m.IpAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceDhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceDhcp = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceArp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceArp = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceRarp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceRarp = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceConfig = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnStatus == nil {
				m.LearnStatus = &EplearnStatus{}
			}
			if err := m.LearnStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsgTblIdx", wireType)
			}
			m.IpsgTblIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpsgTblIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegMacTblIdx", wireType)
			}
			m.RegMacTblIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegMacTblIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RwTblIdx = append(m.RwTblIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEndpoint
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEndpoint
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RwTblIdx = append(m.RwTblIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RwTblIdx", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnicPinnedUplinkIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnicPinnedUplinkIfKeyHandle == nil {
				m.EnicPinnedUplinkIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.EnicPinnedUplinkIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, &EndpointIpAddress{})
			if err := m.IpAddress[len(m.IpAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEndpointLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEndpointLocal = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceConfig = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EpPdStatus = &EndpointStatus_EpdStatus{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EpPdStatus = &EndpointStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointStatus == nil {
				m.EndpointStatus = &EndpointStatus{}
			}
			if err := m.EndpointStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointAttrs == nil {
				m.EndpointAttrs = &EndpointAttributes{}
			}
			if err := m.EndpointAttrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointUpdateRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegmentKeyHandle == nil {
				m.L2SegmentKeyHandle = &L2SegmentKeyHandle{}
			}
			if err := m.L2SegmentKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeleteBy = &EndpointDeleteRequest_KeyOrHandle{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeleteBy = &EndpointDeleteRequest_Filter{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetByInterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetByInterfaceRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointGetByInterfaceRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetAllRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetAllRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetAllRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpLearnStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpLearnStats == nil {
				m.EpLearnStats = &EplearnStats{}
			}
			if err := m.EpLearnStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EndpointSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EndpointStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &EndpointStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EndpointSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationState", wireType)
			}
			m.MigrationState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationState |= (MigrationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterHandle", wireType)
			}
			m.FilterHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FilterStatus == nil {
				m.FilterStatus = &FilterStatus{}
			}
			if err := m.FilterStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &FilterSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FilterStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEndpoint(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEndpoint
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEndpoint(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEndpoint = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEndpoint   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("endpoint.proto", fileDescriptorEndpoint) }

var fileDescriptorEndpoint = []byte{
	// 1711 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4b, 0x6f, 0xdb, 0xca,
	0x15, 0x36, 0x25, 0xc5, 0x96, 0x8f, 0x1e, 0x96, 0xc7, 0x8e, 0xa3, 0xca, 0xb1, 0xad, 0x32, 0x68,
	0x6b, 0x04, 0xa8, 0x1a, 0x38, 0x41, 0x83, 0x38, 0xc9, 0x42, 0x92, 0x5f, 0x42, 0x6c, 0x2b, 0xa5,
	0xe2, 0x20, 0x6d, 0x80, 0xb0, 0xb4, 0x38, 0x96, 0x58, 0xd3, 0x24, 0x4b, 0x52, 0x4e, 0xb4, 0x2b,
	0xba, 0x2c, 0xba, 0x6c, 0x91, 0x45, 0xdb, 0x75, 0x7f, 0x41, 0x7f, 0x40, 0x77, 0x5d, 0x16, 0xe8,
	0xaa, 0x9b, 0xa0, 0xc8, 0xb2, 0xc0, 0xc5, 0x05, 0xf2, 0x0b, 0x2e, 0x66, 0x86, 0xef, 0x87, 0xe2,
	0x7b, 0xa3, 0xe0, 0x66, 0x65, 0xcd, 0xcc, 0x99, 0x8f, 0x67, 0xce, 0xf9, 0xce, 0x77, 0x66, 0x60,
	0x28, 0x63, 0x4d, 0x36, 0x74, 0x45, 0xb3, 0x1b, 0x86, 0xa9, 0xdb, 0x3a, 0xca, 0xbb, 0xe3, 0x5a,
	0xc1, 0x1e, 0x1b, 0xd8, 0x62, 0xd3, 0xb5, 0xfc, 0xf9, 0xd0, 0xf9, 0x55, 0xc2, 0x86, 0x8a, 0x25,
	0x53, 0x73, 0x86, 0x45, 0x19, 0xab, 0xc6, 0x50, 0x61, 0x23, 0xfe, 0x0f, 0x59, 0x40, 0xbb, 0x0e,
	0x40, 0xd3, 0xb6, 0x4d, 0xe5, 0x74, 0x64, 0x63, 0x0b, 0xbd, 0x80, 0x65, 0x45, 0xb3, 0xb1, 0x79,
	0x26, 0xf5, 0xb1, 0x78, 0x8e, 0xc7, 0xe2, 0x50, 0xd2, 0x64, 0x15, 0x57, 0xb9, 0x3a, 0xb7, 0x59,
	0xd8, 0x5a, 0x69, 0x9c, 0x0f, 0x1b, 0x1d, 0x77, 0xfd, 0x09, 0x1e, 0x1f, 0xd0, 0xd5, 0x56, 0xf9,
	0xc3, 0xbb, 0x0d, 0xb8, 0xc4, 0x9a, 0xd2, 0xc7, 0xdb, 0x26, 0x3e, 0x13, 0x90, 0x12, 0xb3, 0x41,
	0xab, 0x30, 0x3f, 0xb2, 0xf0, 0x40, 0xbc, 0x54, 0x25, 0xad, 0x9a, 0xa9, 0x73, 0x9b, 0x25, 0x21,
	0x4f, 0x26, 0x9e, 0xab, 0x92, 0x86, 0x7e, 0x06, 0xa0, 0x18, 0xa2, 0x24, 0xcb, 0x26, 0xb6, 0xac,
	0x6a, 0xb6, 0x9e, 0xdd, 0x2c, 0x6c, 0x55, 0x1a, 0xec, 0x58, 0x9d, 0xa7, 0x4d, 0x36, 0x2f, 0xcc,
	0x2b, 0x86, 0xf3, 0x13, 0x1d, 0x43, 0xc9, 0x1a, 0x04, 0x1d, 0xcc, 0xd1, 0x3d, 0x35, 0xe2, 0x60,
	0x0f, 0xf7, 0x47, 0xa6, 0x62, 0x8f, 0xf7, 0x4d, 0x7d, 0x64, 0xa4, 0x3b, 0x59, 0xb0, 0x06, 0xbe,
	0x77, 0x8f, 0x01, 0xe9, 0xaa, 0x2c, 0x0e, 0xf5, 0x0b, 0x45, 0x1b, 0x88, 0x43, 0xdd, 0xb2, 0x45,
	0xc5, 0xa8, 0x5e, 0xa3, 0xa7, 0x8e, 0x3b, 0xb2, 0xa0, 0xab, 0xf2, 0x01, 0x35, 0x3d, 0xd0, 0x2d,
	0xbb, 0x63, 0xa0, 0xc7, 0x50, 0xba, 0xbc, 0xd0, 0x6d, 0x45, 0xd7, 0x44, 0xcb, 0x96, 0x6c, 0x5c,
	0x9d, 0xad, 0x73, 0x9b, 0xe5, 0xad, 0x6a, 0xc3, 0xcb, 0xd9, 0x91, 0x32, 0x30, 0x25, 0x62, 0xd0,
	0x23, 0xeb, 0x42, 0xd1, 0x31, 0xa7, 0x23, 0xfe, 0x4f, 0x19, 0x28, 0xba, 0xc9, 0xe8, 0x19, 0xb8,
	0x8f, 0x7e, 0x0c, 0xb9, 0x23, 0x6c, 0x4b, 0x4e, 0xd8, 0x51, 0xc3, 0x49, 0x5d, 0xf7, 0xf4, 0x37,
	0xb8, 0x6f, 0x93, 0x15, 0x81, 0xae, 0xa3, 0x0e, 0x94, 0x48, 0x0c, 0x74, 0xd3, 0x0d, 0x43, 0x86,
	0x6e, 0xb8, 0x4e, 0xc2, 0xe0, 0x02, 0x26, 0x47, 0xe0, 0x1c, 0x8f, 0x85, 0xc2, 0x39, 0x1e, 0x77,
	0x4d, 0x27, 0x02, 0x7b, 0x50, 0xbe, 0x34, 0xcf, 0x82, 0x21, 0xcd, 0x3a, 0xa7, 0x3f, 0x1f, 0x36,
	0x9e, 0x9b, 0x67, 0xe9, 0x81, 0x2c, 0x5e, 0x06, 0x56, 0x51, 0xdb, 0x27, 0xaa, 0x28, 0xd9, 0xb6,
	0x69, 0x55, 0x73, 0x14, 0xe7, 0xa6, 0x1f, 0x8b, 0x38, 0xef, 0x84, 0x12, 0x0e, 0xcc, 0x59, 0xdb,
	0xb9, 0xdf, 0xbd, 0xe5, 0x39, 0x7e, 0xcf, 0xa7, 0xa8, 0x80, 0x7f, 0x3b, 0xc2, 0x96, 0x7d, 0x64,
	0x0d, 0xd0, 0x1d, 0x98, 0x33, 0xd9, 0xa8, 0xca, 0xd1, 0xa4, 0xaf, 0xc4, 0x91, 0x49, 0x10, 0x05,
	0xd7, 0x8c, 0xff, 0x4f, 0x06, 0x16, 0xdd, 0x95, 0x8e, 0x47, 0xa1, 0x30, 0xe7, 0xb8, 0x94, 0x54,
	0x07, 0x38, 0x77, 0x1b, 0x16, 0x69, 0x3d, 0x89, 0x96, 0x3e, 0x32, 0xfb, 0x58, 0x94, 0x87, 0x7d,
	0x83, 0x06, 0x3c, 0x2f, 0x2c, 0xd0, 0x85, 0x1e, 0x9d, 0xdf, 0x19, 0xf6, 0x0d, 0xb4, 0x09, 0x95,
	0x90, 0xad, 0x64, 0x1a, 0x34, 0x9e, 0x79, 0xa1, 0x1c, 0x30, 0x6d, 0x9a, 0x46, 0x0c, 0xd5, 0x24,
	0xa6, 0xb9, 0x18, 0xaa, 0x20, 0x99, 0x06, 0x6a, 0xc0, 0x52, 0xc8, 0xb6, 0xaf, 0x6b, 0x67, 0xca,
	0x80, 0xd2, 0x34, 0x2f, 0x2c, 0x06, 0xac, 0xdb, 0x74, 0x01, 0x3d, 0x80, 0xa2, 0x63, 0x6f, 0x4b,
	0xf6, 0xc8, 0xa2, 0xac, 0xa4, 0xf1, 0x72, 0x84, 0x61, 0x97, 0xfd, 0xed, 0xd1, 0x55, 0xa1, 0x10,
	0x18, 0xa0, 0x3a, 0x14, 0x15, 0xc3, 0x1a, 0x88, 0xf6, 0xa9, 0x2a, 0x2a, 0xf2, 0x9b, 0xea, 0x1c,
	0xad, 0x58, 0x20, 0x73, 0xcf, 0x4e, 0xd5, 0x8e, 0xfc, 0x86, 0x7f, 0xe1, 0x07, 0x95, 0xed, 0xd9,
	0x35, 0x64, 0xf4, 0x23, 0x58, 0x30, 0xf1, 0x40, 0xbc, 0x90, 0xfa, 0xde, 0x4e, 0x8e, 0xee, 0x2c,
	0x9a, 0x78, 0x70, 0x24, 0xf5, 0xd9, 0x5e, 0x74, 0x13, 0xc0, 0x7c, 0xed, 0x59, 0x64, 0xea, 0x59,
	0xa2, 0x06, 0xe6, 0x6b, 0x07, 0x79, 0x29, 0x8a, 0xdc, 0x36, 0x64, 0xfe, 0xaf, 0x39, 0x28, 0x87,
	0x67, 0xbf, 0x8f, 0x2a, 0xb9, 0x80, 0x3a, 0x59, 0x11, 0x0d, 0x45, 0xd3, 0xb0, 0x2c, 0x8e, 0x0c,
	0x55, 0xd1, 0xce, 0x45, 0x25, 0xa1, 0x6e, 0xae, 0xaa, 0x95, 0xab, 0xe4, 0xe7, 0x53, 0x0a, 0x77,
	0x42, 0xd1, 0x3a, 0x81, 0x62, 0xda, 0x0e, 0x71, 0x94, 0x69, 0xdc, 0x6a, 0x9c, 0xee, 0x1e, 0xa9,
	0x23, 0x74, 0x55, 0x2c, 0xd1, 0xab, 0x45, 0x55, 0xef, 0x4b, 0xaa, 0x43, 0x95, 0x05, 0xc5, 0x72,
	0xb7, 0x1e, 0x92, 0xe9, 0x34, 0x62, 0xcd, 0xa6, 0x11, 0xeb, 0x11, 0x00, 0x36, 0x64, 0x97, 0x56,
	0x73, 0xf4, 0xc0, 0x09, 0x7e, 0x79, 0xbc, 0x38, 0x98, 0x11, 0xe6, 0xb1, 0x21, 0x3b, 0x79, 0x7b,
	0x04, 0xd0, 0xf7, 0x77, 0xe7, 0x27, 0xef, 0x6e, 0xb3, 0xdd, 0x7d, 0x77, 0x37, 0xd3, 0x86, 0x56,
	0x19, 0x8a, 0xd8, 0x10, 0x3d, 0x14, 0xfe, 0x6f, 0x1c, 0x54, 0x7c, 0xb1, 0xb0, 0x0c, 0x5d, 0xb3,
	0x88, 0xa6, 0x81, 0x64, 0x28, 0xee, 0x87, 0x38, 0xaa, 0xc9, 0x6e, 0x89, 0x37, 0x0d, 0x85, 0x01,
	0xb6, 0xae, 0x7f, 0x78, 0xb7, 0xb1, 0xe8, 0x64, 0xc4, 0x37, 0x17, 0xe6, 0x25, 0xd7, 0x02, 0x35,
	0x61, 0xc1, 0x8b, 0xa3, 0x03, 0xc6, 0x28, 0x54, 0x4d, 0xf3, 0x5a, 0xf0, 0x44, 0x90, 0x8d, 0xf9,
	0x23, 0x58, 0x8a, 0xba, 0x47, 0xc4, 0xec, 0xe7, 0x90, 0x37, 0x9d, 0xa1, 0xa3, 0x66, 0xb5, 0x38,
	0xa4, 0xbb, 0x41, 0xf0, 0x6c, 0xf9, 0xaf, 0x39, 0xb8, 0xee, 0x2e, 0x9f, 0x18, 0x32, 0x69, 0x29,
	0x4c, 0xec, 0xe2, 0x64, 0xe7, 0xa6, 0xd8, 0x12, 0x32, 0x53, 0x6a, 0x09, 0xd9, 0x6f, 0xdd, 0x12,
	0xf8, 0x13, 0xa8, 0x26, 0x1e, 0x98, 0x44, 0xf1, 0x41, 0xb4, 0x25, 0x6c, 0xc4, 0x91, 0x43, 0x9b,
	0xfc, 0xde, 0xd0, 0x83, 0x1f, 0x44, 0x2d, 0x3e, 0x3d, 0x3b, 0x7f, 0xcc, 0xf8, 0x5a, 0xb5, 0xa7,
	0xa8, 0x36, 0x36, 0x13, 0x62, 0xc9, 0x7d, 0xa7, 0x58, 0xa6, 0x5d, 0xd0, 0x32, 0x9f, 0x7c, 0x41,
	0x7b, 0x01, 0xcb, 0xea, 0x56, 0x0f, 0x0f, 0x2e, 0xb0, 0x66, 0xa7, 0xc8, 0xd9, 0xa1, 0xbb, 0x3e,
	0x01, 0x59, 0x8d, 0xd9, 0xf0, 0x5f, 0x05, 0xc8, 0xba, 0x83, 0x55, 0xec, 0x93, 0xf5, 0xc9, 0xa7,
	0x90, 0xf5, 0x60, 0x26, 0x4c, 0xd7, 0x2d, 0x98, 0x3d, 0xa3, 0xc1, 0x4e, 0x2f, 0x4e, 0x96, 0x8c,
	0x83, 0x19, 0xc1, 0xb1, 0x9c, 0xd6, 0xad, 0xa7, 0x55, 0x80, 0x79, 0x99, 0x9e, 0x4c, 0x3c, 0x1d,
	0x07, 0xa9, 0x1a, 0x3a, 0xee, 0x55, 0xa9, 0x1a, 0xda, 0xe4, 0x53, 0xf5, 0xd7, 0xb0, 0x12, 0xb5,
	0x98, 0xae, 0xce, 0xf1, 0xbf, 0xf4, 0x8b, 0x21, 0xfc, 0x05, 0xe2, 0xf9, 0xa3, 0x58, 0x31, 0xd4,
	0xd3, 0x5d, 0x8f, 0x95, 0xc4, 0xdf, 0x39, 0xff, 0x32, 0xb7, 0x8f, 0xed, 0x2f, 0x57, 0xad, 0xf8,
	0xae, 0x4f, 0x56, 0xdf, 0x51, 0xa6, 0x06, 0x91, 0xd4, 0x25, 0xe8, 0x97, 0xbf, 0xc3, 0xcf, 0xdb,
	0x3f, 0x39, 0x58, 0x0b, 0xac, 0xb7, 0xc6, 0x5e, 0x81, 0xba, 0x51, 0xf8, 0xe2, 0xc5, 0x81, 0xc7,
	0x50, 0x9f, 0x78, 0x04, 0x12, 0x9f, 0x66, 0x34, 0x3e, 0x3f, 0x49, 0x8c, 0x4f, 0x7c, 0xb3, 0x1f,
	0xaa, 0x9a, 0x5f, 0x39, 0xfb, 0xd8, 0x6e, 0xaa, 0xaa, 0x0f, 0xcf, 0x1f, 0x42, 0x29, 0xd8, 0x63,
	0x2d, 0xf4, 0x10, 0xca, 0xd8, 0x10, 0xfd, 0x0b, 0xae, 0xe5, 0x91, 0x27, 0xe1, 0x7e, 0x6b, 0x09,
	0x45, 0x6c, 0x1c, 0x7a, 0x23, 0xfe, 0xff, 0x9c, 0xdf, 0x90, 0x69, 0xd2, 0xa6, 0x7c, 0x65, 0xb8,
	0x0d, 0x39, 0xcb, 0xc0, 0x7d, 0x2f, 0xf4, 0xc9, 0x4f, 0x14, 0x6a, 0x83, 0xee, 0xc0, 0xac, 0xf3,
	0xbd, 0xec, 0x47, 0x6e, 0x15, 0x8e, 0x1d, 0xfa, 0x29, 0x5c, 0x63, 0x27, 0x66, 0x6f, 0xab, 0x1b,
	0xc9, 0x1b, 0x2c, 0x81, 0x59, 0xf1, 0x7f, 0xe1, 0x7c, 0xe9, 0x08, 0x1c, 0x96, 0x24, 0x6d, 0x5a,
	0xe7, 0x7d, 0x10, 0x50, 0x87, 0x0c, 0xcd, 0xfe, 0x5a, 0x4a, 0x75, 0xc4, 0xa4, 0xe1, 0xf7, 0x1c,
	0x2c, 0x7a, 0xcf, 0x63, 0x2f, 0x11, 0x6e, 0x00, 0xb9, 0x2b, 0x04, 0xb0, 0x09, 0x0b, 0x17, 0x2e,
	0x80, 0xf3, 0x00, 0xcf, 0x7c, 0xe4, 0x01, 0x5e, 0xbe, 0x08, 0x8d, 0xf9, 0x13, 0x00, 0xd6, 0x1c,
	0xe8, 0xfb, 0x7b, 0x3f, 0x59, 0x96, 0x96, 0x48, 0x05, 0x31, 0xb3, 0xab, 0x89, 0x12, 0xdf, 0x82,
	0x0a, 0xb3, 0x0f, 0xd4, 0x49, 0x23, 0x5a, 0x27, 0xcb, 0xbe, 0x97, 0xbe, 0x0f, 0x7e, 0x51, 0xdc,
	0x85, 0xa2, 0x33, 0xcd, 0x42, 0x7d, 0x0b, 0x4a, 0xac, 0x7b, 0x05, 0x9d, 0x9b, 0x15, 0x8a, 0x6c,
	0xd2, 0xf9, 0xf0, 0x9f, 0x39, 0x28, 0xbb, 0x5f, 0x9e, 0x32, 0xb5, 0x1f, 0x7a, 0xdf, 0x0f, 0xdd,
	0x85, 0x57, 0x62, 0xa7, 0x60, 0x3b, 0x1d, 0xbf, 0x9c, 0x16, 0xd3, 0x81, 0xc5, 0xb0, 0x5b, 0x24,
	0x22, 0xf7, 0x62, 0xad, 0xa5, 0x1a, 0x05, 0x4b, 0xe0, 0xcd, 0x2b, 0x58, 0x62, 0x6b, 0xe1, 0x3b,
	0xc5, 0xd4, 0x72, 0xf7, 0x0b, 0x58, 0x49, 0xc0, 0x27, 0xfe, 0xde, 0x8f, 0x66, 0x70, 0x2d, 0xea,
	0x6e, 0x4a, 0x0b, 0x7f, 0x05, 0xcb, 0xe1, 0xf5, 0x29, 0x37, 0xf0, 0x13, 0xb8, 0x91, 0x84, 0x4f,
	0x7c, 0xde, 0x8e, 0xc5, 0x78, 0x3d, 0xcd, 0xe9, 0x58, 0xa4, 0x5f, 0xba, 0x2c, 0x0e, 0x74, 0xee,
	0xa9, 0x85, 0xf9, 0x89, 0x9b, 0xc6, 0x70, 0xb7, 0xbd, 0x17, 0x8d, 0x71, 0x2d, 0xea, 0x6e, 0x52,
	0xaf, 0xfd, 0x07, 0xe7, 0xf2, 0xeb, 0x73, 0x88, 0xfa, 0x66, 0x48, 0xd4, 0x93, 0xcb, 0x96, 0x29,
	0x52, 0x23, 0x22, 0xe9, 0x69, 0xc5, 0xe1, 0x58, 0xf1, 0x6f, 0x39, 0x97, 0x19, 0x9f, 0x49, 0x9f,
	0xef, 0xc7, 0xf4, 0x79, 0x35, 0x31, 0x9e, 0xd1, 0xdc, 0xdf, 0x7e, 0x09, 0xe5, 0xb0, 0x74, 0xa2,
	0x3c, 0xe4, 0x8e, 0xbb, 0xc7, 0xbb, 0x95, 0x19, 0xb4, 0x00, 0x85, 0xce, 0xb1, 0xf8, 0x54, 0xe8,
	0xee, 0x0b, 0xbb, 0xbd, 0x5e, 0x85, 0x43, 0x05, 0x98, 0xeb, 0x9d, 0xb4, 0xdb, 0x64, 0x90, 0x41,
	0x00, 0xb3, 0x7b, 0xcd, 0xce, 0xe1, 0xee, 0x4e, 0x25, 0x4b, 0x16, 0x9a, 0xad, 0xae, 0xf0, 0x6c,
	0x77, 0xa7, 0x92, 0x23, 0x00, 0xed, 0xee, 0xe1, 0x4e, 0xe5, 0xda, 0xd6, 0x7f, 0x73, 0x90, 0x77,
	0xf5, 0x1c, 0x75, 0xfd, 0x47, 0x53, 0xdb, 0xc4, 0xe4, 0x4b, 0x37, 0x93, 0x5e, 0x5b, 0x2e, 0x43,
	0x6a, 0x6b, 0xe9, 0x6f, 0x31, 0x72, 0x5f, 0x98, 0x41, 0x2f, 0x7d, 0x40, 0xf6, 0xb6, 0x43, 0xfc,
	0x47, 0xde, 0x85, 0x04, 0xf6, 0x56, 0xba, 0x4d, 0x0a, 0x38, 0xab, 0x9b, 0x24, 0xf0, 0xa8, 0x72,
	0x24, 0x81, 0xc7, 0x4a, 0x95, 0x9f, 0x41, 0x02, 0x14, 0x02, 0x3d, 0x13, 0x6d, 0x4c, 0xba, 0x68,
	0x12, 0xd8, 0xfa, 0xc4, 0x5e, 0xcb, 0x30, 0x3b, 0x6e, 0x1b, 0x71, 0x82, 0x5b, 0x8b, 0x4b, 0xac,
	0x87, 0xb7, 0x9a, 0x26, 0xbf, 0x0c, 0xea, 0xc4, 0x85, 0x72, 0x4e, 0x5e, 0x9f, 0x28, 0x7f, 0x04,
	0xf0, 0x87, 0x93, 0xb5, 0x86, 0xc1, 0x1e, 0xc2, 0xbc, 0xc7, 0x44, 0xb4, 0x96, 0x5e, 0xee, 0x04,
	0x70, 0x7d, 0x02, 0x7b, 0x29, 0x5a, 0x6b, 0xe5, 0x5f, 0xef, 0xd7, 0xb9, 0x7f, 0xbf, 0x5f, 0xe7,
	0xfe, 0xf7, 0x7e, 0x9d, 0xfb, 0x55, 0x7e, 0x28, 0xa9, 0xf4, 0x3f, 0x1f, 0xa7, 0xb3, 0xf4, 0xcf,
	0xdd, 0x6f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4c, 0xda, 0x88, 0x20, 0x50, 0x19, 0x00, 0x00,
}
