// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: l2segment.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// BroadcastFwdPolicy defines various forwarding options to deal with
// broadcast traffic
type BroadcastFwdPolicy int32

const (
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_NONE  BroadcastFwdPolicy = 0
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_DROP  BroadcastFwdPolicy = 1
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_FLOOD BroadcastFwdPolicy = 2
)

var BroadcastFwdPolicy_name = map[int32]string{
	0: "BROADCAST_FWD_POLICY_NONE",
	1: "BROADCAST_FWD_POLICY_DROP",
	2: "BROADCAST_FWD_POLICY_FLOOD",
}
var BroadcastFwdPolicy_value = map[string]int32{
	"BROADCAST_FWD_POLICY_NONE":  0,
	"BROADCAST_FWD_POLICY_DROP":  1,
	"BROADCAST_FWD_POLICY_FLOOD": 2,
}

func (x BroadcastFwdPolicy) String() string {
	return proto.EnumName(BroadcastFwdPolicy_name, int32(x))
}
func (BroadcastFwdPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{0} }

// MulticastFwdPolicy defines various forwarding options to deal with
// multicast traffic
type MulticastFwdPolicy int32

const (
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_NONE      MulticastFwdPolicy = 0
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_FLOOD     MulticastFwdPolicy = 1
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_REPLICATE MulticastFwdPolicy = 2
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_DROP      MulticastFwdPolicy = 3
)

var MulticastFwdPolicy_name = map[int32]string{
	0: "MULTICAST_FWD_POLICY_NONE",
	1: "MULTICAST_FWD_POLICY_FLOOD",
	2: "MULTICAST_FWD_POLICY_REPLICATE",
	3: "MULTICAST_FWD_POLICY_DROP",
}
var MulticastFwdPolicy_value = map[string]int32{
	"MULTICAST_FWD_POLICY_NONE":      0,
	"MULTICAST_FWD_POLICY_FLOOD":     1,
	"MULTICAST_FWD_POLICY_REPLICATE": 2,
	"MULTICAST_FWD_POLICY_DROP":      3,
}

func (x MulticastFwdPolicy) String() string {
	return proto.EnumName(MulticastFwdPolicy_name, int32(x))
}
func (MulticastFwdPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{1} }

// L2SegmentSpec message is used to do add/mod of vlan
type L2SegmentSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L2 segment's unique identifier
	KeyOrHandle          *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	NetworkKeyHandle     []*NetworkKeyHandle `protobuf:"bytes,3,rep,name=network_key_handle,json=networkKeyHandle" json:"network_key_handle,omitempty" venice:ref`
	VrfKeyHandle         *VrfKeyHandle       `protobuf:"bytes,4,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:immutable,venice:ref`
	SegmentType          L2SegmentType       `protobuf:"varint,5,opt,name=segment_type,json=segmentType,proto3,enum=types.L2SegmentType" json:"segment_type,omitempty" venice:immutable`
	McastFwdPolicy       MulticastFwdPolicy  `protobuf:"varint,6,opt,name=mcast_fwd_policy,json=mcastFwdPolicy,proto3,enum=l2segment.MulticastFwdPolicy" json:"mcast_fwd_policy,omitempty"`
	BcastFwdPolicy       BroadcastFwdPolicy  `protobuf:"varint,7,opt,name=bcast_fwd_policy,json=bcastFwdPolicy,proto3,enum=l2segment.BroadcastFwdPolicy" json:"bcast_fwd_policy,omitempty"`
	WireEncap            *EncapInfo          `protobuf:"bytes,8,opt,name=wire_encap,json=wireEncap" json:"wire_encap,omitempty" venice:immutable`
	TunnelEncap          *EncapInfo          `protobuf:"bytes,9,opt,name=tunnel_encap,json=tunnelEncap" json:"tunnel_encap,omitempty" venice:immutable`
	Gipo                 *IPAddress          `protobuf:"bytes,10,opt,name=gipo" json:"gipo,omitempty" venice:immutable`
	EplearnCfg           *EplearnCfg         `protobuf:"bytes,11,opt,name=eplearn_cfg,json=eplearnCfg" json:"eplearn_cfg,omitempty"`
	PinnedUplinkIfHandle uint64              `protobuf:"fixed64,12,opt,name=pinned_uplink_if_handle,json=pinnedUplinkIfHandle,proto3" json:"pinned_uplink_if_handle,omitempty"`
}

func (m *L2SegmentSpec) Reset()                    { *m = L2SegmentSpec{} }
func (m *L2SegmentSpec) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentSpec) ProtoMessage()               {}
func (*L2SegmentSpec) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{0} }

func (m *L2SegmentSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentSpec) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentSpec) GetNetworkKeyHandle() []*NetworkKeyHandle {
	if m != nil {
		return m.NetworkKeyHandle
	}
	return nil
}

func (m *L2SegmentSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *L2SegmentSpec) GetSegmentType() L2SegmentType {
	if m != nil {
		return m.SegmentType
	}
	return L2SegmentType_L2_SEGMENT_TYPE_NONE
}

func (m *L2SegmentSpec) GetMcastFwdPolicy() MulticastFwdPolicy {
	if m != nil {
		return m.McastFwdPolicy
	}
	return MulticastFwdPolicy_MULTICAST_FWD_POLICY_NONE
}

func (m *L2SegmentSpec) GetBcastFwdPolicy() BroadcastFwdPolicy {
	if m != nil {
		return m.BcastFwdPolicy
	}
	return BroadcastFwdPolicy_BROADCAST_FWD_POLICY_NONE
}

func (m *L2SegmentSpec) GetWireEncap() *EncapInfo {
	if m != nil {
		return m.WireEncap
	}
	return nil
}

func (m *L2SegmentSpec) GetTunnelEncap() *EncapInfo {
	if m != nil {
		return m.TunnelEncap
	}
	return nil
}

func (m *L2SegmentSpec) GetGipo() *IPAddress {
	if m != nil {
		return m.Gipo
	}
	return nil
}

func (m *L2SegmentSpec) GetEplearnCfg() *EplearnCfg {
	if m != nil {
		return m.EplearnCfg
	}
	return nil
}

func (m *L2SegmentSpec) GetPinnedUplinkIfHandle() uint64 {
	if m != nil {
		return m.PinnedUplinkIfHandle
	}
	return 0
}

// L2SegmentRequestMsg is batched add or modify L2 segment request
type L2SegmentRequestMsg struct {
	Request []*L2SegmentSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentRequestMsg) Reset()                    { *m = L2SegmentRequestMsg{} }
func (m *L2SegmentRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentRequestMsg) ProtoMessage()               {}
func (*L2SegmentRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{1} }

func (m *L2SegmentRequestMsg) GetRequest() []*L2SegmentSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2segment oper state for enterprise pipeline
type L2SegmentStatusEpd struct {
	HwL2SegId      uint32 `protobuf:"varint,3,opt,name=hw_l2seg_id,json=hwL2segId,proto3" json:"hw_l2seg_id,omitempty"`
	L2SegLookupId  uint32 `protobuf:"varint,4,opt,name=l2seg_lookup_id,json=l2segLookupId,proto3" json:"l2seg_lookup_id,omitempty"`
	L2SegVlanIdCpu uint32 `protobuf:"varint,5,opt,name=l2seg_vlan_id_cpu,json=l2segVlanIdCpu,proto3" json:"l2seg_vlan_id_cpu,omitempty"`
	InpPropCpuIdx  uint32 `protobuf:"varint,6,opt,name=inp_prop_cpu_idx,json=inpPropCpuIdx,proto3" json:"inp_prop_cpu_idx,omitempty"`
	// for CPU TX packets with CPU injecting into a VRF.
	InpPropIdx []uint32 `protobuf:"varint,7,rep,packed,name=inp_prop_idx,json=inpPropIdx" json:"inp_prop_idx,omitempty"`
	// for .1q tagged packets
	InpPropIdxPrTag []uint32 `protobuf:"varint,8,rep,packed,name=inp_prop_idx_pr_tag,json=inpPropIdxPrTag" json:"inp_prop_idx_pr_tag,omitempty"`
}

func (m *L2SegmentStatusEpd) Reset()                    { *m = L2SegmentStatusEpd{} }
func (m *L2SegmentStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStatusEpd) ProtoMessage()               {}
func (*L2SegmentStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{2} }

func (m *L2SegmentStatusEpd) GetHwL2SegId() uint32 {
	if m != nil {
		return m.HwL2SegId
	}
	return 0
}

func (m *L2SegmentStatusEpd) GetL2SegLookupId() uint32 {
	if m != nil {
		return m.L2SegLookupId
	}
	return 0
}

func (m *L2SegmentStatusEpd) GetL2SegVlanIdCpu() uint32 {
	if m != nil {
		return m.L2SegVlanIdCpu
	}
	return 0
}

func (m *L2SegmentStatusEpd) GetInpPropCpuIdx() uint32 {
	if m != nil {
		return m.InpPropCpuIdx
	}
	return 0
}

func (m *L2SegmentStatusEpd) GetInpPropIdx() []uint32 {
	if m != nil {
		return m.InpPropIdx
	}
	return nil
}

func (m *L2SegmentStatusEpd) GetInpPropIdxPrTag() []uint32 {
	if m != nil {
		return m.InpPropIdxPrTag
	}
	return nil
}

// L2segment oper state for cloud pipeline
type L2SegmentStatusCpd struct {
}

func (m *L2SegmentStatusCpd) Reset()                    { *m = L2SegmentStatusCpd{} }
func (m *L2SegmentStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStatusCpd) ProtoMessage()               {}
func (*L2SegmentStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{3} }

// L2SegmentStatus represents the current status of the L2 segment
type L2SegmentStatus struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,1,opt,name=l2segment_handle,json=l2segmentHandle,proto3" json:"l2segment_handle,omitempty"`
	VrfId           uint32 `protobuf:"varint,2,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
	// TODO - add vNICs/uplinks this vlan is up on
	//
	// Types that are valid to be assigned to L2SegStatus:
	//	*L2SegmentStatus_EpdInfo
	//	*L2SegmentStatus_CpdInfo
	L2SegStatus isL2SegmentStatus_L2SegStatus `protobuf_oneof:"l2seg_status"`
}

func (m *L2SegmentStatus) Reset()                    { *m = L2SegmentStatus{} }
func (m *L2SegmentStatus) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStatus) ProtoMessage()               {}
func (*L2SegmentStatus) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{4} }

type isL2SegmentStatus_L2SegStatus interface {
	isL2SegmentStatus_L2SegStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type L2SegmentStatus_EpdInfo struct {
	EpdInfo *L2SegmentStatusEpd `protobuf:"bytes,3,opt,name=epd_info,json=epdInfo,oneof"`
}
type L2SegmentStatus_CpdInfo struct {
	CpdInfo *L2SegmentStatusCpd `protobuf:"bytes,4,opt,name=cpd_info,json=cpdInfo,oneof"`
}

func (*L2SegmentStatus_EpdInfo) isL2SegmentStatus_L2SegStatus() {}
func (*L2SegmentStatus_CpdInfo) isL2SegmentStatus_L2SegStatus() {}

func (m *L2SegmentStatus) GetL2SegStatus() isL2SegmentStatus_L2SegStatus {
	if m != nil {
		return m.L2SegStatus
	}
	return nil
}

func (m *L2SegmentStatus) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

func (m *L2SegmentStatus) GetVrfId() uint32 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

func (m *L2SegmentStatus) GetEpdInfo() *L2SegmentStatusEpd {
	if x, ok := m.GetL2SegStatus().(*L2SegmentStatus_EpdInfo); ok {
		return x.EpdInfo
	}
	return nil
}

func (m *L2SegmentStatus) GetCpdInfo() *L2SegmentStatusCpd {
	if x, ok := m.GetL2SegStatus().(*L2SegmentStatus_CpdInfo); ok {
		return x.CpdInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L2SegmentStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L2SegmentStatus_OneofMarshaler, _L2SegmentStatus_OneofUnmarshaler, _L2SegmentStatus_OneofSizer, []interface{}{
		(*L2SegmentStatus_EpdInfo)(nil),
		(*L2SegmentStatus_CpdInfo)(nil),
	}
}

func _L2SegmentStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L2SegmentStatus)
	// l2seg_status
	switch x := m.L2SegStatus.(type) {
	case *L2SegmentStatus_EpdInfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdInfo); err != nil {
			return err
		}
	case *L2SegmentStatus_CpdInfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("L2SegmentStatus.L2SegStatus has unexpected type %T", x)
	}
	return nil
}

func _L2SegmentStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L2SegmentStatus)
	switch tag {
	case 3: // l2seg_status.epd_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentStatusEpd)
		err := b.DecodeMessage(msg)
		m.L2SegStatus = &L2SegmentStatus_EpdInfo{msg}
		return true, err
	case 4: // l2seg_status.cpd_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentStatusCpd)
		err := b.DecodeMessage(msg)
		m.L2SegStatus = &L2SegmentStatus_CpdInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _L2SegmentStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L2SegmentStatus)
	// l2seg_status
	switch x := m.L2SegStatus.(type) {
	case *L2SegmentStatus_EpdInfo:
		s := proto.Size(x.EpdInfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *L2SegmentStatus_CpdInfo:
		s := proto.Size(x.CpdInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L2SegmentResponse is response to L2SegmentSpec
type L2SegmentResponse struct {
	ApiStatus       ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	L2SegmentStatus *L2SegmentStatus `protobuf:"bytes,2,opt,name=l2segment_status,json=l2segmentStatus" json:"l2segment_status,omitempty"`
}

func (m *L2SegmentResponse) Reset()                    { *m = L2SegmentResponse{} }
func (m *L2SegmentResponse) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentResponse) ProtoMessage()               {}
func (*L2SegmentResponse) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{5} }

func (m *L2SegmentResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L2SegmentResponse) GetL2SegmentStatus() *L2SegmentStatus {
	if m != nil {
		return m.L2SegmentStatus
	}
	return nil
}

// L2SegmentResponseMsg is batched response to L2SegmentRequestMsg
type L2SegmentResponseMsg struct {
	Response []*L2SegmentResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L2SegmentResponseMsg) Reset()                    { *m = L2SegmentResponseMsg{} }
func (m *L2SegmentResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentResponseMsg) ProtoMessage()               {}
func (*L2SegmentResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{6} }

func (m *L2SegmentResponseMsg) GetResponse() []*L2SegmentResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L2SegmentDeleteRequest is used to delete a L2 segment
type L2SegmentDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L2 segment's unique identifier
	KeyOrHandle  *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle       `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *L2SegmentDeleteRequest) Reset()                    { *m = L2SegmentDeleteRequest{} }
func (m *L2SegmentDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentDeleteRequest) ProtoMessage()               {}
func (*L2SegmentDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{7} }

func (m *L2SegmentDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentDeleteRequest) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentDeleteRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// L2SegmentDeleteRequestMsg is used to delete a batch of L2 segments
type L2SegmentDeleteRequestMsg struct {
	Request []*L2SegmentDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentDeleteRequestMsg) Reset()         { *m = L2SegmentDeleteRequestMsg{} }
func (m *L2SegmentDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentDeleteRequestMsg) ProtoMessage()    {}
func (*L2SegmentDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{8}
}

func (m *L2SegmentDeleteRequestMsg) GetRequest() []*L2SegmentDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2SegmentDeleteResponse is response to L2SegmentDeleteRequest
type L2SegmentDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *L2SegmentDeleteResponse) Reset()                    { *m = L2SegmentDeleteResponse{} }
func (m *L2SegmentDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentDeleteResponse) ProtoMessage()               {}
func (*L2SegmentDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{9} }

func (m *L2SegmentDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// L2SegmentDeleteResponseMsg is batched response to L2SegmentDeleteRequestMsg
type L2SegmentDeleteResponseMsg struct {
	Response []*L2SegmentDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L2SegmentDeleteResponseMsg) Reset()         { *m = L2SegmentDeleteResponseMsg{} }
func (m *L2SegmentDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentDeleteResponseMsg) ProtoMessage()    {}
func (*L2SegmentDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{10}
}

func (m *L2SegmentDeleteResponseMsg) GetResponse() []*L2SegmentDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L2SegmentGetRequest is used to get information about a L2 Segment
type L2SegmentGetRequest struct {
	Meta         *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle  *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle       `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *L2SegmentGetRequest) Reset()                    { *m = L2SegmentGetRequest{} }
func (m *L2SegmentGetRequest) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetRequest) ProtoMessage()               {}
func (*L2SegmentGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{11} }

func (m *L2SegmentGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentGetRequest) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentGetRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// L2SegmentGetRequestMsg is batched GET request for L2 segments
type L2SegmentGetRequestMsg struct {
	Request []*L2SegmentGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentGetRequestMsg) Reset()                    { *m = L2SegmentGetRequestMsg{} }
func (m *L2SegmentGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetRequestMsg) ProtoMessage()               {}
func (*L2SegmentGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{12} }

func (m *L2SegmentGetRequestMsg) GetRequest() []*L2SegmentGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2SegmentStats is the statistics object for each L2 segment
type L2SegmentStats struct {
	NumEndpoints uint32          `protobuf:"varint,1,opt,name=num_endpoints,json=numEndpoints,proto3" json:"num_endpoints,omitempty"`
	EplearnStats *L2EplearnStats `protobuf:"bytes,2,opt,name=eplearn_stats,json=eplearnStats" json:"eplearn_stats,omitempty"`
}

func (m *L2SegmentStats) Reset()                    { *m = L2SegmentStats{} }
func (m *L2SegmentStats) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStats) ProtoMessage()               {}
func (*L2SegmentStats) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{13} }

func (m *L2SegmentStats) GetNumEndpoints() uint32 {
	if m != nil {
		return m.NumEndpoints
	}
	return 0
}

func (m *L2SegmentStats) GetEplearnStats() *L2EplearnStats {
	if m != nil {
		return m.EplearnStats
	}
	return nil
}

// L2SegmentGetResponse captures all the information about a L2 segment
// only if api_status indicates success, other fields are valid
type L2SegmentGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *L2SegmentSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *L2SegmentStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *L2SegmentStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *L2SegmentGetResponse) Reset()                    { *m = L2SegmentGetResponse{} }
func (m *L2SegmentGetResponse) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetResponse) ProtoMessage()               {}
func (*L2SegmentGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{14} }

func (m *L2SegmentGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L2SegmentGetResponse) GetSpec() *L2SegmentSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *L2SegmentGetResponse) GetStatus() *L2SegmentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *L2SegmentGetResponse) GetStats() *L2SegmentStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// L2SegmentGetResponseMsg is the batched response to L2SegmentGetRequestMsg
type L2SegmentGetResponseMsg struct {
	Response []*L2SegmentGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L2SegmentGetResponseMsg) Reset()         { *m = L2SegmentGetResponseMsg{} }
func (m *L2SegmentGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentGetResponseMsg) ProtoMessage()    {}
func (*L2SegmentGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{15}
}

func (m *L2SegmentGetResponseMsg) GetResponse() []*L2SegmentGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*L2SegmentSpec)(nil), "l2segment.L2SegmentSpec")
	proto.RegisterType((*L2SegmentRequestMsg)(nil), "l2segment.L2SegmentRequestMsg")
	proto.RegisterType((*L2SegmentStatusEpd)(nil), "l2segment.L2segmentStatusEpd")
	proto.RegisterType((*L2SegmentStatusCpd)(nil), "l2segment.L2segmentStatusCpd")
	proto.RegisterType((*L2SegmentStatus)(nil), "l2segment.L2SegmentStatus")
	proto.RegisterType((*L2SegmentResponse)(nil), "l2segment.L2SegmentResponse")
	proto.RegisterType((*L2SegmentResponseMsg)(nil), "l2segment.L2SegmentResponseMsg")
	proto.RegisterType((*L2SegmentDeleteRequest)(nil), "l2segment.L2SegmentDeleteRequest")
	proto.RegisterType((*L2SegmentDeleteRequestMsg)(nil), "l2segment.L2SegmentDeleteRequestMsg")
	proto.RegisterType((*L2SegmentDeleteResponse)(nil), "l2segment.L2SegmentDeleteResponse")
	proto.RegisterType((*L2SegmentDeleteResponseMsg)(nil), "l2segment.L2SegmentDeleteResponseMsg")
	proto.RegisterType((*L2SegmentGetRequest)(nil), "l2segment.L2SegmentGetRequest")
	proto.RegisterType((*L2SegmentGetRequestMsg)(nil), "l2segment.L2SegmentGetRequestMsg")
	proto.RegisterType((*L2SegmentStats)(nil), "l2segment.L2SegmentStats")
	proto.RegisterType((*L2SegmentGetResponse)(nil), "l2segment.L2SegmentGetResponse")
	proto.RegisterType((*L2SegmentGetResponseMsg)(nil), "l2segment.L2SegmentGetResponseMsg")
	proto.RegisterEnum("l2segment.BroadcastFwdPolicy", BroadcastFwdPolicy_name, BroadcastFwdPolicy_value)
	proto.RegisterEnum("l2segment.MulticastFwdPolicy", MulticastFwdPolicy_name, MulticastFwdPolicy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for L2Segment service

type L2SegmentClient interface {
	L2SegmentCreate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error)
	L2SegmentUpdate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error)
	L2SegmentDelete(ctx context.Context, in *L2SegmentDeleteRequestMsg, opts ...grpc.CallOption) (*L2SegmentDeleteResponseMsg, error)
	L2SegmentGet(ctx context.Context, in *L2SegmentGetRequestMsg, opts ...grpc.CallOption) (*L2SegmentGetResponseMsg, error)
}

type l2SegmentClient struct {
	cc *grpc.ClientConn
}

func NewL2SegmentClient(cc *grpc.ClientConn) L2SegmentClient {
	return &l2SegmentClient{cc}
}

func (c *l2SegmentClient) L2SegmentCreate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error) {
	out := new(L2SegmentResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentUpdate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error) {
	out := new(L2SegmentResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentDelete(ctx context.Context, in *L2SegmentDeleteRequestMsg, opts ...grpc.CallOption) (*L2SegmentDeleteResponseMsg, error) {
	out := new(L2SegmentDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentGet(ctx context.Context, in *L2SegmentGetRequestMsg, opts ...grpc.CallOption) (*L2SegmentGetResponseMsg, error) {
	out := new(L2SegmentGetResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for L2Segment service

type L2SegmentServer interface {
	L2SegmentCreate(context.Context, *L2SegmentRequestMsg) (*L2SegmentResponseMsg, error)
	L2SegmentUpdate(context.Context, *L2SegmentRequestMsg) (*L2SegmentResponseMsg, error)
	L2SegmentDelete(context.Context, *L2SegmentDeleteRequestMsg) (*L2SegmentDeleteResponseMsg, error)
	L2SegmentGet(context.Context, *L2SegmentGetRequestMsg) (*L2SegmentGetResponseMsg, error)
}

func RegisterL2SegmentServer(s *grpc.Server, srv L2SegmentServer) {
	s.RegisterService(&_L2Segment_serviceDesc, srv)
}

func _L2Segment_L2SegmentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentCreate(ctx, req.(*L2SegmentRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentUpdate(ctx, req.(*L2SegmentRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentDelete(ctx, req.(*L2SegmentDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentGet(ctx, req.(*L2SegmentGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _L2Segment_serviceDesc = grpc.ServiceDesc{
	ServiceName: "l2segment.L2Segment",
	HandlerType: (*L2SegmentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "L2SegmentCreate",
			Handler:    _L2Segment_L2SegmentCreate_Handler,
		},
		{
			MethodName: "L2SegmentUpdate",
			Handler:    _L2Segment_L2SegmentUpdate_Handler,
		},
		{
			MethodName: "L2SegmentDelete",
			Handler:    _L2Segment_L2SegmentDelete_Handler,
		},
		{
			MethodName: "L2SegmentGet",
			Handler:    _L2Segment_L2SegmentGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "l2segment.proto",
}

func (m *L2SegmentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n2, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.NetworkKeyHandle) > 0 {
		for _, msg := range m.NetworkKeyHandle {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n3, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.SegmentType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.SegmentType))
	}
	if m.McastFwdPolicy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.McastFwdPolicy))
	}
	if m.BcastFwdPolicy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.BcastFwdPolicy))
	}
	if m.WireEncap != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.WireEncap.Size()))
		n4, err := m.WireEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TunnelEncap != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.TunnelEncap.Size()))
		n5, err := m.TunnelEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Gipo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Gipo.Size()))
		n6, err := m.Gipo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.EplearnCfg != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.EplearnCfg.Size()))
		n7, err := m.EplearnCfg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.PinnedUplinkIfHandle != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PinnedUplinkIfHandle))
		i += 8
	}
	return i, nil
}

func (m *L2SegmentRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwL2SegId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.HwL2SegId))
	}
	if m.L2SegLookupId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.L2SegLookupId))
	}
	if m.L2SegVlanIdCpu != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.L2SegVlanIdCpu))
	}
	if m.InpPropCpuIdx != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.InpPropCpuIdx))
	}
	if len(m.InpPropIdx) > 0 {
		dAtA9 := make([]byte, len(m.InpPropIdx)*10)
		var j8 int
		for _, num := range m.InpPropIdx {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.InpPropIdxPrTag) > 0 {
		dAtA11 := make([]byte, len(m.InpPropIdxPrTag)*10)
		var j10 int
		for _, num := range m.InpPropIdxPrTag {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *L2SegmentStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *L2SegmentStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L2SegmentHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.L2SegmentHandle))
		i += 8
	}
	if m.VrfId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.VrfId))
	}
	if m.L2SegStatus != nil {
		nn12, err := m.L2SegStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *L2SegmentStatus_EpdInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.EpdInfo.Size()))
		n13, err := m.EpdInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *L2SegmentStatus_CpdInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.CpdInfo.Size()))
		n14, err := m.CpdInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *L2SegmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.ApiStatus))
	}
	if m.L2SegmentStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.L2SegmentStatus.Size()))
		n15, err := m.L2SegmentStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *L2SegmentResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n16, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n18, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *L2SegmentDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *L2SegmentDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n19, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n20, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n21, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *L2SegmentGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumEndpoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.NumEndpoints))
	}
	if m.EplearnStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.EplearnStats.Size()))
		n22, err := m.EplearnStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *L2SegmentGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Spec.Size()))
		n23, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Status.Size()))
		n24, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Stats.Size()))
		n25, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *L2SegmentGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintL2Segment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *L2SegmentSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if len(m.NetworkKeyHandle) > 0 {
		for _, e := range m.NetworkKeyHandle {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.SegmentType != 0 {
		n += 1 + sovL2Segment(uint64(m.SegmentType))
	}
	if m.McastFwdPolicy != 0 {
		n += 1 + sovL2Segment(uint64(m.McastFwdPolicy))
	}
	if m.BcastFwdPolicy != 0 {
		n += 1 + sovL2Segment(uint64(m.BcastFwdPolicy))
	}
	if m.WireEncap != nil {
		l = m.WireEncap.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.TunnelEncap != nil {
		l = m.TunnelEncap.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.Gipo != nil {
		l = m.Gipo.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.EplearnCfg != nil {
		l = m.EplearnCfg.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.PinnedUplinkIfHandle != 0 {
		n += 9
	}
	return n
}

func (m *L2SegmentRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.HwL2SegId != 0 {
		n += 1 + sovL2Segment(uint64(m.HwL2SegId))
	}
	if m.L2SegLookupId != 0 {
		n += 1 + sovL2Segment(uint64(m.L2SegLookupId))
	}
	if m.L2SegVlanIdCpu != 0 {
		n += 1 + sovL2Segment(uint64(m.L2SegVlanIdCpu))
	}
	if m.InpPropCpuIdx != 0 {
		n += 1 + sovL2Segment(uint64(m.InpPropCpuIdx))
	}
	if len(m.InpPropIdx) > 0 {
		l = 0
		for _, e := range m.InpPropIdx {
			l += sovL2Segment(uint64(e))
		}
		n += 1 + sovL2Segment(uint64(l)) + l
	}
	if len(m.InpPropIdxPrTag) > 0 {
		l = 0
		for _, e := range m.InpPropIdxPrTag {
			l += sovL2Segment(uint64(e))
		}
		n += 1 + sovL2Segment(uint64(l)) + l
	}
	return n
}

func (m *L2SegmentStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *L2SegmentStatus) Size() (n int) {
	var l int
	_ = l
	if m.L2SegmentHandle != 0 {
		n += 9
	}
	if m.VrfId != 0 {
		n += 1 + sovL2Segment(uint64(m.VrfId))
	}
	if m.L2SegStatus != nil {
		n += m.L2SegStatus.Size()
	}
	return n
}

func (m *L2SegmentStatus_EpdInfo) Size() (n int) {
	var l int
	_ = l
	if m.EpdInfo != nil {
		l = m.EpdInfo.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}
func (m *L2SegmentStatus_CpdInfo) Size() (n int) {
	var l int
	_ = l
	if m.CpdInfo != nil {
		l = m.CpdInfo.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}
func (m *L2SegmentResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL2Segment(uint64(m.ApiStatus))
	}
	if m.L2SegmentStatus != nil {
		l = m.L2SegmentStatus.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL2Segment(uint64(m.ApiStatus))
	}
	return n
}

func (m *L2SegmentDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentStats) Size() (n int) {
	var l int
	_ = l
	if m.NumEndpoints != 0 {
		n += 1 + sovL2Segment(uint64(m.NumEndpoints))
	}
	if m.EplearnStats != nil {
		l = m.EplearnStats.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL2Segment(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func sovL2Segment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozL2Segment(x uint64) (n int) {
	return sovL2Segment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *L2SegmentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkKeyHandle = append(m.NetworkKeyHandle, &NetworkKeyHandle{})
			if err := m.NetworkKeyHandle[len(m.NetworkKeyHandle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentType", wireType)
			}
			m.SegmentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentType |= (L2SegmentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McastFwdPolicy", wireType)
			}
			m.McastFwdPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McastFwdPolicy |= (MulticastFwdPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcastFwdPolicy", wireType)
			}
			m.BcastFwdPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BcastFwdPolicy |= (BroadcastFwdPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WireEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WireEncap == nil {
				m.WireEncap = &EncapInfo{}
			}
			if err := m.WireEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TunnelEncap == nil {
				m.TunnelEncap = &EncapInfo{}
			}
			if err := m.TunnelEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gipo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gipo == nil {
				m.Gipo = &IPAddress{}
			}
			if err := m.Gipo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EplearnCfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EplearnCfg == nil {
				m.EplearnCfg = &EplearnCfg{}
			}
			if err := m.EplearnCfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedUplinkIfHandle", wireType)
			}
			m.PinnedUplinkIfHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PinnedUplinkIfHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2segmentStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2segmentStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwL2SegId", wireType)
			}
			m.HwL2SegId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwL2SegId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegLookupId", wireType)
			}
			m.L2SegLookupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2SegLookupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegVlanIdCpu", wireType)
			}
			m.L2SegVlanIdCpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2SegVlanIdCpu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InpPropCpuIdx", wireType)
			}
			m.InpPropCpuIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InpPropCpuIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InpPropIdx = append(m.InpPropIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL2Segment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowL2Segment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InpPropIdx = append(m.InpPropIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InpPropIdx", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InpPropIdxPrTag = append(m.InpPropIdxPrTag, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL2Segment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowL2Segment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InpPropIdxPrTag = append(m.InpPropIdxPrTag, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InpPropIdxPrTag", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2segmentStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2segmentStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentHandle", wireType)
			}
			m.L2SegmentHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.L2SegmentHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			m.VrfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VrfId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2SegmentStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L2SegStatus = &L2SegmentStatus_EpdInfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2SegmentStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L2SegStatus = &L2SegmentStatus_CpdInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegmentStatus == nil {
				m.L2SegmentStatus = &L2SegmentStatus{}
			}
			if err := m.L2SegmentStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L2SegmentResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L2SegmentDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEndpoints", wireType)
			}
			m.NumEndpoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEndpoints |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EplearnStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EplearnStats == nil {
				m.EplearnStats = &L2EplearnStats{}
			}
			if err := m.EplearnStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &L2SegmentSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L2SegmentStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &L2SegmentStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L2SegmentGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipL2Segment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthL2Segment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipL2Segment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthL2Segment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowL2Segment   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("l2segment.proto", fileDescriptorL2Segment) }

var fileDescriptorL2Segment = []byte{
	// 1266 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xc6, 0x69, 0x7e, 0x8e, 0xbd, 0xae, 0x33, 0x4d, 0x5b, 0xd7, 0x50, 0xdb, 0x5d, 0x28,
	0xa4, 0x55, 0x15, 0x24, 0x03, 0x12, 0x2a, 0x08, 0x29, 0x76, 0x9c, 0x76, 0xc1, 0xa9, 0xad, 0x49,
	0xda, 0x02, 0x42, 0x1a, 0x36, 0xde, 0xb1, 0xbd, 0x78, 0xbd, 0x3b, 0xec, 0x4f, 0x5c, 0xdf, 0xf1,
	0x14, 0x88, 0x6b, 0x9e, 0x06, 0x89, 0x9b, 0x4a, 0x5c, 0x22, 0x45, 0xa8, 0x3c, 0x01, 0x79, 0x02,
	0xb4, 0x33, 0xfb, 0xe7, 0xbf, 0x46, 0x48, 0x95, 0x90, 0xb8, 0x8a, 0x67, 0xce, 0x77, 0xbe, 0x99,
	0x39, 0xe7, 0x3b, 0xe7, 0x6c, 0xe0, 0xaa, 0x59, 0x73, 0x69, 0x7f, 0x44, 0x2d, 0x6f, 0x8f, 0x39,
	0xb6, 0x67, 0xa3, 0xad, 0x78, 0xa3, 0x94, 0xf5, 0x26, 0x8c, 0xba, 0x62, 0xbf, 0xb4, 0x39, 0x1c,
	0x84, 0xbf, 0x64, 0xca, 0x4c, 0xaa, 0x39, 0x96, 0x58, 0x2a, 0xbf, 0xad, 0x83, 0xdc, 0xaa, 0x1d,
	0x0b, 0x9f, 0x63, 0x46, 0xbb, 0xe8, 0x2e, 0xac, 0x8d, 0xa8, 0xa7, 0x15, 0xa5, 0xaa, 0xb4, 0x9b,
	0xad, 0x6d, 0xef, 0x09, 0x9a, 0xf6, 0xe9, 0xf7, 0xb4, 0xeb, 0x1d, 0x51, 0x4f, 0xc3, 0xdc, 0x8c,
	0xbe, 0x00, 0x79, 0x48, 0x27, 0xc4, 0x76, 0xc8, 0x40, 0xb3, 0x74, 0x93, 0x16, 0x57, 0x39, 0xfe,
	0xc6, 0xde, 0x70, 0xb0, 0x17, 0x13, 0x7e, 0x49, 0x27, 0x8f, 0xb9, 0xb5, 0x9e, 0xbf, 0x38, 0xaf,
	0xc0, 0x19, 0xb5, 0x8c, 0x2e, 0x7d, 0x38, 0xa4, 0x13, 0x9c, 0x1d, 0xd2, 0x49, 0xdb, 0x11, 0x46,
	0x84, 0x01, 0x59, 0xd4, 0x1b, 0xdb, 0xce, 0x90, 0x04, 0x9c, 0x21, 0x61, 0xa6, 0x9a, 0xd9, 0xcd,
	0xd6, 0x76, 0x02, 0xc2, 0x27, 0xc2, 0xba, 0x98, 0xce, 0xa1, 0x3d, 0x5c, 0xb0, 0x66, 0x10, 0xe8,
	0x39, 0xe4, 0xcf, 0x9c, 0x5e, 0x9a, 0x6f, 0x8d, 0x5f, 0xb0, 0x10, 0xf0, 0x3d, 0x73, 0x7a, 0x09,
	0x57, 0xe5, 0xe2, 0xbc, 0xf2, 0x56, 0xc8, 0x65, 0x8c, 0x46, 0xbe, 0xa7, 0x9d, 0x9a, 0xf4, 0x41,
	0x8a, 0x3c, 0x77, 0x96, 0x82, 0xa3, 0x23, 0xc8, 0x85, 0x21, 0x26, 0x41, 0x68, 0x8a, 0x57, 0xaa,
	0xd2, 0x6e, 0xbe, 0xb6, 0x13, 0xc6, 0x29, 0x7e, 0xfa, 0xc9, 0x84, 0xd1, 0xfa, 0xce, 0xc5, 0x79,
	0xa5, 0x30, 0x4b, 0x8d, 0xb3, 0x6e, 0x02, 0x41, 0x8f, 0xa0, 0x30, 0xea, 0x6a, 0xae, 0x47, 0x7a,
	0x63, 0x9d, 0x30, 0xdb, 0x34, 0xba, 0x93, 0xe2, 0x3a, 0xa7, 0xbc, 0xbd, 0x97, 0x64, 0xf7, 0xc8,
	0x37, 0x3d, 0x23, 0x80, 0x1d, 0x8e, 0xf5, 0x0e, 0x07, 0xe1, 0xfc, 0x68, 0x6a, 0x1d, 0x10, 0x9d,
	0xce, 0x12, 0x6d, 0xcc, 0x11, 0xd5, 0x1d, 0x5b, 0xd3, 0x67, 0x88, 0x4e, 0xa7, 0x89, 0x9a, 0x00,
	0x63, 0xc3, 0xa1, 0x84, 0x5a, 0x5d, 0x8d, 0x15, 0x37, 0xc3, 0xa8, 0x89, 0xe7, 0x35, 0x83, 0x3d,
	0xd5, 0xea, 0xd9, 0x4b, 0x9e, 0xb6, 0x15, 0x78, 0x72, 0x10, 0x52, 0x21, 0xe7, 0xf9, 0x96, 0x45,
	0xcd, 0x90, 0x68, 0xeb, 0x5f, 0x11, 0x65, 0x85, 0xaf, 0xa0, 0x7a, 0x08, 0x6b, 0x7d, 0x83, 0xd9,
	0x45, 0x98, 0xa2, 0x50, 0x3b, 0xfb, 0xba, 0xee, 0x50, 0xd7, 0x5d, 0x42, 0xc1, 0x7d, 0xd0, 0x47,
	0x90, 0x0d, 0x15, 0x4f, 0xba, 0xbd, 0x7e, 0x31, 0xcb, 0x29, 0xae, 0xed, 0x45, 0x55, 0xd0, 0x14,
	0x7f, 0x1b, 0xbd, 0x3e, 0x06, 0x1a, 0xff, 0x46, 0x1f, 0xc3, 0x4d, 0x66, 0x58, 0x16, 0xd5, 0x89,
	0xcf, 0x4c, 0xc3, 0x1a, 0x12, 0xa3, 0x17, 0xc9, 0x28, 0x57, 0x95, 0x76, 0xd7, 0xf1, 0x8e, 0x30,
	0x3f, 0xe5, 0x56, 0xb5, 0x27, 0xb4, 0xa1, 0xa8, 0x70, 0x2d, 0x16, 0x00, 0xa6, 0x3f, 0xf8, 0xd4,
	0xf5, 0x8e, 0xdc, 0x3e, 0xaa, 0xc1, 0x86, 0x23, 0x56, 0x45, 0x89, 0x8b, 0xba, 0x98, 0xca, 0xc8,
	0x54, 0xf5, 0xe1, 0x08, 0xa8, 0xfc, 0xb8, 0x0a, 0xa8, 0x15, 0x81, 0x8e, 0x3d, 0xcd, 0xf3, 0xdd,
	0x26, 0xd3, 0x51, 0x19, 0xb2, 0x83, 0x31, 0xe1, 0xde, 0xc4, 0xd0, 0x8b, 0x99, 0xaa, 0xb4, 0x2b,
	0xe3, 0xad, 0xc1, 0x98, 0x43, 0x55, 0x1d, 0xbd, 0x17, 0xf6, 0x04, 0x62, 0xda, 0xf6, 0xd0, 0x67,
	0x01, 0x66, 0x8d, 0x63, 0x64, 0xbe, 0xdd, 0xe2, 0xbb, 0xaa, 0x8e, 0xee, 0xc1, 0xb6, 0xc0, 0x9d,
	0x99, 0x9a, 0x45, 0x0c, 0x9d, 0x74, 0x99, 0xcf, 0xa5, 0x2c, 0xe3, 0x3c, 0x37, 0x3c, 0x33, 0x35,
	0x4b, 0xd5, 0x1b, 0xcc, 0x47, 0xef, 0x43, 0xc1, 0xb0, 0x18, 0x61, 0x8e, 0xcd, 0x02, 0x14, 0x31,
	0xf4, 0x17, 0x5c, 0xa1, 0x32, 0x96, 0x0d, 0x8b, 0x75, 0x1c, 0x9b, 0x35, 0x98, 0xaf, 0xea, 0x2f,
	0x50, 0x15, 0x72, 0x31, 0x30, 0x00, 0x6d, 0x54, 0x33, 0xbb, 0x32, 0x86, 0x10, 0x14, 0x20, 0x1e,
	0xc0, 0xb5, 0x34, 0x82, 0x30, 0x87, 0x78, 0x5a, 0xbf, 0xb8, 0xc9, 0x81, 0x57, 0x13, 0x60, 0xc7,
	0x39, 0xd1, 0xfa, 0xca, 0xce, 0x5c, 0x04, 0x1a, 0x4c, 0x57, 0xfe, 0x90, 0xe0, 0x6a, 0x12, 0x33,
	0xbe, 0x8d, 0xee, 0x41, 0x21, 0x0e, 0x68, 0x94, 0x27, 0x89, 0xe7, 0x29, 0xe9, 0x90, 0x61, 0xf9,
	0x5e, 0x87, 0xf5, 0xa0, 0x2f, 0x18, 0x3a, 0x6f, 0x58, 0x32, 0xbe, 0x72, 0xe6, 0xf4, 0x54, 0x1d,
	0x3d, 0x84, 0x4d, 0xca, 0x74, 0x62, 0x58, 0x3d, 0x9b, 0x07, 0x35, 0x3b, 0x55, 0x35, 0xf3, 0x89,
	0x78, 0xbc, 0x82, 0x37, 0x28, 0xd3, 0x03, 0x05, 0x07, 0xbe, 0xdd, 0xc8, 0x77, 0xed, 0x32, 0xdf,
	0x86, 0xf0, 0xed, 0x0a, 0xdf, 0x7a, 0x1e, 0x72, 0x22, 0x0f, 0x2e, 0xb7, 0x2a, 0xbf, 0x48, 0xb0,
	0x9d, 0x92, 0x90, 0xcb, 0x6c, 0xcb, 0xa5, 0xe8, 0x10, 0x40, 0x63, 0x46, 0x88, 0xe1, 0x2f, 0xcb,
	0xc7, 0x65, 0xb0, 0xcf, 0x0c, 0xc1, 0x5c, 0xbf, 0x7e, 0x71, 0x5e, 0xd9, 0x0e, 0xcb, 0x20, 0x81,
	0xe3, 0x2d, 0x2d, 0x42, 0xa0, 0x66, 0x3a, 0x4e, 0x21, 0x9b, 0xe8, 0xdb, 0xa5, 0x85, 0x8a, 0x14,
	0x04, 0x49, 0x0c, 0xc5, 0x86, 0xd2, 0x81, 0x9d, 0xb9, 0x3b, 0x06, 0x3a, 0xff, 0x04, 0x36, 0x9d,
	0x70, 0x19, 0x0a, 0xfd, 0xed, 0x45, 0xb4, 0x91, 0x0b, 0x8e, 0xd1, 0xca, 0xef, 0x12, 0xdc, 0x88,
	0xed, 0x07, 0xd4, 0xa4, 0x1e, 0x0d, 0xeb, 0xe7, 0xbf, 0x98, 0x47, 0x87, 0x73, 0xb3, 0x23, 0xb3,
	0x64, 0x76, 0xcc, 0xce, 0xa1, 0xa9, 0x51, 0xa1, 0x7c, 0x05, 0xb7, 0x16, 0x3f, 0x2a, 0x08, 0xd6,
	0xa7, 0xb3, 0x4d, 0xe1, 0xce, 0xa2, 0x58, 0x4d, 0xb9, 0x25, 0xdd, 0x41, 0x83, 0x9b, 0x73, 0x90,
	0x37, 0xab, 0x15, 0xe5, 0x5b, 0x28, 0x2d, 0x39, 0x22, 0xb8, 0xfd, 0xe7, 0x73, 0xa9, 0x56, 0x5e,
	0x77, 0xfd, 0xb9, 0x84, 0xbf, 0x94, 0x52, 0xad, 0xf2, 0x11, 0xf5, 0xfe, 0x07, 0xd9, 0xc6, 0x29,
	0x09, 0x27, 0x2f, 0x12, 0x75, 0x31, 0x93, 0xea, 0xf2, 0xa2, 0x58, 0x25, 0x3e, 0x49, 0x9e, 0x5d,
	0xc8, 0x4f, 0x55, 0xa3, 0x8b, 0xde, 0x01, 0xd9, 0xf2, 0x47, 0x84, 0x5a, 0x3a, 0xb3, 0x0d, 0xcb,
	0x13, 0x19, 0x96, 0x71, 0xce, 0xf2, 0x47, 0xcd, 0x68, 0x0f, 0x7d, 0x06, 0xd1, 0x67, 0x1e, 0x4f,
	0x6c, 0x54, 0xe4, 0x37, 0xe3, 0xb1, 0xd7, 0xaa, 0x85, 0x83, 0x8f, 0x93, 0xe2, 0x1c, 0x4d, 0xad,
	0x94, 0xbf, 0xa5, 0x54, 0x7d, 0xf3, 0x5b, 0xbd, 0xe1, 0x36, 0xf4, 0x00, 0xd6, 0x5c, 0x46, 0xbb,
	0xe1, 0xad, 0x96, 0x0f, 0x43, 0x8e, 0x42, 0x35, 0x58, 0x0f, 0x4f, 0xcc, 0x5c, 0xda, 0xaa, 0x42,
	0x24, 0xfa, 0x00, 0xae, 0x88, 0x87, 0x8b, 0x7e, 0x7c, 0x6b, 0x99, 0x8b, 0x8b, 0x05, 0x4e, 0x79,
	0x96, 0x2a, 0xa8, 0xd4, 0x93, 0x45, 0xa1, 0xce, 0x4a, 0xbd, 0xb2, 0x34, 0x7d, 0xb3, 0x3a, 0xbf,
	0xef, 0x00, 0x9a, 0xff, 0xe4, 0x42, 0xb7, 0xe1, 0x56, 0x1d, 0xb7, 0xf7, 0x0f, 0x1a, 0xfb, 0xc7,
	0x27, 0xe4, 0xf0, 0xf9, 0x01, 0xe9, 0xb4, 0x5b, 0x6a, 0xe3, 0x6b, 0xf2, 0xa4, 0xfd, 0xa4, 0x59,
	0x58, 0x59, 0x6a, 0x3e, 0xc0, 0xed, 0x4e, 0x41, 0x42, 0x65, 0x28, 0x2d, 0x34, 0x1f, 0xb6, 0xda,
	0xed, 0x83, 0xc2, 0xea, 0xfd, 0x9f, 0x24, 0x40, 0xf3, 0x1f, 0x8c, 0x01, 0xeb, 0xd1, 0xd3, 0xd6,
	0x89, 0xba, 0xe4, 0xd0, 0x32, 0x94, 0x16, 0x9a, 0x05, 0xab, 0x84, 0x14, 0x28, 0x2f, 0xb4, 0xe3,
	0x66, 0xa7, 0xa5, 0x36, 0xf6, 0x4f, 0x9a, 0x85, 0xd5, 0xa5, 0x47, 0xf0, 0x8b, 0x67, 0x6a, 0x17,
	0xab, 0xb0, 0x15, 0xc7, 0x0b, 0x9d, 0xa4, 0xe6, 0x78, 0xc3, 0xa1, 0x9a, 0x47, 0x51, 0x79, 0xf1,
	0xb8, 0x88, 0x0a, 0xa9, 0x54, 0x79, 0xdd, 0x38, 0x39, 0x72, 0xfb, 0xca, 0xca, 0x14, 0xeb, 0x53,
	0xa6, 0xbf, 0x21, 0xd6, 0xef, 0x52, 0xac, 0xa2, 0xa7, 0xa1, 0x77, 0x2f, 0x6d, 0xd7, 0x01, 0xf7,
	0xdd, 0xcb, 0xbb, 0xa2, 0x38, 0xe1, 0x39, 0xe4, 0xd2, 0x52, 0x42, 0x77, 0x5e, 0xdf, 0x22, 0x02,
	0x6e, 0xe5, 0x12, 0x19, 0x72, 0xe2, 0x7a, 0xe9, 0xd7, 0x57, 0x65, 0xe9, 0xe5, 0xab, 0xb2, 0xf4,
	0xe7, 0xab, 0xb2, 0xf4, 0xf3, 0x5f, 0xe5, 0x95, 0x6f, 0x36, 0x07, 0x9a, 0xc9, 0xff, 0xfb, 0x3b,
	0x5d, 0xe7, 0x7f, 0x3e, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x16, 0xe3, 0xd7, 0x48, 0x0e,
	0x00, 0x00,
}
