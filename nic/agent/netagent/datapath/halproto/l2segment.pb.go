// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nic/proto/hal/l2segment.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of ObjectMeta from nic/proto/types.proto

// Ignoring public import of EncapInfo from nic/proto/types.proto

// Ignoring public import of IPAddress from nic/proto/types.proto

// Ignoring public import of IPPrefix from nic/proto/types.proto

// Ignoring public import of L4PortRange from nic/proto/types.proto

// Ignoring public import of Empty from nic/proto/types.proto

// Ignoring public import of IPProtocol from nic/proto/types.proto

// Ignoring public import of ICMPMsgType from nic/proto/types.proto

// Ignoring public import of ApiStatus from nic/proto/types.proto

// Ignoring public import of L2SegmentType from nic/proto/types.proto

// Ignoring public import of encapType from nic/proto/types.proto

// Ignoring public import of IPAddressFamily from nic/proto/types.proto

// Ignoring public import of WRingType from nic/proto/types.proto

// Ignoring public import of ProxyType from nic/proto/types.proto

// Ignoring public import of CryptoKeyType from nic/proto/types.proto

// BroadcastFwdPolicy defines various forwarding options to deal with
// broadcast traffic
type BroadcastFwdPolicy int32

const (
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_NONE  BroadcastFwdPolicy = 0
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_DROP  BroadcastFwdPolicy = 1
	BroadcastFwdPolicy_BROADCAST_FWD_POLICY_FLOOD BroadcastFwdPolicy = 2
)

var BroadcastFwdPolicy_name = map[int32]string{
	0: "BROADCAST_FWD_POLICY_NONE",
	1: "BROADCAST_FWD_POLICY_DROP",
	2: "BROADCAST_FWD_POLICY_FLOOD",
}
var BroadcastFwdPolicy_value = map[string]int32{
	"BROADCAST_FWD_POLICY_NONE":  0,
	"BROADCAST_FWD_POLICY_DROP":  1,
	"BROADCAST_FWD_POLICY_FLOOD": 2,
}

func (x BroadcastFwdPolicy) String() string {
	return proto.EnumName(BroadcastFwdPolicy_name, int32(x))
}
func (BroadcastFwdPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{0} }

// MulticastFwdPolicy defines various forwarding options to deal with
// multicast traffic
type MulticastFwdPolicy int32

const (
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_NONE      MulticastFwdPolicy = 0
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_FLOOD     MulticastFwdPolicy = 1
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_REPLICATE MulticastFwdPolicy = 2
	MulticastFwdPolicy_MULTICAST_FWD_POLICY_DROP      MulticastFwdPolicy = 3
)

var MulticastFwdPolicy_name = map[int32]string{
	0: "MULTICAST_FWD_POLICY_NONE",
	1: "MULTICAST_FWD_POLICY_FLOOD",
	2: "MULTICAST_FWD_POLICY_REPLICATE",
	3: "MULTICAST_FWD_POLICY_DROP",
}
var MulticastFwdPolicy_value = map[string]int32{
	"MULTICAST_FWD_POLICY_NONE":      0,
	"MULTICAST_FWD_POLICY_FLOOD":     1,
	"MULTICAST_FWD_POLICY_REPLICATE": 2,
	"MULTICAST_FWD_POLICY_DROP":      3,
}

func (x MulticastFwdPolicy) String() string {
	return proto.EnumName(MulticastFwdPolicy_name, int32(x))
}
func (MulticastFwdPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{1} }

// L2SegmentKeyHandle is used to operate on a L2 segment either by its
// segment id or HAL allocated handle
type L2SegmentKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*L2SegmentKeyHandle_SegmentId
	//	*L2SegmentKeyHandle_L2SegmentHandle
	KeyOrHandle isL2SegmentKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *L2SegmentKeyHandle) Reset()                    { *m = L2SegmentKeyHandle{} }
func (m *L2SegmentKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentKeyHandle) ProtoMessage()               {}
func (*L2SegmentKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{0} }

type isL2SegmentKeyHandle_KeyOrHandle interface {
	isL2SegmentKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type L2SegmentKeyHandle_SegmentId struct {
	SegmentId uint32 `protobuf:"varint,1,opt,name=segment_id,json=segmentId,proto3,oneof"`
}
type L2SegmentKeyHandle_L2SegmentHandle struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,2,opt,name=l2segment_handle,json=l2segmentHandle,proto3,oneof"`
}

func (*L2SegmentKeyHandle_SegmentId) isL2SegmentKeyHandle_KeyOrHandle()       {}
func (*L2SegmentKeyHandle_L2SegmentHandle) isL2SegmentKeyHandle_KeyOrHandle() {}

func (m *L2SegmentKeyHandle) GetKeyOrHandle() isL2SegmentKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentKeyHandle) GetSegmentId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*L2SegmentKeyHandle_SegmentId); ok {
		return x.SegmentId
	}
	return 0
}

func (m *L2SegmentKeyHandle) GetL2SegmentHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*L2SegmentKeyHandle_L2SegmentHandle); ok {
		return x.L2SegmentHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L2SegmentKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L2SegmentKeyHandle_OneofMarshaler, _L2SegmentKeyHandle_OneofUnmarshaler, _L2SegmentKeyHandle_OneofSizer, []interface{}{
		(*L2SegmentKeyHandle_SegmentId)(nil),
		(*L2SegmentKeyHandle_L2SegmentHandle)(nil),
	}
}

func _L2SegmentKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L2SegmentKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L2SegmentKeyHandle_SegmentId:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.SegmentId))
	case *L2SegmentKeyHandle_L2SegmentHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.L2SegmentHandle))
	case nil:
	default:
		return fmt.Errorf("L2SegmentKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _L2SegmentKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L2SegmentKeyHandle)
	switch tag {
	case 1: // key_or_handle.segment_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &L2SegmentKeyHandle_SegmentId{uint32(x)}
		return true, err
	case 2: // key_or_handle.l2segment_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &L2SegmentKeyHandle_L2SegmentHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _L2SegmentKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L2SegmentKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L2SegmentKeyHandle_SegmentId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SegmentId))
	case *L2SegmentKeyHandle_L2SegmentHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L2SegmentSpec message is used to do add/mod of vlan
type L2SegmentSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L2 segment's unique identifier
	KeyOrHandle    *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	NetworkHandle  []uint64            `protobuf:"fixed64,3,rep,packed,name=network_handle,json=networkHandle" json:"network_handle,omitempty"`
	SegmentType    L2SegmentType       `protobuf:"varint,4,opt,name=segment_type,json=segmentType,proto3,enum=types.L2SegmentType" json:"segment_type,omitempty"`
	McastFwdPolicy MulticastFwdPolicy  `protobuf:"varint,5,opt,name=mcast_fwd_policy,json=mcastFwdPolicy,proto3,enum=l2segment.MulticastFwdPolicy" json:"mcast_fwd_policy,omitempty"`
	BcastFwdPolicy BroadcastFwdPolicy  `protobuf:"varint,6,opt,name=bcast_fwd_policy,json=bcastFwdPolicy,proto3,enum=l2segment.BroadcastFwdPolicy" json:"bcast_fwd_policy,omitempty"`
	AccessEncap    *EncapInfo          `protobuf:"bytes,7,opt,name=access_encap,json=accessEncap" json:"access_encap,omitempty"`
	FabricEncap    *EncapInfo          `protobuf:"bytes,8,opt,name=fabric_encap,json=fabricEncap" json:"fabric_encap,omitempty"`
}

func (m *L2SegmentSpec) Reset()                    { *m = L2SegmentSpec{} }
func (m *L2SegmentSpec) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentSpec) ProtoMessage()               {}
func (*L2SegmentSpec) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{1} }

func (m *L2SegmentSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentSpec) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentSpec) GetNetworkHandle() []uint64 {
	if m != nil {
		return m.NetworkHandle
	}
	return nil
}

func (m *L2SegmentSpec) GetSegmentType() L2SegmentType {
	if m != nil {
		return m.SegmentType
	}
	return L2SegmentType_L2_SEGMENT_TYPE_NONE
}

func (m *L2SegmentSpec) GetMcastFwdPolicy() MulticastFwdPolicy {
	if m != nil {
		return m.McastFwdPolicy
	}
	return MulticastFwdPolicy_MULTICAST_FWD_POLICY_NONE
}

func (m *L2SegmentSpec) GetBcastFwdPolicy() BroadcastFwdPolicy {
	if m != nil {
		return m.BcastFwdPolicy
	}
	return BroadcastFwdPolicy_BROADCAST_FWD_POLICY_NONE
}

func (m *L2SegmentSpec) GetAccessEncap() *EncapInfo {
	if m != nil {
		return m.AccessEncap
	}
	return nil
}

func (m *L2SegmentSpec) GetFabricEncap() *EncapInfo {
	if m != nil {
		return m.FabricEncap
	}
	return nil
}

// L2SegmentRequestMsg is batched add or modify L2 segment request
type L2SegmentRequestMsg struct {
	Request []*L2SegmentSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentRequestMsg) Reset()                    { *m = L2SegmentRequestMsg{} }
func (m *L2SegmentRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentRequestMsg) ProtoMessage()               {}
func (*L2SegmentRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{2} }

func (m *L2SegmentRequestMsg) GetRequest() []*L2SegmentSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2SegmentStatus represents the current status of the L2 segment
type L2SegmentStatus struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,1,opt,name=l2segment_handle,json=l2segmentHandle,proto3" json:"l2segment_handle,omitempty"`
}

func (m *L2SegmentStatus) Reset()                    { *m = L2SegmentStatus{} }
func (m *L2SegmentStatus) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStatus) ProtoMessage()               {}
func (*L2SegmentStatus) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{3} }

func (m *L2SegmentStatus) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

// L2SegmentResponse is response to L2SegmentSpec
type L2SegmentResponse struct {
	ApiStatus       ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	L2SegmentStatus *L2SegmentStatus `protobuf:"bytes,2,opt,name=l2segment_status,json=l2segmentStatus" json:"l2segment_status,omitempty"`
}

func (m *L2SegmentResponse) Reset()                    { *m = L2SegmentResponse{} }
func (m *L2SegmentResponse) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentResponse) ProtoMessage()               {}
func (*L2SegmentResponse) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{4} }

func (m *L2SegmentResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L2SegmentResponse) GetL2SegmentStatus() *L2SegmentStatus {
	if m != nil {
		return m.L2SegmentStatus
	}
	return nil
}

// L2SegmentResponseMsg is batched response to L2SegmentRequestMsg
type L2SegmentResponseMsg struct {
	Response []*L2SegmentResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L2SegmentResponseMsg) Reset()                    { *m = L2SegmentResponseMsg{} }
func (m *L2SegmentResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentResponseMsg) ProtoMessage()               {}
func (*L2SegmentResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{5} }

func (m *L2SegmentResponseMsg) GetResponse() []*L2SegmentResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L2SegmentDeleteRequest is used to delete a L2 segment
type L2SegmentDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L2 segment's unique identifier
	KeyOrHandle *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *L2SegmentDeleteRequest) Reset()                    { *m = L2SegmentDeleteRequest{} }
func (m *L2SegmentDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentDeleteRequest) ProtoMessage()               {}
func (*L2SegmentDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{6} }

func (m *L2SegmentDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentDeleteRequest) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L2SegmentDeleteRequestMsg is used to delete a batch of L2 segments
type L2SegmentDeleteRequestMsg struct {
	Request []*L2SegmentDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentDeleteRequestMsg) Reset()         { *m = L2SegmentDeleteRequestMsg{} }
func (m *L2SegmentDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentDeleteRequestMsg) ProtoMessage()    {}
func (*L2SegmentDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{7}
}

func (m *L2SegmentDeleteRequestMsg) GetRequest() []*L2SegmentDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2SegmentDeleteResponseMsg is batched response to L2SegmentDeleteRequestMsg
type L2SegmentDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *L2SegmentDeleteResponseMsg) Reset()         { *m = L2SegmentDeleteResponseMsg{} }
func (m *L2SegmentDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentDeleteResponseMsg) ProtoMessage()    {}
func (*L2SegmentDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{8}
}

func (m *L2SegmentDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// L2SegmentGetRequest is used to get information about a L2 Segment
type L2SegmentGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L2 segment's unique identifier
	KeyOrHandle *L2SegmentKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *L2SegmentGetRequest) Reset()                    { *m = L2SegmentGetRequest{} }
func (m *L2SegmentGetRequest) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetRequest) ProtoMessage()               {}
func (*L2SegmentGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{9} }

func (m *L2SegmentGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L2SegmentGetRequest) GetKeyOrHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L2SegmentGetRequestMsg is batched GET request for L2 segments
type L2SegmentGetRequestMsg struct {
	Request []*L2SegmentGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L2SegmentGetRequestMsg) Reset()                    { *m = L2SegmentGetRequestMsg{} }
func (m *L2SegmentGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetRequestMsg) ProtoMessage()               {}
func (*L2SegmentGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{10} }

func (m *L2SegmentGetRequestMsg) GetRequest() []*L2SegmentGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L2SegmentStats is the statistics object for each L2 segment
type L2SegmentStats struct {
	NumEndpoints uint32 `protobuf:"varint,1,opt,name=num_endpoints,json=numEndpoints,proto3" json:"num_endpoints,omitempty"`
}

func (m *L2SegmentStats) Reset()                    { *m = L2SegmentStats{} }
func (m *L2SegmentStats) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentStats) ProtoMessage()               {}
func (*L2SegmentStats) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{11} }

func (m *L2SegmentStats) GetNumEndpoints() uint32 {
	if m != nil {
		return m.NumEndpoints
	}
	return 0
}

// L2SegmentGetResponse captures all the information about a L2 segment
// only if api_status indicates success, other fields are valid
type L2SegmentGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *L2SegmentSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *L2SegmentStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *L2SegmentStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *L2SegmentGetResponse) Reset()                    { *m = L2SegmentGetResponse{} }
func (m *L2SegmentGetResponse) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentGetResponse) ProtoMessage()               {}
func (*L2SegmentGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorL2Segment, []int{12} }

func (m *L2SegmentGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L2SegmentGetResponse) GetSpec() *L2SegmentSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *L2SegmentGetResponse) GetStatus() *L2SegmentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *L2SegmentGetResponse) GetStats() *L2SegmentStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// L2SegmentGetResponseMsg is the batched response to L2SegmentGetRequestMsg
type L2SegmentGetResponseMsg struct {
	Response []*L2SegmentGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L2SegmentGetResponseMsg) Reset()         { *m = L2SegmentGetResponseMsg{} }
func (m *L2SegmentGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L2SegmentGetResponseMsg) ProtoMessage()    {}
func (*L2SegmentGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL2Segment, []int{13}
}

func (m *L2SegmentGetResponseMsg) GetResponse() []*L2SegmentGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*L2SegmentKeyHandle)(nil), "l2segment.L2SegmentKeyHandle")
	proto.RegisterType((*L2SegmentSpec)(nil), "l2segment.L2SegmentSpec")
	proto.RegisterType((*L2SegmentRequestMsg)(nil), "l2segment.L2SegmentRequestMsg")
	proto.RegisterType((*L2SegmentStatus)(nil), "l2segment.L2SegmentStatus")
	proto.RegisterType((*L2SegmentResponse)(nil), "l2segment.L2SegmentResponse")
	proto.RegisterType((*L2SegmentResponseMsg)(nil), "l2segment.L2SegmentResponseMsg")
	proto.RegisterType((*L2SegmentDeleteRequest)(nil), "l2segment.L2SegmentDeleteRequest")
	proto.RegisterType((*L2SegmentDeleteRequestMsg)(nil), "l2segment.L2SegmentDeleteRequestMsg")
	proto.RegisterType((*L2SegmentDeleteResponseMsg)(nil), "l2segment.L2SegmentDeleteResponseMsg")
	proto.RegisterType((*L2SegmentGetRequest)(nil), "l2segment.L2SegmentGetRequest")
	proto.RegisterType((*L2SegmentGetRequestMsg)(nil), "l2segment.L2SegmentGetRequestMsg")
	proto.RegisterType((*L2SegmentStats)(nil), "l2segment.L2SegmentStats")
	proto.RegisterType((*L2SegmentGetResponse)(nil), "l2segment.L2SegmentGetResponse")
	proto.RegisterType((*L2SegmentGetResponseMsg)(nil), "l2segment.L2SegmentGetResponseMsg")
	proto.RegisterEnum("l2segment.BroadcastFwdPolicy", BroadcastFwdPolicy_name, BroadcastFwdPolicy_value)
	proto.RegisterEnum("l2segment.MulticastFwdPolicy", MulticastFwdPolicy_name, MulticastFwdPolicy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for L2Segment service

type L2SegmentClient interface {
	L2SegmentCreate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error)
	L2SegmentUpdate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error)
	L2SegmentDelete(ctx context.Context, in *L2SegmentDeleteRequestMsg, opts ...grpc.CallOption) (*L2SegmentDeleteResponseMsg, error)
	L2SegmentGet(ctx context.Context, in *L2SegmentGetRequestMsg, opts ...grpc.CallOption) (*L2SegmentGetResponseMsg, error)
}

type l2SegmentClient struct {
	cc *grpc.ClientConn
}

func NewL2SegmentClient(cc *grpc.ClientConn) L2SegmentClient {
	return &l2SegmentClient{cc}
}

func (c *l2SegmentClient) L2SegmentCreate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error) {
	out := new(L2SegmentResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentUpdate(ctx context.Context, in *L2SegmentRequestMsg, opts ...grpc.CallOption) (*L2SegmentResponseMsg, error) {
	out := new(L2SegmentResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentDelete(ctx context.Context, in *L2SegmentDeleteRequestMsg, opts ...grpc.CallOption) (*L2SegmentDeleteResponseMsg, error) {
	out := new(L2SegmentDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l2SegmentClient) L2SegmentGet(ctx context.Context, in *L2SegmentGetRequestMsg, opts ...grpc.CallOption) (*L2SegmentGetResponseMsg, error) {
	out := new(L2SegmentGetResponseMsg)
	err := grpc.Invoke(ctx, "/l2segment.L2Segment/L2SegmentGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for L2Segment service

type L2SegmentServer interface {
	L2SegmentCreate(context.Context, *L2SegmentRequestMsg) (*L2SegmentResponseMsg, error)
	L2SegmentUpdate(context.Context, *L2SegmentRequestMsg) (*L2SegmentResponseMsg, error)
	L2SegmentDelete(context.Context, *L2SegmentDeleteRequestMsg) (*L2SegmentDeleteResponseMsg, error)
	L2SegmentGet(context.Context, *L2SegmentGetRequestMsg) (*L2SegmentGetResponseMsg, error)
}

func RegisterL2SegmentServer(s *grpc.Server, srv L2SegmentServer) {
	s.RegisterService(&_L2Segment_serviceDesc, srv)
}

func _L2Segment_L2SegmentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentCreate(ctx, req.(*L2SegmentRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentUpdate(ctx, req.(*L2SegmentRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentDelete(ctx, req.(*L2SegmentDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _L2Segment_L2SegmentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L2SegmentGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L2SegmentServer).L2SegmentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l2segment.L2Segment/L2SegmentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L2SegmentServer).L2SegmentGet(ctx, req.(*L2SegmentGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _L2Segment_serviceDesc = grpc.ServiceDesc{
	ServiceName: "l2segment.L2Segment",
	HandlerType: (*L2SegmentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "L2SegmentCreate",
			Handler:    _L2Segment_L2SegmentCreate_Handler,
		},
		{
			MethodName: "L2SegmentUpdate",
			Handler:    _L2Segment_L2SegmentUpdate_Handler,
		},
		{
			MethodName: "L2SegmentDelete",
			Handler:    _L2Segment_L2SegmentDelete_Handler,
		},
		{
			MethodName: "L2SegmentGet",
			Handler:    _L2Segment_L2SegmentGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/l2segment.proto",
}

func (m *L2SegmentKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *L2SegmentKeyHandle_SegmentId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintL2Segment(dAtA, i, uint64(m.SegmentId))
	return i, nil
}
func (m *L2SegmentKeyHandle_L2SegmentHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	i = encodeFixed64L2Segment(dAtA, i, uint64(m.L2SegmentHandle))
	return i, nil
}
func (m *L2SegmentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n3, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.NetworkHandle) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(len(m.NetworkHandle)*8))
		for _, num := range m.NetworkHandle {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	if m.SegmentType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.SegmentType))
	}
	if m.McastFwdPolicy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.McastFwdPolicy))
	}
	if m.BcastFwdPolicy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.BcastFwdPolicy))
	}
	if m.AccessEncap != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.AccessEncap.Size()))
		n4, err := m.AccessEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.FabricEncap != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.FabricEncap.Size()))
		n5, err := m.FabricEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *L2SegmentRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L2SegmentHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64L2Segment(dAtA, i, uint64(m.L2SegmentHandle))
	}
	return i, nil
}

func (m *L2SegmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.ApiStatus))
	}
	if m.L2SegmentStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.L2SegmentStatus.Size()))
		n6, err := m.L2SegmentStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *L2SegmentResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n8, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *L2SegmentDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA10 := make([]byte, len(m.ApiStatus)*10)
		var j9 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *L2SegmentGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *L2SegmentGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L2SegmentStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumEndpoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.NumEndpoints))
	}
	return i, nil
}

func (m *L2SegmentGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintL2Segment(dAtA, i, uint64(m.Stats.Size()))
		n15, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *L2SegmentGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2SegmentGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL2Segment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64L2Segment(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32L2Segment(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintL2Segment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *L2SegmentKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *L2SegmentKeyHandle_SegmentId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovL2Segment(uint64(m.SegmentId))
	return n
}
func (m *L2SegmentKeyHandle_L2SegmentHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *L2SegmentSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if len(m.NetworkHandle) > 0 {
		n += 1 + sovL2Segment(uint64(len(m.NetworkHandle)*8)) + len(m.NetworkHandle)*8
	}
	if m.SegmentType != 0 {
		n += 1 + sovL2Segment(uint64(m.SegmentType))
	}
	if m.McastFwdPolicy != 0 {
		n += 1 + sovL2Segment(uint64(m.McastFwdPolicy))
	}
	if m.BcastFwdPolicy != 0 {
		n += 1 + sovL2Segment(uint64(m.BcastFwdPolicy))
	}
	if m.AccessEncap != nil {
		l = m.AccessEncap.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.FabricEncap != nil {
		l = m.FabricEncap.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentStatus) Size() (n int) {
	var l int
	_ = l
	if m.L2SegmentHandle != 0 {
		n += 9
	}
	return n
}

func (m *L2SegmentResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL2Segment(uint64(m.ApiStatus))
	}
	if m.L2SegmentStatus != nil {
		l = m.L2SegmentStatus.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovL2Segment(uint64(e))
		}
		n += 1 + sovL2Segment(uint64(l)) + l
	}
	return n
}

func (m *L2SegmentGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func (m *L2SegmentStats) Size() (n int) {
	var l int
	_ = l
	if m.NumEndpoints != 0 {
		n += 1 + sovL2Segment(uint64(m.NumEndpoints))
	}
	return n
}

func (m *L2SegmentGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL2Segment(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovL2Segment(uint64(l))
	}
	return n
}

func (m *L2SegmentGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL2Segment(uint64(l))
		}
	}
	return n
}

func sovL2Segment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozL2Segment(x uint64) (n int) {
	return sovL2Segment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *L2SegmentKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &L2SegmentKeyHandle_SegmentId{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.KeyOrHandle = &L2SegmentKeyHandle_L2SegmentHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.NetworkHandle = append(m.NetworkHandle, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL2Segment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.NetworkHandle = append(m.NetworkHandle, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkHandle", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentType", wireType)
			}
			m.SegmentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentType |= (L2SegmentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McastFwdPolicy", wireType)
			}
			m.McastFwdPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McastFwdPolicy |= (MulticastFwdPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcastFwdPolicy", wireType)
			}
			m.BcastFwdPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BcastFwdPolicy |= (BroadcastFwdPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessEncap == nil {
				m.AccessEncap = &EncapInfo{}
			}
			if err := m.AccessEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FabricEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FabricEncap == nil {
				m.FabricEncap = &EncapInfo{}
			}
			if err := m.FabricEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentHandle", wireType)
			}
			m.L2SegmentHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.L2SegmentHandle = uint64(dAtA[iNdEx-8])
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.L2SegmentHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegmentStatus == nil {
				m.L2SegmentStatus = &L2SegmentStatus{}
			}
			if err := m.L2SegmentStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L2SegmentResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL2Segment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowL2Segment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L2SegmentKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L2SegmentGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEndpoints", wireType)
			}
			m.NumEndpoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEndpoints |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &L2SegmentSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L2SegmentStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &L2SegmentStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2SegmentGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2SegmentGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2SegmentGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL2Segment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L2SegmentGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL2Segment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL2Segment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipL2Segment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowL2Segment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL2Segment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthL2Segment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowL2Segment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipL2Segment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthL2Segment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowL2Segment   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nic/proto/hal/l2segment.proto", fileDescriptorL2Segment) }

var fileDescriptorL2Segment = []byte{
	// 893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0x9b, 0x6e, 0xb6, 0x7d, 0xf9, 0xd3, 0xec, 0xb0, 0x40, 0x1a, 0x51, 0x37, 0x6b, 0xa8,
	0x14, 0x16, 0xd4, 0x48, 0x5e, 0x21, 0x10, 0x70, 0x69, 0x9a, 0x74, 0x1b, 0x91, 0x6c, 0xa2, 0x69,
	0x96, 0x05, 0x2e, 0xc6, 0x71, 0xa6, 0xad, 0x69, 0x62, 0x1b, 0xcf, 0x84, 0x2a, 0x9f, 0x81, 0x13,
	0x12, 0x42, 0x7c, 0x24, 0x8e, 0x9c, 0x39, 0x20, 0x54, 0x0e, 0xdc, 0xfb, 0x09, 0x90, 0x67, 0x26,
	0xb6, 0xe3, 0x38, 0xad, 0x84, 0x90, 0xe0, 0xe6, 0x79, 0xef, 0xf7, 0x7e, 0xef, 0xcf, 0xfc, 0xde,
	0x24, 0xb0, 0xe7, 0xd8, 0x56, 0xc3, 0xf3, 0x5d, 0xe6, 0x36, 0x2e, 0xcd, 0x49, 0x63, 0xa2, 0x53,
	0x72, 0x31, 0x25, 0x0e, 0x3b, 0xe4, 0x36, 0xb4, 0x1d, 0x1a, 0xaa, 0xaf, 0x47, 0x48, 0x36, 0xf7,
	0x08, 0x15, 0x08, 0x8d, 0x02, 0xea, 0xea, 0x67, 0x02, 0xf3, 0x19, 0x99, 0x9f, 0x9a, 0xce, 0x78,
	0x42, 0xd0, 0x3e, 0x80, 0x8c, 0x33, 0xec, 0x71, 0x45, 0xa9, 0x29, 0xf5, 0xe2, 0x69, 0x06, 0x6f,
	0x4b, 0x5b, 0x67, 0x8c, 0xde, 0x83, 0x72, 0x48, 0x6d, 0x5c, 0xf2, 0xa0, 0xca, 0x46, 0x4d, 0xa9,
	0xe7, 0x4e, 0x33, 0x78, 0x27, 0xf4, 0x08, 0xb6, 0xe6, 0x0e, 0x14, 0xaf, 0xc8, 0xdc, 0x70, 0x7d,
	0x89, 0xd4, 0xfe, 0xca, 0x42, 0x31, 0xcc, 0x7a, 0xe6, 0x11, 0x0b, 0x1d, 0xc0, 0xe6, 0x94, 0x30,
	0x93, 0xa7, 0xca, 0xeb, 0x8f, 0x0e, 0x45, 0x89, 0xfd, 0xd1, 0x37, 0xc4, 0x62, 0x3d, 0xc2, 0x4c,
	0xcc, 0xdd, 0xe8, 0x2c, 0xc1, 0xc4, 0x73, 0xe6, 0xf5, 0xbd, 0xc3, 0xa8, 0xf1, 0xd5, 0x6e, 0x9a,
	0xe5, 0xdb, 0xdf, 0xf7, 0x0b, 0xdf, 0x11, 0xc7, 0xb6, 0xc8, 0xc7, 0xda, 0x15, 0x99, 0x6b, 0x38,
	0x7f, 0x45, 0xe6, 0x7d, 0x5f, 0x36, 0x7b, 0x00, 0x25, 0x87, 0xb0, 0x6b, 0xd7, 0xbf, 0x5a, 0xb0,
	0x66, 0x6b, 0xd9, 0x7a, 0x0e, 0x17, 0xa5, 0x55, 0xc2, 0x3e, 0x84, 0xc2, 0xa2, 0xe1, 0xa0, 0xba,
	0xca, 0x66, 0x4d, 0xa9, 0x97, 0xf4, 0xc7, 0xb2, 0xd4, 0x30, 0xed, 0x70, 0xee, 0x11, 0x9c, 0xa7,
	0xd1, 0x01, 0x3d, 0x87, 0xf2, 0xd4, 0x32, 0x29, 0x33, 0xce, 0xaf, 0xc7, 0x86, 0xe7, 0x4e, 0x6c,
	0x6b, 0x5e, 0x79, 0xc0, 0x83, 0xe3, 0x75, 0xf7, 0x66, 0x13, 0x66, 0x07, 0xb0, 0x93, 0xeb, 0xf1,
	0x80, 0x83, 0x70, 0x69, 0xba, 0x74, 0x0e, 0x88, 0x46, 0x49, 0xa2, 0xdc, 0x0a, 0x51, 0xd3, 0x77,
	0xcd, 0x71, 0x82, 0x68, 0xb4, 0x4c, 0xf4, 0x0c, 0x0a, 0xa6, 0x65, 0x11, 0x4a, 0x0d, 0xe2, 0x58,
	0xa6, 0x57, 0x79, 0xc8, 0xa7, 0x58, 0x96, 0xad, 0xb4, 0x03, 0x5b, 0xc7, 0x39, 0x77, 0x71, 0x5e,
	0xa0, 0xb8, 0x21, 0x08, 0x3a, 0x37, 0x47, 0xbe, 0x6d, 0xc9, 0xa0, 0xad, 0x75, 0x41, 0x02, 0xc5,
	0x0d, 0x5a, 0x07, 0x5e, 0x0b, 0x27, 0x83, 0xc9, 0xb7, 0x33, 0x42, 0x59, 0x8f, 0x5e, 0x20, 0x1d,
	0x1e, 0xfa, 0xe2, 0x54, 0x51, 0x6a, 0xd9, 0x7a, 0x5e, 0xaf, 0xa4, 0xdd, 0x60, 0xa0, 0x0c, 0xbc,
	0x00, 0x6a, 0x9f, 0xc2, 0x4e, 0xe4, 0x61, 0x26, 0x9b, 0x51, 0xf4, 0x6e, 0x8a, 0x0a, 0x03, 0x05,
	0xe5, 0x56, 0x34, 0xa8, 0x7d, 0xaf, 0xc0, 0xa3, 0x58, 0x25, 0xd4, 0x73, 0x1d, 0x4a, 0x50, 0x03,
	0xc0, 0xf4, 0x6c, 0x83, 0x72, 0x3a, 0x1e, 0x5a, 0x0a, 0x3b, 0x3a, 0xf2, 0x6c, 0x91, 0x06, 0x6f,
	0x9b, 0x8b, 0x4f, 0xd4, 0x8e, 0x67, 0x94, 0x61, 0x42, 0x83, 0xd5, 0xd4, 0x0e, 0x04, 0x41, 0x54,
	0x8d, 0x30, 0x68, 0x03, 0x78, 0xbc, 0x52, 0x4c, 0x30, 0x97, 0x8f, 0x60, 0xcb, 0x97, 0x47, 0x39,
	0x98, 0xb7, 0xd2, 0x68, 0x17, 0x21, 0x38, 0x44, 0x6b, 0x3f, 0x2a, 0xf0, 0x46, 0xe8, 0x6f, 0x91,
	0x09, 0x61, 0x44, 0xce, 0xfb, 0xbf, 0xdc, 0x2d, 0xed, 0x0b, 0xd8, 0x4d, 0xaf, 0x2a, 0xe8, 0xf6,
	0x93, 0xa4, 0x0a, 0x9e, 0xa4, 0xe5, 0x5a, 0x0a, 0x8b, 0xe4, 0xd0, 0x83, 0xea, 0x0a, 0x24, 0x1a,
	0x64, 0xf2, 0x62, 0xb3, 0xf7, 0x5c, 0xac, 0xf6, 0x83, 0x12, 0x53, 0xea, 0x73, 0xc2, 0xfe, 0x0f,
	0xc3, 0xc3, 0xb1, 0x2b, 0x8d, 0x4a, 0x12, 0x3a, 0x49, 0x4c, 0x4e, 0x4d, 0x4b, 0x14, 0xc5, 0x44,
	0x63, 0xfb, 0x00, 0x4a, 0x4b, 0xea, 0xa4, 0xe8, 0x6d, 0x28, 0x3a, 0xb3, 0xa9, 0x41, 0x9c, 0xb1,
	0xe7, 0xda, 0x0e, 0x13, 0x6b, 0x50, 0xc4, 0x05, 0x67, 0x36, 0x6d, 0x2f, 0x6c, 0xda, 0x6f, 0x4a,
	0x4c, 0xb1, 0x9c, 0xf7, 0x9f, 0x6e, 0xd0, 0xfb, 0xb0, 0x49, 0x3d, 0x62, 0xc9, 0x01, 0xad, 0xdf,
	0x7b, 0x8e, 0x42, 0x3a, 0xe4, 0x24, 0x75, 0xf6, 0xde, 0x2d, 0x93, 0x48, 0xd4, 0x80, 0x07, 0xc1,
	0x17, 0xe5, 0x2f, 0x74, 0x5e, 0xdf, 0x5d, 0x17, 0x42, 0xb1, 0xc0, 0x69, 0x9f, 0xc3, 0x9b, 0x69,
	0xbd, 0x09, 0x89, 0x26, 0x17, 0x72, 0x7f, 0xed, 0xa4, 0x93, 0x3b, 0xf9, 0xd4, 0x07, 0xb4, 0xfa,
	0x18, 0xa3, 0x3d, 0xd8, 0x6d, 0xe2, 0xfe, 0x51, 0xeb, 0xf8, 0xe8, 0x6c, 0x68, 0x9c, 0xbc, 0x6a,
	0x19, 0x83, 0x7e, 0xb7, 0x73, 0xfc, 0xa5, 0xf1, 0xa2, 0xff, 0xa2, 0x5d, 0xce, 0xac, 0x75, 0xb7,
	0x70, 0x7f, 0x50, 0x56, 0x90, 0x0a, 0xd5, 0x54, 0xf7, 0x49, 0xb7, 0xdf, 0x6f, 0x95, 0x37, 0x9e,
	0xfe, 0xa4, 0x00, 0x5a, 0xfd, 0x29, 0x09, 0x58, 0x7b, 0x2f, 0xbb, 0xc3, 0xce, 0x9a, 0xa4, 0x2a,
	0x54, 0x53, 0xdd, 0x82, 0x55, 0x41, 0x1a, 0xa8, 0xa9, 0x7e, 0xdc, 0x1e, 0x74, 0x3b, 0xc7, 0x47,
	0xc3, 0x76, 0x79, 0x63, 0x6d, 0x0a, 0x5e, 0x78, 0x56, 0xbf, 0xdd, 0x80, 0xed, 0x70, 0x5e, 0x68,
	0x18, 0x7b, 0xcc, 0x8f, 0x7d, 0x62, 0x32, 0x82, 0xd4, 0xf4, 0x97, 0x6e, 0xa1, 0xf9, 0xea, 0xfe,
	0x5d, 0x2f, 0x61, 0x8f, 0x5e, 0x68, 0x99, 0x25, 0xd6, 0x97, 0xde, 0xf8, 0x5f, 0x62, 0xfd, 0x3a,
	0xc6, 0x2a, 0x5e, 0x1a, 0xf4, 0xce, 0xbd, 0x0f, 0x55, 0xc0, 0x7d, 0x70, 0x17, 0x2a, 0x9e, 0xe1,
	0x15, 0x14, 0xe2, 0x52, 0x42, 0x4f, 0xee, 0xde, 0xe6, 0x80, 0x5b, 0xbb, 0x47, 0x86, 0x9c, 0xb8,
	0x59, 0xfd, 0xe5, 0x46, 0x55, 0x7e, 0xbd, 0x51, 0x95, 0x3f, 0x6e, 0x54, 0xe5, 0xe7, 0x3f, 0xd5,
	0xcc, 0x57, 0x5b, 0x97, 0xe6, 0x84, 0xff, 0xf3, 0x1b, 0x64, 0x46, 0x39, 0xfe, 0xf1, 0xec, 0xef,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x68, 0xc2, 0x3d, 0xda, 0x45, 0x0a, 0x00, 0x00,
}
