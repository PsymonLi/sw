// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// NAT pool configuration
// NOTE: addresses inside the NAT pool are "owned" by the device, so device is
// expected to advertise the routes for the same and respond to ARP requests
type NatPoolSpec struct {
	KeyOrHandle *NatPoolKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Address     []*Address        `protobuf:"bytes,2,rep,name=address" json:"address,omitempty" venice:mandatory`
	PortRange   *L4PortRange      `protobuf:"bytes,3,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *NatPoolSpec) Reset()                    { *m = NatPoolSpec{} }
func (m *NatPoolSpec) String() string            { return proto.CompactTextString(m) }
func (*NatPoolSpec) ProtoMessage()               {}
func (*NatPoolSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

func (m *NatPoolSpec) GetKeyOrHandle() *NatPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatPoolSpec) GetAddress() []*Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NatPoolSpec) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

type NatPoolRequestMsg struct {
	Request []*NatPoolSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPoolRequestMsg) Reset()                    { *m = NatPoolRequestMsg{} }
func (m *NatPoolRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolRequestMsg) ProtoMessage()               {}
func (*NatPoolRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{1} }

func (m *NatPoolRequestMsg) GetRequest() []*NatPoolSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPoolStatus is the operational status of a given NAT pool
// TODO: Add NAT mappings here
type NatPoolStatus struct {
	PoolHandle uint64 `protobuf:"fixed64,1,opt,name=pool_handle,json=poolHandle,proto3" json:"pool_handle,omitempty"`
}

func (m *NatPoolStatus) Reset()                    { *m = NatPoolStatus{} }
func (m *NatPoolStatus) String() string            { return proto.CompactTextString(m) }
func (*NatPoolStatus) ProtoMessage()               {}
func (*NatPoolStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{2} }

func (m *NatPoolStatus) GetPoolHandle() uint64 {
	if m != nil {
		return m.PoolHandle
	}
	return 0
}

// NatPoolResponse is response to NatPoolSpec
type NatPoolResponse struct {
	ApiStatus  ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	PoolStatus *NatPoolStatus `protobuf:"bytes,2,opt,name=pool_status,json=poolStatus" json:"pool_status,omitempty"`
}

func (m *NatPoolResponse) Reset()                    { *m = NatPoolResponse{} }
func (m *NatPoolResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPoolResponse) ProtoMessage()               {}
func (*NatPoolResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{3} }

func (m *NatPoolResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPoolResponse) GetPoolStatus() *NatPoolStatus {
	if m != nil {
		return m.PoolStatus
	}
	return nil
}

// NatPoolResponseMsg is batched response to NatPoolRequestMsg
type NatPoolResponseMsg struct {
	Response []*NatPoolResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPoolResponseMsg) Reset()                    { *m = NatPoolResponseMsg{} }
func (m *NatPoolResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolResponseMsg) ProtoMessage()               {}
func (*NatPoolResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{4} }

func (m *NatPoolResponseMsg) GetResponse() []*NatPoolResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPoolDeleteRequest is used to delete a NAT pool
type NatPoolDeleteRequest struct {
	KeyOrHandle *NatPoolKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatPoolDeleteRequest) Reset()                    { *m = NatPoolDeleteRequest{} }
func (m *NatPoolDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPoolDeleteRequest) ProtoMessage()               {}
func (*NatPoolDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{5} }

func (m *NatPoolDeleteRequest) GetKeyOrHandle() *NatPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPoolDeleteRequestMsg is used to delete batch of NAT pools
type NatPoolDeleteRequestMsg struct {
	Request []*NatPoolDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPoolDeleteRequestMsg) Reset()                    { *m = NatPoolDeleteRequestMsg{} }
func (m *NatPoolDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolDeleteRequestMsg) ProtoMessage()               {}
func (*NatPoolDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{6} }

func (m *NatPoolDeleteRequestMsg) GetRequest() []*NatPoolDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPoolDeleteResponse is response to NatPoolDeleteRequest
type NatPoolDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *NatPoolDeleteResponse) Reset()                    { *m = NatPoolDeleteResponse{} }
func (m *NatPoolDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPoolDeleteResponse) ProtoMessage()               {}
func (*NatPoolDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{7} }

func (m *NatPoolDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NatPoolDeleteResponseMsg is batched response to NatPoolDeleteRequestMsg
type NatPoolDeleteResponseMsg struct {
	Response []*NatPoolDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPoolDeleteResponseMsg) Reset()                    { *m = NatPoolDeleteResponseMsg{} }
func (m *NatPoolDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolDeleteResponseMsg) ProtoMessage()               {}
func (*NatPoolDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{8} }

func (m *NatPoolDeleteResponseMsg) GetResponse() []*NatPoolDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPoolGetRequest is used to get all the information about a pool
type NatPoolGetRequest struct {
	KeyOrHandle *NatPoolKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatPoolGetRequest) Reset()                    { *m = NatPoolGetRequest{} }
func (m *NatPoolGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPoolGetRequest) ProtoMessage()               {}
func (*NatPoolGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{9} }

func (m *NatPoolGetRequest) GetKeyOrHandle() *NatPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPoolGetRequestMsg is batched GET requests for NAT pools
type NatPoolGetRequestMsg struct {
	Request []*NatPoolGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPoolGetRequestMsg) Reset()                    { *m = NatPoolGetRequestMsg{} }
func (m *NatPoolGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolGetRequestMsg) ProtoMessage()               {}
func (*NatPoolGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{10} }

func (m *NatPoolGetRequestMsg) GetRequest() []*NatPoolGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPoolStats is the statistics object for NAT pool
type NatPoolStats struct {
}

func (m *NatPoolStats) Reset()                    { *m = NatPoolStats{} }
func (m *NatPoolStats) String() string            { return proto.CompactTextString(m) }
func (*NatPoolStats) ProtoMessage()               {}
func (*NatPoolStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{11} }

// NatPoolGetResponse captures all the information for a given NAT pool
type NatPoolGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatPoolSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatPoolStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatPoolStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatPoolGetResponse) Reset()                    { *m = NatPoolGetResponse{} }
func (m *NatPoolGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPoolGetResponse) ProtoMessage()               {}
func (*NatPoolGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{12} }

func (m *NatPoolGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPoolGetResponse) GetSpec() *NatPoolSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatPoolGetResponse) GetStatus() *NatPoolStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatPoolGetResponse) GetStats() *NatPoolStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatPoolGetResponseMsg is the batched response to NatPoolGetRequestMsg
type NatPoolGetResponseMsg struct {
	Response []*NatPoolGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPoolGetResponseMsg) Reset()                    { *m = NatPoolGetResponseMsg{} }
func (m *NatPoolGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPoolGetResponseMsg) ProtoMessage()               {}
func (*NatPoolGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{13} }

func (m *NatPoolGetResponseMsg) GetResponse() []*NatPoolGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type NatRuleAction struct {
	SrcNatAction NatAction         `protobuf:"varint,1,opt,name=src_nat_action,json=srcNatAction,proto3,enum=types.NatAction" json:"src_nat_action,omitempty" venice:immutable`
	DstNatAction NatAction         `protobuf:"varint,2,opt,name=dst_nat_action,json=dstNatAction,proto3,enum=types.NatAction" json:"dst_nat_action,omitempty" venice:immutable`
	SrcNatPool   *NatPoolKeyHandle `protobuf:"bytes,3,opt,name=src_nat_pool,json=srcNatPool" json:"src_nat_pool,omitempty" venice:ref,venice:constraints={nat.NatRuleAction.src_nat_action!=nat_pb2.NAT_TYPE_NONE}`
	DstNatPool   *NatPoolKeyHandle `protobuf:"bytes,4,opt,name=dst_nat_pool,json=dstNatPool" json:"dst_nat_pool,omitempty" venice:ref,venice:constraints={nat.NatRuleAction.dst_nat_action!=nat_pb2.NAT_TYPE_NONE}`
}

func (m *NatRuleAction) Reset()                    { *m = NatRuleAction{} }
func (m *NatRuleAction) String() string            { return proto.CompactTextString(m) }
func (*NatRuleAction) ProtoMessage()               {}
func (*NatRuleAction) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{14} }

func (m *NatRuleAction) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleAction) GetDstNatAction() NatAction {
	if m != nil {
		return m.DstNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleAction) GetSrcNatPool() *NatPoolKeyHandle {
	if m != nil {
		return m.SrcNatPool
	}
	return nil
}

func (m *NatRuleAction) GetDstNatPool() *NatPoolKeyHandle {
	if m != nil {
		return m.DstNatPool
	}
	return nil
}

// NatRuleSpec is the user intent for the NAT rule
type NatRuleSpec struct {
	RuleId uint64         `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Match  *RuleMatch     `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
	Action *NatRuleAction `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
}

func (m *NatRuleSpec) Reset()                    { *m = NatRuleSpec{} }
func (m *NatRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*NatRuleSpec) ProtoMessage()               {}
func (*NatRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{15} }

func (m *NatRuleSpec) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *NatRuleSpec) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *NatRuleSpec) GetAction() *NatRuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// NatPolicySpec captures the NAT policy which is a group of NAT rules
type NatPolicySpec struct {
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Rules       []*NatRuleSpec      `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty" venice:ref`
}

func (m *NatPolicySpec) Reset()                    { *m = NatPolicySpec{} }
func (m *NatPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*NatPolicySpec) ProtoMessage()               {}
func (*NatPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{16} }

func (m *NatPolicySpec) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatPolicySpec) GetRules() []*NatRuleSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// NatPolicyRequestMsg is the batched NAT policy
type NatPolicyRequestMsg struct {
	Request []*NatPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyRequestMsg) Reset()                    { *m = NatPolicyRequestMsg{} }
func (m *NatPolicyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyRequestMsg) ProtoMessage()               {}
func (*NatPolicyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{17} }

func (m *NatPolicyRequestMsg) GetRequest() []*NatPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPolicyStatus is the operational status of NatPolicySpec
type NatPolicyStatus struct {
	NatPolicyHandle uint64 `protobuf:"fixed64,1,opt,name=nat_policy_handle,json=natPolicyHandle,proto3" json:"nat_policy_handle,omitempty"`
}

func (m *NatPolicyStatus) Reset()                    { *m = NatPolicyStatus{} }
func (m *NatPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyStatus) ProtoMessage()               {}
func (*NatPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{18} }

func (m *NatPolicyStatus) GetNatPolicyHandle() uint64 {
	if m != nil {
		return m.NatPolicyHandle
	}
	return 0
}

// NatPolicyResponse is response to NatPolicySpec
type NatPolicyResponse struct {
	ApiStatus    ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	PolicyStatus *NatPolicyStatus `protobuf:"bytes,2,opt,name=policy_status,json=policyStatus" json:"policy_status,omitempty"`
}

func (m *NatPolicyResponse) Reset()                    { *m = NatPolicyResponse{} }
func (m *NatPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyResponse) ProtoMessage()               {}
func (*NatPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{19} }

func (m *NatPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyResponse) GetPolicyStatus() *NatPolicyStatus {
	if m != nil {
		return m.PolicyStatus
	}
	return nil
}

// NatPolicyResponseMsg is the batched NatPolicyResponse
type NatPolicyResponseMsg struct {
	Response []*NatPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyResponseMsg) Reset()                    { *m = NatPolicyResponseMsg{} }
func (m *NatPolicyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyResponseMsg) ProtoMessage()               {}
func (*NatPolicyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{20} }

func (m *NatPolicyResponseMsg) GetResponse() []*NatPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPolicyDeleteRequest is used to delete a NAT policy
type NatPolicyDeleteRequest struct {
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatPolicyDeleteRequest) Reset()                    { *m = NatPolicyDeleteRequest{} }
func (m *NatPolicyDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteRequest) ProtoMessage()               {}
func (*NatPolicyDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{21} }

func (m *NatPolicyDeleteRequest) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPolicyDeleteRequestMsg is batched NatPolicyDeleteRequest
type NatPolicyDeleteRequestMsg struct {
	Request []*NatPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyDeleteRequestMsg) Reset()                    { *m = NatPolicyDeleteRequestMsg{} }
func (m *NatPolicyDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteRequestMsg) ProtoMessage()               {}
func (*NatPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{22} }

func (m *NatPolicyDeleteRequestMsg) GetRequest() []*NatPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPolicyDeleteResponse is response to NatPolicyDeleteRequest
type NatPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *NatPolicyDeleteResponse) Reset()                    { *m = NatPolicyDeleteResponse{} }
func (m *NatPolicyDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteResponse) ProtoMessage()               {}
func (*NatPolicyDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{23} }

func (m *NatPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NatPolicyDeleteResponseMsg is batched response to NatPolicyDeleteRequestMsg
type NatPolicyDeleteResponseMsg struct {
	Response []*NatPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyDeleteResponseMsg) Reset()                    { *m = NatPolicyDeleteResponseMsg{} }
func (m *NatPolicyDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteResponseMsg) ProtoMessage()               {}
func (*NatPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{24} }

func (m *NatPolicyDeleteResponseMsg) GetResponse() []*NatPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPolicyGetRequest is used to get information about a NAT policy
type NatPolicyGetRequest struct {
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatPolicyGetRequest) Reset()                    { *m = NatPolicyGetRequest{} }
func (m *NatPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetRequest) ProtoMessage()               {}
func (*NatPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{25} }

func (m *NatPolicyGetRequest) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPolicyGetRequestMsg is batched GET request
type NatPolicyGetRequestMsg struct {
	Request []*NatPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyGetRequestMsg) Reset()                    { *m = NatPolicyGetRequestMsg{} }
func (m *NatPolicyGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetRequestMsg) ProtoMessage()               {}
func (*NatPolicyGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{26} }

func (m *NatPolicyGetRequestMsg) GetRequest() []*NatPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// per rule stats
type NatRuleStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions   uint32 `protobuf:"varint,2,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,3,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *NatRuleStats) Reset()                    { *m = NatRuleStats{} }
func (m *NatRuleStats) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStats) ProtoMessage()               {}
func (*NatRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{27} }

func (m *NatRuleStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// per policy stats
type NatPolicyStats struct {
	Stats []*NatRuleStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *NatPolicyStats) Reset()                    { *m = NatPolicyStats{} }
func (m *NatPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyStats) ProtoMessage()               {}
func (*NatPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{28} }

func (m *NatPolicyStats) GetStats() []*NatRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatPolicyGetResponse catpures all information about NAT policy
type NatPolicyGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatPolicyGetResponse) Reset()                    { *m = NatPolicyGetResponse{} }
func (m *NatPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetResponse) ProtoMessage()               {}
func (*NatPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{29} }

func (m *NatPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyGetResponse) GetSpec() *NatPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatPolicyGetResponse) GetStatus() *NatPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatPolicyGetResponse) GetStats() *NatPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatPolicyGetResponseMsg is batched response to NatPolicyGetRequestMsg
type NatPolicyGetResponseMsg struct {
	Response []*NatPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyGetResponseMsg) Reset()                    { *m = NatPolicyGetResponseMsg{} }
func (m *NatPolicyGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetResponseMsg) ProtoMessage()               {}
func (*NatPolicyGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{30} }

func (m *NatPolicyGetResponseMsg) GetResponse() []*NatPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatMappingSpec is the user intent for the NAT mapping
type NatMappingSpec struct {
	KeyOrHandle *NatMappingKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	NatPool     *NatPoolKeyHandle    `protobuf:"bytes,2,opt,name=nat_pool,json=natPool" json:"nat_pool,omitempty" venice:mandatory, venice:ref`
	Bidir       bool                 `protobuf:"varint,3,opt,name=bidir,proto3" json:"bidir,omitempty"`
}

func (m *NatMappingSpec) Reset()                    { *m = NatMappingSpec{} }
func (m *NatMappingSpec) String() string            { return proto.CompactTextString(m) }
func (*NatMappingSpec) ProtoMessage()               {}
func (*NatMappingSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{31} }

func (m *NatMappingSpec) GetKeyOrHandle() *NatMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatMappingSpec) GetNatPool() *NatPoolKeyHandle {
	if m != nil {
		return m.NatPool
	}
	return nil
}

func (m *NatMappingSpec) GetBidir() bool {
	if m != nil {
		return m.Bidir
	}
	return false
}

// NatMappingRequestMsg is the batched add or modify of NAT mapping request
type NatMappingRequestMsg struct {
	Request []*NatMappingSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatMappingRequestMsg) Reset()                    { *m = NatMappingRequestMsg{} }
func (m *NatMappingRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingRequestMsg) ProtoMessage()               {}
func (*NatMappingRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{32} }

func (m *NatMappingRequestMsg) GetRequest() []*NatMappingSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatMappingStatus reflects the current operational status of a NAT mapping
type NatMappingStatus struct {
	Handle     uint64     `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	MappedIp   *IPAddress `protobuf:"bytes,2,opt,name=mapped_ip,json=mappedIp" json:"mapped_ip,omitempty"`
	Configured bool       `protobuf:"varint,3,opt,name=configured,proto3" json:"configured,omitempty"`
	FlowCount  uint32     `protobuf:"varint,4,opt,name=flow_count,json=flowCount,proto3" json:"flow_count,omitempty"`
}

func (m *NatMappingStatus) Reset()                    { *m = NatMappingStatus{} }
func (m *NatMappingStatus) String() string            { return proto.CompactTextString(m) }
func (*NatMappingStatus) ProtoMessage()               {}
func (*NatMappingStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{33} }

func (m *NatMappingStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *NatMappingStatus) GetMappedIp() *IPAddress {
	if m != nil {
		return m.MappedIp
	}
	return nil
}

func (m *NatMappingStatus) GetConfigured() bool {
	if m != nil {
		return m.Configured
	}
	return false
}

func (m *NatMappingStatus) GetFlowCount() uint32 {
	if m != nil {
		return m.FlowCount
	}
	return 0
}

// NatMappingResponse is the response to NatMappingSpec
type NatMappingResponse struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *NatMappingStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *NatMappingResponse) Reset()                    { *m = NatMappingResponse{} }
func (m *NatMappingResponse) String() string            { return proto.CompactTextString(m) }
func (*NatMappingResponse) ProtoMessage()               {}
func (*NatMappingResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{34} }

func (m *NatMappingResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatMappingResponse) GetStatus() *NatMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// NatMappingResponseMsg is batched response to NatMappingRequestMsg
type NatMappingResponseMsg struct {
	Response []*NatMappingResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatMappingResponseMsg) Reset()                    { *m = NatMappingResponseMsg{} }
func (m *NatMappingResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingResponseMsg) ProtoMessage()               {}
func (*NatMappingResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{35} }

func (m *NatMappingResponseMsg) GetResponse() []*NatMappingResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatMappingDeleteRequest is used to delete a NAT mapping
type NatMappingDeleteRequest struct {
	KeyOrHandle *NatMappingKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatMappingDeleteRequest) Reset()                    { *m = NatMappingDeleteRequest{} }
func (m *NatMappingDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*NatMappingDeleteRequest) ProtoMessage()               {}
func (*NatMappingDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{36} }

func (m *NatMappingDeleteRequest) GetKeyOrHandle() *NatMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatMappingDeleteRequestMsg is used to delete batch of NAT mappings
type NatMappingDeleteRequestMsg struct {
	Request []*NatMappingDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatMappingDeleteRequestMsg) Reset()                    { *m = NatMappingDeleteRequestMsg{} }
func (m *NatMappingDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingDeleteRequestMsg) ProtoMessage()               {}
func (*NatMappingDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{37} }

func (m *NatMappingDeleteRequestMsg) GetRequest() []*NatMappingDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatMappingDeleteResponse is response to NatMappingDeleteRequest
type NatMappingDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *NatMappingDeleteResponse) Reset()                    { *m = NatMappingDeleteResponse{} }
func (m *NatMappingDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*NatMappingDeleteResponse) ProtoMessage()               {}
func (*NatMappingDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{38} }

func (m *NatMappingDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NatMappingDeleteResponseMsg is batched response to NatMappingDeleteRequestMsg
type NatMappingDeleteResponseMsg struct {
	Response []*NatMappingDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatMappingDeleteResponseMsg) Reset()                    { *m = NatMappingDeleteResponseMsg{} }
func (m *NatMappingDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingDeleteResponseMsg) ProtoMessage()               {}
func (*NatMappingDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{39} }

func (m *NatMappingDeleteResponseMsg) GetResponse() []*NatMappingDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatMappingGetRequest is used to get information about a NAT mapping
type NatMappingGetRequest struct {
	KeyOrHandle *NatMappingKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *NatMappingGetRequest) Reset()                    { *m = NatMappingGetRequest{} }
func (m *NatMappingGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatMappingGetRequest) ProtoMessage()               {}
func (*NatMappingGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{40} }

func (m *NatMappingGetRequest) GetKeyOrHandle() *NatMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatMappingGetRequestMsg is batched GET request for NAT mappings
type NatMappingGetRequestMsg struct {
	Request []*NatMappingGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatMappingGetRequestMsg) Reset()                    { *m = NatMappingGetRequestMsg{} }
func (m *NatMappingGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingGetRequestMsg) ProtoMessage()               {}
func (*NatMappingGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{41} }

func (m *NatMappingGetRequestMsg) GetRequest() []*NatMappingGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatMappingStats is the statistics object for each NAT mapping
type NatMappingStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions   uint32 `protobuf:"varint,2,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,3,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *NatMappingStats) Reset()                    { *m = NatMappingStats{} }
func (m *NatMappingStats) String() string            { return proto.CompactTextString(m) }
func (*NatMappingStats) ProtoMessage()               {}
func (*NatMappingStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{42} }

func (m *NatMappingStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatMappingStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatMappingStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// NatMappingGetResponse reflects all the information about a NAT mapping
type NatMappingGetResponse struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatMappingSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatMappingStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatMappingStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatMappingGetResponse) Reset()                    { *m = NatMappingGetResponse{} }
func (m *NatMappingGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatMappingGetResponse) ProtoMessage()               {}
func (*NatMappingGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{43} }

func (m *NatMappingGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatMappingGetResponse) GetSpec() *NatMappingSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatMappingGetResponse) GetStatus() *NatMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatMappingGetResponse) GetStats() *NatMappingStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatMappingGetResponseMsg is batched response to NatMappingGetRequestMsg
type NatMappingGetResponseMsg struct {
	Response []*NatMappingGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatMappingGetResponseMsg) Reset()                    { *m = NatMappingGetResponseMsg{} }
func (m *NatMappingGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatMappingGetResponseMsg) ProtoMessage()               {}
func (*NatMappingGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{44} }

func (m *NatMappingGetResponseMsg) GetResponse() []*NatMappingGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*NatPoolSpec)(nil), "nat.NatPoolSpec")
	proto.RegisterType((*NatPoolRequestMsg)(nil), "nat.NatPoolRequestMsg")
	proto.RegisterType((*NatPoolStatus)(nil), "nat.NatPoolStatus")
	proto.RegisterType((*NatPoolResponse)(nil), "nat.NatPoolResponse")
	proto.RegisterType((*NatPoolResponseMsg)(nil), "nat.NatPoolResponseMsg")
	proto.RegisterType((*NatPoolDeleteRequest)(nil), "nat.NatPoolDeleteRequest")
	proto.RegisterType((*NatPoolDeleteRequestMsg)(nil), "nat.NatPoolDeleteRequestMsg")
	proto.RegisterType((*NatPoolDeleteResponse)(nil), "nat.NatPoolDeleteResponse")
	proto.RegisterType((*NatPoolDeleteResponseMsg)(nil), "nat.NatPoolDeleteResponseMsg")
	proto.RegisterType((*NatPoolGetRequest)(nil), "nat.NatPoolGetRequest")
	proto.RegisterType((*NatPoolGetRequestMsg)(nil), "nat.NatPoolGetRequestMsg")
	proto.RegisterType((*NatPoolStats)(nil), "nat.NatPoolStats")
	proto.RegisterType((*NatPoolGetResponse)(nil), "nat.NatPoolGetResponse")
	proto.RegisterType((*NatPoolGetResponseMsg)(nil), "nat.NatPoolGetResponseMsg")
	proto.RegisterType((*NatRuleAction)(nil), "nat.NatRuleAction")
	proto.RegisterType((*NatRuleSpec)(nil), "nat.NatRuleSpec")
	proto.RegisterType((*NatPolicySpec)(nil), "nat.NatPolicySpec")
	proto.RegisterType((*NatPolicyRequestMsg)(nil), "nat.NatPolicyRequestMsg")
	proto.RegisterType((*NatPolicyStatus)(nil), "nat.NatPolicyStatus")
	proto.RegisterType((*NatPolicyResponse)(nil), "nat.NatPolicyResponse")
	proto.RegisterType((*NatPolicyResponseMsg)(nil), "nat.NatPolicyResponseMsg")
	proto.RegisterType((*NatPolicyDeleteRequest)(nil), "nat.NatPolicyDeleteRequest")
	proto.RegisterType((*NatPolicyDeleteRequestMsg)(nil), "nat.NatPolicyDeleteRequestMsg")
	proto.RegisterType((*NatPolicyDeleteResponse)(nil), "nat.NatPolicyDeleteResponse")
	proto.RegisterType((*NatPolicyDeleteResponseMsg)(nil), "nat.NatPolicyDeleteResponseMsg")
	proto.RegisterType((*NatPolicyGetRequest)(nil), "nat.NatPolicyGetRequest")
	proto.RegisterType((*NatPolicyGetRequestMsg)(nil), "nat.NatPolicyGetRequestMsg")
	proto.RegisterType((*NatRuleStats)(nil), "nat.NatRuleStats")
	proto.RegisterType((*NatPolicyStats)(nil), "nat.NatPolicyStats")
	proto.RegisterType((*NatPolicyGetResponse)(nil), "nat.NatPolicyGetResponse")
	proto.RegisterType((*NatPolicyGetResponseMsg)(nil), "nat.NatPolicyGetResponseMsg")
	proto.RegisterType((*NatMappingSpec)(nil), "nat.NatMappingSpec")
	proto.RegisterType((*NatMappingRequestMsg)(nil), "nat.NatMappingRequestMsg")
	proto.RegisterType((*NatMappingStatus)(nil), "nat.NatMappingStatus")
	proto.RegisterType((*NatMappingResponse)(nil), "nat.NatMappingResponse")
	proto.RegisterType((*NatMappingResponseMsg)(nil), "nat.NatMappingResponseMsg")
	proto.RegisterType((*NatMappingDeleteRequest)(nil), "nat.NatMappingDeleteRequest")
	proto.RegisterType((*NatMappingDeleteRequestMsg)(nil), "nat.NatMappingDeleteRequestMsg")
	proto.RegisterType((*NatMappingDeleteResponse)(nil), "nat.NatMappingDeleteResponse")
	proto.RegisterType((*NatMappingDeleteResponseMsg)(nil), "nat.NatMappingDeleteResponseMsg")
	proto.RegisterType((*NatMappingGetRequest)(nil), "nat.NatMappingGetRequest")
	proto.RegisterType((*NatMappingGetRequestMsg)(nil), "nat.NatMappingGetRequestMsg")
	proto.RegisterType((*NatMappingStats)(nil), "nat.NatMappingStats")
	proto.RegisterType((*NatMappingGetResponse)(nil), "nat.NatMappingGetResponse")
	proto.RegisterType((*NatMappingGetResponseMsg)(nil), "nat.NatMappingGetResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Nat service

type NatClient interface {
	// NAT pool related APIs
	NatPoolCreate(ctx context.Context, in *NatPoolRequestMsg, opts ...grpc.CallOption) (*NatPoolResponseMsg, error)
	NatPoolUpdate(ctx context.Context, in *NatPoolRequestMsg, opts ...grpc.CallOption) (*NatPoolResponseMsg, error)
	NatPoolDelete(ctx context.Context, in *NatPoolDeleteRequestMsg, opts ...grpc.CallOption) (*NatPoolDeleteResponseMsg, error)
	NatPoolGet(ctx context.Context, in *NatPoolGetRequestMsg, opts ...grpc.CallOption) (*NatPoolGetResponseMsg, error)
	// NAT policy related APIs
	NatPolicyCreate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error)
	NatPolicyUpdate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error)
	NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*NatPolicyDeleteResponseMsg, error)
	NatPolicyGet(ctx context.Context, in *NatPolicyGetRequestMsg, opts ...grpc.CallOption) (*NatPolicyGetResponseMsg, error)
	// NAT mappings related APIs
	NatMappingCreate(ctx context.Context, in *NatMappingRequestMsg, opts ...grpc.CallOption) (*NatMappingResponseMsg, error)
	NatMappingDelete(ctx context.Context, in *NatMappingDeleteRequestMsg, opts ...grpc.CallOption) (*NatMappingDeleteResponseMsg, error)
	NatMappingGet(ctx context.Context, in *NatMappingGetRequestMsg, opts ...grpc.CallOption) (*NatMappingGetResponseMsg, error)
}

type natClient struct {
	cc *grpc.ClientConn
}

func NewNatClient(cc *grpc.ClientConn) NatClient {
	return &natClient{cc}
}

func (c *natClient) NatPoolCreate(ctx context.Context, in *NatPoolRequestMsg, opts ...grpc.CallOption) (*NatPoolResponseMsg, error) {
	out := new(NatPoolResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPoolCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPoolUpdate(ctx context.Context, in *NatPoolRequestMsg, opts ...grpc.CallOption) (*NatPoolResponseMsg, error) {
	out := new(NatPoolResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPoolUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPoolDelete(ctx context.Context, in *NatPoolDeleteRequestMsg, opts ...grpc.CallOption) (*NatPoolDeleteResponseMsg, error) {
	out := new(NatPoolDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPoolDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPoolGet(ctx context.Context, in *NatPoolGetRequestMsg, opts ...grpc.CallOption) (*NatPoolGetResponseMsg, error) {
	out := new(NatPoolGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPoolGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyCreate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error) {
	out := new(NatPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyUpdate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error) {
	out := new(NatPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*NatPolicyDeleteResponseMsg, error) {
	out := new(NatPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyGet(ctx context.Context, in *NatPolicyGetRequestMsg, opts ...grpc.CallOption) (*NatPolicyGetResponseMsg, error) {
	out := new(NatPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatMappingCreate(ctx context.Context, in *NatMappingRequestMsg, opts ...grpc.CallOption) (*NatMappingResponseMsg, error) {
	out := new(NatMappingResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatMappingCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatMappingDelete(ctx context.Context, in *NatMappingDeleteRequestMsg, opts ...grpc.CallOption) (*NatMappingDeleteResponseMsg, error) {
	out := new(NatMappingDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatMappingDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatMappingGet(ctx context.Context, in *NatMappingGetRequestMsg, opts ...grpc.CallOption) (*NatMappingGetResponseMsg, error) {
	out := new(NatMappingGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatMappingGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Nat service

type NatServer interface {
	// NAT pool related APIs
	NatPoolCreate(context.Context, *NatPoolRequestMsg) (*NatPoolResponseMsg, error)
	NatPoolUpdate(context.Context, *NatPoolRequestMsg) (*NatPoolResponseMsg, error)
	NatPoolDelete(context.Context, *NatPoolDeleteRequestMsg) (*NatPoolDeleteResponseMsg, error)
	NatPoolGet(context.Context, *NatPoolGetRequestMsg) (*NatPoolGetResponseMsg, error)
	// NAT policy related APIs
	NatPolicyCreate(context.Context, *NatPolicyRequestMsg) (*NatPolicyResponseMsg, error)
	NatPolicyUpdate(context.Context, *NatPolicyRequestMsg) (*NatPolicyResponseMsg, error)
	NatPolicyDelete(context.Context, *NatPolicyDeleteRequestMsg) (*NatPolicyDeleteResponseMsg, error)
	NatPolicyGet(context.Context, *NatPolicyGetRequestMsg) (*NatPolicyGetResponseMsg, error)
	// NAT mappings related APIs
	NatMappingCreate(context.Context, *NatMappingRequestMsg) (*NatMappingResponseMsg, error)
	NatMappingDelete(context.Context, *NatMappingDeleteRequestMsg) (*NatMappingDeleteResponseMsg, error)
	NatMappingGet(context.Context, *NatMappingGetRequestMsg) (*NatMappingGetResponseMsg, error)
}

func RegisterNatServer(s *grpc.Server, srv NatServer) {
	s.RegisterService(&_Nat_serviceDesc, srv)
}

func _Nat_NatPoolCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPoolRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPoolCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPoolCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPoolCreate(ctx, req.(*NatPoolRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPoolUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPoolRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPoolUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPoolUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPoolUpdate(ctx, req.(*NatPoolRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPoolDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPoolDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPoolDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPoolDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPoolDelete(ctx, req.(*NatPoolDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPoolGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPoolGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPoolGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPoolGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPoolGet(ctx, req.(*NatPoolGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyCreate(ctx, req.(*NatPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyUpdate(ctx, req.(*NatPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyDelete(ctx, req.(*NatPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyGet(ctx, req.(*NatPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatMappingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatMappingRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatMappingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatMappingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatMappingCreate(ctx, req.(*NatMappingRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatMappingDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatMappingDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatMappingDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatMappingDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatMappingDelete(ctx, req.(*NatMappingDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatMappingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatMappingGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatMappingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatMappingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatMappingGet(ctx, req.(*NatMappingGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nat.Nat",
	HandlerType: (*NatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatPoolCreate",
			Handler:    _Nat_NatPoolCreate_Handler,
		},
		{
			MethodName: "NatPoolUpdate",
			Handler:    _Nat_NatPoolUpdate_Handler,
		},
		{
			MethodName: "NatPoolDelete",
			Handler:    _Nat_NatPoolDelete_Handler,
		},
		{
			MethodName: "NatPoolGet",
			Handler:    _Nat_NatPoolGet_Handler,
		},
		{
			MethodName: "NatPolicyCreate",
			Handler:    _Nat_NatPolicyCreate_Handler,
		},
		{
			MethodName: "NatPolicyUpdate",
			Handler:    _Nat_NatPolicyUpdate_Handler,
		},
		{
			MethodName: "NatPolicyDelete",
			Handler:    _Nat_NatPolicyDelete_Handler,
		},
		{
			MethodName: "NatPolicyGet",
			Handler:    _Nat_NatPolicyGet_Handler,
		},
		{
			MethodName: "NatMappingCreate",
			Handler:    _Nat_NatMappingCreate_Handler,
		},
		{
			MethodName: "NatMappingDelete",
			Handler:    _Nat_NatMappingDelete_Handler,
		},
		{
			MethodName: "NatMappingGet",
			Handler:    _Nat_NatMappingGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nat.proto",
}

func (m *NatPoolSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Address) > 0 {
		for _, msg := range m.Address {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortRange != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PortRange.Size()))
		n2, err := m.PortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *NatPoolRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PoolHandle))
		i += 8
	}
	return i, nil
}

func (m *NatPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.PoolStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PoolStatus.Size()))
		n3, err := m.PoolStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *NatPoolResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n4, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *NatPoolDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *NatPoolDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n5, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *NatPoolGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NatPoolGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n6, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n7, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n8, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *NatPoolGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcNatAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatPool.Size()))
		n9, err := m.SrcNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DstNatPool != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatPool.Size()))
		n10, err := m.DstNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NatRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RuleId))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Match.Size()))
		n11, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Action != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Action.Size()))
		n12, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *NatPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n13, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NatPolicyHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NatPolicyHandle))
		i += 8
	}
	return i, nil
}

func (m *NatPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PolicyStatus.Size()))
		n14, err := m.PolicyStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *NatPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n15, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *NatPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *NatPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n16, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *NatPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *NatPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n17, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n18, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n19, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *NatPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n20, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.NatPool != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NatPool.Size()))
		n21, err := m.NatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Bidir {
		dAtA[i] = 0x18
		i++
		if m.Bidir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NatMappingRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.MappedIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.MappedIp.Size()))
		n22, err := m.MappedIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Configured {
		dAtA[i] = 0x18
		i++
		if m.Configured {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FlowCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.FlowCount))
	}
	return i, nil
}

func (m *NatMappingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n23, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *NatMappingResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n24, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *NatMappingDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *NatMappingDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n25, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *NatMappingGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatMappingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *NatMappingGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n26, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n27, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n28, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *NatMappingGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatMappingGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NatPoolSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.PortRange != nil {
		l = m.PortRange.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolStatus) Size() (n int) {
	var l int
	_ = l
	if m.PoolHandle != 0 {
		n += 9
	}
	return n
}

func (m *NatPoolResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.PoolStatus != nil {
		l = m.PoolStatus.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	return n
}

func (m *NatPoolDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NatPoolGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleAction) Size() (n int) {
	var l int
	_ = l
	if m.SrcNatAction != 0 {
		n += 1 + sovNat(uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		n += 1 + sovNat(uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		l = m.SrcNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.DstNatPool != nil {
		l = m.DstNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNat(uint64(m.RuleId))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.NatPolicyHandle != 0 {
		n += 9
	}
	return n
}

func (m *NatPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		l = m.PolicyStatus.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	return n
}

func (m *NatPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNat(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *NatPolicyStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.NatPool != nil {
		l = m.NatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Bidir {
		n += 2
	}
	return n
}

func (m *NatMappingRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.MappedIp != nil {
		l = m.MappedIp.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Configured {
		n += 2
	}
	if m.FlowCount != 0 {
		n += 1 + sovNat(uint64(m.FlowCount))
	}
	return n
}

func (m *NatMappingResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatMappingResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatMappingDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	return n
}

func (m *NatMappingDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatMappingGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatMappingStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNat(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *NatMappingGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatMappingGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func sovNat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNat(x uint64) (n int) {
	return sovNat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPoolSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &Address{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortRange == nil {
				m.PortRange = &L4PortRange{}
			}
			if err := m.PortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPoolSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolHandle", wireType)
			}
			m.PoolHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolStatus == nil {
				m.PoolStatus = &NatPoolStatus{}
			}
			if err := m.PoolStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPoolResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPoolDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPoolDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPoolGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatPoolSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatPoolStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatPoolStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPoolGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatAction", wireType)
			}
			m.DstNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcNatPool == nil {
				m.SrcNatPool = &NatPoolKeyHandle{}
			}
			if err := m.SrcNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatPool == nil {
				m.DstNatPool = &NatPoolKeyHandle{}
			}
			if err := m.DstNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &NatRuleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &NatRuleSpec{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPolicyHandle", wireType)
			}
			m.NatPolicyHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPolicyHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyStatus == nil {
				m.PolicyStatus = &NatPolicyStatus{}
			}
			if err := m.PolicyStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &NatRuleStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatPool == nil {
				m.NatPool = &NatPoolKeyHandle{}
			}
			if err := m.NatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bidir = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatMappingSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MappedIp == nil {
				m.MappedIp = &IPAddress{}
			}
			if err := m.MappedIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configured", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Configured = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCount", wireType)
			}
			m.FlowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatMappingResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatMappingDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatMappingDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatMappingGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatMappingSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatMappingStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatMappingGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatMappingGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatMappingGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatMappingGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nat.proto", fileDescriptorNat) }

var fileDescriptorNat = []byte{
	// 1582 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0xae, 0xb3, 0xf9, 0x7c, 0x93, 0x6c, 0x93, 0xe9, 0x76, 0xb3, 0x49, 0xd3, 0x6c, 0xb0, 0x50,
	0x5b, 0xa2, 0x64, 0x55, 0xb6, 0xb4, 0xa2, 0x48, 0xa5, 0x6a, 0x4a, 0x4a, 0xda, 0x26, 0xdb, 0xe0,
	0xa6, 0x94, 0x0f, 0x21, 0xe3, 0xd8, 0x93, 0xc4, 0xca, 0xae, 0x6d, 0xec, 0x59, 0xd0, 0x82, 0xb8,
	0x71, 0x46, 0x48, 0x95, 0x10, 0xbf, 0x08, 0x21, 0x4e, 0x70, 0xea, 0x2d, 0xa0, 0x72, 0xe3, 0x98,
	0x5f, 0x80, 0xe6, 0xc3, 0xf6, 0xf8, 0x6b, 0x09, 0xd5, 0x56, 0xe2, 0xb4, 0xeb, 0x99, 0xd7, 0xef,
	0x3c, 0xf3, 0xcc, 0x33, 0xef, 0x33, 0x1e, 0x98, 0x70, 0x0c, 0xd2, 0xf0, 0x7c, 0x97, 0xb8, 0xa8,
	0xe4, 0x18, 0x64, 0x61, 0x92, 0xf4, 0x3c, 0x1c, 0xf0, 0x96, 0x85, 0xf1, 0xa3, 0x43, 0xfe, 0x4f,
	0xfd, 0x55, 0x81, 0xc9, 0x96, 0x41, 0x76, 0x5c, 0xb7, 0xfd, 0xd8, 0xc3, 0x26, 0xda, 0x84, 0xe9,
	0x23, 0xdc, 0xd3, 0x5d, 0x5f, 0x3f, 0x34, 0x1c, 0xab, 0x8d, 0x6b, 0xca, 0xb2, 0x72, 0x65, 0xb2,
	0x59, 0x69, 0x1c, 0x1d, 0x36, 0x44, 0xdc, 0x43, 0xdc, 0xdb, 0x64, 0x7d, 0xeb, 0xe5, 0x93, 0xe3,
	0x3a, 0x7c, 0x89, 0x1d, 0xdb, 0xc4, 0xef, 0x1c, 0xe1, 0x9e, 0x36, 0x79, 0x84, 0x7b, 0x8f, 0x7c,
	0xde, 0x89, 0xde, 0x85, 0x31, 0xc3, 0xb2, 0x7c, 0x1c, 0x04, 0xb5, 0xa1, 0xe5, 0xd2, 0x95, 0xc9,
	0x66, 0xb9, 0xc1, 0x21, 0xdc, 0xe1, 0xad, 0xeb, 0x95, 0x93, 0xe3, 0xfa, 0x8c, 0x78, 0xbb, 0x63,
	0x38, 0x96, 0x41, 0x5c, 0xbf, 0xa7, 0x85, 0x2f, 0xa1, 0x37, 0x01, 0x3c, 0xd7, 0x27, 0xba, 0x6f,
	0x38, 0x07, 0xb8, 0x56, 0x62, 0x30, 0x90, 0x48, 0xb1, 0xf5, 0xd6, 0x8e, 0xeb, 0x13, 0x8d, 0xf6,
	0x68, 0x13, 0x5e, 0xf8, 0x57, 0xbd, 0x0d, 0xb3, 0x02, 0xa3, 0x86, 0xbf, 0xe8, 0xe2, 0x80, 0x6c,
	0x07, 0x07, 0x68, 0x05, 0xc6, 0x7c, 0xfe, 0x54, 0x53, 0x18, 0x8e, 0x99, 0x06, 0xa5, 0x46, 0x9a,
	0xb4, 0x16, 0x06, 0xa8, 0x57, 0x61, 0x3a, 0x6c, 0x27, 0x06, 0xe9, 0x06, 0xa8, 0x0e, 0x93, 0x9e,
	0xeb, 0xb6, 0x65, 0x32, 0x46, 0x35, 0xa0, 0x4d, 0x7c, 0x96, 0xea, 0xf7, 0x0a, 0x9c, 0x8d, 0xc6,
	0x0c, 0x3c, 0xd7, 0x09, 0x30, 0xba, 0x07, 0x60, 0x78, 0xb6, 0x1e, 0xb0, 0x14, 0xec, 0x9d, 0x72,
	0x73, 0x26, 0x9c, 0xbc, 0x67, 0xf3, 0xd4, 0xeb, 0xe7, 0x4f, 0x8e, 0xeb, 0xb3, 0x62, 0xfa, 0x71,
	0xb8, 0x36, 0x61, 0x84, 0x11, 0xe8, 0x9a, 0x18, 0x5c, 0x24, 0x1a, 0x12, 0x14, 0xc8, 0xe8, 0xf9,
	0x3b, 0x0c, 0x10, 0xff, 0xaf, 0xde, 0x03, 0x94, 0xc2, 0x43, 0x49, 0xb8, 0x0a, 0xe3, 0xbe, 0x78,
	0x14, 0x2c, 0x54, 0xe4, 0x3c, 0x61, 0xa8, 0x16, 0x45, 0xa9, 0x9f, 0x43, 0x45, 0x74, 0xbe, 0x87,
	0xdb, 0x98, 0x60, 0xc1, 0xe8, 0xe0, 0x04, 0xa2, 0xb6, 0x60, 0x2e, 0x6f, 0x04, 0x0a, 0xf7, 0x5a,
	0x7a, 0xcd, 0xe6, 0x65, 0xb4, 0x89, 0xf0, 0x78, 0xf1, 0x74, 0x38, 0x9f, 0x0a, 0x18, 0xec, 0x7a,
	0xa8, 0x1a, 0xd4, 0x72, 0x07, 0xa0, 0x88, 0x6f, 0x64, 0x08, 0x5e, 0xc8, 0x83, 0x9c, 0xa1, 0xf9,
	0xb3, 0x48, 0xb2, 0xef, 0x63, 0x32, 0x78, 0x8e, 0x37, 0xa3, 0x55, 0x8c, 0xd3, 0x73, 0x3d, 0xa4,
	0x08, 0xae, 0xca, 0x68, 0xe3, 0xd8, 0x98, 0xdd, 0x32, 0x4c, 0x49, 0xa2, 0x0b, 0xd4, 0xe7, 0x4a,
	0x24, 0x34, 0x16, 0x3e, 0x60, 0xed, 0xbf, 0x0e, 0xc3, 0x81, 0x87, 0x4d, 0x21, 0xfa, 0xec, 0x96,
	0x65, 0xbd, 0x68, 0x05, 0x46, 0xc5, 0x48, 0xa5, 0xc2, 0xcd, 0x21, 0x22, 0xd0, 0x65, 0x18, 0xa1,
	0xff, 0x82, 0xda, 0x30, 0x0b, 0x9d, 0x4d, 0x87, 0x06, 0x1a, 0xef, 0x57, 0xb7, 0x22, 0x1d, 0x49,
	0x13, 0xe3, 0xaa, 0x4c, 0xaf, 0xf1, 0x5c, 0x86, 0xb5, 0xcc, 0x02, 0x3f, 0x2f, 0xb1, 0x9a, 0xa2,
	0x75, 0xdb, 0xf8, 0x8e, 0x49, 0x6c, 0xd7, 0x41, 0x5b, 0x50, 0x0e, 0x7c, 0x53, 0x77, 0x0c, 0xa2,
	0x1b, 0xac, 0x25, 0x45, 0x53, 0xcb, 0x20, 0x3c, 0x32, 0x51, 0x21, 0xed, 0x4e, 0xa7, 0x4b, 0x8c,
	0xbd, 0x36, 0xd6, 0xa6, 0x02, 0xdf, 0x8c, 0x62, 0x68, 0x36, 0x2b, 0x20, 0x72, 0xb6, 0xa1, 0xff,
	0x96, 0xcd, 0x0a, 0x48, 0x9c, 0xed, 0x99, 0x02, 0x53, 0x21, 0x38, 0x5a, 0x54, 0x04, 0xaf, 0xf9,
	0xca, 0xfb, 0xf4, 0xe4, 0xb8, 0xfe, 0x54, 0x24, 0xf4, 0xf1, 0xfe, 0xaa, 0xf8, 0x6b, 0xba, 0x4e,
	0x40, 0x7c, 0xc3, 0x76, 0x48, 0x70, 0xeb, 0x1b, 0xc1, 0x4f, 0x3c, 0xfd, 0x46, 0x72, 0xee, 0xaf,
	0xdd, 0x62, 0x43, 0xed, 0x35, 0x1b, 0xad, 0x3b, 0xbb, 0xfa, 0xee, 0xc7, 0x3b, 0x1b, 0x7a, 0xeb,
	0x51, 0x6b, 0xe3, 0x5b, 0x0d, 0xf8, 0x2c, 0xe9, 0x88, 0x0c, 0x55, 0x38, 0x49, 0x86, 0x6a, 0x78,
	0xe0, 0xa8, 0x92, 0x1c, 0x16, 0xa3, 0xe2, 0x6c, 0xd1, 0x11, 0xd5, 0xaf, 0x99, 0x73, 0xd2, 0x1c,
	0xcc, 0x39, 0xe7, 0x60, 0xcc, 0xef, 0xb6, 0xb1, 0x6e, 0x5b, 0x6c, 0x3d, 0x87, 0xb5, 0x51, 0xfa,
	0x78, 0xdf, 0x42, 0x97, 0x60, 0xa4, 0x63, 0x10, 0xf3, 0x30, 0xd2, 0x32, 0x5f, 0x18, 0xfa, 0xe2,
	0x36, 0x6d, 0xd7, 0x78, 0x37, 0x15, 0xb3, 0x58, 0xc1, 0x94, 0x98, 0x63, 0x98, 0x9a, 0x88, 0x50,
	0x9f, 0x29, 0xc2, 0xa9, 0xda, 0xb6, 0xd9, 0x63, 0xc3, 0x3f, 0xc8, 0xaf, 0x19, 0xd5, 0x88, 0x23,
	0x1a, 0x79, 0x4a, 0xeb, 0xbe, 0x01, 0x23, 0x14, 0x7b, 0x68, 0xdc, 0x33, 0x32, 0x10, 0x3a, 0x58,
	0xe2, 0x6d, 0x1f, 0xef, 0x6b, 0x3c, 0x5c, 0xbd, 0x0b, 0xe7, 0xa2, 0xa1, 0xa4, 0x62, 0xb3, 0x9a,
	0x2e, 0x36, 0xd2, 0x36, 0x0d, 0xf1, 0xc7, 0x85, 0xe6, 0x96, 0x30, 0x54, 0xd6, 0xc3, 0xb7, 0xee,
	0x0a, 0xcc, 0xf2, 0xa5, 0xa7, 0x6d, 0x49, 0x2f, 0x3e, 0xeb, 0x84, 0xb1, 0xa2, 0xe2, 0xfd, 0xa8,
	0x88, 0x8a, 0xca, 0x41, 0x0c, 0xb8, 0x2c, 0xdd, 0x84, 0x69, 0x81, 0x22, 0x61, 0xca, 0x95, 0xd4,
	0x84, 0xf8, 0x7b, 0x53, 0x9e, 0xf4, 0xa4, 0x3e, 0x10, 0xa5, 0x58, 0xc6, 0x45, 0xd9, 0x69, 0x66,
	0xaa, 0x4a, 0x35, 0x99, 0x2d, 0xa7, 0xa8, 0x58, 0x50, 0x8d, 0xba, 0x93, 0xf6, 0x3c, 0x40, 0x19,
	0xa8, 0x1a, 0xcc, 0xe7, 0x8f, 0x42, 0x61, 0x5f, 0x4f, 0x2f, 0xea, 0x85, 0x24, 0xea, 0x02, 0x93,
	0x36, 0x84, 0xe9, 0xcb, 0x21, 0x03, 0xb6, 0xe9, 0x0f, 0x61, 0xa1, 0x60, 0x08, 0x8a, 0xfb, 0xed,
	0x0c, 0xdd, 0x8b, 0xf9, 0xc0, 0x33, 0xa4, 0x1b, 0x92, 0xba, 0x25, 0xb3, 0x1e, 0x24, 0xe3, 0x5b,
	0xd2, 0xba, 0x26, 0x0d, 0xbb, 0x99, 0xa6, 0xbb, 0x96, 0x44, 0x9d, 0x67, 0xd9, 0x3f, 0x28, 0xcc,
	0xb3, 0xd9, 0xae, 0xa5, 0xce, 0x86, 0xae, 0xc0, 0x8c, 0xd3, 0xed, 0xe8, 0xc4, 0xf4, 0xf4, 0x00,
	0x07, 0x81, 0xed, 0x3a, 0x9c, 0xe7, 0x69, 0xad, 0xec, 0x74, 0x3b, 0xbb, 0xa6, 0xf7, 0x58, 0xb4,
	0x86, 0x91, 0x5d, 0x4b, 0x8a, 0x1c, 0x8a, 0x22, 0x9f, 0x58, 0x71, 0xe4, 0x2a, 0x20, 0x1a, 0xe9,
	0x92, 0x43, 0xec, 0xc7, 0xb1, 0x25, 0x16, 0x4b, 0x73, 0x3c, 0xa2, 0x1d, 0x61, 0xb4, 0x7a, 0x13,
	0xca, 0x89, 0x5d, 0x22, 0xd9, 0x32, 0x9f, 0xd6, 0x6c, 0xa2, 0xd6, 0xc8, 0xb6, 0xfc, 0x87, 0x22,
	0x6d, 0xa0, 0x57, 0x71, 0xe4, 0xb8, 0x94, 0x38, 0x72, 0xe4, 0xd5, 0x28, 0x7e, 0xe8, 0x58, 0x4d,
	0x1d, 0x3a, 0xf2, 0x37, 0x7f, 0x78, 0xec, 0x78, 0x23, 0x79, 0xec, 0x38, 0x97, 0x0d, 0x8e, 0x66,
	0xb8, 0x23, 0xed, 0x8d, 0xd4, 0xd1, 0xe3, 0x7a, 0x46, 0xb5, 0xf3, 0x39, 0xeb, 0x9f, 0x91, 0xec,
	0xcf, 0x0a, 0xe3, 0x7b, 0xdb, 0xf0, 0x3c, 0xdb, 0x39, 0x60, 0x3e, 0xf1, 0x30, 0x5f, 0xae, 0x73,
	0x42, 0xae, 0x22, 0xf4, 0x94, 0x46, 0xf1, 0x01, 0x8c, 0x47, 0x9e, 0x3c, 0xd4, 0xc7, 0x93, 0x97,
	0x4f, 0x8e, 0xeb, 0x8b, 0xe9, 0x4f, 0xbd, 0xd5, 0x65, 0xc9, 0x41, 0xc6, 0x1c, 0xe1, 0xf5, 0x15,
	0x18, 0xd9, 0xb3, 0x2d, 0xdb, 0x67, 0xe4, 0x8e, 0x6b, 0xfc, 0x41, 0xdd, 0x60, 0x6b, 0x2f, 0xc0,
	0x49, 0xdb, 0x62, 0x2d, 0xbd, 0x2d, 0x22, 0x7e, 0xa5, 0x39, 0xc7, 0x3b, 0xe2, 0x27, 0x05, 0x66,
	0xa4, 0x3e, 0xbe, 0x42, 0x55, 0x18, 0x4d, 0x58, 0x8a, 0x78, 0x42, 0x6b, 0x30, 0xd1, 0x31, 0x3c,
	0x0f, 0x5b, 0xba, 0xed, 0xa5, 0xbc, 0xfb, 0xfe, 0x8e, 0xf8, 0x88, 0xd5, 0xc6, 0x79, 0xc8, 0x7d,
	0x0f, 0x2d, 0x01, 0x98, 0xae, 0xb3, 0x6f, 0x1f, 0x74, 0x7d, 0x6c, 0x09, 0xf4, 0x52, 0x0b, 0xba,
	0x08, 0xb0, 0xdf, 0x76, 0xbf, 0xd2, 0x4d, 0xb7, 0xeb, 0x10, 0xa6, 0x86, 0x69, 0x6d, 0x82, 0xb6,
	0xdc, 0xa5, 0x0d, 0xea, 0x77, 0xfc, 0x3c, 0x1d, 0x4d, 0x51, 0x88, 0xfb, 0xf6, 0xa9, 0xc4, 0x5d,
	0xfe, 0xfb, 0xb8, 0x0e, 0xf9, 0xaa, 0x5e, 0x8b, 0xd4, 0xca, 0xa7, 0x70, 0x3e, 0x4d, 0x50, 0x42,
	0xae, 0xe2, 0xf0, 0x9b, 0x42, 0xf1, 0x2f, 0x87, 0xdf, 0x54, 0xb4, 0xa4, 0xbf, 0x7d, 0xa6, 0x68,
	0xd1, 0x9f, 0x34, 0xaa, 0x41, 0xea, 0x50, 0xdd, 0x65, 0x25, 0x3f, 0x6f, 0x1c, 0xfe, 0x6d, 0x96,
	0x12, 0xc9, 0x62, 0x0a, 0x79, 0x81, 0x57, 0xed, 0xb1, 0xef, 0xbd, 0x54, 0xcc, 0x80, 0xcd, 0xea,
	0x23, 0xb8, 0x50, 0x34, 0x06, 0x85, 0x7e, 0x33, 0xc3, 0xfa, 0xc5, 0x02, 0xec, 0x19, 0xee, 0x4d,
	0x79, 0xcb, 0x48, 0x7e, 0x35, 0x50, 0xe2, 0x5b, 0xf2, 0x02, 0x27, 0x1d, 0xab, 0xf8, 0x1b, 0x3e,
	0x13, 0x1e, 0x53, 0xfe, 0x8c, 0x5f, 0xa7, 0x48, 0xda, 0xfc, 0x3f, 0xb8, 0xd6, 0x5f, 0x8a, 0xbc,
	0x2b, 0x5e, 0x85, 0xf7, 0x5c, 0x4e, 0x78, 0x4f, 0x6e, 0x11, 0xe3, 0xe6, 0xb3, 0x96, 0x32, 0x9f,
	0xfe, 0xdb, 0x19, 0xad, 0x24, 0xdd, 0xa7, 0x92, 0x13, 0x1d, 0xd9, 0x8f, 0x26, 0xcb, 0x3d, 0xe5,
	0x3f, 0x7d, 0xae, 0x37, 0xb2, 0x2f, 0xc4, 0x22, 0x6c, 0xfe, 0x3e, 0x0a, 0xa5, 0x96, 0x41, 0xd0,
	0x7a, 0x74, 0xb1, 0x76, 0xd7, 0xc7, 0x06, 0xc1, 0xa8, 0x9a, 0xbc, 0x7e, 0x0a, 0x55, 0xb3, 0x30,
	0x97, 0x77, 0x2d, 0xb5, 0x1d, 0x1c, 0xa8, 0x67, 0xa4, 0x1c, 0x4f, 0x3c, 0xeb, 0x25, 0x73, 0xb4,
	0xa2, 0x1c, 0x7c, 0xdf, 0xa0, 0xc5, 0xc2, 0x8b, 0x25, 0x9a, 0xe9, 0x62, 0xf1, 0x1d, 0x0e, 0xcf,
	0xb7, 0x01, 0x10, 0x7f, 0xfd, 0xa3, 0xf9, 0xfc, 0x4b, 0x14, 0x9a, 0x69, 0xa1, 0xe0, 0xa6, 0x80,
	0xa7, 0xd9, 0x94, 0xbe, 0x79, 0x04, 0x41, 0xb5, 0xf4, 0x47, 0x40, 0x94, 0x6a, 0x3e, 0xff, 0xf3,
	0x20, 0x9b, 0x49, 0xd0, 0xf4, 0x92, 0x99, 0x76, 0xa5, 0x4c, 0x82, 0xac, 0xa5, 0x3e, 0x47, 0x7c,
	0x9a, 0xaf, 0xde, 0xef, 0x24, 0xcd, 0xb3, 0x3e, 0x14, 0xd7, 0x48, 0xe2, 0xcc, 0x82, 0x2e, 0x14,
	0x1d, 0x63, 0x69, 0xbe, 0xc5, 0xc2, 0x33, 0x4e, 0x98, 0x4c, 0x72, 0x73, 0xc1, 0xdb, 0x7c, 0xc6,
	0x95, 0xb2, 0x6b, 0x90, 0xb5, 0x37, 0xf5, 0x0c, 0x7a, 0x2a, 0x27, 0x13, 0x13, 0xae, 0xf7, 0x33,
	0x0a, 0x9a, 0x72, 0xb9, 0x6f, 0x35, 0x96, 0x35, 0x17, 0x6f, 0x13, 0xb4, 0x58, 0x58, 0x08, 0x13,
	0x9a, 0xcb, 0xdd, 0x89, 0xea, 0x99, 0xf5, 0xea, 0x2f, 0x2f, 0x96, 0x94, 0xdf, 0x5e, 0x2c, 0x29,
	0x7f, 0xbe, 0x58, 0x52, 0x3e, 0x19, 0x3f, 0x34, 0xda, 0xec, 0x2a, 0x7f, 0x6f, 0x94, 0xfd, 0x5c,
	0xfb, 0x27, 0x00, 0x00, 0xff, 0xff, 0x30, 0xee, 0x2c, 0x90, 0xfa, 0x17, 0x00, 0x00,
}
