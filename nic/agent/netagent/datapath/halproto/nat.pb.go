// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_TYPE_NONE                 NatAction = 0
	NatAction_NAT_TYPE_STATIC_ADDRESS       NatAction = 1
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS      NatAction = 2
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS_PORT NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_STATIC_ADDRESS",
	2: "NAT_TYPE_DYNAMIC_ADDRESS",
	3: "NAT_TYPE_DYNAMIC_ADDRESS_PORT",
}
var NatAction_value = map[string]int32{
	"NAT_TYPE_NONE":                 0,
	"NAT_TYPE_STATIC_ADDRESS":       1,
	"NAT_TYPE_DYNAMIC_ADDRESS":      2,
	"NAT_TYPE_DYNAMIC_ADDRESS_PORT": 3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}
func (NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

// NAT pool definition
// NOTE: addresses inside the NAT pool are "owned" by the device, so device is
// expected to advertise the routes for the same and respond to ARP requests
type NatPool struct {
	Address   []*Address   `protobuf:"bytes,1,rep,name=address" json:"address,omitempty"`
	PortRange *L4PortRange `protobuf:"bytes,2,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *NatPool) Reset()                    { *m = NatPool{} }
func (m *NatPool) String() string            { return proto.CompactTextString(m) }
func (*NatPool) ProtoMessage()               {}
func (*NatPool) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

func (m *NatPool) GetAddress() []*Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NatPool) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

// NatRuleSpec is the user intent for the NAT rule
type NatRuleSpec struct {
	RuleId uint64 `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	// NAT rule match conditions
	SrcAddress   []*IPAddressObj `protobuf:"bytes,2,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	SrcSg        []uint32        `protobuf:"varint,3,rep,packed,name=src_sg,json=srcSg" json:"src_sg,omitempty"`
	DstAddress   []*IPAddressObj `protobuf:"bytes,4,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstSg        []uint32        `protobuf:"varint,5,rep,packed,name=dst_sg,json=dstSg" json:"dst_sg,omitempty"`
	DstPortRange []*L4PortRange  `protobuf:"bytes,6,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange  `protobuf:"bytes,7,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	// NAT rule action related attributes
	SrcNatAction NatAction `protobuf:"varint,8,opt,name=src_nat_action,json=srcNatAction,proto3,enum=nat.NatAction" json:"src_nat_action,omitempty"`
	DstNatAction NatAction `protobuf:"varint,9,opt,name=dst_nat_action,json=dstNatAction,proto3,enum=nat.NatAction" json:"dst_nat_action,omitempty"`
	SrcNatPool   *NatPool  `protobuf:"bytes,10,opt,name=src_nat_pool,json=srcNatPool" json:"src_nat_pool,omitempty"`
	DstNatPool   *NatPool  `protobuf:"bytes,11,opt,name=dst_nat_pool,json=dstNatPool" json:"dst_nat_pool,omitempty"`
}

func (m *NatRuleSpec) Reset()                    { *m = NatRuleSpec{} }
func (m *NatRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*NatRuleSpec) ProtoMessage()               {}
func (*NatRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{1} }

func (m *NatRuleSpec) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *NatRuleSpec) GetSrcAddress() []*IPAddressObj {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *NatRuleSpec) GetSrcSg() []uint32 {
	if m != nil {
		return m.SrcSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstAddress() []*IPAddressObj {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *NatRuleSpec) GetDstSg() []uint32 {
	if m != nil {
		return m.DstSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetDstNatAction() NatAction {
	if m != nil {
		return m.DstNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetSrcNatPool() *NatPool {
	if m != nil {
		return m.SrcNatPool
	}
	return nil
}

func (m *NatRuleSpec) GetDstNatPool() *NatPool {
	if m != nil {
		return m.DstNatPool
	}
	return nil
}

// NatPolicySpec captures the NAT policy which is a group of NAT rules
type NatPolicySpec struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Rules       []*NatRuleSpec      `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *NatPolicySpec) Reset()                    { *m = NatPolicySpec{} }
func (m *NatPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*NatPolicySpec) ProtoMessage()               {}
func (*NatPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{2} }

func (m *NatPolicySpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatPolicySpec) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatPolicySpec) GetRules() []*NatRuleSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// NatPolicyRequestMsg is the batched NAT policy
type NatPolicyRequestMsg struct {
	Request []*NatPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyRequestMsg) Reset()                    { *m = NatPolicyRequestMsg{} }
func (m *NatPolicyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyRequestMsg) ProtoMessage()               {}
func (*NatPolicyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{3} }

func (m *NatPolicyRequestMsg) GetRequest() []*NatPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPolicyStatus is the operational status of NatPolicySpec
type NatPolicyStatus struct {
	NatPolicyHandle uint64 `protobuf:"fixed64,1,opt,name=nat_policy_handle,json=natPolicyHandle,proto3" json:"nat_policy_handle,omitempty"`
}

func (m *NatPolicyStatus) Reset()                    { *m = NatPolicyStatus{} }
func (m *NatPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyStatus) ProtoMessage()               {}
func (*NatPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{4} }

func (m *NatPolicyStatus) GetNatPolicyHandle() uint64 {
	if m != nil {
		return m.NatPolicyHandle
	}
	return 0
}

// NatPolicyResponse is response to NatPolicySpec
type NatPolicyResponse struct {
	ApiStatus    ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	PolicyStatus *NatPolicyStatus `protobuf:"bytes,2,opt,name=policy_status,json=policyStatus" json:"policy_status,omitempty"`
}

func (m *NatPolicyResponse) Reset()                    { *m = NatPolicyResponse{} }
func (m *NatPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyResponse) ProtoMessage()               {}
func (*NatPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{5} }

func (m *NatPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyResponse) GetPolicyStatus() *NatPolicyStatus {
	if m != nil {
		return m.PolicyStatus
	}
	return nil
}

// NatPolicyResponseMsg is the batched NatPolicyResponse
type NatPolicyResponseMsg struct {
	Response []*NatPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyResponseMsg) Reset()                    { *m = NatPolicyResponseMsg{} }
func (m *NatPolicyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyResponseMsg) ProtoMessage()               {}
func (*NatPolicyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{6} }

func (m *NatPolicyResponseMsg) GetResponse() []*NatPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPolicyDeleteRequest is used to delete a NAT policy
type NatPolicyDeleteRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatPolicyDeleteRequest) Reset()                    { *m = NatPolicyDeleteRequest{} }
func (m *NatPolicyDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteRequest) ProtoMessage()               {}
func (*NatPolicyDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{7} }

func (m *NatPolicyDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatPolicyDeleteRequest) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPolicyDeleteRequestMsg is batched NatPolicyDeleteRequest
type NatPolicyDeleteRequestMsg struct {
	Request []*NatPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyDeleteRequestMsg) Reset()                    { *m = NatPolicyDeleteRequestMsg{} }
func (m *NatPolicyDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteRequestMsg) ProtoMessage()               {}
func (*NatPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{8} }

func (m *NatPolicyDeleteRequestMsg) GetRequest() []*NatPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatPolicyDeleteResponse is response to NatPolicyDeleteRequest
type NatPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *NatPolicyDeleteResponse) Reset()                    { *m = NatPolicyDeleteResponse{} }
func (m *NatPolicyDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteResponse) ProtoMessage()               {}
func (*NatPolicyDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{9} }

func (m *NatPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NatPolicyDeleteResponseMsg is batched response to NatPolicyDeleteRequestMsg
type NatPolicyDeleteResponseMsg struct {
	Response []*NatPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyDeleteResponseMsg) Reset()                    { *m = NatPolicyDeleteResponseMsg{} }
func (m *NatPolicyDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyDeleteResponseMsg) ProtoMessage()               {}
func (*NatPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{10} }

func (m *NatPolicyDeleteResponseMsg) GetResponse() []*NatPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatPolicyGetRequest is used to get information about a NAT policy
type NatPolicyGetRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatPolicyGetRequest) Reset()                    { *m = NatPolicyGetRequest{} }
func (m *NatPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetRequest) ProtoMessage()               {}
func (*NatPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{11} }

func (m *NatPolicyGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatPolicyGetRequest) GetKeyOrHandle() *NatPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatPolicyGetRequestMsg is batched GET request
type NatPolicyGetRequestMsg struct {
	Request []*NatPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatPolicyGetRequestMsg) Reset()                    { *m = NatPolicyGetRequestMsg{} }
func (m *NatPolicyGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetRequestMsg) ProtoMessage()               {}
func (*NatPolicyGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{12} }

func (m *NatPolicyGetRequestMsg) GetRequest() []*NatPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// per rule stats
type NatRuleStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions   uint32 `protobuf:"varint,2,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,3,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *NatRuleStats) Reset()                    { *m = NatRuleStats{} }
func (m *NatRuleStats) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStats) ProtoMessage()               {}
func (*NatRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{13} }

func (m *NatRuleStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// per policy stats
type NatPolicyStats struct {
	Stats []*NatRuleStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *NatPolicyStats) Reset()                    { *m = NatPolicyStats{} }
func (m *NatPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyStats) ProtoMessage()               {}
func (*NatPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{14} }

func (m *NatPolicyStats) GetStats() []*NatRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatPolicyGetResponse catpures all information about NAT policy
type NatPolicyGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatPolicyGetResponse) Reset()                    { *m = NatPolicyGetResponse{} }
func (m *NatPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetResponse) ProtoMessage()               {}
func (*NatPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{15} }

func (m *NatPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyGetResponse) GetSpec() *NatPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatPolicyGetResponse) GetStatus() *NatPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatPolicyGetResponse) GetStats() *NatPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatPolicyGetResponseMsg is batched response to NatPolicyGetRequestMsg
type NatPolicyGetResponseMsg struct {
	Response []*NatPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatPolicyGetResponseMsg) Reset()                    { *m = NatPolicyGetResponseMsg{} }
func (m *NatPolicyGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyGetResponseMsg) ProtoMessage()               {}
func (*NatPolicyGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{16} }

func (m *NatPolicyGetResponseMsg) GetResponse() []*NatPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatVpnMappingSpec is the user intent for the NAT-VPN mapping
type NatVpnMappingSpec struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatVpnMappingKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatVpnMappingSpec) Reset()                    { *m = NatVpnMappingSpec{} }
func (m *NatVpnMappingSpec) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingSpec) ProtoMessage()               {}
func (*NatVpnMappingSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{17} }

func (m *NatVpnMappingSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatVpnMappingSpec) GetKeyOrHandle() *NatVpnMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatVpnMappingRequestMsg is the batched add or modify of NAT VPN mapping request
type NatVpnMappingRequestMsg struct {
	Request []*NatVpnMappingSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatVpnMappingRequestMsg) Reset()                    { *m = NatVpnMappingRequestMsg{} }
func (m *NatVpnMappingRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingRequestMsg) ProtoMessage()               {}
func (*NatVpnMappingRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{18} }

func (m *NatVpnMappingRequestMsg) GetRequest() []*NatVpnMappingSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatVpnMappingStatus reflects the current operational status of a NAT VPN mapping
type NatVpnMappingStatus struct {
	Handle     uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	SvcMapping *Svc   `protobuf:"bytes,2,opt,name=svc_mapping,json=svcMapping" json:"svc_mapping,omitempty"`
}

func (m *NatVpnMappingStatus) Reset()                    { *m = NatVpnMappingStatus{} }
func (m *NatVpnMappingStatus) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingStatus) ProtoMessage()               {}
func (*NatVpnMappingStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{19} }

func (m *NatVpnMappingStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *NatVpnMappingStatus) GetSvcMapping() *Svc {
	if m != nil {
		return m.SvcMapping
	}
	return nil
}

// NatVpnMappingResponse is the response to NatVpnMappingSpec
type NatVpnMappingResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *NatVpnMappingStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *NatVpnMappingResponse) Reset()                    { *m = NatVpnMappingResponse{} }
func (m *NatVpnMappingResponse) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingResponse) ProtoMessage()               {}
func (*NatVpnMappingResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{20} }

func (m *NatVpnMappingResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatVpnMappingResponse) GetStatus() *NatVpnMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// NatVpnMappingResponseMsg is batched response to NatVpnMappingRequestMsg
type NatVpnMappingResponseMsg struct {
	Response []*NatVpnMappingResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatVpnMappingResponseMsg) Reset()                    { *m = NatVpnMappingResponseMsg{} }
func (m *NatVpnMappingResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingResponseMsg) ProtoMessage()               {}
func (*NatVpnMappingResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{21} }

func (m *NatVpnMappingResponseMsg) GetResponse() []*NatVpnMappingResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatVpnMappingGetRequest is used to get information about a NAT VPN mapping
type NatVpnMappingGetRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatVpnMappingKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatVpnMappingGetRequest) Reset()                    { *m = NatVpnMappingGetRequest{} }
func (m *NatVpnMappingGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingGetRequest) ProtoMessage()               {}
func (*NatVpnMappingGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{22} }

func (m *NatVpnMappingGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatVpnMappingGetRequest) GetKeyOrHandle() *NatVpnMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatVpnMappingGetRequestMsg is batched GET request for NAT VPN mappings
type NatVpnMappingGetRequestMsg struct {
	Request []*NatVpnMappingGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatVpnMappingGetRequestMsg) Reset()                    { *m = NatVpnMappingGetRequestMsg{} }
func (m *NatVpnMappingGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingGetRequestMsg) ProtoMessage()               {}
func (*NatVpnMappingGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{23} }

func (m *NatVpnMappingGetRequestMsg) GetRequest() []*NatVpnMappingGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatVpnMappingStats is the statistics object for each NAT VPN mapping
type NatVpnMappingStats struct {
	RxBytes              uint64 `protobuf:"varint,1,opt,name=rx_bytes,json=rxBytes,proto3" json:"rx_bytes,omitempty"`
	RxPackets            uint64 `protobuf:"varint,2,opt,name=rx_packets,json=rxPackets,proto3" json:"rx_packets,omitempty"`
	TxBytes              uint64 `protobuf:"varint,3,opt,name=tx_bytes,json=txBytes,proto3" json:"tx_bytes,omitempty"`
	TxPackets            uint64 `protobuf:"varint,4,opt,name=tx_packets,json=txPackets,proto3" json:"tx_packets,omitempty"`
	RxBytesDropped       uint64 `protobuf:"varint,5,opt,name=rx_bytes_dropped,json=rxBytesDropped,proto3" json:"rx_bytes_dropped,omitempty"`
	RxPacketsDropped     uint64 `protobuf:"varint,6,opt,name=rx_packets_dropped,json=rxPacketsDropped,proto3" json:"rx_packets_dropped,omitempty"`
	TxBytesDropped       uint64 `protobuf:"varint,7,opt,name=tx_bytes_dropped,json=txBytesDropped,proto3" json:"tx_bytes_dropped,omitempty"`
	TxPacketsDropped     uint64 `protobuf:"varint,8,opt,name=tx_packets_dropped,json=txPacketsDropped,proto3" json:"tx_packets_dropped,omitempty"`
	NumTcpSessions       uint32 `protobuf:"varint,9,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions       uint32 `protobuf:"varint,10,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions     uint32 `protobuf:"varint,11,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
	NumActiveConnections uint32 `protobuf:"varint,12,opt,name=num_active_connections,json=numActiveConnections,proto3" json:"num_active_connections,omitempty"`
}

func (m *NatVpnMappingStats) Reset()                    { *m = NatVpnMappingStats{} }
func (m *NatVpnMappingStats) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingStats) ProtoMessage()               {}
func (*NatVpnMappingStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{24} }

func (m *NatVpnMappingStats) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxPackets() uint64 {
	if m != nil {
		return m.RxPackets
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxPackets() uint64 {
	if m != nil {
		return m.TxPackets
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxBytesDropped() uint64 {
	if m != nil {
		return m.RxBytesDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxPacketsDropped() uint64 {
	if m != nil {
		return m.RxPacketsDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxBytesDropped() uint64 {
	if m != nil {
		return m.TxBytesDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxPacketsDropped() uint64 {
	if m != nil {
		return m.TxPacketsDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumActiveConnections() uint32 {
	if m != nil {
		return m.NumActiveConnections
	}
	return 0
}

// NatVpnMappingGetResponse reflects all the information about a NAT VPN mapping
type NatVpnMappingGetResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatVpnMappingSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatVpnMappingStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatVpnMappingStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatVpnMappingGetResponse) Reset()                    { *m = NatVpnMappingGetResponse{} }
func (m *NatVpnMappingGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingGetResponse) ProtoMessage()               {}
func (*NatVpnMappingGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{25} }

func (m *NatVpnMappingGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatVpnMappingGetResponse) GetSpec() *NatVpnMappingSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatVpnMappingGetResponse) GetStatus() *NatVpnMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatVpnMappingGetResponse) GetStats() *NatVpnMappingStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatVpnMappingGetResponseMsg is batched response to NatVpnMappingGetRequestMsg
type NatVpnMappingGetResponseMsg struct {
	Response []*NatVpnMappingGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatVpnMappingGetResponseMsg) Reset()                    { *m = NatVpnMappingGetResponseMsg{} }
func (m *NatVpnMappingGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingGetResponseMsg) ProtoMessage()               {}
func (*NatVpnMappingGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{26} }

func (m *NatVpnMappingGetResponseMsg) GetResponse() []*NatVpnMappingGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*NatPool)(nil), "nat.NatPool")
	proto.RegisterType((*NatRuleSpec)(nil), "nat.NatRuleSpec")
	proto.RegisterType((*NatPolicySpec)(nil), "nat.NatPolicySpec")
	proto.RegisterType((*NatPolicyRequestMsg)(nil), "nat.NatPolicyRequestMsg")
	proto.RegisterType((*NatPolicyStatus)(nil), "nat.NatPolicyStatus")
	proto.RegisterType((*NatPolicyResponse)(nil), "nat.NatPolicyResponse")
	proto.RegisterType((*NatPolicyResponseMsg)(nil), "nat.NatPolicyResponseMsg")
	proto.RegisterType((*NatPolicyDeleteRequest)(nil), "nat.NatPolicyDeleteRequest")
	proto.RegisterType((*NatPolicyDeleteRequestMsg)(nil), "nat.NatPolicyDeleteRequestMsg")
	proto.RegisterType((*NatPolicyDeleteResponse)(nil), "nat.NatPolicyDeleteResponse")
	proto.RegisterType((*NatPolicyDeleteResponseMsg)(nil), "nat.NatPolicyDeleteResponseMsg")
	proto.RegisterType((*NatPolicyGetRequest)(nil), "nat.NatPolicyGetRequest")
	proto.RegisterType((*NatPolicyGetRequestMsg)(nil), "nat.NatPolicyGetRequestMsg")
	proto.RegisterType((*NatRuleStats)(nil), "nat.NatRuleStats")
	proto.RegisterType((*NatPolicyStats)(nil), "nat.NatPolicyStats")
	proto.RegisterType((*NatPolicyGetResponse)(nil), "nat.NatPolicyGetResponse")
	proto.RegisterType((*NatPolicyGetResponseMsg)(nil), "nat.NatPolicyGetResponseMsg")
	proto.RegisterType((*NatVpnMappingSpec)(nil), "nat.NatVpnMappingSpec")
	proto.RegisterType((*NatVpnMappingRequestMsg)(nil), "nat.NatVpnMappingRequestMsg")
	proto.RegisterType((*NatVpnMappingStatus)(nil), "nat.NatVpnMappingStatus")
	proto.RegisterType((*NatVpnMappingResponse)(nil), "nat.NatVpnMappingResponse")
	proto.RegisterType((*NatVpnMappingResponseMsg)(nil), "nat.NatVpnMappingResponseMsg")
	proto.RegisterType((*NatVpnMappingGetRequest)(nil), "nat.NatVpnMappingGetRequest")
	proto.RegisterType((*NatVpnMappingGetRequestMsg)(nil), "nat.NatVpnMappingGetRequestMsg")
	proto.RegisterType((*NatVpnMappingStats)(nil), "nat.NatVpnMappingStats")
	proto.RegisterType((*NatVpnMappingGetResponse)(nil), "nat.NatVpnMappingGetResponse")
	proto.RegisterType((*NatVpnMappingGetResponseMsg)(nil), "nat.NatVpnMappingGetResponseMsg")
	proto.RegisterEnum("nat.NatAction", NatAction_name, NatAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Nat service

type NatClient interface {
	// NAT policy related APIs
	NatPolicyCreate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error)
	NatPolicyUpdate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error)
	NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*NatPolicyDeleteResponseMsg, error)
	NatPolicyGet(ctx context.Context, in *NatPolicyGetRequestMsg, opts ...grpc.CallOption) (*NatPolicyGetResponseMsg, error)
	// NAT-VPN mappings related APIs
	NatVpnMappingCreate(ctx context.Context, in *NatVpnMappingRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingResponseMsg, error)
	NatVpnMappingGet(ctx context.Context, in *NatVpnMappingGetRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingGetResponseMsg, error)
}

type natClient struct {
	cc *grpc.ClientConn
}

func NewNatClient(cc *grpc.ClientConn) NatClient {
	return &natClient{cc}
}

func (c *natClient) NatPolicyCreate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error) {
	out := new(NatPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyUpdate(ctx context.Context, in *NatPolicyRequestMsg, opts ...grpc.CallOption) (*NatPolicyResponseMsg, error) {
	out := new(NatPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*NatPolicyDeleteResponseMsg, error) {
	out := new(NatPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatPolicyGet(ctx context.Context, in *NatPolicyGetRequestMsg, opts ...grpc.CallOption) (*NatPolicyGetResponseMsg, error) {
	out := new(NatPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatVpnMappingCreate(ctx context.Context, in *NatVpnMappingRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingResponseMsg, error) {
	out := new(NatVpnMappingResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatVpnMappingCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatVpnMappingGet(ctx context.Context, in *NatVpnMappingGetRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingGetResponseMsg, error) {
	out := new(NatVpnMappingGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatVpnMappingGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Nat service

type NatServer interface {
	// NAT policy related APIs
	NatPolicyCreate(context.Context, *NatPolicyRequestMsg) (*NatPolicyResponseMsg, error)
	NatPolicyUpdate(context.Context, *NatPolicyRequestMsg) (*NatPolicyResponseMsg, error)
	NatPolicyDelete(context.Context, *NatPolicyDeleteRequestMsg) (*NatPolicyDeleteResponseMsg, error)
	NatPolicyGet(context.Context, *NatPolicyGetRequestMsg) (*NatPolicyGetResponseMsg, error)
	// NAT-VPN mappings related APIs
	NatVpnMappingCreate(context.Context, *NatVpnMappingRequestMsg) (*NatVpnMappingResponseMsg, error)
	NatVpnMappingGet(context.Context, *NatVpnMappingGetRequestMsg) (*NatVpnMappingGetResponseMsg, error)
}

func RegisterNatServer(s *grpc.Server, srv NatServer) {
	s.RegisterService(&_Nat_serviceDesc, srv)
}

func _Nat_NatPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyCreate(ctx, req.(*NatPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyUpdate(ctx, req.(*NatPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyDelete(ctx, req.(*NatPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatPolicyGet(ctx, req.(*NatPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatVpnMappingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatVpnMappingRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatVpnMappingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatVpnMappingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatVpnMappingCreate(ctx, req.(*NatVpnMappingRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatVpnMappingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatVpnMappingGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatVpnMappingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatVpnMappingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatVpnMappingGet(ctx, req.(*NatVpnMappingGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nat.Nat",
	HandlerType: (*NatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatPolicyCreate",
			Handler:    _Nat_NatPolicyCreate_Handler,
		},
		{
			MethodName: "NatPolicyUpdate",
			Handler:    _Nat_NatPolicyUpdate_Handler,
		},
		{
			MethodName: "NatPolicyDelete",
			Handler:    _Nat_NatPolicyDelete_Handler,
		},
		{
			MethodName: "NatPolicyGet",
			Handler:    _Nat_NatPolicyGet_Handler,
		},
		{
			MethodName: "NatVpnMappingCreate",
			Handler:    _Nat_NatVpnMappingCreate_Handler,
		},
		{
			MethodName: "NatVpnMappingGet",
			Handler:    _Nat_NatVpnMappingGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nat.proto",
}

func (m *NatPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, msg := range m.Address {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PortRange.Size()))
		n1, err := m.PortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NatRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RuleId))
	}
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcSg) > 0 {
		dAtA3 := make([]byte, len(m.SrcSg)*10)
		var j2 int
		for _, num := range m.SrcSg {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstSg) > 0 {
		dAtA5 := make([]byte, len(m.DstSg)*10)
		var j4 int
		for _, num := range m.DstSg {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNat(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0x32
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SrcNatAction != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatPool.Size()))
		n6, err := m.SrcNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DstNatPool != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatPool.Size()))
		n7, err := m.DstNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *NatPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NatPolicyHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NatPolicyHandle))
		i += 8
	}
	return i, nil
}

func (m *NatPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PolicyStatus.Size()))
		n10, err := m.PolicyStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NatPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *NatPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *NatPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n13, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n14, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *NatPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *NatPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n15, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n16, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n17, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *NatPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n18, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n19, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *NatVpnMappingRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.SvcMapping != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SvcMapping.Size()))
		n20, err := m.SvcMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *NatVpnMappingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n21, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *NatVpnMappingResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n22, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n23, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *NatVpnMappingGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RxBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RxBytes))
	}
	if m.RxPackets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RxPackets))
	}
	if m.TxBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.TxBytes))
	}
	if m.TxPackets != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.TxPackets))
	}
	if m.RxBytesDropped != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RxBytesDropped))
	}
	if m.RxPacketsDropped != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.RxPacketsDropped))
	}
	if m.TxBytesDropped != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.TxBytesDropped))
	}
	if m.TxPacketsDropped != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.TxPacketsDropped))
	}
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumOtherSessions))
	}
	if m.NumActiveConnections != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumActiveConnections))
	}
	return i, nil
}

func (m *NatVpnMappingGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n24, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n25, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n26, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *NatVpnMappingGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NatPool) Size() (n int) {
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.PortRange != nil {
		l = m.PortRange.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNat(uint64(m.RuleId))
	}
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.SrcSg) > 0 {
		l = 0
		for _, e := range m.SrcSg {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.DstSg) > 0 {
		l = 0
		for _, e := range m.DstSg {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.SrcNatAction != 0 {
		n += 1 + sovNat(uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		n += 1 + sovNat(uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		l = m.SrcNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.DstNatPool != nil {
		l = m.DstNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.NatPolicyHandle != 0 {
		n += 9
	}
	return n
}

func (m *NatPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		l = m.PolicyStatus.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	return n
}

func (m *NatPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNat(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *NatPolicyStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatVpnMappingRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.SvcMapping != nil {
		l = m.SvcMapping.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatVpnMappingResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatVpnMappingResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatVpnMappingGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingStats) Size() (n int) {
	var l int
	_ = l
	if m.RxBytes != 0 {
		n += 1 + sovNat(uint64(m.RxBytes))
	}
	if m.RxPackets != 0 {
		n += 1 + sovNat(uint64(m.RxPackets))
	}
	if m.TxBytes != 0 {
		n += 1 + sovNat(uint64(m.TxBytes))
	}
	if m.TxPackets != 0 {
		n += 1 + sovNat(uint64(m.TxPackets))
	}
	if m.RxBytesDropped != 0 {
		n += 1 + sovNat(uint64(m.RxBytesDropped))
	}
	if m.RxPacketsDropped != 0 {
		n += 1 + sovNat(uint64(m.RxPacketsDropped))
	}
	if m.TxBytesDropped != 0 {
		n += 1 + sovNat(uint64(m.TxBytesDropped))
	}
	if m.TxPacketsDropped != 0 {
		n += 1 + sovNat(uint64(m.TxPacketsDropped))
	}
	if m.NumTcpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNat(uint64(m.NumOtherSessions))
	}
	if m.NumActiveConnections != 0 {
		n += 1 + sovNat(uint64(m.NumActiveConnections))
	}
	return n
}

func (m *NatVpnMappingGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatVpnMappingGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func sovNat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNat(x uint64) (n int) {
	return sovNat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &Address{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortRange == nil {
				m.PortRange = &L4PortRange{}
			}
			if err := m.PortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressObj{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcSg = append(m.SrcSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcSg = append(m.SrcSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSg", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressObj{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstSg = append(m.DstSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstSg = append(m.DstSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSg", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatAction", wireType)
			}
			m.DstNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcNatPool == nil {
				m.SrcNatPool = &NatPool{}
			}
			if err := m.SrcNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatPool == nil {
				m.DstNatPool = &NatPool{}
			}
			if err := m.DstNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &NatRuleSpec{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPolicyHandle", wireType)
			}
			m.NatPolicyHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPolicyHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyStatus == nil {
				m.PolicyStatus = &NatPolicyStatus{}
			}
			if err := m.PolicyStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &NatRuleStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatVpnMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatVpnMappingSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvcMapping == nil {
				m.SvcMapping = &Svc{}
			}
			if err := m.SvcMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatVpnMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatVpnMappingResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatVpnMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatVpnMappingGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
			}
			m.RxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
			}
			m.TxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytesDropped", wireType)
			}
			m.RxBytesDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytesDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPacketsDropped", wireType)
			}
			m.RxPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPacketsDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytesDropped", wireType)
			}
			m.TxBytesDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytesDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPacketsDropped", wireType)
			}
			m.TxPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPacketsDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumActiveConnections", wireType)
			}
			m.NumActiveConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumActiveConnections |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatVpnMappingSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatVpnMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatVpnMappingStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatVpnMappingGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nat.proto", fileDescriptorNat) }

var fileDescriptorNat = []byte{
	// 1421 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdf, 0x6e, 0x1b, 0x45,
	0x17, 0xef, 0xc6, 0x8e, 0x9d, 0x1c, 0x3b, 0xae, 0x33, 0x6d, 0x93, 0x8d, 0xf3, 0xf7, 0x5b, 0xe9,
	0xeb, 0xe7, 0xaf, 0x2a, 0x56, 0x31, 0x01, 0xb5, 0x48, 0x08, 0x39, 0x49, 0xa1, 0xa5, 0x8d, 0x63,
	0xad, 0xdd, 0x96, 0x72, 0xb3, 0xda, 0xec, 0x0e, 0x8e, 0x1b, 0x67, 0x77, 0xd9, 0x19, 0x47, 0xb1,
	0xc4, 0x05, 0xd7, 0x08, 0x24, 0xc4, 0x05, 0xe2, 0x21, 0x78, 0x10, 0x2e, 0x79, 0x82, 0x82, 0xca,
	0x1d, 0x5c, 0x80, 0xfa, 0x04, 0x68, 0x66, 0x76, 0x76, 0xd7, 0xbb, 0xeb, 0xd0, 0x8a, 0xa2, 0x5e,
	0x65, 0x67, 0xce, 0xef, 0xfc, 0xe6, 0x9c, 0x99, 0xdf, 0x9c, 0x33, 0x0e, 0xcc, 0x3b, 0x26, 0x6d,
	0x78, 0xbe, 0x4b, 0x5d, 0x94, 0x73, 0x4c, 0x5a, 0x2b, 0xd1, 0xb1, 0x87, 0x89, 0x98, 0xa9, 0xcd,
	0x1d, 0x1f, 0x89, 0x2f, 0xed, 0x53, 0x28, 0xb6, 0x4d, 0xda, 0x71, 0xdd, 0x21, 0xaa, 0x43, 0xd1,
	0xb4, 0x6d, 0x1f, 0x13, 0xa2, 0x2a, 0x5b, 0xb9, 0x7a, 0xa9, 0x59, 0x69, 0x08, 0x9f, 0x96, 0x98,
	0xd5, 0xa5, 0x19, 0xbd, 0x09, 0xe0, 0xb9, 0x3e, 0x35, 0x7c, 0xd3, 0xe9, 0x63, 0x75, 0x66, 0x4b,
	0xa9, 0x97, 0x9a, 0x28, 0x00, 0xdf, 0xdf, 0xee, 0xb8, 0x3e, 0xd5, 0x99, 0x45, 0x9f, 0xf7, 0xe4,
	0xa7, 0xf6, 0x45, 0x1e, 0x4a, 0x6d, 0x93, 0xea, 0xa3, 0x21, 0xee, 0x7a, 0xd8, 0x42, 0xcb, 0x50,
	0xf4, 0x47, 0x43, 0x6c, 0x0c, 0x6c, 0x55, 0xd9, 0x52, 0xea, 0x79, 0xbd, 0xc0, 0x86, 0x77, 0x6d,
	0xb4, 0x0d, 0x25, 0xe2, 0x5b, 0x86, 0x8c, 0x64, 0x86, 0x47, 0x72, 0x29, 0x20, 0xbf, 0xdb, 0x09,
	0x62, 0x39, 0x38, 0x7c, 0xa2, 0x03, 0xf1, 0xad, 0x60, 0x88, 0xae, 0x40, 0x81, 0x79, 0x91, 0xbe,
	0x9a, 0xdb, 0xca, 0xd5, 0x17, 0xf4, 0x59, 0xe2, 0x5b, 0xdd, 0x3e, 0x23, 0xb3, 0x09, 0x0d, 0xc9,
	0xf2, 0xe7, 0x90, 0xd9, 0x84, 0xc6, 0xc8, 0x98, 0x17, 0xe9, 0xab, 0xb3, 0x82, 0xcc, 0x26, 0xb4,
	0xdb, 0x47, 0x37, 0xa1, 0xc2, 0xa6, 0x63, 0x99, 0x17, 0x38, 0x5f, 0x56, 0xe6, 0x65, 0x9b, 0xd0,
	0x70, 0xc4, 0x3c, 0x59, 0x74, 0x31, 0xcf, 0xe2, 0x74, 0x4f, 0xe2, 0x5b, 0x91, 0xe7, 0xb6, 0xf0,
	0x74, 0x4c, 0x6a, 0x98, 0x16, 0x1d, 0xb8, 0x8e, 0x3a, 0xb7, 0xa5, 0xd4, 0x2b, 0xcd, 0x4a, 0x83,
	0x1d, 0x6f, 0xdb, 0xa4, 0x2d, 0x3e, 0xcb, 0xbd, 0xc2, 0x11, 0xf3, 0x62, 0x91, 0xc6, 0xbc, 0xe6,
	0xb3, 0xbd, 0x6c, 0x42, 0x23, 0xaf, 0x06, 0x94, 0xe5, 0x5a, 0x9e, 0xeb, 0x0e, 0x55, 0xe0, 0xe7,
	0x5a, 0x96, 0x3e, 0x4c, 0x23, 0x7c, 0xcf, 0xa5, 0x5e, 0x1a, 0x50, 0x96, 0xab, 0x70, 0x7c, 0x29,
	0x0b, 0x2f, 0x56, 0x60, 0xdf, 0xda, 0x0f, 0x0a, 0x2c, 0xf0, 0xef, 0xe1, 0xc0, 0x1a, 0x73, 0x11,
	0xfc, 0x17, 0xf2, 0x27, 0x98, 0x9a, 0x5c, 0x01, 0xa5, 0xe6, 0x62, 0xb0, 0x1b, 0x07, 0x87, 0x4f,
	0xb0, 0x45, 0xf7, 0x31, 0x35, 0x75, 0x6e, 0x46, 0xf7, 0x61, 0xe1, 0x18, 0x8f, 0x0d, 0xd7, 0x37,
	0x8e, 0x4c, 0xc7, 0x1e, 0x4a, 0xc5, 0x2d, 0x35, 0x8e, 0x8f, 0x1a, 0x21, 0xe1, 0x3d, 0x3c, 0xbe,
	0xc3, 0xad, 0x3b, 0xd5, 0xe7, 0x4f, 0x37, 0xcb, 0xa7, 0xd8, 0x19, 0x58, 0xf8, 0x5d, 0xed, 0x18,
	0x8f, 0x35, 0xbd, 0x74, 0x8c, 0xc7, 0x07, 0xbe, 0x30, 0xa3, 0xab, 0x30, 0xcb, 0xa4, 0x46, 0xb8,
	0x52, 0x4a, 0xcd, 0xaa, 0x8c, 0x57, 0x4a, 0x53, 0x17, 0x66, 0x6d, 0x17, 0x2e, 0x85, 0xe4, 0x3a,
	0xfe, 0x6c, 0x84, 0x09, 0xdd, 0x27, 0x7d, 0x74, 0x1d, 0x8a, 0xbe, 0x18, 0x05, 0xb7, 0x04, 0x45,
	0x09, 0xcb, 0xc4, 0x74, 0x09, 0xd1, 0xde, 0x83, 0x8b, 0x91, 0x85, 0x9a, 0x74, 0x44, 0xd0, 0x35,
	0x58, 0x14, 0x5b, 0xc6, 0xe6, 0x64, 0x46, 0x6c, 0x07, 0x0a, 0xfa, 0x45, 0x47, 0x62, 0x45, 0xac,
	0xda, 0x77, 0x0a, 0x2c, 0xc6, 0x82, 0x20, 0x9e, 0xeb, 0x10, 0x8c, 0x3e, 0x00, 0x30, 0xbd, 0x81,
	0x41, 0x38, 0x1f, 0x77, 0xad, 0x34, 0xab, 0xf2, 0xae, 0x7a, 0x03, 0xb1, 0xce, 0xce, 0x95, 0xe7,
	0x4f, 0x37, 0x17, 0x83, 0x6d, 0x88, 0xe0, 0xfa, 0xbc, 0x29, 0x11, 0xe8, 0x16, 0x2c, 0x04, 0x51,
	0x04, 0x54, 0x62, 0x5f, 0x2f, 0x27, 0x12, 0x12, 0x7e, 0x65, 0x2f, 0x36, 0xd2, 0x3e, 0x82, 0xcb,
	0xa9, 0xb8, 0xd8, 0xee, 0x34, 0x61, 0xce, 0x0f, 0x86, 0xc1, 0xf6, 0x2c, 0x4d, 0xb2, 0x49, 0xb0,
	0x1e, 0xe2, 0xb4, 0xaf, 0x15, 0x58, 0x0a, 0xed, 0x7b, 0x78, 0x88, 0x29, 0x0e, 0xf6, 0xfb, 0xb5,
	0x08, 0x44, 0xd3, 0x61, 0x25, 0x3b, 0x1c, 0x96, 0xe0, 0xdb, 0xc9, 0xe3, 0x5f, 0x9d, 0xcc, 0x6f,
	0xc2, 0x21, 0xd2, 0x81, 0x09, 0xcb, 0x29, 0xc8, 0xab, 0x3d, 0x4d, 0xed, 0x21, 0xd4, 0xa6, 0x2c,
	0xc1, 0xe2, 0xbe, 0x99, 0x3a, 0x98, 0xb5, 0xec, 0xc0, 0x53, 0xc7, 0xf3, 0xa5, 0x12, 0xbb, 0x08,
	0x1f, 0x62, 0xfa, 0x5a, 0xcf, 0xe6, 0x7e, 0x4c, 0x2a, 0x51, 0x2c, 0x42, 0x79, 0x89, 0x83, 0x51,
	0x27, 0xf3, 0x8b, 0xd0, 0xd1, 0xa9, 0x7c, 0xa3, 0x40, 0x59, 0xde, 0x7c, 0x6a, 0x52, 0x82, 0xea,
	0x50, 0x75, 0x46, 0x27, 0x06, 0xb5, 0x3c, 0x83, 0x60, 0x42, 0x06, 0xae, 0x23, 0x4e, 0x64, 0x41,
	0xaf, 0x38, 0xa3, 0x93, 0x9e, 0xe5, 0x75, 0x83, 0x59, 0x89, 0x1c, 0xd9, 0x31, 0xe4, 0x4c, 0x88,
	0x7c, 0x60, 0x47, 0xc8, 0xeb, 0x80, 0x18, 0xd2, 0xa5, 0x47, 0xd8, 0x8f, 0xb0, 0x39, 0x8e, 0x65,
	0x1c, 0x07, 0xcc, 0x20, 0xd1, 0xda, 0x2d, 0xa8, 0x4c, 0xdc, 0x3c, 0x82, 0xfe, 0x07, 0xb3, 0xec,
	0xb0, 0x65, 0x53, 0x5e, 0x9c, 0xa8, 0x57, 0xcc, 0xa0, 0x0b, 0xbb, 0xf6, 0xb3, 0x12, 0xbb, 0x94,
	0x3c, 0xdd, 0x57, 0x5c, 0x2f, 0xae, 0x42, 0x9e, 0x78, 0xd8, 0x0a, 0x1b, 0x7e, 0xba, 0xee, 0x71,
	0x3b, 0xba, 0x0e, 0x85, 0x60, 0xad, 0xdc, 0x39, 0x05, 0x25, 0xc0, 0xa0, 0xff, 0xcb, 0xfc, 0xf2,
	0x1c, 0x7c, 0x29, 0x0d, 0x0e, 0x33, 0xec, 0xc4, 0x6e, 0x51, 0x2c, 0x41, 0x71, 0x2f, 0x93, 0xfa,
	0x5e, 0xc9, 0x38, 0xff, 0x94, 0xb8, 0xbf, 0x12, 0x05, 0xf6, 0xa1, 0xe7, 0xec, 0x9b, 0x9e, 0x37,
	0x70, 0xfa, 0x2f, 0xd3, 0x97, 0x3a, 0xd9, 0xd2, 0xae, 0x05, 0xd2, 0x8e, 0x48, 0x5f, 0x58, 0xde,
	0xf7, 0x78, 0x82, 0x91, 0x63, 0x4c, 0xdf, 0x37, 0x92, 0xfa, 0x0e, 0x0b, 0xeb, 0x64, 0xf0, 0x91,
	0xba, 0x1f, 0xf1, 0x7b, 0x1b, 0xb3, 0x8a, 0xfd, 0x5e, 0x82, 0xc2, 0x44, 0xd3, 0x09, 0x46, 0xa8,
	0x0e, 0x25, 0x72, 0x6a, 0x19, 0x27, 0x02, 0x1c, 0xe4, 0x52, 0x64, 0xb9, 0x74, 0x4f, 0x2d, 0x1d,
	0xc8, 0xa9, 0x15, 0xf0, 0xb0, 0x8a, 0x70, 0x25, 0x11, 0x66, 0xa0, 0xb4, 0xf7, 0x5f, 0x48, 0x69,
	0x95, 0xdf, 0x9e, 0x6e, 0x42, 0xb6, 0xc4, 0x6e, 0x84, 0xd2, 0x11, 0xeb, 0xab, 0x19, 0x49, 0x4e,
	0xc8, 0x47, 0xd3, 0x41, 0xcd, 0x8c, 0x85, 0xed, 0xd9, 0x3b, 0x29, 0x51, 0xd4, 0xd2, 0x7c, 0x19,
	0xaa, 0xf8, 0x56, 0x49, 0x9c, 0xc3, 0xcb, 0x97, 0xbd, 0x57, 0xaf, 0x8d, 0x1e, 0xaf, 0xef, 0x59,
	0x31, 0x89, 0x54, 0x13, 0xf2, 0x58, 0x4b, 0x67, 0x9a, 0x55, 0x02, 0xff, 0xcc, 0x01, 0x4a, 0x6d,
	0x2f, 0x41, 0x2b, 0x30, 0xe7, 0x9f, 0x19, 0x87, 0x63, 0x8a, 0x49, 0xf0, 0x3e, 0x2f, 0xfa, 0x67,
	0x3b, 0x6c, 0x88, 0xd6, 0x01, 0xfc, 0x33, 0xc3, 0x33, 0xad, 0x63, 0x4c, 0xc5, 0x31, 0xe5, 0xf5,
	0x79, 0xff, 0xac, 0x23, 0x26, 0x98, 0x27, 0x95, 0x9e, 0x39, 0xe1, 0x49, 0x23, 0x4f, 0x1a, 0x79,
	0xe6, 0x85, 0x27, 0x0d, 0x3d, 0xeb, 0x50, 0x95, 0x6b, 0x1a, 0xb6, 0xef, 0x7a, 0x1e, 0xb6, 0xd5,
	0x59, 0x0e, 0xaa, 0x04, 0x6b, 0xef, 0x89, 0x59, 0x56, 0x52, 0xa3, 0x10, 0x42, 0x6c, 0x81, 0x63,
	0xab, 0x61, 0x28, 0x12, 0x5d, 0x87, 0x2a, 0x4d, 0xf2, 0x16, 0x05, 0x2f, 0x4d, 0xf1, 0xd2, 0x34,
	0xef, 0x9c, 0xe0, 0xa5, 0x19, 0xbc, 0xa9, 0x66, 0x31, 0xff, 0xc2, 0xcd, 0x02, 0x5e, 0xa2, 0x59,
	0x94, 0xb2, 0x9b, 0x05, 0xda, 0x86, 0x25, 0x86, 0x66, 0x6f, 0xfc, 0x53, 0x6c, 0x58, 0xae, 0xe3,
	0x60, 0xfe, 0x94, 0x27, 0x6a, 0x99, 0x7b, 0x5c, 0x76, 0x46, 0x27, 0x2d, 0x6e, 0xdc, 0x8d, 0x6c,
	0xda, 0x1f, 0x4a, 0xe2, 0xca, 0xfc, 0x1b, 0xbd, 0xe2, 0xda, 0x44, 0xaf, 0x98, 0x56, 0xab, 0x44,
	0xbf, 0xb8, 0x91, 0xe8, 0x17, 0x7f, 0x7b, 0xe9, 0xd1, 0x1b, 0x93, 0x3d, 0x63, 0x39, 0xdb, 0x21,
	0xec, 0x1b, 0x1f, 0xc3, 0xea, 0xb4, 0x84, 0xd9, 0xdd, 0xb9, 0x95, 0x2a, 0x13, 0xeb, 0x53, 0x2e,
	0x4f, 0xb2, 0x52, 0x5c, 0xfb, 0x1c, 0xe6, 0xa3, 0x1f, 0x50, 0x8b, 0xb0, 0xd0, 0x6e, 0xf5, 0x8c,
	0xde, 0xe3, 0xce, 0x6d, 0xa3, 0x7d, 0xd0, 0xbe, 0x5d, 0xbd, 0x80, 0x56, 0x61, 0x39, 0x9c, 0xea,
	0xf6, 0x5a, 0xbd, 0xbb, 0xbb, 0x46, 0x6b, 0x6f, 0x4f, 0xbf, 0xdd, 0xed, 0x56, 0x15, 0xb4, 0x06,
	0x6a, 0x68, 0xdc, 0x7b, 0xdc, 0x6e, 0xed, 0xc7, 0xac, 0x33, 0xe8, 0x3f, 0xb0, 0x3e, 0xcd, 0x6a,
	0x74, 0x0e, 0xf4, 0x5e, 0x35, 0xd7, 0xfc, 0x3d, 0x07, 0xb9, 0xb6, 0x49, 0xd1, 0x9d, 0xd8, 0xaf,
	0x8c, 0x5d, 0x1f, 0x9b, 0x14, 0x23, 0x35, 0xf9, 0xec, 0x96, 0x95, 0xa2, 0xb6, 0x92, 0xfd, 0x20,
	0xdf, 0x27, 0x7d, 0xed, 0xc2, 0x04, 0xd3, 0x03, 0xcf, 0xfe, 0x07, 0x4c, 0xbd, 0x18, 0x93, 0x78,
	0x5b, 0xa2, 0x8d, 0x73, 0x9e, 0xca, 0x8c, 0x6f, 0xf3, 0xbc, 0x17, 0xa9, 0x60, 0xbd, 0xc7, 0x1f,
	0x6c, 0x61, 0x47, 0x47, 0xab, 0xd3, 0x1e, 0x79, 0x8c, 0x6f, 0x6d, 0xea, 0x0b, 0x40, 0x86, 0x38,
	0xd9, 0x20, 0x83, 0xad, 0x5b, 0xcb, 0xea, 0x11, 0x21, 0xe9, 0xfa, 0xf4, 0x0e, 0x22, 0x58, 0x1f,
	0x41, 0x35, 0x29, 0x1c, 0xb4, 0x79, 0x5e, 0x31, 0x66, 0xac, 0x5b, 0xe7, 0x0a, 0x8e, 0x13, 0xef,
	0xd4, 0x7e, 0x7c, 0xb6, 0xa1, 0xfc, 0xf4, 0x6c, 0x43, 0xf9, 0xe5, 0xd9, 0x86, 0xf2, 0xfd, 0xaf,
	0x1b, 0x17, 0x3e, 0x99, 0x3b, 0x32, 0x87, 0xfc, 0xdf, 0x38, 0x87, 0x05, 0xfe, 0xe7, 0xad, 0xbf,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x5c, 0xa4, 0x2d, 0xea, 0xf6, 0x11, 0x00, 0x00,
}
