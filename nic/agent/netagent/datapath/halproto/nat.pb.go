// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_TYPE_NONE                 NatAction = 0
	NatAction_NAT_TYPE_STATIC_ADDRESS       NatAction = 1
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS      NatAction = 2
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS_PORT NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_STATIC_ADDRESS",
	2: "NAT_TYPE_DYNAMIC_ADDRESS",
	3: "NAT_TYPE_DYNAMIC_ADDRESS_PORT",
}
var NatAction_value = map[string]int32{
	"NAT_TYPE_NONE":                 0,
	"NAT_TYPE_STATIC_ADDRESS":       1,
	"NAT_TYPE_DYNAMIC_ADDRESS":      2,
	"NAT_TYPE_DYNAMIC_ADDRESS_PORT": 3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}
func (NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

// NAT pool definition
// NOTE: addresses inside the NAT pool are "owned" by the device, so device is
// expected to advertise the routes for the same and respond to ARP requests
type NatPool struct {
	Address   []*Address   `protobuf:"bytes,1,rep,name=address" json:"address,omitempty"`
	PortRange *L4PortRange `protobuf:"bytes,2,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *NatPool) Reset()                    { *m = NatPool{} }
func (m *NatPool) String() string            { return proto.CompactTextString(m) }
func (*NatPool) ProtoMessage()               {}
func (*NatPool) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

func (m *NatPool) GetAddress() []*Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NatPool) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

// NatRuleSpec is the user intent for the NAT rule
type NatRuleSpec struct {
	Meta        *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	// NAT rule match conditions
	SrcAddress   []*IPAddressObj `protobuf:"bytes,3,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	SrcSg        []uint32        `protobuf:"varint,4,rep,packed,name=src_sg,json=srcSg" json:"src_sg,omitempty"`
	DstAddress   []*IPAddressObj `protobuf:"bytes,5,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstSg        []uint32        `protobuf:"varint,6,rep,packed,name=dst_sg,json=dstSg" json:"dst_sg,omitempty"`
	DstPortRange []*L4PortRange  `protobuf:"bytes,7,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange  `protobuf:"bytes,8,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	// NAT rule action related attributes
	SrcNatAction NatAction `protobuf:"varint,9,opt,name=src_nat_action,json=srcNatAction,proto3,enum=nat.NatAction" json:"src_nat_action,omitempty"`
	DstNatAction NatAction `protobuf:"varint,10,opt,name=dst_nat_action,json=dstNatAction,proto3,enum=nat.NatAction" json:"dst_nat_action,omitempty"`
	SrcNatPool   *NatPool  `protobuf:"bytes,11,opt,name=src_nat_pool,json=srcNatPool" json:"src_nat_pool,omitempty"`
	DstNatPool   *NatPool  `protobuf:"bytes,12,opt,name=dst_nat_pool,json=dstNatPool" json:"dst_nat_pool,omitempty"`
}

func (m *NatRuleSpec) Reset()                    { *m = NatRuleSpec{} }
func (m *NatRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*NatRuleSpec) ProtoMessage()               {}
func (*NatRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{1} }

func (m *NatRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatRuleSpec) GetKeyOrHandle() *NatRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatRuleSpec) GetSrcAddress() []*IPAddressObj {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *NatRuleSpec) GetSrcSg() []uint32 {
	if m != nil {
		return m.SrcSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstAddress() []*IPAddressObj {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *NatRuleSpec) GetDstSg() []uint32 {
	if m != nil {
		return m.DstSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetDstNatAction() NatAction {
	if m != nil {
		return m.DstNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetSrcNatPool() *NatPool {
	if m != nil {
		return m.SrcNatPool
	}
	return nil
}

func (m *NatRuleSpec) GetDstNatPool() *NatPool {
	if m != nil {
		return m.DstNatPool
	}
	return nil
}

// NatRuleRequestMsg is the batched add or modify of NAT rule request
type NatRuleRequestMsg struct {
	Request []*NatRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatRuleRequestMsg) Reset()                    { *m = NatRuleRequestMsg{} }
func (m *NatRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleRequestMsg) ProtoMessage()               {}
func (*NatRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{2} }

func (m *NatRuleRequestMsg) GetRequest() []*NatRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatRuleStatus reflects the current opertional status of the NAT rule
type NatRuleStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *NatRuleStatus) Reset()                    { *m = NatRuleStatus{} }
func (m *NatRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStatus) ProtoMessage()               {}
func (*NatRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{3} }

func (m *NatRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// NatRuleResponse is the response to NatRuleSpec
type NatRuleResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *NatRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *NatRuleResponse) Reset()                    { *m = NatRuleResponse{} }
func (m *NatRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*NatRuleResponse) ProtoMessage()               {}
func (*NatRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{4} }

func (m *NatRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleResponse) GetStatus() *NatRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// NatRuleResponseMsg is batched response to NatRuleRequestMsg
type NatRuleResponseMsg struct {
	Response []*NatRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatRuleResponseMsg) Reset()                    { *m = NatRuleResponseMsg{} }
func (m *NatRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleResponseMsg) ProtoMessage()               {}
func (*NatRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{5} }

func (m *NatRuleResponseMsg) GetResponse() []*NatRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatRuleGetRequest is used to get information about a NAT rule
type NatRuleGetRequest struct {
	Meta        *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatRuleGetRequest) Reset()                    { *m = NatRuleGetRequest{} }
func (m *NatRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetRequest) ProtoMessage()               {}
func (*NatRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{6} }

func (m *NatRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatRuleGetRequest) GetKeyOrHandle() *NatRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatRuleGetRequestMsg is batched GET request for NAT rules
type NatRuleGetRequestMsg struct {
	Request []*NatRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatRuleGetRequestMsg) Reset()                    { *m = NatRuleGetRequestMsg{} }
func (m *NatRuleGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetRequestMsg) ProtoMessage()               {}
func (*NatRuleGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{7} }

func (m *NatRuleGetRequestMsg) GetRequest() []*NatRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatRuleStats is the statistics object for each NAT rule
type NatRuleStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions   uint32 `protobuf:"varint,2,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,3,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *NatRuleStats) Reset()                    { *m = NatRuleStats{} }
func (m *NatRuleStats) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStats) ProtoMessage()               {}
func (*NatRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{8} }

func (m *NatRuleStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// NatRuleGetResponse reflects all the information about a NAT rule
type NatRuleGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatRuleStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatRuleGetResponse) Reset()                    { *m = NatRuleGetResponse{} }
func (m *NatRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetResponse) ProtoMessage()               {}
func (*NatRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{9} }

func (m *NatRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleGetResponse) GetSpec() *NatRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatRuleGetResponse) GetStatus() *NatRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatRuleGetResponse) GetStats() *NatRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatRuleGetResponseMsg is batched response to NatRuleGetRequestMsg
type NatRuleGetResponseMsg struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*NatRuleGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *NatRuleGetResponseMsg) Reset()                    { *m = NatRuleGetResponseMsg{} }
func (m *NatRuleGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetResponseMsg) ProtoMessage()               {}
func (*NatRuleGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{10} }

func (m *NatRuleGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleGetResponseMsg) GetResponse() []*NatRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*NatPool)(nil), "nat.NatPool")
	proto.RegisterType((*NatRuleSpec)(nil), "nat.NatRuleSpec")
	proto.RegisterType((*NatRuleRequestMsg)(nil), "nat.NatRuleRequestMsg")
	proto.RegisterType((*NatRuleStatus)(nil), "nat.NatRuleStatus")
	proto.RegisterType((*NatRuleResponse)(nil), "nat.NatRuleResponse")
	proto.RegisterType((*NatRuleResponseMsg)(nil), "nat.NatRuleResponseMsg")
	proto.RegisterType((*NatRuleGetRequest)(nil), "nat.NatRuleGetRequest")
	proto.RegisterType((*NatRuleGetRequestMsg)(nil), "nat.NatRuleGetRequestMsg")
	proto.RegisterType((*NatRuleStats)(nil), "nat.NatRuleStats")
	proto.RegisterType((*NatRuleGetResponse)(nil), "nat.NatRuleGetResponse")
	proto.RegisterType((*NatRuleGetResponseMsg)(nil), "nat.NatRuleGetResponseMsg")
	proto.RegisterEnum("nat.NatAction", NatAction_name, NatAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Nat service

type NatClient interface {
	NatRuleCreate(ctx context.Context, in *NatRuleRequestMsg, opts ...grpc.CallOption) (*NatRuleResponseMsg, error)
	NatRuleGet(ctx context.Context, in *NatRuleGetRequestMsg, opts ...grpc.CallOption) (*NatRuleGetResponseMsg, error)
}

type natClient struct {
	cc *grpc.ClientConn
}

func NewNatClient(cc *grpc.ClientConn) NatClient {
	return &natClient{cc}
}

func (c *natClient) NatRuleCreate(ctx context.Context, in *NatRuleRequestMsg, opts ...grpc.CallOption) (*NatRuleResponseMsg, error) {
	out := new(NatRuleResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatRuleGet(ctx context.Context, in *NatRuleGetRequestMsg, opts ...grpc.CallOption) (*NatRuleGetResponseMsg, error) {
	out := new(NatRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Nat service

type NatServer interface {
	NatRuleCreate(context.Context, *NatRuleRequestMsg) (*NatRuleResponseMsg, error)
	NatRuleGet(context.Context, *NatRuleGetRequestMsg) (*NatRuleGetResponseMsg, error)
}

func RegisterNatServer(s *grpc.Server, srv NatServer) {
	s.RegisterService(&_Nat_serviceDesc, srv)
}

func _Nat_NatRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatRuleCreate(ctx, req.(*NatRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatRuleGet(ctx, req.(*NatRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nat.Nat",
	HandlerType: (*NatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatRuleCreate",
			Handler:    _Nat_NatRuleCreate_Handler,
		},
		{
			MethodName: "NatRuleGet",
			Handler:    _Nat_NatRuleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nat.proto",
}

func (m *NatPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, msg := range m.Address {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.PortRange.Size()))
		n1, err := m.PortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NatRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n3, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcSg) > 0 {
		dAtA5 := make([]byte, len(m.SrcSg)*10)
		var j4 int
		for _, num := range m.SrcSg {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstSg) > 0 {
		dAtA7 := make([]byte, len(m.DstSg)*10)
		var j6 int
		for _, num := range m.DstSg {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintNat(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SrcNatAction != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatPool.Size()))
		n8, err := m.SrcNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DstNatPool != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.DstNatPool.Size()))
		n9, err := m.DstNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *NatRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *NatRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NatRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *NatRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *NatRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Stats.Size()))
		n15, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *NatRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NatPool) Size() (n int) {
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.PortRange != nil {
		l = m.PortRange.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.SrcSg) > 0 {
		l = 0
		for _, e := range m.SrcSg {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.DstSg) > 0 {
		l = 0
		for _, e := range m.DstSg {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.SrcNatAction != 0 {
		n += 1 + sovNat(uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		n += 1 + sovNat(uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		l = m.SrcNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.DstNatPool != nil {
		l = m.DstNatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *NatRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNat(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNat(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *NatRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func sovNat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNat(x uint64) (n int) {
	return sovNat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &Address{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortRange == nil {
				m.PortRange = &L4PortRange{}
			}
			if err := m.PortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressObj{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcSg = append(m.SrcSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcSg = append(m.SrcSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSg", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressObj{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstSg = append(m.DstSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstSg = append(m.DstSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSg", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatAction", wireType)
			}
			m.DstNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcNatPool == nil {
				m.SrcNatPool = &NatPool{}
			}
			if err := m.SrcNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatPool == nil {
				m.DstNatPool = &NatPool{}
			}
			if err := m.DstNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nat.proto", fileDescriptorNat) }

var fileDescriptorNat = []byte{
	// 864 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0xeb, 0x34, 0x6d, 0x5e, 0x7e, 0x90, 0x0e, 0xfd, 0x61, 0x02, 0xb4, 0xc5, 0x02, 0x6d,
	0x54, 0xa1, 0x08, 0xb2, 0x3d, 0x20, 0x2e, 0xab, 0x74, 0x9b, 0x65, 0x17, 0x88, 0x13, 0x4d, 0xc2,
	0x61, 0xb9, 0x58, 0x53, 0x7b, 0x48, 0xb2, 0x49, 0x6d, 0xe3, 0x99, 0x20, 0x45, 0x42, 0x1c, 0x39,
	0xef, 0x81, 0x03, 0x7f, 0x12, 0x47, 0x6e, 0x48, 0x1c, 0x2a, 0x54, 0x6e, 0x1c, 0xf7, 0x2f, 0x40,
	0x33, 0x9e, 0xb1, 0x4d, 0x92, 0x02, 0x07, 0x24, 0x4e, 0x99, 0x79, 0xef, 0xfb, 0xbe, 0x37, 0xef,
	0xcd, 0x37, 0x0e, 0x94, 0x02, 0xc2, 0x5b, 0x51, 0x1c, 0xf2, 0x10, 0x99, 0x01, 0xe1, 0x8d, 0x32,
	0x5f, 0x46, 0x94, 0x25, 0x91, 0xc6, 0xde, 0x6c, 0x92, 0xac, 0xec, 0xaf, 0x60, 0xd7, 0x21, 0x7c,
	0x10, 0x86, 0x73, 0xd4, 0x84, 0x5d, 0xe2, 0xfb, 0x31, 0x65, 0xcc, 0x32, 0xce, 0xcc, 0x66, 0xb9,
	0x5d, 0x6b, 0x25, 0x9c, 0x4e, 0x12, 0xc5, 0x3a, 0x8d, 0x3e, 0x04, 0x88, 0xc2, 0x98, 0xbb, 0x31,
	0x09, 0xc6, 0xd4, 0xda, 0x3e, 0x33, 0x9a, 0xe5, 0x36, 0x52, 0xe0, 0xcf, 0x2f, 0x06, 0x61, 0xcc,
	0xb1, 0xc8, 0xe0, 0x52, 0xa4, 0x97, 0xf6, 0xaf, 0x05, 0x28, 0x3b, 0x84, 0xe3, 0xc5, 0x9c, 0x0e,
	0x23, 0xea, 0xa1, 0xf7, 0xa0, 0x70, 0x43, 0x39, 0xb1, 0x0c, 0x49, 0xde, 0x57, 0xe4, 0xfe, 0xf5,
	0x0b, 0xea, 0xf1, 0x1e, 0xe5, 0x04, 0xcb, 0x34, 0xfa, 0x14, 0xaa, 0x33, 0xba, 0x74, 0xc3, 0xd8,
	0x9d, 0x90, 0xc0, 0x9f, 0xeb, 0x62, 0x07, 0xad, 0xd9, 0xa4, 0xa5, 0xe4, 0x3e, 0xa3, 0xcb, 0xa7,
	0x32, 0x77, 0x59, 0x7f, 0x75, 0x7b, 0x5a, 0xf9, 0x86, 0x06, 0x53, 0x8f, 0x7e, 0x6c, 0xcf, 0xe8,
	0xd2, 0xc6, 0xe5, 0x19, 0x5d, 0xf6, 0xe3, 0x24, 0x8d, 0x2e, 0xa0, 0xcc, 0x62, 0xcf, 0xd5, 0x3d,
	0x9a, 0xb2, 0xc7, 0xd7, 0x55, 0xe5, 0x67, 0x03, 0xd5, 0x65, 0xff, 0xfa, 0x05, 0x06, 0x16, 0x7b,
	0x6a, 0x8b, 0x0e, 0xa1, 0x28, 0x58, 0x6c, 0x6c, 0x15, 0xce, 0xcc, 0x66, 0x15, 0xef, 0xb0, 0xd8,
	0x1b, 0x8e, 0x85, 0x98, 0xcf, 0x78, 0x2a, 0xb6, 0xf3, 0x37, 0x62, 0x3e, 0xe3, 0x39, 0x31, 0xc1,
	0x62, 0x63, 0xab, 0x98, 0x88, 0xf9, 0x8c, 0x0f, 0xc7, 0xe8, 0x23, 0xa8, 0x89, 0x70, 0x6e, 0xa6,
	0xbb, 0x52, 0x6f, 0xd3, 0x4c, 0x2b, 0x3e, 0xe3, 0xe9, 0x4e, 0x30, 0xc5, 0xe9, 0x72, 0xcc, 0xbd,
	0xfb, 0x99, 0x2c, 0xf6, 0x32, 0xe6, 0x45, 0xc2, 0x0c, 0x08, 0x77, 0x89, 0xc7, 0xa7, 0x61, 0x60,
	0x95, 0xce, 0x8c, 0x66, 0xad, 0x5d, 0x6b, 0x09, 0xe3, 0x38, 0x84, 0x77, 0x64, 0x54, 0xb2, 0xd2,
	0x9d, 0x60, 0x89, 0x93, 0xe6, 0x58, 0xb0, 0x99, 0xe5, 0x33, 0x9e, 0xb1, 0x5a, 0x50, 0xd1, 0xb5,
	0xa2, 0x30, 0x9c, 0x5b, 0x65, 0x79, 0x89, 0x15, 0xcd, 0x11, 0xee, 0x93, 0x33, 0xd7, 0x4e, 0x6c,
	0x41, 0x45, 0x57, 0x91, 0xf8, 0xca, 0x26, 0x7c, 0x52, 0x41, 0xac, 0xed, 0x47, 0xb0, 0xaf, 0xcc,
	0x80, 0xe9, 0xd7, 0x0b, 0xca, 0x78, 0x8f, 0x8d, 0xd1, 0x39, 0xec, 0xc6, 0xc9, 0x4e, 0xd9, 0xb9,
	0xae, 0xf9, 0xda, 0x84, 0x58, 0x03, 0xec, 0x07, 0x50, 0xd5, 0x71, 0x4e, 0xf8, 0x82, 0xa1, 0x23,
	0x28, 0x2a, 0xc3, 0x09, 0x83, 0x16, 0xb1, 0xda, 0xd9, 0xdf, 0xc1, 0x6b, 0x69, 0x25, 0x16, 0x85,
	0x01, 0xa3, 0xe8, 0x11, 0x00, 0x89, 0xa6, 0x2e, 0x93, 0x44, 0x09, 0xaf, 0xb5, 0xeb, 0xfa, 0xe5,
	0x44, 0xd3, 0x44, 0xf0, 0xb2, 0xf6, 0xc7, 0xed, 0x69, 0x0e, 0x87, 0x4b, 0x44, 0xa7, 0xd0, 0x39,
	0x14, 0x15, 0x59, 0xbf, 0xa4, 0xfc, 0x39, 0x13, 0xb8, 0x42, 0xd8, 0x4f, 0x00, 0xad, 0xd4, 0x17,
	0xad, 0x7e, 0x00, 0x7b, 0xb1, 0xda, 0xaa, 0x5e, 0x0f, 0xf2, 0x1a, 0x1a, 0x8a, 0x53, 0x94, 0xfd,
	0xbd, 0x91, 0x8e, 0xec, 0x13, 0xca, 0xd5, 0xd4, 0xfe, 0x87, 0x47, 0x69, 0x3f, 0x85, 0x83, 0xb5,
	0x73, 0x24, 0x2d, 0xad, 0xdc, 0xde, 0x51, 0xbe, 0xa3, 0x0c, 0x9b, 0xdd, 0xe1, 0x4b, 0x03, 0x2a,
	0xb9, 0xa1, 0x31, 0xd4, 0x84, 0x7a, 0xb0, 0xb8, 0x71, 0xb9, 0x17, 0xb9, 0x8c, 0x32, 0x36, 0x0d,
	0x83, 0xe4, 0x7a, 0xaa, 0xb8, 0x16, 0x2c, 0x6e, 0x46, 0x5e, 0x34, 0x54, 0x51, 0x8d, 0x5c, 0xf8,
	0x39, 0xe4, 0x76, 0x8a, 0xfc, 0xc2, 0xcf, 0x90, 0xef, 0x03, 0x12, 0xc8, 0x90, 0x4f, 0x68, 0x9c,
	0x61, 0x4d, 0x89, 0x15, 0x1a, 0x7d, 0x91, 0xd0, 0x68, 0xfb, 0x17, 0x23, 0xbd, 0x2e, 0x79, 0x62,
	0xe5, 0x98, 0x27, 0xff, 0xca, 0x31, 0x87, 0xaf, 0x6e, 0x4f, 0xf7, 0xd5, 0xe0, 0x36, 0x1b, 0xe7,
	0x5d, 0x28, 0xb0, 0x88, 0x7a, 0x6a, 0xfc, 0xeb, 0xf6, 0x96, 0xd9, 0x9c, 0xbd, 0xcc, 0x7f, 0xb2,
	0x17, 0x7a, 0x00, 0x3b, 0x62, 0xc5, 0xac, 0x82, 0x72, 0xc0, 0x0a, 0x94, 0xe1, 0x24, 0x6f, 0xff,
	0x60, 0xc0, 0xe1, 0x7a, 0x67, 0xe2, 0xe2, 0xfe, 0xab, 0xe6, 0x1e, 0xe6, 0x3c, 0xbd, 0x2d, 0x1d,
	0x70, 0xbc, 0xe6, 0x80, 0x55, 0x5b, 0x9f, 0x7f, 0x0b, 0xa5, 0xec, 0xab, 0xb3, 0x0f, 0x55, 0xa7,
	0x33, 0x72, 0x47, 0xcf, 0x07, 0x5d, 0xd7, 0xe9, 0x3b, 0xdd, 0xfa, 0x16, 0x7a, 0x13, 0x8e, 0xd3,
	0xd0, 0x70, 0xd4, 0x19, 0x3d, 0x7b, 0xec, 0x76, 0xae, 0xae, 0x70, 0x77, 0x38, 0xac, 0x1b, 0xe8,
	0x2d, 0xb0, 0xd2, 0xe4, 0xd5, 0x73, 0xa7, 0xd3, 0xcb, 0x65, 0xb7, 0xd1, 0x3b, 0xf0, 0xf6, 0x7d,
	0x59, 0x77, 0xd0, 0xc7, 0xa3, 0xba, 0xd9, 0x7e, 0x69, 0x80, 0xe9, 0x10, 0x8e, 0x2e, 0xd3, 0xaf,
	0xc9, 0xe3, 0x98, 0x12, 0x4e, 0xd1, 0xd1, 0x5f, 0x5f, 0xa3, 0x36, 0x79, 0xe3, 0x78, 0xd3, 0x2b,
	0xed, 0xb1, 0xb1, 0xbd, 0x85, 0xba, 0x00, 0x59, 0xa7, 0xe8, 0x8d, 0xcd, 0xe6, 0x17, 0x1a, 0x8d,
	0x7b, 0xa6, 0x22, 0x65, 0x2e, 0x1b, 0x3f, 0xdd, 0x9d, 0x18, 0x3f, 0xdf, 0x9d, 0x18, 0xbf, 0xdd,
	0x9d, 0x18, 0x3f, 0xfe, 0x7e, 0xb2, 0xf5, 0xe5, 0xde, 0x84, 0xcc, 0xe5, 0x5f, 0xff, 0x75, 0x51,
	0xfe, 0x3c, 0xfc, 0x33, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x9e, 0xd4, 0x62, 0x2a, 0x08, 0x00, 0x00,
}
