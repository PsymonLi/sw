// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gft.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GftTableType int32

const (
	GftTableType_GFT_TABLE_TYPE_NONE                GftTableType = 0
	GftTableType_GFT_TABLE_TYPE_WILDCARD_INGRESS    GftTableType = 1
	GftTableType_GFT_TABLE_TYPE_WILDCARD_EGRESS     GftTableType = 2
	GftTableType_GFT_TABLE_TYPE_EXACT_MATCH_INGRESS GftTableType = 3
	GftTableType_GFT_TABLE_TYPE_EXACT_MATCH_EGRESS  GftTableType = 4
)

var GftTableType_name = map[int32]string{
	0: "GFT_TABLE_TYPE_NONE",
	1: "GFT_TABLE_TYPE_WILDCARD_INGRESS",
	2: "GFT_TABLE_TYPE_WILDCARD_EGRESS",
	3: "GFT_TABLE_TYPE_EXACT_MATCH_INGRESS",
	4: "GFT_TABLE_TYPE_EXACT_MATCH_EGRESS",
}
var GftTableType_value = map[string]int32{
	"GFT_TABLE_TYPE_NONE":                0,
	"GFT_TABLE_TYPE_WILDCARD_INGRESS":    1,
	"GFT_TABLE_TYPE_WILDCARD_EGRESS":     2,
	"GFT_TABLE_TYPE_EXACT_MATCH_INGRESS": 3,
	"GFT_TABLE_TYPE_EXACT_MATCH_EGRESS":  4,
}

func (x GftTableType) String() string {
	return proto.EnumName(GftTableType_name, int32(x))
}
func (GftTableType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGft, []int{0} }

type GftHeaderGroupTranspostionAction int32

const (
	GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_NONE   GftHeaderGroupTranspostionAction = 0
	GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_MODIFY GftHeaderGroupTranspostionAction = 1
	GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_IGNORE GftHeaderGroupTranspostionAction = 2
	GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_PUSH   GftHeaderGroupTranspostionAction = 3
	GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_POP    GftHeaderGroupTranspostionAction = 4
)

var GftHeaderGroupTranspostionAction_name = map[int32]string{
	0: "TRANSPOSITION_ACTION_NONE",
	1: "TRANSPOSITION_ACTION_MODIFY",
	2: "TRANSPOSITION_ACTION_IGNORE",
	3: "TRANSPOSITION_ACTION_PUSH",
	4: "TRANSPOSITION_ACTION_POP",
}
var GftHeaderGroupTranspostionAction_value = map[string]int32{
	"TRANSPOSITION_ACTION_NONE":   0,
	"TRANSPOSITION_ACTION_MODIFY": 1,
	"TRANSPOSITION_ACTION_IGNORE": 2,
	"TRANSPOSITION_ACTION_PUSH":   3,
	"TRANSPOSITION_ACTION_POP":    4,
}

func (x GftHeaderGroupTranspostionAction) String() string {
	return proto.EnumName(GftHeaderGroupTranspostionAction_name, int32(x))
}
func (GftHeaderGroupTranspostionAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{1}
}

type GftEthFields struct {
	DstMacAddr     uint64 `protobuf:"varint,1,opt,name=dst_mac_addr,json=dstMacAddr,proto3" json:"dst_mac_addr,omitempty"`
	SrcMacAddr     uint64 `protobuf:"varint,2,opt,name=src_mac_addr,json=srcMacAddr,proto3" json:"src_mac_addr,omitempty"`
	EthType        uint32 `protobuf:"varint,3,opt,name=eth_type,json=ethType,proto3" json:"eth_type,omitempty"`
	CustomerVlanId uint32 `protobuf:"varint,4,opt,name=customer_vlan_id,json=customerVlanId,proto3" json:"customer_vlan_id,omitempty"`
	ProviderVlanId uint32 `protobuf:"varint,5,opt,name=provider_vlan_id,json=providerVlanId,proto3" json:"provider_vlan_id,omitempty"`
	Priority       uint32 `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *GftEthFields) Reset()                    { *m = GftEthFields{} }
func (m *GftEthFields) String() string            { return proto.CompactTextString(m) }
func (*GftEthFields) ProtoMessage()               {}
func (*GftEthFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{0} }

func (m *GftEthFields) GetDstMacAddr() uint64 {
	if m != nil {
		return m.DstMacAddr
	}
	return 0
}

func (m *GftEthFields) GetSrcMacAddr() uint64 {
	if m != nil {
		return m.SrcMacAddr
	}
	return 0
}

func (m *GftEthFields) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *GftEthFields) GetCustomerVlanId() uint32 {
	if m != nil {
		return m.CustomerVlanId
	}
	return 0
}

func (m *GftEthFields) GetProviderVlanId() uint32 {
	if m != nil {
		return m.ProviderVlanId
	}
	return 0
}

func (m *GftEthFields) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

type GftHeaders struct {
	EthernetHeader bool `protobuf:"varint,1,opt,name=ethernet_header,json=ethernetHeader,proto3" json:"ethernet_header,omitempty"`
	Ipv4Header     bool `protobuf:"varint,2,opt,name=ipv4_header,json=ipv4Header,proto3" json:"ipv4_header,omitempty"`
	Ipv6Header     bool `protobuf:"varint,3,opt,name=ipv6_header,json=ipv6Header,proto3" json:"ipv6_header,omitempty"`
	TcpHeader      bool `protobuf:"varint,4,opt,name=tcp_header,json=tcpHeader,proto3" json:"tcp_header,omitempty"`
	UdpHeader      bool `protobuf:"varint,5,opt,name=udp_header,json=udpHeader,proto3" json:"udp_header,omitempty"`
	IcmpHeader     bool `protobuf:"varint,6,opt,name=icmp_header,json=icmpHeader,proto3" json:"icmp_header,omitempty"`
	NoEncap        bool `protobuf:"varint,7,opt,name=no_encap,json=noEncap,proto3" json:"no_encap,omitempty"`
	IpInIpEncap    bool `protobuf:"varint,8,opt,name=ip_in_ip_encap,json=ipInIpEncap,proto3" json:"ip_in_ip_encap,omitempty"`
	IpInGreEncap   bool `protobuf:"varint,9,opt,name=ip_in_gre_encap,json=ipInGreEncap,proto3" json:"ip_in_gre_encap,omitempty"`
	NvgreEncap     bool `protobuf:"varint,10,opt,name=nvgre_encap,json=nvgreEncap,proto3" json:"nvgre_encap,omitempty"`
	VxlanEncap     bool `protobuf:"varint,11,opt,name=vxlan_encap,json=vxlanEncap,proto3" json:"vxlan_encap,omitempty"`
}

func (m *GftHeaders) Reset()                    { *m = GftHeaders{} }
func (m *GftHeaders) String() string            { return proto.CompactTextString(m) }
func (*GftHeaders) ProtoMessage()               {}
func (*GftHeaders) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{1} }

func (m *GftHeaders) GetEthernetHeader() bool {
	if m != nil {
		return m.EthernetHeader
	}
	return false
}

func (m *GftHeaders) GetIpv4Header() bool {
	if m != nil {
		return m.Ipv4Header
	}
	return false
}

func (m *GftHeaders) GetIpv6Header() bool {
	if m != nil {
		return m.Ipv6Header
	}
	return false
}

func (m *GftHeaders) GetTcpHeader() bool {
	if m != nil {
		return m.TcpHeader
	}
	return false
}

func (m *GftHeaders) GetUdpHeader() bool {
	if m != nil {
		return m.UdpHeader
	}
	return false
}

func (m *GftHeaders) GetIcmpHeader() bool {
	if m != nil {
		return m.IcmpHeader
	}
	return false
}

func (m *GftHeaders) GetNoEncap() bool {
	if m != nil {
		return m.NoEncap
	}
	return false
}

func (m *GftHeaders) GetIpInIpEncap() bool {
	if m != nil {
		return m.IpInIpEncap
	}
	return false
}

func (m *GftHeaders) GetIpInGreEncap() bool {
	if m != nil {
		return m.IpInGreEncap
	}
	return false
}

func (m *GftHeaders) GetNvgreEncap() bool {
	if m != nil {
		return m.NvgreEncap
	}
	return false
}

func (m *GftHeaders) GetVxlanEncap() bool {
	if m != nil {
		return m.VxlanEncap
	}
	return false
}

type GftHeaderFields struct {
	DstMacAddr     bool `protobuf:"varint,1,opt,name=dst_mac_addr,json=dstMacAddr,proto3" json:"dst_mac_addr,omitempty"`
	SrcMacAddr     bool `protobuf:"varint,2,opt,name=src_mac_addr,json=srcMacAddr,proto3" json:"src_mac_addr,omitempty"`
	EthType        bool `protobuf:"varint,3,opt,name=eth_type,json=ethType,proto3" json:"eth_type,omitempty"`
	CustomerVlanId bool `protobuf:"varint,4,opt,name=customer_vlan_id,json=customerVlanId,proto3" json:"customer_vlan_id,omitempty"`
	ProviderVlanId bool `protobuf:"varint,5,opt,name=provider_vlan_id,json=providerVlanId,proto3" json:"provider_vlan_id,omitempty"`
	Dot1PPriority  bool `protobuf:"varint,6,opt,name=dot1p_priority,json=dot1pPriority,proto3" json:"dot1p_priority,omitempty"`
	SrcIpAddr      bool `protobuf:"varint,7,opt,name=src_ip_addr,json=srcIpAddr,proto3" json:"src_ip_addr,omitempty"`
	DstIpAddr      bool `protobuf:"varint,8,opt,name=dst_ip_addr,json=dstIpAddr,proto3" json:"dst_ip_addr,omitempty"`
	IpTtl          bool `protobuf:"varint,9,opt,name=ip_ttl,json=ipTtl,proto3" json:"ip_ttl,omitempty"`
	IpProtocol     bool `protobuf:"varint,10,opt,name=ip_protocol,json=ipProtocol,proto3" json:"ip_protocol,omitempty"`
	IpDscp         bool `protobuf:"varint,11,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty"`
	SrcPort        bool `protobuf:"varint,12,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort        bool `protobuf:"varint,13,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	TcpFlags       bool `protobuf:"varint,14,opt,name=tcp_flags,json=tcpFlags,proto3" json:"tcp_flags,omitempty"`
	TenantId       bool `protobuf:"varint,15,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	IcmpType       bool `protobuf:"varint,16,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	IcmpCode       bool `protobuf:"varint,17,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
	OobVlan        bool `protobuf:"varint,18,opt,name=oob_vlan,json=oobVlan,proto3" json:"oob_vlan,omitempty"`
	OobTenantId    bool `protobuf:"varint,19,opt,name=oob_tenant_id,json=oobTenantId,proto3" json:"oob_tenant_id,omitempty"`
	GreProtocol    bool `protobuf:"varint,20,opt,name=gre_protocol,json=greProtocol,proto3" json:"gre_protocol,omitempty"`
}

func (m *GftHeaderFields) Reset()                    { *m = GftHeaderFields{} }
func (m *GftHeaderFields) String() string            { return proto.CompactTextString(m) }
func (*GftHeaderFields) ProtoMessage()               {}
func (*GftHeaderFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{2} }

func (m *GftHeaderFields) GetDstMacAddr() bool {
	if m != nil {
		return m.DstMacAddr
	}
	return false
}

func (m *GftHeaderFields) GetSrcMacAddr() bool {
	if m != nil {
		return m.SrcMacAddr
	}
	return false
}

func (m *GftHeaderFields) GetEthType() bool {
	if m != nil {
		return m.EthType
	}
	return false
}

func (m *GftHeaderFields) GetCustomerVlanId() bool {
	if m != nil {
		return m.CustomerVlanId
	}
	return false
}

func (m *GftHeaderFields) GetProviderVlanId() bool {
	if m != nil {
		return m.ProviderVlanId
	}
	return false
}

func (m *GftHeaderFields) GetDot1PPriority() bool {
	if m != nil {
		return m.Dot1PPriority
	}
	return false
}

func (m *GftHeaderFields) GetSrcIpAddr() bool {
	if m != nil {
		return m.SrcIpAddr
	}
	return false
}

func (m *GftHeaderFields) GetDstIpAddr() bool {
	if m != nil {
		return m.DstIpAddr
	}
	return false
}

func (m *GftHeaderFields) GetIpTtl() bool {
	if m != nil {
		return m.IpTtl
	}
	return false
}

func (m *GftHeaderFields) GetIpProtocol() bool {
	if m != nil {
		return m.IpProtocol
	}
	return false
}

func (m *GftHeaderFields) GetIpDscp() bool {
	if m != nil {
		return m.IpDscp
	}
	return false
}

func (m *GftHeaderFields) GetSrcPort() bool {
	if m != nil {
		return m.SrcPort
	}
	return false
}

func (m *GftHeaderFields) GetDstPort() bool {
	if m != nil {
		return m.DstPort
	}
	return false
}

func (m *GftHeaderFields) GetTcpFlags() bool {
	if m != nil {
		return m.TcpFlags
	}
	return false
}

func (m *GftHeaderFields) GetTenantId() bool {
	if m != nil {
		return m.TenantId
	}
	return false
}

func (m *GftHeaderFields) GetIcmpType() bool {
	if m != nil {
		return m.IcmpType
	}
	return false
}

func (m *GftHeaderFields) GetIcmpCode() bool {
	if m != nil {
		return m.IcmpCode
	}
	return false
}

func (m *GftHeaderFields) GetOobVlan() bool {
	if m != nil {
		return m.OobVlan
	}
	return false
}

func (m *GftHeaderFields) GetOobTenantId() bool {
	if m != nil {
		return m.OobTenantId
	}
	return false
}

func (m *GftHeaderFields) GetGreProtocol() bool {
	if m != nil {
		return m.GreProtocol
	}
	return false
}

type GftHeaderGroupExactMatchProfile struct {
	Headers     *GftHeaders      `protobuf:"bytes,1,opt,name=headers" json:"headers,omitempty"`
	MatchFields *GftHeaderFields `protobuf:"bytes,2,opt,name=match_fields,json=matchFields" json:"match_fields,omitempty"`
}

func (m *GftHeaderGroupExactMatchProfile) Reset()         { *m = GftHeaderGroupExactMatchProfile{} }
func (m *GftHeaderGroupExactMatchProfile) String() string { return proto.CompactTextString(m) }
func (*GftHeaderGroupExactMatchProfile) ProtoMessage()    {}
func (*GftHeaderGroupExactMatchProfile) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{3}
}

func (m *GftHeaderGroupExactMatchProfile) GetHeaders() *GftHeaders {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GftHeaderGroupExactMatchProfile) GetMatchFields() *GftHeaderFields {
	if m != nil {
		return m.MatchFields
	}
	return nil
}

type GftExactMatchProfileSpec struct {
	Meta               *ObjectMeta                        `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle        *GftExactMatchProfileKeyHandle     `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	RdmaFlow           bool                               `protobuf:"varint,3,opt,name=rdma_flow,json=rdmaFlow,proto3" json:"rdma_flow,omitempty"`
	TableType          GftTableType                       `protobuf:"varint,4,opt,name=table_type,json=tableType,proto3,enum=gft.GftTableType" json:"table_type,omitempty"`
	ExactMatchProfiles []*GftHeaderGroupExactMatchProfile `protobuf:"bytes,5,rep,name=exact_match_profiles,json=exactMatchProfiles" json:"exact_match_profiles,omitempty"`
}

func (m *GftExactMatchProfileSpec) Reset()                    { *m = GftExactMatchProfileSpec{} }
func (m *GftExactMatchProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchProfileSpec) ProtoMessage()               {}
func (*GftExactMatchProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{4} }

func (m *GftExactMatchProfileSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *GftExactMatchProfileSpec) GetKeyOrHandle() *GftExactMatchProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftExactMatchProfileSpec) GetRdmaFlow() bool {
	if m != nil {
		return m.RdmaFlow
	}
	return false
}

func (m *GftExactMatchProfileSpec) GetTableType() GftTableType {
	if m != nil {
		return m.TableType
	}
	return GftTableType_GFT_TABLE_TYPE_NONE
}

func (m *GftExactMatchProfileSpec) GetExactMatchProfiles() []*GftHeaderGroupExactMatchProfile {
	if m != nil {
		return m.ExactMatchProfiles
	}
	return nil
}

// GftExactMatchProfileRequestMsg is used to do batched add or modify of GFT
// exact match profile
type GftExactMatchProfileRequestMsg struct {
	Request []*GftExactMatchProfileSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *GftExactMatchProfileRequestMsg) Reset()         { *m = GftExactMatchProfileRequestMsg{} }
func (m *GftExactMatchProfileRequestMsg) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchProfileRequestMsg) ProtoMessage()    {}
func (*GftExactMatchProfileRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{5}
}

func (m *GftExactMatchProfileRequestMsg) GetRequest() []*GftExactMatchProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// GftExactMatchProfileStatus represents the current status of GFT exact match profile
type GftExactMatchProfileStatus struct {
	ProfileHandle uint64 `protobuf:"fixed64,1,opt,name=profile_handle,json=profileHandle,proto3" json:"profile_handle,omitempty"`
}

func (m *GftExactMatchProfileStatus) Reset()                    { *m = GftExactMatchProfileStatus{} }
func (m *GftExactMatchProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchProfileStatus) ProtoMessage()               {}
func (*GftExactMatchProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{6} }

func (m *GftExactMatchProfileStatus) GetProfileHandle() uint64 {
	if m != nil {
		return m.ProfileHandle
	}
	return 0
}

// GftExactMatchProfileResponse is response to GftExactMatchProfileSpec
type GftExactMatchProfileResponse struct {
	ApiStatus ApiStatus                   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *GftExactMatchProfileStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GftExactMatchProfileResponse) Reset()                    { *m = GftExactMatchProfileResponse{} }
func (m *GftExactMatchProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchProfileResponse) ProtoMessage()               {}
func (*GftExactMatchProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{7} }

func (m *GftExactMatchProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *GftExactMatchProfileResponse) GetStatus() *GftExactMatchProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// GftExactMatchProfileResponseMsg is batched response to GftExactMatchProfileRequestMsg
type GftExactMatchProfileResponseMsg struct {
	Response []*GftExactMatchProfileResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *GftExactMatchProfileResponseMsg) Reset()         { *m = GftExactMatchProfileResponseMsg{} }
func (m *GftExactMatchProfileResponseMsg) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchProfileResponseMsg) ProtoMessage()    {}
func (*GftExactMatchProfileResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{8}
}

func (m *GftExactMatchProfileResponseMsg) GetResponse() []*GftExactMatchProfileResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type UdpMatchFields struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport,proto3" json:"dport,omitempty"`
}

func (m *UdpMatchFields) Reset()                    { *m = UdpMatchFields{} }
func (m *UdpMatchFields) String() string            { return proto.CompactTextString(m) }
func (*UdpMatchFields) ProtoMessage()               {}
func (*UdpMatchFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{9} }

func (m *UdpMatchFields) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *UdpMatchFields) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type TcpMatchFields struct {
	Sport    uint32 `protobuf:"varint,1,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport    uint32 `protobuf:"varint,2,opt,name=dport,proto3" json:"dport,omitempty"`
	TcpFlags uint32 `protobuf:"varint,3,opt,name=tcp_flags,json=tcpFlags,proto3" json:"tcp_flags,omitempty"`
}

func (m *TcpMatchFields) Reset()                    { *m = TcpMatchFields{} }
func (m *TcpMatchFields) String() string            { return proto.CompactTextString(m) }
func (*TcpMatchFields) ProtoMessage()               {}
func (*TcpMatchFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{10} }

func (m *TcpMatchFields) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *TcpMatchFields) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

func (m *TcpMatchFields) GetTcpFlags() uint32 {
	if m != nil {
		return m.TcpFlags
	}
	return 0
}

type IcmpMatchFields struct {
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *IcmpMatchFields) Reset()                    { *m = IcmpMatchFields{} }
func (m *IcmpMatchFields) String() string            { return proto.CompactTextString(m) }
func (*IcmpMatchFields) ProtoMessage()               {}
func (*IcmpMatchFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{11} }

func (m *IcmpMatchFields) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IcmpMatchFields) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type EncapMatchFields struct {
	TenantId    uint32 `protobuf:"varint,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	GreProtocol uint32 `protobuf:"varint,2,opt,name=gre_protocol,json=greProtocol,proto3" json:"gre_protocol,omitempty"`
}

func (m *EncapMatchFields) Reset()                    { *m = EncapMatchFields{} }
func (m *EncapMatchFields) String() string            { return proto.CompactTextString(m) }
func (*EncapMatchFields) ProtoMessage()               {}
func (*EncapMatchFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{12} }

func (m *EncapMatchFields) GetTenantId() uint32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

func (m *EncapMatchFields) GetGreProtocol() uint32 {
	if m != nil {
		return m.GreProtocol
	}
	return 0
}

type GftHeaderGroupTranspositionProfile struct {
	Action      GftHeaderGroupTranspostionAction `protobuf:"varint,1,opt,name=action,proto3,enum=gft.GftHeaderGroupTranspostionAction" json:"action,omitempty"`
	Headers     *GftHeaders                      `protobuf:"bytes,2,opt,name=headers" json:"headers,omitempty"`
	MatchFields *GftHeaderFields                 `protobuf:"bytes,3,opt,name=match_fields,json=matchFields" json:"match_fields,omitempty"`
}

func (m *GftHeaderGroupTranspositionProfile) Reset()         { *m = GftHeaderGroupTranspositionProfile{} }
func (m *GftHeaderGroupTranspositionProfile) String() string { return proto.CompactTextString(m) }
func (*GftHeaderGroupTranspositionProfile) ProtoMessage()    {}
func (*GftHeaderGroupTranspositionProfile) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{13}
}

func (m *GftHeaderGroupTranspositionProfile) GetAction() GftHeaderGroupTranspostionAction {
	if m != nil {
		return m.Action
	}
	return GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_NONE
}

func (m *GftHeaderGroupTranspositionProfile) GetHeaders() *GftHeaders {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GftHeaderGroupTranspositionProfile) GetMatchFields() *GftHeaderFields {
	if m != nil {
		return m.MatchFields
	}
	return nil
}

type GftHeaderTranspositionProfileSpec struct {
	Meta                                  *ObjectMeta                             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle                           *GftHeaderTranspositionProfileKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	RedirectToVportIngressQueue           bool                                    `protobuf:"varint,3,opt,name=redirect_to_vport_ingress_queue,json=redirectToVportIngressQueue,proto3" json:"redirect_to_vport_ingress_queue,omitempty"`
	RedirectToVportEgressQueue            bool                                    `protobuf:"varint,4,opt,name=redirect_to_vport_egress_queue,json=redirectToVportEgressQueue,proto3" json:"redirect_to_vport_egress_queue,omitempty"`
	RedirectToVportIngressQueueIfTtlIsOne bool                                    `protobuf:"varint,5,opt,name=redirect_to_vport_ingress_queue_if_ttl_is_one,json=redirectToVportIngressQueueIfTtlIsOne,proto3" json:"redirect_to_vport_ingress_queue_if_ttl_is_one,omitempty"`
	RedirectToVportEgressQueueIfTtlIsOne  bool                                    `protobuf:"varint,6,opt,name=redirect_to_vport_egress_queue_if_ttl_is_one,json=redirectToVportEgressQueueIfTtlIsOne,proto3" json:"redirect_to_vport_egress_queue_if_ttl_is_one,omitempty"`
	CopyAllPackets                        bool                                    `protobuf:"varint,7,opt,name=copy_all_packets,json=copyAllPackets,proto3" json:"copy_all_packets,omitempty"`
	CopyFirstPacket                       bool                                    `protobuf:"varint,8,opt,name=copy_first_packet,json=copyFirstPacket,proto3" json:"copy_first_packet,omitempty"`
	CopyWhenTcpFlagSet                    bool                                    `protobuf:"varint,9,opt,name=copy_when_tcp_flag_set,json=copyWhenTcpFlagSet,proto3" json:"copy_when_tcp_flag_set,omitempty"`
	CustomActionPresent                   bool                                    `protobuf:"varint,10,opt,name=custom_action_present,json=customActionPresent,proto3" json:"custom_action_present,omitempty"`
	MetaActionBeforeTransposition         bool                                    `protobuf:"varint,11,opt,name=meta_action_before_transposition,json=metaActionBeforeTransposition,proto3" json:"meta_action_before_transposition,omitempty"`
	TableType                             GftTableType                            `protobuf:"varint,12,opt,name=table_type,json=tableType,proto3,enum=gft.GftTableType" json:"table_type,omitempty"`
	TranspositionProfiles                 []*GftHeaderGroupTranspositionProfile   `protobuf:"bytes,13,rep,name=transposition_profiles,json=transpositionProfiles" json:"transposition_profiles,omitempty"`
}

func (m *GftHeaderTranspositionProfileSpec) Reset()         { *m = GftHeaderTranspositionProfileSpec{} }
func (m *GftHeaderTranspositionProfileSpec) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileSpec) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{14}
}

func (m *GftHeaderTranspositionProfileSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *GftHeaderTranspositionProfileSpec) GetKeyOrHandle() *GftHeaderTranspositionProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftHeaderTranspositionProfileSpec) GetRedirectToVportIngressQueue() bool {
	if m != nil {
		return m.RedirectToVportIngressQueue
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetRedirectToVportEgressQueue() bool {
	if m != nil {
		return m.RedirectToVportEgressQueue
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetRedirectToVportIngressQueueIfTtlIsOne() bool {
	if m != nil {
		return m.RedirectToVportIngressQueueIfTtlIsOne
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetRedirectToVportEgressQueueIfTtlIsOne() bool {
	if m != nil {
		return m.RedirectToVportEgressQueueIfTtlIsOne
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetCopyAllPackets() bool {
	if m != nil {
		return m.CopyAllPackets
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetCopyFirstPacket() bool {
	if m != nil {
		return m.CopyFirstPacket
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetCopyWhenTcpFlagSet() bool {
	if m != nil {
		return m.CopyWhenTcpFlagSet
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetCustomActionPresent() bool {
	if m != nil {
		return m.CustomActionPresent
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetMetaActionBeforeTransposition() bool {
	if m != nil {
		return m.MetaActionBeforeTransposition
	}
	return false
}

func (m *GftHeaderTranspositionProfileSpec) GetTableType() GftTableType {
	if m != nil {
		return m.TableType
	}
	return GftTableType_GFT_TABLE_TYPE_NONE
}

func (m *GftHeaderTranspositionProfileSpec) GetTranspositionProfiles() []*GftHeaderGroupTranspositionProfile {
	if m != nil {
		return m.TranspositionProfiles
	}
	return nil
}

// GftHeaderTranspositionProfileRequestMsg is used to do batched add or modify of GFT
// header transposition profile
type GftHeaderTranspositionProfileRequestMsg struct {
	Request []*GftHeaderTranspositionProfileSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *GftHeaderTranspositionProfileRequestMsg) Reset() {
	*m = GftHeaderTranspositionProfileRequestMsg{}
}
func (m *GftHeaderTranspositionProfileRequestMsg) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileRequestMsg) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{15}
}

func (m *GftHeaderTranspositionProfileRequestMsg) GetRequest() []*GftHeaderTranspositionProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// GftHeaderTranspositionProfileStatus represents the current status of GFT header transposition profile
type GftHeaderTranspositionProfileStatus struct {
	ProfileHandle uint64 `protobuf:"fixed64,1,opt,name=profile_handle,json=profileHandle,proto3" json:"profile_handle,omitempty"`
}

func (m *GftHeaderTranspositionProfileStatus) Reset()         { *m = GftHeaderTranspositionProfileStatus{} }
func (m *GftHeaderTranspositionProfileStatus) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileStatus) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{16}
}

func (m *GftHeaderTranspositionProfileStatus) GetProfileHandle() uint64 {
	if m != nil {
		return m.ProfileHandle
	}
	return 0
}

// GftHeaderTranspositionProfileResponse is response to GftHeaderTranspositionProfileSpec
type GftHeaderTranspositionProfileResponse struct {
	ApiStatus ApiStatus                            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *GftHeaderTranspositionProfileStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GftHeaderTranspositionProfileResponse) Reset()         { *m = GftHeaderTranspositionProfileResponse{} }
func (m *GftHeaderTranspositionProfileResponse) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileResponse) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{17}
}

func (m *GftHeaderTranspositionProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *GftHeaderTranspositionProfileResponse) GetStatus() *GftHeaderTranspositionProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// GftHeaderTranspositionProfileResponseMsg is batched response to GftHeaderTranspositionProfileRequestMsg
type GftHeaderTranspositionProfileResponseMsg struct {
	Response []*GftHeaderTranspositionProfileResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *GftHeaderTranspositionProfileResponseMsg) Reset() {
	*m = GftHeaderTranspositionProfileResponseMsg{}
}
func (m *GftHeaderTranspositionProfileResponseMsg) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileResponseMsg) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{18}
}

func (m *GftHeaderTranspositionProfileResponseMsg) GetResponse() []*GftHeaderTranspositionProfileResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type EncapOrTransportMatch struct {
	// Types that are valid to be assigned to EncapOrTransport:
	//	*EncapOrTransportMatch_UdpFields
	//	*EncapOrTransportMatch_TcpFields
	//	*EncapOrTransportMatch_IcmpFields
	//	*EncapOrTransportMatch_EncapFields
	EncapOrTransport isEncapOrTransportMatch_EncapOrTransport `protobuf_oneof:"encap_or_transport"`
}

func (m *EncapOrTransportMatch) Reset()                    { *m = EncapOrTransportMatch{} }
func (m *EncapOrTransportMatch) String() string            { return proto.CompactTextString(m) }
func (*EncapOrTransportMatch) ProtoMessage()               {}
func (*EncapOrTransportMatch) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{19} }

type isEncapOrTransportMatch_EncapOrTransport interface {
	isEncapOrTransportMatch_EncapOrTransport()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EncapOrTransportMatch_UdpFields struct {
	UdpFields *UdpMatchFields `protobuf:"bytes,1,opt,name=udp_fields,json=udpFields,oneof"`
}
type EncapOrTransportMatch_TcpFields struct {
	TcpFields *TcpMatchFields `protobuf:"bytes,2,opt,name=tcp_fields,json=tcpFields,oneof"`
}
type EncapOrTransportMatch_IcmpFields struct {
	IcmpFields *IcmpMatchFields `protobuf:"bytes,3,opt,name=icmp_fields,json=icmpFields,oneof"`
}
type EncapOrTransportMatch_EncapFields struct {
	EncapFields *EncapMatchFields `protobuf:"bytes,4,opt,name=encap_fields,json=encapFields,oneof"`
}

func (*EncapOrTransportMatch_UdpFields) isEncapOrTransportMatch_EncapOrTransport()   {}
func (*EncapOrTransportMatch_TcpFields) isEncapOrTransportMatch_EncapOrTransport()   {}
func (*EncapOrTransportMatch_IcmpFields) isEncapOrTransportMatch_EncapOrTransport()  {}
func (*EncapOrTransportMatch_EncapFields) isEncapOrTransportMatch_EncapOrTransport() {}

func (m *EncapOrTransportMatch) GetEncapOrTransport() isEncapOrTransportMatch_EncapOrTransport {
	if m != nil {
		return m.EncapOrTransport
	}
	return nil
}

func (m *EncapOrTransportMatch) GetUdpFields() *UdpMatchFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportMatch_UdpFields); ok {
		return x.UdpFields
	}
	return nil
}

func (m *EncapOrTransportMatch) GetTcpFields() *TcpMatchFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportMatch_TcpFields); ok {
		return x.TcpFields
	}
	return nil
}

func (m *EncapOrTransportMatch) GetIcmpFields() *IcmpMatchFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportMatch_IcmpFields); ok {
		return x.IcmpFields
	}
	return nil
}

func (m *EncapOrTransportMatch) GetEncapFields() *EncapMatchFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportMatch_EncapFields); ok {
		return x.EncapFields
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EncapOrTransportMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EncapOrTransportMatch_OneofMarshaler, _EncapOrTransportMatch_OneofUnmarshaler, _EncapOrTransportMatch_OneofSizer, []interface{}{
		(*EncapOrTransportMatch_UdpFields)(nil),
		(*EncapOrTransportMatch_TcpFields)(nil),
		(*EncapOrTransportMatch_IcmpFields)(nil),
		(*EncapOrTransportMatch_EncapFields)(nil),
	}
}

func _EncapOrTransportMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EncapOrTransportMatch)
	// encap_or_transport
	switch x := m.EncapOrTransport.(type) {
	case *EncapOrTransportMatch_UdpFields:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpFields); err != nil {
			return err
		}
	case *EncapOrTransportMatch_TcpFields:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpFields); err != nil {
			return err
		}
	case *EncapOrTransportMatch_IcmpFields:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpFields); err != nil {
			return err
		}
	case *EncapOrTransportMatch_EncapFields:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncapFields); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EncapOrTransportMatch.EncapOrTransport has unexpected type %T", x)
	}
	return nil
}

func _EncapOrTransportMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EncapOrTransportMatch)
	switch tag {
	case 1: // encap_or_transport.udp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UdpMatchFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportMatch_UdpFields{msg}
		return true, err
	case 2: // encap_or_transport.tcp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpMatchFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportMatch_TcpFields{msg}
		return true, err
	case 3: // encap_or_transport.icmp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IcmpMatchFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportMatch_IcmpFields{msg}
		return true, err
	case 4: // encap_or_transport.encap_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncapMatchFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportMatch_EncapFields{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EncapOrTransportMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EncapOrTransportMatch)
	// encap_or_transport
	switch x := m.EncapOrTransport.(type) {
	case *EncapOrTransportMatch_UdpFields:
		s := proto.Size(x.UdpFields)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportMatch_TcpFields:
		s := proto.Size(x.TcpFields)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportMatch_IcmpFields:
		s := proto.Size(x.IcmpFields)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportMatch_EncapFields:
		s := proto.Size(x.EncapFields)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GftHeaderGroupExactMatch struct {
	Headers          *GftHeaders            `protobuf:"bytes,1,opt,name=headers" json:"headers,omitempty"`
	MatchFields      *GftHeaderFields       `protobuf:"bytes,2,opt,name=match_fields,json=matchFields" json:"match_fields,omitempty"`
	EthFields        *GftEthFields          `protobuf:"bytes,3,opt,name=eth_fields,json=ethFields" json:"eth_fields,omitempty"`
	SrcIpAddr        *IPAddress             `protobuf:"bytes,4,opt,name=src_ip_addr,json=srcIpAddr" json:"src_ip_addr,omitempty"`
	DstIpAddr        *IPAddress             `protobuf:"bytes,5,opt,name=dst_ip_addr,json=dstIpAddr" json:"dst_ip_addr,omitempty"`
	IpTtl            uint32                 `protobuf:"varint,6,opt,name=ip_ttl,json=ipTtl,proto3" json:"ip_ttl,omitempty"`
	IpDscp           uint32                 `protobuf:"varint,7,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty"`
	IpProtocol       uint32                 `protobuf:"varint,8,opt,name=ip_protocol,json=ipProtocol,proto3" json:"ip_protocol,omitempty"`
	EncapOrTransport *EncapOrTransportMatch `protobuf:"bytes,9,opt,name=encap_or_transport,json=encapOrTransport" json:"encap_or_transport,omitempty"`
}

func (m *GftHeaderGroupExactMatch) Reset()                    { *m = GftHeaderGroupExactMatch{} }
func (m *GftHeaderGroupExactMatch) String() string            { return proto.CompactTextString(m) }
func (*GftHeaderGroupExactMatch) ProtoMessage()               {}
func (*GftHeaderGroupExactMatch) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{20} }

func (m *GftHeaderGroupExactMatch) GetHeaders() *GftHeaders {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GftHeaderGroupExactMatch) GetMatchFields() *GftHeaderFields {
	if m != nil {
		return m.MatchFields
	}
	return nil
}

func (m *GftHeaderGroupExactMatch) GetEthFields() *GftEthFields {
	if m != nil {
		return m.EthFields
	}
	return nil
}

func (m *GftHeaderGroupExactMatch) GetSrcIpAddr() *IPAddress {
	if m != nil {
		return m.SrcIpAddr
	}
	return nil
}

func (m *GftHeaderGroupExactMatch) GetDstIpAddr() *IPAddress {
	if m != nil {
		return m.DstIpAddr
	}
	return nil
}

func (m *GftHeaderGroupExactMatch) GetIpTtl() uint32 {
	if m != nil {
		return m.IpTtl
	}
	return 0
}

func (m *GftHeaderGroupExactMatch) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

func (m *GftHeaderGroupExactMatch) GetIpProtocol() uint32 {
	if m != nil {
		return m.IpProtocol
	}
	return 0
}

func (m *GftHeaderGroupExactMatch) GetEncapOrTransport() *EncapOrTransportMatch {
	if m != nil {
		return m.EncapOrTransport
	}
	return nil
}

type UdpTranspositionFields struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport,proto3" json:"dport,omitempty"`
}

func (m *UdpTranspositionFields) Reset()                    { *m = UdpTranspositionFields{} }
func (m *UdpTranspositionFields) String() string            { return proto.CompactTextString(m) }
func (*UdpTranspositionFields) ProtoMessage()               {}
func (*UdpTranspositionFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{21} }

func (m *UdpTranspositionFields) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *UdpTranspositionFields) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type TcpTranspositionFields struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport,proto3" json:"dport,omitempty"`
}

func (m *TcpTranspositionFields) Reset()                    { *m = TcpTranspositionFields{} }
func (m *TcpTranspositionFields) String() string            { return proto.CompactTextString(m) }
func (*TcpTranspositionFields) ProtoMessage()               {}
func (*TcpTranspositionFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{22} }

func (m *TcpTranspositionFields) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *TcpTranspositionFields) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type IcmpTranspositionFields struct {
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *IcmpTranspositionFields) Reset()                    { *m = IcmpTranspositionFields{} }
func (m *IcmpTranspositionFields) String() string            { return proto.CompactTextString(m) }
func (*IcmpTranspositionFields) ProtoMessage()               {}
func (*IcmpTranspositionFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{23} }

func (m *IcmpTranspositionFields) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IcmpTranspositionFields) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type EncapTranspositionFields struct {
	TenantId    uint32 `protobuf:"varint,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	GreProtocol uint32 `protobuf:"varint,2,opt,name=gre_protocol,json=greProtocol,proto3" json:"gre_protocol,omitempty"`
}

func (m *EncapTranspositionFields) Reset()                    { *m = EncapTranspositionFields{} }
func (m *EncapTranspositionFields) String() string            { return proto.CompactTextString(m) }
func (*EncapTranspositionFields) ProtoMessage()               {}
func (*EncapTranspositionFields) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{24} }

func (m *EncapTranspositionFields) GetTenantId() uint32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

func (m *EncapTranspositionFields) GetGreProtocol() uint32 {
	if m != nil {
		return m.GreProtocol
	}
	return 0
}

type EncapOrTransportTransposition struct {
	// Types that are valid to be assigned to EncapOrTransport:
	//	*EncapOrTransportTransposition_UdpFields
	//	*EncapOrTransportTransposition_TcpFields
	//	*EncapOrTransportTransposition_IcmpFields
	//	*EncapOrTransportTransposition_EncapFields
	EncapOrTransport isEncapOrTransportTransposition_EncapOrTransport `protobuf_oneof:"encap_or_transport"`
}

func (m *EncapOrTransportTransposition) Reset()         { *m = EncapOrTransportTransposition{} }
func (m *EncapOrTransportTransposition) String() string { return proto.CompactTextString(m) }
func (*EncapOrTransportTransposition) ProtoMessage()    {}
func (*EncapOrTransportTransposition) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{25}
}

type isEncapOrTransportTransposition_EncapOrTransport interface {
	isEncapOrTransportTransposition_EncapOrTransport()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EncapOrTransportTransposition_UdpFields struct {
	UdpFields *UdpTranspositionFields `protobuf:"bytes,1,opt,name=udp_fields,json=udpFields,oneof"`
}
type EncapOrTransportTransposition_TcpFields struct {
	TcpFields *TcpTranspositionFields `protobuf:"bytes,2,opt,name=tcp_fields,json=tcpFields,oneof"`
}
type EncapOrTransportTransposition_IcmpFields struct {
	IcmpFields *IcmpTranspositionFields `protobuf:"bytes,3,opt,name=icmp_fields,json=icmpFields,oneof"`
}
type EncapOrTransportTransposition_EncapFields struct {
	EncapFields *EncapTranspositionFields `protobuf:"bytes,4,opt,name=encap_fields,json=encapFields,oneof"`
}

func (*EncapOrTransportTransposition_UdpFields) isEncapOrTransportTransposition_EncapOrTransport()   {}
func (*EncapOrTransportTransposition_TcpFields) isEncapOrTransportTransposition_EncapOrTransport()   {}
func (*EncapOrTransportTransposition_IcmpFields) isEncapOrTransportTransposition_EncapOrTransport()  {}
func (*EncapOrTransportTransposition_EncapFields) isEncapOrTransportTransposition_EncapOrTransport() {}

func (m *EncapOrTransportTransposition) GetEncapOrTransport() isEncapOrTransportTransposition_EncapOrTransport {
	if m != nil {
		return m.EncapOrTransport
	}
	return nil
}

func (m *EncapOrTransportTransposition) GetUdpFields() *UdpTranspositionFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportTransposition_UdpFields); ok {
		return x.UdpFields
	}
	return nil
}

func (m *EncapOrTransportTransposition) GetTcpFields() *TcpTranspositionFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportTransposition_TcpFields); ok {
		return x.TcpFields
	}
	return nil
}

func (m *EncapOrTransportTransposition) GetIcmpFields() *IcmpTranspositionFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportTransposition_IcmpFields); ok {
		return x.IcmpFields
	}
	return nil
}

func (m *EncapOrTransportTransposition) GetEncapFields() *EncapTranspositionFields {
	if x, ok := m.GetEncapOrTransport().(*EncapOrTransportTransposition_EncapFields); ok {
		return x.EncapFields
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EncapOrTransportTransposition) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EncapOrTransportTransposition_OneofMarshaler, _EncapOrTransportTransposition_OneofUnmarshaler, _EncapOrTransportTransposition_OneofSizer, []interface{}{
		(*EncapOrTransportTransposition_UdpFields)(nil),
		(*EncapOrTransportTransposition_TcpFields)(nil),
		(*EncapOrTransportTransposition_IcmpFields)(nil),
		(*EncapOrTransportTransposition_EncapFields)(nil),
	}
}

func _EncapOrTransportTransposition_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EncapOrTransportTransposition)
	// encap_or_transport
	switch x := m.EncapOrTransport.(type) {
	case *EncapOrTransportTransposition_UdpFields:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpFields); err != nil {
			return err
		}
	case *EncapOrTransportTransposition_TcpFields:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpFields); err != nil {
			return err
		}
	case *EncapOrTransportTransposition_IcmpFields:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpFields); err != nil {
			return err
		}
	case *EncapOrTransportTransposition_EncapFields:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncapFields); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EncapOrTransportTransposition.EncapOrTransport has unexpected type %T", x)
	}
	return nil
}

func _EncapOrTransportTransposition_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EncapOrTransportTransposition)
	switch tag {
	case 1: // encap_or_transport.udp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UdpTranspositionFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportTransposition_UdpFields{msg}
		return true, err
	case 2: // encap_or_transport.tcp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpTranspositionFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportTransposition_TcpFields{msg}
		return true, err
	case 3: // encap_or_transport.icmp_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IcmpTranspositionFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportTransposition_IcmpFields{msg}
		return true, err
	case 4: // encap_or_transport.encap_fields
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncapTranspositionFields)
		err := b.DecodeMessage(msg)
		m.EncapOrTransport = &EncapOrTransportTransposition_EncapFields{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EncapOrTransportTransposition_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EncapOrTransportTransposition)
	// encap_or_transport
	switch x := m.EncapOrTransport.(type) {
	case *EncapOrTransportTransposition_UdpFields:
		s := proto.Size(x.UdpFields)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportTransposition_TcpFields:
		s := proto.Size(x.TcpFields)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportTransposition_IcmpFields:
		s := proto.Size(x.IcmpFields)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EncapOrTransportTransposition_EncapFields:
		s := proto.Size(x.EncapFields)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GftHeaderGroupTransposition struct {
	Action           GftHeaderGroupTranspostionAction `protobuf:"varint,1,opt,name=action,proto3,enum=gft.GftHeaderGroupTranspostionAction" json:"action,omitempty"`
	Headers          *GftHeaders                      `protobuf:"bytes,2,opt,name=headers" json:"headers,omitempty"`
	HeaderFields     *GftHeaderFields                 `protobuf:"bytes,3,opt,name=header_fields,json=headerFields" json:"header_fields,omitempty"`
	EthFields        *GftEthFields                    `protobuf:"bytes,4,opt,name=eth_fields,json=ethFields" json:"eth_fields,omitempty"`
	SrcIpAddr        *IPAddress                       `protobuf:"bytes,5,opt,name=src_ip_addr,json=srcIpAddr" json:"src_ip_addr,omitempty"`
	DstIpAddr        *IPAddress                       `protobuf:"bytes,6,opt,name=dst_ip_addr,json=dstIpAddr" json:"dst_ip_addr,omitempty"`
	IpTtl            uint32                           `protobuf:"varint,7,opt,name=ip_ttl,json=ipTtl,proto3" json:"ip_ttl,omitempty"`
	IpDscp           uint32                           `protobuf:"varint,8,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty"`
	IpProtocol       uint32                           `protobuf:"varint,9,opt,name=ip_protocol,json=ipProtocol,proto3" json:"ip_protocol,omitempty"`
	EncapOrTransport *EncapOrTransportTransposition   `protobuf:"bytes,10,opt,name=encap_or_transport,json=encapOrTransport" json:"encap_or_transport,omitempty"`
}

func (m *GftHeaderGroupTransposition) Reset()                    { *m = GftHeaderGroupTransposition{} }
func (m *GftHeaderGroupTransposition) String() string            { return proto.CompactTextString(m) }
func (*GftHeaderGroupTransposition) ProtoMessage()               {}
func (*GftHeaderGroupTransposition) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{26} }

func (m *GftHeaderGroupTransposition) GetAction() GftHeaderGroupTranspostionAction {
	if m != nil {
		return m.Action
	}
	return GftHeaderGroupTranspostionAction_TRANSPOSITION_ACTION_NONE
}

func (m *GftHeaderGroupTransposition) GetHeaders() *GftHeaders {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GftHeaderGroupTransposition) GetHeaderFields() *GftHeaderFields {
	if m != nil {
		return m.HeaderFields
	}
	return nil
}

func (m *GftHeaderGroupTransposition) GetEthFields() *GftEthFields {
	if m != nil {
		return m.EthFields
	}
	return nil
}

func (m *GftHeaderGroupTransposition) GetSrcIpAddr() *IPAddress {
	if m != nil {
		return m.SrcIpAddr
	}
	return nil
}

func (m *GftHeaderGroupTransposition) GetDstIpAddr() *IPAddress {
	if m != nil {
		return m.DstIpAddr
	}
	return nil
}

func (m *GftHeaderGroupTransposition) GetIpTtl() uint32 {
	if m != nil {
		return m.IpTtl
	}
	return 0
}

func (m *GftHeaderGroupTransposition) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

func (m *GftHeaderGroupTransposition) GetIpProtocol() uint32 {
	if m != nil {
		return m.IpProtocol
	}
	return 0
}

func (m *GftHeaderGroupTransposition) GetEncapOrTransport() *EncapOrTransportTransposition {
	if m != nil {
		return m.EncapOrTransport
	}
	return nil
}

type GftExactMatchFlowEntrySpec struct {
	Meta                                  *ObjectMeta                             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	TableType                             GftTableType                            `protobuf:"varint,2,opt,name=table_type,json=tableType,proto3,enum=gft.GftTableType" json:"table_type,omitempty"`
	KeyOrHandle                           *GftExactMatchFlowEntryKeyHandle        `protobuf:"bytes,3,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	ExactMatchProfile                     *GftExactMatchProfileKeyHandle          `protobuf:"bytes,4,opt,name=exact_match_profile,json=exactMatchProfile" json:"exact_match_profile,omitempty" venice:ref`
	TranspositionProfile                  *GftHeaderTranspositionProfileKeyHandle `protobuf:"bytes,5,opt,name=transposition_profile,json=transpositionProfile" json:"transposition_profile,omitempty" venice:ref`
	AddInActivatedState                   bool                                    `protobuf:"varint,6,opt,name=add_in_activated_state,json=addInActivatedState,proto3" json:"add_in_activated_state,omitempty"`
	RdmaFlow                              bool                                    `protobuf:"varint,7,opt,name=rdma_flow,json=rdmaFlow,proto3" json:"rdma_flow,omitempty"`
	RedirectToVportIngressQueue           bool                                    `protobuf:"varint,8,opt,name=redirect_to_vport_ingress_queue,json=redirectToVportIngressQueue,proto3" json:"redirect_to_vport_ingress_queue,omitempty"`
	RedirectToVportEgressQueue            bool                                    `protobuf:"varint,9,opt,name=redirect_to_vport_egress_queue,json=redirectToVportEgressQueue,proto3" json:"redirect_to_vport_egress_queue,omitempty"`
	RedirectToVportIngressQueueIfTtlIsOne bool                                    `protobuf:"varint,10,opt,name=redirect_to_vport_ingress_queue_if_ttl_is_one,json=redirectToVportIngressQueueIfTtlIsOne,proto3" json:"redirect_to_vport_ingress_queue_if_ttl_is_one,omitempty"`
	RedirectToVportEgressQueueIfTtlIsOne  bool                                    `protobuf:"varint,11,opt,name=redirect_to_vport_egress_queue_if_ttl_is_one,json=redirectToVportEgressQueueIfTtlIsOne,proto3" json:"redirect_to_vport_egress_queue_if_ttl_is_one,omitempty"`
	CopyAllPackets                        bool                                    `protobuf:"varint,12,opt,name=copy_all_packets,json=copyAllPackets,proto3" json:"copy_all_packets,omitempty"`
	CopyFirstPacket                       bool                                    `protobuf:"varint,13,opt,name=copy_first_packet,json=copyFirstPacket,proto3" json:"copy_first_packet,omitempty"`
	CopyWhenTcpFlagSet                    bool                                    `protobuf:"varint,14,opt,name=copy_when_tcp_flag_set,json=copyWhenTcpFlagSet,proto3" json:"copy_when_tcp_flag_set,omitempty"`
	CustomActionPresent                   bool                                    `protobuf:"varint,15,opt,name=custom_action_present,json=customActionPresent,proto3" json:"custom_action_present,omitempty"`
	MetaActionBeforeTransposition         bool                                    `protobuf:"varint,16,opt,name=meta_action_before_transposition,json=metaActionBeforeTransposition,proto3" json:"meta_action_before_transposition,omitempty"`
	CopyAfterTcpFinFlagSet                bool                                    `protobuf:"varint,17,opt,name=copy_after_tcp_fin_flag_set,json=copyAfterTcpFinFlagSet,proto3" json:"copy_after_tcp_fin_flag_set,omitempty"`
	CopyAfterTcpRstFlagSet                bool                                    `protobuf:"varint,18,opt,name=copy_after_tcp_rst_flag_set,json=copyAfterTcpRstFlagSet,proto3" json:"copy_after_tcp_rst_flag_set,omitempty"`
	VportId                               uint32                                  `protobuf:"varint,19,opt,name=vport_id,json=vportId,proto3" json:"vport_id,omitempty"`
	RedirectVportId                       uint32                                  `protobuf:"varint,20,opt,name=redirect_vport_id,json=redirectVportId,proto3" json:"redirect_vport_id,omitempty"`
	TtlOneRedirectVportId                 uint32                                  `protobuf:"varint,21,opt,name=ttl_one_redirect_vport_id,json=ttlOneRedirectVportId,proto3" json:"ttl_one_redirect_vport_id,omitempty"`
	ExactMatches                          []*GftHeaderGroupExactMatch             `protobuf:"bytes,22,rep,name=exact_matches,json=exactMatches" json:"exact_matches,omitempty"`
	Transpositions                        []*GftHeaderGroupTransposition          `protobuf:"bytes,23,rep,name=transpositions" json:"transpositions,omitempty"`
}

func (m *GftExactMatchFlowEntrySpec) Reset()                    { *m = GftExactMatchFlowEntrySpec{} }
func (m *GftExactMatchFlowEntrySpec) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntrySpec) ProtoMessage()               {}
func (*GftExactMatchFlowEntrySpec) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{27} }

func (m *GftExactMatchFlowEntrySpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *GftExactMatchFlowEntrySpec) GetTableType() GftTableType {
	if m != nil {
		return m.TableType
	}
	return GftTableType_GFT_TABLE_TYPE_NONE
}

func (m *GftExactMatchFlowEntrySpec) GetKeyOrHandle() *GftExactMatchFlowEntryKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftExactMatchFlowEntrySpec) GetExactMatchProfile() *GftExactMatchProfileKeyHandle {
	if m != nil {
		return m.ExactMatchProfile
	}
	return nil
}

func (m *GftExactMatchFlowEntrySpec) GetTranspositionProfile() *GftHeaderTranspositionProfileKeyHandle {
	if m != nil {
		return m.TranspositionProfile
	}
	return nil
}

func (m *GftExactMatchFlowEntrySpec) GetAddInActivatedState() bool {
	if m != nil {
		return m.AddInActivatedState
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetRdmaFlow() bool {
	if m != nil {
		return m.RdmaFlow
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetRedirectToVportIngressQueue() bool {
	if m != nil {
		return m.RedirectToVportIngressQueue
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetRedirectToVportEgressQueue() bool {
	if m != nil {
		return m.RedirectToVportEgressQueue
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetRedirectToVportIngressQueueIfTtlIsOne() bool {
	if m != nil {
		return m.RedirectToVportIngressQueueIfTtlIsOne
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetRedirectToVportEgressQueueIfTtlIsOne() bool {
	if m != nil {
		return m.RedirectToVportEgressQueueIfTtlIsOne
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCopyAllPackets() bool {
	if m != nil {
		return m.CopyAllPackets
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCopyFirstPacket() bool {
	if m != nil {
		return m.CopyFirstPacket
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCopyWhenTcpFlagSet() bool {
	if m != nil {
		return m.CopyWhenTcpFlagSet
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCustomActionPresent() bool {
	if m != nil {
		return m.CustomActionPresent
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetMetaActionBeforeTransposition() bool {
	if m != nil {
		return m.MetaActionBeforeTransposition
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCopyAfterTcpFinFlagSet() bool {
	if m != nil {
		return m.CopyAfterTcpFinFlagSet
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetCopyAfterTcpRstFlagSet() bool {
	if m != nil {
		return m.CopyAfterTcpRstFlagSet
	}
	return false
}

func (m *GftExactMatchFlowEntrySpec) GetVportId() uint32 {
	if m != nil {
		return m.VportId
	}
	return 0
}

func (m *GftExactMatchFlowEntrySpec) GetRedirectVportId() uint32 {
	if m != nil {
		return m.RedirectVportId
	}
	return 0
}

func (m *GftExactMatchFlowEntrySpec) GetTtlOneRedirectVportId() uint32 {
	if m != nil {
		return m.TtlOneRedirectVportId
	}
	return 0
}

func (m *GftExactMatchFlowEntrySpec) GetExactMatches() []*GftHeaderGroupExactMatch {
	if m != nil {
		return m.ExactMatches
	}
	return nil
}

func (m *GftExactMatchFlowEntrySpec) GetTranspositions() []*GftHeaderGroupTransposition {
	if m != nil {
		return m.Transpositions
	}
	return nil
}

// GftExactMatchFlowEntryRequestMsg is used to do batched add or modify of GFT
// exact match flow entry
type GftExactMatchFlowEntryRequestMsg struct {
	Request []*GftExactMatchFlowEntrySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *GftExactMatchFlowEntryRequestMsg) Reset()         { *m = GftExactMatchFlowEntryRequestMsg{} }
func (m *GftExactMatchFlowEntryRequestMsg) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntryRequestMsg) ProtoMessage()    {}
func (*GftExactMatchFlowEntryRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{28}
}

func (m *GftExactMatchFlowEntryRequestMsg) GetRequest() []*GftExactMatchFlowEntrySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// GftExactMatchFlowEntryStatus represents the current status of GFT exact match flow entry
type GftExactMatchFlowEntryStatus struct {
	FlowEntryHandle uint64 `protobuf:"fixed64,1,opt,name=flow_entry_handle,json=flowEntryHandle,proto3" json:"flow_entry_handle,omitempty"`
	FlowIndex       uint64 `protobuf:"varint,2,opt,name=flow_index,json=flowIndex,proto3" json:"flow_index,omitempty"`
	FlowInfoIndex   uint64 `protobuf:"varint,3,opt,name=flow_info_index,json=flowInfoIndex,proto3" json:"flow_info_index,omitempty"`
}

func (m *GftExactMatchFlowEntryStatus) Reset()                    { *m = GftExactMatchFlowEntryStatus{} }
func (m *GftExactMatchFlowEntryStatus) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntryStatus) ProtoMessage()               {}
func (*GftExactMatchFlowEntryStatus) Descriptor() ([]byte, []int) { return fileDescriptorGft, []int{29} }

func (m *GftExactMatchFlowEntryStatus) GetFlowEntryHandle() uint64 {
	if m != nil {
		return m.FlowEntryHandle
	}
	return 0
}

func (m *GftExactMatchFlowEntryStatus) GetFlowIndex() uint64 {
	if m != nil {
		return m.FlowIndex
	}
	return 0
}

func (m *GftExactMatchFlowEntryStatus) GetFlowInfoIndex() uint64 {
	if m != nil {
		return m.FlowInfoIndex
	}
	return 0
}

// GftExactMatchFlowEntryResponse is response to GftExactMatchFlowEntrySpec
type GftExactMatchFlowEntryResponse struct {
	ApiStatus ApiStatus                     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *GftExactMatchFlowEntryStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *GftExactMatchFlowEntryResponse) Reset()         { *m = GftExactMatchFlowEntryResponse{} }
func (m *GftExactMatchFlowEntryResponse) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntryResponse) ProtoMessage()    {}
func (*GftExactMatchFlowEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{30}
}

func (m *GftExactMatchFlowEntryResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *GftExactMatchFlowEntryResponse) GetStatus() *GftExactMatchFlowEntryStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// GftExactMatchFlowEntryResponseMsg is batched response to GftExactMatchFlowEntryRequestMsg
type GftExactMatchFlowEntryResponseMsg struct {
	Response []*GftExactMatchFlowEntryResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *GftExactMatchFlowEntryResponseMsg) Reset()         { *m = GftExactMatchFlowEntryResponseMsg{} }
func (m *GftExactMatchFlowEntryResponseMsg) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntryResponseMsg) ProtoMessage()    {}
func (*GftExactMatchFlowEntryResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorGft, []int{31}
}

func (m *GftExactMatchFlowEntryResponseMsg) GetResponse() []*GftExactMatchFlowEntryResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*GftEthFields)(nil), "gft.GftEthFields")
	proto.RegisterType((*GftHeaders)(nil), "gft.GftHeaders")
	proto.RegisterType((*GftHeaderFields)(nil), "gft.GftHeaderFields")
	proto.RegisterType((*GftHeaderGroupExactMatchProfile)(nil), "gft.GftHeaderGroupExactMatchProfile")
	proto.RegisterType((*GftExactMatchProfileSpec)(nil), "gft.GftExactMatchProfileSpec")
	proto.RegisterType((*GftExactMatchProfileRequestMsg)(nil), "gft.GftExactMatchProfileRequestMsg")
	proto.RegisterType((*GftExactMatchProfileStatus)(nil), "gft.GftExactMatchProfileStatus")
	proto.RegisterType((*GftExactMatchProfileResponse)(nil), "gft.GftExactMatchProfileResponse")
	proto.RegisterType((*GftExactMatchProfileResponseMsg)(nil), "gft.GftExactMatchProfileResponseMsg")
	proto.RegisterType((*UdpMatchFields)(nil), "gft.UdpMatchFields")
	proto.RegisterType((*TcpMatchFields)(nil), "gft.TcpMatchFields")
	proto.RegisterType((*IcmpMatchFields)(nil), "gft.IcmpMatchFields")
	proto.RegisterType((*EncapMatchFields)(nil), "gft.EncapMatchFields")
	proto.RegisterType((*GftHeaderGroupTranspositionProfile)(nil), "gft.GftHeaderGroupTranspositionProfile")
	proto.RegisterType((*GftHeaderTranspositionProfileSpec)(nil), "gft.GftHeaderTranspositionProfileSpec")
	proto.RegisterType((*GftHeaderTranspositionProfileRequestMsg)(nil), "gft.GftHeaderTranspositionProfileRequestMsg")
	proto.RegisterType((*GftHeaderTranspositionProfileStatus)(nil), "gft.GftHeaderTranspositionProfileStatus")
	proto.RegisterType((*GftHeaderTranspositionProfileResponse)(nil), "gft.GftHeaderTranspositionProfileResponse")
	proto.RegisterType((*GftHeaderTranspositionProfileResponseMsg)(nil), "gft.GftHeaderTranspositionProfileResponseMsg")
	proto.RegisterType((*EncapOrTransportMatch)(nil), "gft.EncapOrTransportMatch")
	proto.RegisterType((*GftHeaderGroupExactMatch)(nil), "gft.GftHeaderGroupExactMatch")
	proto.RegisterType((*UdpTranspositionFields)(nil), "gft.UdpTranspositionFields")
	proto.RegisterType((*TcpTranspositionFields)(nil), "gft.TcpTranspositionFields")
	proto.RegisterType((*IcmpTranspositionFields)(nil), "gft.IcmpTranspositionFields")
	proto.RegisterType((*EncapTranspositionFields)(nil), "gft.EncapTranspositionFields")
	proto.RegisterType((*EncapOrTransportTransposition)(nil), "gft.EncapOrTransportTransposition")
	proto.RegisterType((*GftHeaderGroupTransposition)(nil), "gft.GftHeaderGroupTransposition")
	proto.RegisterType((*GftExactMatchFlowEntrySpec)(nil), "gft.GftExactMatchFlowEntrySpec")
	proto.RegisterType((*GftExactMatchFlowEntryRequestMsg)(nil), "gft.GftExactMatchFlowEntryRequestMsg")
	proto.RegisterType((*GftExactMatchFlowEntryStatus)(nil), "gft.GftExactMatchFlowEntryStatus")
	proto.RegisterType((*GftExactMatchFlowEntryResponse)(nil), "gft.GftExactMatchFlowEntryResponse")
	proto.RegisterType((*GftExactMatchFlowEntryResponseMsg)(nil), "gft.GftExactMatchFlowEntryResponseMsg")
	proto.RegisterEnum("gft.GftTableType", GftTableType_name, GftTableType_value)
	proto.RegisterEnum("gft.GftHeaderGroupTranspostionAction", GftHeaderGroupTranspostionAction_name, GftHeaderGroupTranspostionAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Gft service

type GftClient interface {
	GftExactMatchProfileCreate(ctx context.Context, in *GftExactMatchProfileRequestMsg, opts ...grpc.CallOption) (*GftExactMatchProfileResponseMsg, error)
	GftHeaderTranspositionProfileCreate(ctx context.Context, in *GftHeaderTranspositionProfileRequestMsg, opts ...grpc.CallOption) (*GftHeaderTranspositionProfileResponseMsg, error)
	GftExactMatchFlowEntryCreate(ctx context.Context, in *GftExactMatchFlowEntryRequestMsg, opts ...grpc.CallOption) (*GftExactMatchFlowEntryResponseMsg, error)
}

type gftClient struct {
	cc *grpc.ClientConn
}

func NewGftClient(cc *grpc.ClientConn) GftClient {
	return &gftClient{cc}
}

func (c *gftClient) GftExactMatchProfileCreate(ctx context.Context, in *GftExactMatchProfileRequestMsg, opts ...grpc.CallOption) (*GftExactMatchProfileResponseMsg, error) {
	out := new(GftExactMatchProfileResponseMsg)
	err := grpc.Invoke(ctx, "/gft.Gft/GftExactMatchProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gftClient) GftHeaderTranspositionProfileCreate(ctx context.Context, in *GftHeaderTranspositionProfileRequestMsg, opts ...grpc.CallOption) (*GftHeaderTranspositionProfileResponseMsg, error) {
	out := new(GftHeaderTranspositionProfileResponseMsg)
	err := grpc.Invoke(ctx, "/gft.Gft/GftHeaderTranspositionProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gftClient) GftExactMatchFlowEntryCreate(ctx context.Context, in *GftExactMatchFlowEntryRequestMsg, opts ...grpc.CallOption) (*GftExactMatchFlowEntryResponseMsg, error) {
	out := new(GftExactMatchFlowEntryResponseMsg)
	err := grpc.Invoke(ctx, "/gft.Gft/GftExactMatchFlowEntryCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gft service

type GftServer interface {
	GftExactMatchProfileCreate(context.Context, *GftExactMatchProfileRequestMsg) (*GftExactMatchProfileResponseMsg, error)
	GftHeaderTranspositionProfileCreate(context.Context, *GftHeaderTranspositionProfileRequestMsg) (*GftHeaderTranspositionProfileResponseMsg, error)
	GftExactMatchFlowEntryCreate(context.Context, *GftExactMatchFlowEntryRequestMsg) (*GftExactMatchFlowEntryResponseMsg, error)
}

func RegisterGftServer(s *grpc.Server, srv GftServer) {
	s.RegisterService(&_Gft_serviceDesc, srv)
}

func _Gft_GftExactMatchProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GftExactMatchProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GftServer).GftExactMatchProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gft.Gft/GftExactMatchProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GftServer).GftExactMatchProfileCreate(ctx, req.(*GftExactMatchProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gft_GftHeaderTranspositionProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GftHeaderTranspositionProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GftServer).GftHeaderTranspositionProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gft.Gft/GftHeaderTranspositionProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GftServer).GftHeaderTranspositionProfileCreate(ctx, req.(*GftHeaderTranspositionProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gft_GftExactMatchFlowEntryCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GftExactMatchFlowEntryRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GftServer).GftExactMatchFlowEntryCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gft.Gft/GftExactMatchFlowEntryCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GftServer).GftExactMatchFlowEntryCreate(ctx, req.(*GftExactMatchFlowEntryRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gft.Gft",
	HandlerType: (*GftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GftExactMatchProfileCreate",
			Handler:    _Gft_GftExactMatchProfileCreate_Handler,
		},
		{
			MethodName: "GftHeaderTranspositionProfileCreate",
			Handler:    _Gft_GftHeaderTranspositionProfileCreate_Handler,
		},
		{
			MethodName: "GftExactMatchFlowEntryCreate",
			Handler:    _Gft_GftExactMatchFlowEntryCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gft.proto",
}

func (m *GftEthFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftEthFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DstMacAddr != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.DstMacAddr))
	}
	if m.SrcMacAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.SrcMacAddr))
	}
	if m.EthType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EthType))
	}
	if m.CustomerVlanId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.CustomerVlanId))
	}
	if m.ProviderVlanId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.ProviderVlanId))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Priority))
	}
	return i, nil
}

func (m *GftHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaders) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EthernetHeader {
		dAtA[i] = 0x8
		i++
		if m.EthernetHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv4Header {
		dAtA[i] = 0x10
		i++
		if m.Ipv4Header {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6Header {
		dAtA[i] = 0x18
		i++
		if m.Ipv6Header {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpHeader {
		dAtA[i] = 0x20
		i++
		if m.TcpHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UdpHeader {
		dAtA[i] = 0x28
		i++
		if m.UdpHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpHeader {
		dAtA[i] = 0x30
		i++
		if m.IcmpHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoEncap {
		dAtA[i] = 0x38
		i++
		if m.NoEncap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpInIpEncap {
		dAtA[i] = 0x40
		i++
		if m.IpInIpEncap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpInGreEncap {
		dAtA[i] = 0x48
		i++
		if m.IpInGreEncap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NvgreEncap {
		dAtA[i] = 0x50
		i++
		if m.NvgreEncap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VxlanEncap {
		dAtA[i] = 0x58
		i++
		if m.VxlanEncap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GftHeaderFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DstMacAddr {
		dAtA[i] = 0x8
		i++
		if m.DstMacAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SrcMacAddr {
		dAtA[i] = 0x10
		i++
		if m.SrcMacAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EthType {
		dAtA[i] = 0x18
		i++
		if m.EthType {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CustomerVlanId {
		dAtA[i] = 0x20
		i++
		if m.CustomerVlanId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProviderVlanId {
		dAtA[i] = 0x28
		i++
		if m.ProviderVlanId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dot1PPriority {
		dAtA[i] = 0x30
		i++
		if m.Dot1PPriority {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SrcIpAddr {
		dAtA[i] = 0x38
		i++
		if m.SrcIpAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DstIpAddr {
		dAtA[i] = 0x40
		i++
		if m.DstIpAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpTtl {
		dAtA[i] = 0x48
		i++
		if m.IpTtl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpProtocol {
		dAtA[i] = 0x50
		i++
		if m.IpProtocol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpDscp {
		dAtA[i] = 0x58
		i++
		if m.IpDscp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SrcPort {
		dAtA[i] = 0x60
		i++
		if m.SrcPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DstPort {
		dAtA[i] = 0x68
		i++
		if m.DstPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpFlags {
		dAtA[i] = 0x70
		i++
		if m.TcpFlags {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TenantId {
		dAtA[i] = 0x78
		i++
		if m.TenantId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpType {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IcmpType {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpCode {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IcmpCode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OobVlan {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.OobVlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OobTenantId {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.OobTenantId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GreProtocol {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.GreProtocol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GftHeaderGroupExactMatchProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderGroupExactMatchProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Headers != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Headers.Size()))
		n1, err := m.Headers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MatchFields != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.MatchFields.Size()))
		n2, err := m.MatchFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GftExactMatchProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n4, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.RdmaFlow {
		dAtA[i] = 0x18
		i++
		if m.RdmaFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TableType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TableType))
	}
	if len(m.ExactMatchProfiles) > 0 {
		for _, msg := range m.ExactMatchProfiles {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftExactMatchProfileRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchProfileRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftExactMatchProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProfileHandle))
		i += 8
	}
	return i, nil
}

func (m *GftExactMatchProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Status.Size()))
		n5, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *GftExactMatchProfileResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchProfileResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UdpMatchFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpMatchFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sport != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Dport))
	}
	return i, nil
}

func (m *TcpMatchFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpMatchFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sport != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Dport))
	}
	if m.TcpFlags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TcpFlags))
	}
	return i, nil
}

func (m *IcmpMatchFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpMatchFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *EncapMatchFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapMatchFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TenantId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TenantId))
	}
	if m.GreProtocol != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.GreProtocol))
	}
	return i, nil
}

func (m *GftHeaderGroupTranspositionProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderGroupTranspositionProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Action))
	}
	if m.Headers != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Headers.Size()))
		n6, err := m.Headers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.MatchFields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.MatchFields.Size()))
		n7, err := m.MatchFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *GftHeaderTranspositionProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderTranspositionProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.RedirectToVportIngressQueue {
		dAtA[i] = 0x18
		i++
		if m.RedirectToVportIngressQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportEgressQueue {
		dAtA[i] = 0x20
		i++
		if m.RedirectToVportEgressQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportIngressQueueIfTtlIsOne {
		dAtA[i] = 0x28
		i++
		if m.RedirectToVportIngressQueueIfTtlIsOne {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportEgressQueueIfTtlIsOne {
		dAtA[i] = 0x30
		i++
		if m.RedirectToVportEgressQueueIfTtlIsOne {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyAllPackets {
		dAtA[i] = 0x38
		i++
		if m.CopyAllPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyFirstPacket {
		dAtA[i] = 0x40
		i++
		if m.CopyFirstPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyWhenTcpFlagSet {
		dAtA[i] = 0x48
		i++
		if m.CopyWhenTcpFlagSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CustomActionPresent {
		dAtA[i] = 0x50
		i++
		if m.CustomActionPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MetaActionBeforeTransposition {
		dAtA[i] = 0x58
		i++
		if m.MetaActionBeforeTransposition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TableType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TableType))
	}
	if len(m.TranspositionProfiles) > 0 {
		for _, msg := range m.TranspositionProfiles {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftHeaderTranspositionProfileRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderTranspositionProfileRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftHeaderTranspositionProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderTranspositionProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProfileHandle))
		i += 8
	}
	return i, nil
}

func (m *GftHeaderTranspositionProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderTranspositionProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *GftHeaderTranspositionProfileResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderTranspositionProfileResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EncapOrTransportMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapOrTransportMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EncapOrTransport != nil {
		nn11, err := m.EncapOrTransport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *EncapOrTransportMatch_UdpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UdpFields != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.UdpFields.Size()))
		n12, err := m.UdpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *EncapOrTransportMatch_TcpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpFields != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TcpFields.Size()))
		n13, err := m.TcpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *EncapOrTransportMatch_IcmpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpFields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IcmpFields.Size()))
		n14, err := m.IcmpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *EncapOrTransportMatch_EncapFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EncapFields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EncapFields.Size()))
		n15, err := m.EncapFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *GftHeaderGroupExactMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderGroupExactMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Headers != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Headers.Size()))
		n16, err := m.Headers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MatchFields != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.MatchFields.Size()))
		n17, err := m.MatchFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.EthFields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EthFields.Size()))
		n18, err := m.EthFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.SrcIpAddr != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.SrcIpAddr.Size()))
		n19, err := m.SrcIpAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.DstIpAddr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.DstIpAddr.Size()))
		n20, err := m.DstIpAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.IpTtl != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpTtl))
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpDscp))
	}
	if m.IpProtocol != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpProtocol))
	}
	if m.EncapOrTransport != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EncapOrTransport.Size()))
		n21, err := m.EncapOrTransport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *UdpTranspositionFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpTranspositionFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sport != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Dport))
	}
	return i, nil
}

func (m *TcpTranspositionFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpTranspositionFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sport != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Dport))
	}
	return i, nil
}

func (m *IcmpTranspositionFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpTranspositionFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *EncapTranspositionFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapTranspositionFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TenantId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TenantId))
	}
	if m.GreProtocol != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.GreProtocol))
	}
	return i, nil
}

func (m *EncapOrTransportTransposition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapOrTransportTransposition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EncapOrTransport != nil {
		nn22, err := m.EncapOrTransport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *EncapOrTransportTransposition_UdpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UdpFields != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.UdpFields.Size()))
		n23, err := m.UdpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *EncapOrTransportTransposition_TcpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpFields != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TcpFields.Size()))
		n24, err := m.TcpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *EncapOrTransportTransposition_IcmpFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpFields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IcmpFields.Size()))
		n25, err := m.IcmpFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *EncapOrTransportTransposition_EncapFields) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EncapFields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EncapFields.Size()))
		n26, err := m.EncapFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *GftHeaderGroupTransposition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftHeaderGroupTransposition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Action))
	}
	if m.Headers != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Headers.Size()))
		n27, err := m.Headers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.HeaderFields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.HeaderFields.Size()))
		n28, err := m.HeaderFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.EthFields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EthFields.Size()))
		n29, err := m.EthFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.SrcIpAddr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.SrcIpAddr.Size()))
		n30, err := m.SrcIpAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.DstIpAddr != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.DstIpAddr.Size()))
		n31, err := m.DstIpAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.IpTtl != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpTtl))
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpDscp))
	}
	if m.IpProtocol != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.IpProtocol))
	}
	if m.EncapOrTransport != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.EncapOrTransport.Size()))
		n32, err := m.EncapOrTransport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *GftExactMatchFlowEntrySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchFlowEntrySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Meta.Size()))
		n33, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.TableType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TableType))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n34, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.ExactMatchProfile != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.ExactMatchProfile.Size()))
		n35, err := m.ExactMatchProfile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.TranspositionProfile != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TranspositionProfile.Size()))
		n36, err := m.TranspositionProfile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.AddInActivatedState {
		dAtA[i] = 0x30
		i++
		if m.AddInActivatedState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RdmaFlow {
		dAtA[i] = 0x38
		i++
		if m.RdmaFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportIngressQueue {
		dAtA[i] = 0x40
		i++
		if m.RedirectToVportIngressQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportEgressQueue {
		dAtA[i] = 0x48
		i++
		if m.RedirectToVportEgressQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportIngressQueueIfTtlIsOne {
		dAtA[i] = 0x50
		i++
		if m.RedirectToVportIngressQueueIfTtlIsOne {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectToVportEgressQueueIfTtlIsOne {
		dAtA[i] = 0x58
		i++
		if m.RedirectToVportEgressQueueIfTtlIsOne {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyAllPackets {
		dAtA[i] = 0x60
		i++
		if m.CopyAllPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyFirstPacket {
		dAtA[i] = 0x68
		i++
		if m.CopyFirstPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyWhenTcpFlagSet {
		dAtA[i] = 0x70
		i++
		if m.CopyWhenTcpFlagSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CustomActionPresent {
		dAtA[i] = 0x78
		i++
		if m.CustomActionPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MetaActionBeforeTransposition {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.MetaActionBeforeTransposition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyAfterTcpFinFlagSet {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.CopyAfterTcpFinFlagSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CopyAfterTcpRstFlagSet {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.CopyAfterTcpRstFlagSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VportId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.VportId))
	}
	if m.RedirectVportId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.RedirectVportId))
	}
	if m.TtlOneRedirectVportId != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.TtlOneRedirectVportId))
	}
	if len(m.ExactMatches) > 0 {
		for _, msg := range m.ExactMatches {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Transpositions) > 0 {
		for _, msg := range m.Transpositions {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftExactMatchFlowEntryRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchFlowEntryRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GftExactMatchFlowEntryStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchFlowEntryStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowEntryHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.FlowEntryHandle))
		i += 8
	}
	if m.FlowIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.FlowIndex))
	}
	if m.FlowInfoIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.FlowInfoIndex))
	}
	return i, nil
}

func (m *GftExactMatchFlowEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchFlowEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGft(dAtA, i, uint64(m.Status.Size()))
		n37, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *GftExactMatchFlowEntryResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GftExactMatchFlowEntryResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintGft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GftEthFields) Size() (n int) {
	var l int
	_ = l
	if m.DstMacAddr != 0 {
		n += 1 + sovGft(uint64(m.DstMacAddr))
	}
	if m.SrcMacAddr != 0 {
		n += 1 + sovGft(uint64(m.SrcMacAddr))
	}
	if m.EthType != 0 {
		n += 1 + sovGft(uint64(m.EthType))
	}
	if m.CustomerVlanId != 0 {
		n += 1 + sovGft(uint64(m.CustomerVlanId))
	}
	if m.ProviderVlanId != 0 {
		n += 1 + sovGft(uint64(m.ProviderVlanId))
	}
	if m.Priority != 0 {
		n += 1 + sovGft(uint64(m.Priority))
	}
	return n
}

func (m *GftHeaders) Size() (n int) {
	var l int
	_ = l
	if m.EthernetHeader {
		n += 2
	}
	if m.Ipv4Header {
		n += 2
	}
	if m.Ipv6Header {
		n += 2
	}
	if m.TcpHeader {
		n += 2
	}
	if m.UdpHeader {
		n += 2
	}
	if m.IcmpHeader {
		n += 2
	}
	if m.NoEncap {
		n += 2
	}
	if m.IpInIpEncap {
		n += 2
	}
	if m.IpInGreEncap {
		n += 2
	}
	if m.NvgreEncap {
		n += 2
	}
	if m.VxlanEncap {
		n += 2
	}
	return n
}

func (m *GftHeaderFields) Size() (n int) {
	var l int
	_ = l
	if m.DstMacAddr {
		n += 2
	}
	if m.SrcMacAddr {
		n += 2
	}
	if m.EthType {
		n += 2
	}
	if m.CustomerVlanId {
		n += 2
	}
	if m.ProviderVlanId {
		n += 2
	}
	if m.Dot1PPriority {
		n += 2
	}
	if m.SrcIpAddr {
		n += 2
	}
	if m.DstIpAddr {
		n += 2
	}
	if m.IpTtl {
		n += 2
	}
	if m.IpProtocol {
		n += 2
	}
	if m.IpDscp {
		n += 2
	}
	if m.SrcPort {
		n += 2
	}
	if m.DstPort {
		n += 2
	}
	if m.TcpFlags {
		n += 2
	}
	if m.TenantId {
		n += 2
	}
	if m.IcmpType {
		n += 3
	}
	if m.IcmpCode {
		n += 3
	}
	if m.OobVlan {
		n += 3
	}
	if m.OobTenantId {
		n += 3
	}
	if m.GreProtocol {
		n += 3
	}
	return n
}

func (m *GftHeaderGroupExactMatchProfile) Size() (n int) {
	var l int
	_ = l
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.MatchFields != nil {
		l = m.MatchFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftExactMatchProfileSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.RdmaFlow {
		n += 2
	}
	if m.TableType != 0 {
		n += 1 + sovGft(uint64(m.TableType))
	}
	if len(m.ExactMatchProfiles) > 0 {
		for _, e := range m.ExactMatchProfiles {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftExactMatchProfileRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftExactMatchProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		n += 9
	}
	return n
}

func (m *GftExactMatchProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovGft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftExactMatchProfileResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *UdpMatchFields) Size() (n int) {
	var l int
	_ = l
	if m.Sport != 0 {
		n += 1 + sovGft(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovGft(uint64(m.Dport))
	}
	return n
}

func (m *TcpMatchFields) Size() (n int) {
	var l int
	_ = l
	if m.Sport != 0 {
		n += 1 + sovGft(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovGft(uint64(m.Dport))
	}
	if m.TcpFlags != 0 {
		n += 1 + sovGft(uint64(m.TcpFlags))
	}
	return n
}

func (m *IcmpMatchFields) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGft(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovGft(uint64(m.Code))
	}
	return n
}

func (m *EncapMatchFields) Size() (n int) {
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 1 + sovGft(uint64(m.TenantId))
	}
	if m.GreProtocol != 0 {
		n += 1 + sovGft(uint64(m.GreProtocol))
	}
	return n
}

func (m *GftHeaderGroupTranspositionProfile) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovGft(uint64(m.Action))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.MatchFields != nil {
		l = m.MatchFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftHeaderTranspositionProfileSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.RedirectToVportIngressQueue {
		n += 2
	}
	if m.RedirectToVportEgressQueue {
		n += 2
	}
	if m.RedirectToVportIngressQueueIfTtlIsOne {
		n += 2
	}
	if m.RedirectToVportEgressQueueIfTtlIsOne {
		n += 2
	}
	if m.CopyAllPackets {
		n += 2
	}
	if m.CopyFirstPacket {
		n += 2
	}
	if m.CopyWhenTcpFlagSet {
		n += 2
	}
	if m.CustomActionPresent {
		n += 2
	}
	if m.MetaActionBeforeTransposition {
		n += 2
	}
	if m.TableType != 0 {
		n += 1 + sovGft(uint64(m.TableType))
	}
	if len(m.TranspositionProfiles) > 0 {
		for _, e := range m.TranspositionProfiles {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftHeaderTranspositionProfileRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftHeaderTranspositionProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		n += 9
	}
	return n
}

func (m *GftHeaderTranspositionProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovGft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftHeaderTranspositionProfileResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *EncapOrTransportMatch) Size() (n int) {
	var l int
	_ = l
	if m.EncapOrTransport != nil {
		n += m.EncapOrTransport.Size()
	}
	return n
}

func (m *EncapOrTransportMatch_UdpFields) Size() (n int) {
	var l int
	_ = l
	if m.UdpFields != nil {
		l = m.UdpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportMatch_TcpFields) Size() (n int) {
	var l int
	_ = l
	if m.TcpFields != nil {
		l = m.TcpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportMatch_IcmpFields) Size() (n int) {
	var l int
	_ = l
	if m.IcmpFields != nil {
		l = m.IcmpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportMatch_EncapFields) Size() (n int) {
	var l int
	_ = l
	if m.EncapFields != nil {
		l = m.EncapFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *GftHeaderGroupExactMatch) Size() (n int) {
	var l int
	_ = l
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.MatchFields != nil {
		l = m.MatchFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.EthFields != nil {
		l = m.EthFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.SrcIpAddr != nil {
		l = m.SrcIpAddr.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.DstIpAddr != nil {
		l = m.DstIpAddr.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.IpTtl != 0 {
		n += 1 + sovGft(uint64(m.IpTtl))
	}
	if m.IpDscp != 0 {
		n += 1 + sovGft(uint64(m.IpDscp))
	}
	if m.IpProtocol != 0 {
		n += 1 + sovGft(uint64(m.IpProtocol))
	}
	if m.EncapOrTransport != nil {
		l = m.EncapOrTransport.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *UdpTranspositionFields) Size() (n int) {
	var l int
	_ = l
	if m.Sport != 0 {
		n += 1 + sovGft(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovGft(uint64(m.Dport))
	}
	return n
}

func (m *TcpTranspositionFields) Size() (n int) {
	var l int
	_ = l
	if m.Sport != 0 {
		n += 1 + sovGft(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovGft(uint64(m.Dport))
	}
	return n
}

func (m *IcmpTranspositionFields) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGft(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovGft(uint64(m.Code))
	}
	return n
}

func (m *EncapTranspositionFields) Size() (n int) {
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 1 + sovGft(uint64(m.TenantId))
	}
	if m.GreProtocol != 0 {
		n += 1 + sovGft(uint64(m.GreProtocol))
	}
	return n
}

func (m *EncapOrTransportTransposition) Size() (n int) {
	var l int
	_ = l
	if m.EncapOrTransport != nil {
		n += m.EncapOrTransport.Size()
	}
	return n
}

func (m *EncapOrTransportTransposition_UdpFields) Size() (n int) {
	var l int
	_ = l
	if m.UdpFields != nil {
		l = m.UdpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportTransposition_TcpFields) Size() (n int) {
	var l int
	_ = l
	if m.TcpFields != nil {
		l = m.TcpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportTransposition_IcmpFields) Size() (n int) {
	var l int
	_ = l
	if m.IcmpFields != nil {
		l = m.IcmpFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *EncapOrTransportTransposition_EncapFields) Size() (n int) {
	var l int
	_ = l
	if m.EncapFields != nil {
		l = m.EncapFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}
func (m *GftHeaderGroupTransposition) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovGft(uint64(m.Action))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.HeaderFields != nil {
		l = m.HeaderFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.EthFields != nil {
		l = m.EthFields.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.SrcIpAddr != nil {
		l = m.SrcIpAddr.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.DstIpAddr != nil {
		l = m.DstIpAddr.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.IpTtl != 0 {
		n += 1 + sovGft(uint64(m.IpTtl))
	}
	if m.IpDscp != 0 {
		n += 1 + sovGft(uint64(m.IpDscp))
	}
	if m.IpProtocol != 0 {
		n += 1 + sovGft(uint64(m.IpProtocol))
	}
	if m.EncapOrTransport != nil {
		l = m.EncapOrTransport.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftExactMatchFlowEntrySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.TableType != 0 {
		n += 1 + sovGft(uint64(m.TableType))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.ExactMatchProfile != nil {
		l = m.ExactMatchProfile.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.TranspositionProfile != nil {
		l = m.TranspositionProfile.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	if m.AddInActivatedState {
		n += 2
	}
	if m.RdmaFlow {
		n += 2
	}
	if m.RedirectToVportIngressQueue {
		n += 2
	}
	if m.RedirectToVportEgressQueue {
		n += 2
	}
	if m.RedirectToVportIngressQueueIfTtlIsOne {
		n += 2
	}
	if m.RedirectToVportEgressQueueIfTtlIsOne {
		n += 2
	}
	if m.CopyAllPackets {
		n += 2
	}
	if m.CopyFirstPacket {
		n += 2
	}
	if m.CopyWhenTcpFlagSet {
		n += 2
	}
	if m.CustomActionPresent {
		n += 2
	}
	if m.MetaActionBeforeTransposition {
		n += 3
	}
	if m.CopyAfterTcpFinFlagSet {
		n += 3
	}
	if m.CopyAfterTcpRstFlagSet {
		n += 3
	}
	if m.VportId != 0 {
		n += 2 + sovGft(uint64(m.VportId))
	}
	if m.RedirectVportId != 0 {
		n += 2 + sovGft(uint64(m.RedirectVportId))
	}
	if m.TtlOneRedirectVportId != 0 {
		n += 2 + sovGft(uint64(m.TtlOneRedirectVportId))
	}
	if len(m.ExactMatches) > 0 {
		for _, e := range m.ExactMatches {
			l = e.Size()
			n += 2 + l + sovGft(uint64(l))
		}
	}
	if len(m.Transpositions) > 0 {
		for _, e := range m.Transpositions {
			l = e.Size()
			n += 2 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftExactMatchFlowEntryRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func (m *GftExactMatchFlowEntryStatus) Size() (n int) {
	var l int
	_ = l
	if m.FlowEntryHandle != 0 {
		n += 9
	}
	if m.FlowIndex != 0 {
		n += 1 + sovGft(uint64(m.FlowIndex))
	}
	if m.FlowInfoIndex != 0 {
		n += 1 + sovGft(uint64(m.FlowInfoIndex))
	}
	return n
}

func (m *GftExactMatchFlowEntryResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovGft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGft(uint64(l))
	}
	return n
}

func (m *GftExactMatchFlowEntryResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovGft(uint64(l))
		}
	}
	return n
}

func sovGft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGft(x uint64) (n int) {
	return sovGft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GftEthFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftEthFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftEthFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMacAddr", wireType)
			}
			m.DstMacAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMacAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMacAddr", wireType)
			}
			m.SrcMacAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMacAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			m.EthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerVlanId", wireType)
			}
			m.CustomerVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderVlanId", wireType)
			}
			m.ProviderVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EthernetHeader = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Header", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv4Header = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Header", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6Header = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpHeader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UdpHeader = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpHeader = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEncap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoEncap = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInIpEncap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpInIpEncap = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInGreEncap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpInGreEncap = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NvgreEncap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NvgreEncap = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanEncap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VxlanEncap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMacAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DstMacAddr = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMacAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrcMacAddr = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EthType = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerVlanId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CustomerVlanId = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderVlanId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProviderVlanId = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1PPriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dot1PPriority = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIpAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrcIpAddr = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DstIpAddr = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpTtl = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpProtocol = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDscp = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrcPort = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DstPort = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlags", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpFlags = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TenantId = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpType", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpType = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpCode = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OobVlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OobVlan = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OobTenantId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OobTenantId = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreProtocol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GreProtocol = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderGroupExactMatchProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderGroupExactMatchProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderGroupExactMatchProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &GftHeaders{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchFields == nil {
				m.MatchFields = &GftHeaderFields{}
			}
			if err := m.MatchFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &GftExactMatchProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdmaFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RdmaFlow = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			m.TableType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableType |= (GftTableType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatchProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactMatchProfiles = append(m.ExactMatchProfiles, &GftHeaderGroupExactMatchProfile{})
			if err := m.ExactMatchProfiles[len(m.ExactMatchProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchProfileRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchProfileRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchProfileRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &GftExactMatchProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileHandle", wireType)
			}
			m.ProfileHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &GftExactMatchProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchProfileResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchProfileResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchProfileResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &GftExactMatchProfileResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpMatchFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpMatchFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpMatchFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpMatchFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpMatchFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpMatchFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlags", wireType)
			}
			m.TcpFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpMatchFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpMatchFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpMatchFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapMatchFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapMatchFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapMatchFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreProtocol", wireType)
			}
			m.GreProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GreProtocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderGroupTranspositionProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderGroupTranspositionProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderGroupTranspositionProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (GftHeaderGroupTranspostionAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &GftHeaders{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchFields == nil {
				m.MatchFields = &GftHeaderFields{}
			}
			if err := m.MatchFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderTranspositionProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &GftHeaderTranspositionProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportIngressQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportIngressQueue = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportEgressQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportEgressQueue = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportIngressQueueIfTtlIsOne", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportIngressQueueIfTtlIsOne = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportEgressQueueIfTtlIsOne", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportEgressQueueIfTtlIsOne = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyAllPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyAllPackets = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFirstPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFirstPacket = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyWhenTcpFlagSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyWhenTcpFlagSet = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomActionPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CustomActionPresent = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaActionBeforeTransposition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetaActionBeforeTransposition = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			m.TableType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableType |= (GftTableType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranspositionProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TranspositionProfiles = append(m.TranspositionProfiles, &GftHeaderGroupTranspositionProfile{})
			if err := m.TranspositionProfiles[len(m.TranspositionProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderTranspositionProfileRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &GftHeaderTranspositionProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderTranspositionProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileHandle", wireType)
			}
			m.ProfileHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderTranspositionProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &GftHeaderTranspositionProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderTranspositionProfileResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderTranspositionProfileResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &GftHeaderTranspositionProfileResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapOrTransportMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapOrTransportMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapOrTransportMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UdpMatchFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportMatch_UdpFields{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpMatchFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportMatch_TcpFields{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IcmpMatchFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportMatch_IcmpFields{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EncapMatchFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportMatch_EncapFields{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderGroupExactMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderGroupExactMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderGroupExactMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &GftHeaders{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchFields == nil {
				m.MatchFields = &GftHeaderFields{}
			}
			if err := m.MatchFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EthFields == nil {
				m.EthFields = &GftEthFields{}
			}
			if err := m.EthFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIpAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIpAddr == nil {
				m.SrcIpAddr = &IPAddress{}
			}
			if err := m.SrcIpAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpAddr == nil {
				m.DstIpAddr = &IPAddress{}
			}
			if err := m.DstIpAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtl", wireType)
			}
			m.IpTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapOrTransport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncapOrTransport == nil {
				m.EncapOrTransport = &EncapOrTransportMatch{}
			}
			if err := m.EncapOrTransport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpTranspositionFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpTranspositionFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpTranspositionFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpTranspositionFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpTranspositionFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpTranspositionFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpTranspositionFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpTranspositionFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpTranspositionFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapTranspositionFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapTranspositionFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapTranspositionFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreProtocol", wireType)
			}
			m.GreProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GreProtocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapOrTransportTransposition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapOrTransportTransposition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapOrTransportTransposition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UdpTranspositionFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportTransposition_UdpFields{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpTranspositionFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportTransposition_TcpFields{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IcmpTranspositionFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportTransposition_IcmpFields{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EncapTranspositionFields{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EncapOrTransport = &EncapOrTransportTransposition_EncapFields{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftHeaderGroupTransposition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftHeaderGroupTransposition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftHeaderGroupTransposition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (GftHeaderGroupTranspostionAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &GftHeaders{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeaderFields == nil {
				m.HeaderFields = &GftHeaderFields{}
			}
			if err := m.HeaderFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EthFields == nil {
				m.EthFields = &GftEthFields{}
			}
			if err := m.EthFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIpAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIpAddr == nil {
				m.SrcIpAddr = &IPAddress{}
			}
			if err := m.SrcIpAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpAddr == nil {
				m.DstIpAddr = &IPAddress{}
			}
			if err := m.DstIpAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtl", wireType)
			}
			m.IpTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapOrTransport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncapOrTransport == nil {
				m.EncapOrTransport = &EncapOrTransportTransposition{}
			}
			if err := m.EncapOrTransport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchFlowEntrySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchFlowEntrySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchFlowEntrySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			m.TableType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableType |= (GftTableType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &GftExactMatchFlowEntryKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatchProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExactMatchProfile == nil {
				m.ExactMatchProfile = &GftExactMatchProfileKeyHandle{}
			}
			if err := m.ExactMatchProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranspositionProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TranspositionProfile == nil {
				m.TranspositionProfile = &GftHeaderTranspositionProfileKeyHandle{}
			}
			if err := m.TranspositionProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddInActivatedState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddInActivatedState = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdmaFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RdmaFlow = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportIngressQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportIngressQueue = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportEgressQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportEgressQueue = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportIngressQueueIfTtlIsOne", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportIngressQueueIfTtlIsOne = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToVportEgressQueueIfTtlIsOne", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedirectToVportEgressQueueIfTtlIsOne = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyAllPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyAllPackets = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFirstPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFirstPacket = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyWhenTcpFlagSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyWhenTcpFlagSet = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomActionPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CustomActionPresent = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaActionBeforeTransposition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetaActionBeforeTransposition = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyAfterTcpFinFlagSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyAfterTcpFinFlagSet = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyAfterTcpRstFlagSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyAfterTcpRstFlagSet = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VportId", wireType)
			}
			m.VportId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VportId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectVportId", wireType)
			}
			m.RedirectVportId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedirectVportId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlOneRedirectVportId", wireType)
			}
			m.TtlOneRedirectVportId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlOneRedirectVportId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactMatches = append(m.ExactMatches, &GftHeaderGroupExactMatch{})
			if err := m.ExactMatches[len(m.ExactMatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transpositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transpositions = append(m.Transpositions, &GftHeaderGroupTransposition{})
			if err := m.Transpositions[len(m.Transpositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchFlowEntryRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &GftExactMatchFlowEntrySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchFlowEntryStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowEntryHandle", wireType)
			}
			m.FlowEntryHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowEntryHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowIndex", wireType)
			}
			m.FlowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowInfoIndex", wireType)
			}
			m.FlowInfoIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowInfoIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchFlowEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &GftExactMatchFlowEntryStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GftExactMatchFlowEntryResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GftExactMatchFlowEntryResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &GftExactMatchFlowEntryResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGft   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gft.proto", fileDescriptorGft) }

var fileDescriptorGft = []byte{
	// 2494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xb7, 0xe4, 0x2f, 0xf9, 0xe9, 0xd3, 0xed, 0x8f, 0x28, 0x76, 0xfc, 0x35, 0x8e, 0x13, 0xe3,
	0xda, 0x4d, 0x2d, 0xde, 0xd4, 0x86, 0x2c, 0xd9, 0xda, 0x95, 0x6d, 0xd9, 0x56, 0x11, 0x5b, 0x62,
	0xac, 0x24, 0x24, 0x05, 0xf4, 0x8e, 0x67, 0x5a, 0xd6, 0x60, 0x79, 0x66, 0x76, 0xa6, 0xed, 0xc4,
	0x77, 0xa8, 0x82, 0x0b, 0x55, 0xdc, 0xb8, 0x71, 0xe0, 0x0f, 0xa0, 0xb8, 0x70, 0x05, 0x4e, 0x50,
	0x9c, 0xf8, 0x07, 0x48, 0x51, 0xe1, 0xc2, 0x39, 0x57, 0x0e, 0x50, 0xfd, 0x31, 0x23, 0xcd, 0x68,
	0x24, 0xcb, 0x9b, 0xb0, 0x27, 0x69, 0xde, 0xfb, 0xbd, 0xee, 0x37, 0xdd, 0xaf, 0x7f, 0xef, 0xbd,
	0x1e, 0x98, 0x38, 0x69, 0xd0, 0x7b, 0x8e, 0x6b, 0x53, 0x1b, 0x0d, 0x9f, 0x34, 0xe8, 0x5c, 0x9a,
	0x5e, 0x3a, 0xc4, 0x13, 0x92, 0xb9, 0xd4, 0x69, 0x53, 0xfc, 0x53, 0xfe, 0x91, 0x80, 0xcc, 0x5e,
	0x83, 0x96, 0x69, 0x73, 0xd7, 0x24, 0x2d, 0xc3, 0x43, 0xcb, 0x90, 0x31, 0x3c, 0x8a, 0xcf, 0x34,
	0x1d, 0x6b, 0x86, 0xe1, 0x16, 0x13, 0xcb, 0x89, 0xf5, 0x11, 0x15, 0x0c, 0x8f, 0x1e, 0x68, 0x7a,
	0xc9, 0x30, 0x5c, 0x86, 0xf0, 0x5c, 0xbd, 0x8d, 0x48, 0x0a, 0x84, 0xe7, 0xea, 0x3e, 0xe2, 0x26,
	0xa4, 0x08, 0x6d, 0x62, 0x36, 0x63, 0x71, 0x78, 0x39, 0xb1, 0x9e, 0x55, 0xc7, 0x09, 0x6d, 0xd6,
	0x2f, 0x1d, 0x82, 0xd6, 0xa1, 0xa0, 0x9f, 0x7b, 0xd4, 0x3e, 0x23, 0x2e, 0xbe, 0x68, 0x69, 0x16,
	0x36, 0x8d, 0xe2, 0x08, 0x87, 0xe4, 0x7c, 0xf9, 0xd3, 0x96, 0x66, 0x55, 0x0c, 0x86, 0x74, 0x5c,
	0xfb, 0xc2, 0x34, 0x3a, 0x90, 0xa3, 0x02, 0xe9, 0xcb, 0x25, 0x72, 0x0e, 0x52, 0x8e, 0x6b, 0xda,
	0xae, 0x49, 0x2f, 0x8b, 0x63, 0x1c, 0x11, 0x3c, 0x2b, 0xff, 0x4d, 0x02, 0xec, 0x35, 0xe8, 0x3e,
	0xd1, 0x0c, 0xe2, 0x7a, 0xe8, 0x2e, 0xe4, 0x09, 0x6d, 0x12, 0xd7, 0x22, 0x14, 0x37, 0xb9, 0x8c,
	0xbf, 0x60, 0x4a, 0xcd, 0xf9, 0x62, 0x81, 0x44, 0x4b, 0x90, 0x36, 0x9d, 0x8b, 0xfb, 0x3e, 0x28,
	0xc9, 0x41, 0xc0, 0x44, 0x21, 0xc0, 0x27, 0x3e, 0x60, 0x38, 0x00, 0x7c, 0x22, 0x01, 0x0b, 0x00,
	0x54, 0x77, 0x7c, 0xfd, 0x08, 0xd7, 0x4f, 0x50, 0xdd, 0x69, 0xab, 0xcf, 0x8d, 0x40, 0x3d, 0x2a,
	0xd4, 0xe7, 0x86, 0xd3, 0x31, 0xbc, 0x7e, 0x16, 0xe8, 0xc7, 0xe4, 0xf0, 0xfa, 0x99, 0x0f, 0xb8,
	0x09, 0x29, 0xcb, 0xc6, 0xc4, 0xd2, 0x35, 0xa7, 0x38, 0xce, 0xb5, 0xe3, 0x96, 0x5d, 0x66, 0x8f,
	0x68, 0x15, 0x72, 0xa6, 0x83, 0x4d, 0x0b, 0x9b, 0x8e, 0x04, 0xa4, 0x38, 0x20, 0x6d, 0x3a, 0x15,
	0xab, 0xe2, 0x08, 0xd0, 0x1a, 0xe4, 0x05, 0xe8, 0xc4, 0x25, 0x12, 0x35, 0xc1, 0x51, 0x19, 0x86,
	0xda, 0x73, 0x89, 0x80, 0x2d, 0x41, 0xda, 0xba, 0x68, 0x43, 0x40, 0xf8, 0xc1, 0x45, 0x01, 0xe0,
	0xe2, 0x15, 0xdb, 0x1e, 0x01, 0x48, 0x0b, 0x00, 0x17, 0x71, 0x80, 0xf2, 0xf3, 0x51, 0xc8, 0x07,
	0x3b, 0xd0, 0x27, 0xc8, 0x52, 0x57, 0x06, 0x59, 0xaa, 0x6f, 0x90, 0xa5, 0xae, 0x0e, 0xb2, 0xd4,
	0xc0, 0x41, 0x96, 0xea, 0x0a, 0xb2, 0x35, 0xc8, 0x19, 0x36, 0xfd, 0xb6, 0x83, 0x43, 0xa1, 0x96,
	0x52, 0xb3, 0x5c, 0x5a, 0x93, 0x42, 0xb4, 0x08, 0x69, 0xe6, 0xb7, 0xe9, 0x08, 0xb7, 0xc5, 0xce,
	0x4c, 0x78, 0xae, 0x5e, 0x71, 0xb8, 0xd7, 0x8b, 0x90, 0x66, 0x6f, 0xee, 0xeb, 0xc5, 0xc6, 0x4c,
	0x18, 0x1e, 0x95, 0xfa, 0x19, 0x18, 0x33, 0x1d, 0x4c, 0x69, 0x4b, 0xee, 0xc6, 0xa8, 0xe9, 0xd4,
	0x69, 0x4b, 0x44, 0x1b, 0xe6, 0x47, 0x56, 0xb7, 0x5b, 0xfe, 0x36, 0x98, 0x4e, 0x4d, 0x4a, 0xd0,
	0x0d, 0x18, 0x37, 0x1d, 0x6c, 0x78, 0xba, 0xbf, 0x05, 0x63, 0xa6, 0xb3, 0xe3, 0xe9, 0x0e, 0x5b,
	0x26, 0xe6, 0x90, 0x63, 0xbb, 0xb4, 0x98, 0x11, 0xcb, 0xe4, 0xb9, 0x7a, 0xcd, 0x76, 0x29, 0x53,
	0x31, 0x5f, 0xb8, 0x2a, 0x2b, 0x54, 0x86, 0x47, 0xb9, 0x6a, 0x1e, 0x58, 0xa8, 0xe2, 0x46, 0x4b,
	0x3b, 0xf1, 0x8a, 0x39, 0xae, 0x4b, 0x51, 0xdd, 0xd9, 0x65, 0xcf, 0x5c, 0x49, 0x2c, 0xcd, 0xa2,
	0x6c, 0xb5, 0xf2, 0x52, 0xc9, 0x05, 0x15, 0x83, 0x29, 0x79, 0xe0, 0xf2, 0x7d, 0x29, 0x08, 0x25,
	0x13, 0xf0, 0x8d, 0xf1, 0x95, 0xba, 0x6d, 0x90, 0xe2, 0x64, 0x5b, 0xb9, 0x6d, 0x1b, 0x84, 0xb9,
	0x63, 0xdb, 0xc7, 0x7c, 0x1b, 0x8a, 0x48, 0xb8, 0x63, 0xdb, 0xc7, 0x6c, 0xf9, 0x91, 0x02, 0x59,
	0xa6, 0x6a, 0xcf, 0x3a, 0x25, 0x02, 0xda, 0xb6, 0x8f, 0xeb, 0xfe, 0xc4, 0x2b, 0x90, 0x61, 0x71,
	0x1a, 0xac, 0xd1, 0xb4, 0x80, 0x9c, 0xb8, 0xc4, 0x5f, 0x24, 0xe5, 0x67, 0x09, 0x58, 0x0a, 0x42,
	0x71, 0xcf, 0xb5, 0xcf, 0x9d, 0xf2, 0x2b, 0x4d, 0xa7, 0x07, 0x1a, 0xd5, 0x9b, 0x35, 0xd7, 0x6e,
	0x98, 0x2d, 0x82, 0xbe, 0x05, 0xe3, 0xe2, 0xcc, 0x79, 0x3c, 0x2a, 0xd3, 0x9b, 0xf9, 0x7b, 0x8c,
	0x49, 0xdb, 0x1c, 0xa2, 0xfa, 0x7a, 0xf4, 0x00, 0x32, 0x67, 0xcc, 0x14, 0x37, 0x78, 0x54, 0xf3,
	0x18, 0x4d, 0x6f, 0x4e, 0x87, 0xf1, 0x22, 0xe2, 0xd5, 0x34, 0x47, 0x8a, 0x07, 0xe5, 0xcf, 0x49,
	0x28, 0x32, 0xd2, 0x8d, 0x4e, 0x7e, 0xe4, 0x10, 0x1d, 0xad, 0xc1, 0xc8, 0x19, 0xa1, 0x9a, 0x9c,
	0x7d, 0xf2, 0x9e, 0xe0, 0xed, 0xea, 0xf1, 0x4f, 0x88, 0x4e, 0x0f, 0x08, 0xd5, 0x54, 0xae, 0x46,
	0xcf, 0x20, 0x7b, 0x4a, 0x2e, 0xb1, 0xed, 0xe2, 0xa6, 0x66, 0x19, 0x2d, 0x22, 0x67, 0x5f, 0xb9,
	0x77, 0xda, 0xbc, 0x17, 0x37, 0xf6, 0xf7, 0xc8, 0xe5, 0x3e, 0x07, 0x6e, 0x15, 0xde, 0xbe, 0x5e,
	0xca, 0x5c, 0x10, 0xcb, 0xd4, 0xc9, 0xa7, 0xca, 0x29, 0xb9, 0x54, 0xd4, 0xf4, 0x29, 0xb9, 0xac,
	0xba, 0x42, 0xcd, 0xf6, 0xc8, 0x35, 0xce, 0x34, 0xdc, 0x68, 0xd9, 0x2f, 0xe5, 0xc1, 0x4a, 0x31,
	0xc1, 0x6e, 0xcb, 0x7e, 0x89, 0x3e, 0x02, 0xa0, 0xda, 0x71, 0x8b, 0x88, 0xed, 0x65, 0x67, 0x2a,
	0xb7, 0x39, 0xe9, 0xbf, 0x70, 0x9d, 0x69, 0xd8, 0x3e, 0xab, 0x13, 0xd4, 0xff, 0x8b, 0x9e, 0xc2,
	0x34, 0x61, 0xbe, 0x60, 0xb1, 0x54, 0x8e, 0xf0, 0xc6, 0x2b, 0x8e, 0x2e, 0x0f, 0xaf, 0xa7, 0x37,
	0x6f, 0x87, 0x17, 0x2b, 0x7e, 0x4f, 0x54, 0x44, 0xa2, 0x22, 0x4f, 0x79, 0x0e, 0x8b, 0x71, 0xaf,
	0xa9, 0x92, 0xaf, 0xce, 0x89, 0x47, 0x0f, 0xbc, 0x13, 0xf4, 0x00, 0xc6, 0x5d, 0xf1, 0x54, 0x4c,
	0xf0, 0xc9, 0x16, 0xfc, 0xc9, 0x62, 0x17, 0x5e, 0xf5, 0xd1, 0xca, 0x36, 0xcc, 0xc5, 0x82, 0xa8,
	0x46, 0xcf, 0x3d, 0x46, 0x04, 0xf2, 0x25, 0xfc, 0x95, 0x67, 0x3b, 0x35, 0xa6, 0x66, 0xa5, 0x54,
	0x2c, 0xa3, 0xf2, 0x9b, 0x04, 0xdc, 0x8a, 0x77, 0xd0, 0x73, 0x6c, 0xcb, 0x23, 0x68, 0x17, 0x40,
	0x73, 0x4c, 0xec, 0xf1, 0x51, 0xf9, 0x18, 0xb9, 0xcd, 0x82, 0xdc, 0xed, 0x92, 0x63, 0x8a, 0xd9,
	0xb6, 0x66, 0xde, 0xbe, 0x5e, 0x9a, 0x94, 0x9b, 0xd5, 0x86, 0xab, 0x13, 0x9a, 0x8f, 0x40, 0x0f,
	0x60, 0x4c, 0x8e, 0x21, 0x22, 0x60, 0xa9, 0xf7, 0x5b, 0x0a, 0x5b, 0x09, 0x57, 0xbe, 0xe4, 0x87,
	0xa1, 0xa7, 0x83, 0x6c, 0x09, 0x3f, 0x83, 0x94, 0x2b, 0x1f, 0xe5, 0x1a, 0xae, 0xf4, 0x1c, 0xdd,
	0xb7, 0x53, 0x03, 0x13, 0xe5, 0x11, 0xe4, 0x9e, 0x18, 0xce, 0x41, 0x3b, 0xf2, 0xd1, 0x34, 0x8c,
	0x7a, 0x9c, 0x6f, 0x12, 0x3c, 0x4f, 0x8b, 0x07, 0x26, 0x35, 0xb8, 0x34, 0x29, 0xa4, 0xfc, 0x41,
	0x79, 0x0e, 0xb9, 0xba, 0xfe, 0x75, 0xad, 0xc3, 0x0c, 0x26, 0x8a, 0x90, 0x80, 0xc1, 0x94, 0x87,
	0x90, 0xaf, 0xe8, 0x67, 0xa1, 0xb1, 0x11, 0x8c, 0xf0, 0x98, 0x16, 0x43, 0xf3, 0xff, 0x4c, 0xc6,
	0x99, 0x4a, 0x0c, 0xcc, 0xff, 0x2b, 0x2a, 0x14, 0x78, 0x5e, 0xeb, 0xb4, 0x0d, 0x11, 0x62, 0x42,
	0xce, 0xd5, 0x8b, 0x97, 0xc4, 0x60, 0x21, 0x5e, 0xfa, 0x4b, 0x02, 0x94, 0xf0, 0x19, 0xa8, 0xbb,
	0x9a, 0xe5, 0x39, 0xb6, 0x67, 0x52, 0xd3, 0xb6, 0x7c, 0x6a, 0xfa, 0x0c, 0xc6, 0x34, 0x9d, 0x09,
	0x64, 0xb4, 0xac, 0xc5, 0x1c, 0x1e, 0xdf, 0x90, 0xc1, 0x4a, 0x1c, 0xac, 0x4a, 0xa3, 0x4e, 0x66,
	0x4b, 0x5e, 0x93, 0xd9, 0x86, 0x07, 0x65, 0xb6, 0x5f, 0x8c, 0xc3, 0x4a, 0x00, 0x88, 0x7b, 0x89,
	0xeb, 0x50, 0xdc, 0x97, 0xf1, 0x14, 0xb7, 0x21, 0x29, 0xae, 0xf7, 0x24, 0x03, 0x73, 0xdd, 0x0e,
	0x2c, 0xb9, 0xc4, 0x30, 0x5d, 0xa2, 0x53, 0x4c, 0x6d, 0x7c, 0xc1, 0x22, 0x07, 0x9b, 0xd6, 0x89,
	0x4b, 0x3c, 0x0f, 0x7f, 0x75, 0x4e, 0xce, 0xfd, 0xd2, 0x62, 0xde, 0x87, 0xd5, 0xed, 0xa7, 0x0c,
	0x54, 0x11, 0x98, 0xef, 0x33, 0x08, 0xda, 0x82, 0xc5, 0xee, 0x51, 0x48, 0xe7, 0x20, 0xa2, 0xf8,
	0x98, 0x8b, 0x0c, 0x52, 0xee, 0x18, 0xe3, 0x87, 0xf0, 0xe1, 0x15, 0x9e, 0x60, 0xb3, 0xc1, 0xea,
	0x02, 0x6c, 0x7a, 0xd8, 0xb6, 0x88, 0xac, 0x52, 0xd6, 0xfa, 0xf8, 0x55, 0x69, 0xd4, 0x69, 0xab,
	0xe2, 0x55, 0x2d, 0x82, 0x5e, 0xc0, 0x07, 0xfd, 0x3d, 0x8c, 0x0c, 0x2e, 0x4a, 0x9b, 0xdb, 0xbd,
	0xfd, 0xed, 0x18, 0x9b, 0x15, 0x5b, 0xb6, 0x73, 0x89, 0xb5, 0x56, 0x0b, 0x3b, 0x9a, 0x7e, 0x4a,
	0xa8, 0x27, 0xcb, 0x9e, 0x1c, 0x93, 0x97, 0x5a, 0xad, 0x9a, 0x90, 0xa2, 0x0d, 0x98, 0xe4, 0xc8,
	0x86, 0xe9, 0xb2, 0xb2, 0x83, 0x4b, 0x65, 0x05, 0x94, 0x67, 0x8a, 0x5d, 0x26, 0x17, 0x60, 0xb4,
	0x09, 0xb3, 0x1c, 0xfb, 0xb2, 0x49, 0x2c, 0xec, 0x1f, 0x64, 0xec, 0x11, 0x2a, 0xeb, 0x22, 0xc4,
	0xb4, 0xcf, 0x9a, 0xc4, 0xaa, 0x8b, 0x33, 0x7d, 0xc4, 0x6d, 0x66, 0x44, 0x79, 0x87, 0x45, 0xc4,
	0x63, 0xc7, 0x25, 0x1e, 0xb1, 0xa8, 0x2c, 0x97, 0xa6, 0x84, 0x52, 0x9c, 0x8a, 0x9a, 0x50, 0xa1,
	0x3d, 0x58, 0x66, 0xb1, 0xe6, 0x5b, 0x1c, 0x93, 0x86, 0xed, 0x12, 0x4c, 0x3b, 0x83, 0x4a, 0x16,
	0x54, 0x0b, 0x0c, 0x27, 0x8c, 0xb7, 0x38, 0x2a, 0x14, 0x79, 0x91, 0xcc, 0x98, 0x19, 0x20, 0x33,
	0xfe, 0x18, 0x66, 0x43, 0xf3, 0xb4, 0x73, 0x63, 0x96, 0x53, 0xed, 0xdd, 0x3e, 0xc7, 0xbb, 0x33,
	0xda, 0xd5, 0x19, 0x1a, 0x23, 0xf5, 0x94, 0x53, 0xb8, 0xdb, 0xf7, 0x94, 0x74, 0xa4, 0xca, 0x2f,
	0xa2, 0xa9, 0xf2, 0x4e, 0x78, 0xee, 0x5e, 0x27, 0xb9, 0x9d, 0x33, 0x1f, 0xc3, 0x6a, 0x7f, 0xf4,
	0xb5, 0x92, 0xe7, 0xef, 0x13, 0xb0, 0x76, 0x85, 0xef, 0xef, 0x39, 0x8b, 0x7e, 0x11, 0xc9, 0xa2,
	0xeb, 0x03, 0x2c, 0x40, 0x38, 0x9d, 0xba, 0xb0, 0x3e, 0x90, 0xcb, 0x6c, 0xbd, 0x77, 0xbb, 0xf2,
	0xea, 0xc6, 0xd5, 0xf3, 0xc5, 0x24, 0xd8, 0x5f, 0x26, 0x61, 0x86, 0x67, 0xa3, 0xaa, 0x6f, 0xe1,
	0x8a, 0x9c, 0x8c, 0xee, 0x8b, 0xf6, 0x52, 0xf2, 0xb7, 0x20, 0xda, 0x29, 0x3e, 0x47, 0x38, 0x23,
	0xef, 0x0f, 0xf1, 0xae, 0x53, 0x26, 0xb2, 0xfb, 0xa2, 0x67, 0x0d, 0xd5, 0xb3, 0xc2, 0x2a, 0x9c,
	0x89, 0x99, 0x15, 0x4b, 0xa6, 0xc2, 0xea, 0x81, 0xec, 0x55, 0x63, 0x92, 0x45, 0x24, 0xcb, 0xee,
	0x0f, 0x89, 0x1e, 0x56, 0x1a, 0x7e, 0x0a, 0x19, 0xde, 0x35, 0xfa, 0x96, 0x23, 0xdc, 0x72, 0x86,
	0x5b, 0x46, 0x93, 0xec, 0xfe, 0x90, 0x9a, 0xe6, 0x60, 0xf1, 0xb8, 0x35, 0x0d, 0x48, 0xd8, 0xda,
	0xae, 0x7f, 0x5c, 0x5d, 0xaa, 0xfc, 0x6e, 0x98, 0x57, 0xd6, 0xb1, 0xd5, 0xe4, 0x37, 0x51, 0xda,
	0x33, 0x1a, 0x60, 0x5d, 0x69, 0x68, 0x29, 0x02, 0x1a, 0x08, 0x6e, 0x59, 0xd4, 0x09, 0x42, 0xdb,
	0x16, 0xa1, 0x8e, 0x51, 0xac, 0x81, 0x1f, 0xc2, 0x95, 0x1a, 0xeb, 0x0a, 0x89, 0xe7, 0x75, 0xf6,
	0x90, 0x1f, 0x85, 0x7b, 0xc8, 0xd1, 0x5e, 0x16, 0x71, 0x5d, 0xa5, 0xb8, 0x1f, 0x91, 0x5d, 0x65,
	0x47, 0xd3, 0x38, 0xce, 0xe5, 0x7e, 0xd3, 0x18, 0x69, 0x37, 0x53, 0x5c, 0xd9, 0xd9, 0x6e, 0xee,
	0xc7, 0xad, 0x3e, 0xa7, 0xe6, 0xf4, 0xe6, 0x5c, 0x7b, 0xff, 0xa2, 0x61, 0xa9, 0x16, 0x48, 0x44,
	0xac, 0xec, 0xc0, 0xec, 0x13, 0x23, 0xcc, 0x6b, 0x5f, 0xa3, 0x56, 0xdc, 0x81, 0xd9, 0xba, 0xfe,
	0xce, 0xa3, 0x94, 0xe0, 0x06, 0x0b, 0xd8, 0xb8, 0x61, 0x06, 0x2d, 0x0f, 0x5f, 0x40, 0x91, 0xbf,
	0x79, 0xdc, 0x18, 0xef, 0x5a, 0x26, 0xfe, 0x21, 0x09, 0x0b, 0xd1, 0x65, 0x0d, 0x27, 0xa1, 0x47,
	0x31, 0xa7, 0x7e, 0xde, 0x3f, 0xf5, 0x31, 0x2e, 0x85, 0x4f, 0xff, 0xa3, 0x98, 0xd3, 0x3f, 0xef,
	0x9f, 0xfe, 0x1e, 0xd6, 0x6d, 0x16, 0xf8, 0x3c, 0x8e, 0x05, 0x6e, 0x05, 0x2c, 0x10, 0x6f, 0xdf,
	0xc9, 0x06, 0x5b, 0xb1, 0x6c, 0xb0, 0xd0, 0x8e, 0xa6, 0xf8, 0x21, 0x06, 0x60, 0x85, 0xff, 0x0c,
	0xc3, 0x7c, 0x9f, 0x3c, 0xfa, 0x0d, 0x16, 0xd6, 0x0f, 0x21, 0x2b, 0xfe, 0x0e, 0x52, 0x59, 0x67,
	0x9a, 0x9d, 0x77, 0x66, 0x61, 0x66, 0x19, 0xb9, 0x3e, 0xb3, 0x8c, 0x5e, 0x9b, 0x59, 0xc6, 0xae,
	0xc3, 0x2c, 0xe3, 0x3d, 0x98, 0x25, 0xd5, 0x8f, 0x59, 0x26, 0xba, 0x98, 0xa5, 0x16, 0xcb, 0x2c,
	0xc0, 0x3d, 0x51, 0x62, 0x99, 0x25, 0xb4, 0x97, 0x31, 0x0c, 0xf3, 0xb7, 0x74, 0xa4, 0x9f, 0xdf,
	0x6d, 0xd9, 0x2f, 0xcb, 0x16, 0x75, 0x2f, 0xaf, 0xd3, 0x8c, 0x84, 0xeb, 0xbb, 0xe4, 0x00, 0xf5,
	0xdd, 0xf3, 0x68, 0xfb, 0x22, 0xf6, 0x7a, 0xb5, 0xeb, 0x86, 0x26, 0xf0, 0x67, 0xe0, 0xbe, 0x45,
	0x83, 0xa9, 0x98, 0x4b, 0x15, 0x19, 0x14, 0x03, 0x5c, 0x01, 0xe5, 0xde, 0xbe, 0x5e, 0x02, 0x39,
	0xbc, 0x4b, 0x1a, 0xea, 0x64, 0xd7, 0x05, 0x0b, 0xb2, 0x61, 0x26, 0xb6, 0x3a, 0x95, 0x61, 0x74,
	0x9d, 0x26, 0x2c, 0x3a, 0xdb, 0x74, 0x5c, 0xbd, 0x8a, 0x3e, 0x86, 0x59, 0xcd, 0x30, 0xb0, 0x69,
	0xf1, 0x5a, 0xfc, 0x42, 0xa3, 0xc4, 0xe0, 0x75, 0x9a, 0xdf, 0x8d, 0x4c, 0x69, 0x86, 0x51, 0xe1,
	0x47, 0x8f, 0xeb, 0x58, 0xf5, 0x15, 0xb9, 0xac, 0x1a, 0x8f, 0x5c, 0x56, 0x0d, 0xd0, 0xdd, 0xa5,
	0xde, 0x47, 0x77, 0x37, 0xf1, 0xfe, 0xbb, 0x3b, 0xf8, 0x7f, 0x76, 0x77, 0xe9, 0x77, 0xec, 0xee,
	0x32, 0x83, 0x77, 0x77, 0xd9, 0xeb, 0x76, 0x77, 0xb9, 0xeb, 0x77, 0x77, 0xf9, 0x77, 0xeb, 0xee,
	0x0a, 0x83, 0x74, 0x77, 0xdf, 0x85, 0x79, 0xb1, 0x0c, 0x0d, 0x4a, 0x5c, 0xe1, 0xb1, 0x69, 0xb5,
	0xbd, 0x16, 0x57, 0xd9, 0xfc, 0x9d, 0x4a, 0x0c, 0xc1, 0xdc, 0x36, 0x2d, 0xdf, 0xf3, 0x6e, 0x63,
	0xb6, 0x42, 0x81, 0x31, 0xea, 0x36, 0x56, 0x3d, 0xea, 0x1b, 0xdf, 0x84, 0x94, 0x0c, 0x17, 0x71,
	0xeb, 0x9d, 0x55, 0xc7, 0xf9, 0x73, 0xc5, 0x60, 0x2b, 0x1e, 0xec, 0x7b, 0x80, 0x99, 0xe6, 0x98,
	0xbc, 0xaf, 0x78, 0x2a, 0xb1, 0xdf, 0x81, 0x9b, 0x2c, 0x02, 0x6c, 0x8b, 0xe0, 0x6e, 0x9b, 0x19,
	0x6e, 0x33, 0x43, 0x69, 0xab, 0x6a, 0x11, 0x35, 0x62, 0xb9, 0x05, 0xd9, 0x0e, 0xae, 0x21, 0x5e,
	0x71, 0x36, 0x7c, 0x99, 0x1a, 0x5b, 0x6b, 0xab, 0x99, 0x36, 0xa3, 0x10, 0x0f, 0xed, 0x43, 0x2e,
	0xb4, 0xe8, 0x5e, 0xf1, 0x06, 0x1f, 0x64, 0xf9, 0xaa, 0x16, 0x57, 0x8d, 0xd8, 0x29, 0x3f, 0x82,
	0xe5, 0x78, 0xee, 0xec, 0xe8, 0x66, 0x1f, 0x46, 0xbb, 0xd9, 0x98, 0x2b, 0xd1, 0x50, 0x0e, 0x68,
	0xb7, 0xb1, 0xbf, 0x8a, 0xde, 0xda, 0xb6, 0x71, 0xa2, 0x4f, 0xdc, 0x80, 0x49, 0xc6, 0x35, 0x98,
	0x30, 0x59, 0xb8, 0x87, 0xcd, 0x37, 0x7c, 0xac, 0x64, 0xe9, 0x05, 0x00, 0x8e, 0x35, 0x2d, 0x83,
	0xbc, 0x92, 0x9f, 0x49, 0x27, 0x98, 0xa4, 0xc2, 0x04, 0xe8, 0x0e, 0xe4, 0xa5, 0xba, 0x61, 0x4b,
	0xcc, 0x30, 0xc7, 0x64, 0x05, 0xa6, 0x61, 0x73, 0x9c, 0xf2, 0xdb, 0x44, 0xe4, 0xaa, 0xbb, 0xe3,
	0x9d, 0xdf, 0x73, 0x17, 0xfc, 0x30, 0xd2, 0x05, 0xaf, 0xf4, 0x5b, 0xb8, 0x70, 0xfb, 0x6b, 0xf0,
	0x8b, 0xbf, 0x3e, 0x4e, 0xb2, 0x9d, 0xf9, 0xbc, 0xab, 0xef, 0x5d, 0xed, 0x33, 0x43, 0x77, 0xc3,
	0xbb, 0xf1, 0x47, 0xf1, 0xb9, 0x3a, 0xc8, 0xb7, 0xe8, 0x06, 0x4c, 0xed, 0xed, 0xd6, 0x71, 0xbd,
	0xb4, 0xf5, 0xb8, 0x8c, 0xeb, 0xcf, 0x6b, 0x65, 0x7c, 0x58, 0x3d, 0x2c, 0x17, 0x86, 0xd0, 0x2a,
	0x2c, 0x45, 0x14, 0xcf, 0x2a, 0x8f, 0x77, 0xb6, 0x4b, 0xea, 0x0e, 0xae, 0x1c, 0xee, 0xa9, 0xe5,
	0xa3, 0xa3, 0x42, 0x02, 0x29, 0xb0, 0xd8, 0x0b, 0x54, 0x16, 0x98, 0x24, 0xba, 0x03, 0x4a, 0x04,
	0x53, 0xfe, 0x41, 0x69, 0xbb, 0x8e, 0x0f, 0x4a, 0xf5, 0xed, 0xfd, 0x60, 0xac, 0x61, 0xb4, 0x06,
	0x2b, 0x7d, 0x70, 0x72, 0xb8, 0x91, 0x8d, 0x3f, 0x25, 0x78, 0x04, 0xf7, 0xad, 0x2c, 0xd1, 0x02,
	0xdc, 0xac, 0xab, 0xa5, 0xc3, 0xa3, 0x5a, 0xf5, 0xa8, 0x52, 0xaf, 0x54, 0x0f, 0x71, 0x69, 0x9b,
	0xff, 0xc8, 0x77, 0x5b, 0x82, 0xf9, 0x58, 0xf5, 0x41, 0x75, 0xa7, 0xb2, 0xfb, 0xbc, 0x90, 0xe8,
	0x09, 0xa8, 0xec, 0x1d, 0x56, 0xd5, 0x72, 0x21, 0xd9, 0x73, 0x82, 0xda, 0x93, 0xa3, 0xfd, 0xc2,
	0x30, 0xba, 0x05, 0xc5, 0x78, 0x75, 0xb5, 0x56, 0x18, 0xd9, 0xfc, 0x77, 0x12, 0x86, 0xf7, 0x1a,
	0x14, 0x99, 0xf1, 0xdf, 0x49, 0xb6, 0x5d, 0xc2, 0x52, 0xf3, 0x6a, 0x9f, 0x2f, 0x05, 0xfe, 0x51,
	0x9d, 0xbb, 0x7d, 0xe5, 0xe7, 0x84, 0x03, 0xef, 0x44, 0x19, 0x42, 0x3f, 0x4d, 0x5c, 0x71, 0xbf,
	0x24, 0x27, 0xfd, 0x60, 0x90, 0x6b, 0x94, 0x60, 0xf6, 0x0f, 0x07, 0xbf, 0x74, 0x11, 0x6e, 0xd8,
	0xbd, 0xd8, 0x41, 0x4e, 0xbf, 0xd6, 0x37, 0x9a, 0x83, 0x79, 0xef, 0x0c, 0x10, 0xf4, 0x7c, 0xc2,
	0xad, 0xb9, 0xbf, 0xbe, 0x59, 0x4c, 0xfc, 0xfd, 0xcd, 0x62, 0xe2, 0x9f, 0x6f, 0x16, 0x13, 0xbf,
	0xfe, 0xd7, 0xe2, 0xd0, 0x8b, 0x54, 0x53, 0x6b, 0xf1, 0xf2, 0xf9, 0x78, 0x8c, 0xff, 0x7c, 0xfc,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdb, 0x6f, 0xfe, 0x55, 0xea, 0x21, 0x00, 0x00,
}
