// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipsec.proto.draft

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// IPSec protocols
type IpsecProtocol int32

const (
	IpsecProtocol_IPSEC_PROTOCOL_NONE IpsecProtocol = 0
	IpsecProtocol_IPSEC_PROTOCOL_AH   IpsecProtocol = 1
	IpsecProtocol_IPSEC_PROTOCOL_ESP  IpsecProtocol = 2
)

var IpsecProtocol_name = map[int32]string{
	0: "IPSEC_PROTOCOL_NONE",
	1: "IPSEC_PROTOCOL_AH",
	2: "IPSEC_PROTOCOL_ESP",
}
var IpsecProtocol_value = map[string]int32{
	"IPSEC_PROTOCOL_NONE": 0,
	"IPSEC_PROTOCOL_AH":   1,
	"IPSEC_PROTOCOL_ESP":  2,
}

func (x IpsecProtocol) String() string {
	return proto.EnumName(IpsecProtocol_name, int32(x))
}
func (IpsecProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{0} }

// Encryption algorithms
type EncryptionAlgorithm int32

const (
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE        EncryptionAlgorithm = 0
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_GCM_128 EncryptionAlgorithm = 1
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_GCM_256 EncryptionAlgorithm = 2
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_128 EncryptionAlgorithm = 3
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_192 EncryptionAlgorithm = 4
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_256 EncryptionAlgorithm = 5
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_128 EncryptionAlgorithm = 6
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_192 EncryptionAlgorithm = 7
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_256 EncryptionAlgorithm = 8
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_DES3        EncryptionAlgorithm = 9
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_CHA_CHA     EncryptionAlgorithm = 10
)

var EncryptionAlgorithm_name = map[int32]string{
	0:  "ENCRYPTION_ALGORITHM_NONE",
	1:  "ENCRYPTION_ALGORITHM_AES_GCM_128",
	2:  "ENCRYPTION_ALGORITHM_AES_GCM_256",
	3:  "ENCRYPTION_ALGORITHM_AES_CCM_128",
	4:  "ENCRYPTION_ALGORITHM_AES_CCM_192",
	5:  "ENCRYPTION_ALGORITHM_AES_CCM_256",
	6:  "ENCRYPTION_ALGORITHM_AES_CBC_128",
	7:  "ENCRYPTION_ALGORITHM_AES_CBC_192",
	8:  "ENCRYPTION_ALGORITHM_AES_CBC_256",
	9:  "ENCRYPTION_ALGORITHM_DES3",
	10: "ENCRYPTION_ALGORITHM_CHA_CHA",
}
var EncryptionAlgorithm_value = map[string]int32{
	"ENCRYPTION_ALGORITHM_NONE":        0,
	"ENCRYPTION_ALGORITHM_AES_GCM_128": 1,
	"ENCRYPTION_ALGORITHM_AES_GCM_256": 2,
	"ENCRYPTION_ALGORITHM_AES_CCM_128": 3,
	"ENCRYPTION_ALGORITHM_AES_CCM_192": 4,
	"ENCRYPTION_ALGORITHM_AES_CCM_256": 5,
	"ENCRYPTION_ALGORITHM_AES_CBC_128": 6,
	"ENCRYPTION_ALGORITHM_AES_CBC_192": 7,
	"ENCRYPTION_ALGORITHM_AES_CBC_256": 8,
	"ENCRYPTION_ALGORITHM_DES3":        9,
	"ENCRYPTION_ALGORITHM_CHA_CHA":     10,
}

func (x EncryptionAlgorithm) String() string {
	return proto.EnumName(EncryptionAlgorithm_name, int32(x))
}
func (EncryptionAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{1} }

// Authentication algorithms
type AuthenticationAlgorithm int32

const (
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE AuthenticationAlgorithm = 0
	AuthenticationAlgorithm_AUTHENTICATION_AES_GCM        AuthenticationAlgorithm = 1
	AuthenticationAlgorithm_AUTHENTICATION_AES_CCM        AuthenticationAlgorithm = 2
	AuthenticationAlgorithm_AUTHENTICATION_HMAC           AuthenticationAlgorithm = 3
	AuthenticationAlgorithm_AUTHENTICATION_AES_CBC_SHA    AuthenticationAlgorithm = 4
)

var AuthenticationAlgorithm_name = map[int32]string{
	0: "AUTHENTICATION_ALGORITHM_NONE",
	1: "AUTHENTICATION_AES_GCM",
	2: "AUTHENTICATION_AES_CCM",
	3: "AUTHENTICATION_HMAC",
	4: "AUTHENTICATION_AES_CBC_SHA",
}
var AuthenticationAlgorithm_value = map[string]int32{
	"AUTHENTICATION_ALGORITHM_NONE": 0,
	"AUTHENTICATION_AES_GCM":        1,
	"AUTHENTICATION_AES_CCM":        2,
	"AUTHENTICATION_HMAC":           3,
	"AUTHENTICATION_AES_CBC_SHA":    4,
}

func (x AuthenticationAlgorithm) String() string {
	return proto.EnumName(AuthenticationAlgorithm_name, int32(x))
}
func (AuthenticationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{2}
}

// Key object
type Key struct {
	// Types that are valid to be assigned to KeyInfo:
	//	*Key_Key
	//	*Key_KeyLocation
	KeyInfo isKey_KeyInfo `protobuf_oneof:"key_info"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{0} }

type isKey_KeyInfo interface {
	isKey_KeyInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Key_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type Key_KeyLocation struct {
	KeyLocation uint32 `protobuf:"varint,2,opt,name=key_location,json=keyLocation,proto3,oneof"`
}

func (*Key_Key) isKey_KeyInfo()         {}
func (*Key_KeyLocation) isKey_KeyInfo() {}

func (m *Key) GetKeyInfo() isKey_KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *Key) GetKey() []byte {
	if x, ok := m.GetKeyInfo().(*Key_Key); ok {
		return x.Key
	}
	return nil
}

func (m *Key) GetKeyLocation() uint32 {
	if x, ok := m.GetKeyInfo().(*Key_KeyLocation); ok {
		return x.KeyLocation
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Key) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Key_OneofMarshaler, _Key_OneofUnmarshaler, _Key_OneofSizer, []interface{}{
		(*Key_Key)(nil),
		(*Key_KeyLocation)(nil),
	}
}

func _Key_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Key)
	// key_info
	switch x := m.KeyInfo.(type) {
	case *Key_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *Key_KeyLocation:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.KeyLocation))
	case nil:
	default:
		return fmt.Errorf("Key.KeyInfo has unexpected type %T", x)
	}
	return nil
}

func _Key_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Key)
	switch tag {
	case 1: // key_info.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyInfo = &Key_Key{x}
		return true, err
	case 2: // key_info.key_location
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyInfo = &Key_KeyLocation{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Key_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Key)
	// key_info
	switch x := m.KeyInfo.(type) {
	case *Key_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *Key_KeyLocation:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.KeyLocation))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IPSec security association object
type IpsecSAEncrypt struct {
	Meta                    *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle             *IpsecSAEncryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Protocol                IpsecProtocol            `protobuf:"varint,3,opt,name=protocol,proto3,enum=ipsec.IpsecProtocol" json:"protocol,omitempty"`
	AuthenticationAlgorithm AuthenticationAlgorithm  `protobuf:"varint,4,opt,name=authentication_algorithm,json=authenticationAlgorithm,proto3,enum=ipsec.AuthenticationAlgorithm" json:"authentication_algorithm,omitempty"`
	AuthenticationKey       *Key                     `protobuf:"bytes,5,opt,name=authentication_key,json=authenticationKey" json:"authentication_key,omitempty"`
	EncryptionAlgorithm     EncryptionAlgorithm      `protobuf:"varint,6,opt,name=encryption_algorithm,json=encryptionAlgorithm,proto3,enum=ipsec.EncryptionAlgorithm" json:"encryption_algorithm,omitempty"`
	EncryptionKey           *Key                     `protobuf:"bytes,7,opt,name=encryption_key,json=encryptionKey" json:"encryption_key,omitempty"`
	LocalGatewayIp          *IPAddress               `protobuf:"bytes,8,opt,name=local_gateway_ip,json=localGatewayIp" json:"local_gateway_ip,omitempty"`
	RemoteGatewayIp         *IPAddress               `protobuf:"bytes,9,opt,name=remote_gateway_ip,json=remoteGatewayIp" json:"remote_gateway_ip,omitempty"`
	Spi                     uint32                   `protobuf:"varint,10,opt,name=spi,proto3" json:"spi,omitempty"`
	NatTraversalPort        uint32                   `protobuf:"varint,11,opt,name=nat_traversal_port,json=natTraversalPort,proto3" json:"nat_traversal_port,omitempty"`
	Salt                    uint32                   `protobuf:"varint,12,opt,name=salt,proto3" json:"salt,omitempty"`
	Iv                      uint64                   `protobuf:"varint,13,opt,name=iv,proto3" json:"iv,omitempty"`
}

func (m *IpsecSAEncrypt) Reset()                    { *m = IpsecSAEncrypt{} }
func (m *IpsecSAEncrypt) String() string            { return proto.CompactTextString(m) }
func (*IpsecSAEncrypt) ProtoMessage()               {}
func (*IpsecSAEncrypt) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{1} }

func (m *IpsecSAEncrypt) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSAEncrypt) GetKeyOrHandle() *IpsecSAEncryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecSAEncrypt) GetProtocol() IpsecProtocol {
	if m != nil {
		return m.Protocol
	}
	return IpsecProtocol_IPSEC_PROTOCOL_NONE
}

func (m *IpsecSAEncrypt) GetAuthenticationAlgorithm() AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgorithm
	}
	return AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE
}

func (m *IpsecSAEncrypt) GetAuthenticationKey() *Key {
	if m != nil {
		return m.AuthenticationKey
	}
	return nil
}

func (m *IpsecSAEncrypt) GetEncryptionAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSAEncrypt) GetEncryptionKey() *Key {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *IpsecSAEncrypt) GetLocalGatewayIp() *IPAddress {
	if m != nil {
		return m.LocalGatewayIp
	}
	return nil
}

func (m *IpsecSAEncrypt) GetRemoteGatewayIp() *IPAddress {
	if m != nil {
		return m.RemoteGatewayIp
	}
	return nil
}

func (m *IpsecSAEncrypt) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *IpsecSAEncrypt) GetNatTraversalPort() uint32 {
	if m != nil {
		return m.NatTraversalPort
	}
	return 0
}

func (m *IpsecSAEncrypt) GetSalt() uint32 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *IpsecSAEncrypt) GetIv() uint64 {
	if m != nil {
		return m.Iv
	}
	return 0
}

// IPSec security association object
type IpsecSADecrypt struct {
	Meta                    *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle             *IpsecSADecryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Protocol                IpsecProtocol            `protobuf:"varint,3,opt,name=protocol,proto3,enum=ipsec.IpsecProtocol" json:"protocol,omitempty"`
	AuthenticationAlgorithm AuthenticationAlgorithm  `protobuf:"varint,4,opt,name=authentication_algorithm,json=authenticationAlgorithm,proto3,enum=ipsec.AuthenticationAlgorithm" json:"authentication_algorithm,omitempty"`
	AuthenticationKey       *Key                     `protobuf:"bytes,5,opt,name=authentication_key,json=authenticationKey" json:"authentication_key,omitempty"`
	DecryptionAlgorithm     EncryptionAlgorithm      `protobuf:"varint,6,opt,name=decryption_algorithm,json=decryptionAlgorithm,proto3,enum=ipsec.EncryptionAlgorithm" json:"decryption_algorithm,omitempty"`
	RekeyDecAlgorithm       EncryptionAlgorithm      `protobuf:"varint,7,opt,name=rekey_dec_algorithm,json=rekeyDecAlgorithm,proto3,enum=ipsec.EncryptionAlgorithm" json:"rekey_dec_algorithm,omitempty"`
	DecryptionKey           *Key                     `protobuf:"bytes,8,opt,name=decryption_key,json=decryptionKey" json:"decryption_key,omitempty"`
	RekeyAuthenticationKey  *Key                     `protobuf:"bytes,9,opt,name=rekey_authentication_key,json=rekeyAuthenticationKey" json:"rekey_authentication_key,omitempty"`
	RekeyDecryptionKey      *Key                     `protobuf:"bytes,10,opt,name=rekey_decryption_key,json=rekeyDecryptionKey" json:"rekey_decryption_key,omitempty"`
	LocalGatewayIp          *IPAddress               `protobuf:"bytes,11,opt,name=local_gateway_ip,json=localGatewayIp" json:"local_gateway_ip,omitempty"`
	RemoteGatewayIp         *IPAddress               `protobuf:"bytes,12,opt,name=remote_gateway_ip,json=remoteGatewayIp" json:"remote_gateway_ip,omitempty"`
	Spi                     uint32                   `protobuf:"varint,13,opt,name=spi,proto3" json:"spi,omitempty"`
	RekeyActive             uint32                   `protobuf:"varint,14,opt,name=rekey_active,json=rekeyActive,proto3" json:"rekey_active,omitempty"`
	RekeySpi                uint32                   `protobuf:"varint,15,opt,name=rekey_spi,json=rekeySpi,proto3" json:"rekey_spi,omitempty"`
	Salt                    uint32                   `protobuf:"varint,16,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *IpsecSADecrypt) Reset()                    { *m = IpsecSADecrypt{} }
func (m *IpsecSADecrypt) String() string            { return proto.CompactTextString(m) }
func (*IpsecSADecrypt) ProtoMessage()               {}
func (*IpsecSADecrypt) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{2} }

func (m *IpsecSADecrypt) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSADecrypt) GetKeyOrHandle() *IpsecSADecryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecSADecrypt) GetProtocol() IpsecProtocol {
	if m != nil {
		return m.Protocol
	}
	return IpsecProtocol_IPSEC_PROTOCOL_NONE
}

func (m *IpsecSADecrypt) GetAuthenticationAlgorithm() AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgorithm
	}
	return AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE
}

func (m *IpsecSADecrypt) GetAuthenticationKey() *Key {
	if m != nil {
		return m.AuthenticationKey
	}
	return nil
}

func (m *IpsecSADecrypt) GetDecryptionAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.DecryptionAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSADecrypt) GetRekeyDecAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.RekeyDecAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSADecrypt) GetDecryptionKey() *Key {
	if m != nil {
		return m.DecryptionKey
	}
	return nil
}

func (m *IpsecSADecrypt) GetRekeyAuthenticationKey() *Key {
	if m != nil {
		return m.RekeyAuthenticationKey
	}
	return nil
}

func (m *IpsecSADecrypt) GetRekeyDecryptionKey() *Key {
	if m != nil {
		return m.RekeyDecryptionKey
	}
	return nil
}

func (m *IpsecSADecrypt) GetLocalGatewayIp() *IPAddress {
	if m != nil {
		return m.LocalGatewayIp
	}
	return nil
}

func (m *IpsecSADecrypt) GetRemoteGatewayIp() *IPAddress {
	if m != nil {
		return m.RemoteGatewayIp
	}
	return nil
}

func (m *IpsecSADecrypt) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *IpsecSADecrypt) GetRekeyActive() uint32 {
	if m != nil {
		return m.RekeyActive
	}
	return 0
}

func (m *IpsecSADecrypt) GetRekeySpi() uint32 {
	if m != nil {
		return m.RekeySpi
	}
	return 0
}

func (m *IpsecSADecrypt) GetSalt() uint32 {
	if m != nil {
		return m.Salt
	}
	return 0
}

// IpsecRuleSpec is the user intent for the IPSec rule
type IpsecRuleSpec struct {
	Meta         *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle  *IpsecRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	VrfKeyHandle *VrfKeyHandle       `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	// IPSec rule match conditions
	SrcAddress []*IPAddressObj `protobuf:"bytes,4,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	DstAddress []*IPAddressObj `protobuf:"bytes,6,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	Protocol   []IPProtocol    `protobuf:"varint,7,rep,packed,name=protocol,enum=types.IPProtocol" json:"protocol,omitempty"`
	// Types that are valid to be assigned to L4AppInfo:
	//	*IpsecRuleSpec_PortInfo
	//	*IpsecRuleSpec_EspInfo_
	L4AppInfo isIpsecRuleSpec_L4AppInfo `protobuf_oneof:"L4AppInfo"`
	// IPSec security associaton parameters
	//
	// Types that are valid to be assigned to IpSecSAInfo:
	//	*IpsecRuleSpec_EncSecurityAssociation
	//	*IpsecRuleSpec_DecSecurityAssociation
	IpSecSAInfo isIpsecRuleSpec_IpSecSAInfo `protobuf_oneof:"IpSecSAInfo"`
}

func (m *IpsecRuleSpec) Reset()                    { *m = IpsecRuleSpec{} }
func (m *IpsecRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleSpec) ProtoMessage()               {}
func (*IpsecRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{3} }

type isIpsecRuleSpec_L4AppInfo interface {
	isIpsecRuleSpec_L4AppInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isIpsecRuleSpec_IpSecSAInfo interface {
	isIpsecRuleSpec_IpSecSAInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpsecRuleSpec_PortInfo struct {
	PortInfo *IpsecRuleSpec_AppPortInfo `protobuf:"bytes,8,opt,name=port_info,json=portInfo,oneof"`
}
type IpsecRuleSpec_EspInfo_ struct {
	EspInfo *IpsecRuleSpec_EspInfo `protobuf:"bytes,9,opt,name=esp_info,json=espInfo,oneof"`
}
type IpsecRuleSpec_EncSecurityAssociation struct {
	EncSecurityAssociation *IpsecSAEncrypt `protobuf:"bytes,10,opt,name=enc_security_association,json=encSecurityAssociation,oneof"`
}
type IpsecRuleSpec_DecSecurityAssociation struct {
	DecSecurityAssociation *IpsecSADecrypt `protobuf:"bytes,11,opt,name=dec_security_association,json=decSecurityAssociation,oneof"`
}

func (*IpsecRuleSpec_PortInfo) isIpsecRuleSpec_L4AppInfo()                 {}
func (*IpsecRuleSpec_EspInfo_) isIpsecRuleSpec_L4AppInfo()                 {}
func (*IpsecRuleSpec_EncSecurityAssociation) isIpsecRuleSpec_IpSecSAInfo() {}
func (*IpsecRuleSpec_DecSecurityAssociation) isIpsecRuleSpec_IpSecSAInfo() {}

func (m *IpsecRuleSpec) GetL4AppInfo() isIpsecRuleSpec_L4AppInfo {
	if m != nil {
		return m.L4AppInfo
	}
	return nil
}
func (m *IpsecRuleSpec) GetIpSecSAInfo() isIpsecRuleSpec_IpSecSAInfo {
	if m != nil {
		return m.IpSecSAInfo
	}
	return nil
}

func (m *IpsecRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecRuleSpec) GetKeyOrHandle() *IpsecRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecRuleSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *IpsecRuleSpec) GetSrcAddress() []*IPAddressObj {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *IpsecRuleSpec) GetDstAddress() []*IPAddressObj {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *IpsecRuleSpec) GetProtocol() []IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *IpsecRuleSpec) GetPortInfo() *IpsecRuleSpec_AppPortInfo {
	if x, ok := m.GetL4AppInfo().(*IpsecRuleSpec_PortInfo); ok {
		return x.PortInfo
	}
	return nil
}

func (m *IpsecRuleSpec) GetEspInfo() *IpsecRuleSpec_EspInfo {
	if x, ok := m.GetL4AppInfo().(*IpsecRuleSpec_EspInfo_); ok {
		return x.EspInfo
	}
	return nil
}

func (m *IpsecRuleSpec) GetEncSecurityAssociation() *IpsecSAEncrypt {
	if x, ok := m.GetIpSecSAInfo().(*IpsecRuleSpec_EncSecurityAssociation); ok {
		return x.EncSecurityAssociation
	}
	return nil
}

func (m *IpsecRuleSpec) GetDecSecurityAssociation() *IpsecSADecrypt {
	if x, ok := m.GetIpSecSAInfo().(*IpsecRuleSpec_DecSecurityAssociation); ok {
		return x.DecSecurityAssociation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpsecRuleSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpsecRuleSpec_OneofMarshaler, _IpsecRuleSpec_OneofUnmarshaler, _IpsecRuleSpec_OneofSizer, []interface{}{
		(*IpsecRuleSpec_PortInfo)(nil),
		(*IpsecRuleSpec_EspInfo_)(nil),
		(*IpsecRuleSpec_EncSecurityAssociation)(nil),
		(*IpsecRuleSpec_DecSecurityAssociation)(nil),
	}
}

func _IpsecRuleSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpsecRuleSpec)
	// L4AppInfo
	switch x := m.L4AppInfo.(type) {
	case *IpsecRuleSpec_PortInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortInfo); err != nil {
			return err
		}
	case *IpsecRuleSpec_EspInfo_:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EspInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IpsecRuleSpec.L4AppInfo has unexpected type %T", x)
	}
	// IpSecSAInfo
	switch x := m.IpSecSAInfo.(type) {
	case *IpsecRuleSpec_EncSecurityAssociation:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncSecurityAssociation); err != nil {
			return err
		}
	case *IpsecRuleSpec_DecSecurityAssociation:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DecSecurityAssociation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IpsecRuleSpec.IpSecSAInfo has unexpected type %T", x)
	}
	return nil
}

func _IpsecRuleSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpsecRuleSpec)
	switch tag {
	case 8: // L4AppInfo.port_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IpsecRuleSpec_AppPortInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &IpsecRuleSpec_PortInfo{msg}
		return true, err
	case 9: // L4AppInfo.esp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IpsecRuleSpec_EspInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &IpsecRuleSpec_EspInfo_{msg}
		return true, err
	case 10: // IpSecSAInfo.enc_security_association
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IpsecSAEncrypt)
		err := b.DecodeMessage(msg)
		m.IpSecSAInfo = &IpsecRuleSpec_EncSecurityAssociation{msg}
		return true, err
	case 11: // IpSecSAInfo.dec_security_association
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IpsecSADecrypt)
		err := b.DecodeMessage(msg)
		m.IpSecSAInfo = &IpsecRuleSpec_DecSecurityAssociation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IpsecRuleSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpsecRuleSpec)
	// L4AppInfo
	switch x := m.L4AppInfo.(type) {
	case *IpsecRuleSpec_PortInfo:
		s := proto.Size(x.PortInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IpsecRuleSpec_EspInfo_:
		s := proto.Size(x.EspInfo)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// IpSecSAInfo
	switch x := m.IpSecSAInfo.(type) {
	case *IpsecRuleSpec_EncSecurityAssociation:
		s := proto.Size(x.EncSecurityAssociation)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IpsecRuleSpec_DecSecurityAssociation:
		s := proto.Size(x.DecSecurityAssociation)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type IpsecRuleSpec_AppPortInfo struct {
	DstPortRange []*L4PortRange `protobuf:"bytes,1,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange `protobuf:"bytes,2,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
}

func (m *IpsecRuleSpec_AppPortInfo) Reset()         { *m = IpsecRuleSpec_AppPortInfo{} }
func (m *IpsecRuleSpec_AppPortInfo) String() string { return proto.CompactTextString(m) }
func (*IpsecRuleSpec_AppPortInfo) ProtoMessage()    {}
func (*IpsecRuleSpec_AppPortInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{3, 0}
}

func (m *IpsecRuleSpec_AppPortInfo) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *IpsecRuleSpec_AppPortInfo) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

type IpsecRuleSpec_EspInfo struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi,proto3" json:"spi,omitempty"`
}

func (m *IpsecRuleSpec_EspInfo) Reset()         { *m = IpsecRuleSpec_EspInfo{} }
func (m *IpsecRuleSpec_EspInfo) String() string { return proto.CompactTextString(m) }
func (*IpsecRuleSpec_EspInfo) ProtoMessage()    {}
func (*IpsecRuleSpec_EspInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{3, 1}
}

func (m *IpsecRuleSpec_EspInfo) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

// IpsecRuleRequestMsg is the batched add or modify of NAT rule request
type IpsecRuleRequestMsg struct {
	Request []*IpsecRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecRuleRequestMsg) Reset()                    { *m = IpsecRuleRequestMsg{} }
func (m *IpsecRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleRequestMsg) ProtoMessage()               {}
func (*IpsecRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{4} }

func (m *IpsecRuleRequestMsg) GetRequest() []*IpsecRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecRuleStatus reflects the current operational status of the IPSec rule
type IpsecRuleStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *IpsecRuleStatus) Reset()                    { *m = IpsecRuleStatus{} }
func (m *IpsecRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleStatus) ProtoMessage()               {}
func (*IpsecRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{5} }

func (m *IpsecRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// IpsecRuleResponse is the response to IpsecRuleSpec
type IpsecRuleResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *IpsecRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *IpsecRuleResponse) Reset()                    { *m = IpsecRuleResponse{} }
func (m *IpsecRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleResponse) ProtoMessage()               {}
func (*IpsecRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{6} }

func (m *IpsecRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecRuleResponse) GetStatus() *IpsecRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// IpsecRuleResponseMsg is batched response to IpsecRuleRequestMsg
type IpsecRuleResponseMsg struct {
	Response []*IpsecRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *IpsecRuleResponseMsg) Reset()                    { *m = IpsecRuleResponseMsg{} }
func (m *IpsecRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleResponseMsg) ProtoMessage()               {}
func (*IpsecRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{7} }

func (m *IpsecRuleResponseMsg) GetResponse() []*IpsecRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// IpsecRuleDeleteRequest is used to delete a policy rule
type IpsecRuleDeleteRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecRuleDeleteRequest) Reset()                    { *m = IpsecRuleDeleteRequest{} }
func (m *IpsecRuleDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleDeleteRequest) ProtoMessage()               {}
func (*IpsecRuleDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{8} }

func (m *IpsecRuleDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecRuleDeleteRequest) GetKeyOrHandle() *IpsecRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecRuleDeleteRequestMsg is used to delete a batch of ipsec rules
type IpsecRuleDeleteRequestMsg struct {
	Request []*IpsecRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecRuleDeleteRequestMsg) Reset()         { *m = IpsecRuleDeleteRequestMsg{} }
func (m *IpsecRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecRuleDeleteRequestMsg) ProtoMessage()    {}
func (*IpsecRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{9}
}

func (m *IpsecRuleDeleteRequestMsg) GetRequest() []*IpsecRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecRuleDeleteResponseMsg is batched response to IpsecRuleDeleteRequestMsg
type IpsecRuleDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *IpsecRuleDeleteResponseMsg) Reset()         { *m = IpsecRuleDeleteResponseMsg{} }
func (m *IpsecRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecRuleDeleteResponseMsg) ProtoMessage()    {}
func (*IpsecRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{10}
}

func (m *IpsecRuleDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// IpsecRuleGetRequest is used to get information about a ipsec rule
type IpsecRuleGetRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecRuleGetRequest) Reset()                    { *m = IpsecRuleGetRequest{} }
func (m *IpsecRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleGetRequest) ProtoMessage()               {}
func (*IpsecRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{11} }

func (m *IpsecRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecRuleGetRequest) GetKeyOrHandle() *IpsecRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecRuleGetRequestMsg is batched GET requests for ipsec rule
type IpsecRuleGetRequestMsg struct {
	Request []*IpsecRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecRuleGetRequestMsg) Reset()         { *m = IpsecRuleGetRequestMsg{} }
func (m *IpsecRuleGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecRuleGetRequestMsg) ProtoMessage()    {}
func (*IpsecRuleGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{12}
}

func (m *IpsecRuleGetRequestMsg) GetRequest() []*IpsecRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSAEncryptRequestMsg is batched add or modify ipseccb request
type IpsecSAEncryptRequestMsg struct {
	Request []*IpsecSAEncrypt `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSAEncryptRequestMsg) Reset()         { *m = IpsecSAEncryptRequestMsg{} }
func (m *IpsecSAEncryptRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptRequestMsg) ProtoMessage()    {}
func (*IpsecSAEncryptRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{13}
}

func (m *IpsecSAEncryptRequestMsg) GetRequest() []*IpsecSAEncrypt {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSAEncryptStatus is the operational status of a given ipseccb
type IpsecSAEncryptStatus struct {
	IpseccbHandle uint64 `protobuf:"fixed64,1,opt,name=ipseccb_handle,json=ipseccbHandle,proto3" json:"ipseccb_handle,omitempty"`
}

func (m *IpsecSAEncryptStatus) Reset()                    { *m = IpsecSAEncryptStatus{} }
func (m *IpsecSAEncryptStatus) String() string            { return proto.CompactTextString(m) }
func (*IpsecSAEncryptStatus) ProtoMessage()               {}
func (*IpsecSAEncryptStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{14} }

func (m *IpsecSAEncryptStatus) GetIpseccbHandle() uint64 {
	if m != nil {
		return m.IpseccbHandle
	}
	return 0
}

// IpsecSAEncryptResponse is response to IpsecSA
type IpsecSAEncryptResponse struct {
	ApiStatus     ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	IpseccbStatus *IpsecSAEncryptStatus `protobuf:"bytes,2,opt,name=ipseccb_status,json=ipseccbStatus" json:"ipseccb_status,omitempty"`
}

func (m *IpsecSAEncryptResponse) Reset()         { *m = IpsecSAEncryptResponse{} }
func (m *IpsecSAEncryptResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptResponse) ProtoMessage()    {}
func (*IpsecSAEncryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{15}
}

func (m *IpsecSAEncryptResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSAEncryptResponse) GetIpseccbStatus() *IpsecSAEncryptStatus {
	if m != nil {
		return m.IpseccbStatus
	}
	return nil
}

// IpsecSAEncryptResponseMsg is batched response to IpsecSAEncryptRequestMsg
type IpsecSAEncryptResponseMsg struct {
	Response []*IpsecSAEncryptResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *IpsecSAEncryptResponseMsg) Reset()         { *m = IpsecSAEncryptResponseMsg{} }
func (m *IpsecSAEncryptResponseMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptResponseMsg) ProtoMessage()    {}
func (*IpsecSAEncryptResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{16}
}

func (m *IpsecSAEncryptResponseMsg) GetResponse() []*IpsecSAEncryptResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// IpsecSAEncryptDeleteRequest is used to delete a ipseccb
type IpsecSAEncryptDeleteRequest struct {
	Meta        *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecSAEncryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecSAEncryptDeleteRequest) Reset()         { *m = IpsecSAEncryptDeleteRequest{} }
func (m *IpsecSAEncryptDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptDeleteRequest) ProtoMessage()    {}
func (*IpsecSAEncryptDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{17}
}

func (m *IpsecSAEncryptDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSAEncryptDeleteRequest) GetKeyOrHandle() *IpsecSAEncryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecSAEncryptDeleteRequestMsg is used to delete a batch of ipseccbs
type IpsecSAEncryptDeleteRequestMsg struct {
	Request []*IpsecSAEncryptDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSAEncryptDeleteRequestMsg) Reset()         { *m = IpsecSAEncryptDeleteRequestMsg{} }
func (m *IpsecSAEncryptDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptDeleteRequestMsg) ProtoMessage()    {}
func (*IpsecSAEncryptDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{18}
}

func (m *IpsecSAEncryptDeleteRequestMsg) GetRequest() []*IpsecSAEncryptDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSAEncryptDeleteResponseMsg is batched response to IpsecSADeleteRequestMsg
type IpsecSAEncryptDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *IpsecSAEncryptDeleteResponseMsg) Reset()         { *m = IpsecSAEncryptDeleteResponseMsg{} }
func (m *IpsecSAEncryptDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptDeleteResponseMsg) ProtoMessage()    {}
func (*IpsecSAEncryptDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{19}
}

func (m *IpsecSAEncryptDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// IpsecSAEncryptGetRequest is used to get information about a ipseccb
type IpsecSAEncryptGetRequest struct {
	Meta        *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecSAEncryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecSAEncryptGetRequest) Reset()         { *m = IpsecSAEncryptGetRequest{} }
func (m *IpsecSAEncryptGetRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptGetRequest) ProtoMessage()    {}
func (*IpsecSAEncryptGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{20}
}

func (m *IpsecSAEncryptGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSAEncryptGetRequest) GetKeyOrHandle() *IpsecSAEncryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecSAEncryptGetRequestMsg is batched GET requests for ipseccbs
type IpsecSAEncryptGetRequestMsg struct {
	Request []*IpsecSAEncryptGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSAEncryptGetRequestMsg) Reset()         { *m = IpsecSAEncryptGetRequestMsg{} }
func (m *IpsecSAEncryptGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptGetRequestMsg) ProtoMessage()    {}
func (*IpsecSAEncryptGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{21}
}

func (m *IpsecSAEncryptGetRequestMsg) GetRequest() []*IpsecSAEncryptGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSADecryptRequestMsg is batched add or modify ipseccb request
type IpsecSADecryptRequestMsg struct {
	Request []*IpsecSADecrypt `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSADecryptRequestMsg) Reset()         { *m = IpsecSADecryptRequestMsg{} }
func (m *IpsecSADecryptRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptRequestMsg) ProtoMessage()    {}
func (*IpsecSADecryptRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{22}
}

func (m *IpsecSADecryptRequestMsg) GetRequest() []*IpsecSADecrypt {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSADecryptStatus is the operational status of a given ipseccb
type IpsecSADecryptStatus struct {
	IpseccbHandle uint64 `protobuf:"fixed64,1,opt,name=ipseccb_handle,json=ipseccbHandle,proto3" json:"ipseccb_handle,omitempty"`
}

func (m *IpsecSADecryptStatus) Reset()                    { *m = IpsecSADecryptStatus{} }
func (m *IpsecSADecryptStatus) String() string            { return proto.CompactTextString(m) }
func (*IpsecSADecryptStatus) ProtoMessage()               {}
func (*IpsecSADecryptStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsecDraft, []int{23} }

func (m *IpsecSADecryptStatus) GetIpseccbHandle() uint64 {
	if m != nil {
		return m.IpseccbHandle
	}
	return 0
}

// IpsecSADecryptResponse is response to IpsecSA
type IpsecSADecryptResponse struct {
	ApiStatus     ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	IpseccbStatus *IpsecSADecryptStatus `protobuf:"bytes,2,opt,name=ipseccb_status,json=ipseccbStatus" json:"ipseccb_status,omitempty"`
}

func (m *IpsecSADecryptResponse) Reset()         { *m = IpsecSADecryptResponse{} }
func (m *IpsecSADecryptResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptResponse) ProtoMessage()    {}
func (*IpsecSADecryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{24}
}

func (m *IpsecSADecryptResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSADecryptResponse) GetIpseccbStatus() *IpsecSADecryptStatus {
	if m != nil {
		return m.IpseccbStatus
	}
	return nil
}

// IpsecSADecryptResponseMsg is batched response to IpsecSADecryptRequestMsg
type IpsecSADecryptResponseMsg struct {
	Response []*IpsecSADecryptResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *IpsecSADecryptResponseMsg) Reset()         { *m = IpsecSADecryptResponseMsg{} }
func (m *IpsecSADecryptResponseMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptResponseMsg) ProtoMessage()    {}
func (*IpsecSADecryptResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{25}
}

func (m *IpsecSADecryptResponseMsg) GetResponse() []*IpsecSADecryptResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// IpsecSADecryptDeleteRequest is used to delete a ipseccb
type IpsecSADecryptDeleteRequest struct {
	Meta        *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecSADecryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecSADecryptDeleteRequest) Reset()         { *m = IpsecSADecryptDeleteRequest{} }
func (m *IpsecSADecryptDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptDeleteRequest) ProtoMessage()    {}
func (*IpsecSADecryptDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{26}
}

func (m *IpsecSADecryptDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSADecryptDeleteRequest) GetKeyOrHandle() *IpsecSADecryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecSADecryptDeleteRequestMsg is used to delete a batch of ipseccbs
type IpsecSADecryptDeleteRequestMsg struct {
	Request []*IpsecSADecryptDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSADecryptDeleteRequestMsg) Reset()         { *m = IpsecSADecryptDeleteRequestMsg{} }
func (m *IpsecSADecryptDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptDeleteRequestMsg) ProtoMessage()    {}
func (*IpsecSADecryptDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{27}
}

func (m *IpsecSADecryptDeleteRequestMsg) GetRequest() []*IpsecSADecryptDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// IpsecSADecryptDeleteResponseMsg is batched response to IpsecSADeleteRequestMsg
type IpsecSADecryptDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *IpsecSADecryptDeleteResponseMsg) Reset()         { *m = IpsecSADecryptDeleteResponseMsg{} }
func (m *IpsecSADecryptDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptDeleteResponseMsg) ProtoMessage()    {}
func (*IpsecSADecryptDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{28}
}

func (m *IpsecSADecryptDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// IpsecSADecryptGetRequest is used to get information about a ipseccb
type IpsecSADecryptGetRequest struct {
	Meta        *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *IpsecSADecryptKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *IpsecSADecryptGetRequest) Reset()         { *m = IpsecSADecryptGetRequest{} }
func (m *IpsecSADecryptGetRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptGetRequest) ProtoMessage()    {}
func (*IpsecSADecryptGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{29}
}

func (m *IpsecSADecryptGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *IpsecSADecryptGetRequest) GetKeyOrHandle() *IpsecSADecryptKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// IpsecSADecryptGetRequestMsg is batched GET requests for ipseccbs
type IpsecSADecryptGetRequestMsg struct {
	Request []*IpsecSADecryptGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *IpsecSADecryptGetRequestMsg) Reset()         { *m = IpsecSADecryptGetRequestMsg{} }
func (m *IpsecSADecryptGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptGetRequestMsg) ProtoMessage()    {}
func (*IpsecSADecryptGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorIpsecDraft, []int{30}
}

func (m *IpsecSADecryptGetRequestMsg) GetRequest() []*IpsecSADecryptGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterType((*Key)(nil), "ipsec.Key")
	proto.RegisterType((*IpsecSAEncrypt)(nil), "ipsec.IpsecSAEncrypt")
	proto.RegisterType((*IpsecSADecrypt)(nil), "ipsec.IpsecSADecrypt")
	proto.RegisterType((*IpsecRuleSpec)(nil), "ipsec.IpsecRuleSpec")
	proto.RegisterType((*IpsecRuleSpec_AppPortInfo)(nil), "ipsec.IpsecRuleSpec.AppPortInfo")
	proto.RegisterType((*IpsecRuleSpec_EspInfo)(nil), "ipsec.IpsecRuleSpec.EspInfo")
	proto.RegisterType((*IpsecRuleRequestMsg)(nil), "ipsec.IpsecRuleRequestMsg")
	proto.RegisterType((*IpsecRuleStatus)(nil), "ipsec.IpsecRuleStatus")
	proto.RegisterType((*IpsecRuleResponse)(nil), "ipsec.IpsecRuleResponse")
	proto.RegisterType((*IpsecRuleResponseMsg)(nil), "ipsec.IpsecRuleResponseMsg")
	proto.RegisterType((*IpsecRuleDeleteRequest)(nil), "ipsec.IpsecRuleDeleteRequest")
	proto.RegisterType((*IpsecRuleDeleteRequestMsg)(nil), "ipsec.IpsecRuleDeleteRequestMsg")
	proto.RegisterType((*IpsecRuleDeleteResponseMsg)(nil), "ipsec.IpsecRuleDeleteResponseMsg")
	proto.RegisterType((*IpsecRuleGetRequest)(nil), "ipsec.IpsecRuleGetRequest")
	proto.RegisterType((*IpsecRuleGetRequestMsg)(nil), "ipsec.IpsecRuleGetRequestMsg")
	proto.RegisterType((*IpsecSAEncryptRequestMsg)(nil), "ipsec.IpsecSAEncryptRequestMsg")
	proto.RegisterType((*IpsecSAEncryptStatus)(nil), "ipsec.IpsecSAEncryptStatus")
	proto.RegisterType((*IpsecSAEncryptResponse)(nil), "ipsec.IpsecSAEncryptResponse")
	proto.RegisterType((*IpsecSAEncryptResponseMsg)(nil), "ipsec.IpsecSAEncryptResponseMsg")
	proto.RegisterType((*IpsecSAEncryptDeleteRequest)(nil), "ipsec.IpsecSAEncryptDeleteRequest")
	proto.RegisterType((*IpsecSAEncryptDeleteRequestMsg)(nil), "ipsec.IpsecSAEncryptDeleteRequestMsg")
	proto.RegisterType((*IpsecSAEncryptDeleteResponseMsg)(nil), "ipsec.IpsecSAEncryptDeleteResponseMsg")
	proto.RegisterType((*IpsecSAEncryptGetRequest)(nil), "ipsec.IpsecSAEncryptGetRequest")
	proto.RegisterType((*IpsecSAEncryptGetRequestMsg)(nil), "ipsec.IpsecSAEncryptGetRequestMsg")
	proto.RegisterType((*IpsecSADecryptRequestMsg)(nil), "ipsec.IpsecSADecryptRequestMsg")
	proto.RegisterType((*IpsecSADecryptStatus)(nil), "ipsec.IpsecSADecryptStatus")
	proto.RegisterType((*IpsecSADecryptResponse)(nil), "ipsec.IpsecSADecryptResponse")
	proto.RegisterType((*IpsecSADecryptResponseMsg)(nil), "ipsec.IpsecSADecryptResponseMsg")
	proto.RegisterType((*IpsecSADecryptDeleteRequest)(nil), "ipsec.IpsecSADecryptDeleteRequest")
	proto.RegisterType((*IpsecSADecryptDeleteRequestMsg)(nil), "ipsec.IpsecSADecryptDeleteRequestMsg")
	proto.RegisterType((*IpsecSADecryptDeleteResponseMsg)(nil), "ipsec.IpsecSADecryptDeleteResponseMsg")
	proto.RegisterType((*IpsecSADecryptGetRequest)(nil), "ipsec.IpsecSADecryptGetRequest")
	proto.RegisterType((*IpsecSADecryptGetRequestMsg)(nil), "ipsec.IpsecSADecryptGetRequestMsg")
	proto.RegisterEnum("ipsec.IpsecProtocol", IpsecProtocol_name, IpsecProtocol_value)
	proto.RegisterEnum("ipsec.EncryptionAlgorithm", EncryptionAlgorithm_name, EncryptionAlgorithm_value)
	proto.RegisterEnum("ipsec.AuthenticationAlgorithm", AuthenticationAlgorithm_name, AuthenticationAlgorithm_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Ipsec service

type IpsecClient interface {
	IpsecRuleCreate(ctx context.Context, in *IpsecRuleRequestMsg, opts ...grpc.CallOption) (*IpsecRuleResponseMsg, error)
	IpsecRuleUpdate(ctx context.Context, in *IpsecRuleRequestMsg, opts ...grpc.CallOption) (*IpsecRuleResponseMsg, error)
	IpsecRuleDelete(ctx context.Context, in *IpsecRuleDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecRuleDeleteResponseMsg, error)
	IpsecRuleGet(ctx context.Context, in *IpsecRuleGetRequestMsg, opts ...grpc.CallOption) (*IpsecRuleGetRequestMsg, error)
	IpsecSAEncryptCreate(ctx context.Context, in *IpsecSAEncryptRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptResponseMsg, error)
	IpsecSAEncryptUpdate(ctx context.Context, in *IpsecSAEncryptRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptResponseMsg, error)
	IpsecSAEncryptDelete(ctx context.Context, in *IpsecSAEncryptDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptDeleteResponseMsg, error)
	IpsecSAEncryptGet(ctx context.Context, in *IpsecSAEncryptGetRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptGetRequestMsg, error)
	IpsecSADecryptCreate(ctx context.Context, in *IpsecSADecryptRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptResponseMsg, error)
	IpsecSADecryptUpdate(ctx context.Context, in *IpsecSADecryptRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptResponseMsg, error)
	IpsecSADecryptDelete(ctx context.Context, in *IpsecSADecryptDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptDeleteResponseMsg, error)
	IpsecSADecryptGet(ctx context.Context, in *IpsecSADecryptGetRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptGetRequestMsg, error)
}

type ipsecClient struct {
	cc *grpc.ClientConn
}

func NewIpsecClient(cc *grpc.ClientConn) IpsecClient {
	return &ipsecClient{cc}
}

func (c *ipsecClient) IpsecRuleCreate(ctx context.Context, in *IpsecRuleRequestMsg, opts ...grpc.CallOption) (*IpsecRuleResponseMsg, error) {
	out := new(IpsecRuleResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecRuleUpdate(ctx context.Context, in *IpsecRuleRequestMsg, opts ...grpc.CallOption) (*IpsecRuleResponseMsg, error) {
	out := new(IpsecRuleResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecRuleDelete(ctx context.Context, in *IpsecRuleDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecRuleDeleteResponseMsg, error) {
	out := new(IpsecRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecRuleGet(ctx context.Context, in *IpsecRuleGetRequestMsg, opts ...grpc.CallOption) (*IpsecRuleGetRequestMsg, error) {
	out := new(IpsecRuleGetRequestMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSAEncryptCreate(ctx context.Context, in *IpsecSAEncryptRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptResponseMsg, error) {
	out := new(IpsecSAEncryptResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSAEncryptCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSAEncryptUpdate(ctx context.Context, in *IpsecSAEncryptRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptResponseMsg, error) {
	out := new(IpsecSAEncryptResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSAEncryptUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSAEncryptDelete(ctx context.Context, in *IpsecSAEncryptDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptDeleteResponseMsg, error) {
	out := new(IpsecSAEncryptDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSAEncryptDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSAEncryptGet(ctx context.Context, in *IpsecSAEncryptGetRequestMsg, opts ...grpc.CallOption) (*IpsecSAEncryptGetRequestMsg, error) {
	out := new(IpsecSAEncryptGetRequestMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSAEncryptGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSADecryptCreate(ctx context.Context, in *IpsecSADecryptRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptResponseMsg, error) {
	out := new(IpsecSADecryptResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSADecryptCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSADecryptUpdate(ctx context.Context, in *IpsecSADecryptRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptResponseMsg, error) {
	out := new(IpsecSADecryptResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSADecryptUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSADecryptDelete(ctx context.Context, in *IpsecSADecryptDeleteRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptDeleteResponseMsg, error) {
	out := new(IpsecSADecryptDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSADecryptDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecClient) IpsecSADecryptGet(ctx context.Context, in *IpsecSADecryptGetRequestMsg, opts ...grpc.CallOption) (*IpsecSADecryptGetRequestMsg, error) {
	out := new(IpsecSADecryptGetRequestMsg)
	err := grpc.Invoke(ctx, "/ipsec.Ipsec/IpsecSADecryptGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ipsec service

type IpsecServer interface {
	IpsecRuleCreate(context.Context, *IpsecRuleRequestMsg) (*IpsecRuleResponseMsg, error)
	IpsecRuleUpdate(context.Context, *IpsecRuleRequestMsg) (*IpsecRuleResponseMsg, error)
	IpsecRuleDelete(context.Context, *IpsecRuleDeleteRequestMsg) (*IpsecRuleDeleteResponseMsg, error)
	IpsecRuleGet(context.Context, *IpsecRuleGetRequestMsg) (*IpsecRuleGetRequestMsg, error)
	IpsecSAEncryptCreate(context.Context, *IpsecSAEncryptRequestMsg) (*IpsecSAEncryptResponseMsg, error)
	IpsecSAEncryptUpdate(context.Context, *IpsecSAEncryptRequestMsg) (*IpsecSAEncryptResponseMsg, error)
	IpsecSAEncryptDelete(context.Context, *IpsecSAEncryptDeleteRequestMsg) (*IpsecSAEncryptDeleteResponseMsg, error)
	IpsecSAEncryptGet(context.Context, *IpsecSAEncryptGetRequestMsg) (*IpsecSAEncryptGetRequestMsg, error)
	IpsecSADecryptCreate(context.Context, *IpsecSADecryptRequestMsg) (*IpsecSADecryptResponseMsg, error)
	IpsecSADecryptUpdate(context.Context, *IpsecSADecryptRequestMsg) (*IpsecSADecryptResponseMsg, error)
	IpsecSADecryptDelete(context.Context, *IpsecSADecryptDeleteRequestMsg) (*IpsecSADecryptDeleteResponseMsg, error)
	IpsecSADecryptGet(context.Context, *IpsecSADecryptGetRequestMsg) (*IpsecSADecryptGetRequestMsg, error)
}

func RegisterIpsecServer(s *grpc.Server, srv IpsecServer) {
	s.RegisterService(&_Ipsec_serviceDesc, srv)
}

func _Ipsec_IpsecRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecRuleCreate(ctx, req.(*IpsecRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecRuleUpdate(ctx, req.(*IpsecRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecRuleDelete(ctx, req.(*IpsecRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecRuleGet(ctx, req.(*IpsecRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSAEncryptCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSAEncryptCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSAEncryptCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSAEncryptCreate(ctx, req.(*IpsecSAEncryptRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSAEncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSAEncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSAEncryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSAEncryptUpdate(ctx, req.(*IpsecSAEncryptRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSAEncryptDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSAEncryptDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSAEncryptDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSAEncryptDelete(ctx, req.(*IpsecSAEncryptDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSAEncryptGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSAEncryptGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSAEncryptGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSAEncryptGet(ctx, req.(*IpsecSAEncryptGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSADecryptCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSADecryptCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSADecryptCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSADecryptCreate(ctx, req.(*IpsecSADecryptRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSADecryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSADecryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSADecryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSADecryptUpdate(ctx, req.(*IpsecSADecryptRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSADecryptDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSADecryptDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSADecryptDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSADecryptDelete(ctx, req.(*IpsecSADecryptDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ipsec_IpsecSADecryptGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecServer).IpsecSADecryptGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipsec.Ipsec/IpsecSADecryptGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecServer).IpsecSADecryptGet(ctx, req.(*IpsecSADecryptGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ipsec_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ipsec.Ipsec",
	HandlerType: (*IpsecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IpsecRuleCreate",
			Handler:    _Ipsec_IpsecRuleCreate_Handler,
		},
		{
			MethodName: "IpsecRuleUpdate",
			Handler:    _Ipsec_IpsecRuleUpdate_Handler,
		},
		{
			MethodName: "IpsecRuleDelete",
			Handler:    _Ipsec_IpsecRuleDelete_Handler,
		},
		{
			MethodName: "IpsecRuleGet",
			Handler:    _Ipsec_IpsecRuleGet_Handler,
		},
		{
			MethodName: "IpsecSAEncryptCreate",
			Handler:    _Ipsec_IpsecSAEncryptCreate_Handler,
		},
		{
			MethodName: "IpsecSAEncryptUpdate",
			Handler:    _Ipsec_IpsecSAEncryptUpdate_Handler,
		},
		{
			MethodName: "IpsecSAEncryptDelete",
			Handler:    _Ipsec_IpsecSAEncryptDelete_Handler,
		},
		{
			MethodName: "IpsecSAEncryptGet",
			Handler:    _Ipsec_IpsecSAEncryptGet_Handler,
		},
		{
			MethodName: "IpsecSADecryptCreate",
			Handler:    _Ipsec_IpsecSADecryptCreate_Handler,
		},
		{
			MethodName: "IpsecSADecryptUpdate",
			Handler:    _Ipsec_IpsecSADecryptUpdate_Handler,
		},
		{
			MethodName: "IpsecSADecryptDelete",
			Handler:    _Ipsec_IpsecSADecryptDelete_Handler,
		},
		{
			MethodName: "IpsecSADecryptGet",
			Handler:    _Ipsec_IpsecSADecryptGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ipsec.proto.draft",
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyInfo != nil {
		nn1, err := m.KeyInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Key_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *Key_KeyLocation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyLocation))
	return i, nil
}
func (m *IpsecSAEncrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n3, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.AuthenticationKey.Size()))
		n4, err := m.AuthenticationKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.EncryptionAlgorithm != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.EncryptionAlgorithm))
	}
	if m.EncryptionKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.EncryptionKey.Size()))
		n5, err := m.EncryptionKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.LocalGatewayIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.LocalGatewayIp.Size()))
		n6, err := m.LocalGatewayIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.RemoteGatewayIp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RemoteGatewayIp.Size()))
		n7, err := m.RemoteGatewayIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Spi != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Spi))
	}
	if m.NatTraversalPort != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.NatTraversalPort))
	}
	if m.Salt != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Salt))
	}
	if m.Iv != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Iv))
	}
	return i, nil
}

func (m *IpsecSADecrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.AuthenticationKey.Size()))
		n10, err := m.AuthenticationKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DecryptionAlgorithm != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.DecryptionAlgorithm))
	}
	if m.RekeyDecAlgorithm != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RekeyDecAlgorithm))
	}
	if m.DecryptionKey != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.DecryptionKey.Size()))
		n11, err := m.DecryptionKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.RekeyAuthenticationKey != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RekeyAuthenticationKey.Size()))
		n12, err := m.RekeyAuthenticationKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.RekeyDecryptionKey != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RekeyDecryptionKey.Size()))
		n13, err := m.RekeyDecryptionKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.LocalGatewayIp != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.LocalGatewayIp.Size()))
		n14, err := m.LocalGatewayIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.RemoteGatewayIp != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RemoteGatewayIp.Size()))
		n15, err := m.RemoteGatewayIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Spi != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Spi))
	}
	if m.RekeyActive != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RekeyActive))
	}
	if m.RekeySpi != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.RekeySpi))
	}
	if m.Salt != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Salt))
	}
	return i, nil
}

func (m *IpsecRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n16, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n18, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x32
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Protocol) > 0 {
		dAtA20 := make([]byte, len(m.Protocol)*10)
		var j19 int
		for _, num := range m.Protocol {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if m.L4AppInfo != nil {
		nn21, err := m.L4AppInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.IpSecSAInfo != nil {
		nn22, err := m.IpSecSAInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *IpsecRuleSpec_PortInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.PortInfo.Size()))
		n23, err := m.PortInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *IpsecRuleSpec_EspInfo_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EspInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.EspInfo.Size()))
		n24, err := m.EspInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *IpsecRuleSpec_EncSecurityAssociation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EncSecurityAssociation != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.EncSecurityAssociation.Size()))
		n25, err := m.EncSecurityAssociation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *IpsecRuleSpec_DecSecurityAssociation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DecSecurityAssociation != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.DecSecurityAssociation.Size()))
		n26, err := m.DecSecurityAssociation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *IpsecRuleSpec_AppPortInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleSpec_AppPortInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x12
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecRuleSpec_EspInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleSpec_EspInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Spi))
	}
	return i, nil
}

func (m *IpsecRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *IpsecRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Status.Size()))
		n27, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *IpsecRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n28, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n29, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *IpsecRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA31 := make([]byte, len(m.ApiStatus)*10)
		var j30 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	return i, nil
}

func (m *IpsecRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n32, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n33, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *IpsecRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSAEncryptRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSAEncryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpseccbHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IpseccbHandle))
		i += 8
	}
	return i, nil
}

func (m *IpsecSAEncryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.IpseccbStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.IpseccbStatus.Size()))
		n34, err := m.IpseccbStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *IpsecSAEncryptResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSAEncryptDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n35, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n36, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *IpsecSAEncryptDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSAEncryptDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA38 := make([]byte, len(m.ApiStatus)*10)
		var j37 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	return i, nil
}

func (m *IpsecSAEncryptGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n39, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n40, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *IpsecSAEncryptGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSADecryptRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSADecryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpseccbHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IpseccbHandle))
		i += 8
	}
	return i, nil
}

func (m *IpsecSADecryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.IpseccbStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.IpseccbStatus.Size()))
		n41, err := m.IpseccbStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *IpsecSADecryptResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSADecryptDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n42, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n43, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *IpsecSADecryptDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IpsecSADecryptDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA45 := make([]byte, len(m.ApiStatus)*10)
		var j44 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(j44))
		i += copy(dAtA[i:], dAtA45[:j44])
	}
	return i, nil
}

func (m *IpsecSADecryptGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.Meta.Size()))
		n46, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsecDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n47, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *IpsecSADecryptGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsecDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintIpsecDraft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Key) Size() (n int) {
	var l int
	_ = l
	if m.KeyInfo != nil {
		n += m.KeyInfo.Size()
	}
	return n
}

func (m *Key_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}
func (m *Key_KeyLocation) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovIpsecDraft(uint64(m.KeyLocation))
	return n
}
func (m *IpsecSAEncrypt) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		n += 1 + sovIpsecDraft(uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		l = m.AuthenticationKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.EncryptionAlgorithm != 0 {
		n += 1 + sovIpsecDraft(uint64(m.EncryptionAlgorithm))
	}
	if m.EncryptionKey != nil {
		l = m.EncryptionKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.LocalGatewayIp != nil {
		l = m.LocalGatewayIp.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.RemoteGatewayIp != nil {
		l = m.RemoteGatewayIp.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.Spi != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Spi))
	}
	if m.NatTraversalPort != 0 {
		n += 1 + sovIpsecDraft(uint64(m.NatTraversalPort))
	}
	if m.Salt != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Salt))
	}
	if m.Iv != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Iv))
	}
	return n
}

func (m *IpsecSADecrypt) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		n += 1 + sovIpsecDraft(uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		l = m.AuthenticationKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.DecryptionAlgorithm != 0 {
		n += 1 + sovIpsecDraft(uint64(m.DecryptionAlgorithm))
	}
	if m.RekeyDecAlgorithm != 0 {
		n += 1 + sovIpsecDraft(uint64(m.RekeyDecAlgorithm))
	}
	if m.DecryptionKey != nil {
		l = m.DecryptionKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.RekeyAuthenticationKey != nil {
		l = m.RekeyAuthenticationKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.RekeyDecryptionKey != nil {
		l = m.RekeyDecryptionKey.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.LocalGatewayIp != nil {
		l = m.LocalGatewayIp.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.RemoteGatewayIp != nil {
		l = m.RemoteGatewayIp.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.Spi != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Spi))
	}
	if m.RekeyActive != 0 {
		n += 1 + sovIpsecDraft(uint64(m.RekeyActive))
	}
	if m.RekeySpi != 0 {
		n += 1 + sovIpsecDraft(uint64(m.RekeySpi))
	}
	if m.Salt != 0 {
		n += 2 + sovIpsecDraft(uint64(m.Salt))
	}
	return n
}

func (m *IpsecRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	if len(m.Protocol) > 0 {
		l = 0
		for _, e := range m.Protocol {
			l += sovIpsecDraft(uint64(e))
		}
		n += 1 + sovIpsecDraft(uint64(l)) + l
	}
	if m.L4AppInfo != nil {
		n += m.L4AppInfo.Size()
	}
	if m.IpSecSAInfo != nil {
		n += m.IpSecSAInfo.Size()
	}
	return n
}

func (m *IpsecRuleSpec_PortInfo) Size() (n int) {
	var l int
	_ = l
	if m.PortInfo != nil {
		l = m.PortInfo.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}
func (m *IpsecRuleSpec_EspInfo_) Size() (n int) {
	var l int
	_ = l
	if m.EspInfo != nil {
		l = m.EspInfo.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}
func (m *IpsecRuleSpec_EncSecurityAssociation) Size() (n int) {
	var l int
	_ = l
	if m.EncSecurityAssociation != nil {
		l = m.EncSecurityAssociation.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}
func (m *IpsecRuleSpec_DecSecurityAssociation) Size() (n int) {
	var l int
	_ = l
	if m.DecSecurityAssociation != nil {
		l = m.DecSecurityAssociation.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}
func (m *IpsecRuleSpec_AppPortInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecRuleSpec_EspInfo) Size() (n int) {
	var l int
	_ = l
	if m.Spi != 0 {
		n += 1 + sovIpsecDraft(uint64(m.Spi))
	}
	return n
}

func (m *IpsecRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *IpsecRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsecDraft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovIpsecDraft(uint64(e))
		}
		n += 1 + sovIpsecDraft(uint64(l)) + l
	}
	return n
}

func (m *IpsecRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSAEncryptRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSAEncryptStatus) Size() (n int) {
	var l int
	_ = l
	if m.IpseccbHandle != 0 {
		n += 9
	}
	return n
}

func (m *IpsecSAEncryptResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsecDraft(uint64(m.ApiStatus))
	}
	if m.IpseccbStatus != nil {
		l = m.IpseccbStatus.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSAEncryptResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSAEncryptDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSAEncryptDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSAEncryptDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovIpsecDraft(uint64(e))
		}
		n += 1 + sovIpsecDraft(uint64(l)) + l
	}
	return n
}

func (m *IpsecSAEncryptGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSAEncryptGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSADecryptRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSADecryptStatus) Size() (n int) {
	var l int
	_ = l
	if m.IpseccbHandle != 0 {
		n += 9
	}
	return n
}

func (m *IpsecSADecryptResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsecDraft(uint64(m.ApiStatus))
	}
	if m.IpseccbStatus != nil {
		l = m.IpseccbStatus.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSADecryptResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSADecryptDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSADecryptDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func (m *IpsecSADecryptDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovIpsecDraft(uint64(e))
		}
		n += 1 + sovIpsecDraft(uint64(l)) + l
	}
	return n
}

func (m *IpsecSADecryptGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovIpsecDraft(uint64(l))
	}
	return n
}

func (m *IpsecSADecryptGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsecDraft(uint64(l))
		}
	}
	return n
}

func sovIpsecDraft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIpsecDraft(x uint64) (n int) {
	return sovIpsecDraft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyInfo = &Key_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLocation", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyInfo = &Key_KeyLocation{v}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSAEncryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IpsecProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgorithm", wireType)
			}
			m.AuthenticationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationAlgorithm |= (AuthenticationAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticationKey == nil {
				m.AuthenticationKey = &Key{}
			}
			if err := m.AuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgorithm", wireType)
			}
			m.EncryptionAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionAlgorithm |= (EncryptionAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionKey == nil {
				m.EncryptionKey = &Key{}
			}
			if err := m.EncryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalGatewayIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalGatewayIp == nil {
				m.LocalGatewayIp = &IPAddress{}
			}
			if err := m.LocalGatewayIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteGatewayIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteGatewayIp == nil {
				m.RemoteGatewayIp = &IPAddress{}
			}
			if err := m.RemoteGatewayIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatTraversalPort", wireType)
			}
			m.NatTraversalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatTraversalPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iv", wireType)
			}
			m.Iv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSADecryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IpsecProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgorithm", wireType)
			}
			m.AuthenticationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationAlgorithm |= (AuthenticationAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticationKey == nil {
				m.AuthenticationKey = &Key{}
			}
			if err := m.AuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionAlgorithm", wireType)
			}
			m.DecryptionAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecryptionAlgorithm |= (EncryptionAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecAlgorithm", wireType)
			}
			m.RekeyDecAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeyDecAlgorithm |= (EncryptionAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecryptionKey == nil {
				m.DecryptionKey = &Key{}
			}
			if err := m.DecryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyAuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RekeyAuthenticationKey == nil {
				m.RekeyAuthenticationKey = &Key{}
			}
			if err := m.RekeyAuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RekeyDecryptionKey == nil {
				m.RekeyDecryptionKey = &Key{}
			}
			if err := m.RekeyDecryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalGatewayIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalGatewayIp == nil {
				m.LocalGatewayIp = &IPAddress{}
			}
			if err := m.LocalGatewayIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteGatewayIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteGatewayIp == nil {
				m.RemoteGatewayIp = &IPAddress{}
			}
			if err := m.RemoteGatewayIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyActive", wireType)
			}
			m.RekeyActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeyActive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeySpi", wireType)
			}
			m.RekeySpi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeySpi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressObj{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressObj{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v IPProtocol
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IPProtocol(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Protocol = append(m.Protocol, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsecDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v IPProtocol
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsecDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IPProtocol(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Protocol = append(m.Protocol, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecRuleSpec_AppPortInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &IpsecRuleSpec_PortInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecRuleSpec_EspInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &IpsecRuleSpec_EspInfo_{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncSecurityAssociation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecSAEncrypt{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpSecSAInfo = &IpsecRuleSpec_EncSecurityAssociation{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecSecurityAssociation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecSADecrypt{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpSecSAInfo = &IpsecRuleSpec_DecSecurityAssociation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleSpec_AppPortInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppPortInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppPortInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleSpec_EspInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EspInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EspInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &IpsecRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsecDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsecDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSAEncrypt{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpseccbHandle", wireType)
			}
			m.IpseccbHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IpseccbHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpseccbStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpseccbStatus == nil {
				m.IpseccbStatus = &IpsecSAEncryptStatus{}
			}
			if err := m.IpseccbStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSAEncryptResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSAEncryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSAEncryptDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsecDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsecDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSAEncryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSAEncryptGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSADecrypt{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpseccbHandle", wireType)
			}
			m.IpseccbHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IpseccbHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpseccbStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpseccbStatus == nil {
				m.IpseccbStatus = &IpsecSADecryptStatus{}
			}
			if err := m.IpseccbStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSADecryptResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSADecryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSADecryptDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsecDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsecDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &IpsecSADecryptKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSADecryptGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpsecDraft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpsecDraft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsecDraft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIpsecDraft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpsecDraft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpsecDraft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpsecDraft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpsecDraft   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ipsec.proto.draft", fileDescriptorIpsecDraft) }

var fileDescriptorIpsecDraft = []byte{
	// 1781 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4d, 0x73, 0xe3, 0x48,
	0x19, 0xb6, 0xe2, 0xc4, 0x76, 0x5e, 0x7f, 0x8c, 0xd2, 0xc9, 0x66, 0xb4, 0xce, 0x26, 0xf1, 0x08,
	0x86, 0x0a, 0x53, 0xe0, 0x61, 0xbd, 0x03, 0x6c, 0xa6, 0x86, 0x9a, 0x92, 0x1d, 0x33, 0xf6, 0x8e,
	0x1d, 0x7b, 0xe5, 0xec, 0x32, 0x0b, 0x05, 0x2a, 0x8d, 0xdc, 0x49, 0xb4, 0xf1, 0xd8, 0x42, 0x52,
	0x02, 0x2e, 0x4e, 0x50, 0xcb, 0x91, 0x3b, 0x7f, 0x80, 0x23, 0x17, 0x7e, 0x04, 0xc5, 0x11, 0xfe,
	0xc0, 0x14, 0x35, 0xdc, 0x38, 0xee, 0x2f, 0xa0, 0xba, 0xd5, 0xfa, 0x74, 0xdb, 0x4e, 0xe6, 0x83,
	0xcb, 0x1e, 0x52, 0x91, 0xf4, 0x3e, 0xef, 0xd3, 0xef, 0xd7, 0xd3, 0x6a, 0x19, 0x36, 0x4c, 0xcb,
	0xc1, 0x46, 0xd5, 0xb2, 0x27, 0xee, 0xa4, 0x3a, 0xb4, 0xf5, 0x53, 0x17, 0xad, 0xd1, 0x47, 0xe5,
	0xbc, 0x3b, 0xb5, 0xb0, 0xe3, 0x59, 0xca, 0xb9, 0x8b, 0x73, 0xef, 0x4a, 0xfe, 0x04, 0xd2, 0x4f,
	0xf1, 0x14, 0x21, 0x48, 0x5f, 0xe0, 0xa9, 0x24, 0x54, 0x84, 0x83, 0x42, 0x2b, 0xa5, 0x92, 0x1b,
	0xf4, 0x2d, 0x28, 0x5c, 0xe0, 0xa9, 0x36, 0x9a, 0x18, 0xba, 0x6b, 0x4e, 0xc6, 0xd2, 0x4a, 0x45,
	0x38, 0x28, 0xb6, 0x52, 0x6a, 0xfe, 0x02, 0x4f, 0x3b, 0xec, 0x61, 0x1d, 0x20, 0x47, 0x40, 0xe6,
	0xf8, 0x74, 0x22, 0xff, 0x6d, 0x0d, 0x4a, 0x6d, 0xb2, 0xd8, 0x40, 0x69, 0x8e, 0x0d, 0x7b, 0x6a,
	0xb9, 0xe8, 0x2e, 0xac, 0xbe, 0xc0, 0xae, 0x4e, 0x89, 0xf3, 0xb5, 0x8d, 0xaa, 0x17, 0x44, 0xef,
	0xf9, 0x97, 0xd8, 0x70, 0xbb, 0xd8, 0xd5, 0x55, 0x6a, 0x46, 0x9f, 0x42, 0x91, 0xb0, 0x4c, 0x6c,
	0xed, 0x5c, 0x1f, 0x0f, 0x47, 0x98, 0xae, 0x95, 0xaf, 0xed, 0x54, 0x2f, 0xce, 0xab, 0x71, 0xc6,
	0xa7, 0x78, 0xda, 0xa2, 0x90, 0xba, 0xf8, 0xf5, 0xcb, 0xfd, 0xc2, 0x15, 0x1e, 0x9b, 0x06, 0x7e,
	0x28, 0x5f, 0xe0, 0xa9, 0x4c, 0x03, 0xeb, 0xd9, 0x9e, 0x19, 0xfd, 0x00, 0x72, 0x34, 0x43, 0x63,
	0x32, 0x92, 0xd2, 0x15, 0xe1, 0xa0, 0x54, 0xdb, 0xaa, 0x7a, 0xc5, 0xa1, 0x84, 0x7d, 0x66, 0x53,
	0x03, 0x14, 0xfa, 0x02, 0x24, 0xfd, 0xd2, 0x3d, 0xc7, 0x63, 0xd7, 0xf4, 0x92, 0xd3, 0xf4, 0xd1,
	0xd9, 0xc4, 0x36, 0xdd, 0xf3, 0x17, 0xd2, 0x2a, 0x65, 0xd8, 0x63, 0x0c, 0x4a, 0x0c, 0xa6, 0xf8,
	0x28, 0xf5, 0xb6, 0xce, 0x37, 0xa0, 0x43, 0x40, 0x09, 0x6a, 0x52, 0xed, 0x35, 0x9a, 0x24, 0x30,
	0xd2, 0xa7, 0x78, 0xaa, 0x6e, 0xc4, 0x51, 0xa4, 0x33, 0x5d, 0xd8, 0xc2, 0x5e, 0xea, 0xf1, 0x88,
	0x32, 0x34, 0xa2, 0x32, 0x73, 0x6e, 0x06, 0x90, 0x30, 0x9a, 0x4d, 0x3c, 0xfb, 0x10, 0x7d, 0x08,
	0xa5, 0x08, 0x1d, 0x89, 0x22, 0x3b, 0x13, 0x45, 0x31, 0x44, 0x90, 0x08, 0x1e, 0x82, 0x48, 0x66,
	0x60, 0xa4, 0x9d, 0xe9, 0x2e, 0xfe, 0x8d, 0x3e, 0xd5, 0x4c, 0x4b, 0xca, 0x51, 0x27, 0x91, 0xf5,
	0xb3, 0xdd, 0x57, 0x86, 0x43, 0x1b, 0x3b, 0x8e, 0x5a, 0xa2, 0xc8, 0x27, 0x1e, 0xb0, 0x6d, 0xa1,
	0x47, 0xb0, 0x61, 0xe3, 0x17, 0x13, 0x17, 0x47, 0x9d, 0xd7, 0xe7, 0x38, 0xdf, 0xf2, 0xa0, 0xa1,
	0xb7, 0x08, 0x69, 0xc7, 0x32, 0x25, 0x20, 0x83, 0xa7, 0x92, 0x4b, 0xf4, 0x3d, 0x40, 0x63, 0xdd,
	0xd5, 0x5c, 0x5b, 0xbf, 0xc2, 0xb6, 0xa3, 0x8f, 0x34, 0x6b, 0x62, 0xbb, 0x52, 0x9e, 0x02, 0xc4,
	0xb1, 0xee, 0x9e, 0xf8, 0x86, 0xfe, 0xc4, 0x76, 0x11, 0x82, 0x55, 0x47, 0x1f, 0xb9, 0x52, 0x81,
	0xda, 0xe9, 0x35, 0x2a, 0xc1, 0x8a, 0x79, 0x25, 0x15, 0x2b, 0xc2, 0xc1, 0xaa, 0xba, 0x62, 0x5e,
	0xc9, 0x5f, 0x65, 0x83, 0xa1, 0x3d, 0xc2, 0x6f, 0x7b, 0x68, 0x19, 0xe3, 0x37, 0x71, 0x68, 0x87,
	0xf8, 0xf5, 0x86, 0x36, 0xf4, 0x0b, 0x23, 0xf9, 0x04, 0x36, 0x6d, 0x4c, 0x6a, 0x3d, 0xc4, 0x46,
	0x84, 0x2d, 0xbb, 0x94, 0x6d, 0x83, 0xba, 0x1d, 0x61, 0x23, 0x26, 0x80, 0x48, 0x68, 0x24, 0xa3,
	0xdc, 0xac, 0x00, 0x42, 0x04, 0xc9, 0xe6, 0x08, 0x24, 0x6f, 0x79, 0x4e, 0x39, 0xd6, 0x67, 0x9c,
	0xb7, 0x29, 0x56, 0x99, 0xa9, 0xc9, 0x23, 0xd8, 0x0a, 0x92, 0x88, 0x2e, 0x0f, 0x33, 0x0c, 0xc8,
	0x8f, 0x7a, 0x89, 0x08, 0xf3, 0x6f, 0x22, 0xc2, 0xc2, 0x0d, 0x45, 0x58, 0x0c, 0x45, 0x78, 0x07,
	0x0a, 0xac, 0x1e, 0x86, 0x6b, 0x5e, 0x61, 0xa9, 0x44, 0x4d, 0x79, 0x2f, 0x6f, 0xfa, 0x08, 0xed,
	0xc0, 0xba, 0x07, 0x21, 0xae, 0xb7, 0xa8, 0x3d, 0x47, 0x1f, 0x0c, 0x2c, 0x33, 0x90, 0xa5, 0x18,
	0xca, 0x52, 0xfe, 0x7b, 0x06, 0x8a, 0x74, 0xc6, 0xd5, 0xcb, 0x11, 0x1e, 0x58, 0xd8, 0xb8, 0xae,
	0x0a, 0x3b, 0x7c, 0x15, 0x6e, 0x07, 0x2a, 0x24, 0x84, 0xd7, 0x16, 0xe0, 0x4f, 0xa1, 0x74, 0x65,
	0x9f, 0x92, 0xbe, 0xf8, 0x74, 0x69, 0x56, 0xa7, 0x8b, 0xf3, 0xea, 0xe7, 0xf6, 0x69, 0x48, 0x54,
	0xfa, 0xfa, 0xe5, 0x3e, 0x30, 0x22, 0x1b, 0x9f, 0xaa, 0x85, 0xab, 0x88, 0x15, 0x3d, 0x80, 0xbc,
	0x63, 0x1b, 0x9a, 0xee, 0x15, 0x55, 0x5a, 0xad, 0xa4, 0x0f, 0xf2, 0xb5, 0xcd, 0x64, 0xb1, 0x7b,
	0xcf, 0xbf, 0x54, 0xc1, 0xb1, 0x0d, 0x76, 0x4b, 0xbc, 0x86, 0x8e, 0x1b, 0x78, 0x65, 0x16, 0x78,
	0x0d, 0x1d, 0xd7, 0xf7, 0xfa, 0x7e, 0x64, 0xd3, 0xc8, 0x56, 0xd2, 0x07, 0xa5, 0xa0, 0x58, 0xed,
	0x3e, 0x67, 0xc7, 0x78, 0x0c, 0xeb, 0x64, 0xd3, 0xa4, 0xaf, 0x6c, 0x36, 0xfb, 0x95, 0xe8, 0x26,
	0xe3, 0x37, 0xa0, 0xaa, 0x58, 0x16, 0xd9, 0x45, 0xdb, 0xe3, 0xd3, 0x49, 0x2b, 0xa5, 0xe6, 0x2c,
	0x76, 0x8d, 0x0e, 0x21, 0x87, 0x1d, 0xcb, 0xf3, 0xf7, 0xc6, 0xff, 0x03, 0xae, 0x7f, 0xd3, 0xb1,
	0x98, 0x6f, 0x16, 0x7b, 0x97, 0xe8, 0x53, 0x90, 0xf0, 0xd8, 0xd0, 0x1c, 0x6c, 0x5c, 0xda, 0xa6,
	0x3b, 0xd5, 0x74, 0xc7, 0x99, 0x18, 0xa6, 0x77, 0xbc, 0xf0, 0x74, 0xf0, 0x5e, 0x94, 0x2a, 0x78,
	0xeb, 0xb7, 0x04, 0x75, 0x1b, 0x8f, 0x8d, 0x01, 0xf3, 0x53, 0x42, 0x37, 0x42, 0x49, 0x76, 0x05,
	0x2e, 0x65, 0x9e, 0x47, 0xc9, 0x74, 0x45, 0x28, 0x87, 0x98, 0x47, 0x59, 0xfe, 0xbd, 0x00, 0xf9,
	0x48, 0xf2, 0xe8, 0x63, 0x28, 0x91, 0xb6, 0xd0, 0xaa, 0xd9, 0xfa, 0xf8, 0x0c, 0x4b, 0x02, 0xed,
	0x0c, 0x62, 0x65, 0xee, 0x3c, 0x20, 0x50, 0x95, 0x58, 0xd4, 0xc2, 0xd0, 0x71, 0x83, 0x3b, 0xe2,
	0x49, 0xc6, 0x20, 0xe2, 0xb9, 0x32, 0xdf, 0xd3, 0xb1, 0x8d, 0xe0, 0xae, 0xbc, 0x03, 0x59, 0x56,
	0x3f, 0x5f, 0x80, 0x42, 0x20, 0xc0, 0x7a, 0x1e, 0xd6, 0x3b, 0x0f, 0x14, 0x8b, 0x9a, 0xeb, 0x45,
	0xc8, 0xb7, 0xad, 0x01, 0xc9, 0x8c, 0xdc, 0xca, 0x4d, 0xd8, 0x0c, 0xda, 0xa0, 0xe2, 0x5f, 0x5f,
	0x62, 0xc7, 0xed, 0x3a, 0x67, 0xa8, 0x0a, 0x59, 0xdb, 0xbb, 0x63, 0xc1, 0x6f, 0xf1, 0x7a, 0xa6,
	0xfa, 0x20, 0xf9, 0xbb, 0x70, 0x2b, 0xb4, 0xb8, 0xba, 0x7b, 0xe9, 0xa0, 0x6d, 0xc8, 0x30, 0x4d,
	0x90, 0x50, 0x32, 0x2a, 0xbb, 0x93, 0xbf, 0x12, 0x60, 0x23, 0xb2, 0xa4, 0x63, 0x4d, 0xc6, 0x0e,
	0x46, 0x8f, 0x01, 0x74, 0xcb, 0xd4, 0x1c, 0xea, 0x4b, 0x3d, 0x4a, 0xc1, 0x6e, 0xa3, 0x58, 0xa6,
	0xc7, 0x59, 0x2f, 0xfd, 0xf7, 0xe5, 0x7e, 0x04, 0xa7, 0xae, 0xeb, 0xbe, 0x09, 0x55, 0x21, 0xc3,
	0x9c, 0x7d, 0x45, 0x27, 0x03, 0xf6, 0x5c, 0x18, 0x4a, 0xee, 0xc0, 0xd6, 0x4c, 0x14, 0x24, 0xf3,
	0x07, 0x90, 0xb3, 0xd9, 0x2d, 0x4b, 0x5d, 0x4a, 0x32, 0xf9, 0x70, 0x35, 0x40, 0xca, 0xbf, 0x83,
	0xed, 0xc0, 0x7c, 0x84, 0x47, 0xd8, 0xf5, 0x8b, 0x79, 0xdd, 0x7d, 0xe9, 0xe1, 0x8d, 0xf6, 0xa5,
	0xd8, 0x2e, 0x24, 0x9f, 0xc0, 0xfb, 0xfc, 0xc5, 0x49, 0x3e, 0x3f, 0x4e, 0x76, 0x72, 0x37, 0x99,
	0x4e, 0xcc, 0x25, 0x6c, 0x69, 0x17, 0xca, 0x33, 0x90, 0xb0, 0x4c, 0xf7, 0x13, 0xfd, 0x4a, 0xf3,
	0xfa, 0x15, 0xe9, 0x8f, 0xfc, 0xdb, 0xc8, 0xa0, 0x3d, 0xc1, 0xee, 0xff, 0xb1, 0x3c, 0xc7, 0x91,
	0xde, 0x84, 0x2b, 0x7b, 0xbd, 0x4e, 0xd4, 0xa6, 0x9c, 0xac, 0x4d, 0x88, 0x0f, 0x0b, 0xf3, 0x14,
	0xa4, 0xf8, 0x76, 0x13, 0x61, 0xbc, 0x9f, 0x64, 0xe4, 0x6f, 0x50, 0x21, 0xd9, 0x4f, 0xd8, 0x18,
	0x06, 0x26, 0x36, 0xce, 0x77, 0xa1, 0x44, 0x1d, 0x8d, 0xe7, 0x5a, 0x4c, 0x45, 0x45, 0xf6, 0x94,
	0xe5, 0xf6, 0x27, 0x81, 0x25, 0x17, 0x09, 0x86, 0x29, 0xea, 0xfe, 0x75, 0x14, 0x15, 0x55, 0x50,
	0x3d, 0x5c, 0x32, 0xa6, 0xa4, 0x1d, 0x6e, 0x0a, 0xcc, 0xdf, 0x8f, 0x87, 0x75, 0xf9, 0x73, 0x36,
	0x8a, 0x33, 0xe1, 0x90, 0xe2, 0x1c, 0xce, 0x48, 0x6b, 0x97, 0x5f, 0x9d, 0x59, 0x7d, 0xfd, 0x51,
	0x80, 0x9d, 0x38, 0xe8, 0xb5, 0x54, 0xf6, 0xf8, 0xe6, 0x1f, 0x8e, 0xf1, 0x59, 0xfa, 0x15, 0xec,
	0x2d, 0x08, 0x83, 0x24, 0xf9, 0x28, 0x39, 0x01, 0x32, 0x37, 0xc7, 0x39, 0xa2, 0x53, 0x61, 0x9f,
	0x8f, 0x7b, 0x03, 0xe5, 0xfd, 0x41, 0x48, 0x0e, 0xec, 0xcd, 0xf5, 0xf7, 0xc6, 0x85, 0x7b, 0x96,
	0xec, 0x5f, 0x5c, 0x89, 0x87, 0xc9, 0xaa, 0xed, 0x73, 0xab, 0xb6, 0x58, 0x8e, 0xec, 0x55, 0x7d,
	0x03, 0x39, 0xfa, 0x1e, 0x1c, 0x39, 0x32, 0xd3, 0x6b, 0xcb, 0x31, 0x08, 0xe6, 0x1d, 0xcb, 0x31,
	0x16, 0xe7, 0x7c, 0x39, 0x26, 0xc2, 0xb9, 0x96, 0x1c, 0x13, 0x3e, 0x7c, 0x39, 0x32, 0xd0, 0xbb,
	0x92, 0x63, 0xf2, 0x93, 0x78, 0x9e, 0x1c, 0x79, 0x61, 0x5c, 0x47, 0x8e, 0x3c, 0x3f, 0x9e, 0x1c,
	0x13, 0xb8, 0xb7, 0x23, 0x47, 0x46, 0xfa, 0x4e, 0xe4, 0xb8, 0xb8, 0x70, 0xcf, 0x92, 0xfd, 0xbb,
	0x99, 0x1c, 0x67, 0x9c, 0x82, 0x92, 0xdd, 0xfb, 0x19, 0xfb, 0x30, 0xf3, 0x3f, 0x25, 0xd0, 0x6d,
	0xd8, 0x6c, 0xf7, 0x07, 0xcd, 0x86, 0xd6, 0x57, 0x7b, 0x27, 0xbd, 0x46, 0xaf, 0xa3, 0x1d, 0xf7,
	0x8e, 0x9b, 0x62, 0x0a, 0xbd, 0x07, 0x1b, 0x09, 0x83, 0xd2, 0x12, 0x05, 0xb4, 0x0d, 0x28, 0xf1,
	0xb8, 0x39, 0xe8, 0x8b, 0x2b, 0xf7, 0xfe, 0x92, 0x86, 0x4d, 0xce, 0x47, 0x3b, 0xda, 0x85, 0xf7,
	0x9b, 0xc7, 0x0d, 0xf5, 0x8b, 0xfe, 0x49, 0xbb, 0x77, 0xac, 0x29, 0x9d, 0x27, 0x3d, 0xb5, 0x7d,
	0xd2, 0xea, 0xfa, 0xab, 0x7c, 0x1b, 0x2a, 0x5c, 0xb3, 0xd2, 0x1c, 0x68, 0x4f, 0x1a, 0x5d, 0xed,
	0xc3, 0xda, 0xc7, 0xa2, 0xb0, 0x14, 0x55, 0xfb, 0xe1, 0x8f, 0xc4, 0x95, 0x85, 0xa8, 0x06, 0xe3,
	0x4a, 0x2f, 0x47, 0x1d, 0xd6, 0xc4, 0xd5, 0xa5, 0x28, 0xb2, 0xe2, 0xda, 0x62, 0x54, 0xbd, 0x41,
	0x57, 0xcc, 0x2c, 0x47, 0x1d, 0xd6, 0xc4, 0xec, 0x52, 0x14, 0x59, 0x31, 0x37, 0xb7, 0x9c, 0x47,
	0xcd, 0xc1, 0x47, 0xe2, 0x3a, 0xaa, 0xc0, 0x07, 0x5c, 0x73, 0xa3, 0xa5, 0x90, 0x3f, 0x11, 0xee,
	0xfd, 0x55, 0x80, 0xdb, 0x73, 0x7e, 0x3c, 0x42, 0x77, 0x60, 0x57, 0xf9, 0xec, 0xa4, 0xd5, 0x3c,
	0x3e, 0x69, 0x37, 0x14, 0x7e, 0xbf, 0xca, 0xb0, 0x9d, 0x84, 0x78, 0x3d, 0x10, 0x85, 0x39, 0xb6,
	0x46, 0xa3, 0x2b, 0xae, 0x90, 0x31, 0x4b, 0xd8, 0x5a, 0x5d, 0xa5, 0x21, 0xa6, 0xd1, 0x1e, 0x94,
	0x79, 0x4e, 0xf5, 0x86, 0x36, 0x68, 0x29, 0xe2, 0x6a, 0xed, 0x5f, 0x39, 0x58, 0xa3, 0x13, 0x8b,
	0x3a, 0x91, 0x8f, 0x98, 0x86, 0x8d, 0x75, 0x17, 0xa3, 0xf2, 0xec, 0xd9, 0xdf, 0x17, 0x49, 0x79,
	0x67, 0xde, 0x77, 0x41, 0xd7, 0x39, 0x93, 0x53, 0x31, 0xb6, 0xcf, 0xac, 0xe1, 0x1b, 0xb2, 0x3d,
	0x8b, 0xb0, 0x79, 0x9b, 0x10, 0xaa, 0x2c, 0x3c, 0xc8, 0x13, 0xce, 0x3b, 0xf3, 0x10, 0x51, 0xe6,
	0x63, 0x28, 0x44, 0x8f, 0xbb, 0x68, 0x77, 0xfe, 0x19, 0x98, 0x70, 0x2e, 0x36, 0xcb, 0x29, 0xf4,
	0x8b, 0xe4, 0x89, 0x96, 0x95, 0x72, 0x7f, 0xce, 0x59, 0x2f, 0x60, 0xae, 0x2c, 0x3c, 0x0c, 0xce,
	0x21, 0x67, 0x95, 0x7d, 0x2b, 0xe4, 0x67, 0x49, 0x72, 0x56, 0xe8, 0xbb, 0xcb, 0x4f, 0x70, 0x64,
	0x89, 0xef, 0x2c, 0x84, 0x45, 0x17, 0xfa, 0x25, 0xfb, 0x02, 0x8e, 0x9e, 0x6b, 0x90, 0xbc, 0xe4,
	0xc4, 0x43, 0x96, 0xb8, 0x06, 0x26, 0x56, 0x24, 0xb6, 0x4f, 0xf3, 0x3b, 0x30, 0x73, 0x5c, 0x4a,
	0x16, 0x69, 0xf6, 0xcc, 0xc0, 0x23, 0xe7, 0x77, 0xe0, 0xf5, 0xc8, 0xcf, 0x92, 0xe4, 0xfc, 0x0e,
	0xcc, 0x79, 0xd9, 0x27, 0x3b, 0x30, 0xef, 0x9d, 0x1d, 0xeb, 0x40, 0xf8, 0x2a, 0x43, 0xf2, 0x92,
	0x97, 0x1c, 0xa7, 0x03, 0x3c, 0x8c, 0x9c, 0xaa, 0x97, 0xff, 0xf1, 0x6a, 0x4f, 0xf8, 0xe7, 0xab,
	0x3d, 0xe1, 0xdf, 0xaf, 0xf6, 0x84, 0x3f, 0xff, 0x67, 0x2f, 0xf5, 0xf3, 0xdc, 0xb9, 0x3e, 0xa2,
	0xbf, 0xa9, 0x3d, 0xcf, 0xd0, 0x7f, 0x1f, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xd0, 0x03,
	0x35, 0x7c, 0x1b, 0x00, 0x00,
}
