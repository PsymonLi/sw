// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: l4lb.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// session stickiness selectors - once a session is load balanced to a backend
// server, new sessions from same client from that point on will be pinned to
// the same backend as long as there is atleast one session active towards that
// backend. once all sessions from that client age out, if a new session comes
// from same client, LB algorithm can pick a new backend again
type SessionAffinity int32

const (
	SessionAffinity_L4LB_SESSION_AFFINITY_NONE      SessionAffinity = 0
	SessionAffinity_L4LB_SESSION_AFFINITY_SIP       SessionAffinity = 1
	SessionAffinity_L4LB_SESSION_AFFINITY_SIP_SPORT SessionAffinity = 2
)

var SessionAffinity_name = map[int32]string{
	0: "L4LB_SESSION_AFFINITY_NONE",
	1: "L4LB_SESSION_AFFINITY_SIP",
	2: "L4LB_SESSION_AFFINITY_SIP_SPORT",
}
var SessionAffinity_value = map[string]int32{
	"L4LB_SESSION_AFFINITY_NONE":      0,
	"L4LB_SESSION_AFFINITY_SIP":       1,
	"L4LB_SESSION_AFFINITY_SIP_SPORT": 2,
}

func (x SessionAffinity) String() string {
	return proto.EnumName(SessionAffinity_name, int32(x))
}
func (SessionAffinity) EnumDescriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{0} }

// supported LB algorithms
type LBAlgorithm int32

const (
	LBAlgorithm_L4LB_ALGORITHM_NONE                 LBAlgorithm = 0
	LBAlgorithm_L4LB_ALGORITHM_ROUND_ROBIN          LBAlgorithm = 1
	LBAlgorithm_L4LB_ALGORITHM_WEIGHTED_ROUND_ROBIN LBAlgorithm = 2
	LBAlgorithm_L4LB_ALGORITHM_RANDOM               LBAlgorithm = 3
	LBAlgorithm_L4LB_ALGORITHM_LEAST_CONNECTIONS    LBAlgorithm = 4
	LBAlgorithm_L4LB_ALGORITHM_PICK2_RANDOM         LBAlgorithm = 5
	LBAlgorithm_L4LB_ALGORITHM_MIN_CONNECTIONS      LBAlgorithm = 6
	LBAlgorithm_L4LB_ALGORITHM_HASH_ON_SOURCE_IP    LBAlgorithm = 7
)

var LBAlgorithm_name = map[int32]string{
	0: "L4LB_ALGORITHM_NONE",
	1: "L4LB_ALGORITHM_ROUND_ROBIN",
	2: "L4LB_ALGORITHM_WEIGHTED_ROUND_ROBIN",
	3: "L4LB_ALGORITHM_RANDOM",
	4: "L4LB_ALGORITHM_LEAST_CONNECTIONS",
	5: "L4LB_ALGORITHM_PICK2_RANDOM",
	6: "L4LB_ALGORITHM_MIN_CONNECTIONS",
	7: "L4LB_ALGORITHM_HASH_ON_SOURCE_IP",
}
var LBAlgorithm_value = map[string]int32{
	"L4LB_ALGORITHM_NONE":                 0,
	"L4LB_ALGORITHM_ROUND_ROBIN":          1,
	"L4LB_ALGORITHM_WEIGHTED_ROUND_ROBIN": 2,
	"L4LB_ALGORITHM_RANDOM":               3,
	"L4LB_ALGORITHM_LEAST_CONNECTIONS":    4,
	"L4LB_ALGORITHM_PICK2_RANDOM":         5,
	"L4LB_ALGORITHM_MIN_CONNECTIONS":      6,
	"L4LB_ALGORITHM_HASH_ON_SOURCE_IP":    7,
}

func (x LBAlgorithm) String() string {
	return proto.EnumName(LBAlgorithm_name, int32(x))
}
func (LBAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{1} }

// protocol types (i.e., traffic types) that can be load balanced based
type L4LBProtocol int32

const (
	L4LBProtocol_L4LB_PROTO_NONE L4LBProtocol = 0
	L4LBProtocol_L4LB_PROTO_TCP  L4LBProtocol = 6
	L4LBProtocol_L4LB_PROTO_UDP  L4LBProtocol = 17
)

var L4LBProtocol_name = map[int32]string{
	0:  "L4LB_PROTO_NONE",
	6:  "L4LB_PROTO_TCP",
	17: "L4LB_PROTO_UDP",
}
var L4LBProtocol_value = map[string]int32{
	"L4LB_PROTO_NONE": 0,
	"L4LB_PROTO_TCP":  6,
	"L4LB_PROTO_UDP":  17,
}

func (x L4LBProtocol) String() string {
	return proto.EnumName(L4LBProtocol_name, int32(x))
}
func (L4LBProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{2} }

// IP protocol type supported for LB probes
type L4LBProbeProtocol int32

const (
	L4LBProbeProtocol_L4LB_PROBE_PROTO_NONE L4LBProbeProtocol = 0
	L4LBProbeProtocol_L4LB_PROBE_PROTO_ICMP L4LBProbeProtocol = 1
	L4LBProbeProtocol_L4LB_PROBE_PROTO_TCP  L4LBProbeProtocol = 6
	L4LBProbeProtocol_L4LB_PROBE_PROTO_UDP  L4LBProbeProtocol = 17
)

var L4LBProbeProtocol_name = map[int32]string{
	0:  "L4LB_PROBE_PROTO_NONE",
	1:  "L4LB_PROBE_PROTO_ICMP",
	6:  "L4LB_PROBE_PROTO_TCP",
	17: "L4LB_PROBE_PROTO_UDP",
}
var L4LBProbeProtocol_value = map[string]int32{
	"L4LB_PROBE_PROTO_NONE": 0,
	"L4LB_PROBE_PROTO_ICMP": 1,
	"L4LB_PROBE_PROTO_TCP":  6,
	"L4LB_PROBE_PROTO_UDP":  17,
}

func (x L4LBProbeProtocol) String() string {
	return proto.EnumName(L4LBProbeProtocol_name, int32(x))
}
func (L4LBProbeProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{3} }

// L4LbStatus status reflects the current status of either whole service
// or each backend service instance at any given time
type L4LbStatus int32

const (
	L4LbStatus_L4LB_STATUS_NONE L4LbStatus = 0
	L4LbStatus_L4LB_STATUS_UP   L4LbStatus = 1
	L4LbStatus_L4LB_STATUS_DOWN L4LbStatus = 2
)

var L4LbStatus_name = map[int32]string{
	0: "L4LB_STATUS_NONE",
	1: "L4LB_STATUS_UP",
	2: "L4LB_STATUS_DOWN",
}
var L4LbStatus_value = map[string]int32{
	"L4LB_STATUS_NONE": 0,
	"L4LB_STATUS_UP":   1,
	"L4LB_STATUS_DOWN": 2,
}

func (x L4LbStatus) String() string {
	return proto.EnumName(L4LbStatus_name, int32(x))
}
func (L4LbStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{4} }

// LB algorithm and any parameters needed by these algorithms
type LBMethod struct {
	Algorithm LBAlgorithm `protobuf:"varint,1,opt,name=algorithm,proto3,enum=l4lb.LBAlgorithm" json:"algorithm,omitempty"`
}

func (m *LBMethod) Reset()                    { *m = LBMethod{} }
func (m *LBMethod) String() string            { return proto.CompactTextString(m) }
func (*LBMethod) ProtoMessage()               {}
func (*LBMethod) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{0} }

func (m *LBMethod) GetAlgorithm() LBAlgorithm {
	if m != nil {
		return m.Algorithm
	}
	return LBAlgorithm_L4LB_ALGORITHM_NONE
}

// HealthCheck captures the L4 LB health check configuration
type HealthCheck struct {
	ProbePort         uint32            `protobuf:"fixed32,1,opt,name=probe_port,json=probePort,proto3" json:"probe_port,omitempty"`
	ProbeProtocol     L4LBProbeProtocol `protobuf:"varint,2,opt,name=probe_protocol,json=probeProtocol,proto3,enum=l4lb.L4LBProbeProtocol" json:"probe_protocol,omitempty"`
	ProbeInterval     uint32            `protobuf:"fixed32,3,opt,name=probe_interval,json=probeInterval,proto3" json:"probe_interval,omitempty"`
	ProbesPerInterval uint32            `protobuf:"fixed32,4,opt,name=probes_per_interval,json=probesPerInterval,proto3" json:"probes_per_interval,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{1} }

func (m *HealthCheck) GetProbePort() uint32 {
	if m != nil {
		return m.ProbePort
	}
	return 0
}

func (m *HealthCheck) GetProbeProtocol() L4LBProbeProtocol {
	if m != nil {
		return m.ProbeProtocol
	}
	return L4LBProbeProtocol_L4LB_PROBE_PROTO_NONE
}

func (m *HealthCheck) GetProbeInterval() uint32 {
	if m != nil {
		return m.ProbeInterval
	}
	return 0
}

func (m *HealthCheck) GetProbesPerInterval() uint32 {
	if m != nil {
		return m.ProbesPerInterval
	}
	return 0
}

// L4LbServiceKey uniquely identifies a service
type L4LbServiceKey struct {
	ServiceIpAddress *IPAddress   `protobuf:"bytes,1,opt,name=service_ip_address,json=serviceIpAddress" json:"service_ip_address,omitempty"`
	IpProtocol       L4LBProtocol `protobuf:"varint,2,opt,name=ip_protocol,json=ipProtocol,proto3,enum=l4lb.L4LBProtocol" json:"ip_protocol,omitempty"`
	ServicePort      uint32       `protobuf:"varint,3,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty"`
}

func (m *L4LbServiceKey) Reset()                    { *m = L4LbServiceKey{} }
func (m *L4LbServiceKey) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceKey) ProtoMessage()               {}
func (*L4LbServiceKey) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{2} }

func (m *L4LbServiceKey) GetServiceIpAddress() *IPAddress {
	if m != nil {
		return m.ServiceIpAddress
	}
	return nil
}

func (m *L4LbServiceKey) GetIpProtocol() L4LBProtocol {
	if m != nil {
		return m.IpProtocol
	}
	return L4LBProtocol_L4LB_PROTO_NONE
}

func (m *L4LbServiceKey) GetServicePort() uint32 {
	if m != nil {
		return m.ServicePort
	}
	return 0
}

// L4 LB service key or handle object
type L4LbServiceKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*L4LbServiceKeyHandle_ServiceKey
	//	*L4LbServiceKeyHandle_ServiceHandle
	KeyOrHandle isL4LbServiceKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *L4LbServiceKeyHandle) Reset()                    { *m = L4LbServiceKeyHandle{} }
func (m *L4LbServiceKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceKeyHandle) ProtoMessage()               {}
func (*L4LbServiceKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{3} }

type isL4LbServiceKeyHandle_KeyOrHandle interface {
	isL4LbServiceKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type L4LbServiceKeyHandle_ServiceKey struct {
	ServiceKey *L4LbServiceKey `protobuf:"bytes,1,opt,name=service_key,json=serviceKey,oneof"`
}
type L4LbServiceKeyHandle_ServiceHandle struct {
	ServiceHandle uint64 `protobuf:"fixed64,2,opt,name=service_handle,json=serviceHandle,proto3,oneof"`
}

func (*L4LbServiceKeyHandle_ServiceKey) isL4LbServiceKeyHandle_KeyOrHandle()    {}
func (*L4LbServiceKeyHandle_ServiceHandle) isL4LbServiceKeyHandle_KeyOrHandle() {}

func (m *L4LbServiceKeyHandle) GetKeyOrHandle() isL4LbServiceKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L4LbServiceKeyHandle) GetServiceKey() *L4LbServiceKey {
	if x, ok := m.GetKeyOrHandle().(*L4LbServiceKeyHandle_ServiceKey); ok {
		return x.ServiceKey
	}
	return nil
}

func (m *L4LbServiceKeyHandle) GetServiceHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*L4LbServiceKeyHandle_ServiceHandle); ok {
		return x.ServiceHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L4LbServiceKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L4LbServiceKeyHandle_OneofMarshaler, _L4LbServiceKeyHandle_OneofUnmarshaler, _L4LbServiceKeyHandle_OneofSizer, []interface{}{
		(*L4LbServiceKeyHandle_ServiceKey)(nil),
		(*L4LbServiceKeyHandle_ServiceHandle)(nil),
	}
}

func _L4LbServiceKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L4LbServiceKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L4LbServiceKeyHandle_ServiceKey:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceKey); err != nil {
			return err
		}
	case *L4LbServiceKeyHandle_ServiceHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.ServiceHandle))
	case nil:
	default:
		return fmt.Errorf("L4LbServiceKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _L4LbServiceKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L4LbServiceKeyHandle)
	switch tag {
	case 1: // key_or_handle.service_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L4LbServiceKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &L4LbServiceKeyHandle_ServiceKey{msg}
		return true, err
	case 2: // key_or_handle.service_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &L4LbServiceKeyHandle_ServiceHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _L4LbServiceKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L4LbServiceKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L4LbServiceKeyHandle_ServiceKey:
		s := proto.Size(x.ServiceKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *L4LbServiceKeyHandle_ServiceHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L4LbServiceSpec message represents one service request
type L4LbServiceSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L4 LB service's unique identifier
	KeyOrHandle      *L4LbServiceKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	ProxyArpEnable   bool                  `protobuf:"varint,3,opt,name=proxy_arp_enable,json=proxyArpEnable,proto3" json:"proxy_arp_enable,omitempty"`
	ServiceMac       uint64                `protobuf:"fixed64,4,opt,name=service_mac,json=serviceMac,proto3" json:"service_mac,omitempty"`
	SessionAffinity  SessionAffinity       `protobuf:"varint,5,opt,name=session_affinity,json=sessionAffinity,proto3,enum=l4lb.SessionAffinity" json:"session_affinity,omitempty"`
	LoadBalancerType *LBMethod             `protobuf:"bytes,6,opt,name=load_balancer_type,json=loadBalancerType" json:"load_balancer_type,omitempty"`
	HealthCheck      *HealthCheck          `protobuf:"bytes,7,opt,name=health_check,json=healthCheck" json:"health_check,omitempty"`
}

func (m *L4LbServiceSpec) Reset()                    { *m = L4LbServiceSpec{} }
func (m *L4LbServiceSpec) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceSpec) ProtoMessage()               {}
func (*L4LbServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{4} }

func (m *L4LbServiceSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbServiceSpec) GetKeyOrHandle() *L4LbServiceKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L4LbServiceSpec) GetProxyArpEnable() bool {
	if m != nil {
		return m.ProxyArpEnable
	}
	return false
}

func (m *L4LbServiceSpec) GetServiceMac() uint64 {
	if m != nil {
		return m.ServiceMac
	}
	return 0
}

func (m *L4LbServiceSpec) GetSessionAffinity() SessionAffinity {
	if m != nil {
		return m.SessionAffinity
	}
	return SessionAffinity_L4LB_SESSION_AFFINITY_NONE
}

func (m *L4LbServiceSpec) GetLoadBalancerType() *LBMethod {
	if m != nil {
		return m.LoadBalancerType
	}
	return nil
}

func (m *L4LbServiceSpec) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

// L4LbServiceRequestMsg is batched request message that is used to do
// add/mod of L4 LB service(s)
type L4LbServiceRequestMsg struct {
	Request []*L4LbServiceSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbServiceRequestMsg) Reset()                    { *m = L4LbServiceRequestMsg{} }
func (m *L4LbServiceRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceRequestMsg) ProtoMessage()               {}
func (*L4LbServiceRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{5} }

func (m *L4LbServiceRequestMsg) GetRequest() []*L4LbServiceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4LbServiceStatus represents the current status of the service
type L4LbServiceStatus struct {
	ServiceStatus L4LbStatus `protobuf:"varint,1,opt,name=service_status,json=serviceStatus,proto3,enum=l4lb.L4LbStatus" json:"service_status,omitempty"`
	ServiceHandle uint64     `protobuf:"fixed64,2,opt,name=service_handle,json=serviceHandle,proto3" json:"service_handle,omitempty"`
}

func (m *L4LbServiceStatus) Reset()                    { *m = L4LbServiceStatus{} }
func (m *L4LbServiceStatus) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceStatus) ProtoMessage()               {}
func (*L4LbServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{6} }

func (m *L4LbServiceStatus) GetServiceStatus() L4LbStatus {
	if m != nil {
		return m.ServiceStatus
	}
	return L4LbStatus_L4LB_STATUS_NONE
}

func (m *L4LbServiceStatus) GetServiceHandle() uint64 {
	if m != nil {
		return m.ServiceHandle
	}
	return 0
}

// L4LbServiceResponse is response to one L4LbServiceSpec
type L4LbServiceResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *L4LbServiceStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *L4LbServiceResponse) Reset()                    { *m = L4LbServiceResponse{} }
func (m *L4LbServiceResponse) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceResponse) ProtoMessage()               {}
func (*L4LbServiceResponse) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{7} }

func (m *L4LbServiceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L4LbServiceResponse) GetStatus() *L4LbServiceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// L4LbServiceResponseMsg is response to L4LbServiceRequestMsg
type L4LbServiceResponseMsg struct {
	Response []*L4LbServiceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L4LbServiceResponseMsg) Reset()                    { *m = L4LbServiceResponseMsg{} }
func (m *L4LbServiceResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceResponseMsg) ProtoMessage()               {}
func (*L4LbServiceResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{8} }

func (m *L4LbServiceResponseMsg) GetResponse() []*L4LbServiceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4LbServiceDeleteRequest is used to delete a service object, all backend
// servers should be delete before deleting the service itself or else delete
// operation will fail
type L4LbServiceDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L4 LB service's unique identifier
	KeyOrHandle *L4LbServiceKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *L4LbServiceDeleteRequest) Reset()                    { *m = L4LbServiceDeleteRequest{} }
func (m *L4LbServiceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceDeleteRequest) ProtoMessage()               {}
func (*L4LbServiceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{9} }

func (m *L4LbServiceDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbServiceDeleteRequest) GetKeyOrHandle() *L4LbServiceKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L4LbServiceDeleteRequestMsg is used to delete a batch of services
type L4LbServiceDeleteRequestMsg struct {
	Request []*L4LbServiceDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbServiceDeleteRequestMsg) Reset()                    { *m = L4LbServiceDeleteRequestMsg{} }
func (m *L4LbServiceDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceDeleteRequestMsg) ProtoMessage()               {}
func (*L4LbServiceDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{10} }

func (m *L4LbServiceDeleteRequestMsg) GetRequest() []*L4LbServiceDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type L4LbServiceDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *L4LbServiceDeleteResponse) Reset()                    { *m = L4LbServiceDeleteResponse{} }
func (m *L4LbServiceDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceDeleteResponse) ProtoMessage()               {}
func (*L4LbServiceDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{11} }

func (m *L4LbServiceDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// L4LbServiceDeleteResponseMsg is batched response to L4LbServiceDeleteRequestMsg
type L4LbServiceDeleteResponseMsg struct {
	Response []*L4LbServiceDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L4LbServiceDeleteResponseMsg) Reset()         { *m = L4LbServiceDeleteResponseMsg{} }
func (m *L4LbServiceDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L4LbServiceDeleteResponseMsg) ProtoMessage()    {}
func (*L4LbServiceDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL4Lb, []int{12}
}

func (m *L4LbServiceDeleteResponseMsg) GetResponse() []*L4LbServiceDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4LbServiceStats captures all the statistics of given L4LB service
type L4LbServiceStats struct {
	NumActiveBackends       uint32 `protobuf:"fixed32,1,opt,name=num_active_backends,json=numActiveBackends,proto3" json:"num_active_backends,omitempty"`
	NumActiveSessions       uint32 `protobuf:"fixed32,2,opt,name=num_active_sessions,json=numActiveSessions,proto3" json:"num_active_sessions,omitempty"`
	NumSessionsLoadBalanced uint32 `protobuf:"fixed32,3,opt,name=num_sessions_load_balanced,json=numSessionsLoadBalanced,proto3" json:"num_sessions_load_balanced,omitempty"`
	NumSessionsFailed       uint32 `protobuf:"fixed32,4,opt,name=num_sessions_failed,json=numSessionsFailed,proto3" json:"num_sessions_failed,omitempty"`
	NumHealthChangeEvents   uint32 `protobuf:"fixed32,5,opt,name=num_health_change_events,json=numHealthChangeEvents,proto3" json:"num_health_change_events,omitempty"`
}

func (m *L4LbServiceStats) Reset()                    { *m = L4LbServiceStats{} }
func (m *L4LbServiceStats) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceStats) ProtoMessage()               {}
func (*L4LbServiceStats) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{13} }

func (m *L4LbServiceStats) GetNumActiveBackends() uint32 {
	if m != nil {
		return m.NumActiveBackends
	}
	return 0
}

func (m *L4LbServiceStats) GetNumActiveSessions() uint32 {
	if m != nil {
		return m.NumActiveSessions
	}
	return 0
}

func (m *L4LbServiceStats) GetNumSessionsLoadBalanced() uint32 {
	if m != nil {
		return m.NumSessionsLoadBalanced
	}
	return 0
}

func (m *L4LbServiceStats) GetNumSessionsFailed() uint32 {
	if m != nil {
		return m.NumSessionsFailed
	}
	return 0
}

func (m *L4LbServiceStats) GetNumHealthChangeEvents() uint32 {
	if m != nil {
		return m.NumHealthChangeEvents
	}
	return 0
}

// L4LbBackendKey uniquely identifies a backend server
type L4LbBackendKey struct {
	BackendIpAddress *IPAddress `protobuf:"bytes,1,opt,name=backend_ip_address,json=backendIpAddress" json:"backend_ip_address,omitempty"`
	BackendPort      uint32     `protobuf:"varint,2,opt,name=backend_port,json=backendPort,proto3" json:"backend_port,omitempty"`
}

func (m *L4LbBackendKey) Reset()                    { *m = L4LbBackendKey{} }
func (m *L4LbBackendKey) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendKey) ProtoMessage()               {}
func (*L4LbBackendKey) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{14} }

func (m *L4LbBackendKey) GetBackendIpAddress() *IPAddress {
	if m != nil {
		return m.BackendIpAddress
	}
	return nil
}

func (m *L4LbBackendKey) GetBackendPort() uint32 {
	if m != nil {
		return m.BackendPort
	}
	return 0
}

// L4 LB backend key or handle object
type L4LbBackendKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*L4LbBackendKeyHandle_BackendKey
	//	*L4LbBackendKeyHandle_ServiceHandle
	KeyOrHandle isL4LbBackendKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *L4LbBackendKeyHandle) Reset()                    { *m = L4LbBackendKeyHandle{} }
func (m *L4LbBackendKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendKeyHandle) ProtoMessage()               {}
func (*L4LbBackendKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{15} }

type isL4LbBackendKeyHandle_KeyOrHandle interface {
	isL4LbBackendKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type L4LbBackendKeyHandle_BackendKey struct {
	BackendKey *L4LbBackendKey `protobuf:"bytes,1,opt,name=backend_key,json=backendKey,oneof"`
}
type L4LbBackendKeyHandle_ServiceHandle struct {
	ServiceHandle uint64 `protobuf:"fixed64,2,opt,name=service_handle,json=serviceHandle,proto3,oneof"`
}

func (*L4LbBackendKeyHandle_BackendKey) isL4LbBackendKeyHandle_KeyOrHandle()    {}
func (*L4LbBackendKeyHandle_ServiceHandle) isL4LbBackendKeyHandle_KeyOrHandle() {}

func (m *L4LbBackendKeyHandle) GetKeyOrHandle() isL4LbBackendKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L4LbBackendKeyHandle) GetBackendKey() *L4LbBackendKey {
	if x, ok := m.GetKeyOrHandle().(*L4LbBackendKeyHandle_BackendKey); ok {
		return x.BackendKey
	}
	return nil
}

func (m *L4LbBackendKeyHandle) GetServiceHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*L4LbBackendKeyHandle_ServiceHandle); ok {
		return x.ServiceHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L4LbBackendKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L4LbBackendKeyHandle_OneofMarshaler, _L4LbBackendKeyHandle_OneofUnmarshaler, _L4LbBackendKeyHandle_OneofSizer, []interface{}{
		(*L4LbBackendKeyHandle_BackendKey)(nil),
		(*L4LbBackendKeyHandle_ServiceHandle)(nil),
	}
}

func _L4LbBackendKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L4LbBackendKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L4LbBackendKeyHandle_BackendKey:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BackendKey); err != nil {
			return err
		}
	case *L4LbBackendKeyHandle_ServiceHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.ServiceHandle))
	case nil:
	default:
		return fmt.Errorf("L4LbBackendKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _L4LbBackendKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L4LbBackendKeyHandle)
	switch tag {
	case 1: // key_or_handle.backend_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L4LbBackendKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &L4LbBackendKeyHandle_BackendKey{msg}
		return true, err
	case 2: // key_or_handle.service_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &L4LbBackendKeyHandle_ServiceHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _L4LbBackendKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L4LbBackendKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L4LbBackendKeyHandle_BackendKey:
		s := proto.Size(x.BackendKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *L4LbBackendKeyHandle_ServiceHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Backend server representation
type L4LbBackendSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// backend_key_or_handle is the backend being created/updated
	BackendKeyOrHandle *L4LbBackendKeyHandle `protobuf:"bytes,2,opt,name=backend_key_or_handle,json=backendKeyOrHandle" json:"backend_key_or_handle,omitempty" venice:key`
	ServiceKeyOrHandle *L4LbServiceKeyHandle `protobuf:"bytes,3,opt,name=service_key_or_handle,json=serviceKeyOrHandle" json:"service_key_or_handle,omitempty"`
}

func (m *L4LbBackendSpec) Reset()                    { *m = L4LbBackendSpec{} }
func (m *L4LbBackendSpec) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendSpec) ProtoMessage()               {}
func (*L4LbBackendSpec) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{16} }

func (m *L4LbBackendSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbBackendSpec) GetBackendKeyOrHandle() *L4LbBackendKeyHandle {
	if m != nil {
		return m.BackendKeyOrHandle
	}
	return nil
}

func (m *L4LbBackendSpec) GetServiceKeyOrHandle() *L4LbServiceKeyHandle {
	if m != nil {
		return m.ServiceKeyOrHandle
	}
	return nil
}

// L4LbBackendRequestMsg is batched request message for add/mod of backends
type L4LbBackendRequestMsg struct {
	Request []*L4LbBackendSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbBackendRequestMsg) Reset()                    { *m = L4LbBackendRequestMsg{} }
func (m *L4LbBackendRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendRequestMsg) ProtoMessage()               {}
func (*L4LbBackendRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{17} }

func (m *L4LbBackendRequestMsg) GetRequest() []*L4LbBackendSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4LbBackendStatus represents the current status of the backend server
type L4LbBackendStatus struct {
	Status        L4LbStatus `protobuf:"varint,1,opt,name=status,proto3,enum=l4lb.L4LbStatus" json:"status,omitempty"`
	ServiceHandle uint64     `protobuf:"fixed64,2,opt,name=service_handle,json=serviceHandle,proto3" json:"service_handle,omitempty"`
}

func (m *L4LbBackendStatus) Reset()                    { *m = L4LbBackendStatus{} }
func (m *L4LbBackendStatus) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendStatus) ProtoMessage()               {}
func (*L4LbBackendStatus) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{18} }

func (m *L4LbBackendStatus) GetStatus() L4LbStatus {
	if m != nil {
		return m.Status
	}
	return L4LbStatus_L4LB_STATUS_NONE
}

func (m *L4LbBackendStatus) GetServiceHandle() uint64 {
	if m != nil {
		return m.ServiceHandle
	}
	return 0
}

// L4LbBackendResponse is response to L4LbBackendSpec
type L4LbBackendResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *L4LbBackendStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *L4LbBackendResponse) Reset()                    { *m = L4LbBackendResponse{} }
func (m *L4LbBackendResponse) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendResponse) ProtoMessage()               {}
func (*L4LbBackendResponse) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{19} }

func (m *L4LbBackendResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L4LbBackendResponse) GetStatus() *L4LbBackendStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// L4LbBackendResponseMsg is response to L4LbBackendRequestMsg
type L4LbBackendResponseMsg struct {
	Response []*L4LbBackendResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L4LbBackendResponseMsg) Reset()                    { *m = L4LbBackendResponseMsg{} }
func (m *L4LbBackendResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendResponseMsg) ProtoMessage()               {}
func (*L4LbBackendResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{20} }

func (m *L4LbBackendResponseMsg) GetResponse() []*L4LbBackendResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4LbBackendDeleteRequest is used to delete a backend service instance
type L4LbBackendDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the backend's key or handle
	KeyOrHandle *L4LbBackendKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *L4LbBackendDeleteRequest) Reset()                    { *m = L4LbBackendDeleteRequest{} }
func (m *L4LbBackendDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendDeleteRequest) ProtoMessage()               {}
func (*L4LbBackendDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{21} }

func (m *L4LbBackendDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbBackendDeleteRequest) GetKeyOrHandle() *L4LbBackendKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L4LbBackendDeleteRequestMsg is used to delete a batch of backends
type L4LbBackendDeleteRequestMsg struct {
	Request []*L4LbBackendDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbBackendDeleteRequestMsg) Reset()                    { *m = L4LbBackendDeleteRequestMsg{} }
func (m *L4LbBackendDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendDeleteRequestMsg) ProtoMessage()               {}
func (*L4LbBackendDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{22} }

func (m *L4LbBackendDeleteRequestMsg) GetRequest() []*L4LbBackendDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4LbBackendDeleteResponseMsg is batched response to L4LbBackendDeleteRequestMsg
type L4LbBackendDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *L4LbBackendDeleteResponseMsg) Reset()         { *m = L4LbBackendDeleteResponseMsg{} }
func (m *L4LbBackendDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*L4LbBackendDeleteResponseMsg) ProtoMessage()    {}
func (*L4LbBackendDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorL4Lb, []int{23}
}

func (m *L4LbBackendDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// L4LbBackendStats captures all statistics for given backend instance
type L4LbBackendStats struct {
	NumActiveSessions      uint32 `protobuf:"fixed32,1,opt,name=num_active_sessions,json=numActiveSessions,proto3" json:"num_active_sessions,omitempty"`
	NumTotalSessions       uint32 `protobuf:"fixed32,2,opt,name=num_total_sessions,json=numTotalSessions,proto3" json:"num_total_sessions,omitempty"`
	NumHealthCheckFailures uint32 `protobuf:"fixed32,3,opt,name=num_health_check_failures,json=numHealthCheckFailures,proto3" json:"num_health_check_failures,omitempty"`
	NumHealthProbeFailures uint32 `protobuf:"fixed32,4,opt,name=num_health_probe_failures,json=numHealthProbeFailures,proto3" json:"num_health_probe_failures,omitempty"`
}

func (m *L4LbBackendStats) Reset()                    { *m = L4LbBackendStats{} }
func (m *L4LbBackendStats) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendStats) ProtoMessage()               {}
func (*L4LbBackendStats) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{24} }

func (m *L4LbBackendStats) GetNumActiveSessions() uint32 {
	if m != nil {
		return m.NumActiveSessions
	}
	return 0
}

func (m *L4LbBackendStats) GetNumTotalSessions() uint32 {
	if m != nil {
		return m.NumTotalSessions
	}
	return 0
}

func (m *L4LbBackendStats) GetNumHealthCheckFailures() uint32 {
	if m != nil {
		return m.NumHealthCheckFailures
	}
	return 0
}

func (m *L4LbBackendStats) GetNumHealthProbeFailures() uint32 {
	if m != nil {
		return m.NumHealthProbeFailures
	}
	return 0
}

// L4LbBackendGetRequest is used to get information about a particular backend
type L4LbBackendGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the backend's key or handle
	KeyOrHandle *L4LbBackendKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *L4LbBackendGetRequest) Reset()                    { *m = L4LbBackendGetRequest{} }
func (m *L4LbBackendGetRequest) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendGetRequest) ProtoMessage()               {}
func (*L4LbBackendGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{25} }

func (m *L4LbBackendGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbBackendGetRequest) GetKeyOrHandle() *L4LbBackendKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L4LbBackendGetRequestMsg is batched GET request for backends
type L4LbBackendGetRequestMsg struct {
	Request []*L4LbBackendGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbBackendGetRequestMsg) Reset()                    { *m = L4LbBackendGetRequestMsg{} }
func (m *L4LbBackendGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendGetRequestMsg) ProtoMessage()               {}
func (*L4LbBackendGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{26} }

func (m *L4LbBackendGetRequestMsg) GetRequest() []*L4LbBackendGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4LbBackendGetResponse returns all the information about a backend
type L4LbBackendGetResponse struct {
	Spec   *L4LbBackendSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *L4LbBackendStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *L4LbBackendStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *L4LbBackendGetResponse) Reset()                    { *m = L4LbBackendGetResponse{} }
func (m *L4LbBackendGetResponse) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendGetResponse) ProtoMessage()               {}
func (*L4LbBackendGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{27} }

func (m *L4LbBackendGetResponse) GetSpec() *L4LbBackendSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *L4LbBackendGetResponse) GetStatus() *L4LbBackendStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *L4LbBackendGetResponse) GetStats() *L4LbBackendStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// L4LbBackendGetResponseMsg is response to L4LbBackendGetRequestMsg
type L4LbBackendGetResponseMsg struct {
	Response []*L4LbBackendGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L4LbBackendGetResponseMsg) Reset()                    { *m = L4LbBackendGetResponseMsg{} }
func (m *L4LbBackendGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbBackendGetResponseMsg) ProtoMessage()               {}
func (*L4LbBackendGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{28} }

func (m *L4LbBackendGetResponseMsg) GetResponse() []*L4LbBackendGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4LbServiceGetRequest is used to get information about a service
type L4LbServiceGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is L4 LB service's unique identifier
	KeyOrHandle *L4LbServiceKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *L4LbServiceGetRequest) Reset()                    { *m = L4LbServiceGetRequest{} }
func (m *L4LbServiceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceGetRequest) ProtoMessage()               {}
func (*L4LbServiceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{29} }

func (m *L4LbServiceGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *L4LbServiceGetRequest) GetKeyOrHandle() *L4LbServiceKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// L4LbServiceGetRequestMsg is batched GET request for services
type L4LbServiceGetRequestMsg struct {
	Request []*L4LbServiceGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *L4LbServiceGetRequestMsg) Reset()                    { *m = L4LbServiceGetRequestMsg{} }
func (m *L4LbServiceGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceGetRequestMsg) ProtoMessage()               {}
func (*L4LbServiceGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{30} }

func (m *L4LbServiceGetRequestMsg) GetRequest() []*L4LbServiceGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4LbServiceGetResponse captures all the information about a service
type L4LbServiceGetResponse struct {
	Spec     *L4LbServiceSpec          `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status   *L4LbServiceStatus        `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats    *L4LbServiceStats         `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
	Backends []*L4LbBackendGetResponse `protobuf:"bytes,4,rep,name=backends" json:"backends,omitempty"`
}

func (m *L4LbServiceGetResponse) Reset()                    { *m = L4LbServiceGetResponse{} }
func (m *L4LbServiceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceGetResponse) ProtoMessage()               {}
func (*L4LbServiceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{31} }

func (m *L4LbServiceGetResponse) GetSpec() *L4LbServiceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *L4LbServiceGetResponse) GetStatus() *L4LbServiceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *L4LbServiceGetResponse) GetStats() *L4LbServiceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *L4LbServiceGetResponse) GetBackends() []*L4LbBackendGetResponse {
	if m != nil {
		return m.Backends
	}
	return nil
}

// L4LbServiceGetResponseMsg is response to L4LbServiceGetRequestMsg
type L4LbServiceGetResponseMsg struct {
	Response []*L4LbServiceGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *L4LbServiceGetResponseMsg) Reset()                    { *m = L4LbServiceGetResponseMsg{} }
func (m *L4LbServiceGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*L4LbServiceGetResponseMsg) ProtoMessage()               {}
func (*L4LbServiceGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorL4Lb, []int{32} }

func (m *L4LbServiceGetResponseMsg) GetResponse() []*L4LbServiceGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*LBMethod)(nil), "l4lb.LBMethod")
	proto.RegisterType((*HealthCheck)(nil), "l4lb.HealthCheck")
	proto.RegisterType((*L4LbServiceKey)(nil), "l4lb.L4LbServiceKey")
	proto.RegisterType((*L4LbServiceKeyHandle)(nil), "l4lb.L4LbServiceKeyHandle")
	proto.RegisterType((*L4LbServiceSpec)(nil), "l4lb.L4LbServiceSpec")
	proto.RegisterType((*L4LbServiceRequestMsg)(nil), "l4lb.L4LbServiceRequestMsg")
	proto.RegisterType((*L4LbServiceStatus)(nil), "l4lb.L4LbServiceStatus")
	proto.RegisterType((*L4LbServiceResponse)(nil), "l4lb.L4LbServiceResponse")
	proto.RegisterType((*L4LbServiceResponseMsg)(nil), "l4lb.L4LbServiceResponseMsg")
	proto.RegisterType((*L4LbServiceDeleteRequest)(nil), "l4lb.L4LbServiceDeleteRequest")
	proto.RegisterType((*L4LbServiceDeleteRequestMsg)(nil), "l4lb.L4LbServiceDeleteRequestMsg")
	proto.RegisterType((*L4LbServiceDeleteResponse)(nil), "l4lb.L4LbServiceDeleteResponse")
	proto.RegisterType((*L4LbServiceDeleteResponseMsg)(nil), "l4lb.L4LbServiceDeleteResponseMsg")
	proto.RegisterType((*L4LbServiceStats)(nil), "l4lb.L4LbServiceStats")
	proto.RegisterType((*L4LbBackendKey)(nil), "l4lb.L4LbBackendKey")
	proto.RegisterType((*L4LbBackendKeyHandle)(nil), "l4lb.L4LbBackendKeyHandle")
	proto.RegisterType((*L4LbBackendSpec)(nil), "l4lb.L4LbBackendSpec")
	proto.RegisterType((*L4LbBackendRequestMsg)(nil), "l4lb.L4LbBackendRequestMsg")
	proto.RegisterType((*L4LbBackendStatus)(nil), "l4lb.L4LbBackendStatus")
	proto.RegisterType((*L4LbBackendResponse)(nil), "l4lb.L4LbBackendResponse")
	proto.RegisterType((*L4LbBackendResponseMsg)(nil), "l4lb.L4LbBackendResponseMsg")
	proto.RegisterType((*L4LbBackendDeleteRequest)(nil), "l4lb.L4LbBackendDeleteRequest")
	proto.RegisterType((*L4LbBackendDeleteRequestMsg)(nil), "l4lb.L4LbBackendDeleteRequestMsg")
	proto.RegisterType((*L4LbBackendDeleteResponseMsg)(nil), "l4lb.L4LbBackendDeleteResponseMsg")
	proto.RegisterType((*L4LbBackendStats)(nil), "l4lb.L4LbBackendStats")
	proto.RegisterType((*L4LbBackendGetRequest)(nil), "l4lb.L4LbBackendGetRequest")
	proto.RegisterType((*L4LbBackendGetRequestMsg)(nil), "l4lb.L4LbBackendGetRequestMsg")
	proto.RegisterType((*L4LbBackendGetResponse)(nil), "l4lb.L4LbBackendGetResponse")
	proto.RegisterType((*L4LbBackendGetResponseMsg)(nil), "l4lb.L4LbBackendGetResponseMsg")
	proto.RegisterType((*L4LbServiceGetRequest)(nil), "l4lb.L4LbServiceGetRequest")
	proto.RegisterType((*L4LbServiceGetRequestMsg)(nil), "l4lb.L4LbServiceGetRequestMsg")
	proto.RegisterType((*L4LbServiceGetResponse)(nil), "l4lb.L4LbServiceGetResponse")
	proto.RegisterType((*L4LbServiceGetResponseMsg)(nil), "l4lb.L4LbServiceGetResponseMsg")
	proto.RegisterEnum("l4lb.SessionAffinity", SessionAffinity_name, SessionAffinity_value)
	proto.RegisterEnum("l4lb.LBAlgorithm", LBAlgorithm_name, LBAlgorithm_value)
	proto.RegisterEnum("l4lb.L4LBProtocol", L4LBProtocol_name, L4LBProtocol_value)
	proto.RegisterEnum("l4lb.L4LBProbeProtocol", L4LBProbeProtocol_name, L4LBProbeProtocol_value)
	proto.RegisterEnum("l4lb.L4LbStatus", L4LbStatus_name, L4LbStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for L4Lb service

type L4LbClient interface {
	L4LbServiceCreate(ctx context.Context, in *L4LbServiceRequestMsg, opts ...grpc.CallOption) (*L4LbServiceResponseMsg, error)
}

type l4LbClient struct {
	cc *grpc.ClientConn
}

func NewL4LbClient(cc *grpc.ClientConn) L4LbClient {
	return &l4LbClient{cc}
}

func (c *l4LbClient) L4LbServiceCreate(ctx context.Context, in *L4LbServiceRequestMsg, opts ...grpc.CallOption) (*L4LbServiceResponseMsg, error) {
	out := new(L4LbServiceResponseMsg)
	err := grpc.Invoke(ctx, "/l4lb.L4Lb/L4LbServiceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for L4Lb service

type L4LbServer interface {
	L4LbServiceCreate(context.Context, *L4LbServiceRequestMsg) (*L4LbServiceResponseMsg, error)
}

func RegisterL4LbServer(s *grpc.Server, srv L4LbServer) {
	s.RegisterService(&_L4Lb_serviceDesc, srv)
}

func _L4Lb_L4LbServiceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L4LbServiceRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L4LbServer).L4LbServiceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/l4lb.L4Lb/L4LbServiceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L4LbServer).L4LbServiceCreate(ctx, req.(*L4LbServiceRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _L4Lb_serviceDesc = grpc.ServiceDesc{
	ServiceName: "l4lb.L4Lb",
	HandlerType: (*L4LbServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "L4LbServiceCreate",
			Handler:    _L4Lb_L4LbServiceCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "l4lb.proto",
}

func (m *LBMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LBMethod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algorithm != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Algorithm))
	}
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProbePort != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbePort))
		i += 4
	}
	if m.ProbeProtocol != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ProbeProtocol))
	}
	if m.ProbeInterval != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbeInterval))
		i += 4
	}
	if m.ProbesPerInterval != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbesPerInterval))
		i += 4
	}
	return i, nil
}

func (m *L4LbServiceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServiceIpAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServiceIpAddress.Size()))
		n1, err := m.ServiceIpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IpProtocol != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.IpProtocol))
	}
	if m.ServicePort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServicePort))
	}
	return i, nil
}

func (m *L4LbServiceKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn2, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *L4LbServiceKeyHandle_ServiceKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServiceKey.Size()))
		n3, err := m.ServiceKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *L4LbServiceKeyHandle_ServiceHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServiceHandle))
	i += 8
	return i, nil
}
func (m *L4LbServiceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n5, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ProxyArpEnable {
		dAtA[i] = 0x18
		i++
		if m.ProxyArpEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ServiceMac != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServiceMac))
		i += 8
	}
	if m.SessionAffinity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.SessionAffinity))
	}
	if m.LoadBalancerType != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.LoadBalancerType.Size()))
		n6, err := m.LoadBalancerType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.HealthCheck != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.HealthCheck.Size()))
		n7, err := m.HealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *L4LbServiceRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServiceStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServiceStatus))
	}
	if m.ServiceHandle != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServiceHandle))
		i += 8
	}
	return i, nil
}

func (m *L4LbServiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Status.Size()))
		n8, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *L4LbServiceResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n9, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n10, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *L4LbServiceDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *L4LbServiceDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumActiveBackends != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumActiveBackends))
		i += 4
	}
	if m.NumActiveSessions != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumActiveSessions))
		i += 4
	}
	if m.NumSessionsLoadBalanced != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumSessionsLoadBalanced))
		i += 4
	}
	if m.NumSessionsFailed != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumSessionsFailed))
		i += 4
	}
	if m.NumHealthChangeEvents != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumHealthChangeEvents))
		i += 4
	}
	return i, nil
}

func (m *L4LbBackendKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BackendIpAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.BackendIpAddress.Size()))
		n11, err := m.BackendIpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.BackendPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.BackendPort))
	}
	return i, nil
}

func (m *L4LbBackendKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *L4LbBackendKeyHandle_BackendKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BackendKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.BackendKey.Size()))
		n13, err := m.BackendKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *L4LbBackendKeyHandle_ServiceHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServiceHandle))
	i += 8
	return i, nil
}
func (m *L4LbBackendSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n14, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.BackendKeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.BackendKeyOrHandle.Size()))
		n15, err := m.BackendKeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ServiceKeyOrHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServiceKeyOrHandle.Size()))
		n16, err := m.ServiceKeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *L4LbBackendRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbBackendStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Status))
	}
	if m.ServiceHandle != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServiceHandle))
		i += 8
	}
	return i, nil
}

func (m *L4LbBackendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Status.Size()))
		n17, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *L4LbBackendResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbBackendDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n18, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n19, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *L4LbBackendDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbBackendDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA21 := make([]byte, len(m.ApiStatus)*10)
		var j20 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *L4LbBackendStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumActiveSessions != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumActiveSessions))
		i += 4
	}
	if m.NumTotalSessions != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumTotalSessions))
		i += 4
	}
	if m.NumHealthCheckFailures != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumHealthCheckFailures))
		i += 4
	}
	if m.NumHealthProbeFailures != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumHealthProbeFailures))
		i += 4
	}
	return i, nil
}

func (m *L4LbBackendGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n22, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n23, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *L4LbBackendGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbBackendGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Spec.Size()))
		n24, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Status.Size()))
		n25, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Stats.Size()))
		n26, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *L4LbBackendGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbBackendGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Meta.Size()))
		n27, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *L4LbServiceGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Spec.Size()))
		n29, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Status.Size()))
		n30, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintL4Lb(dAtA, i, uint64(m.Stats.Size()))
		n31, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Backends) > 0 {
		for _, msg := range m.Backends {
			dAtA[i] = 0x22
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *L4LbServiceGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbServiceGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintL4Lb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintL4Lb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LBMethod) Size() (n int) {
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovL4Lb(uint64(m.Algorithm))
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	var l int
	_ = l
	if m.ProbePort != 0 {
		n += 5
	}
	if m.ProbeProtocol != 0 {
		n += 1 + sovL4Lb(uint64(m.ProbeProtocol))
	}
	if m.ProbeInterval != 0 {
		n += 5
	}
	if m.ProbesPerInterval != 0 {
		n += 5
	}
	return n
}

func (m *L4LbServiceKey) Size() (n int) {
	var l int
	_ = l
	if m.ServiceIpAddress != nil {
		l = m.ServiceIpAddress.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.IpProtocol != 0 {
		n += 1 + sovL4Lb(uint64(m.IpProtocol))
	}
	if m.ServicePort != 0 {
		n += 1 + sovL4Lb(uint64(m.ServicePort))
	}
	return n
}

func (m *L4LbServiceKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *L4LbServiceKeyHandle_ServiceKey) Size() (n int) {
	var l int
	_ = l
	if m.ServiceKey != nil {
		l = m.ServiceKey.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}
func (m *L4LbServiceKeyHandle_ServiceHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *L4LbServiceSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.ProxyArpEnable {
		n += 2
	}
	if m.ServiceMac != 0 {
		n += 9
	}
	if m.SessionAffinity != 0 {
		n += 1 + sovL4Lb(uint64(m.SessionAffinity))
	}
	if m.LoadBalancerType != nil {
		l = m.LoadBalancerType.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbServiceRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceStatus) Size() (n int) {
	var l int
	_ = l
	if m.ServiceStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ServiceStatus))
	}
	if m.ServiceHandle != 0 {
		n += 9
	}
	return n
}

func (m *L4LbServiceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbServiceResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbServiceDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ApiStatus))
	}
	return n
}

func (m *L4LbServiceDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceStats) Size() (n int) {
	var l int
	_ = l
	if m.NumActiveBackends != 0 {
		n += 5
	}
	if m.NumActiveSessions != 0 {
		n += 5
	}
	if m.NumSessionsLoadBalanced != 0 {
		n += 5
	}
	if m.NumSessionsFailed != 0 {
		n += 5
	}
	if m.NumHealthChangeEvents != 0 {
		n += 5
	}
	return n
}

func (m *L4LbBackendKey) Size() (n int) {
	var l int
	_ = l
	if m.BackendIpAddress != nil {
		l = m.BackendIpAddress.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.BackendPort != 0 {
		n += 1 + sovL4Lb(uint64(m.BackendPort))
	}
	return n
}

func (m *L4LbBackendKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *L4LbBackendKeyHandle_BackendKey) Size() (n int) {
	var l int
	_ = l
	if m.BackendKey != nil {
		l = m.BackendKey.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}
func (m *L4LbBackendKeyHandle_ServiceHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *L4LbBackendSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.BackendKeyOrHandle != nil {
		l = m.BackendKeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.ServiceKeyOrHandle != nil {
		l = m.ServiceKeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbBackendRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbBackendStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovL4Lb(uint64(m.Status))
	}
	if m.ServiceHandle != 0 {
		n += 9
	}
	return n
}

func (m *L4LbBackendResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbBackendResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbBackendDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbBackendDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbBackendDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovL4Lb(uint64(e))
		}
		n += 1 + sovL4Lb(uint64(l)) + l
	}
	return n
}

func (m *L4LbBackendStats) Size() (n int) {
	var l int
	_ = l
	if m.NumActiveSessions != 0 {
		n += 5
	}
	if m.NumTotalSessions != 0 {
		n += 5
	}
	if m.NumHealthCheckFailures != 0 {
		n += 5
	}
	if m.NumHealthProbeFailures != 0 {
		n += 5
	}
	return n
}

func (m *L4LbBackendGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbBackendGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbBackendGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbBackendGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	return n
}

func (m *L4LbServiceGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if len(m.Backends) > 0 {
		for _, e := range m.Backends {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func (m *L4LbServiceGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	return n
}

func sovL4Lb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozL4Lb(x uint64) (n int) {
	return sovL4Lb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LBMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LBMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LBMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= (LBAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbePort", wireType)
			}
			m.ProbePort = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbePort = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeProtocol", wireType)
			}
			m.ProbeProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeProtocol |= (L4LBProbeProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeInterval", wireType)
			}
			m.ProbeInterval = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbeInterval = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbesPerInterval", wireType)
			}
			m.ProbesPerInterval = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbesPerInterval = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceIpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceIpAddress == nil {
				m.ServiceIpAddress = &IPAddress{}
			}
			if err := m.ServiceIpAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (L4LBProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L4LbServiceKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &L4LbServiceKeyHandle_ServiceKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &L4LbServiceKeyHandle_ServiceHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L4LbServiceKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyArpEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProxyArpEnable = bool(v != 0)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMac", wireType)
			}
			m.ServiceMac = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceMac = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinity", wireType)
			}
			m.SessionAffinity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionAffinity |= (SessionAffinity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancerType == nil {
				m.LoadBalancerType = &LBMethod{}
			}
			if err := m.LoadBalancerType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &HealthCheck{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbServiceSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStatus", wireType)
			}
			m.ServiceStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceStatus |= (L4LbStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHandle", wireType)
			}
			m.ServiceHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L4LbServiceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbServiceResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L4LbServiceKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbServiceDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbServiceDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumActiveBackends", wireType)
			}
			m.NumActiveBackends = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumActiveBackends = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumActiveSessions", wireType)
			}
			m.NumActiveSessions = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumActiveSessions = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSessionsLoadBalanced", wireType)
			}
			m.NumSessionsLoadBalanced = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSessionsLoadBalanced = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSessionsFailed", wireType)
			}
			m.NumSessionsFailed = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSessionsFailed = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHealthChangeEvents", wireType)
			}
			m.NumHealthChangeEvents = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumHealthChangeEvents = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendIpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackendIpAddress == nil {
				m.BackendIpAddress = &IPAddress{}
			}
			if err := m.BackendIpAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendPort", wireType)
			}
			m.BackendPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackendPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L4LbBackendKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &L4LbBackendKeyHandle_BackendKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &L4LbBackendKeyHandle_ServiceHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendKeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackendKeyOrHandle == nil {
				m.BackendKeyOrHandle = &L4LbBackendKeyHandle{}
			}
			if err := m.BackendKeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceKeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceKeyOrHandle == nil {
				m.ServiceKeyOrHandle = &L4LbServiceKeyHandle{}
			}
			if err := m.ServiceKeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbBackendSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (L4LbStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHandle", wireType)
			}
			m.ServiceHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L4LbBackendStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbBackendResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L4LbBackendKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbBackendDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL4Lb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowL4Lb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumActiveSessions", wireType)
			}
			m.NumActiveSessions = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumActiveSessions = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTotalSessions", wireType)
			}
			m.NumTotalSessions = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumTotalSessions = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHealthCheckFailures", wireType)
			}
			m.NumHealthCheckFailures = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumHealthCheckFailures = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHealthProbeFailures", wireType)
			}
			m.NumHealthProbeFailures = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumHealthProbeFailures = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L4LbBackendKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbBackendGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &L4LbBackendSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L4LbBackendStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &L4LbBackendStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbBackendGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbBackendGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbBackendGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbBackendGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &L4LbServiceKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbServiceGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &L4LbServiceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L4LbServiceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &L4LbServiceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backends = append(m.Backends, &L4LbBackendGetResponse{})
			if err := m.Backends[len(m.Backends)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbServiceGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbServiceGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbServiceGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbServiceGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipL4Lb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthL4Lb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipL4Lb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthL4Lb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowL4Lb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("l4lb.proto", fileDescriptorL4Lb) }

var fileDescriptorL4Lb = []byte{
	// 1620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x36, 0x6d, 0xc5, 0x76, 0x8e, 0x7c, 0xa1, 0x27, 0x71, 0x2c, 0x3b, 0x89, 0x9d, 0x30, 0x7f,
	0x10, 0xff, 0x46, 0x60, 0x03, 0x8e, 0x7f, 0xe4, 0x6f, 0x53, 0x04, 0x95, 0x64, 0x39, 0x22, 0x22,
	0x89, 0x0a, 0x25, 0x23, 0xbd, 0xa0, 0x20, 0x28, 0x6a, 0x62, 0xa9, 0x92, 0x48, 0x96, 0xa4, 0xdc,
	0x6a, 0xd1, 0x07, 0xc8, 0xa6, 0x40, 0x77, 0x01, 0xba, 0xeb, 0xaa, 0xef, 0xd1, 0x4d, 0x97, 0x7d,
	0x80, 0xa2, 0x28, 0x52, 0x20, 0x0f, 0xd0, 0x27, 0x28, 0x38, 0x17, 0xde, 0x44, 0xc5, 0x76, 0x80,
	0x20, 0x2b, 0x89, 0x73, 0xbe, 0x33, 0xe7, 0x9c, 0x39, 0x97, 0x6f, 0x48, 0x80, 0xfe, 0x41, 0xbf,
	0xb5, 0x6b, 0x3b, 0x96, 0x67, 0xa1, 0x8c, 0xff, 0x7f, 0x23, 0xeb, 0x8d, 0x6c, 0xec, 0xd2, 0x25,
	0xe9, 0x11, 0xcc, 0x57, 0x0a, 0x55, 0xec, 0x75, 0xac, 0x36, 0xda, 0x83, 0xcb, 0x7a, 0xff, 0xc4,
	0x72, 0xba, 0x5e, 0x67, 0x90, 0x13, 0x6e, 0x09, 0xdb, 0x4b, 0xfb, 0x2b, 0xbb, 0x44, 0xbd, 0x52,
	0xc8, 0x73, 0x81, 0x1a, 0x62, 0xa4, 0x5f, 0x05, 0xc8, 0x96, 0xb1, 0xde, 0xf7, 0x3a, 0xc5, 0x0e,
	0x36, 0x7a, 0xe8, 0x26, 0x80, 0xed, 0x58, 0x2d, 0xac, 0xd9, 0x96, 0xe3, 0x91, 0x1d, 0xe6, 0xd4,
	0xcb, 0x64, 0xa5, 0x6e, 0x39, 0x1e, 0x7a, 0x0c, 0x4b, 0x4c, 0xec, 0x9b, 0x36, 0xac, 0x7e, 0x6e,
	0x9a, 0x18, 0x59, 0x63, 0x46, 0x0e, 0x2a, 0x85, 0x3a, 0x01, 0x33, 0xb1, 0xba, 0x68, 0x47, 0x1f,
	0xd1, 0x5d, 0xae, 0xdf, 0x35, 0x3d, 0xec, 0x9c, 0xea, 0xfd, 0xdc, 0x0c, 0x31, 0x41, 0x61, 0x32,
	0x5b, 0x44, 0xbb, 0x70, 0x85, 0x2c, 0xb8, 0x9a, 0x8d, 0x9d, 0x10, 0x9b, 0x21, 0xd8, 0x15, 0x2a,
	0xaa, 0x63, 0x87, 0xe3, 0xa5, 0x5f, 0x04, 0x58, 0xaa, 0x1c, 0x54, 0x5a, 0x0d, 0xec, 0x9c, 0x76,
	0x0d, 0xfc, 0x14, 0x8f, 0xd0, 0x63, 0x40, 0x2e, 0x7d, 0xd2, 0xba, 0xb6, 0xa6, 0xb7, 0xdb, 0x0e,
	0x76, 0x5d, 0x12, 0x50, 0x76, 0x5f, 0xdc, 0xa5, 0xe7, 0x27, 0xd7, 0xf3, 0x74, 0x5d, 0x15, 0x19,
	0x56, 0xb6, 0xd9, 0x0a, 0x7a, 0x00, 0xd9, 0xae, 0x9d, 0x0c, 0x13, 0xc5, 0xc2, 0xa4, 0x11, 0x42,
	0xd7, 0x0e, 0xc2, 0xbb, 0x0d, 0x0b, 0xdc, 0x28, 0x39, 0x3f, 0x3f, 0xb8, 0x45, 0x35, 0xcb, 0xd6,
	0xfc, 0x13, 0x94, 0x5e, 0x0a, 0x70, 0x35, 0xee, 0x6a, 0x59, 0x37, 0xdb, 0x7d, 0x8c, 0x1e, 0x02,
	0xc7, 0x69, 0x3d, 0x3c, 0x62, 0x9e, 0x5e, 0x0d, 0x0c, 0x46, 0x15, 0xa6, 0x54, 0x70, 0xc3, 0x48,
	0xef, 0xc1, 0x12, 0x57, 0xec, 0x90, 0xad, 0x88, 0xb3, 0xb3, 0xe5, 0x29, 0x75, 0x91, 0xad, 0x53,
	0x0b, 0x85, 0x65, 0x58, 0xec, 0xe1, 0x91, 0x66, 0x39, 0x0c, 0x27, 0xbd, 0x9c, 0x81, 0xe5, 0xc8,
	0xd6, 0x0d, 0x1b, 0x1b, 0xe8, 0x2e, 0x64, 0x06, 0xd8, 0xd3, 0x99, 0xfd, 0x15, 0x76, 0x52, 0x4a,
	0xeb, 0x6b, 0x6c, 0x78, 0x55, 0xec, 0xe9, 0x2a, 0x11, 0xa3, 0x5a, 0x62, 0x2f, 0x62, 0x33, 0xbb,
	0xbf, 0x91, 0xea, 0x2f, 0x35, 0xbf, 0xf4, 0xcf, 0x9f, 0x5b, 0x70, 0x8a, 0xcd, 0xae, 0x81, 0x3f,
	0xee, 0xe1, 0x91, 0x9a, 0xed, 0xe1, 0x91, 0xe2, 0xb0, 0xe8, 0xb7, 0x41, 0xb4, 0x1d, 0xeb, 0xbb,
	0x91, 0xa6, 0x3b, 0xb6, 0x86, 0x4d, 0xbd, 0xd5, 0xc7, 0xe4, 0xf4, 0xe6, 0xd5, 0x25, 0xb2, 0x9e,
	0x77, 0xec, 0x12, 0x59, 0x45, 0x5b, 0xe1, 0x39, 0x0d, 0x74, 0x83, 0xd4, 0xc4, 0x6c, 0x70, 0x1e,
	0x55, 0xdd, 0x40, 0x9f, 0x82, 0xe8, 0x62, 0xd7, 0xed, 0x5a, 0xa6, 0xa6, 0xbf, 0x78, 0xd1, 0x35,
	0xbb, 0xde, 0x28, 0x77, 0x89, 0xa4, 0x6f, 0x95, 0x7a, 0xd7, 0xa0, 0xd2, 0x3c, 0x13, 0xaa, 0xcb,
	0x6e, 0x7c, 0x01, 0x7d, 0x02, 0xa8, 0x6f, 0xe9, 0x6d, 0xad, 0xa5, 0xf7, 0x75, 0xd3, 0xc0, 0x8e,
	0xe6, 0x1f, 0x42, 0x6e, 0x96, 0x44, 0xb8, 0xc4, 0xdb, 0x89, 0x76, 0x9c, 0x2a, 0xfa, 0xc8, 0x02,
	0x03, 0x36, 0x47, 0x36, 0x46, 0x07, 0xb0, 0xd0, 0x21, 0x1d, 0xa5, 0x19, 0x7e, 0x4b, 0xe5, 0xe6,
	0xd8, 0x49, 0x12, 0xbd, 0x48, 0xaf, 0xa9, 0xd9, 0x4e, 0xf8, 0x20, 0x95, 0x61, 0x35, 0x72, 0x6a,
	0x2a, 0xfe, 0x66, 0x88, 0x5d, 0xaf, 0xea, 0x9e, 0xa0, 0x3d, 0x98, 0x73, 0xe8, 0x53, 0x4e, 0xb8,
	0x35, 0xb3, 0x9d, 0xe5, 0x51, 0x24, 0x12, 0xa7, 0x72, 0x94, 0xe4, 0xc2, 0x4a, 0x54, 0xe6, 0xe9,
	0xde, 0xd0, 0x45, 0x0f, 0xc3, 0x22, 0x71, 0xc9, 0x0a, 0x9b, 0x0e, 0x62, 0x64, 0x33, 0xb2, 0x1e,
	0x14, 0x0d, 0x53, 0xbc, 0x9b, 0x5e, 0x5d, 0x89, 0xda, 0x92, 0xbe, 0x85, 0x2b, 0x31, 0xf7, 0x5d,
	0xdb, 0x32, 0x5d, 0x8c, 0xf6, 0x00, 0x74, 0xbb, 0x9b, 0x34, 0x49, 0x6b, 0x2a, 0x6f, 0x77, 0x99,
	0xc9, 0xcb, 0x3a, 0xff, 0x8b, 0xf6, 0x60, 0x96, 0x81, 0x69, 0x41, 0xad, 0x8d, 0x07, 0x4b, 0x75,
	0x18, 0x4c, 0x52, 0xe0, 0x5a, 0x8a, 0x61, 0xff, 0xe0, 0xfe, 0x07, 0xf3, 0x0e, 0x7b, 0x64, 0x27,
	0xb7, 0x3e, 0xb6, 0x19, 0xc7, 0xab, 0x01, 0x54, 0xfa, 0x51, 0x80, 0x5c, 0x04, 0x71, 0x88, 0xfb,
	0xd8, 0xe3, 0xf9, 0xf8, 0x40, 0xdd, 0x21, 0x3d, 0x87, 0xeb, 0x93, 0x5c, 0xf2, 0x23, 0xfd, 0x7f,
	0xb2, 0x44, 0x36, 0xc7, 0x0c, 0xc5, 0x74, 0xc2, 0x5a, 0xa9, 0xc0, 0x7a, 0x0a, 0xe8, 0x1d, 0x93,
	0x27, 0x7d, 0x09, 0x37, 0x26, 0xee, 0xe6, 0xfb, 0xf9, 0x68, 0x2c, 0x23, 0x5b, 0x13, 0x1d, 0x1d,
	0xcb, 0xcb, 0xab, 0x69, 0x10, 0x13, 0x65, 0xe0, 0xfa, 0x44, 0x61, 0x0e, 0x07, 0x9a, 0x6e, 0x78,
	0xdd, 0x53, 0xac, 0xb5, 0x74, 0xa3, 0x87, 0xcd, 0xb6, 0xcb, 0x78, 0x6b, 0xc5, 0x1c, 0x0e, 0xf2,
	0x44, 0x52, 0x60, 0x82, 0x04, 0x9e, 0xf5, 0x3d, 0xad, 0xb5, 0x28, 0x9e, 0x4d, 0x08, 0x17, 0x3d,
	0x82, 0x0d, 0x1f, 0xcf, 0x81, 0x5a, 0x74, 0x2c, 0xb4, 0x19, 0x77, 0xad, 0x99, 0xc3, 0x01, 0x57,
	0xa8, 0x84, 0xc3, 0xa0, 0xcd, 0x8d, 0x05, 0xca, 0x2f, 0xf4, 0x6e, 0x1f, 0xb7, 0x39, 0x8b, 0x45,
	0xb4, 0x8e, 0x88, 0x00, 0x3d, 0x84, 0x9c, 0x8f, 0x0f, 0x86, 0x87, 0x6e, 0x9e, 0x60, 0x0d, 0x9f,
	0x62, 0xd3, 0x73, 0xc9, 0x00, 0x9b, 0x53, 0x57, 0xcd, 0xe1, 0x80, 0x4f, 0x10, 0x5f, 0x5a, 0x22,
	0x42, 0xc9, 0xa5, 0xec, 0xc7, 0xa2, 0x64, 0xec, 0xc7, 0x0e, 0xe3, 0x5c, 0xec, 0xc7, 0xb0, 0x21,
	0xfb, 0xdd, 0x86, 0x05, 0xae, 0x4f, 0x88, 0x6c, 0x9a, 0x12, 0x19, 0x5b, 0x8b, 0x11, 0x59, 0x68,
	0x35, 0x24, 0x32, 0xae, 0x9b, 0x4a, 0x64, 0x11, 0x85, 0x29, 0x15, 0x5a, 0xa1, 0xd3, 0xef, 0x4e,
	0x64, 0x6f, 0x04, 0x4a, 0x64, 0x6c, 0xeb, 0x8b, 0x10, 0xd9, 0x57, 0xb0, 0x1a, 0xf1, 0xf6, 0x6d,
	0x2d, 0x9b, 0x0c, 0x74, 0xac, 0x65, 0x51, 0x18, 0x4b, 0xc0, 0x6b, 0x55, 0x58, 0x8d, 0xb0, 0x7a,
	0x64, 0xfb, 0x99, 0xb3, 0x26, 0x82, 0x8a, 0x42, 0x8e, 0x0f, 0x06, 0x01, 0x63, 0x09, 0xe6, 0xca,
	0x39, 0x59, 0x22, 0x72, 0x2a, 0x61, 0xe7, 0xb7, 0x29, 0x4b, 0x70, 0x19, 0x9d, 0xbe, 0xdb, 0xc1,
	0xf4, 0x9d, 0xc4, 0x0e, 0x4c, 0x7e, 0x41, 0x5a, 0x08, 0xfc, 0x7d, 0x0f, 0xb4, 0x10, 0x8b, 0x20,
	0x49, 0x0b, 0x09, 0xc3, 0x67, 0xd2, 0x42, 0x02, 0x9f, 0x42, 0x0b, 0x0c, 0xf1, 0x9e, 0x68, 0xe1,
	0xcc, 0x1a, 0x4b, 0xa3, 0x85, 0x34, 0x97, 0xce, 0xa2, 0x85, 0x34, 0x9d, 0xb0, 0x38, 0x14, 0x3a,
	0xc8, 0x13, 0xa0, 0xf0, 0x0c, 0x93, 0xf9, 0x9b, 0x39, 0x8b, 0x19, 0xde, 0x08, 0x74, 0x78, 0x47,
	0x92, 0x35, 0x71, 0x18, 0x0b, 0x93, 0x86, 0xf1, 0x7d, 0x40, 0x3e, 0xde, 0xb3, 0x3c, 0xbd, 0x9f,
	0x9c, 0xdd, 0xa2, 0x39, 0x1c, 0x34, 0x7d, 0x41, 0x80, 0xfe, 0x08, 0xd6, 0x63, 0xd3, 0x14, 0x1b,
	0x3d, 0x32, 0x81, 0x87, 0x0e, 0x76, 0xd9, 0xe4, 0xbe, 0x16, 0x19, 0xa7, 0xd8, 0xe8, 0x1d, 0x31,
	0x69, 0x42, 0x95, 0xbe, 0xb0, 0x04, 0xaa, 0x99, 0x84, 0x2a, 0x79, 0xdf, 0xe1, 0xaa, 0xd2, 0x0f,
	0x42, 0xac, 0x43, 0x9f, 0x60, 0xef, 0x03, 0xd7, 0xc8, 0xb3, 0x58, 0xd9, 0x86, 0xfe, 0xd0, 0x56,
	0x48, 0x14, 0xc8, 0xf5, 0x31, 0x2b, 0xa1, 0x42, 0x58, 0x1d, 0x3f, 0x0b, 0xb1, 0xe6, 0x22, 0x10,
	0xd6, 0xd8, 0xff, 0x85, 0x8c, 0x6b, 0x63, 0x83, 0x05, 0x39, 0x61, 0x06, 0x11, 0xc8, 0x85, 0x5b,
	0x1a, 0xdd, 0x87, 0x4b, 0xfe, 0x3f, 0x97, 0x8d, 0xce, 0x6b, 0xa9, 0x78, 0x57, 0xa5, 0x20, 0xe9,
	0x98, 0xde, 0x6c, 0xc6, 0x7d, 0xa4, 0x9d, 0x91, 0x9c, 0x01, 0x37, 0xd2, 0x23, 0x1f, 0x1b, 0x03,
	0x3c, 0xbf, 0x6c, 0x5a, 0xbf, 0x8f, 0xfc, 0x5e, 0xec, 0x6a, 0xf8, 0x2c, 0x76, 0x5b, 0x3d, 0x7f,
	0x7e, 0xc7, 0x14, 0xc2, 0xfc, 0xfe, 0x21, 0xc4, 0xee, 0xd4, 0xe7, 0xca, 0x6f, 0xf4, 0x4d, 0xe4,
	0xcc, 0xfc, 0xa6, 0xde, 0xe4, 0xdf, 0x92, 0xdf, 0xe8, 0x95, 0x8f, 0xe5, 0xd7, 0x4f, 0x61, 0x70,
	0xdd, 0xcb, 0x9c, 0x27, 0x85, 0x1c, 0xcd, 0x2b, 0x63, 0x3c, 0xba, 0x33, 0x2b, 0x63, 0x5c, 0x25,
	0xac, 0x8c, 0x9d, 0x21, 0x2c, 0x27, 0x5e, 0x2c, 0xd1, 0x26, 0x6c, 0x54, 0x0e, 0x2a, 0x05, 0xad,
	0x51, 0x6a, 0x34, 0x64, 0xa5, 0xa6, 0xe5, 0x8f, 0x8e, 0xe4, 0x9a, 0xdc, 0xfc, 0x5c, 0xab, 0x29,
	0xb5, 0x92, 0x38, 0x85, 0x6e, 0x12, 0x4f, 0x52, 0xe4, 0x0d, 0xb9, 0x2e, 0x0a, 0xe8, 0x0e, 0x6c,
	0x4d, 0x14, 0x6b, 0x8d, 0xba, 0xa2, 0x36, 0xc5, 0xe9, 0x9d, 0x9f, 0xa6, 0x21, 0x1b, 0xf9, 0xb6,
	0x83, 0xd6, 0x08, 0xe3, 0x16, 0xb4, 0x7c, 0xe5, 0x89, 0xa2, 0xca, 0xcd, 0x72, 0x95, 0x1b, 0xe3,
	0xce, 0x84, 0x02, 0x55, 0x39, 0xae, 0x1d, 0x6a, 0xaa, 0x52, 0x90, 0x6b, 0xa2, 0x80, 0xee, 0xc1,
	0x9d, 0x84, 0xfc, 0x79, 0x49, 0x7e, 0x52, 0x6e, 0x96, 0x0e, 0x63, 0xc0, 0x69, 0xb4, 0x4e, 0x3a,
	0x20, 0xb6, 0x51, 0xbe, 0x76, 0xa8, 0x54, 0xc5, 0x19, 0xf4, 0x1f, 0xb8, 0x95, 0x10, 0x55, 0x4a,
	0xf9, 0x46, 0x53, 0x2b, 0x2a, 0xb5, 0x5a, 0xa9, 0xd8, 0x94, 0x95, 0x5a, 0x43, 0xcc, 0xa0, 0x2d,
	0x42, 0x5b, 0x51, 0x54, 0x5d, 0x2e, 0x3e, 0xdd, 0xe7, 0xdb, 0x5c, 0x42, 0x12, 0x6c, 0x26, 0x00,
	0x55, 0xb9, 0x16, 0xdb, 0x64, 0x36, 0xc5, 0x54, 0x39, 0xdf, 0x28, 0x6b, 0x4a, 0x4d, 0x6b, 0x28,
	0xc7, 0x6a, 0xb1, 0xa4, 0xc9, 0x75, 0x71, 0x6e, 0xe7, 0x29, 0x2c, 0x44, 0x3f, 0xd6, 0xa0, 0x2b,
	0xe4, 0x9e, 0x58, 0xd0, 0xea, 0xaa, 0xd2, 0x54, 0xf8, 0xc9, 0x20, 0x72, 0x7d, 0xe6, 0x8b, 0xcd,
	0x62, 0x5d, 0x9c, 0x4d, 0xac, 0x1d, 0x1f, 0xd6, 0xc5, 0x95, 0x9d, 0xef, 0xc9, 0x95, 0x29, 0xfe,
	0x81, 0x2b, 0x38, 0x8d, 0xba, 0xaa, 0x14, 0x4a, 0xf1, 0x7d, 0xd3, 0x44, 0x72, 0xb1, 0xea, 0xa7,
	0x36, 0x47, 0xee, 0xce, 0x71, 0x11, 0x35, 0x9c, 0x26, 0xa1, 0xe6, 0x2b, 0x00, 0xe1, 0x45, 0x0c,
	0x5d, 0x25, 0x84, 0x5a, 0xd0, 0x1a, 0xcd, 0x7c, 0xf3, 0xb8, 0x91, 0x0c, 0x85, 0xad, 0x1e, 0xfb,
	0xb6, 0x12, 0xc8, 0x43, 0xe5, 0x79, 0x4d, 0x9c, 0xde, 0xff, 0x0c, 0x32, 0xfe, 0x6e, 0xa8, 0x1e,
	0xfb, 0x5a, 0x50, 0x74, 0xb0, 0xee, 0x61, 0x74, 0x3d, 0xe5, 0x45, 0x99, 0x4f, 0x95, 0x8d, 0x1b,
	0x13, 0xdf, 0xa2, 0xab, 0xee, 0x89, 0x34, 0x55, 0xd8, 0xf8, 0xed, 0xf5, 0xa6, 0xf0, 0xfb, 0xeb,
	0x4d, 0xe1, 0xaf, 0xd7, 0x9b, 0xc2, 0xab, 0xbf, 0x37, 0xa7, 0xbe, 0x98, 0xef, 0xe8, 0x7d, 0xf2,
	0x25, 0xad, 0x35, 0x4b, 0x7e, 0x1e, 0xfc, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x45, 0xa2, 0xef,
	0xd3, 0x14, 0x00, 0x00,
}
