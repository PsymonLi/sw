// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fwlog.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Type of action on the flow while the log was generated
type FlowLogEventType int32

const (
	FlowLogEventType_FLOW_LOG_EVENT_TYPE_CREATE FlowLogEventType = 0
	FlowLogEventType_FLOW_LOG_EVENT_TYPE_DELETE FlowLogEventType = 1
)

var FlowLogEventType_name = map[int32]string{
	0: "FLOW_LOG_EVENT_TYPE_CREATE",
	1: "FLOW_LOG_EVENT_TYPE_DELETE",
}
var FlowLogEventType_value = map[string]int32{
	"FLOW_LOG_EVENT_TYPE_CREATE": 0,
	"FLOW_LOG_EVENT_TYPE_DELETE": 1,
}

func (x FlowLogEventType) String() string {
	return proto.EnumName(FlowLogEventType_name, int32(x))
}
func (FlowLogEventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorFwlog, []int{0} }

// On receiver side, the enums can be converted back to strings using the
// ##enum##_Name() APIs in the generated file for a better readability
type FWEvent struct {
	Flowaction      FlowLogEventType `protobuf:"varint,1,opt,name=flowaction,proto3,enum=fwlog.FlowLogEventType" json:"flowaction,omitempty"`
	SourceVrf       uint64           `protobuf:"varint,2,opt,name=source_vrf,json=sourceVrf,proto3" json:"source_vrf,omitempty"`
	DestVrf         uint64           `protobuf:"varint,3,opt,name=dest_vrf,json=destVrf,proto3" json:"dest_vrf,omitempty"`
	IpVer           int32            `protobuf:"varint,4,opt,name=ipVer,proto3" json:"ipVer,omitempty"`
	Sipv4           uint32           `protobuf:"varint,5,opt,name=sipv4,proto3" json:"sipv4,omitempty"`
	Dipv4           uint32           `protobuf:"varint,6,opt,name=dipv4,proto3" json:"dipv4,omitempty"`
	Sport           uint32           `protobuf:"varint,7,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport           uint32           `protobuf:"varint,8,opt,name=dport,proto3" json:"dport,omitempty"`
	IpProt          IPProtocol       `protobuf:"varint,9,opt,name=ipProt,proto3,enum=types.IPProtocol" json:"ipProt,omitempty"`
	Direction       uint32           `protobuf:"varint,10,opt,name=direction,proto3" json:"direction,omitempty"`
	Sipv61          uint64           `protobuf:"varint,11,opt,name=sipv61,proto3" json:"sipv61,omitempty"`
	Sipv62          uint64           `protobuf:"varint,12,opt,name=sipv62,proto3" json:"sipv62,omitempty"`
	Dipv61          uint64           `protobuf:"varint,13,opt,name=dipv61,proto3" json:"dipv61,omitempty"`
	Dipv62          uint64           `protobuf:"varint,14,opt,name=dipv62,proto3" json:"dipv62,omitempty"`
	Fwaction        SecurityAction   `protobuf:"varint,15,opt,name=fwaction,proto3,enum=nwsec.SecurityAction" json:"fwaction,omitempty"`
	Alg             ALGName          `protobuf:"varint,16,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
	Snataction      NatAction        `protobuf:"varint,17,opt,name=snataction,proto3,enum=nat.NatAction" json:"snataction,omitempty"`
	Dnataction      NatAction        `protobuf:"varint,18,opt,name=dnataction,proto3,enum=nat.NatAction" json:"dnataction,omitempty"`
	Natsipv4        uint32           `protobuf:"varint,19,opt,name=natsipv4,proto3" json:"natsipv4,omitempty"`
	Natdipv4        uint32           `protobuf:"varint,20,opt,name=natdipv4,proto3" json:"natdipv4,omitempty"`
	Natsport        uint32           `protobuf:"varint,21,opt,name=natsport,proto3" json:"natsport,omitempty"`
	Natdport        uint32           `protobuf:"varint,22,opt,name=natdport,proto3" json:"natdport,omitempty"`
	Timestamp       int64            `protobuf:"varint,23,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	SessionId       uint64           `protobuf:"varint,24,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ParentSessionId uint64           `protobuf:"varint,25,opt,name=parent_session_id,json=parentSessionId,proto3" json:"parent_session_id,omitempty"`
	RuleId          uint64           `protobuf:"varint,26,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Icmptype        uint32           `protobuf:"varint,27,opt,name=icmptype,proto3" json:"icmptype,omitempty"`
	Icmpcode        uint32           `protobuf:"varint,28,opt,name=icmpcode,proto3" json:"icmpcode,omitempty"`
	Icmpid          uint32           `protobuf:"varint,29,opt,name=icmpid,proto3" json:"icmpid,omitempty"`
}

func (m *FWEvent) Reset()                    { *m = FWEvent{} }
func (m *FWEvent) String() string            { return proto.CompactTextString(m) }
func (*FWEvent) ProtoMessage()               {}
func (*FWEvent) Descriptor() ([]byte, []int) { return fileDescriptorFwlog, []int{0} }

func (m *FWEvent) GetFlowaction() FlowLogEventType {
	if m != nil {
		return m.Flowaction
	}
	return FlowLogEventType_FLOW_LOG_EVENT_TYPE_CREATE
}

func (m *FWEvent) GetSourceVrf() uint64 {
	if m != nil {
		return m.SourceVrf
	}
	return 0
}

func (m *FWEvent) GetDestVrf() uint64 {
	if m != nil {
		return m.DestVrf
	}
	return 0
}

func (m *FWEvent) GetIpVer() int32 {
	if m != nil {
		return m.IpVer
	}
	return 0
}

func (m *FWEvent) GetSipv4() uint32 {
	if m != nil {
		return m.Sipv4
	}
	return 0
}

func (m *FWEvent) GetDipv4() uint32 {
	if m != nil {
		return m.Dipv4
	}
	return 0
}

func (m *FWEvent) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FWEvent) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

func (m *FWEvent) GetIpProt() IPProtocol {
	if m != nil {
		return m.IpProt
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FWEvent) GetDirection() uint32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *FWEvent) GetSipv61() uint64 {
	if m != nil {
		return m.Sipv61
	}
	return 0
}

func (m *FWEvent) GetSipv62() uint64 {
	if m != nil {
		return m.Sipv62
	}
	return 0
}

func (m *FWEvent) GetDipv61() uint64 {
	if m != nil {
		return m.Dipv61
	}
	return 0
}

func (m *FWEvent) GetDipv62() uint64 {
	if m != nil {
		return m.Dipv62
	}
	return 0
}

func (m *FWEvent) GetFwaction() SecurityAction {
	if m != nil {
		return m.Fwaction
	}
	return SecurityAction_SECURITY_RULE_ACTION_NONE
}

func (m *FWEvent) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

func (m *FWEvent) GetSnataction() NatAction {
	if m != nil {
		return m.Snataction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *FWEvent) GetDnataction() NatAction {
	if m != nil {
		return m.Dnataction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *FWEvent) GetNatsipv4() uint32 {
	if m != nil {
		return m.Natsipv4
	}
	return 0
}

func (m *FWEvent) GetNatdipv4() uint32 {
	if m != nil {
		return m.Natdipv4
	}
	return 0
}

func (m *FWEvent) GetNatsport() uint32 {
	if m != nil {
		return m.Natsport
	}
	return 0
}

func (m *FWEvent) GetNatdport() uint32 {
	if m != nil {
		return m.Natdport
	}
	return 0
}

func (m *FWEvent) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FWEvent) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *FWEvent) GetParentSessionId() uint64 {
	if m != nil {
		return m.ParentSessionId
	}
	return 0
}

func (m *FWEvent) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *FWEvent) GetIcmptype() uint32 {
	if m != nil {
		return m.Icmptype
	}
	return 0
}

func (m *FWEvent) GetIcmpcode() uint32 {
	if m != nil {
		return m.Icmpcode
	}
	return 0
}

func (m *FWEvent) GetIcmpid() uint32 {
	if m != nil {
		return m.Icmpid
	}
	return 0
}

func init() {
	proto.RegisterType((*FWEvent)(nil), "fwlog.FWEvent")
	proto.RegisterEnum("fwlog.FlowLogEventType", FlowLogEventType_name, FlowLogEventType_value)
}
func (m *FWEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FWEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flowaction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Flowaction))
	}
	if m.SourceVrf != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.SourceVrf))
	}
	if m.DestVrf != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.DestVrf))
	}
	if m.IpVer != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.IpVer))
	}
	if m.Sipv4 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Sipv4))
	}
	if m.Dipv4 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Dipv4))
	}
	if m.Sport != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Dport))
	}
	if m.IpProt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.IpProt))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Direction))
	}
	if m.Sipv61 != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Sipv61))
	}
	if m.Sipv62 != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Sipv62))
	}
	if m.Dipv61 != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Dipv61))
	}
	if m.Dipv62 != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Dipv62))
	}
	if m.Fwaction != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Fwaction))
	}
	if m.Alg != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Alg))
	}
	if m.Snataction != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Snataction))
	}
	if m.Dnataction != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Dnataction))
	}
	if m.Natsipv4 != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Natsipv4))
	}
	if m.Natdipv4 != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Natdipv4))
	}
	if m.Natsport != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Natsport))
	}
	if m.Natdport != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Natdport))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Timestamp))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.SessionId))
	}
	if m.ParentSessionId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.ParentSessionId))
	}
	if m.RuleId != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.RuleId))
	}
	if m.Icmptype != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Icmptype))
	}
	if m.Icmpcode != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Icmpcode))
	}
	if m.Icmpid != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintFwlog(dAtA, i, uint64(m.Icmpid))
	}
	return i, nil
}

func encodeVarintFwlog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FWEvent) Size() (n int) {
	var l int
	_ = l
	if m.Flowaction != 0 {
		n += 1 + sovFwlog(uint64(m.Flowaction))
	}
	if m.SourceVrf != 0 {
		n += 1 + sovFwlog(uint64(m.SourceVrf))
	}
	if m.DestVrf != 0 {
		n += 1 + sovFwlog(uint64(m.DestVrf))
	}
	if m.IpVer != 0 {
		n += 1 + sovFwlog(uint64(m.IpVer))
	}
	if m.Sipv4 != 0 {
		n += 1 + sovFwlog(uint64(m.Sipv4))
	}
	if m.Dipv4 != 0 {
		n += 1 + sovFwlog(uint64(m.Dipv4))
	}
	if m.Sport != 0 {
		n += 1 + sovFwlog(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovFwlog(uint64(m.Dport))
	}
	if m.IpProt != 0 {
		n += 1 + sovFwlog(uint64(m.IpProt))
	}
	if m.Direction != 0 {
		n += 1 + sovFwlog(uint64(m.Direction))
	}
	if m.Sipv61 != 0 {
		n += 1 + sovFwlog(uint64(m.Sipv61))
	}
	if m.Sipv62 != 0 {
		n += 1 + sovFwlog(uint64(m.Sipv62))
	}
	if m.Dipv61 != 0 {
		n += 1 + sovFwlog(uint64(m.Dipv61))
	}
	if m.Dipv62 != 0 {
		n += 1 + sovFwlog(uint64(m.Dipv62))
	}
	if m.Fwaction != 0 {
		n += 1 + sovFwlog(uint64(m.Fwaction))
	}
	if m.Alg != 0 {
		n += 2 + sovFwlog(uint64(m.Alg))
	}
	if m.Snataction != 0 {
		n += 2 + sovFwlog(uint64(m.Snataction))
	}
	if m.Dnataction != 0 {
		n += 2 + sovFwlog(uint64(m.Dnataction))
	}
	if m.Natsipv4 != 0 {
		n += 2 + sovFwlog(uint64(m.Natsipv4))
	}
	if m.Natdipv4 != 0 {
		n += 2 + sovFwlog(uint64(m.Natdipv4))
	}
	if m.Natsport != 0 {
		n += 2 + sovFwlog(uint64(m.Natsport))
	}
	if m.Natdport != 0 {
		n += 2 + sovFwlog(uint64(m.Natdport))
	}
	if m.Timestamp != 0 {
		n += 2 + sovFwlog(uint64(m.Timestamp))
	}
	if m.SessionId != 0 {
		n += 2 + sovFwlog(uint64(m.SessionId))
	}
	if m.ParentSessionId != 0 {
		n += 2 + sovFwlog(uint64(m.ParentSessionId))
	}
	if m.RuleId != 0 {
		n += 2 + sovFwlog(uint64(m.RuleId))
	}
	if m.Icmptype != 0 {
		n += 2 + sovFwlog(uint64(m.Icmptype))
	}
	if m.Icmpcode != 0 {
		n += 2 + sovFwlog(uint64(m.Icmpcode))
	}
	if m.Icmpid != 0 {
		n += 2 + sovFwlog(uint64(m.Icmpid))
	}
	return n
}

func sovFwlog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFwlog(x uint64) (n int) {
	return sovFwlog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FWEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwlog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FWEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FWEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flowaction", wireType)
			}
			m.Flowaction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flowaction |= (FlowLogEventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceVrf", wireType)
			}
			m.SourceVrf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceVrf |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestVrf", wireType)
			}
			m.DestVrf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestVrf |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVer", wireType)
			}
			m.IpVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sipv4", wireType)
			}
			m.Sipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sipv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dipv4", wireType)
			}
			m.Dipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dipv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProt", wireType)
			}
			m.IpProt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProt |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sipv61", wireType)
			}
			m.Sipv61 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sipv61 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sipv62", wireType)
			}
			m.Sipv62 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sipv62 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dipv61", wireType)
			}
			m.Dipv61 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dipv61 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dipv62", wireType)
			}
			m.Dipv62 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dipv62 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fwaction", wireType)
			}
			m.Fwaction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fwaction |= (SecurityAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snataction", wireType)
			}
			m.Snataction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snataction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnataction", wireType)
			}
			m.Dnataction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnataction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Natsipv4", wireType)
			}
			m.Natsipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Natsipv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Natdipv4", wireType)
			}
			m.Natdipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Natdipv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Natsport", wireType)
			}
			m.Natsport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Natsport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Natdport", wireType)
			}
			m.Natdport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Natdport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSessionId", wireType)
			}
			m.ParentSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentSessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmptype", wireType)
			}
			m.Icmptype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmptype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpcode", wireType)
			}
			m.Icmpcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpcode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpid", wireType)
			}
			m.Icmpid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFwlog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwlog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFwlog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFwlog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFwlog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFwlog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFwlog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFwlog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFwlog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFwlog   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fwlog.proto", fileDescriptorFwlog) }

var fileDescriptorFwlog = []byte{
	// 569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0xdd, 0x6e, 0xda, 0x30,
	0x18, 0x86, 0x97, 0xb5, 0xfc, 0x99, 0xb5, 0x05, 0xaf, 0x05, 0x97, 0x51, 0x14, 0xed, 0x88, 0xf5,
	0x20, 0x52, 0xd9, 0xb4, 0x1d, 0xb3, 0x2d, 0x54, 0x48, 0x88, 0xa2, 0x14, 0x51, 0x6d, 0x27, 0x51,
	0x16, 0x1b, 0x16, 0x29, 0xc4, 0x51, 0x62, 0x40, 0xdc, 0xc2, 0xae, 0x6c, 0x87, 0xbb, 0x84, 0x89,
	0x2b, 0x99, 0xfc, 0xd9, 0x24, 0xd1, 0xb4, 0x1d, 0xc1, 0xfb, 0xbc, 0x4f, 0x2c, 0xc7, 0x9f, 0x83,
	0xea, 0xcb, 0x5d, 0xc8, 0x57, 0x56, 0x9c, 0x70, 0xc1, 0x71, 0x09, 0x42, 0xa7, 0x1e, 0xed, 0x52,
	0xe6, 0x2b, 0xd6, 0xa9, 0x45, 0x9e, 0xd0, 0x7f, 0xeb, 0x62, 0x1f, 0xb3, 0x54, 0x85, 0xd7, 0x3f,
	0x2a, 0xa8, 0x32, 0x7a, 0xb2, 0xb7, 0x2c, 0x12, 0xf8, 0x03, 0x42, 0xcb, 0x90, 0xef, 0x3c, 0x5f,
	0x04, 0x3c, 0x22, 0x86, 0x69, 0xf4, 0xcf, 0x07, 0x6d, 0x4b, 0xad, 0x3c, 0x0a, 0xf9, 0x6e, 0xc2,
	0x57, 0x20, 0xce, 0xf7, 0x31, 0x73, 0x0a, 0x2a, 0xbe, 0x41, 0x28, 0xe5, 0x9b, 0xc4, 0x67, 0xee,
	0x36, 0x59, 0x92, 0xe7, 0xa6, 0xd1, 0x3f, 0x75, 0x6a, 0x8a, 0x2c, 0x92, 0x25, 0xbe, 0x46, 0x55,
	0xca, 0x52, 0x01, 0xe5, 0x09, 0x94, 0x15, 0x99, 0x65, 0x75, 0x89, 0x4a, 0x41, 0xbc, 0x60, 0x09,
	0x39, 0x35, 0x8d, 0x7e, 0xc9, 0x51, 0x41, 0xd2, 0x34, 0x88, 0xb7, 0xef, 0x48, 0xc9, 0x34, 0xfa,
	0x67, 0x8e, 0x0a, 0x92, 0x52, 0xa0, 0x65, 0x45, 0xe9, 0x91, 0xa6, 0x31, 0x4f, 0x04, 0xa9, 0x68,
	0x57, 0x06, 0x70, 0x81, 0x56, 0xb5, 0x0b, 0xf4, 0x0d, 0x2a, 0x07, 0xf1, 0x2c, 0xe1, 0x82, 0xd4,
	0xe0, 0xe5, 0x9a, 0x96, 0x3a, 0x8a, 0xf1, 0x4c, 0x42, 0xee, 0xf3, 0xd0, 0xd1, 0x02, 0xee, 0xa2,
	0x1a, 0x0d, 0x12, 0xa6, 0x8e, 0x02, 0xc1, 0x22, 0x39, 0xc0, 0x2d, 0x54, 0x96, 0x7b, 0x7a, 0x7f,
	0x47, 0xea, 0xf0, 0x3e, 0x3a, 0x65, 0x7c, 0x40, 0x5e, 0x14, 0xf8, 0x40, 0x72, 0xaa, 0xfc, 0x33,
	0xc5, 0x69, 0xe6, 0x53, 0xe5, 0x9f, 0x17, 0xf8, 0x00, 0xdf, 0xa1, 0xea, 0xf2, 0x38, 0x87, 0x0b,
	0xd8, 0xea, 0x95, 0xa5, 0xa6, 0xf9, 0xc8, 0xfc, 0x4d, 0x12, 0x88, 0xfd, 0x10, 0x4a, 0x27, 0xd3,
	0xb0, 0x89, 0x4e, 0xbc, 0x70, 0x45, 0x1a, 0x60, 0x9f, 0x6b, 0x7b, 0x38, 0xb9, 0x9f, 0x7a, 0x6b,
	0xe6, 0xc8, 0x0a, 0x5b, 0x08, 0xa5, 0x91, 0x27, 0xf4, 0xb2, 0xcd, 0xa3, 0xe8, 0x09, 0x6b, 0xea,
	0x09, 0xbd, 0x5e, 0xc1, 0x90, 0x3e, 0xcd, 0x7d, 0xfc, 0x6f, 0x3f, 0x37, 0x70, 0x07, 0x55, 0x23,
	0x4f, 0xa8, 0xc1, 0xbd, 0x84, 0x13, 0xcb, 0xb2, 0xee, 0xd4, 0xf8, 0x2e, 0xb3, 0x8e, 0x16, 0x3a,
	0x35, 0xc4, 0xab, 0xfc, 0x39, 0x98, 0x98, 0x7e, 0x0e, 0xba, 0x56, 0xfe, 0x1c, 0x74, 0x5d, 0x54,
	0x13, 0xc1, 0x9a, 0xa5, 0xc2, 0x5b, 0xc7, 0xa4, 0x6d, 0x1a, 0xfd, 0x13, 0x27, 0x07, 0x70, 0x27,
	0x59, 0x9a, 0x06, 0x3c, 0x72, 0x03, 0x4a, 0x88, 0xbe, 0x93, 0x8a, 0x8c, 0x29, 0xbe, 0x45, 0xcd,
	0xd8, 0x4b, 0x58, 0x24, 0xdc, 0x82, 0x75, 0x0d, 0xd6, 0x85, 0x2a, 0x1e, 0x33, 0xb7, 0x8d, 0x2a,
	0xc9, 0x26, 0x64, 0xd2, 0xe8, 0xa8, 0x31, 0xc9, 0x38, 0xa6, 0x72, 0x77, 0x81, 0xbf, 0x8e, 0xe5,
	0x25, 0x22, 0xaf, 0xd4, 0xee, 0x8e, 0xf9, 0xd8, 0xf9, 0x9c, 0x32, 0xd2, 0xcd, 0x3b, 0x99, 0xe5,
	0xd8, 0xe5, 0xff, 0x80, 0x92, 0x1b, 0x68, 0x74, 0xba, 0x75, 0x50, 0xe3, 0xef, 0xef, 0x0c, 0xf7,
	0x50, 0x67, 0x34, 0x79, 0x78, 0x72, 0x27, 0x0f, 0xf7, 0xae, 0xbd, 0xb0, 0xa7, 0x73, 0x77, 0xfe,
	0x65, 0x66, 0xbb, 0x9f, 0x1c, 0x7b, 0x38, 0xb7, 0x1b, 0xcf, 0xfe, 0xd7, 0x7f, 0xb6, 0x27, 0xf6,
	0xdc, 0x6e, 0x18, 0x1f, 0x5b, 0x3f, 0x0f, 0x3d, 0xe3, 0xd7, 0xa1, 0x67, 0xfc, 0x3e, 0xf4, 0x8c,
	0xaf, 0xd5, 0xef, 0x5e, 0x08, 0x1f, 0xfe, 0xb7, 0x32, 0xfc, 0xbc, 0xfd, 0x13, 0x00, 0x00, 0xff,
	0xff, 0xcd, 0x52, 0x5c, 0xdf, 0x3a, 0x04, 0x00, 0x00,
}
