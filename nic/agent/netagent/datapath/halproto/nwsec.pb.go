// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nwsec.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// normalization feature actions upon detecting malformed packets
type NormalizationAction int32

const (
	NormalizationAction_NORM_ACTION_NONE  NormalizationAction = 0
	NormalizationAction_NORM_ACTION_ALLOW NormalizationAction = 1
	NormalizationAction_NORM_ACTION_DROP  NormalizationAction = 2
	NormalizationAction_NORM_ACTION_EDIT  NormalizationAction = 3
)

var NormalizationAction_name = map[int32]string{
	0: "NORM_ACTION_NONE",
	1: "NORM_ACTION_ALLOW",
	2: "NORM_ACTION_DROP",
	3: "NORM_ACTION_EDIT",
}
var NormalizationAction_value = map[string]int32{
	"NORM_ACTION_NONE":  0,
	"NORM_ACTION_ALLOW": 1,
	"NORM_ACTION_DROP":  2,
	"NORM_ACTION_EDIT":  3,
}

func (x NormalizationAction) String() string {
	return proto.EnumName(NormalizationAction_name, int32(x))
}
func (NormalizationAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{0} }

// Firewall policy actions
type FirewallAction int32

const (
	FirewallAction_FIREWALL_ACTION_NONE   FirewallAction = 0
	FirewallAction_FIREWALL_ACTION_ALLOW  FirewallAction = 1
	FirewallAction_FIREWALL_ACTION_DENY   FirewallAction = 2
	FirewallAction_FIREWALL_ACTION_REJECT FirewallAction = 3
)

var FirewallAction_name = map[int32]string{
	0: "FIREWALL_ACTION_NONE",
	1: "FIREWALL_ACTION_ALLOW",
	2: "FIREWALL_ACTION_DENY",
	3: "FIREWALL_ACTION_REJECT",
}
var FirewallAction_value = map[string]int32{
	"FIREWALL_ACTION_NONE":   0,
	"FIREWALL_ACTION_ALLOW":  1,
	"FIREWALL_ACTION_DENY":   2,
	"FIREWALL_ACTION_REJECT": 3,
}

func (x FirewallAction) String() string {
	return proto.EnumName(FirewallAction_name, int32(x))
}
func (FirewallAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{1} }

// Applicaion Layer Gateway (ALG) names for invoking appropriate ALG
type ALGName int32

const (
	ALGName_APP_SVC_NONE     ALGName = 0
	ALGName_APP_SVC_TFTP     ALGName = 1
	ALGName_APP_SVC_FTP      ALGName = 2
	ALGName_APP_SVC_DNS      ALGName = 3
	ALGName_APP_SVC_SIP      ALGName = 4
	ALGName_APP_SVC_SUN_RPC  ALGName = 5
	ALGName_APP_SVC_MSFT_RPC ALGName = 6
)

var ALGName_name = map[int32]string{
	0: "APP_SVC_NONE",
	1: "APP_SVC_TFTP",
	2: "APP_SVC_FTP",
	3: "APP_SVC_DNS",
	4: "APP_SVC_SIP",
	5: "APP_SVC_SUN_RPC",
	6: "APP_SVC_MSFT_RPC",
}
var ALGName_value = map[string]int32{
	"APP_SVC_NONE":     0,
	"APP_SVC_TFTP":     1,
	"APP_SVC_FTP":      2,
	"APP_SVC_DNS":      3,
	"APP_SVC_SIP":      4,
	"APP_SVC_SUN_RPC":  5,
	"APP_SVC_MSFT_RPC": 6,
}

func (x ALGName) String() string {
	return proto.EnumName(ALGName_name, int32(x))
}
func (ALGName) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{2} }

// ------------------------------------------------------------------------------
// SecurityProfileSpec object captures feature knobs that are most likely
// shareable across L2 segments, vrfs, or even interfaces and most of the
// time operates on defaults. It is possible that there is only object of this
// kind in the system.
// NOTE: user is not expected to fill in all the fields explicitly, that job is
//       done by the agent. Agent will be exposing user visible knobs and fill
//       in the defaults when interacting with HAL.
//
// Expected defaults:
//
// 1. Any abnormal behavior w.r.t flags (IP or TCP), default action is drop
// 2. Anything to do with options, default behavior is to reset/trim
// 3. Any length related errors, default is truncate the pkt
//
// {
//     cnxn_tracking_en                    = true
//     tcp_non_syn_first_pkt_drop          = true
//
//     ip_normalization_en                 = true
//     {
//         ip_ttl_change_detect_en         = false
//         ip_rsvd_flags_action            = drop
//         ip_df_action                    = allow
//         ip_options_action               = allow
//         ip_invalid_len_action           = trim
//         ip_normalize_ttl                = 0 (applicable only for workload
//                                              generated traffic)
//     }
//
//     icmp_normalization_en               = true
//     {
//         icmp_invalid_code_action        = drop
//         icmp_deprecated_msgs_drop       = true
//         icmp_redirect_msg_drop          = true
//     }
//
//     tcp_normalization_en                = true
//     {
//         tcp_split_handshake_drop        = false
//         tcp_rsvd_flags_action           = drop
//         tcp_unexpected_mss_action       = strip
//         tcp_unexpected_win_scale_action = strip
//         tcp_urg_ptr_not_set_action      = reset
//         tcp_urg_flag_not_set_action     = reset
//         tcp_urg_payload_missing_action  = reset
//         tcp_rst_with_data_action        = drop
//         tcp_data_len_gt_mss_action      = trim  (if conntrack is enabled)
//         tcp_data_len_gt_win_size_action = trim  (if conntrack is enabled)
//         tcp_unexpected_ts_option_action = reset (if conntrack is enabled)
//         tcp_unexpected_echo_ts_action   = drop
//         tcp_ts_not_present_drop         = true  (if conntrack is enabled)
//         tcp_invalid_flags_drop          = true
//         tcp_nonsyn_noack_drop           = true
//     }
// }
// ------------------------------------------------------------------------------
type SecurityProfileSpec struct {
	Meta                  *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle           *SecurityProfileKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	CnxnTrackingEn        bool                      `protobuf:"varint,3,opt,name=cnxn_tracking_en,json=cnxnTrackingEn,proto3" json:"cnxn_tracking_en,omitempty"`
	IpsgEn                bool                      `protobuf:"varint,4,opt,name=ipsg_en,json=ipsgEn,proto3" json:"ipsg_en,omitempty"`
	TcpRttEstimateEn      bool                      `protobuf:"varint,5,opt,name=tcp_rtt_estimate_en,json=tcpRttEstimateEn,proto3" json:"tcp_rtt_estimate_en,omitempty"`
	SessionIdleTimeout    uint32                    `protobuf:"varint,6,opt,name=session_idle_timeout,json=sessionIdleTimeout,proto3" json:"session_idle_timeout,omitempty"`
	TcpCnxnSetupTimeout   uint32                    `protobuf:"varint,7,opt,name=tcp_cnxn_setup_timeout,json=tcpCnxnSetupTimeout,proto3" json:"tcp_cnxn_setup_timeout,omitempty"`
	TcpCloseTimeout       uint32                    `protobuf:"varint,8,opt,name=tcp_close_timeout,json=tcpCloseTimeout,proto3" json:"tcp_close_timeout,omitempty"`
	TcpCloseWaitTimeout   uint32                    `protobuf:"varint,9,opt,name=tcp_close_wait_timeout,json=tcpCloseWaitTimeout,proto3" json:"tcp_close_wait_timeout,omitempty"`
	TcpNonSynFirstPktDrop bool                      `protobuf:"varint,10,opt,name=tcp_non_syn_first_pkt_drop,json=tcpNonSynFirstPktDrop,proto3" json:"tcp_non_syn_first_pkt_drop,omitempty"`
	IpNormalizationEn     bool                      `protobuf:"varint,11,opt,name=ip_normalization_en,json=ipNormalizationEn,proto3" json:"ip_normalization_en,omitempty"`
	TcpNormalizationEn    bool                      `protobuf:"varint,12,opt,name=tcp_normalization_en,json=tcpNormalizationEn,proto3" json:"tcp_normalization_en,omitempty"`
	IcmpNormalizationEn   bool                      `protobuf:"varint,13,opt,name=icmp_normalization_en,json=icmpNormalizationEn,proto3" json:"icmp_normalization_en,omitempty"`
	// IP normalization knobs
	IpTtlChangeDetectEn bool                `protobuf:"varint,20,opt,name=ip_ttl_change_detect_en,json=ipTtlChangeDetectEn,proto3" json:"ip_ttl_change_detect_en,omitempty"`
	IpRsvdFlagsAction   NormalizationAction `protobuf:"varint,21,opt,name=ip_rsvd_flags_action,json=ipRsvdFlagsAction,proto3,enum=nwsec.NormalizationAction" json:"ip_rsvd_flags_action,omitempty"`
	IpDfAction          NormalizationAction `protobuf:"varint,22,opt,name=ip_df_action,json=ipDfAction,proto3,enum=nwsec.NormalizationAction" json:"ip_df_action,omitempty"`
	IpOptionsAction     NormalizationAction `protobuf:"varint,23,opt,name=ip_options_action,json=ipOptionsAction,proto3,enum=nwsec.NormalizationAction" json:"ip_options_action,omitempty"`
	IpInvalidLenAction  NormalizationAction `protobuf:"varint,24,opt,name=ip_invalid_len_action,json=ipInvalidLenAction,proto3,enum=nwsec.NormalizationAction" json:"ip_invalid_len_action,omitempty"`
	IpNormalizeTtl      uint32              `protobuf:"varint,25,opt,name=ip_normalize_ttl,json=ipNormalizeTtl,proto3" json:"ip_normalize_ttl,omitempty" range:0-255`
	// ICMP/ICMPv6 normalization knobs
	IcmpInvalidCodeAction  NormalizationAction `protobuf:"varint,30,opt,name=icmp_invalid_code_action,json=icmpInvalidCodeAction,proto3,enum=nwsec.NormalizationAction" json:"icmp_invalid_code_action,omitempty"`
	IcmpDeprecatedMsgsDrop bool                `protobuf:"varint,31,opt,name=icmp_deprecated_msgs_drop,json=icmpDeprecatedMsgsDrop,proto3" json:"icmp_deprecated_msgs_drop,omitempty"`
	IcmpRedirectMsgDrop    bool                `protobuf:"varint,32,opt,name=icmp_redirect_msg_drop,json=icmpRedirectMsgDrop,proto3" json:"icmp_redirect_msg_drop,omitempty"`
	// TCP normalization knobs
	TcpSplitHandshakeDrop         bool                `protobuf:"varint,41,opt,name=tcp_split_handshake_drop,json=tcpSplitHandshakeDrop,proto3" json:"tcp_split_handshake_drop,omitempty"`
	TcpRsvdFlagsAction            NormalizationAction `protobuf:"varint,42,opt,name=tcp_rsvd_flags_action,json=tcpRsvdFlagsAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_rsvd_flags_action,omitempty"`
	TcpUnexpectedMssAction        NormalizationAction `protobuf:"varint,43,opt,name=tcp_unexpected_mss_action,json=tcpUnexpectedMssAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_mss_action,omitempty"`
	TcpUnexpectedWinScaleAction   NormalizationAction `protobuf:"varint,44,opt,name=tcp_unexpected_win_scale_action,json=tcpUnexpectedWinScaleAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_win_scale_action,omitempty"`
	TcpUnexpectedSackPermAction   NormalizationAction `protobuf:"varint,45,opt,name=tcp_unexpected_sack_perm_action,json=tcpUnexpectedSackPermAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_sack_perm_action,omitempty"`
	TcpUrgPtrNotSetAction         NormalizationAction `protobuf:"varint,46,opt,name=tcp_urg_ptr_not_set_action,json=tcpUrgPtrNotSetAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_ptr_not_set_action,omitempty"`
	TcpUrgFlagNotSetAction        NormalizationAction `protobuf:"varint,47,opt,name=tcp_urg_flag_not_set_action,json=tcpUrgFlagNotSetAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_flag_not_set_action,omitempty"`
	TcpUrgPayloadMissingAction    NormalizationAction `protobuf:"varint,48,opt,name=tcp_urg_payload_missing_action,json=tcpUrgPayloadMissingAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_payload_missing_action,omitempty"`
	TcpRstWithDataAction          NormalizationAction `protobuf:"varint,49,opt,name=tcp_rst_with_data_action,json=tcpRstWithDataAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_rst_with_data_action,omitempty"`
	TcpDataLenGtMssAction         NormalizationAction `protobuf:"varint,50,opt,name=tcp_data_len_gt_mss_action,json=tcpDataLenGtMssAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_data_len_gt_mss_action,omitempty"`
	TcpDataLenGtWinSizeAction     NormalizationAction `protobuf:"varint,51,opt,name=tcp_data_len_gt_win_size_action,json=tcpDataLenGtWinSizeAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_data_len_gt_win_size_action,omitempty"`
	TcpUnexpectedTsOptionAction   NormalizationAction `protobuf:"varint,52,opt,name=tcp_unexpected_ts_option_action,json=tcpUnexpectedTsOptionAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_ts_option_action,omitempty"`
	TcpUnexpectedEchoTsAction     NormalizationAction `protobuf:"varint,53,opt,name=tcp_unexpected_echo_ts_action,json=tcpUnexpectedEchoTsAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_echo_ts_action,omitempty"`
	TcpUnexpectedSackOptionAction NormalizationAction `protobuf:"varint,54,opt,name=tcp_unexpected_sack_option_action,json=tcpUnexpectedSackOptionAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_sack_option_action,omitempty"`
	TcpTsNotPresentDrop           bool                `protobuf:"varint,55,opt,name=tcp_ts_not_present_drop,json=tcpTsNotPresentDrop,proto3" json:"tcp_ts_not_present_drop,omitempty"`
	// We will check for the following cases for invalid TCP flags
	// 1. SYN + FIN
	// 2. SYN + RST
	// 3. All TCP flags set (tcp_flags = 0xFF)
	// 4. No TCP flags set (tcp_flags = 0x0)
	TcpInvalidFlagsDrop bool `protobuf:"varint,56,opt,name=tcp_invalid_flags_drop,json=tcpInvalidFlagsDrop,proto3" json:"tcp_invalid_flags_drop,omitempty"`
	TcpNonsynNoackDrop  bool `protobuf:"varint,57,opt,name=tcp_nonsyn_noack_drop,json=tcpNonsynNoackDrop,proto3" json:"tcp_nonsyn_noack_drop,omitempty"`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{0} }

func (m *SecurityProfileSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityProfileSpec) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityProfileSpec) GetCnxnTrackingEn() bool {
	if m != nil {
		return m.CnxnTrackingEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpsgEn() bool {
	if m != nil {
		return m.IpsgEn
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpRttEstimateEn() bool {
	if m != nil {
		return m.TcpRttEstimateEn
	}
	return false
}

func (m *SecurityProfileSpec) GetSessionIdleTimeout() uint32 {
	if m != nil {
		return m.SessionIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpCnxnSetupTimeout() uint32 {
	if m != nil {
		return m.TcpCnxnSetupTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpCloseTimeout() uint32 {
	if m != nil {
		return m.TcpCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpCloseWaitTimeout() uint32 {
	if m != nil {
		return m.TcpCloseWaitTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpNonSynFirstPktDrop() bool {
	if m != nil {
		return m.TcpNonSynFirstPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpNormalizationEn() bool {
	if m != nil {
		return m.IpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNormalizationEn() bool {
	if m != nil {
		return m.TcpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpNormalizationEn() bool {
	if m != nil {
		return m.IcmpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpTtlChangeDetectEn() bool {
	if m != nil {
		return m.IpTtlChangeDetectEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpRsvdFlagsAction() NormalizationAction {
	if m != nil {
		return m.IpRsvdFlagsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpDfAction() NormalizationAction {
	if m != nil {
		return m.IpDfAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpOptionsAction() NormalizationAction {
	if m != nil {
		return m.IpOptionsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpInvalidLenAction() NormalizationAction {
	if m != nil {
		return m.IpInvalidLenAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpNormalizeTtl() uint32 {
	if m != nil {
		return m.IpNormalizeTtl
	}
	return 0
}

func (m *SecurityProfileSpec) GetIcmpInvalidCodeAction() NormalizationAction {
	if m != nil {
		return m.IcmpInvalidCodeAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIcmpDeprecatedMsgsDrop() bool {
	if m != nil {
		return m.IcmpDeprecatedMsgsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpRedirectMsgDrop() bool {
	if m != nil {
		return m.IcmpRedirectMsgDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpSplitHandshakeDrop() bool {
	if m != nil {
		return m.TcpSplitHandshakeDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpRsvdFlagsAction() NormalizationAction {
	if m != nil {
		return m.TcpRsvdFlagsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedMssAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedMssAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedWinScaleAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedWinScaleAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedSackPermAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedSackPermAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgPtrNotSetAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgPtrNotSetAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgFlagNotSetAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgFlagNotSetAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgPayloadMissingAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgPayloadMissingAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpRstWithDataAction() NormalizationAction {
	if m != nil {
		return m.TcpRstWithDataAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpDataLenGtMssAction() NormalizationAction {
	if m != nil {
		return m.TcpDataLenGtMssAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpDataLenGtWinSizeAction() NormalizationAction {
	if m != nil {
		return m.TcpDataLenGtWinSizeAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedTsOptionAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedTsOptionAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedEchoTsAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedEchoTsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedSackOptionAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedSackOptionAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpTsNotPresentDrop() bool {
	if m != nil {
		return m.TcpTsNotPresentDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpInvalidFlagsDrop() bool {
	if m != nil {
		return m.TcpInvalidFlagsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNonsynNoackDrop() bool {
	if m != nil {
		return m.TcpNonsynNoackDrop
	}
	return false
}

// SecurityProfileRequestMsg is batched add or modify profile request
type SecurityProfileRequestMsg struct {
	Request []*SecurityProfileSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileRequestMsg) Reset()                    { *m = SecurityProfileRequestMsg{} }
func (m *SecurityProfileRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileRequestMsg) ProtoMessage()               {}
func (*SecurityProfileRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{1} }

func (m *SecurityProfileRequestMsg) GetRequest() []*SecurityProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityProfile operational status
type SecurityProfileStatus struct {
	ProfileHandle uint64 `protobuf:"fixed64,1,opt,name=profile_handle,json=profileHandle,proto3" json:"profile_handle,omitempty"`
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{2} }

func (m *SecurityProfileStatus) GetProfileHandle() uint64 {
	if m != nil {
		return m.ProfileHandle
	}
	return 0
}

// SecurityProfileResponse is response to SecurityProfileSpec
type SecurityProfileResponse struct {
	ApiStatus     ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	ProfileStatus *SecurityProfileStatus `protobuf:"bytes,2,opt,name=profile_status,json=profileStatus" json:"profile_status,omitempty"`
}

func (m *SecurityProfileResponse) Reset()                    { *m = SecurityProfileResponse{} }
func (m *SecurityProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponse) ProtoMessage()               {}
func (*SecurityProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{3} }

func (m *SecurityProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileResponse) GetProfileStatus() *SecurityProfileStatus {
	if m != nil {
		return m.ProfileStatus
	}
	return nil
}

// SecurityProfileResponseMsg is batched response to SecurityProfileRequestMsg
type SecurityProfileResponseMsg struct {
	Response []*SecurityProfileResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileResponseMsg) Reset()                    { *m = SecurityProfileResponseMsg{} }
func (m *SecurityProfileResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponseMsg) ProtoMessage()               {}
func (*SecurityProfileResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{4} }

func (m *SecurityProfileResponseMsg) GetResponse() []*SecurityProfileResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityProfileDeleteRequest is used to delete a SecurityProfile profile
type SecurityProfileDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify SecurityProfile being deleted
	KeyOrHandle *SecurityProfileKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *SecurityProfileDeleteRequest) Reset()         { *m = SecurityProfileDeleteRequest{} }
func (m *SecurityProfileDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequest) ProtoMessage()    {}
func (*SecurityProfileDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{5}
}

func (m *SecurityProfileDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityProfileDeleteRequest) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityProfileDeleteRequestMsg is used to delete a batch of SecurityProfile profiles
type SecurityProfileDeleteRequestMsg struct {
	Request []*SecurityProfileDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileDeleteRequestMsg) Reset()         { *m = SecurityProfileDeleteRequestMsg{} }
func (m *SecurityProfileDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityProfileDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{6}
}

func (m *SecurityProfileDeleteRequestMsg) GetRequest() []*SecurityProfileDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityProfileResponse is response to SecurityProfileSpec
type SecurityProfileDeleteResponse struct {
	ApiStatus     ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	ProfileStatus *SecurityProfileStatus `protobuf:"bytes,2,opt,name=profile_status,json=profileStatus" json:"profile_status,omitempty"`
}

func (m *SecurityProfileDeleteResponse) Reset()         { *m = SecurityProfileDeleteResponse{} }
func (m *SecurityProfileDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponse) ProtoMessage()    {}
func (*SecurityProfileDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{7}
}

func (m *SecurityProfileDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileDeleteResponse) GetProfileStatus() *SecurityProfileStatus {
	if m != nil {
		return m.ProfileStatus
	}
	return nil
}

// SecurityProfileDeleteResponseMsg is batched response to SecurityProfileDeleteRequestMsg
type SecurityProfileDeleteResponseMsg struct {
	Response []*SecurityProfileDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileDeleteResponseMsg) Reset()         { *m = SecurityProfileDeleteResponseMsg{} }
func (m *SecurityProfileDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityProfileDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{8}
}

func (m *SecurityProfileDeleteResponseMsg) GetResponse() []*SecurityProfileDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityProfileGetRequest is used to get information about a L2 Segment
type SecurityProfileGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security profile's identifier for retrieval
	KeyOrHandle *SecurityProfileKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *SecurityProfileGetRequest) Reset()                    { *m = SecurityProfileGetRequest{} }
func (m *SecurityProfileGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequest) ProtoMessage()               {}
func (*SecurityProfileGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{9} }

func (m *SecurityProfileGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityProfileGetRequest) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityProfileGetRequestMsg is batched GET request for SecurityProfile profiles
type SecurityProfileGetRequestMsg struct {
	Request []*SecurityProfileGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileGetRequestMsg) Reset()         { *m = SecurityProfileGetRequestMsg{} }
func (m *SecurityProfileGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequestMsg) ProtoMessage()    {}
func (*SecurityProfileGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{10}
}

func (m *SecurityProfileGetRequestMsg) GetRequest() []*SecurityProfileGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityProfileStats is the statistics object for each SecurityProfile profile
type SecurityProfileStats struct {
}

func (m *SecurityProfileStats) Reset()                    { *m = SecurityProfileStats{} }
func (m *SecurityProfileStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStats) ProtoMessage()               {}
func (*SecurityProfileStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{11} }

// SecurityProfileGetResponse captures all the information about a SecurityProfile profile
type SecurityProfileGetResponse struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Spec      *SecurityProfileSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityProfileStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityProfileStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityProfileGetResponse) Reset()                    { *m = SecurityProfileGetResponse{} }
func (m *SecurityProfileGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponse) ProtoMessage()               {}
func (*SecurityProfileGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{12} }

func (m *SecurityProfileGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileGetResponse) GetSpec() *SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityProfileGetResponse) GetStatus() *SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityProfileGetResponse) GetStats() *SecurityProfileStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityProfileGetResponseMsg is the batched response to SecurityProfileGetRequestMsg
type SecurityProfileGetResponseMsg struct {
	Response []*SecurityProfileGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileGetResponseMsg) Reset()         { *m = SecurityProfileGetResponseMsg{} }
func (m *SecurityProfileGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponseMsg) ProtoMessage()    {}
func (*SecurityProfileGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{13}
}

func (m *SecurityProfileGetResponseMsg) GetResponse() []*SecurityProfileGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Service object identifies an app defined by IP protocol and TCP/UDP port
// in most cases. This object also can specify blanket apps like all TCP or
// UDP traffic, all IP traffic, ICMP type/code combinations etc.
type Service struct {
	IpProtocol IPProtocol `protobuf:"varint,1,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol" json:"ip_protocol,omitempty"`
	// Types that are valid to be assigned to L4Info:
	//	*Service_DstPort
	//	*Service_IcmpMsgType
	L4Info isService_L4Info `protobuf_oneof:"l4_info"`
	Alg    ALGName          `protobuf:"varint,4,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{14} }

type isService_L4Info interface {
	isService_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Service_DstPort struct {
	DstPort uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort,proto3,oneof"`
}
type Service_IcmpMsgType struct {
	IcmpMsgType ICMPMsgType `protobuf:"varint,3,opt,name=icmp_msg_type,json=icmpMsgType,proto3,enum=types.ICMPMsgType,oneof"`
}

func (*Service_DstPort) isService_L4Info()     {}
func (*Service_IcmpMsgType) isService_L4Info() {}

func (m *Service) GetL4Info() isService_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *Service) GetIpProtocol() IPProtocol {
	if m != nil {
		return m.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *Service) GetDstPort() uint32 {
	if x, ok := m.GetL4Info().(*Service_DstPort); ok {
		return x.DstPort
	}
	return 0
}

func (m *Service) GetIcmpMsgType() ICMPMsgType {
	if x, ok := m.GetL4Info().(*Service_IcmpMsgType); ok {
		return x.IcmpMsgType
	}
	return ICMPMsgType_ICMP_MSG_TYPE_NONE
}

func (m *Service) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Service) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Service_OneofMarshaler, _Service_OneofUnmarshaler, _Service_OneofSizer, []interface{}{
		(*Service_DstPort)(nil),
		(*Service_IcmpMsgType)(nil),
	}
}

func _Service_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Service)
	// l4_info
	switch x := m.L4Info.(type) {
	case *Service_DstPort:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DstPort))
	case *Service_IcmpMsgType:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IcmpMsgType))
	case nil:
	default:
		return fmt.Errorf("Service.L4Info has unexpected type %T", x)
	}
	return nil
}

func _Service_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Service)
	switch tag {
	case 2: // l4_info.dst_port
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &Service_DstPort{uint32(x)}
		return true, err
	case 3: // l4_info.icmp_msg_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &Service_IcmpMsgType{ICMPMsgType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Service_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Service)
	// l4_info
	switch x := m.L4Info.(type) {
	case *Service_DstPort:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DstPort))
	case *Service_IcmpMsgType:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IcmpMsgType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FirewallRuleSpec defines a stateful firewall rule that is part of a
// SecurityGroupSpec
type FirewallRuleSpec struct {
	Svc    []*Service     `protobuf:"bytes,2,rep,name=svc" json:"svc,omitempty"`
	Action FirewallAction `protobuf:"varint,3,opt,name=action,proto3,enum=nwsec.FirewallAction" json:"action,omitempty"`
	Log    bool           `protobuf:"varint,4,opt,name=log,proto3" json:"log,omitempty"`
}

func (m *FirewallRuleSpec) Reset()                    { *m = FirewallRuleSpec{} }
func (m *FirewallRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FirewallRuleSpec) ProtoMessage()               {}
func (*FirewallRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{15} }

func (m *FirewallRuleSpec) GetSvc() []*Service {
	if m != nil {
		return m.Svc
	}
	return nil
}

func (m *FirewallRuleSpec) GetAction() FirewallAction {
	if m != nil {
		return m.Action
	}
	return FirewallAction_FIREWALL_ACTION_NONE
}

func (m *FirewallRuleSpec) GetLog() bool {
	if m != nil {
		return m.Log
	}
	return false
}

// ingress policy for the security group
type SGPolicy struct {
	InFwRules []*FirewallRuleSpec `protobuf:"bytes,1,rep,name=in_fw_rules,json=inFwRules" json:"in_fw_rules,omitempty"`
	EgFwRules []*FirewallRuleSpec `protobuf:"bytes,2,rep,name=eg_fw_rules,json=egFwRules" json:"eg_fw_rules,omitempty"`
}

func (m *SGPolicy) Reset()                    { *m = SGPolicy{} }
func (m *SGPolicy) String() string            { return proto.CompactTextString(m) }
func (*SGPolicy) ProtoMessage()               {}
func (*SGPolicy) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{16} }

func (m *SGPolicy) GetInFwRules() []*FirewallRuleSpec {
	if m != nil {
		return m.InFwRules
	}
	return nil
}

func (m *SGPolicy) GetEgFwRules() []*FirewallRuleSpec {
	if m != nil {
		return m.EgFwRules
	}
	return nil
}

// SecurityGroupPolicySpec captures the policy for a security group pair (aka. group of
// endpoints or enic interfaces) in both directions from workload's perspective.
// This policy will be attached to enic interface or an endpoint so it applies
// to the traffic from/to that workload. If no match is found for the new
// session in the slow path, either a drop flow will be installed or packet will
// be dropped without creating drop flow
type SecurityGroupPolicySpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
	PolicyRules *SGPolicy                     `protobuf:"bytes,3,opt,name=policy_rules,json=policyRules" json:"policy_rules,omitempty"`
}

func (m *SecurityGroupPolicySpec) Reset()                    { *m = SecurityGroupPolicySpec{} }
func (m *SecurityGroupPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicySpec) ProtoMessage()               {}
func (*SecurityGroupPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{17} }

func (m *SecurityGroupPolicySpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupPolicySpec) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityGroupPolicySpec) GetPolicyRules() *SGPolicy {
	if m != nil {
		return m.PolicyRules
	}
	return nil
}

// SecurityGroupPolicyRequestMsg is batched add or modify security group policy request
type SecurityGroupPolicyRequestMsg struct {
	Request []*SecurityGroupPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyRequestMsg) Reset()         { *m = SecurityGroupPolicyRequestMsg{} }
func (m *SecurityGroupPolicyRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{18}
}

func (m *SecurityGroupPolicyRequestMsg) GetRequest() []*SecurityGroupPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security group operational status
type SecurityGroupPolicyStatus struct {
	PolicyHandle uint64 `protobuf:"fixed64,1,opt,name=policy_handle,json=policyHandle,proto3" json:"policy_handle,omitempty"`
}

func (m *SecurityGroupPolicyStatus) Reset()                    { *m = SecurityGroupPolicyStatus{} }
func (m *SecurityGroupPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyStatus) ProtoMessage()               {}
func (*SecurityGroupPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{19} }

func (m *SecurityGroupPolicyStatus) GetPolicyHandle() uint64 {
	if m != nil {
		return m.PolicyHandle
	}
	return 0
}

// SecurityGroupResponse is the response to SecurityGroupPolicySpec
type SecurityGroupPolicyResponse struct {
	ApiStatus ApiStatus                  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *SecurityGroupPolicyStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityGroupPolicyResponse) Reset()         { *m = SecurityGroupPolicyResponse{} }
func (m *SecurityGroupPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{20}
}

func (m *SecurityGroupPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupPolicyResponse) GetStatus() *SecurityGroupPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SecurityGroupResponseMsg is batched response to SecurityGroupPolicyRequestMsg
type SecurityGroupPolicyResponseMsg struct {
	Response []*SecurityGroupPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupPolicyResponseMsg) Reset()         { *m = SecurityGroupPolicyResponseMsg{} }
func (m *SecurityGroupPolicyResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{21}
}

func (m *SecurityGroupPolicyResponseMsg) GetResponse() []*SecurityGroupPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupPolicyDeleteRequest is used to delete a security group policy
type SecurityGroupPolicyDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityGroupPolicyDeleteRequest) Reset()         { *m = SecurityGroupPolicyDeleteRequest{} }
func (m *SecurityGroupPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{22}
}

func (m *SecurityGroupPolicyDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupPolicyDeleteRequest) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupDeleteRequestMsg is used to delete a batch of security group policies.
type SecurityGroupPolicyDeleteRequestMsg struct {
	Request []*SecurityGroupPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Reset()         { *m = SecurityGroupPolicyDeleteRequestMsg{} }
func (m *SecurityGroupPolicyDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{23}
}

func (m *SecurityGroupPolicyDeleteRequestMsg) GetRequest() []*SecurityGroupPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityGroupPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
}

func (m *SecurityGroupPolicyDeleteResponse) Reset()         { *m = SecurityGroupPolicyDeleteResponse{} }
func (m *SecurityGroupPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{24}
}

func (m *SecurityGroupPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// SecurityGroupPolicyDeleteResponseMsg is batched response to
// SecurityGroupPolicyDeleteRequestMsg
type SecurityGroupPolicyDeleteResponseMsg struct {
	Response []*SecurityGroupPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Reset()         { *m = SecurityGroupPolicyDeleteResponseMsg{} }
func (m *SecurityGroupPolicyDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{25}
}

func (m *SecurityGroupPolicyDeleteResponseMsg) GetResponse() []*SecurityGroupPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupPolicyGetRequest is used to get information about a security group policy
type SecurityGroupPolicyGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityGroupPolicyGetRequest) Reset()         { *m = SecurityGroupPolicyGetRequest{} }
func (m *SecurityGroupPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetRequest) ProtoMessage()    {}
func (*SecurityGroupPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{26}
}

func (m *SecurityGroupPolicyGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupPolicyGetRequest) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupGetRequestMsg is batched GET request for security group policies
type SecurityGroupPolicyGetRequestMsg struct {
	Request []*SecurityGroupPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyGetRequestMsg) Reset()         { *m = SecurityGroupPolicyGetRequestMsg{} }
func (m *SecurityGroupPolicyGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{27}
}

func (m *SecurityGroupPolicyGetRequestMsg) GetRequest() []*SecurityGroupPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupStats is the statistics object for a security group
type SecurityGroupPolicyStats struct {
}

func (m *SecurityGroupPolicyStats) Reset()                    { *m = SecurityGroupPolicyStats{} }
func (m *SecurityGroupPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyStats) ProtoMessage()               {}
func (*SecurityGroupPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{28} }

// SecurityGroupGetResponse captures all the information about a security group
type SecurityGroupPolicyGetResponse struct {
	ApiStatus ApiStatus                  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Spec      *SecurityGroupPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityGroupPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityGroupPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityGroupPolicyGetResponse) Reset()         { *m = SecurityGroupPolicyGetResponse{} }
func (m *SecurityGroupPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{29}
}

func (m *SecurityGroupPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupPolicyGetResponse) GetSpec() *SecurityGroupPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponse) GetStatus() *SecurityGroupPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponse) GetStats() *SecurityGroupPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityGroupPolicyGetResponseMsg is batched response to SecurityGroupGetRequestMsg
type SecurityGroupPolicyGetResponseMsg struct {
	Response  []*SecurityGroupPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	ApiStatus ApiStatus                         `protobuf:"varint,2,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SecurityGroupPolicyGetResponseMsg) Reset()         { *m = SecurityGroupPolicyGetResponseMsg{} }
func (m *SecurityGroupPolicyGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{30}
}

func (m *SecurityGroupPolicyGetResponseMsg) GetResponse() []*SecurityGroupPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type SecurityGroupSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// Key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityGroupSpec) Reset()                    { *m = SecurityGroupSpec{} }
func (m *SecurityGroupSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupSpec) ProtoMessage()               {}
func (*SecurityGroupSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{31} }

func (m *SecurityGroupSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupSpec) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupRequestMsg is batched add or modify security group policy request
type SecurityGroupRequestMsg struct {
	Request []*SecurityGroupSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupRequestMsg) Reset()                    { *m = SecurityGroupRequestMsg{} }
func (m *SecurityGroupRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupRequestMsg) ProtoMessage()               {}
func (*SecurityGroupRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{32} }

func (m *SecurityGroupRequestMsg) GetRequest() []*SecurityGroupSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security group operational status
type SecurityGroupStatus struct {
	SgHandle uint64 `protobuf:"fixed64,1,opt,name=sg_handle,json=sgHandle,proto3" json:"sg_handle,omitempty"`
}

func (m *SecurityGroupStatus) Reset()                    { *m = SecurityGroupStatus{} }
func (m *SecurityGroupStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupStatus) ProtoMessage()               {}
func (*SecurityGroupStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{33} }

func (m *SecurityGroupStatus) GetSgHandle() uint64 {
	if m != nil {
		return m.SgHandle
	}
	return 0
}

// SecurityGroupResponse is the response to SecurityGroupSpec
type SecurityGroupResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *SecurityGroupStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityGroupResponse) Reset()                    { *m = SecurityGroupResponse{} }
func (m *SecurityGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupResponse) ProtoMessage()               {}
func (*SecurityGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{34} }

func (m *SecurityGroupResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupResponse) GetStatus() *SecurityGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SecurityGroupResponseMsg is batched response to SecurityGroupRequestMsg
type SecurityGroupResponseMsg struct {
	Response []*SecurityGroupResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupResponseMsg) Reset()                    { *m = SecurityGroupResponseMsg{} }
func (m *SecurityGroupResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupResponseMsg) ProtoMessage()               {}
func (*SecurityGroupResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{35} }

func (m *SecurityGroupResponseMsg) GetResponse() []*SecurityGroupResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupDeleteRequest is used to delete a security group
type SecurityGroupDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityGroupDeleteRequest) Reset()                    { *m = SecurityGroupDeleteRequest{} }
func (m *SecurityGroupDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteRequest) ProtoMessage()               {}
func (*SecurityGroupDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{36} }

func (m *SecurityGroupDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupDeleteRequest) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupDeleteRequestMsg is used to delete a batch of security groups
type SecurityGroupDeleteRequestMsg struct {
	Request []*SecurityGroupDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupDeleteRequestMsg) Reset()         { *m = SecurityGroupDeleteRequestMsg{} }
func (m *SecurityGroupDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityGroupDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{37}
}

func (m *SecurityGroupDeleteRequestMsg) GetRequest() []*SecurityGroupDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupDeleteResponseMsg is batched response to
// SecurityGroupDeleteRequestMsg
type SecurityGroupDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status"`
}

func (m *SecurityGroupDeleteResponseMsg) Reset()         { *m = SecurityGroupDeleteResponseMsg{} }
func (m *SecurityGroupDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityGroupDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{38}
}

func (m *SecurityGroupDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// SecurityGroupGetRequest is used to get information about a security group
type SecurityGroupGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityGroupGetRequest) Reset()                    { *m = SecurityGroupGetRequest{} }
func (m *SecurityGroupGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetRequest) ProtoMessage()               {}
func (*SecurityGroupGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{39} }

func (m *SecurityGroupGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupGetRequest) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupGetRequestMsg is batched GET request for security groups
type SecurityGroupGetRequestMsg struct {
	Request []*SecurityGroupGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupGetRequestMsg) Reset()                    { *m = SecurityGroupGetRequestMsg{} }
func (m *SecurityGroupGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetRequestMsg) ProtoMessage()               {}
func (*SecurityGroupGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{40} }

func (m *SecurityGroupGetRequestMsg) GetRequest() []*SecurityGroupGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupStats is the statistics object for a security group
type SecurityGroupStats struct {
}

func (m *SecurityGroupStats) Reset()                    { *m = SecurityGroupStats{} }
func (m *SecurityGroupStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupStats) ProtoMessage()               {}
func (*SecurityGroupStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{41} }

// SecurityGroupGetResponse captures all the information about a security group
type SecurityGroupGetResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Spec      *SecurityGroupSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityGroupStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityGroupStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityGroupGetResponse) Reset()                    { *m = SecurityGroupGetResponse{} }
func (m *SecurityGroupGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetResponse) ProtoMessage()               {}
func (*SecurityGroupGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{42} }

func (m *SecurityGroupGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupGetResponse) GetSpec() *SecurityGroupSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityGroupGetResponse) GetStatus() *SecurityGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityGroupGetResponse) GetStats() *SecurityGroupStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityGroupGetResponseMsg is batched response to SecurityGroupGetRequestMsg
type SecurityGroupGetResponseMsg struct {
	Response  []*SecurityGroupGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	ApiStatus ApiStatus                   `protobuf:"varint,2,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SecurityGroupGetResponseMsg) Reset()         { *m = SecurityGroupGetResponseMsg{} }
func (m *SecurityGroupGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupGetResponseMsg) ProtoMessage()    {}
func (*SecurityGroupGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{43}
}

func (m *SecurityGroupGetResponseMsg) GetResponse() []*SecurityGroupGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SecurityGroupGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type ICMPMsg struct {
	Type ICMPMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=types.ICMPMsgType" json:"type,omitempty"`
	Code uint32      `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *ICMPMsg) Reset()                    { *m = ICMPMsg{} }
func (m *ICMPMsg) String() string            { return proto.CompactTextString(m) }
func (*ICMPMsg) ProtoMessage()               {}
func (*ICMPMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{44} }

func (m *ICMPMsg) GetType() ICMPMsgType {
	if m != nil {
		return m.Type
	}
	return ICMPMsgType_ICMP_MSG_TYPE_NONE
}

func (m *ICMPMsg) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type DoSService struct {
	IpProtocol IPProtocol `protobuf:"varint,1,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol" json:"ip_protocol,omitempty"`
	// Types that are valid to be assigned to L4Info:
	//	*DoSService_DstPort
	//	*DoSService_IcmpMsg
	L4Info isDoSService_L4Info `protobuf_oneof:"l4_info"`
}

func (m *DoSService) Reset()                    { *m = DoSService{} }
func (m *DoSService) String() string            { return proto.CompactTextString(m) }
func (*DoSService) ProtoMessage()               {}
func (*DoSService) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{45} }

type isDoSService_L4Info interface {
	isDoSService_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DoSService_DstPort struct {
	DstPort uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort,proto3,oneof"`
}
type DoSService_IcmpMsg struct {
	IcmpMsg *ICMPMsg `protobuf:"bytes,3,opt,name=icmp_msg,json=icmpMsg,oneof"`
}

func (*DoSService_DstPort) isDoSService_L4Info() {}
func (*DoSService_IcmpMsg) isDoSService_L4Info() {}

func (m *DoSService) GetL4Info() isDoSService_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *DoSService) GetIpProtocol() IPProtocol {
	if m != nil {
		return m.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *DoSService) GetDstPort() uint32 {
	if x, ok := m.GetL4Info().(*DoSService_DstPort); ok {
		return x.DstPort
	}
	return 0
}

func (m *DoSService) GetIcmpMsg() *ICMPMsg {
	if x, ok := m.GetL4Info().(*DoSService_IcmpMsg); ok {
		return x.IcmpMsg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DoSService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DoSService_OneofMarshaler, _DoSService_OneofUnmarshaler, _DoSService_OneofSizer, []interface{}{
		(*DoSService_DstPort)(nil),
		(*DoSService_IcmpMsg)(nil),
	}
}

func _DoSService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DoSService)
	// l4_info
	switch x := m.L4Info.(type) {
	case *DoSService_DstPort:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DstPort))
	case *DoSService_IcmpMsg:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpMsg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DoSService.L4Info has unexpected type %T", x)
	}
	return nil
}

func _DoSService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DoSService)
	switch tag {
	case 2: // l4_info.dst_port
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &DoSService_DstPort{uint32(x)}
		return true, err
	case 3: // l4_info.icmp_msg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPMsg)
		err := b.DecodeMessage(msg)
		m.L4Info = &DoSService_IcmpMsg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DoSService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DoSService)
	// l4_info
	switch x := m.L4Info.(type) {
	case *DoSService_DstPort:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DstPort))
	case *DoSService_IcmpMsg:
		s := proto.Size(x.IcmpMsg)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DoSSessionLimits captures the session limits to be enforced on a security
// group
type DoSSessionLimits struct {
	MaxSessions     uint32 `protobuf:"varint,1,opt,name=max_sessions,json=maxSessions,proto3" json:"max_sessions,omitempty"`
	BlockingTimeout uint32 `protobuf:"varint,2,opt,name=blocking_timeout,json=blockingTimeout,proto3" json:"blocking_timeout,omitempty"`
}

func (m *DoSSessionLimits) Reset()                    { *m = DoSSessionLimits{} }
func (m *DoSSessionLimits) String() string            { return proto.CompactTextString(m) }
func (*DoSSessionLimits) ProtoMessage()               {}
func (*DoSSessionLimits) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46} }

func (m *DoSSessionLimits) GetMaxSessions() uint32 {
	if m != nil {
		return m.MaxSessions
	}
	return 0
}

func (m *DoSSessionLimits) GetBlockingTimeout() uint32 {
	if m != nil {
		return m.BlockingTimeout
	}
	return 0
}

// DoSPolicer is aggregate DoS policer object
type DoSPolicer struct {
	BytesPerSecond uint32 `protobuf:"varint,1,opt,name=bytes_per_second,json=bytesPerSecond,proto3" json:"bytes_per_second,omitempty"`
	PeakRate       uint32 `protobuf:"varint,2,opt,name=peak_rate,json=peakRate,proto3" json:"peak_rate,omitempty"`
	BurstSize      uint32 `protobuf:"varint,3,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
}

func (m *DoSPolicer) Reset()                    { *m = DoSPolicer{} }
func (m *DoSPolicer) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicer) ProtoMessage()               {}
func (*DoSPolicer) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{47} }

func (m *DoSPolicer) GetBytesPerSecond() uint32 {
	if m != nil {
		return m.BytesPerSecond
	}
	return 0
}

func (m *DoSPolicer) GetPeakRate() uint32 {
	if m != nil {
		return m.PeakRate
	}
	return 0
}

func (m *DoSPolicer) GetBurstSize() uint32 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

// DoSFloodLimits object captures the flood limits configuration
type DoSFloodLimits struct {
	RestrictLimits *DoSFloodLimits_RestrictLimits `protobuf:"bytes,1,opt,name=restrict_limits,json=restrictLimits" json:"restrict_limits,omitempty"`
	ProtectLimits  *DoSFloodLimits_ProtectLimits  `protobuf:"bytes,2,opt,name=protect_limits,json=protectLimits" json:"protect_limits,omitempty"`
}

func (m *DoSFloodLimits) Reset()                    { *m = DoSFloodLimits{} }
func (m *DoSFloodLimits) String() string            { return proto.CompactTextString(m) }
func (*DoSFloodLimits) ProtoMessage()               {}
func (*DoSFloodLimits) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{48} }

func (m *DoSFloodLimits) GetRestrictLimits() *DoSFloodLimits_RestrictLimits {
	if m != nil {
		return m.RestrictLimits
	}
	return nil
}

func (m *DoSFloodLimits) GetProtectLimits() *DoSFloodLimits_ProtectLimits {
	if m != nil {
		return m.ProtectLimits
	}
	return nil
}

// default and only action in restrict phase is Random Early Drop (RED)
type DoSFloodLimits_RestrictLimits struct {
	Pps      uint32 `protobuf:"varint,1,opt,name=pps,proto3" json:"pps,omitempty"`
	BurstPps uint32 `protobuf:"varint,2,opt,name=burst_pps,json=burstPps,proto3" json:"burst_pps,omitempty"`
	Duration uint32 `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *DoSFloodLimits_RestrictLimits) Reset()         { *m = DoSFloodLimits_RestrictLimits{} }
func (m *DoSFloodLimits_RestrictLimits) String() string { return proto.CompactTextString(m) }
func (*DoSFloodLimits_RestrictLimits) ProtoMessage()    {}
func (*DoSFloodLimits_RestrictLimits) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{48, 0}
}

func (m *DoSFloodLimits_RestrictLimits) GetPps() uint32 {
	if m != nil {
		return m.Pps
	}
	return 0
}

func (m *DoSFloodLimits_RestrictLimits) GetBurstPps() uint32 {
	if m != nil {
		return m.BurstPps
	}
	return 0
}

func (m *DoSFloodLimits_RestrictLimits) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// default and only action in protection phase is drop
type DoSFloodLimits_ProtectLimits struct {
	Pps      uint32 `protobuf:"varint,1,opt,name=pps,proto3" json:"pps,omitempty"`
	BurstPps uint32 `protobuf:"varint,2,opt,name=burst_pps,json=burstPps,proto3" json:"burst_pps,omitempty"`
	Duration uint32 `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *DoSFloodLimits_ProtectLimits) Reset()         { *m = DoSFloodLimits_ProtectLimits{} }
func (m *DoSFloodLimits_ProtectLimits) String() string { return proto.CompactTextString(m) }
func (*DoSFloodLimits_ProtectLimits) ProtoMessage()    {}
func (*DoSFloodLimits_ProtectLimits) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{48, 1}
}

func (m *DoSFloodLimits_ProtectLimits) GetPps() uint32 {
	if m != nil {
		return m.Pps
	}
	return 0
}

func (m *DoSFloodLimits_ProtectLimits) GetBurstPps() uint32 {
	if m != nil {
		return m.BurstPps
	}
	return 0
}

func (m *DoSFloodLimits_ProtectLimits) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// DoSProtectionSpec defines DoS protection policy for a security group
type DoSProtectionSpec struct {
	Svc *DoSService `protobuf:"bytes,1,opt,name=svc" json:"svc,omitempty"`
	// service for which rest of
	// the DoS config to be
	// applied on
	SessionSetupRate  uint32            `protobuf:"varint,2,opt,name=session_setup_rate,json=sessionSetupRate,proto3" json:"session_setup_rate,omitempty"`
	SessionLimits     *DoSSessionLimits `protobuf:"bytes,3,opt,name=session_limits,json=sessionLimits" json:"session_limits,omitempty"`
	Policer           *DoSPolicer       `protobuf:"bytes,4,opt,name=policer" json:"policer,omitempty"`
	TcpSynFloodLimits *DoSFloodLimits   `protobuf:"bytes,5,opt,name=tcp_syn_flood_limits,json=tcpSynFloodLimits" json:"tcp_syn_flood_limits,omitempty"`
	UdpFloodLimits    *DoSFloodLimits   `protobuf:"bytes,6,opt,name=udp_flood_limits,json=udpFloodLimits" json:"udp_flood_limits,omitempty"`
	IcmpFloodLimits   *DoSFloodLimits   `protobuf:"bytes,7,opt,name=icmp_flood_limits,json=icmpFloodLimits" json:"icmp_flood_limits,omitempty"`
	OtherFloodLimits  *DoSFloodLimits   `protobuf:"bytes,8,opt,name=other_flood_limits,json=otherFloodLimits" json:"other_flood_limits,omitempty"`
	// traffic (IP and non-IP)
	PeerSgHandle uint64 `protobuf:"varint,9,opt,name=peer_sg_handle,json=peerSgHandle,proto3" json:"peer_sg_handle,omitempty"`
}

func (m *DoSProtectionSpec) Reset()                    { *m = DoSProtectionSpec{} }
func (m *DoSProtectionSpec) String() string            { return proto.CompactTextString(m) }
func (*DoSProtectionSpec) ProtoMessage()               {}
func (*DoSProtectionSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{49} }

func (m *DoSProtectionSpec) GetSvc() *DoSService {
	if m != nil {
		return m.Svc
	}
	return nil
}

func (m *DoSProtectionSpec) GetSessionSetupRate() uint32 {
	if m != nil {
		return m.SessionSetupRate
	}
	return 0
}

func (m *DoSProtectionSpec) GetSessionLimits() *DoSSessionLimits {
	if m != nil {
		return m.SessionLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetPolicer() *DoSPolicer {
	if m != nil {
		return m.Policer
	}
	return nil
}

func (m *DoSProtectionSpec) GetTcpSynFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.TcpSynFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetUdpFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.UdpFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetIcmpFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.IcmpFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetOtherFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.OtherFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetPeerSgHandle() uint64 {
	if m != nil {
		return m.PeerSgHandle
	}
	return 0
}

// ingress policy for DoS
type IngressDoSPolicy struct {
	DosProtection *DoSProtectionSpec `protobuf:"bytes,1,opt,name=dos_protection,json=dosProtection" json:"dos_protection,omitempty"`
}

func (m *IngressDoSPolicy) Reset()                    { *m = IngressDoSPolicy{} }
func (m *IngressDoSPolicy) String() string            { return proto.CompactTextString(m) }
func (*IngressDoSPolicy) ProtoMessage()               {}
func (*IngressDoSPolicy) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{50} }

func (m *IngressDoSPolicy) GetDosProtection() *DoSProtectionSpec {
	if m != nil {
		return m.DosProtection
	}
	return nil
}

// egress policy for DoS
type EgressDoSPolicy struct {
	DosProtection *DoSProtectionSpec `protobuf:"bytes,1,opt,name=dos_protection,json=dosProtection" json:"dos_protection,omitempty"`
}

func (m *EgressDoSPolicy) Reset()                    { *m = EgressDoSPolicy{} }
func (m *EgressDoSPolicy) String() string            { return proto.CompactTextString(m) }
func (*EgressDoSPolicy) ProtoMessage()               {}
func (*EgressDoSPolicy) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{51} }

func (m *EgressDoSPolicy) GetDosProtection() *DoSProtectionSpec {
	if m != nil {
		return m.DosProtection
	}
	return nil
}

// DoSPolicySpec that has the ingressDosPolicy and EgressDoSPolicy,
// Spec is identified by the handle. HAL will assign a unique handle for each
// DoSPolicy object and the clients are expected to pass the handle for
// Get/Modify/Delete calls. Note that there is no identifier for this object
type DoSPolicySpec struct {
	Meta          *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	IngressPolicy *IngressDoSPolicy `protobuf:"bytes,2,opt,name=ingress_policy,json=ingressPolicy" json:"ingress_policy,omitempty"`
	EgressPolicy  *EgressDoSPolicy  `protobuf:"bytes,3,opt,name=egress_policy,json=egressPolicy" json:"egress_policy,omitempty"`
	DosHandle     uint64            `protobuf:"fixed64,4,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
	SgHandle      []uint64          `protobuf:"varint,5,rep,packed,name=sg_handle,json=sgHandle" json:"sg_handle,omitempty"`
}

func (m *DoSPolicySpec) Reset()                    { *m = DoSPolicySpec{} }
func (m *DoSPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicySpec) ProtoMessage()               {}
func (*DoSPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{52} }

func (m *DoSPolicySpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicySpec) GetIngressPolicy() *IngressDoSPolicy {
	if m != nil {
		return m.IngressPolicy
	}
	return nil
}

func (m *DoSPolicySpec) GetEgressPolicy() *EgressDoSPolicy {
	if m != nil {
		return m.EgressPolicy
	}
	return nil
}

func (m *DoSPolicySpec) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

func (m *DoSPolicySpec) GetSgHandle() []uint64 {
	if m != nil {
		return m.SgHandle
	}
	return nil
}

// DoSPolicyRequestMsg is batched add or modify DoS request
type DoSPolicyRequestMsg struct {
	Request []*DoSPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyRequestMsg) Reset()                    { *m = DoSPolicyRequestMsg{} }
func (m *DoSPolicyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyRequestMsg) ProtoMessage()               {}
func (*DoSPolicyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{53} }

func (m *DoSPolicyRequestMsg) GetRequest() []*DoSPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// DoS operational status
type DoSPolicyStatus struct {
	DosHandle uint64 `protobuf:"fixed64,1,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyStatus) Reset()                    { *m = DoSPolicyStatus{} }
func (m *DoSPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyStatus) ProtoMessage()               {}
func (*DoSPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{54} }

func (m *DoSPolicyStatus) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSResponse is the response to DoSPolicySpec
type DoSPolicyResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *DoSPolicyStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *DoSPolicyResponse) Reset()                    { *m = DoSPolicyResponse{} }
func (m *DoSPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyResponse) ProtoMessage()               {}
func (*DoSPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{55} }

func (m *DoSPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DoSPolicyResponse) GetStatus() *DoSPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// DoSPolicyResponseMsg is batched response to DoSPolicyRequestMsg
type DoSPolicyResponseMsg struct {
	Response []*DoSPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyResponseMsg) Reset()                    { *m = DoSPolicyResponseMsg{} }
func (m *DoSPolicyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyResponseMsg) ProtoMessage()               {}
func (*DoSPolicyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{56} }

func (m *DoSPolicyResponseMsg) GetResponse() []*DoSPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DoSRequest is used to delete a DoS
type DoSPolicyDeleteRequest struct {
	Meta      *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	DosHandle uint64      `protobuf:"fixed64,2,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyDeleteRequest) Reset()                    { *m = DoSPolicyDeleteRequest{} }
func (m *DoSPolicyDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteRequest) ProtoMessage()               {}
func (*DoSPolicyDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{57} }

func (m *DoSPolicyDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicyDeleteRequest) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSPolicyDeleteRequestMsg is used to delete a batch of security groups
type DoSPolicyDeleteRequestMsg struct {
	Request []*DoSPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyDeleteRequestMsg) Reset()                    { *m = DoSPolicyDeleteRequestMsg{} }
func (m *DoSPolicyDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteRequestMsg) ProtoMessage()               {}
func (*DoSPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{58} }

func (m *DoSPolicyDeleteRequestMsg) GetRequest() []*DoSPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type DoSPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
}

func (m *DoSPolicyDeleteResponse) Reset()                    { *m = DoSPolicyDeleteResponse{} }
func (m *DoSPolicyDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteResponse) ProtoMessage()               {}
func (*DoSPolicyDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{59} }

func (m *DoSPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// DoSPolicyDeleteResponseMsg is batched response to
// DoSPolicyDeleteRequestMsg
type DoSPolicyDeleteResponseMsg struct {
	Response []*DoSPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyDeleteResponseMsg) Reset()                    { *m = DoSPolicyDeleteResponseMsg{} }
func (m *DoSPolicyDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteResponseMsg) ProtoMessage()               {}
func (*DoSPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{60} }

func (m *DoSPolicyDeleteResponseMsg) GetResponse() []*DoSPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DoSGetRequest is used to get information about a DoS
type DoSPolicyGetRequest struct {
	Meta      *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	DosHandle uint64      `protobuf:"fixed64,2,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyGetRequest) Reset()                    { *m = DoSPolicyGetRequest{} }
func (m *DoSPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetRequest) ProtoMessage()               {}
func (*DoSPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{61} }

func (m *DoSPolicyGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicyGetRequest) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSPolicyGetRequestMsg is batched GET request for DoS
type DoSPolicyGetRequestMsg struct {
	Request []*DoSPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyGetRequestMsg) Reset()                    { *m = DoSPolicyGetRequestMsg{} }
func (m *DoSPolicyGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetRequestMsg) ProtoMessage()               {}
func (*DoSPolicyGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{62} }

func (m *DoSPolicyGetRequestMsg) GetRequest() []*DoSPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// DoSPolicyStats is the statistics object for a security group
type DoSPolicyStats struct {
}

func (m *DoSPolicyStats) Reset()                    { *m = DoSPolicyStats{} }
func (m *DoSPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyStats) ProtoMessage()               {}
func (*DoSPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{63} }

// DoSGetResponse captures all the information about a security group
type DoSPolicyGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Spec      *DoSPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *DoSPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *DoSPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *DoSPolicyGetResponse) Reset()                    { *m = DoSPolicyGetResponse{} }
func (m *DoSPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetResponse) ProtoMessage()               {}
func (*DoSPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{64} }

func (m *DoSPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DoSPolicyGetResponse) GetSpec() *DoSPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *DoSPolicyGetResponse) GetStatus() *DoSPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DoSPolicyGetResponse) GetStats() *DoSPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// DoSPolicyGetResponseMsg is batched response to DoSPolicyGetRequestMsg
type DoSPolicyGetResponseMsg struct {
	Response []*DoSPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyGetResponseMsg) Reset()                    { *m = DoSPolicyGetResponseMsg{} }
func (m *DoSPolicyGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetResponseMsg) ProtoMessage()               {}
func (*DoSPolicyGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{65} }

func (m *DoSPolicyGetResponseMsg) GetResponse() []*DoSPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*SecurityProfileSpec)(nil), "nwsec.SecurityProfileSpec")
	proto.RegisterType((*SecurityProfileRequestMsg)(nil), "nwsec.SecurityProfileRequestMsg")
	proto.RegisterType((*SecurityProfileStatus)(nil), "nwsec.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileResponse)(nil), "nwsec.SecurityProfileResponse")
	proto.RegisterType((*SecurityProfileResponseMsg)(nil), "nwsec.SecurityProfileResponseMsg")
	proto.RegisterType((*SecurityProfileDeleteRequest)(nil), "nwsec.SecurityProfileDeleteRequest")
	proto.RegisterType((*SecurityProfileDeleteRequestMsg)(nil), "nwsec.SecurityProfileDeleteRequestMsg")
	proto.RegisterType((*SecurityProfileDeleteResponse)(nil), "nwsec.SecurityProfileDeleteResponse")
	proto.RegisterType((*SecurityProfileDeleteResponseMsg)(nil), "nwsec.SecurityProfileDeleteResponseMsg")
	proto.RegisterType((*SecurityProfileGetRequest)(nil), "nwsec.SecurityProfileGetRequest")
	proto.RegisterType((*SecurityProfileGetRequestMsg)(nil), "nwsec.SecurityProfileGetRequestMsg")
	proto.RegisterType((*SecurityProfileStats)(nil), "nwsec.SecurityProfileStats")
	proto.RegisterType((*SecurityProfileGetResponse)(nil), "nwsec.SecurityProfileGetResponse")
	proto.RegisterType((*SecurityProfileGetResponseMsg)(nil), "nwsec.SecurityProfileGetResponseMsg")
	proto.RegisterType((*Service)(nil), "nwsec.Service")
	proto.RegisterType((*FirewallRuleSpec)(nil), "nwsec.FirewallRuleSpec")
	proto.RegisterType((*SGPolicy)(nil), "nwsec.SGPolicy")
	proto.RegisterType((*SecurityGroupPolicySpec)(nil), "nwsec.SecurityGroupPolicySpec")
	proto.RegisterType((*SecurityGroupPolicyRequestMsg)(nil), "nwsec.SecurityGroupPolicyRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyStatus)(nil), "nwsec.SecurityGroupPolicyStatus")
	proto.RegisterType((*SecurityGroupPolicyResponse)(nil), "nwsec.SecurityGroupPolicyResponse")
	proto.RegisterType((*SecurityGroupPolicyResponseMsg)(nil), "nwsec.SecurityGroupPolicyResponseMsg")
	proto.RegisterType((*SecurityGroupPolicyDeleteRequest)(nil), "nwsec.SecurityGroupPolicyDeleteRequest")
	proto.RegisterType((*SecurityGroupPolicyDeleteRequestMsg)(nil), "nwsec.SecurityGroupPolicyDeleteRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyDeleteResponse)(nil), "nwsec.SecurityGroupPolicyDeleteResponse")
	proto.RegisterType((*SecurityGroupPolicyDeleteResponseMsg)(nil), "nwsec.SecurityGroupPolicyDeleteResponseMsg")
	proto.RegisterType((*SecurityGroupPolicyGetRequest)(nil), "nwsec.SecurityGroupPolicyGetRequest")
	proto.RegisterType((*SecurityGroupPolicyGetRequestMsg)(nil), "nwsec.SecurityGroupPolicyGetRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyStats)(nil), "nwsec.SecurityGroupPolicyStats")
	proto.RegisterType((*SecurityGroupPolicyGetResponse)(nil), "nwsec.SecurityGroupPolicyGetResponse")
	proto.RegisterType((*SecurityGroupPolicyGetResponseMsg)(nil), "nwsec.SecurityGroupPolicyGetResponseMsg")
	proto.RegisterType((*SecurityGroupSpec)(nil), "nwsec.SecurityGroupSpec")
	proto.RegisterType((*SecurityGroupRequestMsg)(nil), "nwsec.SecurityGroupRequestMsg")
	proto.RegisterType((*SecurityGroupStatus)(nil), "nwsec.SecurityGroupStatus")
	proto.RegisterType((*SecurityGroupResponse)(nil), "nwsec.SecurityGroupResponse")
	proto.RegisterType((*SecurityGroupResponseMsg)(nil), "nwsec.SecurityGroupResponseMsg")
	proto.RegisterType((*SecurityGroupDeleteRequest)(nil), "nwsec.SecurityGroupDeleteRequest")
	proto.RegisterType((*SecurityGroupDeleteRequestMsg)(nil), "nwsec.SecurityGroupDeleteRequestMsg")
	proto.RegisterType((*SecurityGroupDeleteResponseMsg)(nil), "nwsec.SecurityGroupDeleteResponseMsg")
	proto.RegisterType((*SecurityGroupGetRequest)(nil), "nwsec.SecurityGroupGetRequest")
	proto.RegisterType((*SecurityGroupGetRequestMsg)(nil), "nwsec.SecurityGroupGetRequestMsg")
	proto.RegisterType((*SecurityGroupStats)(nil), "nwsec.SecurityGroupStats")
	proto.RegisterType((*SecurityGroupGetResponse)(nil), "nwsec.SecurityGroupGetResponse")
	proto.RegisterType((*SecurityGroupGetResponseMsg)(nil), "nwsec.SecurityGroupGetResponseMsg")
	proto.RegisterType((*ICMPMsg)(nil), "nwsec.ICMPMsg")
	proto.RegisterType((*DoSService)(nil), "nwsec.DoSService")
	proto.RegisterType((*DoSSessionLimits)(nil), "nwsec.DoSSessionLimits")
	proto.RegisterType((*DoSPolicer)(nil), "nwsec.DoSPolicer")
	proto.RegisterType((*DoSFloodLimits)(nil), "nwsec.DoSFloodLimits")
	proto.RegisterType((*DoSFloodLimits_RestrictLimits)(nil), "nwsec.DoSFloodLimits.RestrictLimits")
	proto.RegisterType((*DoSFloodLimits_ProtectLimits)(nil), "nwsec.DoSFloodLimits.ProtectLimits")
	proto.RegisterType((*DoSProtectionSpec)(nil), "nwsec.DoSProtectionSpec")
	proto.RegisterType((*IngressDoSPolicy)(nil), "nwsec.IngressDoSPolicy")
	proto.RegisterType((*EgressDoSPolicy)(nil), "nwsec.EgressDoSPolicy")
	proto.RegisterType((*DoSPolicySpec)(nil), "nwsec.DoSPolicySpec")
	proto.RegisterType((*DoSPolicyRequestMsg)(nil), "nwsec.DoSPolicyRequestMsg")
	proto.RegisterType((*DoSPolicyStatus)(nil), "nwsec.DoSPolicyStatus")
	proto.RegisterType((*DoSPolicyResponse)(nil), "nwsec.DoSPolicyResponse")
	proto.RegisterType((*DoSPolicyResponseMsg)(nil), "nwsec.DoSPolicyResponseMsg")
	proto.RegisterType((*DoSPolicyDeleteRequest)(nil), "nwsec.DoSPolicyDeleteRequest")
	proto.RegisterType((*DoSPolicyDeleteRequestMsg)(nil), "nwsec.DoSPolicyDeleteRequestMsg")
	proto.RegisterType((*DoSPolicyDeleteResponse)(nil), "nwsec.DoSPolicyDeleteResponse")
	proto.RegisterType((*DoSPolicyDeleteResponseMsg)(nil), "nwsec.DoSPolicyDeleteResponseMsg")
	proto.RegisterType((*DoSPolicyGetRequest)(nil), "nwsec.DoSPolicyGetRequest")
	proto.RegisterType((*DoSPolicyGetRequestMsg)(nil), "nwsec.DoSPolicyGetRequestMsg")
	proto.RegisterType((*DoSPolicyStats)(nil), "nwsec.DoSPolicyStats")
	proto.RegisterType((*DoSPolicyGetResponse)(nil), "nwsec.DoSPolicyGetResponse")
	proto.RegisterType((*DoSPolicyGetResponseMsg)(nil), "nwsec.DoSPolicyGetResponseMsg")
	proto.RegisterEnum("nwsec.NormalizationAction", NormalizationAction_name, NormalizationAction_value)
	proto.RegisterEnum("nwsec.FirewallAction", FirewallAction_name, FirewallAction_value)
	proto.RegisterEnum("nwsec.ALGName", ALGName_name, ALGName_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NwSecurity service

type NwSecurityClient interface {
	SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error)
	SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error)
	SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityProfileDeleteResponseMsg, error)
	SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequestMsg, opts ...grpc.CallOption) (*SecurityProfileGetResponseMsg, error)
	SecurityGroupPolicyCreate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyUpdate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyDelete(ctx context.Context, in *SecurityGroupPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyDeleteResponseMsg, error)
	SecurityGroupPolicyGet(ctx context.Context, in *SecurityGroupPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyGetResponseMsg, error)
	SecurityGroupCreate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error)
	SecurityGroupUpdate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error)
	SecurityGroupDelete(ctx context.Context, in *SecurityGroupDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupDeleteResponseMsg, error)
	SecurityGroupGet(ctx context.Context, in *SecurityGroupGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupGetResponseMsg, error)
	DoSPolicyCreate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error)
	DoSPolicyUpdate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error)
	DoSPolicyDelete(ctx context.Context, in *DoSPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*DoSPolicyDeleteResponseMsg, error)
	DoSPolicyGet(ctx context.Context, in *DoSPolicyGetRequestMsg, opts ...grpc.CallOption) (*DoSPolicyGetResponseMsg, error)
}

type nwSecurityClient struct {
	cc *grpc.ClientConn
}

func NewNwSecurityClient(cc *grpc.ClientConn) NwSecurityClient {
	return &nwSecurityClient{cc}
}

func (c *nwSecurityClient) SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error) {
	out := new(SecurityProfileResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error) {
	out := new(SecurityProfileResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityProfileDeleteResponseMsg, error) {
	out := new(SecurityProfileDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequestMsg, opts ...grpc.CallOption) (*SecurityProfileGetResponseMsg, error) {
	out := new(SecurityProfileGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyCreate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error) {
	out := new(SecurityGroupPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyUpdate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error) {
	out := new(SecurityGroupPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyDelete(ctx context.Context, in *SecurityGroupPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyDeleteResponseMsg, error) {
	out := new(SecurityGroupPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyGet(ctx context.Context, in *SecurityGroupPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyGetResponseMsg, error) {
	out := new(SecurityGroupPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupCreate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error) {
	out := new(SecurityGroupResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupUpdate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error) {
	out := new(SecurityGroupResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupDelete(ctx context.Context, in *SecurityGroupDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupDeleteResponseMsg, error) {
	out := new(SecurityGroupDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupGet(ctx context.Context, in *SecurityGroupGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupGetResponseMsg, error) {
	out := new(SecurityGroupGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) DoSPolicyCreate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error) {
	out := new(DoSPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/DoSPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) DoSPolicyUpdate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error) {
	out := new(DoSPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/DoSPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) DoSPolicyDelete(ctx context.Context, in *DoSPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*DoSPolicyDeleteResponseMsg, error) {
	out := new(DoSPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/DoSPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) DoSPolicyGet(ctx context.Context, in *DoSPolicyGetRequestMsg, opts ...grpc.CallOption) (*DoSPolicyGetResponseMsg, error) {
	out := new(DoSPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/DoSPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NwSecurity service

type NwSecurityServer interface {
	SecurityProfileCreate(context.Context, *SecurityProfileRequestMsg) (*SecurityProfileResponseMsg, error)
	SecurityProfileUpdate(context.Context, *SecurityProfileRequestMsg) (*SecurityProfileResponseMsg, error)
	SecurityProfileDelete(context.Context, *SecurityProfileDeleteRequestMsg) (*SecurityProfileDeleteResponseMsg, error)
	SecurityProfileGet(context.Context, *SecurityProfileGetRequestMsg) (*SecurityProfileGetResponseMsg, error)
	SecurityGroupPolicyCreate(context.Context, *SecurityGroupPolicyRequestMsg) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyUpdate(context.Context, *SecurityGroupPolicyRequestMsg) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyDelete(context.Context, *SecurityGroupPolicyDeleteRequestMsg) (*SecurityGroupPolicyDeleteResponseMsg, error)
	SecurityGroupPolicyGet(context.Context, *SecurityGroupPolicyGetRequestMsg) (*SecurityGroupPolicyGetResponseMsg, error)
	SecurityGroupCreate(context.Context, *SecurityGroupRequestMsg) (*SecurityGroupResponseMsg, error)
	SecurityGroupUpdate(context.Context, *SecurityGroupRequestMsg) (*SecurityGroupResponseMsg, error)
	SecurityGroupDelete(context.Context, *SecurityGroupDeleteRequestMsg) (*SecurityGroupDeleteResponseMsg, error)
	SecurityGroupGet(context.Context, *SecurityGroupGetRequestMsg) (*SecurityGroupGetResponseMsg, error)
	DoSPolicyCreate(context.Context, *DoSPolicyRequestMsg) (*DoSPolicyResponseMsg, error)
	DoSPolicyUpdate(context.Context, *DoSPolicyRequestMsg) (*DoSPolicyResponseMsg, error)
	DoSPolicyDelete(context.Context, *DoSPolicyDeleteRequestMsg) (*DoSPolicyDeleteResponseMsg, error)
	DoSPolicyGet(context.Context, *DoSPolicyGetRequestMsg) (*DoSPolicyGetResponseMsg, error)
}

func RegisterNwSecurityServer(s *grpc.Server, srv NwSecurityServer) {
	s.RegisterService(&_NwSecurity_serviceDesc, srv)
}

func _NwSecurity_SecurityProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileCreate(ctx, req.(*SecurityProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileUpdate(ctx, req.(*SecurityProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileDelete(ctx, req.(*SecurityProfileDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileGet(ctx, req.(*SecurityProfileGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyCreate(ctx, req.(*SecurityGroupPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyUpdate(ctx, req.(*SecurityGroupPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyDelete(ctx, req.(*SecurityGroupPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyGet(ctx, req.(*SecurityGroupPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupCreate(ctx, req.(*SecurityGroupRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupUpdate(ctx, req.(*SecurityGroupRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupDelete(ctx, req.(*SecurityGroupDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupGet(ctx, req.(*SecurityGroupGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_DoSPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).DoSPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/DoSPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).DoSPolicyCreate(ctx, req.(*DoSPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_DoSPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).DoSPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/DoSPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).DoSPolicyUpdate(ctx, req.(*DoSPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_DoSPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).DoSPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/DoSPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).DoSPolicyDelete(ctx, req.(*DoSPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_DoSPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).DoSPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/DoSPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).DoSPolicyGet(ctx, req.(*DoSPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _NwSecurity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nwsec.NwSecurity",
	HandlerType: (*NwSecurityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityProfileCreate",
			Handler:    _NwSecurity_SecurityProfileCreate_Handler,
		},
		{
			MethodName: "SecurityProfileUpdate",
			Handler:    _NwSecurity_SecurityProfileUpdate_Handler,
		},
		{
			MethodName: "SecurityProfileDelete",
			Handler:    _NwSecurity_SecurityProfileDelete_Handler,
		},
		{
			MethodName: "SecurityProfileGet",
			Handler:    _NwSecurity_SecurityProfileGet_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyCreate",
			Handler:    _NwSecurity_SecurityGroupPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyUpdate",
			Handler:    _NwSecurity_SecurityGroupPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyDelete",
			Handler:    _NwSecurity_SecurityGroupPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyGet",
			Handler:    _NwSecurity_SecurityGroupPolicyGet_Handler,
		},
		{
			MethodName: "SecurityGroupCreate",
			Handler:    _NwSecurity_SecurityGroupCreate_Handler,
		},
		{
			MethodName: "SecurityGroupUpdate",
			Handler:    _NwSecurity_SecurityGroupUpdate_Handler,
		},
		{
			MethodName: "SecurityGroupDelete",
			Handler:    _NwSecurity_SecurityGroupDelete_Handler,
		},
		{
			MethodName: "SecurityGroupGet",
			Handler:    _NwSecurity_SecurityGroupGet_Handler,
		},
		{
			MethodName: "DoSPolicyCreate",
			Handler:    _NwSecurity_DoSPolicyCreate_Handler,
		},
		{
			MethodName: "DoSPolicyUpdate",
			Handler:    _NwSecurity_DoSPolicyUpdate_Handler,
		},
		{
			MethodName: "DoSPolicyDelete",
			Handler:    _NwSecurity_DoSPolicyDelete_Handler,
		},
		{
			MethodName: "DoSPolicyGet",
			Handler:    _NwSecurity_DoSPolicyGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nwsec.proto",
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n2, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CnxnTrackingEn {
		dAtA[i] = 0x18
		i++
		if m.CnxnTrackingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpsgEn {
		dAtA[i] = 0x20
		i++
		if m.IpsgEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpRttEstimateEn {
		dAtA[i] = 0x28
		i++
		if m.TcpRttEstimateEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SessionIdleTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SessionIdleTimeout))
	}
	if m.TcpCnxnSetupTimeout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpCnxnSetupTimeout))
	}
	if m.TcpCloseTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpCloseTimeout))
	}
	if m.TcpCloseWaitTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpCloseWaitTimeout))
	}
	if m.TcpNonSynFirstPktDrop {
		dAtA[i] = 0x50
		i++
		if m.TcpNonSynFirstPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpNormalizationEn {
		dAtA[i] = 0x58
		i++
		if m.IpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNormalizationEn {
		dAtA[i] = 0x60
		i++
		if m.TcpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpNormalizationEn {
		dAtA[i] = 0x68
		i++
		if m.IcmpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpTtlChangeDetectEn {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IpTtlChangeDetectEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpRsvdFlagsAction != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpRsvdFlagsAction))
	}
	if m.IpDfAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpDfAction))
	}
	if m.IpOptionsAction != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpOptionsAction))
	}
	if m.IpInvalidLenAction != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpInvalidLenAction))
	}
	if m.IpNormalizeTtl != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpNormalizeTtl))
	}
	if m.IcmpInvalidCodeAction != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpInvalidCodeAction))
	}
	if m.IcmpDeprecatedMsgsDrop {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.IcmpDeprecatedMsgsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpRedirectMsgDrop {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.IcmpRedirectMsgDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpSplitHandshakeDrop {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		if m.TcpSplitHandshakeDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpRsvdFlagsAction != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpRsvdFlagsAction))
	}
	if m.TcpUnexpectedMssAction != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedMssAction))
	}
	if m.TcpUnexpectedWinScaleAction != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedWinScaleAction))
	}
	if m.TcpUnexpectedSackPermAction != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedSackPermAction))
	}
	if m.TcpUrgPtrNotSetAction != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgPtrNotSetAction))
	}
	if m.TcpUrgFlagNotSetAction != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgFlagNotSetAction))
	}
	if m.TcpUrgPayloadMissingAction != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgPayloadMissingAction))
	}
	if m.TcpRstWithDataAction != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpRstWithDataAction))
	}
	if m.TcpDataLenGtMssAction != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpDataLenGtMssAction))
	}
	if m.TcpDataLenGtWinSizeAction != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpDataLenGtWinSizeAction))
	}
	if m.TcpUnexpectedTsOptionAction != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedTsOptionAction))
	}
	if m.TcpUnexpectedEchoTsAction != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedEchoTsAction))
	}
	if m.TcpUnexpectedSackOptionAction != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedSackOptionAction))
	}
	if m.TcpTsNotPresentDrop {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		if m.TcpTsNotPresentDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpInvalidFlagsDrop {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		if m.TcpInvalidFlagsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNonsynNoackDrop {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		if m.TcpNonsynNoackDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SecurityProfileRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.ProfileHandle))
	}
	return i, nil
}

func (m *SecurityProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ProfileStatus.Size()))
		n3, err := m.ProfileStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SecurityProfileResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n5, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ProfileStatus.Size()))
		n6, err := m.ProfileStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n8, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SecurityProfileGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfileGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n9, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n11, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SecurityProfileGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpProtocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		nn12, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	if m.Alg != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Alg))
	}
	return i, nil
}

func (m *Service_DstPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintNwsec(dAtA, i, uint64(m.DstPort))
	return i, nil
}
func (m *Service_IcmpMsgType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpMsgType))
	return i, nil
}
func (m *FirewallRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svc) > 0 {
		for _, msg := range m.Svc {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Action != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Action))
	}
	if m.Log {
		dAtA[i] = 0x20
		i++
		if m.Log {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SGPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InFwRules) > 0 {
		for _, msg := range m.InFwRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgFwRules) > 0 {
		for _, msg := range m.EgFwRules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n13, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n14, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.PolicyRules != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PolicyRules.Size()))
		n15, err := m.PolicyRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *SecurityGroupPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.PolicyHandle))
	}
	return i, nil
}

func (m *SecurityGroupPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n16, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SecurityGroupPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n17, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n18, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n19, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n20, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityGroupPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n21, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n22, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n23, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n24, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n25, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SecurityGroupRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SgHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.SgHandle))
	}
	return i, nil
}

func (m *SecurityGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n26, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *SecurityGroupResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n27, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *SecurityGroupDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA30 := make([]byte, len(m.ApiStatus)*10)
		var j29 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	return i, nil
}

func (m *SecurityGroupGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n31, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n32, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *SecurityGroupGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityGroupGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n33, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n34, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n35, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *SecurityGroupGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *ICMPMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *DoSService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpProtocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		nn36, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn36
	}
	return i, nil
}

func (m *DoSService_DstPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintNwsec(dAtA, i, uint64(m.DstPort))
	return i, nil
}
func (m *DoSService_IcmpMsg) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpMsg != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpMsg.Size()))
		n37, err := m.IcmpMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *DoSSessionLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSSessionLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.MaxSessions))
	}
	if m.BlockingTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.BlockingTimeout))
	}
	return i, nil
}

func (m *DoSPolicer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BytesPerSecond != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.BytesPerSecond))
	}
	if m.PeakRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PeakRate))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.BurstSize))
	}
	return i, nil
}

func (m *DoSFloodLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RestrictLimits != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.RestrictLimits.Size()))
		n38, err := m.RestrictLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.ProtectLimits != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ProtectLimits.Size()))
		n39, err := m.ProtectLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *DoSFloodLimits_RestrictLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits_RestrictLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *DoSFloodLimits_ProtectLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits_ProtectLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *DoSProtectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSProtectionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Svc.Size()))
		n40, err := m.Svc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.SessionSetupRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SessionSetupRate))
	}
	if m.SessionLimits != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SessionLimits.Size()))
		n41, err := m.SessionLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Policer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Policer.Size()))
		n42, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.TcpSynFloodLimits != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpSynFloodLimits.Size()))
		n43, err := m.TcpSynFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.UdpFloodLimits != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.UdpFloodLimits.Size()))
		n44, err := m.UdpFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.IcmpFloodLimits != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpFloodLimits.Size()))
		n45, err := m.IcmpFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.OtherFloodLimits != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.OtherFloodLimits.Size()))
		n46, err := m.OtherFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.PeerSgHandle != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PeerSgHandle))
	}
	return i, nil
}

func (m *IngressDoSPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressDoSPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosProtection != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DosProtection.Size()))
		n47, err := m.DosProtection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *EgressDoSPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressDoSPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosProtection != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DosProtection.Size()))
		n48, err := m.DosProtection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *DoSPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n49, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.IngressPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IngressPolicy.Size()))
		n50, err := m.IngressPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.EgressPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.EgressPolicy.Size()))
		n51, err := m.EgressPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.DosHandle))
	}
	if len(m.SgHandle) > 0 {
		dAtA53 := make([]byte, len(m.SgHandle)*10)
		var j52 int
		for _, num := range m.SgHandle {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	return i, nil
}

func (m *DoSPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.DosHandle))
	}
	return i, nil
}

func (m *DoSPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n54, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}

func (m *DoSPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n55, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.DosHandle))
	}
	return i, nil
}

func (m *DoSPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *DoSPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n56, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Nwsec(dAtA, i, uint64(m.DosHandle))
	}
	return i, nil
}

func (m *DoSPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DoSPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n57, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n58, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n59, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *DoSPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Nwsec(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Nwsec(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNwsec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.CnxnTrackingEn {
		n += 2
	}
	if m.IpsgEn {
		n += 2
	}
	if m.TcpRttEstimateEn {
		n += 2
	}
	if m.SessionIdleTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.SessionIdleTimeout))
	}
	if m.TcpCnxnSetupTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpCnxnSetupTimeout))
	}
	if m.TcpCloseTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpCloseTimeout))
	}
	if m.TcpCloseWaitTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpCloseWaitTimeout))
	}
	if m.TcpNonSynFirstPktDrop {
		n += 2
	}
	if m.IpNormalizationEn {
		n += 2
	}
	if m.TcpNormalizationEn {
		n += 2
	}
	if m.IcmpNormalizationEn {
		n += 2
	}
	if m.IpTtlChangeDetectEn {
		n += 3
	}
	if m.IpRsvdFlagsAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpRsvdFlagsAction))
	}
	if m.IpDfAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpDfAction))
	}
	if m.IpOptionsAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpOptionsAction))
	}
	if m.IpInvalidLenAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpInvalidLenAction))
	}
	if m.IpNormalizeTtl != 0 {
		n += 2 + sovNwsec(uint64(m.IpNormalizeTtl))
	}
	if m.IcmpInvalidCodeAction != 0 {
		n += 2 + sovNwsec(uint64(m.IcmpInvalidCodeAction))
	}
	if m.IcmpDeprecatedMsgsDrop {
		n += 3
	}
	if m.IcmpRedirectMsgDrop {
		n += 3
	}
	if m.TcpSplitHandshakeDrop {
		n += 3
	}
	if m.TcpRsvdFlagsAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpRsvdFlagsAction))
	}
	if m.TcpUnexpectedMssAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedMssAction))
	}
	if m.TcpUnexpectedWinScaleAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedWinScaleAction))
	}
	if m.TcpUnexpectedSackPermAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedSackPermAction))
	}
	if m.TcpUrgPtrNotSetAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgPtrNotSetAction))
	}
	if m.TcpUrgFlagNotSetAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgFlagNotSetAction))
	}
	if m.TcpUrgPayloadMissingAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgPayloadMissingAction))
	}
	if m.TcpRstWithDataAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpRstWithDataAction))
	}
	if m.TcpDataLenGtMssAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpDataLenGtMssAction))
	}
	if m.TcpDataLenGtWinSizeAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpDataLenGtWinSizeAction))
	}
	if m.TcpUnexpectedTsOptionAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedTsOptionAction))
	}
	if m.TcpUnexpectedEchoTsAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedEchoTsAction))
	}
	if m.TcpUnexpectedSackOptionAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedSackOptionAction))
	}
	if m.TcpTsNotPresentDrop {
		n += 3
	}
	if m.TcpInvalidFlagsDrop {
		n += 3
	}
	if m.TcpNonsynNoackDrop {
		n += 3
	}
	return n
}

func (m *SecurityProfileRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		n += 9
	}
	return n
}

func (m *SecurityProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		l = m.ProfileStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		l = m.ProfileStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfileGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.IpProtocol != 0 {
		n += 1 + sovNwsec(uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	if m.Alg != 0 {
		n += 1 + sovNwsec(uint64(m.Alg))
	}
	return n
}

func (m *Service_DstPort) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec(uint64(m.DstPort))
	return n
}
func (m *Service_IcmpMsgType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec(uint64(m.IcmpMsgType))
	return n
}
func (m *FirewallRuleSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Svc) > 0 {
		for _, e := range m.Svc {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.Action != 0 {
		n += 1 + sovNwsec(uint64(m.Action))
	}
	if m.Log {
		n += 2
	}
	return n
}

func (m *SGPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.InFwRules) > 0 {
		for _, e := range m.InFwRules {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if len(m.EgFwRules) > 0 {
		for _, e := range m.EgFwRules {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.PolicyRules != nil {
		l = m.PolicyRules.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.PolicyHandle != 0 {
		n += 9
	}
	return n
}

func (m *SecurityGroupPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityGroupPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityGroupSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupStatus) Size() (n int) {
	var l int
	_ = l
	if m.SgHandle != 0 {
		n += 9
	}
	return n
}

func (m *SecurityGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNwsec(uint64(e))
		}
		n += 1 + sovNwsec(uint64(l)) + l
	}
	return n
}

func (m *SecurityGroupGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityGroupGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *ICMPMsg) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNwsec(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovNwsec(uint64(m.Code))
	}
	return n
}

func (m *DoSService) Size() (n int) {
	var l int
	_ = l
	if m.IpProtocol != 0 {
		n += 1 + sovNwsec(uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	return n
}

func (m *DoSService_DstPort) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec(uint64(m.DstPort))
	return n
}
func (m *DoSService_IcmpMsg) Size() (n int) {
	var l int
	_ = l
	if m.IcmpMsg != nil {
		l = m.IcmpMsg.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *DoSSessionLimits) Size() (n int) {
	var l int
	_ = l
	if m.MaxSessions != 0 {
		n += 1 + sovNwsec(uint64(m.MaxSessions))
	}
	if m.BlockingTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.BlockingTimeout))
	}
	return n
}

func (m *DoSPolicer) Size() (n int) {
	var l int
	_ = l
	if m.BytesPerSecond != 0 {
		n += 1 + sovNwsec(uint64(m.BytesPerSecond))
	}
	if m.PeakRate != 0 {
		n += 1 + sovNwsec(uint64(m.PeakRate))
	}
	if m.BurstSize != 0 {
		n += 1 + sovNwsec(uint64(m.BurstSize))
	}
	return n
}

func (m *DoSFloodLimits) Size() (n int) {
	var l int
	_ = l
	if m.RestrictLimits != nil {
		l = m.RestrictLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.ProtectLimits != nil {
		l = m.ProtectLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *DoSFloodLimits_RestrictLimits) Size() (n int) {
	var l int
	_ = l
	if m.Pps != 0 {
		n += 1 + sovNwsec(uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		n += 1 + sovNwsec(uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		n += 1 + sovNwsec(uint64(m.Duration))
	}
	return n
}

func (m *DoSFloodLimits_ProtectLimits) Size() (n int) {
	var l int
	_ = l
	if m.Pps != 0 {
		n += 1 + sovNwsec(uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		n += 1 + sovNwsec(uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		n += 1 + sovNwsec(uint64(m.Duration))
	}
	return n
}

func (m *DoSProtectionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Svc != nil {
		l = m.Svc.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.SessionSetupRate != 0 {
		n += 1 + sovNwsec(uint64(m.SessionSetupRate))
	}
	if m.SessionLimits != nil {
		l = m.SessionLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.TcpSynFloodLimits != nil {
		l = m.TcpSynFloodLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.UdpFloodLimits != nil {
		l = m.UdpFloodLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.IcmpFloodLimits != nil {
		l = m.IcmpFloodLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.OtherFloodLimits != nil {
		l = m.OtherFloodLimits.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.PeerSgHandle != 0 {
		n += 1 + sovNwsec(uint64(m.PeerSgHandle))
	}
	return n
}

func (m *IngressDoSPolicy) Size() (n int) {
	var l int
	_ = l
	if m.DosProtection != nil {
		l = m.DosProtection.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *EgressDoSPolicy) Size() (n int) {
	var l int
	_ = l
	if m.DosProtection != nil {
		l = m.DosProtection.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *DoSPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.IngressPolicy != nil {
		l = m.IngressPolicy.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.EgressPolicy != nil {
		l = m.EgressPolicy.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	if len(m.SgHandle) > 0 {
		l = 0
		for _, e := range m.SgHandle {
			l += sovNwsec(uint64(e))
		}
		n += 1 + sovNwsec(uint64(l)) + l
	}
	return n
}

func (m *DoSPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *DoSPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *DoSPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DoSPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *DoSPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func sovNwsec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNwsec(x uint64) (n int) {
	return sovNwsec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnxnTrackingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CnxnTrackingEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsgEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpsgEn = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRttEstimateEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpRttEstimateEn = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdleTimeout", wireType)
			}
			m.SessionIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCnxnSetupTimeout", wireType)
			}
			m.TcpCnxnSetupTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCnxnSetupTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCloseTimeout", wireType)
			}
			m.TcpCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCloseWaitTimeout", wireType)
			}
			m.TcpCloseWaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCloseWaitTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNonSynFirstPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNonSynFirstPktDrop = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpNormalizationEn = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNormalizationEn = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpNormalizationEn = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtlChangeDetectEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpTtlChangeDetectEn = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRsvdFlagsAction", wireType)
			}
			m.IpRsvdFlagsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpRsvdFlagsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDfAction", wireType)
			}
			m.IpDfAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDfAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOptionsAction", wireType)
			}
			m.IpOptionsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOptionsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInvalidLenAction", wireType)
			}
			m.IpInvalidLenAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInvalidLenAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpNormalizeTtl", wireType)
			}
			m.IpNormalizeTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpNormalizeTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInvalidCodeAction", wireType)
			}
			m.IcmpInvalidCodeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInvalidCodeAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpDeprecatedMsgsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpDeprecatedMsgsDrop = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpRedirectMsgDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpRedirectMsgDrop = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSplitHandshakeDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpSplitHandshakeDrop = bool(v != 0)
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRsvdFlagsAction", wireType)
			}
			m.TcpRsvdFlagsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRsvdFlagsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedMssAction", wireType)
			}
			m.TcpUnexpectedMssAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedMssAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedWinScaleAction", wireType)
			}
			m.TcpUnexpectedWinScaleAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedWinScaleAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedSackPermAction", wireType)
			}
			m.TcpUnexpectedSackPermAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedSackPermAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgPtrNotSetAction", wireType)
			}
			m.TcpUrgPtrNotSetAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgPtrNotSetAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgFlagNotSetAction", wireType)
			}
			m.TcpUrgFlagNotSetAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgFlagNotSetAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgPayloadMissingAction", wireType)
			}
			m.TcpUrgPayloadMissingAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgPayloadMissingAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstWithDataAction", wireType)
			}
			m.TcpRstWithDataAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRstWithDataAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDataLenGtMssAction", wireType)
			}
			m.TcpDataLenGtMssAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDataLenGtMssAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDataLenGtWinSizeAction", wireType)
			}
			m.TcpDataLenGtWinSizeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDataLenGtWinSizeAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedTsOptionAction", wireType)
			}
			m.TcpUnexpectedTsOptionAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedTsOptionAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedEchoTsAction", wireType)
			}
			m.TcpUnexpectedEchoTsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedEchoTsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedSackOptionAction", wireType)
			}
			m.TcpUnexpectedSackOptionAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedSackOptionAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTsNotPresentDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpTsNotPresentDrop = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpInvalidFlagsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpInvalidFlagsDrop = bool(v != 0)
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNonsynNoackDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNonsynNoackDrop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileHandle", wireType)
			}
			m.ProfileHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ProfileHandle = uint64(dAtA[iNdEx-8])
			m.ProfileHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.ProfileHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.ProfileHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.ProfileHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.ProfileHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.ProfileHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.ProfileHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfileStatus == nil {
				m.ProfileStatus = &SecurityProfileStatus{}
			}
			if err := m.ProfileStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfileStatus == nil {
				m.ProfileStatus = &SecurityProfileStatus{}
			}
			if err := m.ProfileStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityProfileSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityProfileStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &Service_DstPort{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpMsgType", wireType)
			}
			var v ICMPMsgType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ICMPMsgType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &Service_IcmpMsgType{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svc = append(m.Svc, &Service{})
			if err := m.Svc[len(m.Svc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (FirewallAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Log = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFwRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFwRules = append(m.InFwRules, &FirewallRuleSpec{})
			if err := m.InFwRules[len(m.InFwRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgFwRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgFwRules = append(m.EgFwRules, &FirewallRuleSpec{})
			if err := m.EgFwRules[len(m.EgFwRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyRules == nil {
				m.PolicyRules = &SGPolicy{}
			}
			if err := m.PolicyRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyHandle", wireType)
			}
			m.PolicyHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.PolicyHandle = uint64(dAtA[iNdEx-8])
			m.PolicyHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.PolicyHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.PolicyHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.PolicyHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.PolicyHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.PolicyHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.PolicyHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityGroupPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityGroupPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SgHandle", wireType)
			}
			m.SgHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SgHandle = uint64(dAtA[iNdEx-8])
			m.SgHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.SgHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.SgHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.SgHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.SgHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.SgHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.SgHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNwsec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNwsec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityGroupSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityGroupStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ICMPMsgType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &DoSService_DstPort{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &DoSService_IcmpMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSSessionLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSSessionLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSSessionLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockingTimeout", wireType)
			}
			m.BlockingTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockingTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerSecond", wireType)
			}
			m.BytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPerSecond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakRate", wireType)
			}
			m.PeakRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSFloodLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSFloodLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestrictLimits == nil {
				m.RestrictLimits = &DoSFloodLimits_RestrictLimits{}
			}
			if err := m.RestrictLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtectLimits == nil {
				m.ProtectLimits = &DoSFloodLimits_ProtectLimits{}
			}
			if err := m.ProtectLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits_RestrictLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestrictLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestrictLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pps", wireType)
			}
			m.Pps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPps", wireType)
			}
			m.BurstPps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits_ProtectLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pps", wireType)
			}
			m.Pps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPps", wireType)
			}
			m.BurstPps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSProtectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSProtectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSProtectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Svc == nil {
				m.Svc = &DoSService{}
			}
			if err := m.Svc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionSetupRate", wireType)
			}
			m.SessionSetupRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionSetupRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionLimits == nil {
				m.SessionLimits = &DoSSessionLimits{}
			}
			if err := m.SessionLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &DoSPolicer{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpSynFloodLimits == nil {
				m.TcpSynFloodLimits = &DoSFloodLimits{}
			}
			if err := m.TcpSynFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UdpFloodLimits == nil {
				m.UdpFloodLimits = &DoSFloodLimits{}
			}
			if err := m.UdpFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IcmpFloodLimits == nil {
				m.IcmpFloodLimits = &DoSFloodLimits{}
			}
			if err := m.IcmpFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherFloodLimits == nil {
				m.OtherFloodLimits = &DoSFloodLimits{}
			}
			if err := m.OtherFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerSgHandle", wireType)
			}
			m.PeerSgHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerSgHandle |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressDoSPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressDoSPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressDoSPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DosProtection == nil {
				m.DosProtection = &DoSProtectionSpec{}
			}
			if err := m.DosProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressDoSPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressDoSPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressDoSPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DosProtection == nil {
				m.DosProtection = &DoSProtectionSpec{}
			}
			if err := m.DosProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressPolicy == nil {
				m.IngressPolicy = &IngressDoSPolicy{}
			}
			if err := m.IngressPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgressPolicy == nil {
				m.EgressPolicy = &EgressDoSPolicy{}
			}
			if err := m.EgressPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.DosHandle = uint64(dAtA[iNdEx-8])
			m.DosHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.DosHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.DosHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.DosHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.DosHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.DosHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.DosHandle |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SgHandle = append(m.SgHandle, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNwsec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNwsec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SgHandle = append(m.SgHandle, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SgHandle", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.DosHandle = uint64(dAtA[iNdEx-8])
			m.DosHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.DosHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.DosHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.DosHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.DosHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.DosHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.DosHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DoSPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.DosHandle = uint64(dAtA[iNdEx-8])
			m.DosHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.DosHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.DosHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.DosHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.DosHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.DosHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.DosHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.DosHandle = uint64(dAtA[iNdEx-8])
			m.DosHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.DosHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.DosHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.DosHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.DosHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.DosHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.DosHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DoSPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DoSPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DoSPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNwsec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNwsec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNwsec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNwsec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNwsec   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nwsec.proto", fileDescriptorNwsec) }

var fileDescriptorNwsec = []byte{
	// 3330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xdd, 0x73, 0xdb, 0xc6,
	0xb5, 0x37, 0x24, 0x59, 0x1f, 0x47, 0x22, 0x45, 0xad, 0xf5, 0x41, 0x51, 0xb1, 0x24, 0xd3, 0x76,
	0xa2, 0xd8, 0xb1, 0xe2, 0xd0, 0xf6, 0xb5, 0x93, 0xdc, 0xeb, 0x44, 0xd6, 0x87, 0xad, 0x44, 0xa4,
	0x78, 0x41, 0x3a, 0x76, 0x9c, 0x8c, 0x61, 0x18, 0x58, 0x53, 0x88, 0x48, 0x00, 0x17, 0xbb, 0xb4,
	0xcc, 0xdc, 0xfb, 0x76, 0x3b, 0x9d, 0x69, 0x93, 0xd7, 0xb6, 0xee, 0x53, 0x9f, 0xfa, 0x87, 0x74,
	0xfa, 0xd2, 0xc7, 0xfe, 0x05, 0x9e, 0x4e, 0xda, 0xa7, 0x3c, 0xb4, 0x33, 0x99, 0x69, 0x9f, 0x3b,
	0xfb, 0x01, 0x10, 0x00, 0x41, 0x52, 0x4a, 0xd8, 0x69, 0x9e, 0x24, 0xec, 0x9e, 0xf3, 0x3b, 0xbb,
	0xe7, 0xfc, 0xf6, 0xec, 0xd9, 0x5d, 0xc2, 0xa4, 0x7d, 0x44, 0xb0, 0xb1, 0xee, 0x7a, 0x0e, 0x75,
	0xd0, 0x69, 0xfe, 0x91, 0x9b, 0xa4, 0x2d, 0x17, 0x13, 0xd1, 0x96, 0x1b, 0x3f, 0x3c, 0x10, 0xff,
	0xe5, 0xff, 0x3e, 0x0b, 0x67, 0x2a, 0xd8, 0x68, 0x7a, 0x16, 0x6d, 0x95, 0x3d, 0xe7, 0x99, 0x55,
	0xc7, 0x15, 0x17, 0x1b, 0xe8, 0x22, 0x8c, 0x34, 0x30, 0xd5, 0xb3, 0xca, 0xaa, 0xb2, 0x36, 0x59,
	0x98, 0x59, 0x17, 0xda, 0xfb, 0x4f, 0xbf, 0xc0, 0x06, 0x2d, 0x62, 0xaa, 0xab, 0xbc, 0x1b, 0xa9,
	0x90, 0x3a, 0xc4, 0x2d, 0xcd, 0xf1, 0xb4, 0x03, 0xdd, 0x36, 0xeb, 0x38, 0x3b, 0xc4, 0xe5, 0x5f,
	0x5b, 0x3f, 0x3c, 0x58, 0x8f, 0xc1, 0x7e, 0x8c, 0x5b, 0xf7, 0xb8, 0xcc, 0x9d, 0xcc, 0x77, 0xaf,
	0x56, 0xa6, 0x9e, 0x63, 0xdb, 0x32, 0xf0, 0x7b, 0xf9, 0x43, 0xdc, 0xca, 0xab, 0x93, 0x87, 0xb8,
	0xb5, 0xef, 0x89, 0x6e, 0xb4, 0x06, 0x19, 0xc3, 0x7e, 0x61, 0x6b, 0xd4, 0xd3, 0x8d, 0x43, 0xcb,
	0xae, 0x69, 0xd8, 0xce, 0x0e, 0xaf, 0x2a, 0x6b, 0xe3, 0x6a, 0x9a, 0xb5, 0x57, 0x65, 0xf3, 0xb6,
	0x8d, 0x16, 0x60, 0xcc, 0x72, 0x09, 0x17, 0x18, 0xe1, 0x02, 0xa3, 0xec, 0x73, 0xdb, 0x46, 0x57,
	0xe0, 0x0c, 0x35, 0x5c, 0xcd, 0xa3, 0x54, 0xc3, 0x84, 0x5a, 0x0d, 0x9d, 0x62, 0x26, 0x74, 0x9a,
	0x0b, 0x65, 0xa8, 0xe1, 0xaa, 0x94, 0x6e, 0xcb, 0x8e, 0x6d, 0x1b, 0x5d, 0x85, 0x59, 0x82, 0x09,
	0xb1, 0x1c, 0x5b, 0xb3, 0xcc, 0x3a, 0xd6, 0xa8, 0xd5, 0xc0, 0x4e, 0x93, 0x66, 0x47, 0x57, 0x95,
	0xb5, 0x94, 0x8a, 0x64, 0xdf, 0xae, 0x59, 0xc7, 0x55, 0xd1, 0x83, 0xae, 0xc1, 0x3c, 0x33, 0xc0,
	0xc7, 0x49, 0x30, 0x6d, 0xba, 0x81, 0xce, 0x18, 0xd7, 0x61, 0xe6, 0x37, 0xed, 0x17, 0x76, 0x85,
	0xf5, 0xf9, 0x4a, 0x97, 0x60, 0x86, 0x2b, 0xd5, 0x1d, 0xd2, 0xb6, 0x31, 0xce, 0xe5, 0xa7, 0x99,
	0x3c, 0x6b, 0x8f, 0x1b, 0xe0, 0xb2, 0x47, 0xba, 0x45, 0x03, 0x85, 0x89, 0xb6, 0x01, 0xd6, 0xf9,
	0x40, 0xb7, 0xa8, 0xaf, 0xf4, 0x2e, 0xe4, 0x98, 0x92, 0xed, 0xd8, 0x1a, 0x69, 0xd9, 0xda, 0x33,
	0xcb, 0x23, 0x54, 0x73, 0x0f, 0xa9, 0x66, 0x7a, 0x8e, 0x9b, 0x05, 0x3e, 0xfb, 0x39, 0x6a, 0xb8,
	0x25, 0xc7, 0xae, 0xb4, 0xec, 0x1d, 0xd6, 0x5d, 0x3e, 0xa4, 0x5b, 0x9e, 0xe3, 0xa2, 0x75, 0x38,
	0x63, 0x31, 0x4d, 0xaf, 0xa1, 0xd7, 0xad, 0x2f, 0x75, 0xca, 0x7c, 0x81, 0xed, 0xec, 0x24, 0xd7,
	0x99, 0xb1, 0xdc, 0x52, 0xb8, 0x47, 0xb8, 0x4c, 0x98, 0x8a, 0x29, 0x4c, 0x71, 0x05, 0xc4, 0x8d,
	0x44, 0x35, 0x0a, 0x30, 0x67, 0x19, 0x8d, 0x04, 0x95, 0x14, 0x57, 0x39, 0xc3, 0x3a, 0xe3, 0x3a,
	0xd7, 0x61, 0xc1, 0x72, 0x35, 0x4a, 0xeb, 0x9a, 0x71, 0xa0, 0xdb, 0x35, 0xac, 0x99, 0x98, 0x62,
	0x83, 0x32, 0xad, 0x59, 0xa9, 0xe5, 0x56, 0x69, 0x7d, 0x93, 0x77, 0x6e, 0xf1, 0xbe, 0x6d, 0x1b,
	0x7d, 0x0c, 0xb3, 0x96, 0xab, 0x79, 0xe4, 0xb9, 0xa9, 0x3d, 0xab, 0xeb, 0x35, 0xa2, 0xe9, 0x06,
	0xc3, 0xcb, 0xce, 0xad, 0x2a, 0x6b, 0xe9, 0x42, 0x6e, 0x5d, 0xac, 0x8e, 0x88, 0xad, 0x0d, 0x2e,
	0xc1, 0x26, 0xaa, 0x92, 0xe7, 0xe6, 0x0e, 0xd3, 0x12, 0x4d, 0xe8, 0x3f, 0x61, 0xca, 0x72, 0x35,
	0xf3, 0x99, 0x0f, 0x32, 0xdf, 0x17, 0x04, 0x2c, 0x77, 0xeb, 0x99, 0xd4, 0xde, 0x81, 0x19, 0xcb,
	0xd5, 0x1c, 0x97, 0x7d, 0x04, 0xe3, 0x58, 0xe8, 0x0b, 0x31, 0x6d, 0xb9, 0xfb, 0x42, 0x47, 0xe2,
	0x14, 0x61, 0xce, 0x72, 0x35, 0xcb, 0x7e, 0xae, 0xd7, 0x2d, 0x53, 0xab, 0x63, 0xdb, 0xc7, 0xca,
	0xf6, 0xc5, 0x42, 0x96, 0xbb, 0x2b, 0xf4, 0xf6, 0xb0, 0x6c, 0x43, 0xef, 0x42, 0x26, 0x14, 0x6d,
	0xcc, 0x3c, 0x9c, 0x5d, 0x64, 0xbc, 0xba, 0x33, 0xfd, 0xdd, 0xab, 0x95, 0x49, 0x8f, 0xb9, 0xf3,
	0xbd, 0xab, 0x57, 0x0a, 0x37, 0x6e, 0xa8, 0xe9, 0x76, 0xec, 0x71, 0x95, 0xd6, 0x51, 0x05, 0xb2,
	0x3c, 0x8c, 0xfe, 0x58, 0x0c, 0xc7, 0xc4, 0xfe, 0x60, 0x96, 0xfb, 0x0e, 0x86, 0x53, 0x40, 0x0e,
	0x67, 0xd3, 0x31, 0x71, 0x30, 0x9e, 0x45, 0x0e, 0x6a, 0x62, 0xd7, 0xc3, 0x86, 0x4e, 0xb1, 0xa9,
	0x35, 0x48, 0x8d, 0x08, 0xde, 0xae, 0xf0, 0x48, 0xcf, 0x33, 0x81, 0xad, 0xa0, 0xbf, 0x48, 0x6a,
	0x84, 0x13, 0xf7, 0x1a, 0xf0, 0x1e, 0xcd, 0xc3, 0xa6, 0xe5, 0x31, 0x6e, 0x34, 0x48, 0x4d, 0xe8,
	0xad, 0xb6, 0x79, 0xa5, 0xca, 0xce, 0x22, 0xa9, 0x71, 0xa5, 0x9b, 0x90, 0x65, 0xec, 0x25, 0x6e,
	0xdd, 0xa2, 0x3c, 0x73, 0x91, 0x03, 0xfd, 0x10, 0x0b, 0xb5, 0x37, 0x83, 0x65, 0x52, 0x61, 0xdd,
	0xf7, 0xfc, 0x5e, 0xae, 0x58, 0x84, 0x39, 0x9e, 0x58, 0x3a, 0xb8, 0x75, 0xa9, 0x7f, 0x1c, 0x58,
	0xda, 0x89, 0x91, 0xeb, 0x3e, 0x2c, 0x32, 0xb8, 0xa6, 0x8d, 0x5f, 0xb8, 0xd8, 0x10, 0xd3, 0x0e,
	0x20, 0x2f, 0xf7, 0x85, 0x64, 0x29, 0xe2, 0x7e, 0xa0, 0x5b, 0x24, 0x3e, 0xec, 0x13, 0x58, 0x89,
	0xc1, 0x1e, 0x59, 0xb6, 0x46, 0x0c, 0xbd, 0x1e, 0x84, 0xea, 0xad, 0xbe, 0xe0, 0x4b, 0x11, 0xf0,
	0x07, 0x96, 0x5d, 0x61, 0xfa, 0x5d, 0x2d, 0x10, 0xdd, 0x38, 0xd4, 0x5c, 0xec, 0x35, 0x7c, 0x0b,
	0x57, 0x4e, 0x68, 0xa1, 0xa2, 0x1b, 0x87, 0x65, 0xec, 0x35, 0x02, 0xd7, 0xf0, 0x5c, 0xd6, 0xf4,
	0x6a, 0x9a, 0x4b, 0x3d, 0xcd, 0x76, 0x28, 0x4b, 0xb4, 0x3e, 0xf8, 0x7a, 0x7f, 0xa6, 0x31, 0x70,
	0xaf, 0x56, 0xa6, 0x5e, 0xc9, 0xa1, 0x15, 0x4c, 0x25, 0xec, 0x03, 0x58, 0xf2, 0x61, 0x59, 0xfc,
	0xe2, 0xb8, 0x6f, 0x1f, 0xcf, 0xe7, 0x5e, 0x8d, 0x45, 0x31, 0x02, 0xfc, 0x18, 0x96, 0x83, 0xf1,
	0xea, 0xad, 0xba, 0xa3, 0x9b, 0x5a, 0xc3, 0x22, 0x84, 0xed, 0x5f, 0x12, 0xfb, 0x6a, 0x5f, 0xec,
	0x9c, 0x1c, 0xb3, 0xd0, 0x2f, 0x0a, 0x75, 0x89, 0xaf, 0x0a, 0xca, 0xb2, 0x8c, 0x7e, 0x64, 0xd1,
	0x03, 0xcd, 0xd4, 0xa9, 0xee, 0x23, 0xbf, 0xd3, 0x17, 0x79, 0x96, 0x93, 0x8f, 0x3e, 0xb0, 0xe8,
	0xc1, 0x96, 0x4e, 0xf5, 0xa8, 0x8f, 0x39, 0x14, 0xcb, 0x29, 0x35, 0x1a, 0xe6, 0x5f, 0xe1, 0x58,
	0x3e, 0x66, 0x70, 0x7b, 0xd8, 0xbe, 0x4b, 0xdb, 0xf4, 0x7b, 0x2c, 0xc8, 0x11, 0x86, 0xe5, 0xfc,
	0x63, 0x99, 0x46, 0x62, 0x5f, 0xeb, 0x8b, 0xbd, 0x18, 0xc6, 0x66, 0xec, 0xb3, 0xbe, 0xec, 0x4e,
	0x3e, 0x4a, 0x64, 0x8e, 0xf5, 0xf1, 0xaf, 0x9f, 0x90, 0x7c, 0x55, 0x22, 0xf2, 0xad, 0xb4, 0xf0,
	0x39, 0x9c, 0x8d, 0x59, 0xc0, 0xc6, 0x81, 0xc3, 0xcc, 0x48, 0xfc, 0x1b, 0xc7, 0x1a, 0x7f, 0x1b,
	0x7f, 0xdb, 0x38, 0x70, 0xaa, 0xbe, 0x7f, 0x4c, 0x38, 0x97, 0xb4, 0x78, 0xa2, 0x33, 0xf8, 0x8f,
	0xbe, 0x16, 0xce, 0x76, 0x2c, 0x9f, 0xc8, 0x1c, 0xae, 0xc3, 0x02, 0xb3, 0x42, 0x09, 0xe7, 0xb8,
	0xeb, 0x61, 0x82, 0x6d, 0x59, 0x09, 0xdc, 0x14, 0x99, 0x91, 0x1a, 0x6e, 0x95, 0x94, 0x1c, 0x5a,
	0x16, 0x7d, 0x7e, 0x3a, 0x65, 0x5a, 0x7e, 0x76, 0x17, 0x39, 0x8e, 0x2b, 0xdd, 0x0a, 0x94, 0x64,
	0xfe, 0xe6, 0x89, 0x8c, 0x2b, 0xbd, 0x23, 0xb2, 0xa2, 0xed, 0xd8, 0xac, 0xec, 0xb0, 0x1d, 0x36,
	0x1b, 0xae, 0xf3, 0x6e, 0xa8, 0x1a, 0x60, 0x7d, 0x25, 0xd6, 0xc5, 0x54, 0xf2, 0xff, 0x0d, 0x8b,
	0xb1, 0xfa, 0x50, 0xc5, 0xff, 0xd3, 0xc4, 0x84, 0xa5, 0x68, 0x74, 0x1d, 0xc6, 0x3c, 0xf1, 0x95,
	0x55, 0x56, 0x87, 0xd7, 0x26, 0x03, 0x37, 0x24, 0x54, 0xaa, 0xaa, 0x2f, 0x9a, 0xbf, 0x0d, 0x73,
	0xf1, 0x7e, 0xaa, 0xd3, 0x26, 0x41, 0x17, 0x21, 0xed, 0x8a, 0x06, 0xbf, 0x4a, 0x65, 0x55, 0xed,
	0xa8, 0x9a, 0x92, 0xad, 0xa2, 0xee, 0xcc, 0xff, 0x46, 0x81, 0x85, 0x8e, 0x31, 0x11, 0xd7, 0xb1,
	0x09, 0x46, 0x1f, 0x00, 0xe8, 0xae, 0xa5, 0x11, 0x0e, 0xc8, 0xd5, 0xd3, 0x85, 0x8c, 0x2c, 0x8a,
	0x37, 0x5c, 0x4b, 0x18, 0xba, 0x93, 0xfe, 0xf6, 0xd5, 0x4a, 0x48, 0x4e, 0x9d, 0xd0, 0xfd, 0x2e,
	0xb4, 0xd9, 0x1e, 0x83, 0x04, 0xf1, 0x2b, 0xe5, 0xe4, 0x99, 0x09, 0x00, 0x7f, 0x84, 0xe2, 0x33,
	0xff, 0x10, 0x72, 0x5d, 0x06, 0xc8, 0xbc, 0xf6, 0x1e, 0x8c, 0x7b, 0xf2, 0x53, 0xba, 0x6d, 0x39,
	0x19, 0xdc, 0x57, 0x52, 0x03, 0xf9, 0xfc, 0xaf, 0x15, 0x78, 0x2d, 0x26, 0xb5, 0x85, 0xeb, 0x98,
	0xfa, 0x51, 0xf9, 0x37, 0x9e, 0x07, 0xf2, 0x4f, 0x60, 0xa5, 0xd7, 0xd0, 0xd8, 0xd4, 0xff, 0x2b,
	0x4e, 0x98, 0xf3, 0xc9, 0x33, 0x8f, 0x28, 0xb6, 0x99, 0xf3, 0x5b, 0x05, 0xce, 0x76, 0x91, 0xfc,
	0x51, 0xc5, 0xdf, 0x84, 0xd5, 0x9e, 0xc3, 0x64, 0xae, 0xf8, 0xb0, 0x83, 0x05, 0x17, 0x7a, 0xfb,
	0xa2, 0x83, 0x0b, 0xbf, 0x54, 0x3a, 0xd6, 0xe6, 0x5d, 0x4c, 0x7f, 0x04, 0x44, 0x78, 0xd4, 0xc1,
	0xd1, 0xf6, 0xb8, 0xc4, 0x02, 0x88, 0xb1, 0x60, 0x35, 0x79, 0xe6, 0x6d, 0xad, 0x36, 0x05, 0xe6,
	0x61, 0x36, 0x21, 0x04, 0x24, 0xff, 0x0f, 0xa5, 0x63, 0xcd, 0x71, 0xf5, 0x41, 0xf1, 0x62, 0x1d,
	0x46, 0x88, 0x8b, 0x0d, 0xe9, 0x9e, 0x5e, 0x79, 0x8e, 0xcb, 0xa1, 0xeb, 0x30, 0x2a, 0x8d, 0x0d,
	0x1f, 0x83, 0x3f, 0x52, 0x16, 0xbd, 0x03, 0xa7, 0xd9, 0x7f, 0x84, 0x1f, 0x93, 0x27, 0x0b, 0x4b,
	0xdd, 0x95, 0x88, 0x2a, 0x24, 0xf3, 0x8f, 0x3b, 0x96, 0x44, 0x68, 0xde, 0x62, 0xcd, 0xc5, 0x89,
	0x76, 0xae, 0x87, 0xbb, 0x3b, 0x58, 0xf6, 0x3b, 0x05, 0xc6, 0x2a, 0xd8, 0x7b, 0x6e, 0x19, 0x18,
	0x15, 0x60, 0xd2, 0x72, 0x35, 0x7e, 0x21, 0x61, 0x38, 0x75, 0xe9, 0x46, 0x9f, 0x5a, 0xbb, 0xe5,
	0xb2, 0xec, 0x60, 0x27, 0x2b, 0xff, 0x7f, 0xb4, 0x04, 0xe3, 0x26, 0x3b, 0xdd, 0x3a, 0x1e, 0xe5,
	0xce, 0x4b, 0xdd, 0x3b, 0xa5, 0x8e, 0x99, 0x84, 0x96, 0x1d, 0x8f, 0xa2, 0x5b, 0x90, 0xe2, 0x87,
	0x02, 0x76, 0x16, 0x60, 0x28, 0xdc, 0x59, 0xe9, 0x02, 0xf2, 0x21, 0x37, 0x8b, 0xe5, 0x22, 0xa9,
	0x55, 0x5b, 0x2e, 0xbe, 0x77, 0x4a, 0x9d, 0x64, 0xa2, 0xf2, 0x13, 0xad, 0xc2, 0xb0, 0x5e, 0xaf,
	0x71, 0x3f, 0xa5, 0x0b, 0x69, 0x39, 0xa1, 0x8d, 0xbd, 0xbb, 0x25, 0xbd, 0x81, 0x55, 0xd6, 0x75,
	0x67, 0x02, 0xc6, 0xea, 0xd7, 0x35, 0xcb, 0x7e, 0xe6, 0xe4, 0x9b, 0x90, 0xd9, 0xb1, 0x3c, 0x7c,
	0xa4, 0xd7, 0xeb, 0x6a, 0x53, 0x5e, 0x9c, 0xac, 0xc2, 0x30, 0x79, 0xce, 0xe2, 0xc9, 0x3c, 0x92,
	0x0e, 0x3c, 0xc2, 0x27, 0xaa, 0xb2, 0x2e, 0x74, 0x05, 0x46, 0xe5, 0x1e, 0x2f, 0x46, 0x35, 0x27,
	0x85, 0x7c, 0x28, 0xb9, 0xbd, 0x4b, 0x21, 0x94, 0x81, 0xe1, 0xba, 0x53, 0x93, 0x17, 0x1c, 0xec,
	0xdf, 0xfc, 0xff, 0xc1, 0x78, 0xe5, 0x6e, 0xd9, 0xa9, 0x5b, 0x46, 0x0b, 0xdd, 0x84, 0x49, 0xcb,
	0xd6, 0x9e, 0x1d, 0x69, 0x5e, 0xb3, 0x8e, 0x89, 0x0c, 0xc4, 0x42, 0x0c, 0xd1, 0x1f, 0x9c, 0x3a,
	0x61, 0xd9, 0x3b, 0x47, 0xec, 0x8b, 0x30, 0x45, 0x5c, 0x6b, 0x2b, 0x0e, 0xf5, 0x51, 0xc4, 0x35,
	0xa9, 0x98, 0xff, 0x7d, 0x68, 0x9b, 0xbc, 0xeb, 0x39, 0x4d, 0x57, 0x8c, 0xe4, 0x24, 0xb7, 0x46,
	0xc5, 0xe4, 0xe4, 0xb0, 0x1a, 0x4e, 0x0e, 0x21, 0xe8, 0x76, 0x82, 0x18, 0xfb, 0xf6, 0xd5, 0xca,
	0xf0, 0x21, 0x6e, 0x45, 0x2f, 0x8c, 0x0a, 0x30, 0xe5, 0x72, 0x41, 0x39, 0x17, 0xb1, 0x32, 0xa6,
	0x7d, 0xdf, 0x4b, 0x57, 0xa9, 0x93, 0x42, 0x48, 0xcc, 0xe2, 0xd3, 0x36, 0xbd, 0x43, 0x96, 0x42,
	0xc9, 0xe4, 0x56, 0x3c, 0x99, 0xc4, 0x37, 0xd3, 0xd8, 0xdc, 0xdb, 0xa9, 0xe4, 0xc3, 0x76, 0xfa,
	0x0c, 0xcb, 0x88, 0x95, 0x78, 0x1e, 0x52, 0x72, 0xac, 0x91, 0x52, 0x44, 0x4e, 0x40, 0x26, 0xba,
	0x97, 0x0a, 0x2c, 0x25, 0x8e, 0x6e, 0x50, 0x59, 0xe7, 0x56, 0x90, 0x45, 0x7c, 0xcf, 0x77, 0x9f,
	0x5b, 0x24, 0x93, 0xe4, 0x9f, 0xc0, 0x72, 0x8f, 0x91, 0x31, 0xc7, 0xdd, 0xee, 0xc8, 0x0b, 0xf9,
	0xee, 0xe8, 0x09, 0x89, 0xe1, 0xa5, 0xd2, 0xde, 0xe5, 0x42, 0x92, 0xdf, 0xab, 0x1c, 0x19, 0x2c,
	0xd1, 0xf2, 0x07, 0x70, 0xbe, 0xdf, 0xc8, 0x98, 0x07, 0x36, 0xe2, 0xd4, 0x79, 0xa3, 0xbb, 0x03,
	0xba, 0x54, 0x24, 0x26, 0x9c, 0xeb, 0x21, 0x3c, 0x20, 0x1a, 0xe4, 0xeb, 0x70, 0xa1, 0xaf, 0x15,
	0x36, 0xa1, 0xad, 0x8e, 0x90, 0xae, 0xf5, 0x9f, 0x51, 0x47, 0x60, 0x7f, 0xa1, 0x24, 0xae, 0xb9,
	0x93, 0xd7, 0x16, 0x03, 0x8e, 0xea, 0xd3, 0x44, 0xbe, 0x45, 0x4b, 0x8b, 0xdb, 0xf1, 0x90, 0x5e,
	0xe8, 0xee, 0x80, 0xa4, 0xf2, 0x22, 0x07, 0xd9, 0x2e, 0x6b, 0x8b, 0xe4, 0x7f, 0x3a, 0x94, 0xb8,
	0xa6, 0x06, 0x5a, 0x66, 0x14, 0x22, 0x65, 0x46, 0xbf, 0x54, 0x26, 0x4a, 0x8d, 0x5b, 0xb1, 0x52,
	0xe3, 0xd8, 0x49, 0x02, 0xdd, 0x88, 0x96, 0x1b, 0x2b, 0xbd, 0x15, 0x83, 0x92, 0xe3, 0x57, 0x4a,
	0x22, 0xeb, 0x63, 0x75, 0xc7, 0x46, 0x07, 0x19, 0x2f, 0xf6, 0x89, 0x45, 0x9c, 0x89, 0xe8, 0xed,
	0x88, 0x3b, 0x87, 0x92, 0xdd, 0x19, 0x5e, 0x28, 0xff, 0xaf, 0xc0, 0x4c, 0x04, 0xfd, 0x24, 0xbb,
	0xdd, 0xdd, 0x64, 0xba, 0xe6, 0x3a, 0xe8, 0xda, 0x8f, 0xa8, 0xc5, 0xd8, 0xc6, 0x1b, 0xe2, 0x67,
	0x21, 0xce, 0xcf, 0x6c, 0x92, 0x4f, 0xa2, 0xfb, 0x54, 0xa1, 0xfd, 0xf2, 0x23, 0x7a, 0x45, 0xf0,
	0x96, 0x60, 0x82, 0xd4, 0xa2, 0xbb, 0xd3, 0x38, 0xa9, 0xc9, 0x21, 0x7c, 0xad, 0xb4, 0x0f, 0xd9,
	0x72, 0x0c, 0x83, 0xa3, 0x68, 0x74, 0x4f, 0xca, 0x25, 0xce, 0x20, 0xba, 0x1b, 0x55, 0x63, 0xcb,
	0x2a, 0xcc, 0x93, 0x5b, 0x1d, 0x3c, 0x79, 0x2d, 0x09, 0x31, 0x21, 0x51, 0x7d, 0x1d, 0xaa, 0xf9,
	0xb9, 0xcc, 0xf7, 0xda, 0x7b, 0x06, 0x16, 0xf6, 0xcf, 0x63, 0x69, 0xb3, 0x63, 0xbf, 0x79, 0x3f,
	0x1e, 0xfc, 0x73, 0x49, 0x13, 0xed, 0xb2, 0xd3, 0xe8, 0xb1, 0xe4, 0xd3, 0x99, 0xfd, 0xe3, 0x91,
	0x1d, 0x3e, 0xe9, 0x36, 0xf3, 0xb3, 0x78, 0xc5, 0x78, 0xf2, 0x94, 0x3f, 0x30, 0x67, 0x7e, 0x12,
	0x0b, 0x6d, 0x34, 0xcd, 0x1f, 0xaf, 0xe8, 0x4b, 0x4a, 0xf0, 0xb3, 0x80, 0x3a, 0x88, 0x4a, 0xf2,
	0x7f, 0x55, 0x62, 0x04, 0x1d, 0x68, 0x52, 0x7f, 0x2b, 0x92, 0xd4, 0xbb, 0xaf, 0x78, 0x91, 0xce,
	0x0b, 0xb1, 0x74, 0x7e, 0x8c, 0xf5, 0x85, 0xde, 0x8e, 0x26, 0xf2, 0xc5, 0x6e, 0x2a, 0x41, 0x0a,
	0xff, 0x2a, 0x5e, 0xb9, 0xc6, 0x92, 0xf7, 0xfb, 0x1d, 0x8b, 0x72, 0xa5, 0xab, 0x87, 0x7f, 0x78,
	0xda, 0xde, 0x86, 0x31, 0x79, 0xd4, 0x43, 0xaf, 0xc3, 0x08, 0x3f, 0x08, 0x2a, 0xdd, 0x0e, 0x82,
	0x2a, 0xef, 0x47, 0x08, 0x46, 0x0c, 0xc7, 0x14, 0xfc, 0x4a, 0xa9, 0xfc, 0x7f, 0x56, 0xb8, 0xc0,
	0x96, 0x53, 0xf9, 0x97, 0x9d, 0x56, 0x2f, 0xc3, 0xb8, 0x7f, 0x5a, 0x95, 0xb1, 0xf1, 0xcf, 0x8d,
	0x72, 0x7c, 0x4c, 0x58, 0x1e, 0x52, 0xc3, 0xc7, 0xcf, 0x27, 0x90, 0xe1, 0xc3, 0xe2, 0xaf, 0xd3,
	0x7b, 0x56, 0xc3, 0xa2, 0x04, 0x9d, 0x83, 0xa9, 0x86, 0xfe, 0x42, 0x93, 0x4f, 0xd6, 0x82, 0x56,
	0x29, 0x75, 0xb2, 0xa1, 0xbf, 0x90, 0x72, 0x04, 0xbd, 0x09, 0x99, 0xa7, 0x75, 0x47, 0x3c, 0xad,
	0xfb, 0x8f, 0xca, 0x62, 0xba, 0xd3, 0x7e, 0xbb, 0x7c, 0x50, 0xce, 0x7b, 0x7c, 0xe2, 0x7c, 0x2b,
	0xc5, 0x1e, 0x5a, 0x83, 0xcc, 0xd3, 0x16, 0xc5, 0x44, 0x73, 0xb1, 0xa7, 0x11, 0x6c, 0x38, 0xb6,
	0x29, 0xf1, 0xd3, 0xbc, 0xbd, 0x8c, 0xbd, 0x0a, 0x6f, 0x65, 0x7b, 0x88, 0x8b, 0xf5, 0x43, 0xcd,
	0xd3, 0xa9, 0xef, 0xca, 0x71, 0xd6, 0xa0, 0xea, 0x14, 0xa3, 0xb3, 0x00, 0x4f, 0x9b, 0x1e, 0xa1,
	0xfc, 0x41, 0x80, 0x4f, 0x38, 0xa5, 0x4e, 0xf0, 0x96, 0x8a, 0xf5, 0x25, 0xce, 0xff, 0x65, 0x08,
	0xd2, 0x5b, 0x4e, 0x65, 0xa7, 0xee, 0x38, 0xa6, 0x9c, 0x54, 0x11, 0xa6, 0x3d, 0x4c, 0xa8, 0x67,
	0x19, 0x54, 0xab, 0xf3, 0x26, 0x99, 0x2f, 0xfc, 0x2a, 0x2c, 0x2a, 0xbf, 0xae, 0x4a, 0x61, 0xf1,
	0xa9, 0xa6, 0xbd, 0xc8, 0x37, 0xfa, 0x88, 0xdf, 0xc5, 0xf1, 0x87, 0x64, 0x89, 0x26, 0x56, 0xd0,
	0xf9, 0x64, 0xb4, 0xb2, 0x90, 0x95, 0x60, 0x29, 0x37, 0xfc, 0x99, 0xfb, 0x0c, 0xd2, 0x51, 0x6b,
	0xec, 0xbc, 0xee, 0xba, 0xbe, 0xe3, 0xd9, 0xbf, 0xcc, 0x1b, 0x62, 0xc2, 0xac, 0x5d, 0x7a, 0x83,
	0x37, 0x94, 0x5d, 0x82, 0x72, 0x30, 0x6e, 0x36, 0x3d, 0x3d, 0xb8, 0x0f, 0x48, 0xa9, 0xc1, 0x77,
	0xee, 0x11, 0xa4, 0x22, 0xc6, 0x07, 0x88, 0x9d, 0xff, 0xf9, 0x08, 0xcc, 0xb0, 0xd8, 0x0a, 0x7c,
	0xcb, 0xb1, 0x79, 0x49, 0x73, 0x5e, 0xdc, 0x5e, 0xf8, 0xd9, 0x38, 0xf0, 0x47, 0xe4, 0x02, 0xe3,
	0x2d, 0xf0, 0x7f, 0x12, 0x21, 0x7f, 0xfb, 0x10, 0x0a, 0x73, 0x46, 0xf6, 0xf0, 0x1f, 0x3e, 0xf0,
	0x70, 0xdf, 0x86, 0xb4, 0x2f, 0x2d, 0xbd, 0x2d, 0x38, 0xbe, 0x10, 0x46, 0x0f, 0x51, 0x58, 0x4d,
	0x91, 0x08, 0xa3, 0x2f, 0xc3, 0x98, 0x2b, 0x08, 0x28, 0xb3, 0x50, 0x68, 0x58, 0x92, 0x99, 0xaa,
	0x2f, 0x81, 0x76, 0xc4, 0xcf, 0x12, 0xf8, 0xaf, 0x1f, 0x58, 0x08, 0x7d, 0x93, 0xa7, 0xb9, 0xe6,
	0x5c, 0x62, 0x80, 0xd5, 0x19, 0x6a, 0xb8, 0x95, 0x96, 0x1d, 0x66, 0xdc, 0x07, 0x90, 0x69, 0x9a,
	0x6e, 0x14, 0x63, 0xb4, 0x17, 0x46, 0xba, 0x69, 0xba, 0x61, 0x80, 0x0d, 0x98, 0xe1, 0x6b, 0x3a,
	0x82, 0x30, 0xd6, 0x0b, 0x61, 0x9a, 0xc9, 0x87, 0x21, 0x36, 0x01, 0x39, 0xf4, 0x00, 0x7b, 0x51,
	0x8c, 0xf1, 0x5e, 0x18, 0x19, 0xae, 0x10, 0x06, 0xb9, 0x00, 0x69, 0x17, 0xb3, 0xe5, 0x1a, 0x94,
	0x74, 0x13, 0xab, 0xca, 0xda, 0x88, 0x3a, 0xc5, 0x5a, 0x2b, 0x7e, 0x59, 0x57, 0x81, 0xcc, 0xae,
	0x5d, 0xf3, 0x30, 0x21, 0xbe, 0x53, 0x5b, 0xe8, 0x03, 0x48, 0x9b, 0x0e, 0xd1, 0xdc, 0x80, 0x20,
	0x92, 0x15, 0xd9, 0x90, 0xfb, 0x23, 0xe4, 0x51, 0x53, 0xa6, 0x43, 0xda, 0x4d, 0x79, 0x15, 0xa6,
	0xb7, 0x07, 0x8d, 0xf9, 0x37, 0x05, 0x52, 0x01, 0xdc, 0x49, 0x8a, 0xf0, 0xdb, 0x90, 0xb6, 0xc4,
	0x0c, 0x35, 0x71, 0xd5, 0x22, 0xd7, 0xbc, 0xcf, 0xc2, 0xf8, 0xf4, 0xd5, 0x94, 0x14, 0x97, 0x23,
	0x7f, 0x1f, 0x52, 0x38, 0xa2, 0x2e, 0x48, 0x3c, 0x2f, 0xd5, 0x63, 0x13, 0x55, 0xa7, 0x70, 0x58,
	0xf9, 0x2c, 0x00, 0x9b, 0xb6, 0x0c, 0xc0, 0x08, 0xaf, 0xa9, 0x27, 0x4c, 0x87, 0xc8, 0xfb, 0xab,
	0x48, 0xc5, 0x7d, 0x7a, 0x75, 0x78, 0x6d, 0x24, 0x54, 0x71, 0x6f, 0xc3, 0x99, 0x36, 0x6c, 0xbb,
	0x52, 0x59, 0x8f, 0x57, 0x2a, 0xb3, 0xb1, 0x55, 0x11, 0xbb, 0x94, 0xba, 0x0a, 0xd3, 0xed, 0x1e,
	0xb1, 0xb9, 0x47, 0x47, 0xa5, 0xc4, 0x46, 0x95, 0xff, 0x89, 0x22, 0x12, 0xc4, 0x80, 0xaf, 0x9e,
	0xd6, 0x63, 0x65, 0xfe, 0x7c, 0xc7, 0xb8, 0xa3, 0x25, 0xfe, 0x1e, 0xcc, 0x76, 0x8c, 0x42, 0xbc,
	0x11, 0xc6, 0x2b, 0x89, 0x6c, 0x1c, 0x29, 0xa1, 0xb4, 0x7f, 0x0c, 0xf3, 0x41, 0xf7, 0xf7, 0xaa,
	0xea, 0xa3, 0x4e, 0x1b, 0x8a, 0x3b, 0xad, 0x0a, 0x8b, 0xc9, 0xf8, 0x6c, 0xc8, 0x37, 0xe3, 0x31,
	0x3b, 0x1b, 0x1f, 0x71, 0x97, 0x1a, 0xfd, 0x11, 0x2c, 0x74, 0x88, 0x0c, 0xea, 0x0e, 0xe8, 0x21,
	0xe4, 0xba, 0x60, 0xf7, 0x7e, 0x53, 0xec, 0xa2, 0x14, 0xf2, 0xf5, 0x67, 0x21, 0xe6, 0x9e, 0xbc,
	0xe2, 0xef, 0xe3, 0xe8, 0x52, 0x28, 0x90, 0xd1, 0x1a, 0xbe, 0xeb, 0xe3, 0x71, 0x82, 0x7c, 0xdb,
	0xc5, 0x19, 0x5e, 0x74, 0x84, 0xaf, 0x65, 0x5e, 0x29, 0x21, 0xe6, 0x0d, 0xb4, 0x6e, 0x5f, 0x8b,
	0xd4, 0xed, 0xc9, 0x0b, 0x57, 0xd4, 0xec, 0xeb, 0xb1, 0x9a, 0xbd, 0xcf, 0x62, 0x41, 0x97, 0xa3,
	0xf5, 0xfa, 0x5c, 0x92, 0x78, 0x50, 0xab, 0xab, 0x21, 0x56, 0xc5, 0xca, 0xf4, 0x9b, 0x1d, 0x61,
	0x5f, 0x4a, 0x74, 0x62, 0x3c, 0xe6, 0x97, 0x6c, 0x38, 0x93, 0xf0, 0x53, 0x05, 0x34, 0x0b, 0x99,
	0xd2, 0xbe, 0x5a, 0xd4, 0x36, 0x36, 0xab, 0xbb, 0xfb, 0x25, 0xad, 0xb4, 0x5f, 0xda, 0xce, 0x9c,
	0x42, 0x73, 0x30, 0x13, 0x6e, 0xdd, 0xd8, 0xdb, 0xdb, 0x7f, 0x90, 0x51, 0xe2, 0xc2, 0x5b, 0xea,
	0x7e, 0x39, 0x33, 0x14, 0x6f, 0xdd, 0xde, 0xda, 0xad, 0x66, 0x86, 0x2f, 0xfd, 0x2f, 0xa4, 0xa3,
	0xcf, 0x26, 0x28, 0x0b, 0xb3, 0x3b, 0xbb, 0xea, 0xf6, 0x83, 0x8d, 0xbd, 0xbd, 0x98, 0xb9, 0x45,
	0x98, 0x8b, 0xf7, 0xf8, 0x26, 0x13, 0x94, 0xb6, 0xb6, 0x4b, 0x9f, 0x66, 0x86, 0x50, 0x0e, 0xe6,
	0xe3, 0x3d, 0xea, 0xf6, 0x47, 0xdb, 0x9b, 0xcc, 0xf8, 0x57, 0x0a, 0x8c, 0xc9, 0xa7, 0x21, 0x94,
	0x81, 0xa9, 0x8d, 0x72, 0x59, 0xab, 0x7c, 0xb2, 0xe9, 0x9b, 0x0b, 0xb5, 0x54, 0x77, 0xaa, 0xe5,
	0x8c, 0x82, 0xa6, 0x61, 0xd2, 0x6f, 0x61, 0x0d, 0x43, 0xe1, 0x86, 0xad, 0x52, 0x25, 0x33, 0x1c,
	0x6e, 0xa8, 0xec, 0x96, 0x33, 0x23, 0xe8, 0x0c, 0x4c, 0x07, 0x0d, 0xf7, 0x4b, 0x9a, 0x5a, 0xde,
	0xcc, 0x9c, 0x66, 0xae, 0xf0, 0x1b, 0x8b, 0x95, 0x9d, 0x2a, 0x6f, 0x1d, 0x2d, 0xbc, 0x9c, 0x02,
	0x28, 0x1d, 0xf9, 0xc7, 0x28, 0xf4, 0xb8, 0xe3, 0xd7, 0x10, 0x9b, 0x1e, 0x66, 0xf5, 0xd8, 0x6a,
	0xb7, 0x1f, 0x05, 0xf8, 0x2b, 0x28, 0x77, 0xae, 0xf7, 0xcf, 0x06, 0x8a, 0xa4, 0x96, 0x3f, 0x95,
	0x80, 0x7f, 0xdf, 0x35, 0x07, 0x88, 0xff, 0x45, 0x07, 0xbe, 0x48, 0x34, 0xe8, 0xf5, 0x63, 0x3c,
	0xed, 0x33, 0x2b, 0x6f, 0x1c, 0xe7, 0xd9, 0x5b, 0xd8, 0xd2, 0xdb, 0x87, 0xf7, 0xf6, 0x9b, 0x25,
	0x3a, 0xdf, 0xef, 0xf5, 0x98, 0x59, 0xb9, 0xd0, 0xf7, 0xcd, 0xd3, 0x9f, 0x4e, 0xd2, 0xa3, 0x90,
	0x0c, 0xc9, 0x85, 0x5e, 0x0f, 0x24, 0x81, 0xa9, 0x8b, 0xfd, 0x9f, 0x51, 0x7a, 0xd9, 0x92, 0xe1,
	0x19, 0xb0, 0xad, 0xe7, 0x89, 0xb6, 0x64, 0xa8, 0x2e, 0x1d, 0xf3, 0xdd, 0x83, 0x59, 0xbc, 0x7c,
	0xdc, 0x17, 0x05, 0x61, 0xb7, 0x01, 0xf3, 0xc9, 0xd7, 0xbd, 0xe8, 0x8d, 0xe3, 0xdc, 0xcc, 0x33,
	0x8b, 0x6b, 0xc7, 0xba, 0x36, 0x16, 0xe6, 0x1e, 0xc6, 0xee, 0x4a, 0x65, 0xe0, 0x96, 0x93, 0x6f,
	0x14, 0x03, 0x13, 0x2b, 0xbd, 0x6e, 0x1c, 0x93, 0x91, 0x65, 0x98, 0x06, 0x80, 0x6c, 0xc6, 0x90,
	0x65, 0x50, 0x2e, 0xf4, 0xbd, 0x1c, 0xec, 0x4a, 0x80, 0xa4, 0x40, 0x7c, 0x06, 0x99, 0xf8, 0xd5,
	0x0d, 0x3a, 0xd7, 0xfb, 0xd6, 0x8c, 0xe1, 0xe7, 0xfb, 0x5c, 0xfb, 0x08, 0xf0, 0xbd, 0x50, 0xd5,
	0x2a, 0x5d, 0x9e, 0xeb, 0xac, 0xf2, 0x02, 0xd0, 0xa5, 0x6e, 0x15, 0x60, 0x27, 0x9a, 0x74, 0xf3,
	0x0f, 0x40, 0x7b, 0x18, 0x42, 0x93, 0xae, 0x5d, 0xed, 0x59, 0xcf, 0x85, 0x53, 0x5f, 0xf7, 0x92,
	0x2b, 0x7f, 0x0a, 0xed, 0xc3, 0x54, 0x78, 0x9b, 0x45, 0x67, 0xbb, 0x17, 0x30, 0x0c, 0x73, 0xb9,
	0xc7, 0xd6, 0xcc, 0x01, 0xef, 0xe4, 0xfe, 0xf0, 0xcd, 0xb2, 0xf2, 0xc7, 0x6f, 0x96, 0x95, 0x3f,
	0x7d, 0xb3, 0xac, 0xbc, 0xfc, 0xf3, 0xf2, 0xa9, 0x47, 0xe3, 0x07, 0x7a, 0x9d, 0xdf, 0x60, 0x3d,
	0x1d, 0xe5, 0x7f, 0xae, 0xfd, 0x33, 0x00, 0x00, 0xff, 0xff, 0x0c, 0xc9, 0xfd, 0xa6, 0x34, 0x32,
	0x00, 0x00,
}
