// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcp_proxy.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TcpProxyActionType int32

const (
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_NONE    TcpProxyActionType = 0
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_ENABLE  TcpProxyActionType = 1
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_DISABLE TcpProxyActionType = 2
)

var TcpProxyActionType_name = map[int32]string{
	0: "TCP_PROXY_ACTION_TYPE_NONE",
	1: "TCP_PROXY_ACTION_TYPE_ENABLE",
	2: "TCP_PROXY_ACTION_TYPE_DISABLE",
}
var TcpProxyActionType_value = map[string]int32{
	"TCP_PROXY_ACTION_TYPE_NONE":    0,
	"TCP_PROXY_ACTION_TYPE_ENABLE":  1,
	"TCP_PROXY_ACTION_TYPE_DISABLE": 2,
}

func (x TcpProxyActionType) String() string {
	return proto.EnumName(TcpProxyActionType_name, int32(x))
}
func (TcpProxyActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{0} }

type TcpProxyAction struct {
	TcpProxyActionType TcpProxyActionType `protobuf:"varint,1,opt,name=tcp_proxy_action_type,json=tcpProxyActionType,proto3,enum=tcp_proxy.TcpProxyActionType" json:"tcp_proxy_action_type,omitempty"`
}

func (m *TcpProxyAction) Reset()                    { *m = TcpProxyAction{} }
func (m *TcpProxyAction) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyAction) ProtoMessage()               {}
func (*TcpProxyAction) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{0} }

func (m *TcpProxyAction) GetTcpProxyActionType() TcpProxyActionType {
	if m != nil {
		return m.TcpProxyActionType
	}
	return TcpProxyActionType_TCP_PROXY_ACTION_TYPE_NONE
}

type TcpProxyRuleMatchSpec struct {
	RuleId         uint64          `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Match          *RuleMatch      `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
	TcpProxyAction *TcpProxyAction `protobuf:"bytes,3,opt,name=tcp_proxy_action,json=tcpProxyAction" json:"tcp_proxy_action,omitempty"`
}

func (m *TcpProxyRuleMatchSpec) Reset()                    { *m = TcpProxyRuleMatchSpec{} }
func (m *TcpProxyRuleMatchSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleMatchSpec) ProtoMessage()               {}
func (*TcpProxyRuleMatchSpec) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{1} }

func (m *TcpProxyRuleMatchSpec) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *TcpProxyRuleMatchSpec) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *TcpProxyRuleMatchSpec) GetTcpProxyAction() *TcpProxyAction {
	if m != nil {
		return m.TcpProxyAction
	}
	return nil
}

// TcpProxyRuleSpec is the user intent for the TcpProxy rule
type TcpProxyRuleSpec struct {
	Meta         *ObjectMeta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle  *TcpProxyRuleKeyHandle   `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle            `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	Rules        []*TcpProxyRuleMatchSpec `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
}

func (m *TcpProxyRuleSpec) Reset()                    { *m = TcpProxyRuleSpec{} }
func (m *TcpProxyRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleSpec) ProtoMessage()               {}
func (*TcpProxyRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{2} }

func (m *TcpProxyRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *TcpProxyRuleSpec) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *TcpProxyRuleSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *TcpProxyRuleSpec) GetRules() []*TcpProxyRuleMatchSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// TcpProxyRuleRequestMsg is the batched add or modify of NAT rule request
type TcpProxyRuleRequestMsg struct {
	Request []*TcpProxyRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleRequestMsg) Reset()                    { *m = TcpProxyRuleRequestMsg{} }
func (m *TcpProxyRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleRequestMsg) ProtoMessage()               {}
func (*TcpProxyRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{3} }

func (m *TcpProxyRuleRequestMsg) GetRequest() []*TcpProxyRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyRuleStatus reflects the current operational status of the TcpProxy rule
type TcpProxyRuleStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *TcpProxyRuleStatus) Reset()                    { *m = TcpProxyRuleStatus{} }
func (m *TcpProxyRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleStatus) ProtoMessage()               {}
func (*TcpProxyRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{4} }

func (m *TcpProxyRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// TcpProxyRuleResponse is the response to TcpProxyRuleSpec
type TcpProxyRuleResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *TcpProxyRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *TcpProxyRuleResponse) Reset()                    { *m = TcpProxyRuleResponse{} }
func (m *TcpProxyRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleResponse) ProtoMessage()               {}
func (*TcpProxyRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{5} }

func (m *TcpProxyRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyRuleResponse) GetStatus() *TcpProxyRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// TcpProxyRuleResponseMsg is batched response to TcpProxyRuleRequestMsg
type TcpProxyRuleResponseMsg struct {
	Response []*TcpProxyRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleResponseMsg) Reset()                    { *m = TcpProxyRuleResponseMsg{} }
func (m *TcpProxyRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleResponseMsg) ProtoMessage()               {}
func (*TcpProxyRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{6} }

func (m *TcpProxyRuleResponseMsg) GetResponse() []*TcpProxyRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyRuleDeleteRequest is used to delete a policy rule
type TcpProxyRuleDeleteRequest struct {
	Meta        *ObjectMeta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *TcpProxyRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyRuleDeleteRequest) Reset()         { *m = TcpProxyRuleDeleteRequest{} }
func (m *TcpProxyRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteRequest) ProtoMessage()    {}
func (*TcpProxyRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{7}
}

func (m *TcpProxyRuleDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *TcpProxyRuleDeleteRequest) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyRuleDeleteRequestMsg is used to delete a batch of tcp_proxy rules
type TcpProxyRuleDeleteRequestMsg struct {
	Request []*TcpProxyRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleDeleteRequestMsg) Reset()         { *m = TcpProxyRuleDeleteRequestMsg{} }
func (m *TcpProxyRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteRequestMsg) ProtoMessage()    {}
func (*TcpProxyRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{8}
}

func (m *TcpProxyRuleDeleteRequestMsg) GetRequest() []*TcpProxyRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyRuleDeleteResponse is response to TcpProxyRuleDeleteRequest
type TcpProxyRuleDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *TcpProxyRuleDeleteResponse) Reset()         { *m = TcpProxyRuleDeleteResponse{} }
func (m *TcpProxyRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteResponse) ProtoMessage()    {}
func (*TcpProxyRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{9}
}

func (m *TcpProxyRuleDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// TcpProxyRuleDeleteResponseMsg is batched response to TcpProxyRuleDeleteRequestMsg
type TcpProxyRuleDeleteResponseMsg struct {
	Response []*TcpProxyRuleDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleDeleteResponseMsg) Reset()         { *m = TcpProxyRuleDeleteResponseMsg{} }
func (m *TcpProxyRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteResponseMsg) ProtoMessage()    {}
func (*TcpProxyRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{10}
}

func (m *TcpProxyRuleDeleteResponseMsg) GetResponse() []*TcpProxyRuleDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyRuleGetRequest is used to get information about a tcp_proxy rule
type TcpProxyRuleGetRequest struct {
	Meta        *ObjectMeta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *TcpProxyRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyRuleGetRequest) Reset()                    { *m = TcpProxyRuleGetRequest{} }
func (m *TcpProxyRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetRequest) ProtoMessage()               {}
func (*TcpProxyRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{11} }

func (m *TcpProxyRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *TcpProxyRuleGetRequest) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyRuleGetRequestMsg is batched GET requests for tcp_proxy rule
type TcpProxyRuleGetRequestMsg struct {
	Request []*TcpProxyRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleGetRequestMsg) Reset()         { *m = TcpProxyRuleGetRequestMsg{} }
func (m *TcpProxyRuleGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetRequestMsg) ProtoMessage()    {}
func (*TcpProxyRuleGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{12}
}

func (m *TcpProxyRuleGetRequestMsg) GetRequest() []*TcpProxyRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// per rule stats
type TcpProxyRuleEntryStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,2,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *TcpProxyRuleEntryStats) Reset()                    { *m = TcpProxyRuleEntryStats{} }
func (m *TcpProxyRuleEntryStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleEntryStats) ProtoMessage()               {}
func (*TcpProxyRuleEntryStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{13} }

func (m *TcpProxyRuleEntryStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *TcpProxyRuleEntryStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// per policy stats
type TcpProxyRuleStats struct {
	Stats []*TcpProxyRuleEntryStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *TcpProxyRuleStats) Reset()                    { *m = TcpProxyRuleStats{} }
func (m *TcpProxyRuleStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleStats) ProtoMessage()               {}
func (*TcpProxyRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{14} }

func (m *TcpProxyRuleStats) GetStats() []*TcpProxyRuleEntryStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpProxyRuleGetResponse catpures all information about TcpProxy policy
type TcpProxyRuleGetResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *TcpProxyRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *TcpProxyRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *TcpProxyRuleStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *TcpProxyRuleGetResponse) Reset()                    { *m = TcpProxyRuleGetResponse{} }
func (m *TcpProxyRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetResponse) ProtoMessage()               {}
func (*TcpProxyRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{15} }

func (m *TcpProxyRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyRuleGetResponse) GetSpec() *TcpProxyRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TcpProxyRuleGetResponse) GetStatus() *TcpProxyRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TcpProxyRuleGetResponse) GetStats() *TcpProxyRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpProxyRuleGetResponseMsg is batched response to TcpProxyRuleGetRequestMsg
type TcpProxyRuleGetResponseMsg struct {
	Response []*TcpProxyRuleGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleGetResponseMsg) Reset()         { *m = TcpProxyRuleGetResponseMsg{} }
func (m *TcpProxyRuleGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetResponseMsg) ProtoMessage()    {}
func (*TcpProxyRuleGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{16}
}

func (m *TcpProxyRuleGetResponseMsg) GetResponse() []*TcpProxyRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*TcpProxyAction)(nil), "tcp_proxy.TcpProxyAction")
	proto.RegisterType((*TcpProxyRuleMatchSpec)(nil), "tcp_proxy.TcpProxyRuleMatchSpec")
	proto.RegisterType((*TcpProxyRuleSpec)(nil), "tcp_proxy.TcpProxyRuleSpec")
	proto.RegisterType((*TcpProxyRuleRequestMsg)(nil), "tcp_proxy.TcpProxyRuleRequestMsg")
	proto.RegisterType((*TcpProxyRuleStatus)(nil), "tcp_proxy.TcpProxyRuleStatus")
	proto.RegisterType((*TcpProxyRuleResponse)(nil), "tcp_proxy.TcpProxyRuleResponse")
	proto.RegisterType((*TcpProxyRuleResponseMsg)(nil), "tcp_proxy.TcpProxyRuleResponseMsg")
	proto.RegisterType((*TcpProxyRuleDeleteRequest)(nil), "tcp_proxy.TcpProxyRuleDeleteRequest")
	proto.RegisterType((*TcpProxyRuleDeleteRequestMsg)(nil), "tcp_proxy.TcpProxyRuleDeleteRequestMsg")
	proto.RegisterType((*TcpProxyRuleDeleteResponse)(nil), "tcp_proxy.TcpProxyRuleDeleteResponse")
	proto.RegisterType((*TcpProxyRuleDeleteResponseMsg)(nil), "tcp_proxy.TcpProxyRuleDeleteResponseMsg")
	proto.RegisterType((*TcpProxyRuleGetRequest)(nil), "tcp_proxy.TcpProxyRuleGetRequest")
	proto.RegisterType((*TcpProxyRuleGetRequestMsg)(nil), "tcp_proxy.TcpProxyRuleGetRequestMsg")
	proto.RegisterType((*TcpProxyRuleEntryStats)(nil), "tcp_proxy.TcpProxyRuleEntryStats")
	proto.RegisterType((*TcpProxyRuleStats)(nil), "tcp_proxy.TcpProxyRuleStats")
	proto.RegisterType((*TcpProxyRuleGetResponse)(nil), "tcp_proxy.TcpProxyRuleGetResponse")
	proto.RegisterType((*TcpProxyRuleGetResponseMsg)(nil), "tcp_proxy.TcpProxyRuleGetResponseMsg")
	proto.RegisterEnum("tcp_proxy.TcpProxyActionType", TcpProxyActionType_name, TcpProxyActionType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TcpProxy service

type TcpProxyClient interface {
	TcpProxyRuleCreate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleUpdate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleDelete(ctx context.Context, in *TcpProxyRuleDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleDeleteResponseMsg, error)
	TcpProxyRuleGet(ctx context.Context, in *TcpProxyRuleGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleGetResponseMsg, error)
}

type tcpProxyClient struct {
	cc *grpc.ClientConn
}

func NewTcpProxyClient(cc *grpc.ClientConn) TcpProxyClient {
	return &tcpProxyClient{cc}
}

func (c *tcpProxyClient) TcpProxyRuleCreate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error) {
	out := new(TcpProxyRuleResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleUpdate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error) {
	out := new(TcpProxyRuleResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleDelete(ctx context.Context, in *TcpProxyRuleDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleDeleteResponseMsg, error) {
	out := new(TcpProxyRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleGet(ctx context.Context, in *TcpProxyRuleGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleGetResponseMsg, error) {
	out := new(TcpProxyRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TcpProxy service

type TcpProxyServer interface {
	TcpProxyRuleCreate(context.Context, *TcpProxyRuleRequestMsg) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleUpdate(context.Context, *TcpProxyRuleRequestMsg) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleDelete(context.Context, *TcpProxyRuleDeleteRequestMsg) (*TcpProxyRuleDeleteResponseMsg, error)
	TcpProxyRuleGet(context.Context, *TcpProxyRuleGetRequestMsg) (*TcpProxyRuleGetResponseMsg, error)
}

func RegisterTcpProxyServer(s *grpc.Server, srv TcpProxyServer) {
	s.RegisterService(&_TcpProxy_serviceDesc, srv)
}

func _TcpProxy_TcpProxyRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleCreate(ctx, req.(*TcpProxyRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleUpdate(ctx, req.(*TcpProxyRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleDelete(ctx, req.(*TcpProxyRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleGet(ctx, req.(*TcpProxyRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _TcpProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tcp_proxy.TcpProxy",
	HandlerType: (*TcpProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TcpProxyRuleCreate",
			Handler:    _TcpProxy_TcpProxyRuleCreate_Handler,
		},
		{
			MethodName: "TcpProxyRuleUpdate",
			Handler:    _TcpProxy_TcpProxyRuleUpdate_Handler,
		},
		{
			MethodName: "TcpProxyRuleDelete",
			Handler:    _TcpProxy_TcpProxyRuleDelete_Handler,
		},
		{
			MethodName: "TcpProxyRuleGet",
			Handler:    _TcpProxy_TcpProxyRuleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tcp_proxy.proto",
}

func (m *TcpProxyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpProxyActionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpProxyActionType))
	}
	return i, nil
}

func (m *TcpProxyRuleMatchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleMatchSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RuleId))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Match.Size()))
		n1, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TcpProxyAction != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpProxyAction.Size()))
		n2, err := m.TcpProxyAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *TcpProxyRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n4, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n5, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *TcpProxyRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *TcpProxyRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n8, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Meta.Size()))
		n9, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n10, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *TcpProxyRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleEntryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleEntryStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *TcpProxyRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Spec.Size()))
		n11, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Status.Size()))
		n12, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Stats.Size()))
		n13, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *TcpProxyRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTcpProxy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TcpProxyAction) Size() (n int) {
	var l int
	_ = l
	if m.TcpProxyActionType != 0 {
		n += 1 + sovTcpProxy(uint64(m.TcpProxyActionType))
	}
	return n
}

func (m *TcpProxyRuleMatchSpec) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovTcpProxy(uint64(m.RuleId))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.TcpProxyAction != nil {
		l = m.TcpProxyAction.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *TcpProxyRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	return n
}

func (m *TcpProxyRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleEntryStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovTcpProxy(uint64(m.NumTcpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovTcpProxy(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *TcpProxyRuleStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func sovTcpProxy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTcpProxy(x uint64) (n int) {
	return sovTcpProxy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TcpProxyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpProxyActionType", wireType)
			}
			m.TcpProxyActionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpProxyActionType |= (TcpProxyActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleMatchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleMatchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleMatchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpProxyAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpProxyAction == nil {
				m.TcpProxyAction = &TcpProxyAction{}
			}
			if err := m.TcpProxyAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &TcpProxyRuleMatchSpec{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpProxyRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleEntryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleEntryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleEntryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &TcpProxyRuleEntryStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TcpProxyRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpProxyRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TcpProxyRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTcpProxy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTcpProxy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTcpProxy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTcpProxy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTcpProxy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTcpProxy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tcp_proxy.proto", fileDescriptorTcpProxy) }

var fileDescriptorTcpProxy = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xc6, 0x8e, 0x9b, 0x3e, 0x53, 0xd7, 0x19, 0x91, 0xd6, 0x31, 0x89, 0xe3, 0xac, 0x1a,
	0xb0, 0x50, 0x65, 0x24, 0xa3, 0x82, 0x04, 0x02, 0x64, 0xbb, 0x2e, 0x44, 0xd4, 0x1f, 0x9a, 0x98,
	0xaa, 0x45, 0xc0, 0xb2, 0x5e, 0x4f, 0x6a, 0x63, 0x7b, 0x77, 0xd9, 0x19, 0x47, 0xec, 0x05, 0x89,
	0x1b, 0x27, 0x6e, 0x48, 0x5c, 0xf8, 0x7f, 0x38, 0xf2, 0x17, 0x44, 0x28, 0xdc, 0x38, 0xf6, 0x8e,
	0x84, 0x66, 0x66, 0xd7, 0xfb, 0x11, 0x6f, 0xec, 0x4a, 0x15, 0xa7, 0x64, 0xe6, 0xfd, 0xde, 0xef,
	0x7d, 0xfc, 0xde, 0xbc, 0x35, 0xdc, 0x66, 0x86, 0xad, 0xd9, 0x8e, 0xf5, 0x83, 0x5b, 0xb5, 0x1d,
	0x8b, 0x59, 0xe8, 0xe6, 0xe2, 0xa2, 0x98, 0x65, 0xae, 0x4d, 0xa8, 0xbc, 0x2f, 0x6e, 0x4f, 0x46,
	0xf2, 0x3f, 0x75, 0x00, 0xb9, 0xbe, 0x61, 0xf7, 0x38, 0xa4, 0x6e, 0xb0, 0xb1, 0x65, 0xa2, 0x1e,
	0xec, 0x2e, 0xbc, 0x34, 0x5d, 0xdc, 0x69, 0xdc, 0xb7, 0xa0, 0x94, 0x95, 0x4a, 0xae, 0x76, 0x50,
	0x0d, 0x82, 0x44, 0x3d, 0xfb, 0xae, 0x4d, 0x30, 0x62, 0x57, 0xee, 0xd4, 0xdf, 0x15, 0xd8, 0xf5,
	0xa1, 0x78, 0x3e, 0x25, 0x6d, 0x9d, 0x19, 0xa3, 0x53, 0x9b, 0x18, 0xe8, 0x2e, 0xdc, 0x70, 0xe6,
	0x53, 0xa2, 0x8d, 0x87, 0x82, 0x3d, 0x8d, 0x33, 0xfc, 0x78, 0x32, 0x44, 0x6f, 0xc2, 0xd6, 0x8c,
	0xa3, 0x0a, 0x9b, 0x65, 0xa5, 0x92, 0xad, 0xe5, 0xab, 0x32, 0xfb, 0x85, 0x37, 0x96, 0x66, 0xd4,
	0x84, 0x7c, 0x3c, 0xd9, 0x42, 0x4a, 0xb8, 0xec, 0x25, 0xe6, 0x89, 0x73, 0xd1, 0x1c, 0xd5, 0x9f,
	0x37, 0x21, 0x1f, 0xce, 0x4f, 0xa4, 0x76, 0x0c, 0xe9, 0x19, 0x61, 0xba, 0xc8, 0x2b, 0x5b, 0xdb,
	0xf1, 0x12, 0xe8, 0x0e, 0xbe, 0x23, 0x06, 0x6b, 0x13, 0xa6, 0x63, 0x61, 0x46, 0x6d, 0xb8, 0x35,
	0x21, 0xae, 0x66, 0x39, 0xda, 0x48, 0x37, 0x87, 0x53, 0xe2, 0x25, 0xbc, 0x57, 0x9d, 0x8c, 0xaa,
	0x61, 0xce, 0xcf, 0x89, 0xfb, 0x99, 0x00, 0x34, 0x72, 0x2f, 0x2e, 0x0e, 0xe1, 0x9c, 0x98, 0x63,
	0x83, 0x7c, 0x30, 0x21, 0x2e, 0xce, 0x4e, 0x88, 0xdb, 0x75, 0xa4, 0x11, 0x3d, 0x82, 0xdc, 0xb9,
	0x73, 0xa6, 0x71, 0x4a, 0x8f, 0x2f, 0xe5, 0x35, 0x60, 0x32, 0xaa, 0x3e, 0x71, 0xce, 0x96, 0xd3,
	0x38, 0xe4, 0x0c, 0xbf, 0x76, 0x1e, 0xb2, 0xa2, 0xf7, 0x60, 0x8b, 0x77, 0x92, 0x16, 0xd2, 0xe5,
	0x54, 0x25, 0x5b, 0x2b, 0x2f, 0x69, 0x46, 0x44, 0x09, 0x2c, 0xe1, 0x6a, 0x17, 0xee, 0x84, 0xed,
	0x98, 0x7c, 0x3f, 0x27, 0x94, 0xb5, 0xe9, 0x73, 0xf4, 0x00, 0x6e, 0x38, 0xf2, 0x54, 0x50, 0x04,
	0xe7, 0x1b, 0x09, 0x9c, 0x82, 0xce, 0xc7, 0xaa, 0xf7, 0x01, 0x45, 0x8c, 0x4c, 0x67, 0x73, 0x8a,
	0xee, 0x40, 0xc6, 0x2b, 0x8f, 0xb7, 0x37, 0x83, 0xbd, 0x93, 0xfa, 0x8b, 0x02, 0xaf, 0x47, 0xe3,
	0x53, 0xdb, 0x32, 0x29, 0x41, 0x9f, 0x00, 0xe8, 0xf6, 0x58, 0xa3, 0xc2, 0xdd, 0x9b, 0x44, 0x7f,
	0x28, 0xea, 0xf6, 0x58, 0xd2, 0x36, 0x72, 0xff, 0x5c, 0x1c, 0x86, 0x70, 0xf8, 0xa6, 0xee, 0x9b,
	0xd0, 0x03, 0xc8, 0x78, 0xce, 0x52, 0xa0, 0x83, 0xa4, 0xec, 0xa5, 0xa7, 0x07, 0x56, 0x9f, 0xc0,
	0xdd, 0x65, 0xf9, 0xf0, 0x86, 0x7c, 0x08, 0xdb, 0x8e, 0x77, 0xf4, 0x3a, 0x72, 0x98, 0xc0, 0xe9,
	0x7b, 0xe1, 0x85, 0x83, 0xfa, 0x93, 0x02, 0x7b, 0x61, 0xc8, 0x43, 0x32, 0x25, 0xcc, 0x6f, 0xf7,
	0xba, 0xb3, 0xf7, 0xd1, 0xcb, 0xce, 0x5e, 0x64, 0xd6, 0xd4, 0x6f, 0x60, 0x3f, 0x31, 0x05, 0x5e,
	0xe0, 0xc7, 0x71, 0xc5, 0xef, 0x25, 0xd4, 0x17, 0xf1, 0x0c, 0xa4, 0x1f, 0x42, 0x71, 0x19, 0xca,
	0x53, 0xf4, 0xd1, 0x5a, 0x8a, 0xee, 0xbe, 0xb8, 0x38, 0xdc, 0xf1, 0xa6, 0x7c, 0xa9, 0xb0, 0xea,
	0x00, 0x0e, 0x92, 0xa3, 0xf0, 0x32, 0xea, 0x57, 0x74, 0x3a, 0x5e, 0x51, 0xc7, 0x15, 0xb5, 0x7e,
	0x8c, 0xbe, 0x8a, 0x4f, 0x09, 0xfb, 0x7f, 0x95, 0x7a, 0x1a, 0x1d, 0x96, 0x20, 0xbe, 0x9c, 0xc3,
	0x98, 0x4c, 0x47, 0x09, 0xe5, 0x05, 0x6e, 0x81, 0x46, 0x76, 0xb4, 0xb2, 0x96, 0xc9, 0x1c, 0x97,
	0x37, 0x96, 0xa2, 0x0a, 0xe4, 0xcd, 0xf9, 0x4c, 0xe3, 0x54, 0x94, 0x50, 0x3a, 0xb6, 0x4c, 0xa9,
	0xd2, 0x2d, 0x9c, 0x33, 0xe7, 0xb3, 0xbe, 0x61, 0x9f, 0x7a, 0xb7, 0xe8, 0x3e, 0x20, 0x8e, 0xb4,
	0xd8, 0x88, 0x38, 0x01, 0x76, 0x53, 0x60, 0x39, 0x47, 0x97, 0x1b, 0x7c, 0xb4, 0xfa, 0x18, 0x76,
	0xe2, 0xef, 0x8d, 0xa2, 0xf7, 0x61, 0x8b, 0x2b, 0x4b, 0x57, 0x54, 0x10, 0xa4, 0x87, 0x25, 0x5e,
	0xfd, 0x57, 0x89, 0x3e, 0x50, 0x51, 0xe3, 0xab, 0x9d, 0x30, 0xf4, 0x0e, 0xa4, 0xa9, 0x4d, 0x0c,
	0x4f, 0xb3, 0x6b, 0xd7, 0x9e, 0x00, 0x86, 0x76, 0x4d, 0xea, 0x25, 0x76, 0x0d, 0xaa, 0xf9, 0x4d,
	0x48, 0x0b, 0xaf, 0xfd, 0x6b, 0xbc, 0x16, 0xf5, 0x7f, 0x15, 0x7d, 0x63, 0xa1, 0xf2, 0xe5, 0x0b,
	0x8e, 0x8f, 0xbe, 0x7a, 0xdd, 0x6c, 0xc4, 0xe7, 0xfe, 0x6d, 0x37, 0x58, 0xde, 0xc1, 0xe7, 0x1c,
	0x95, 0xa0, 0xd8, 0x6f, 0xf6, 0xb4, 0x1e, 0xee, 0x3e, 0x7d, 0xa6, 0xd5, 0x9b, 0xfd, 0x93, 0x6e,
	0x47, 0xeb, 0x3f, 0xeb, 0xb5, 0xb4, 0x4e, 0xb7, 0xd3, 0xca, 0x6f, 0xa0, 0x32, 0xec, 0x2f, 0xb7,
	0xb7, 0x3a, 0xf5, 0xc6, 0xe3, 0x56, 0x5e, 0x41, 0x47, 0x70, 0xb0, 0x1c, 0xf1, 0xf0, 0xe4, 0x54,
	0x40, 0x36, 0x6b, 0xbf, 0xa6, 0x60, 0xdb, 0x8f, 0x8d, 0xbe, 0x8e, 0x7e, 0x44, 0x9a, 0x0e, 0xd1,
	0x19, 0x41, 0x47, 0x89, 0xeb, 0xd6, 0x7f, 0x1b, 0x45, 0x75, 0xc5, 0x46, 0x6e, 0xd3, 0xe7, 0xea,
	0x46, 0x9c, 0xfe, 0x0b, 0x7b, 0xf8, 0x4a, 0xe9, 0xc7, 0x51, 0x7a, 0xb9, 0x65, 0xd0, 0x5b, 0xeb,
	0x2c, 0x53, 0x1e, 0xa4, 0xb2, 0xd6, 0xb6, 0x92, 0xa1, 0xbe, 0x85, 0xdb, 0x31, 0x55, 0xd1, 0xbd,
	0x95, 0xdb, 0x80, 0x07, 0x39, 0x5e, 0x3d, 0x17, 0x22, 0x42, 0xa3, 0xf8, 0xc7, 0x65, 0x49, 0xf9,
	0xf3, 0xb2, 0xa4, 0xfc, 0x75, 0x59, 0x52, 0x7e, 0xfb, 0xbb, 0xb4, 0xf1, 0xe5, 0xf6, 0x48, 0x9f,
	0x8a, 0xdf, 0x92, 0x83, 0x8c, 0xf8, 0xf3, 0xee, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x45, 0x58,
	0x93, 0x22, 0x87, 0x0a, 0x00, 0x00,
}
