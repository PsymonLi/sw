// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcp_proxy.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TcpProxyActionType int32

const (
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_NONE    TcpProxyActionType = 0
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_ENABLE  TcpProxyActionType = 1
	TcpProxyActionType_TCP_PROXY_ACTION_TYPE_DISABLE TcpProxyActionType = 2
)

var TcpProxyActionType_name = map[int32]string{
	0: "TCP_PROXY_ACTION_TYPE_NONE",
	1: "TCP_PROXY_ACTION_TYPE_ENABLE",
	2: "TCP_PROXY_ACTION_TYPE_DISABLE",
}
var TcpProxyActionType_value = map[string]int32{
	"TCP_PROXY_ACTION_TYPE_NONE":    0,
	"TCP_PROXY_ACTION_TYPE_ENABLE":  1,
	"TCP_PROXY_ACTION_TYPE_DISABLE": 2,
}

func (x TcpProxyActionType) String() string {
	return proto.EnumName(TcpProxyActionType_name, int32(x))
}
func (TcpProxyActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{0} }

type TlsProxySide int32

const (
	TlsProxySide_TLS_PROXY_SIDE_NONE   TlsProxySide = 0
	TlsProxySide_TLS_PROXY_SIDE_CLIENT TlsProxySide = 1
	TlsProxySide_TLS_PROXY_SIDE_SERVER TlsProxySide = 2
)

var TlsProxySide_name = map[int32]string{
	0: "TLS_PROXY_SIDE_NONE",
	1: "TLS_PROXY_SIDE_CLIENT",
	2: "TLS_PROXY_SIDE_SERVER",
}
var TlsProxySide_value = map[string]int32{
	"TLS_PROXY_SIDE_NONE":   0,
	"TLS_PROXY_SIDE_CLIENT": 1,
	"TLS_PROXY_SIDE_SERVER": 2,
}

func (x TlsProxySide) String() string {
	return proto.EnumName(TlsProxySide_name, int32(x))
}
func (TlsProxySide) EnumDescriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{1} }

type TcpProxySessionFilter struct {
	SrcIp    *IPAddress `protobuf:"bytes,1,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp    *IPAddress `protobuf:"bytes,2,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	SrcPort  uint32     `protobuf:"varint,3,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort  uint32     `protobuf:"varint,4,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	MatchAll bool       `protobuf:"varint,5,opt,name=match_all,json=matchAll,proto3" json:"match_all,omitempty"`
}

func (m *TcpProxySessionFilter) Reset()                    { *m = TcpProxySessionFilter{} }
func (m *TcpProxySessionFilter) String() string            { return proto.CompactTextString(m) }
func (*TcpProxySessionFilter) ProtoMessage()               {}
func (*TcpProxySessionFilter) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{0} }

func (m *TcpProxySessionFilter) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *TcpProxySessionFilter) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *TcpProxySessionFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TcpProxySessionFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TcpProxySessionFilter) GetMatchAll() bool {
	if m != nil {
		return m.MatchAll
	}
	return false
}

type TcpProxySessionGetRequest struct {
	SessionFilter *TcpProxySessionFilter `protobuf:"bytes,1,opt,name=session_filter,json=sessionFilter" json:"session_filter,omitempty"`
}

func (m *TcpProxySessionGetRequest) Reset()         { *m = TcpProxySessionGetRequest{} }
func (m *TcpProxySessionGetRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetRequest) ProtoMessage()    {}
func (*TcpProxySessionGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{1}
}

func (m *TcpProxySessionGetRequest) GetSessionFilter() *TcpProxySessionFilter {
	if m != nil {
		return m.SessionFilter
	}
	return nil
}

type TcpproxyFlow struct {
	Qid1     uint64     `protobuf:"varint,1,opt,name=qid1,proto3" json:"qid1,omitempty"`
	Qid2     uint64     `protobuf:"varint,2,opt,name=qid2,proto3" json:"qid2,omitempty"`
	SrcIp    *IPAddress `protobuf:"bytes,3,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp    *IPAddress `protobuf:"bytes,4,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	Sport    uint32     `protobuf:"varint,5,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport    uint32     `protobuf:"varint,6,opt,name=dport,proto3" json:"dport,omitempty"`
	FlowType uint32     `protobuf:"varint,7,opt,name=flow_type,json=flowType,proto3" json:"flow_type,omitempty"`
}

func (m *TcpproxyFlow) Reset()                    { *m = TcpproxyFlow{} }
func (m *TcpproxyFlow) String() string            { return proto.CompactTextString(m) }
func (*TcpproxyFlow) ProtoMessage()               {}
func (*TcpproxyFlow) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{2} }

func (m *TcpproxyFlow) GetQid1() uint64 {
	if m != nil {
		return m.Qid1
	}
	return 0
}

func (m *TcpproxyFlow) GetQid2() uint64 {
	if m != nil {
		return m.Qid2
	}
	return 0
}

func (m *TcpproxyFlow) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *TcpproxyFlow) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *TcpproxyFlow) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *TcpproxyFlow) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

func (m *TcpproxyFlow) GetFlowType() uint32 {
	if m != nil {
		return m.FlowType
	}
	return 0
}

// TcpProxySessionGetRequestMsg is batched get request
type TcpProxySessionGetRequestMsg struct {
	Request []*TcpProxySessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxySessionGetRequestMsg) Reset()         { *m = TcpProxySessionGetRequestMsg{} }
func (m *TcpProxySessionGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetRequestMsg) ProtoMessage()    {}
func (*TcpProxySessionGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{3}
}

func (m *TcpProxySessionGetRequestMsg) GetRequest() []*TcpProxySessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type TcpProxySessionGetResponse struct {
	ApiStatus    ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	TcpproxyFlow *TcpproxyFlow `protobuf:"bytes,2,opt,name=tcpproxy_flow,json=tcpproxyFlow" json:"tcpproxy_flow,omitempty"`
}

func (m *TcpProxySessionGetResponse) Reset()         { *m = TcpProxySessionGetResponse{} }
func (m *TcpProxySessionGetResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetResponse) ProtoMessage()    {}
func (*TcpProxySessionGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{4}
}

func (m *TcpProxySessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxySessionGetResponse) GetTcpproxyFlow() *TcpproxyFlow {
	if m != nil {
		return m.TcpproxyFlow
	}
	return nil
}

type TcpProxySessionGetResponseMsg struct {
	ApiStatus ApiStatus                     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Response  []*TcpProxySessionGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxySessionGetResponseMsg) Reset()         { *m = TcpProxySessionGetResponseMsg{} }
func (m *TcpProxySessionGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetResponseMsg) ProtoMessage()    {}
func (*TcpProxySessionGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{5}
}

func (m *TcpProxySessionGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxySessionGetResponseMsg) GetResponse() []*TcpProxySessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type TlsProxyECDSAKey struct {
	SignKeyIdx uint32 `protobuf:"varint,1,opt,name=sign_key_idx,json=signKeyIdx,proto3" json:"sign_key_idx,omitempty"`
}

func (m *TlsProxyECDSAKey) Reset()                    { *m = TlsProxyECDSAKey{} }
func (m *TlsProxyECDSAKey) String() string            { return proto.CompactTextString(m) }
func (*TlsProxyECDSAKey) ProtoMessage()               {}
func (*TlsProxyECDSAKey) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{6} }

func (m *TlsProxyECDSAKey) GetSignKeyIdx() uint32 {
	if m != nil {
		return m.SignKeyIdx
	}
	return 0
}

type TlsProxyRSAKey struct {
	SignKeyIdx    uint32 `protobuf:"varint,1,opt,name=sign_key_idx,json=signKeyIdx,proto3" json:"sign_key_idx,omitempty"`
	DecryptKeyIdx uint32 `protobuf:"varint,2,opt,name=decrypt_key_idx,json=decryptKeyIdx,proto3" json:"decrypt_key_idx,omitempty"`
}

func (m *TlsProxyRSAKey) Reset()                    { *m = TlsProxyRSAKey{} }
func (m *TlsProxyRSAKey) String() string            { return proto.CompactTextString(m) }
func (*TlsProxyRSAKey) ProtoMessage()               {}
func (*TlsProxyRSAKey) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{7} }

func (m *TlsProxyRSAKey) GetSignKeyIdx() uint32 {
	if m != nil {
		return m.SignKeyIdx
	}
	return 0
}

func (m *TlsProxyRSAKey) GetDecryptKeyIdx() uint32 {
	if m != nil {
		return m.DecryptKeyIdx
	}
	return 0
}

type TlsProxyAction struct {
	AsymKeyType  CryptoAsymKeyType `protobuf:"varint,1,opt,name=asym_key_type,json=asymKeyType,proto3,enum=types.CryptoAsymKeyType" json:"asym_key_type,omitempty"`
	CertId       uint32            `protobuf:"varint,2,opt,name=cert_id,json=certId,proto3" json:"cert_id,omitempty"`
	TrustRootId  uint32            `protobuf:"varint,3,opt,name=trust_root_id,json=trustRootId,proto3" json:"trust_root_id,omitempty"`
	Ciphers      string            `protobuf:"bytes,4,opt,name=ciphers,proto3" json:"ciphers,omitempty"`
	TlsProxySide TlsProxySide      `protobuf:"varint,5,opt,name=tls_proxy_side,json=tlsProxySide,proto3,enum=tcp_proxy.TlsProxySide" json:"tls_proxy_side,omitempty"`
	// Types that are valid to be assigned to Keys:
	//	*TlsProxyAction_EcdsaKey
	//	*TlsProxyAction_RsaKey
	Keys isTlsProxyAction_Keys `protobuf_oneof:"Keys"`
}

func (m *TlsProxyAction) Reset()                    { *m = TlsProxyAction{} }
func (m *TlsProxyAction) String() string            { return proto.CompactTextString(m) }
func (*TlsProxyAction) ProtoMessage()               {}
func (*TlsProxyAction) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{8} }

type isTlsProxyAction_Keys interface {
	isTlsProxyAction_Keys()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsProxyAction_EcdsaKey struct {
	EcdsaKey *TlsProxyECDSAKey `protobuf:"bytes,6,opt,name=ecdsa_key,json=ecdsaKey,oneof"`
}
type TlsProxyAction_RsaKey struct {
	RsaKey *TlsProxyRSAKey `protobuf:"bytes,7,opt,name=rsa_key,json=rsaKey,oneof"`
}

func (*TlsProxyAction_EcdsaKey) isTlsProxyAction_Keys() {}
func (*TlsProxyAction_RsaKey) isTlsProxyAction_Keys()   {}

func (m *TlsProxyAction) GetKeys() isTlsProxyAction_Keys {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *TlsProxyAction) GetAsymKeyType() CryptoAsymKeyType {
	if m != nil {
		return m.AsymKeyType
	}
	return CryptoAsymKeyType_CRYPTO_ASYM_KEY_TYPE_ECDSA
}

func (m *TlsProxyAction) GetCertId() uint32 {
	if m != nil {
		return m.CertId
	}
	return 0
}

func (m *TlsProxyAction) GetTrustRootId() uint32 {
	if m != nil {
		return m.TrustRootId
	}
	return 0
}

func (m *TlsProxyAction) GetCiphers() string {
	if m != nil {
		return m.Ciphers
	}
	return ""
}

func (m *TlsProxyAction) GetTlsProxySide() TlsProxySide {
	if m != nil {
		return m.TlsProxySide
	}
	return TlsProxySide_TLS_PROXY_SIDE_NONE
}

func (m *TlsProxyAction) GetEcdsaKey() *TlsProxyECDSAKey {
	if x, ok := m.GetKeys().(*TlsProxyAction_EcdsaKey); ok {
		return x.EcdsaKey
	}
	return nil
}

func (m *TlsProxyAction) GetRsaKey() *TlsProxyRSAKey {
	if x, ok := m.GetKeys().(*TlsProxyAction_RsaKey); ok {
		return x.RsaKey
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TlsProxyAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TlsProxyAction_OneofMarshaler, _TlsProxyAction_OneofUnmarshaler, _TlsProxyAction_OneofSizer, []interface{}{
		(*TlsProxyAction_EcdsaKey)(nil),
		(*TlsProxyAction_RsaKey)(nil),
	}
}

func _TlsProxyAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TlsProxyAction)
	// Keys
	switch x := m.Keys.(type) {
	case *TlsProxyAction_EcdsaKey:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EcdsaKey); err != nil {
			return err
		}
	case *TlsProxyAction_RsaKey:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RsaKey); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TlsProxyAction.Keys has unexpected type %T", x)
	}
	return nil
}

func _TlsProxyAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TlsProxyAction)
	switch tag {
	case 6: // Keys.ecdsa_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsProxyECDSAKey)
		err := b.DecodeMessage(msg)
		m.Keys = &TlsProxyAction_EcdsaKey{msg}
		return true, err
	case 7: // Keys.rsa_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsProxyRSAKey)
		err := b.DecodeMessage(msg)
		m.Keys = &TlsProxyAction_RsaKey{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TlsProxyAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TlsProxyAction)
	// Keys
	switch x := m.Keys.(type) {
	case *TlsProxyAction_EcdsaKey:
		s := proto.Size(x.EcdsaKey)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TlsProxyAction_RsaKey:
		s := proto.Size(x.RsaKey)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TcpProxyAction struct {
	TcpProxyActionType TcpProxyActionType `protobuf:"varint,1,opt,name=tcp_proxy_action_type,json=tcpProxyActionType,proto3,enum=tcp_proxy.TcpProxyActionType" json:"tcp_proxy_action_type,omitempty"`
	ProxyType          ProxyType          `protobuf:"varint,2,opt,name=proxy_type,json=proxyType,proto3,enum=types.ProxyType" json:"proxy_type,omitempty"`
	// Types that are valid to be assigned to ProxyConfig:
	//	*TcpProxyAction_Tls
	ProxyConfig isTcpProxyAction_ProxyConfig `protobuf_oneof:"proxy_config"`
}

func (m *TcpProxyAction) Reset()                    { *m = TcpProxyAction{} }
func (m *TcpProxyAction) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyAction) ProtoMessage()               {}
func (*TcpProxyAction) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{9} }

type isTcpProxyAction_ProxyConfig interface {
	isTcpProxyAction_ProxyConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TcpProxyAction_Tls struct {
	Tls *TlsProxyAction `protobuf:"bytes,3,opt,name=tls,oneof"`
}

func (*TcpProxyAction_Tls) isTcpProxyAction_ProxyConfig() {}

func (m *TcpProxyAction) GetProxyConfig() isTcpProxyAction_ProxyConfig {
	if m != nil {
		return m.ProxyConfig
	}
	return nil
}

func (m *TcpProxyAction) GetTcpProxyActionType() TcpProxyActionType {
	if m != nil {
		return m.TcpProxyActionType
	}
	return TcpProxyActionType_TCP_PROXY_ACTION_TYPE_NONE
}

func (m *TcpProxyAction) GetProxyType() ProxyType {
	if m != nil {
		return m.ProxyType
	}
	return ProxyType_PROXY_TYPE_NONE
}

func (m *TcpProxyAction) GetTls() *TlsProxyAction {
	if x, ok := m.GetProxyConfig().(*TcpProxyAction_Tls); ok {
		return x.Tls
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TcpProxyAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TcpProxyAction_OneofMarshaler, _TcpProxyAction_OneofUnmarshaler, _TcpProxyAction_OneofSizer, []interface{}{
		(*TcpProxyAction_Tls)(nil),
	}
}

func _TcpProxyAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TcpProxyAction)
	// proxy_config
	switch x := m.ProxyConfig.(type) {
	case *TcpProxyAction_Tls:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tls); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TcpProxyAction.ProxyConfig has unexpected type %T", x)
	}
	return nil
}

func _TcpProxyAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TcpProxyAction)
	switch tag {
	case 3: // proxy_config.tls
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsProxyAction)
		err := b.DecodeMessage(msg)
		m.ProxyConfig = &TcpProxyAction_Tls{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TcpProxyAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TcpProxyAction)
	// proxy_config
	switch x := m.ProxyConfig.(type) {
	case *TcpProxyAction_Tls:
		s := proto.Size(x.Tls)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TcpProxyRuleMatchSpec struct {
	RuleId         uint64          `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Match          *RuleMatch      `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
	TcpProxyAction *TcpProxyAction `protobuf:"bytes,3,opt,name=tcp_proxy_action,json=tcpProxyAction" json:"tcp_proxy_action,omitempty"`
}

func (m *TcpProxyRuleMatchSpec) Reset()                    { *m = TcpProxyRuleMatchSpec{} }
func (m *TcpProxyRuleMatchSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleMatchSpec) ProtoMessage()               {}
func (*TcpProxyRuleMatchSpec) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{10} }

func (m *TcpProxyRuleMatchSpec) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *TcpProxyRuleMatchSpec) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *TcpProxyRuleMatchSpec) GetTcpProxyAction() *TcpProxyAction {
	if m != nil {
		return m.TcpProxyAction
	}
	return nil
}

// TcpProxyRuleSpec is the user intent for the TcpProxy rule
type TcpProxyRuleSpec struct {
	KeyOrHandle  *TcpProxyRuleKeyHandle   `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle            `protobuf:"bytes,2,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	Rules        []*TcpProxyRuleMatchSpec `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *TcpProxyRuleSpec) Reset()                    { *m = TcpProxyRuleSpec{} }
func (m *TcpProxyRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleSpec) ProtoMessage()               {}
func (*TcpProxyRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{11} }

func (m *TcpProxyRuleSpec) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *TcpProxyRuleSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *TcpProxyRuleSpec) GetRules() []*TcpProxyRuleMatchSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// TcpProxyRuleRequestMsg is the batched add or modify of NAT rule request
type TcpProxyRuleRequestMsg struct {
	Request []*TcpProxyRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleRequestMsg) Reset()                    { *m = TcpProxyRuleRequestMsg{} }
func (m *TcpProxyRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleRequestMsg) ProtoMessage()               {}
func (*TcpProxyRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{12} }

func (m *TcpProxyRuleRequestMsg) GetRequest() []*TcpProxyRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyRuleStatus reflects the current operational status of the TcpProxy rule
type TcpProxyRuleStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *TcpProxyRuleStatus) Reset()                    { *m = TcpProxyRuleStatus{} }
func (m *TcpProxyRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleStatus) ProtoMessage()               {}
func (*TcpProxyRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{13} }

func (m *TcpProxyRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// TcpProxyRuleResponse is the response to TcpProxyRuleSpec
type TcpProxyRuleResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *TcpProxyRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *TcpProxyRuleResponse) Reset()                    { *m = TcpProxyRuleResponse{} }
func (m *TcpProxyRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleResponse) ProtoMessage()               {}
func (*TcpProxyRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{14} }

func (m *TcpProxyRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyRuleResponse) GetStatus() *TcpProxyRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// TcpProxyRuleResponseMsg is batched response to TcpProxyRuleRequestMsg
type TcpProxyRuleResponseMsg struct {
	Response []*TcpProxyRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleResponseMsg) Reset()                    { *m = TcpProxyRuleResponseMsg{} }
func (m *TcpProxyRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleResponseMsg) ProtoMessage()               {}
func (*TcpProxyRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{15} }

func (m *TcpProxyRuleResponseMsg) GetResponse() []*TcpProxyRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyRuleDeleteRequest is used to delete a policy rule
type TcpProxyRuleDeleteRequest struct {
	KeyOrHandle *TcpProxyRuleKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyRuleDeleteRequest) Reset()         { *m = TcpProxyRuleDeleteRequest{} }
func (m *TcpProxyRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteRequest) ProtoMessage()    {}
func (*TcpProxyRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{16}
}

func (m *TcpProxyRuleDeleteRequest) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyRuleDeleteRequestMsg is used to delete a batch of tcp_proxy rules
type TcpProxyRuleDeleteRequestMsg struct {
	Request []*TcpProxyRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleDeleteRequestMsg) Reset()         { *m = TcpProxyRuleDeleteRequestMsg{} }
func (m *TcpProxyRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteRequestMsg) ProtoMessage()    {}
func (*TcpProxyRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{17}
}

func (m *TcpProxyRuleDeleteRequestMsg) GetRequest() []*TcpProxyRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyRuleDeleteResponse is response to TcpProxyRuleDeleteRequest
type TcpProxyRuleDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *TcpProxyRuleDeleteResponse) Reset()         { *m = TcpProxyRuleDeleteResponse{} }
func (m *TcpProxyRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteResponse) ProtoMessage()    {}
func (*TcpProxyRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{18}
}

func (m *TcpProxyRuleDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// TcpProxyRuleDeleteResponseMsg is batched response to TcpProxyRuleDeleteRequestMsg
type TcpProxyRuleDeleteResponseMsg struct {
	Response []*TcpProxyRuleDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleDeleteResponseMsg) Reset()         { *m = TcpProxyRuleDeleteResponseMsg{} }
func (m *TcpProxyRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleDeleteResponseMsg) ProtoMessage()    {}
func (*TcpProxyRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{19}
}

func (m *TcpProxyRuleDeleteResponseMsg) GetResponse() []*TcpProxyRuleDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyRuleGetRequest is used to get information about a tcp_proxy rule
type TcpProxyRuleGetRequest struct {
	KeyOrHandle *TcpProxyRuleKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyRuleGetRequest) Reset()                    { *m = TcpProxyRuleGetRequest{} }
func (m *TcpProxyRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetRequest) ProtoMessage()               {}
func (*TcpProxyRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{20} }

func (m *TcpProxyRuleGetRequest) GetKeyOrHandle() *TcpProxyRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyRuleGetRequestMsg is batched GET requests for tcp_proxy rule
type TcpProxyRuleGetRequestMsg struct {
	Request []*TcpProxyRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyRuleGetRequestMsg) Reset()         { *m = TcpProxyRuleGetRequestMsg{} }
func (m *TcpProxyRuleGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetRequestMsg) ProtoMessage()    {}
func (*TcpProxyRuleGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{21}
}

func (m *TcpProxyRuleGetRequestMsg) GetRequest() []*TcpProxyRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// per rule stats
type TcpProxyRuleEntryStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,2,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *TcpProxyRuleEntryStats) Reset()                    { *m = TcpProxyRuleEntryStats{} }
func (m *TcpProxyRuleEntryStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleEntryStats) ProtoMessage()               {}
func (*TcpProxyRuleEntryStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{22} }

func (m *TcpProxyRuleEntryStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *TcpProxyRuleEntryStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// per policy stats
type TcpProxyRuleStats struct {
	Stats []*TcpProxyRuleEntryStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *TcpProxyRuleStats) Reset()                    { *m = TcpProxyRuleStats{} }
func (m *TcpProxyRuleStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleStats) ProtoMessage()               {}
func (*TcpProxyRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{23} }

func (m *TcpProxyRuleStats) GetStats() []*TcpProxyRuleEntryStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpProxyRuleGetResponse catpures all information about TcpProxy policy
type TcpProxyRuleGetResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *TcpProxyRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *TcpProxyRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *TcpProxyRuleStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *TcpProxyRuleGetResponse) Reset()                    { *m = TcpProxyRuleGetResponse{} }
func (m *TcpProxyRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetResponse) ProtoMessage()               {}
func (*TcpProxyRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{24} }

func (m *TcpProxyRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyRuleGetResponse) GetSpec() *TcpProxyRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TcpProxyRuleGetResponse) GetStatus() *TcpProxyRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TcpProxyRuleGetResponse) GetStats() *TcpProxyRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpProxyRuleGetResponseMsg is batched response to TcpProxyRuleGetRequestMsg
type TcpProxyRuleGetResponseMsg struct {
	Response []*TcpProxyRuleGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyRuleGetResponseMsg) Reset()         { *m = TcpProxyRuleGetResponseMsg{} }
func (m *TcpProxyRuleGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyRuleGetResponseMsg) ProtoMessage()    {}
func (*TcpProxyRuleGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{25}
}

func (m *TcpProxyRuleGetResponseMsg) GetResponse() []*TcpProxyRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyCbKeyHandle is used to operate on a tcp_cb either by its key or handle
type TcpProxyCbKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*TcpProxyCbKeyHandle_TcpcbId
	//	*TcpProxyCbKeyHandle_TcpcbHandle
	KeyOrHandle isTcpProxyCbKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *TcpProxyCbKeyHandle) Reset()                    { *m = TcpProxyCbKeyHandle{} }
func (m *TcpProxyCbKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbKeyHandle) ProtoMessage()               {}
func (*TcpProxyCbKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{26} }

type isTcpProxyCbKeyHandle_KeyOrHandle interface {
	isTcpProxyCbKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TcpProxyCbKeyHandle_TcpcbId struct {
	TcpcbId uint32 `protobuf:"varint,1,opt,name=tcpcb_id,json=tcpcbId,proto3,oneof"`
}
type TcpProxyCbKeyHandle_TcpcbHandle struct {
	TcpcbHandle uint64 `protobuf:"fixed64,2,opt,name=tcpcb_handle,json=tcpcbHandle,proto3,oneof"`
}

func (*TcpProxyCbKeyHandle_TcpcbId) isTcpProxyCbKeyHandle_KeyOrHandle()     {}
func (*TcpProxyCbKeyHandle_TcpcbHandle) isTcpProxyCbKeyHandle_KeyOrHandle() {}

func (m *TcpProxyCbKeyHandle) GetKeyOrHandle() isTcpProxyCbKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *TcpProxyCbKeyHandle) GetTcpcbId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*TcpProxyCbKeyHandle_TcpcbId); ok {
		return x.TcpcbId
	}
	return 0
}

func (m *TcpProxyCbKeyHandle) GetTcpcbHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*TcpProxyCbKeyHandle_TcpcbHandle); ok {
		return x.TcpcbHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TcpProxyCbKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TcpProxyCbKeyHandle_OneofMarshaler, _TcpProxyCbKeyHandle_OneofUnmarshaler, _TcpProxyCbKeyHandle_OneofSizer, []interface{}{
		(*TcpProxyCbKeyHandle_TcpcbId)(nil),
		(*TcpProxyCbKeyHandle_TcpcbHandle)(nil),
	}
}

func _TcpProxyCbKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TcpProxyCbKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *TcpProxyCbKeyHandle_TcpcbId:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TcpcbId))
	case *TcpProxyCbKeyHandle_TcpcbHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.TcpcbHandle))
	case nil:
	default:
		return fmt.Errorf("TcpProxyCbKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _TcpProxyCbKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TcpProxyCbKeyHandle)
	switch tag {
	case 1: // key_or_handle.tcpcb_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &TcpProxyCbKeyHandle_TcpcbId{uint32(x)}
		return true, err
	case 2: // key_or_handle.tcpcb_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &TcpProxyCbKeyHandle_TcpcbHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _TcpProxyCbKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TcpProxyCbKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *TcpProxyCbKeyHandle_TcpcbId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TcpcbId))
	case *TcpProxyCbKeyHandle_TcpcbHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TcpProxyCbSpec captures all the tcp_cb level configuration
type TcpProxyCbSpec struct {
	KeyOrHandle        *TcpProxyCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	RcvNxt             uint32               `protobuf:"varint,2,opt,name=rcv_nxt,json=rcvNxt,proto3" json:"rcv_nxt,omitempty"`
	SndNxt             uint32               `protobuf:"varint,3,opt,name=snd_nxt,json=sndNxt,proto3" json:"snd_nxt,omitempty"`
	SndUna             uint32               `protobuf:"varint,4,opt,name=snd_una,json=sndUna,proto3" json:"snd_una,omitempty"`
	RcvTsval           uint32               `protobuf:"varint,5,opt,name=rcv_tsval,json=rcvTsval,proto3" json:"rcv_tsval,omitempty"`
	TsRecent           uint32               `protobuf:"varint,6,opt,name=ts_recent,json=tsRecent,proto3" json:"ts_recent,omitempty"`
	SerqBase           uint64               `protobuf:"fixed64,7,opt,name=serq_base,json=serqBase,proto3" json:"serq_base,omitempty"`
	DebugDol           uint32               `protobuf:"varint,8,opt,name=debug_dol,json=debugDol,proto3" json:"debug_dol,omitempty"`
	SesqBase           uint64               `protobuf:"fixed64,9,opt,name=sesq_base,json=sesqBase,proto3" json:"sesq_base,omitempty"`
	SesqPi             uint32               `protobuf:"varint,10,opt,name=sesq_pi,json=sesqPi,proto3" json:"sesq_pi,omitempty"`
	SesqCi             uint32               `protobuf:"varint,11,opt,name=sesq_ci,json=sesqCi,proto3" json:"sesq_ci,omitempty"`
	SndWnd             uint32               `protobuf:"varint,12,opt,name=snd_wnd,json=sndWnd,proto3" json:"snd_wnd,omitempty"`
	SndCwnd            uint32               `protobuf:"varint,13,opt,name=snd_cwnd,json=sndCwnd,proto3" json:"snd_cwnd,omitempty"`
	RcvMss             uint32               `protobuf:"varint,14,opt,name=rcv_mss,json=rcvMss,proto3" json:"rcv_mss,omitempty"`
	SourcePort         uint32               `protobuf:"varint,15,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestPort           uint32               `protobuf:"varint,16,opt,name=dest_port,json=destPort,proto3" json:"dest_port,omitempty"`
	HeaderTemplate     []byte               `protobuf:"bytes,17,opt,name=header_template,json=headerTemplate,proto3" json:"header_template,omitempty"`
	State              uint32               `protobuf:"varint,18,opt,name=state,proto3" json:"state,omitempty"`
	SourceLif          uint32               `protobuf:"varint,19,opt,name=source_lif,json=sourceLif,proto3" json:"source_lif,omitempty"`
	AsesqBase          uint64               `protobuf:"fixed64,20,opt,name=asesq_base,json=asesqBase,proto3" json:"asesq_base,omitempty"`
	AsesqPi            uint32               `protobuf:"varint,21,opt,name=asesq_pi,json=asesqPi,proto3" json:"asesq_pi,omitempty"`
	AsesqCi            uint32               `protobuf:"varint,22,opt,name=asesq_ci,json=asesqCi,proto3" json:"asesq_ci,omitempty"`
	DebugDolTx         uint32               `protobuf:"varint,23,opt,name=debug_dol_tx,json=debugDolTx,proto3" json:"debug_dol_tx,omitempty"`
	HeaderLen          uint32               `protobuf:"varint,24,opt,name=header_len,json=headerLen,proto3" json:"header_len,omitempty"`
	PendingAckSend     bool                 `protobuf:"varint,25,opt,name=pending_ack_send,json=pendingAckSend,proto3" json:"pending_ack_send,omitempty"`
	L7ProxyType        AppRedirType         `protobuf:"varint,26,opt,name=l7_proxy_type,json=l7ProxyType,proto3,enum=types.AppRedirType" json:"l7_proxy_type,omitempty"`
	SesqRetxCi         uint32               `protobuf:"varint,27,opt,name=sesq_retx_ci,json=sesqRetxCi,proto3" json:"sesq_retx_ci,omitempty"`
	RetxSndUna         uint64               `protobuf:"varint,28,opt,name=retx_snd_una,json=retxSndUna,proto3" json:"retx_snd_una,omitempty"`
	RxTs               uint64               `protobuf:"varint,29,opt,name=rx_ts,json=rxTs,proto3" json:"rx_ts,omitempty"`
	Rto                uint64               `protobuf:"varint,30,opt,name=rto,proto3" json:"rto,omitempty"`
	SndCwndCnt         uint32               `protobuf:"varint,31,opt,name=snd_cwnd_cnt,json=sndCwndCnt,proto3" json:"snd_cwnd_cnt,omitempty"`
	DebugDolTblsetaddr uint32               `protobuf:"varint,32,opt,name=debug_dol_tblsetaddr,json=debugDolTblsetaddr,proto3" json:"debug_dol_tblsetaddr,omitempty"`
	SerqPi             uint32               `protobuf:"varint,33,opt,name=serq_pi,json=serqPi,proto3" json:"serq_pi,omitempty"`
	PredFlags          uint32               `protobuf:"varint,34,opt,name=pred_flags,json=predFlags,proto3" json:"pred_flags,omitempty"`
	OtherQid           uint32               `protobuf:"varint,35,opt,name=other_qid,json=otherQid,proto3" json:"other_qid,omitempty"`
	PacketsOut         uint32               `protobuf:"varint,36,opt,name=packets_out,json=packetsOut,proto3" json:"packets_out,omitempty"`
	RtoPi              uint32               `protobuf:"varint,37,opt,name=rto_pi,json=rtoPi,proto3" json:"rto_pi,omitempty"`
	RetxTimerCi        uint32               `protobuf:"varint,38,opt,name=retx_timer_ci,json=retxTimerCi,proto3" json:"retx_timer_ci,omitempty"`
	RtoBackoff         uint32               `protobuf:"varint,39,opt,name=rto_backoff,json=rtoBackoff,proto3" json:"rto_backoff,omitempty"`
	CpuId              uint32               `protobuf:"varint,40,opt,name=cpu_id,json=cpuId,proto3" json:"cpu_id,omitempty"`
	SerqCi             uint32               `protobuf:"varint,41,opt,name=serq_ci,json=serqCi,proto3" json:"serq_ci,omitempty"`
	RcvWnd             uint32               `protobuf:"varint,42,opt,name=rcv_wnd,json=rcvWnd,proto3" json:"rcv_wnd,omitempty"`
	SndWscale          uint32               `protobuf:"varint,43,opt,name=snd_wscale,json=sndWscale,proto3" json:"snd_wscale,omitempty"`
	RcvWscale          uint32               `protobuf:"varint,44,opt,name=rcv_wscale,json=rcvWscale,proto3" json:"rcv_wscale,omitempty"`
	SesqTxCi           uint32               `protobuf:"varint,45,opt,name=sesq_tx_ci,json=sesqTxCi,proto3" json:"sesq_tx_ci,omitempty"`
}

func (m *TcpProxyCbSpec) Reset()                    { *m = TcpProxyCbSpec{} }
func (m *TcpProxyCbSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbSpec) ProtoMessage()               {}
func (*TcpProxyCbSpec) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{27} }

func (m *TcpProxyCbSpec) GetKeyOrHandle() *TcpProxyCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *TcpProxyCbSpec) GetRcvNxt() uint32 {
	if m != nil {
		return m.RcvNxt
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndNxt() uint32 {
	if m != nil {
		return m.SndNxt
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndUna() uint32 {
	if m != nil {
		return m.SndUna
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRcvTsval() uint32 {
	if m != nil {
		return m.RcvTsval
	}
	return 0
}

func (m *TcpProxyCbSpec) GetTsRecent() uint32 {
	if m != nil {
		return m.TsRecent
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSerqBase() uint64 {
	if m != nil {
		return m.SerqBase
	}
	return 0
}

func (m *TcpProxyCbSpec) GetDebugDol() uint32 {
	if m != nil {
		return m.DebugDol
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSesqBase() uint64 {
	if m != nil {
		return m.SesqBase
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSesqPi() uint32 {
	if m != nil {
		return m.SesqPi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSesqCi() uint32 {
	if m != nil {
		return m.SesqCi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndWnd() uint32 {
	if m != nil {
		return m.SndWnd
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndCwnd() uint32 {
	if m != nil {
		return m.SndCwnd
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRcvMss() uint32 {
	if m != nil {
		return m.RcvMss
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *TcpProxyCbSpec) GetDestPort() uint32 {
	if m != nil {
		return m.DestPort
	}
	return 0
}

func (m *TcpProxyCbSpec) GetHeaderTemplate() []byte {
	if m != nil {
		return m.HeaderTemplate
	}
	return nil
}

func (m *TcpProxyCbSpec) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSourceLif() uint32 {
	if m != nil {
		return m.SourceLif
	}
	return 0
}

func (m *TcpProxyCbSpec) GetAsesqBase() uint64 {
	if m != nil {
		return m.AsesqBase
	}
	return 0
}

func (m *TcpProxyCbSpec) GetAsesqPi() uint32 {
	if m != nil {
		return m.AsesqPi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetAsesqCi() uint32 {
	if m != nil {
		return m.AsesqCi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetDebugDolTx() uint32 {
	if m != nil {
		return m.DebugDolTx
	}
	return 0
}

func (m *TcpProxyCbSpec) GetHeaderLen() uint32 {
	if m != nil {
		return m.HeaderLen
	}
	return 0
}

func (m *TcpProxyCbSpec) GetPendingAckSend() bool {
	if m != nil {
		return m.PendingAckSend
	}
	return false
}

func (m *TcpProxyCbSpec) GetL7ProxyType() AppRedirType {
	if m != nil {
		return m.L7ProxyType
	}
	return AppRedirType_APP_REDIR_TYPE_NONE
}

func (m *TcpProxyCbSpec) GetSesqRetxCi() uint32 {
	if m != nil {
		return m.SesqRetxCi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRetxSndUna() uint64 {
	if m != nil {
		return m.RetxSndUna
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRxTs() uint64 {
	if m != nil {
		return m.RxTs
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRto() uint64 {
	if m != nil {
		return m.Rto
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndCwndCnt() uint32 {
	if m != nil {
		return m.SndCwndCnt
	}
	return 0
}

func (m *TcpProxyCbSpec) GetDebugDolTblsetaddr() uint32 {
	if m != nil {
		return m.DebugDolTblsetaddr
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSerqPi() uint32 {
	if m != nil {
		return m.SerqPi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetPredFlags() uint32 {
	if m != nil {
		return m.PredFlags
	}
	return 0
}

func (m *TcpProxyCbSpec) GetOtherQid() uint32 {
	if m != nil {
		return m.OtherQid
	}
	return 0
}

func (m *TcpProxyCbSpec) GetPacketsOut() uint32 {
	if m != nil {
		return m.PacketsOut
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRtoPi() uint32 {
	if m != nil {
		return m.RtoPi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRetxTimerCi() uint32 {
	if m != nil {
		return m.RetxTimerCi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRtoBackoff() uint32 {
	if m != nil {
		return m.RtoBackoff
	}
	return 0
}

func (m *TcpProxyCbSpec) GetCpuId() uint32 {
	if m != nil {
		return m.CpuId
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSerqCi() uint32 {
	if m != nil {
		return m.SerqCi
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRcvWnd() uint32 {
	if m != nil {
		return m.RcvWnd
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSndWscale() uint32 {
	if m != nil {
		return m.SndWscale
	}
	return 0
}

func (m *TcpProxyCbSpec) GetRcvWscale() uint32 {
	if m != nil {
		return m.RcvWscale
	}
	return 0
}

func (m *TcpProxyCbSpec) GetSesqTxCi() uint32 {
	if m != nil {
		return m.SesqTxCi
	}
	return 0
}

// TcpProxyCbRequestMsg is batched add or modify tcpcb request
type TcpProxyCbRequestMsg struct {
	Request []*TcpProxyCbSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyCbRequestMsg) Reset()                    { *m = TcpProxyCbRequestMsg{} }
func (m *TcpProxyCbRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbRequestMsg) ProtoMessage()               {}
func (*TcpProxyCbRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{28} }

func (m *TcpProxyCbRequestMsg) GetRequest() []*TcpProxyCbSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyCbStatus is the operational status of a given tcpcb
type TcpProxyCbStatus struct {
	TcpcbHandle uint64 `protobuf:"fixed64,1,opt,name=tcpcb_handle,json=tcpcbHandle,proto3" json:"tcpcb_handle,omitempty"`
}

func (m *TcpProxyCbStatus) Reset()                    { *m = TcpProxyCbStatus{} }
func (m *TcpProxyCbStatus) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbStatus) ProtoMessage()               {}
func (*TcpProxyCbStatus) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{29} }

func (m *TcpProxyCbStatus) GetTcpcbHandle() uint64 {
	if m != nil {
		return m.TcpcbHandle
	}
	return 0
}

// TcpProxyCbResponse is response to TcpProxyCbSpec
type TcpProxyCbResponse struct {
	ApiStatus   ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	TcpcbStatus *TcpProxyCbStatus `protobuf:"bytes,2,opt,name=tcpcb_status,json=tcpcbStatus" json:"tcpcb_status,omitempty"`
}

func (m *TcpProxyCbResponse) Reset()                    { *m = TcpProxyCbResponse{} }
func (m *TcpProxyCbResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbResponse) ProtoMessage()               {}
func (*TcpProxyCbResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{30} }

func (m *TcpProxyCbResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyCbResponse) GetTcpcbStatus() *TcpProxyCbStatus {
	if m != nil {
		return m.TcpcbStatus
	}
	return nil
}

// TcpProxyCbResponseMsg is batched response to TcpProxyCbRequestMsg
type TcpProxyCbResponseMsg struct {
	Response []*TcpProxyCbResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyCbResponseMsg) Reset()                    { *m = TcpProxyCbResponseMsg{} }
func (m *TcpProxyCbResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbResponseMsg) ProtoMessage()               {}
func (*TcpProxyCbResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{31} }

func (m *TcpProxyCbResponseMsg) GetResponse() []*TcpProxyCbResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyCbDeleteRequest is used to delete a tcpcb
type TcpProxyCbDeleteRequest struct {
	KeyOrHandle *TcpProxyCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyCbDeleteRequest) Reset()                    { *m = TcpProxyCbDeleteRequest{} }
func (m *TcpProxyCbDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbDeleteRequest) ProtoMessage()               {}
func (*TcpProxyCbDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{32} }

func (m *TcpProxyCbDeleteRequest) GetKeyOrHandle() *TcpProxyCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyCbDeleteRequestMsg is used to delete a batch of tcpcbs
type TcpProxyCbDeleteRequestMsg struct {
	Request []*TcpProxyCbDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyCbDeleteRequestMsg) Reset()         { *m = TcpProxyCbDeleteRequestMsg{} }
func (m *TcpProxyCbDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyCbDeleteRequestMsg) ProtoMessage()    {}
func (*TcpProxyCbDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{33}
}

func (m *TcpProxyCbDeleteRequestMsg) GetRequest() []*TcpProxyCbDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyCbDeleteResponseMsg is batched response to TcpProxyCbDeleteRequestMsg
type TcpProxyCbDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *TcpProxyCbDeleteResponseMsg) Reset()         { *m = TcpProxyCbDeleteResponseMsg{} }
func (m *TcpProxyCbDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyCbDeleteResponseMsg) ProtoMessage()    {}
func (*TcpProxyCbDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{34}
}

func (m *TcpProxyCbDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// TcpProxyCbGetRequest is used to get information about a tcpcb
type TcpProxyCbGetRequest struct {
	KeyOrHandle *TcpProxyCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *TcpProxyCbGetRequest) Reset()                    { *m = TcpProxyCbGetRequest{} }
func (m *TcpProxyCbGetRequest) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbGetRequest) ProtoMessage()               {}
func (*TcpProxyCbGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{35} }

func (m *TcpProxyCbGetRequest) GetKeyOrHandle() *TcpProxyCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// TcpProxyCbGetRequestMsg is batched GET requests for tcpcbs
type TcpProxyCbGetRequestMsg struct {
	Request []*TcpProxyCbGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyCbGetRequestMsg) Reset()                    { *m = TcpProxyCbGetRequestMsg{} }
func (m *TcpProxyCbGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbGetRequestMsg) ProtoMessage()               {}
func (*TcpProxyCbGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{36} }

func (m *TcpProxyCbGetRequestMsg) GetRequest() []*TcpProxyCbGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpProxyCbStats is the statistics object for each tcpcb
type TcpProxyCbStats struct {
	BytesRcvd            uint64 `protobuf:"varint,1,opt,name=bytes_rcvd,json=bytesRcvd,proto3" json:"bytes_rcvd,omitempty"`
	PktsRcvd             uint64 `protobuf:"varint,2,opt,name=pkts_rcvd,json=pktsRcvd,proto3" json:"pkts_rcvd,omitempty"`
	PagesAlloced         uint64 `protobuf:"varint,3,opt,name=pages_alloced,json=pagesAlloced,proto3" json:"pages_alloced,omitempty"`
	DescAlloced          uint64 `protobuf:"varint,4,opt,name=desc_alloced,json=descAlloced,proto3" json:"desc_alloced,omitempty"`
	DebugNumPktToMem     uint64 `protobuf:"varint,5,opt,name=debug_num_pkt_to_mem,json=debugNumPktToMem,proto3" json:"debug_num_pkt_to_mem,omitempty"`
	DebugNumPhvToMem     uint64 `protobuf:"varint,6,opt,name=debug_num_phv_to_mem,json=debugNumPhvToMem,proto3" json:"debug_num_phv_to_mem,omitempty"`
	DebugAtomicDelta     uint32 `protobuf:"varint,8,opt,name=debug_atomic_delta,json=debugAtomicDelta,proto3" json:"debug_atomic_delta,omitempty"`
	DebugAtomic0Incr1247 uint32 `protobuf:"varint,9,opt,name=debug_atomic0_incr1247,json=debugAtomic0Incr1247,proto3" json:"debug_atomic0_incr1247,omitempty"`
	DebugAtomic1Incr247  uint32 `protobuf:"varint,10,opt,name=debug_atomic1_incr247,json=debugAtomic1Incr247,proto3" json:"debug_atomic1_incr247,omitempty"`
	DebugAtomic2Incr47   uint32 `protobuf:"varint,11,opt,name=debug_atomic2_incr47,json=debugAtomic2Incr47,proto3" json:"debug_atomic2_incr47,omitempty"`
	DebugAtomic3Incr47   uint32 `protobuf:"varint,12,opt,name=debug_atomic3_incr47,json=debugAtomic3Incr47,proto3" json:"debug_atomic3_incr47,omitempty"`
	DebugAtomic4Incr7    uint32 `protobuf:"varint,13,opt,name=debug_atomic4_incr7,json=debugAtomic4Incr7,proto3" json:"debug_atomic4_incr7,omitempty"`
	DebugAtomic5Incr7    uint32 `protobuf:"varint,14,opt,name=debug_atomic5_incr7,json=debugAtomic5Incr7,proto3" json:"debug_atomic5_incr7,omitempty"`
	DebugAtomic6Incr7    uint32 `protobuf:"varint,15,opt,name=debug_atomic6_incr7,json=debugAtomic6Incr7,proto3" json:"debug_atomic6_incr7,omitempty"`
	BytesAcked           uint64 `protobuf:"varint,16,opt,name=bytes_acked,json=bytesAcked,proto3" json:"bytes_acked,omitempty"`
	SlowPathCnt          uint64 `protobuf:"varint,17,opt,name=slow_path_cnt,json=slowPathCnt,proto3" json:"slow_path_cnt,omitempty"`
	SerqFullCnt          uint64 `protobuf:"varint,18,opt,name=serq_full_cnt,json=serqFullCnt,proto3" json:"serq_full_cnt,omitempty"`
	OooCnt               uint64 `protobuf:"varint,19,opt,name=ooo_cnt,json=oooCnt,proto3" json:"ooo_cnt,omitempty"`
	BytesSent            uint64 `protobuf:"varint,10001,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	PktsSent             uint64 `protobuf:"varint,10002,opt,name=pkts_sent,json=pktsSent,proto3" json:"pkts_sent,omitempty"`
	DebugNumPhvToPkt     uint64 `protobuf:"varint,10003,opt,name=debug_num_phv_to_pkt,json=debugNumPhvToPkt,proto3" json:"debug_num_phv_to_pkt,omitempty"`
	DebugNumMemToPkt     uint64 `protobuf:"varint,10004,opt,name=debug_num_mem_to_pkt,json=debugNumMemToPkt,proto3" json:"debug_num_mem_to_pkt,omitempty"`
}

func (m *TcpProxyCbStats) Reset()                    { *m = TcpProxyCbStats{} }
func (m *TcpProxyCbStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbStats) ProtoMessage()               {}
func (*TcpProxyCbStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{37} }

func (m *TcpProxyCbStats) GetBytesRcvd() uint64 {
	if m != nil {
		return m.BytesRcvd
	}
	return 0
}

func (m *TcpProxyCbStats) GetPktsRcvd() uint64 {
	if m != nil {
		return m.PktsRcvd
	}
	return 0
}

func (m *TcpProxyCbStats) GetPagesAlloced() uint64 {
	if m != nil {
		return m.PagesAlloced
	}
	return 0
}

func (m *TcpProxyCbStats) GetDescAlloced() uint64 {
	if m != nil {
		return m.DescAlloced
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugNumPktToMem() uint64 {
	if m != nil {
		return m.DebugNumPktToMem
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugNumPhvToMem() uint64 {
	if m != nil {
		return m.DebugNumPhvToMem
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomicDelta() uint32 {
	if m != nil {
		return m.DebugAtomicDelta
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic0Incr1247() uint32 {
	if m != nil {
		return m.DebugAtomic0Incr1247
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic1Incr247() uint32 {
	if m != nil {
		return m.DebugAtomic1Incr247
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic2Incr47() uint32 {
	if m != nil {
		return m.DebugAtomic2Incr47
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic3Incr47() uint32 {
	if m != nil {
		return m.DebugAtomic3Incr47
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic4Incr7() uint32 {
	if m != nil {
		return m.DebugAtomic4Incr7
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic5Incr7() uint32 {
	if m != nil {
		return m.DebugAtomic5Incr7
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugAtomic6Incr7() uint32 {
	if m != nil {
		return m.DebugAtomic6Incr7
	}
	return 0
}

func (m *TcpProxyCbStats) GetBytesAcked() uint64 {
	if m != nil {
		return m.BytesAcked
	}
	return 0
}

func (m *TcpProxyCbStats) GetSlowPathCnt() uint64 {
	if m != nil {
		return m.SlowPathCnt
	}
	return 0
}

func (m *TcpProxyCbStats) GetSerqFullCnt() uint64 {
	if m != nil {
		return m.SerqFullCnt
	}
	return 0
}

func (m *TcpProxyCbStats) GetOooCnt() uint64 {
	if m != nil {
		return m.OooCnt
	}
	return 0
}

func (m *TcpProxyCbStats) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *TcpProxyCbStats) GetPktsSent() uint64 {
	if m != nil {
		return m.PktsSent
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugNumPhvToPkt() uint64 {
	if m != nil {
		return m.DebugNumPhvToPkt
	}
	return 0
}

func (m *TcpProxyCbStats) GetDebugNumMemToPkt() uint64 {
	if m != nil {
		return m.DebugNumMemToPkt
	}
	return 0
}

// TcpProxyCbGetResponse captures all the information about a tcpcb
// only if api_status indicates success, other fields are valid
type TcpProxyCbGetResponse struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *TcpProxyCbSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *TcpProxyCbStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *TcpProxyCbStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *TcpProxyCbGetResponse) Reset()                    { *m = TcpProxyCbGetResponse{} }
func (m *TcpProxyCbGetResponse) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyCbGetResponse) ProtoMessage()               {}
func (*TcpProxyCbGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{38} }

func (m *TcpProxyCbGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyCbGetResponse) GetSpec() *TcpProxyCbSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TcpProxyCbGetResponse) GetStatus() *TcpProxyCbStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TcpProxyCbGetResponse) GetStats() *TcpProxyCbStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpProxyCbGetResponseMsg is batched response to TcpProxyCbGetRequestMsg
type TcpProxyCbGetResponseMsg struct {
	Response []*TcpProxyCbGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *TcpProxyCbGetResponseMsg) Reset()         { *m = TcpProxyCbGetResponseMsg{} }
func (m *TcpProxyCbGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyCbGetResponseMsg) ProtoMessage()    {}
func (*TcpProxyCbGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{39}
}

func (m *TcpProxyCbGetResponseMsg) GetResponse() []*TcpProxyCbGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// TcpProxyGlobalStatsGetRequest is used to get global TCP stats
type TcpProxyGlobalStatsGetRequest struct {
	Dummy uint32 `protobuf:"varint,1,opt,name=dummy,proto3" json:"dummy,omitempty"`
}

func (m *TcpProxyGlobalStatsGetRequest) Reset()         { *m = TcpProxyGlobalStatsGetRequest{} }
func (m *TcpProxyGlobalStatsGetRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStatsGetRequest) ProtoMessage()    {}
func (*TcpProxyGlobalStatsGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{40}
}

func (m *TcpProxyGlobalStatsGetRequest) GetDummy() uint32 {
	if m != nil {
		return m.Dummy
	}
	return 0
}

// TcpProxyCbGetRequestMsg is batched GET requests for tcp global stats
type TcpProxyGlobalStatsGetRequestMsg struct {
	Request []*TcpProxyGlobalStatsGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *TcpProxyGlobalStatsGetRequestMsg) Reset()         { *m = TcpProxyGlobalStatsGetRequestMsg{} }
func (m *TcpProxyGlobalStatsGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStatsGetRequestMsg) ProtoMessage()    {}
func (*TcpProxyGlobalStatsGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{41}
}

func (m *TcpProxyGlobalStatsGetRequestMsg) GetRequest() []*TcpProxyGlobalStatsGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// Only if api_status indicates success, other fields are valid
type TcpProxyGlobalStatsGetResponseMsg struct {
	ApiStatus   ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	GlobalStats *TcpProxyGlobalStats `protobuf:"bytes,2,opt,name=global_stats,json=globalStats" json:"global_stats,omitempty"`
}

func (m *TcpProxyGlobalStatsGetResponseMsg) Reset()         { *m = TcpProxyGlobalStatsGetResponseMsg{} }
func (m *TcpProxyGlobalStatsGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStatsGetResponseMsg) ProtoMessage()    {}
func (*TcpProxyGlobalStatsGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTcpProxy, []int{42}
}

func (m *TcpProxyGlobalStatsGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyGlobalStatsGetResponseMsg) GetGlobalStats() *TcpProxyGlobalStats {
	if m != nil {
		return m.GlobalStats
	}
	return nil
}

// TcpProxyGlobalStats captures global TCP statistics
type TcpProxyGlobalStats struct {
	RnmdrFull            uint64 `protobuf:"varint,1,opt,name=rnmdr_full,json=rnmdrFull,proto3" json:"rnmdr_full,omitempty"`
	InvalidSesqDescr     uint64 `protobuf:"varint,2,opt,name=invalid_sesq_descr,json=invalidSesqDescr,proto3" json:"invalid_sesq_descr,omitempty"`
	InvalidRetxSesqDescr uint64 `protobuf:"varint,3,opt,name=invalid_retx_sesq_descr,json=invalidRetxSesqDescr,proto3" json:"invalid_retx_sesq_descr,omitempty"`
	StretchAck           uint64 `protobuf:"varint,4,opt,name=stretch_ack,json=stretchAck,proto3" json:"stretch_ack,omitempty"`
	RetxNopSchedule      uint64 `protobuf:"varint,5,opt,name=retx_nop_schedule,json=retxNopSchedule,proto3" json:"retx_nop_schedule,omitempty"`
	GcFull               uint64 `protobuf:"varint,6,opt,name=gc_full,json=gcFull,proto3" json:"gc_full,omitempty"`
	TlsGcFull            uint64 `protobuf:"varint,7,opt,name=tls_gc_full,json=tlsGcFull,proto3" json:"tls_gc_full,omitempty"`
}

func (m *TcpProxyGlobalStats) Reset()                    { *m = TcpProxyGlobalStats{} }
func (m *TcpProxyGlobalStats) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStats) ProtoMessage()               {}
func (*TcpProxyGlobalStats) Descriptor() ([]byte, []int) { return fileDescriptorTcpProxy, []int{43} }

func (m *TcpProxyGlobalStats) GetRnmdrFull() uint64 {
	if m != nil {
		return m.RnmdrFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetInvalidSesqDescr() uint64 {
	if m != nil {
		return m.InvalidSesqDescr
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetInvalidRetxSesqDescr() uint64 {
	if m != nil {
		return m.InvalidRetxSesqDescr
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetStretchAck() uint64 {
	if m != nil {
		return m.StretchAck
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRetxNopSchedule() uint64 {
	if m != nil {
		return m.RetxNopSchedule
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetGcFull() uint64 {
	if m != nil {
		return m.GcFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTlsGcFull() uint64 {
	if m != nil {
		return m.TlsGcFull
	}
	return 0
}

func init() {
	proto.RegisterType((*TcpProxySessionFilter)(nil), "tcp_proxy.TcpProxySessionFilter")
	proto.RegisterType((*TcpProxySessionGetRequest)(nil), "tcp_proxy.TcpProxySessionGetRequest")
	proto.RegisterType((*TcpproxyFlow)(nil), "tcp_proxy.tcpproxy_flow")
	proto.RegisterType((*TcpProxySessionGetRequestMsg)(nil), "tcp_proxy.TcpProxySessionGetRequestMsg")
	proto.RegisterType((*TcpProxySessionGetResponse)(nil), "tcp_proxy.TcpProxySessionGetResponse")
	proto.RegisterType((*TcpProxySessionGetResponseMsg)(nil), "tcp_proxy.TcpProxySessionGetResponseMsg")
	proto.RegisterType((*TlsProxyECDSAKey)(nil), "tcp_proxy.TlsProxyECDSAKey")
	proto.RegisterType((*TlsProxyRSAKey)(nil), "tcp_proxy.TlsProxyRSAKey")
	proto.RegisterType((*TlsProxyAction)(nil), "tcp_proxy.TlsProxyAction")
	proto.RegisterType((*TcpProxyAction)(nil), "tcp_proxy.TcpProxyAction")
	proto.RegisterType((*TcpProxyRuleMatchSpec)(nil), "tcp_proxy.TcpProxyRuleMatchSpec")
	proto.RegisterType((*TcpProxyRuleSpec)(nil), "tcp_proxy.TcpProxyRuleSpec")
	proto.RegisterType((*TcpProxyRuleRequestMsg)(nil), "tcp_proxy.TcpProxyRuleRequestMsg")
	proto.RegisterType((*TcpProxyRuleStatus)(nil), "tcp_proxy.TcpProxyRuleStatus")
	proto.RegisterType((*TcpProxyRuleResponse)(nil), "tcp_proxy.TcpProxyRuleResponse")
	proto.RegisterType((*TcpProxyRuleResponseMsg)(nil), "tcp_proxy.TcpProxyRuleResponseMsg")
	proto.RegisterType((*TcpProxyRuleDeleteRequest)(nil), "tcp_proxy.TcpProxyRuleDeleteRequest")
	proto.RegisterType((*TcpProxyRuleDeleteRequestMsg)(nil), "tcp_proxy.TcpProxyRuleDeleteRequestMsg")
	proto.RegisterType((*TcpProxyRuleDeleteResponse)(nil), "tcp_proxy.TcpProxyRuleDeleteResponse")
	proto.RegisterType((*TcpProxyRuleDeleteResponseMsg)(nil), "tcp_proxy.TcpProxyRuleDeleteResponseMsg")
	proto.RegisterType((*TcpProxyRuleGetRequest)(nil), "tcp_proxy.TcpProxyRuleGetRequest")
	proto.RegisterType((*TcpProxyRuleGetRequestMsg)(nil), "tcp_proxy.TcpProxyRuleGetRequestMsg")
	proto.RegisterType((*TcpProxyRuleEntryStats)(nil), "tcp_proxy.TcpProxyRuleEntryStats")
	proto.RegisterType((*TcpProxyRuleStats)(nil), "tcp_proxy.TcpProxyRuleStats")
	proto.RegisterType((*TcpProxyRuleGetResponse)(nil), "tcp_proxy.TcpProxyRuleGetResponse")
	proto.RegisterType((*TcpProxyRuleGetResponseMsg)(nil), "tcp_proxy.TcpProxyRuleGetResponseMsg")
	proto.RegisterType((*TcpProxyCbKeyHandle)(nil), "tcp_proxy.TcpProxyCbKeyHandle")
	proto.RegisterType((*TcpProxyCbSpec)(nil), "tcp_proxy.TcpProxyCbSpec")
	proto.RegisterType((*TcpProxyCbRequestMsg)(nil), "tcp_proxy.TcpProxyCbRequestMsg")
	proto.RegisterType((*TcpProxyCbStatus)(nil), "tcp_proxy.TcpProxyCbStatus")
	proto.RegisterType((*TcpProxyCbResponse)(nil), "tcp_proxy.TcpProxyCbResponse")
	proto.RegisterType((*TcpProxyCbResponseMsg)(nil), "tcp_proxy.TcpProxyCbResponseMsg")
	proto.RegisterType((*TcpProxyCbDeleteRequest)(nil), "tcp_proxy.TcpProxyCbDeleteRequest")
	proto.RegisterType((*TcpProxyCbDeleteRequestMsg)(nil), "tcp_proxy.TcpProxyCbDeleteRequestMsg")
	proto.RegisterType((*TcpProxyCbDeleteResponseMsg)(nil), "tcp_proxy.TcpProxyCbDeleteResponseMsg")
	proto.RegisterType((*TcpProxyCbGetRequest)(nil), "tcp_proxy.TcpProxyCbGetRequest")
	proto.RegisterType((*TcpProxyCbGetRequestMsg)(nil), "tcp_proxy.TcpProxyCbGetRequestMsg")
	proto.RegisterType((*TcpProxyCbStats)(nil), "tcp_proxy.TcpProxyCbStats")
	proto.RegisterType((*TcpProxyCbGetResponse)(nil), "tcp_proxy.TcpProxyCbGetResponse")
	proto.RegisterType((*TcpProxyCbGetResponseMsg)(nil), "tcp_proxy.TcpProxyCbGetResponseMsg")
	proto.RegisterType((*TcpProxyGlobalStatsGetRequest)(nil), "tcp_proxy.TcpProxyGlobalStatsGetRequest")
	proto.RegisterType((*TcpProxyGlobalStatsGetRequestMsg)(nil), "tcp_proxy.TcpProxyGlobalStatsGetRequestMsg")
	proto.RegisterType((*TcpProxyGlobalStatsGetResponseMsg)(nil), "tcp_proxy.TcpProxyGlobalStatsGetResponseMsg")
	proto.RegisterType((*TcpProxyGlobalStats)(nil), "tcp_proxy.TcpProxyGlobalStats")
	proto.RegisterEnum("tcp_proxy.TcpProxyActionType", TcpProxyActionType_name, TcpProxyActionType_value)
	proto.RegisterEnum("tcp_proxy.TlsProxySide", TlsProxySide_name, TlsProxySide_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TcpProxy service

type TcpProxyClient interface {
	TcpProxyRuleCreate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleUpdate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleDelete(ctx context.Context, in *TcpProxyRuleDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleDeleteResponseMsg, error)
	TcpProxyRuleGet(ctx context.Context, in *TcpProxyRuleGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleGetResponseMsg, error)
	TcpProxyCbCreate(ctx context.Context, in *TcpProxyCbRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbResponseMsg, error)
	TcpProxyCbUpdate(ctx context.Context, in *TcpProxyCbRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbResponseMsg, error)
	TcpProxyCbDelete(ctx context.Context, in *TcpProxyCbDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbDeleteResponseMsg, error)
	TcpProxyCbGet(ctx context.Context, in *TcpProxyCbGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbGetResponseMsg, error)
	TcpProxySessionGet(ctx context.Context, in *TcpProxySessionGetRequestMsg, opts ...grpc.CallOption) (*TcpProxySessionGetResponseMsg, error)
	TcpProxyGlobalStatsGet(ctx context.Context, in *TcpProxyGlobalStatsGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyGlobalStatsGetResponseMsg, error)
}

type tcpProxyClient struct {
	cc *grpc.ClientConn
}

func NewTcpProxyClient(cc *grpc.ClientConn) TcpProxyClient {
	return &tcpProxyClient{cc}
}

func (c *tcpProxyClient) TcpProxyRuleCreate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error) {
	out := new(TcpProxyRuleResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleUpdate(ctx context.Context, in *TcpProxyRuleRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleResponseMsg, error) {
	out := new(TcpProxyRuleResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleDelete(ctx context.Context, in *TcpProxyRuleDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleDeleteResponseMsg, error) {
	out := new(TcpProxyRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyRuleGet(ctx context.Context, in *TcpProxyRuleGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyRuleGetResponseMsg, error) {
	out := new(TcpProxyRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyCbCreate(ctx context.Context, in *TcpProxyCbRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbResponseMsg, error) {
	out := new(TcpProxyCbResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyCbCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyCbUpdate(ctx context.Context, in *TcpProxyCbRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbResponseMsg, error) {
	out := new(TcpProxyCbResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyCbUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyCbDelete(ctx context.Context, in *TcpProxyCbDeleteRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbDeleteResponseMsg, error) {
	out := new(TcpProxyCbDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyCbDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyCbGet(ctx context.Context, in *TcpProxyCbGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyCbGetResponseMsg, error) {
	out := new(TcpProxyCbGetResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyCbGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxySessionGet(ctx context.Context, in *TcpProxySessionGetRequestMsg, opts ...grpc.CallOption) (*TcpProxySessionGetResponseMsg, error) {
	out := new(TcpProxySessionGetResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxySessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tcpProxyClient) TcpProxyGlobalStatsGet(ctx context.Context, in *TcpProxyGlobalStatsGetRequestMsg, opts ...grpc.CallOption) (*TcpProxyGlobalStatsGetResponseMsg, error) {
	out := new(TcpProxyGlobalStatsGetResponseMsg)
	err := grpc.Invoke(ctx, "/tcp_proxy.TcpProxy/TcpProxyGlobalStatsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TcpProxy service

type TcpProxyServer interface {
	TcpProxyRuleCreate(context.Context, *TcpProxyRuleRequestMsg) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleUpdate(context.Context, *TcpProxyRuleRequestMsg) (*TcpProxyRuleResponseMsg, error)
	TcpProxyRuleDelete(context.Context, *TcpProxyRuleDeleteRequestMsg) (*TcpProxyRuleDeleteResponseMsg, error)
	TcpProxyRuleGet(context.Context, *TcpProxyRuleGetRequestMsg) (*TcpProxyRuleGetResponseMsg, error)
	TcpProxyCbCreate(context.Context, *TcpProxyCbRequestMsg) (*TcpProxyCbResponseMsg, error)
	TcpProxyCbUpdate(context.Context, *TcpProxyCbRequestMsg) (*TcpProxyCbResponseMsg, error)
	TcpProxyCbDelete(context.Context, *TcpProxyCbDeleteRequestMsg) (*TcpProxyCbDeleteResponseMsg, error)
	TcpProxyCbGet(context.Context, *TcpProxyCbGetRequestMsg) (*TcpProxyCbGetResponseMsg, error)
	TcpProxySessionGet(context.Context, *TcpProxySessionGetRequestMsg) (*TcpProxySessionGetResponseMsg, error)
	TcpProxyGlobalStatsGet(context.Context, *TcpProxyGlobalStatsGetRequestMsg) (*TcpProxyGlobalStatsGetResponseMsg, error)
}

func RegisterTcpProxyServer(s *grpc.Server, srv TcpProxyServer) {
	s.RegisterService(&_TcpProxy_serviceDesc, srv)
}

func _TcpProxy_TcpProxyRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleCreate(ctx, req.(*TcpProxyRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleUpdate(ctx, req.(*TcpProxyRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleDelete(ctx, req.(*TcpProxyRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyRuleGet(ctx, req.(*TcpProxyRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyCbCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyCbRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyCbCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyCbCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyCbCreate(ctx, req.(*TcpProxyCbRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyCbUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyCbRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyCbUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyCbUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyCbUpdate(ctx, req.(*TcpProxyCbRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyCbDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyCbDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyCbDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyCbDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyCbDelete(ctx, req.(*TcpProxyCbDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyCbGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyCbGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyCbGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyCbGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyCbGet(ctx, req.(*TcpProxyCbGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxySessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxySessionGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxySessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxySessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxySessionGet(ctx, req.(*TcpProxySessionGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TcpProxy_TcpProxyGlobalStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyGlobalStatsGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TcpProxyServer).TcpProxyGlobalStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tcp_proxy.TcpProxy/TcpProxyGlobalStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TcpProxyServer).TcpProxyGlobalStatsGet(ctx, req.(*TcpProxyGlobalStatsGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _TcpProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tcp_proxy.TcpProxy",
	HandlerType: (*TcpProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TcpProxyRuleCreate",
			Handler:    _TcpProxy_TcpProxyRuleCreate_Handler,
		},
		{
			MethodName: "TcpProxyRuleUpdate",
			Handler:    _TcpProxy_TcpProxyRuleUpdate_Handler,
		},
		{
			MethodName: "TcpProxyRuleDelete",
			Handler:    _TcpProxy_TcpProxyRuleDelete_Handler,
		},
		{
			MethodName: "TcpProxyRuleGet",
			Handler:    _TcpProxy_TcpProxyRuleGet_Handler,
		},
		{
			MethodName: "TcpProxyCbCreate",
			Handler:    _TcpProxy_TcpProxyCbCreate_Handler,
		},
		{
			MethodName: "TcpProxyCbUpdate",
			Handler:    _TcpProxy_TcpProxyCbUpdate_Handler,
		},
		{
			MethodName: "TcpProxyCbDelete",
			Handler:    _TcpProxy_TcpProxyCbDelete_Handler,
		},
		{
			MethodName: "TcpProxyCbGet",
			Handler:    _TcpProxy_TcpProxyCbGet_Handler,
		},
		{
			MethodName: "TcpProxySessionGet",
			Handler:    _TcpProxy_TcpProxySessionGet_Handler,
		},
		{
			MethodName: "TcpProxyGlobalStatsGet",
			Handler:    _TcpProxy_TcpProxyGlobalStatsGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tcp_proxy.proto",
}

func (m *TcpProxySessionFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcIp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SrcIp.Size()))
		n1, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DstIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DstIp.Size()))
		n2, err := m.DstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DstPort))
	}
	if m.MatchAll {
		dAtA[i] = 0x28
		i++
		if m.MatchAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TcpProxySessionGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionFilter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SessionFilter.Size()))
		n3, err := m.SessionFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *TcpproxyFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpproxyFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Qid1 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Qid1))
	}
	if m.Qid2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Qid2))
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SrcIp.Size()))
		n4, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DstIp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DstIp.Size()))
		n5, err := m.DstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Sport != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Dport))
	}
	if m.FlowType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.FlowType))
	}
	return i, nil
}

func (m *TcpProxySessionGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxySessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.TcpproxyFlow != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpproxyFlow.Size()))
		n6, err := m.TcpproxyFlow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *TcpProxySessionGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TlsProxyECDSAKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsProxyECDSAKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignKeyIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SignKeyIdx))
	}
	return i, nil
}

func (m *TlsProxyRSAKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsProxyRSAKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignKeyIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SignKeyIdx))
	}
	if m.DecryptKeyIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DecryptKeyIdx))
	}
	return i, nil
}

func (m *TlsProxyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsProxyAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AsymKeyType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.AsymKeyType))
	}
	if m.CertId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.CertId))
	}
	if m.TrustRootId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TrustRootId))
	}
	if len(m.Ciphers) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(len(m.Ciphers)))
		i += copy(dAtA[i:], m.Ciphers)
	}
	if m.TlsProxySide != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TlsProxySide))
	}
	if m.Keys != nil {
		nn7, err := m.Keys.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *TlsProxyAction_EcdsaKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EcdsaKey != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.EcdsaKey.Size()))
		n8, err := m.EcdsaKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *TlsProxyAction_RsaKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RsaKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RsaKey.Size()))
		n9, err := m.RsaKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *TcpProxyAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpProxyActionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpProxyActionType))
	}
	if m.ProxyType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ProxyType))
	}
	if m.ProxyConfig != nil {
		nn10, err := m.ProxyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *TcpProxyAction_Tls) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Tls != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Tls.Size()))
		n11, err := m.Tls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *TcpProxyRuleMatchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleMatchSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RuleId))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Match.Size()))
		n12, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TcpProxyAction != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpProxyAction.Size()))
		n13, err := m.TcpProxyAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *TcpProxyRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n14, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n15, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *TcpProxyRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Status.Size()))
		n16, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *TcpProxyRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *TcpProxyRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n18, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *TcpProxyRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleEntryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleEntryStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *TcpProxyRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Spec.Size()))
		n19, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Status.Size()))
		n20, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Stats.Size()))
		n21, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *TcpProxyRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyCbKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn22, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *TcpProxyCbKeyHandle_TcpcbId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpcbId))
	return i, nil
}
func (m *TcpProxyCbKeyHandle_TcpcbHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TcpcbHandle))
	i += 8
	return i, nil
}
func (m *TcpProxyCbSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n23, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RcvNxt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RcvNxt))
	}
	if m.SndNxt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndNxt))
	}
	if m.SndUna != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndUna))
	}
	if m.RcvTsval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RcvTsval))
	}
	if m.TsRecent != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TsRecent))
	}
	if m.SerqBase != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SerqBase))
		i += 8
	}
	if m.DebugDol != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugDol))
	}
	if m.SesqBase != 0 {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SesqBase))
		i += 8
	}
	if m.SesqPi != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SesqPi))
	}
	if m.SesqCi != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SesqCi))
	}
	if m.SndWnd != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndWnd))
	}
	if m.SndCwnd != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndCwnd))
	}
	if m.RcvMss != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RcvMss))
	}
	if m.SourcePort != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SourcePort))
	}
	if m.DestPort != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DestPort))
	}
	if len(m.HeaderTemplate) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(len(m.HeaderTemplate)))
		i += copy(dAtA[i:], m.HeaderTemplate)
	}
	if m.State != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.State))
	}
	if m.SourceLif != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SourceLif))
	}
	if m.AsesqBase != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AsesqBase))
		i += 8
	}
	if m.AsesqPi != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.AsesqPi))
	}
	if m.AsesqCi != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.AsesqCi))
	}
	if m.DebugDolTx != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugDolTx))
	}
	if m.HeaderLen != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.HeaderLen))
	}
	if m.PendingAckSend {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.PendingAckSend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.L7ProxyType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.L7ProxyType))
	}
	if m.SesqRetxCi != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SesqRetxCi))
	}
	if m.RetxSndUna != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RetxSndUna))
	}
	if m.RxTs != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RxTs))
	}
	if m.Rto != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Rto))
	}
	if m.SndCwndCnt != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndCwndCnt))
	}
	if m.DebugDolTblsetaddr != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugDolTblsetaddr))
	}
	if m.SerqPi != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SerqPi))
	}
	if m.PredFlags != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.PredFlags))
	}
	if m.OtherQid != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.OtherQid))
	}
	if m.PacketsOut != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.PacketsOut))
	}
	if m.RtoPi != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RtoPi))
	}
	if m.RetxTimerCi != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RetxTimerCi))
	}
	if m.RtoBackoff != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RtoBackoff))
	}
	if m.CpuId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.CpuId))
	}
	if m.SerqCi != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SerqCi))
	}
	if m.RcvWnd != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RcvWnd))
	}
	if m.SndWscale != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RcvWscale))
	}
	if m.SesqTxCi != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SesqTxCi))
	}
	return i, nil
}

func (m *TcpProxyCbRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyCbStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpcbHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TcpcbHandle))
		i += 8
	}
	return i, nil
}

func (m *TcpProxyCbResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.TcpcbStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TcpcbStatus.Size()))
		n24, err := m.TcpcbStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *TcpProxyCbResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyCbDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n25, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *TcpProxyCbDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyCbDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA27 := make([]byte, len(m.ApiStatus)*10)
		var j26 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	return i, nil
}

func (m *TcpProxyCbGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *TcpProxyCbGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyCbStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BytesRcvd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.BytesRcvd))
	}
	if m.PktsRcvd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.PktsRcvd))
	}
	if m.PagesAlloced != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.PagesAlloced))
	}
	if m.DescAlloced != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DescAlloced))
	}
	if m.DebugNumPktToMem != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugNumPktToMem))
	}
	if m.DebugNumPhvToMem != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugNumPhvToMem))
	}
	if m.DebugAtomicDelta != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomicDelta))
	}
	if m.DebugAtomic0Incr1247 != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic0Incr1247))
	}
	if m.DebugAtomic1Incr247 != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic1Incr247))
	}
	if m.DebugAtomic2Incr47 != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic2Incr47))
	}
	if m.DebugAtomic3Incr47 != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic3Incr47))
	}
	if m.DebugAtomic4Incr7 != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic4Incr7))
	}
	if m.DebugAtomic5Incr7 != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic5Incr7))
	}
	if m.DebugAtomic6Incr7 != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugAtomic6Incr7))
	}
	if m.BytesAcked != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.BytesAcked))
	}
	if m.SlowPathCnt != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SlowPathCnt))
	}
	if m.SerqFullCnt != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.SerqFullCnt))
	}
	if m.OooCnt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.OooCnt))
	}
	if m.BytesSent != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.BytesSent))
	}
	if m.PktsSent != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.PktsSent))
	}
	if m.DebugNumPhvToPkt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugNumPhvToPkt))
	}
	if m.DebugNumMemToPkt != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.DebugNumMemToPkt))
	}
	return i, nil
}

func (m *TcpProxyCbGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Spec.Size()))
		n29, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Status.Size()))
		n30, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Stats.Size()))
		n31, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *TcpProxyCbGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyCbGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyGlobalStatsGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStatsGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dummy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.Dummy))
	}
	return i, nil
}

func (m *TcpProxyGlobalStatsGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStatsGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTcpProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TcpProxyGlobalStatsGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStatsGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.GlobalStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.GlobalStats.Size()))
		n32, err := m.GlobalStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *TcpProxyGlobalStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RnmdrFull != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RnmdrFull))
	}
	if m.InvalidSesqDescr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.InvalidSesqDescr))
	}
	if m.InvalidRetxSesqDescr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.InvalidRetxSesqDescr))
	}
	if m.StretchAck != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.StretchAck))
	}
	if m.RetxNopSchedule != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.RetxNopSchedule))
	}
	if m.GcFull != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.GcFull))
	}
	if m.TlsGcFull != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTcpProxy(dAtA, i, uint64(m.TlsGcFull))
	}
	return i, nil
}

func encodeVarintTcpProxy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TcpProxySessionFilter) Size() (n int) {
	var l int
	_ = l
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovTcpProxy(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovTcpProxy(uint64(m.DstPort))
	}
	if m.MatchAll {
		n += 2
	}
	return n
}

func (m *TcpProxySessionGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.SessionFilter != nil {
		l = m.SessionFilter.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpproxyFlow) Size() (n int) {
	var l int
	_ = l
	if m.Qid1 != 0 {
		n += 1 + sovTcpProxy(uint64(m.Qid1))
	}
	if m.Qid2 != 0 {
		n += 1 + sovTcpProxy(uint64(m.Qid2))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Sport != 0 {
		n += 1 + sovTcpProxy(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovTcpProxy(uint64(m.Dport))
	}
	if m.FlowType != 0 {
		n += 1 + sovTcpProxy(uint64(m.FlowType))
	}
	return n
}

func (m *TcpProxySessionGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxySessionGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.TcpproxyFlow != nil {
		l = m.TcpproxyFlow.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxySessionGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TlsProxyECDSAKey) Size() (n int) {
	var l int
	_ = l
	if m.SignKeyIdx != 0 {
		n += 1 + sovTcpProxy(uint64(m.SignKeyIdx))
	}
	return n
}

func (m *TlsProxyRSAKey) Size() (n int) {
	var l int
	_ = l
	if m.SignKeyIdx != 0 {
		n += 1 + sovTcpProxy(uint64(m.SignKeyIdx))
	}
	if m.DecryptKeyIdx != 0 {
		n += 1 + sovTcpProxy(uint64(m.DecryptKeyIdx))
	}
	return n
}

func (m *TlsProxyAction) Size() (n int) {
	var l int
	_ = l
	if m.AsymKeyType != 0 {
		n += 1 + sovTcpProxy(uint64(m.AsymKeyType))
	}
	if m.CertId != 0 {
		n += 1 + sovTcpProxy(uint64(m.CertId))
	}
	if m.TrustRootId != 0 {
		n += 1 + sovTcpProxy(uint64(m.TrustRootId))
	}
	l = len(m.Ciphers)
	if l > 0 {
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.TlsProxySide != 0 {
		n += 1 + sovTcpProxy(uint64(m.TlsProxySide))
	}
	if m.Keys != nil {
		n += m.Keys.Size()
	}
	return n
}

func (m *TlsProxyAction_EcdsaKey) Size() (n int) {
	var l int
	_ = l
	if m.EcdsaKey != nil {
		l = m.EcdsaKey.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}
func (m *TlsProxyAction_RsaKey) Size() (n int) {
	var l int
	_ = l
	if m.RsaKey != nil {
		l = m.RsaKey.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}
func (m *TcpProxyAction) Size() (n int) {
	var l int
	_ = l
	if m.TcpProxyActionType != 0 {
		n += 1 + sovTcpProxy(uint64(m.TcpProxyActionType))
	}
	if m.ProxyType != 0 {
		n += 1 + sovTcpProxy(uint64(m.ProxyType))
	}
	if m.ProxyConfig != nil {
		n += m.ProxyConfig.Size()
	}
	return n
}

func (m *TcpProxyAction_Tls) Size() (n int) {
	var l int
	_ = l
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}
func (m *TcpProxyRuleMatchSpec) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovTcpProxy(uint64(m.RuleId))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.TcpProxyAction != nil {
		l = m.TcpProxyAction.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *TcpProxyRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	return n
}

func (m *TcpProxyRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleEntryStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovTcpProxy(uint64(m.NumTcpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovTcpProxy(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *TcpProxyRuleStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyCbKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *TcpProxyCbKeyHandle_TcpcbId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTcpProxy(uint64(m.TcpcbId))
	return n
}
func (m *TcpProxyCbKeyHandle_TcpcbHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *TcpProxyCbSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.RcvNxt != 0 {
		n += 1 + sovTcpProxy(uint64(m.RcvNxt))
	}
	if m.SndNxt != 0 {
		n += 1 + sovTcpProxy(uint64(m.SndNxt))
	}
	if m.SndUna != 0 {
		n += 1 + sovTcpProxy(uint64(m.SndUna))
	}
	if m.RcvTsval != 0 {
		n += 1 + sovTcpProxy(uint64(m.RcvTsval))
	}
	if m.TsRecent != 0 {
		n += 1 + sovTcpProxy(uint64(m.TsRecent))
	}
	if m.SerqBase != 0 {
		n += 9
	}
	if m.DebugDol != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugDol))
	}
	if m.SesqBase != 0 {
		n += 9
	}
	if m.SesqPi != 0 {
		n += 1 + sovTcpProxy(uint64(m.SesqPi))
	}
	if m.SesqCi != 0 {
		n += 1 + sovTcpProxy(uint64(m.SesqCi))
	}
	if m.SndWnd != 0 {
		n += 1 + sovTcpProxy(uint64(m.SndWnd))
	}
	if m.SndCwnd != 0 {
		n += 1 + sovTcpProxy(uint64(m.SndCwnd))
	}
	if m.RcvMss != 0 {
		n += 1 + sovTcpProxy(uint64(m.RcvMss))
	}
	if m.SourcePort != 0 {
		n += 1 + sovTcpProxy(uint64(m.SourcePort))
	}
	if m.DestPort != 0 {
		n += 2 + sovTcpProxy(uint64(m.DestPort))
	}
	l = len(m.HeaderTemplate)
	if l > 0 {
		n += 2 + l + sovTcpProxy(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovTcpProxy(uint64(m.State))
	}
	if m.SourceLif != 0 {
		n += 2 + sovTcpProxy(uint64(m.SourceLif))
	}
	if m.AsesqBase != 0 {
		n += 10
	}
	if m.AsesqPi != 0 {
		n += 2 + sovTcpProxy(uint64(m.AsesqPi))
	}
	if m.AsesqCi != 0 {
		n += 2 + sovTcpProxy(uint64(m.AsesqCi))
	}
	if m.DebugDolTx != 0 {
		n += 2 + sovTcpProxy(uint64(m.DebugDolTx))
	}
	if m.HeaderLen != 0 {
		n += 2 + sovTcpProxy(uint64(m.HeaderLen))
	}
	if m.PendingAckSend {
		n += 3
	}
	if m.L7ProxyType != 0 {
		n += 2 + sovTcpProxy(uint64(m.L7ProxyType))
	}
	if m.SesqRetxCi != 0 {
		n += 2 + sovTcpProxy(uint64(m.SesqRetxCi))
	}
	if m.RetxSndUna != 0 {
		n += 2 + sovTcpProxy(uint64(m.RetxSndUna))
	}
	if m.RxTs != 0 {
		n += 2 + sovTcpProxy(uint64(m.RxTs))
	}
	if m.Rto != 0 {
		n += 2 + sovTcpProxy(uint64(m.Rto))
	}
	if m.SndCwndCnt != 0 {
		n += 2 + sovTcpProxy(uint64(m.SndCwndCnt))
	}
	if m.DebugDolTblsetaddr != 0 {
		n += 2 + sovTcpProxy(uint64(m.DebugDolTblsetaddr))
	}
	if m.SerqPi != 0 {
		n += 2 + sovTcpProxy(uint64(m.SerqPi))
	}
	if m.PredFlags != 0 {
		n += 2 + sovTcpProxy(uint64(m.PredFlags))
	}
	if m.OtherQid != 0 {
		n += 2 + sovTcpProxy(uint64(m.OtherQid))
	}
	if m.PacketsOut != 0 {
		n += 2 + sovTcpProxy(uint64(m.PacketsOut))
	}
	if m.RtoPi != 0 {
		n += 2 + sovTcpProxy(uint64(m.RtoPi))
	}
	if m.RetxTimerCi != 0 {
		n += 2 + sovTcpProxy(uint64(m.RetxTimerCi))
	}
	if m.RtoBackoff != 0 {
		n += 2 + sovTcpProxy(uint64(m.RtoBackoff))
	}
	if m.CpuId != 0 {
		n += 2 + sovTcpProxy(uint64(m.CpuId))
	}
	if m.SerqCi != 0 {
		n += 2 + sovTcpProxy(uint64(m.SerqCi))
	}
	if m.RcvWnd != 0 {
		n += 2 + sovTcpProxy(uint64(m.RcvWnd))
	}
	if m.SndWscale != 0 {
		n += 2 + sovTcpProxy(uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		n += 2 + sovTcpProxy(uint64(m.RcvWscale))
	}
	if m.SesqTxCi != 0 {
		n += 2 + sovTcpProxy(uint64(m.SesqTxCi))
	}
	return n
}

func (m *TcpProxyCbRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyCbStatus) Size() (n int) {
	var l int
	_ = l
	if m.TcpcbHandle != 0 {
		n += 9
	}
	return n
}

func (m *TcpProxyCbResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.TcpcbStatus != nil {
		l = m.TcpcbStatus.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyCbResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyCbDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyCbDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyCbDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovTcpProxy(uint64(e))
		}
		n += 1 + sovTcpProxy(uint64(l)) + l
	}
	return n
}

func (m *TcpProxyCbGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyCbGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyCbStats) Size() (n int) {
	var l int
	_ = l
	if m.BytesRcvd != 0 {
		n += 1 + sovTcpProxy(uint64(m.BytesRcvd))
	}
	if m.PktsRcvd != 0 {
		n += 1 + sovTcpProxy(uint64(m.PktsRcvd))
	}
	if m.PagesAlloced != 0 {
		n += 1 + sovTcpProxy(uint64(m.PagesAlloced))
	}
	if m.DescAlloced != 0 {
		n += 1 + sovTcpProxy(uint64(m.DescAlloced))
	}
	if m.DebugNumPktToMem != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugNumPktToMem))
	}
	if m.DebugNumPhvToMem != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugNumPhvToMem))
	}
	if m.DebugAtomicDelta != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomicDelta))
	}
	if m.DebugAtomic0Incr1247 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic0Incr1247))
	}
	if m.DebugAtomic1Incr247 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic1Incr247))
	}
	if m.DebugAtomic2Incr47 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic2Incr47))
	}
	if m.DebugAtomic3Incr47 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic3Incr47))
	}
	if m.DebugAtomic4Incr7 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic4Incr7))
	}
	if m.DebugAtomic5Incr7 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic5Incr7))
	}
	if m.DebugAtomic6Incr7 != 0 {
		n += 1 + sovTcpProxy(uint64(m.DebugAtomic6Incr7))
	}
	if m.BytesAcked != 0 {
		n += 2 + sovTcpProxy(uint64(m.BytesAcked))
	}
	if m.SlowPathCnt != 0 {
		n += 2 + sovTcpProxy(uint64(m.SlowPathCnt))
	}
	if m.SerqFullCnt != 0 {
		n += 2 + sovTcpProxy(uint64(m.SerqFullCnt))
	}
	if m.OooCnt != 0 {
		n += 2 + sovTcpProxy(uint64(m.OooCnt))
	}
	if m.BytesSent != 0 {
		n += 3 + sovTcpProxy(uint64(m.BytesSent))
	}
	if m.PktsSent != 0 {
		n += 3 + sovTcpProxy(uint64(m.PktsSent))
	}
	if m.DebugNumPhvToPkt != 0 {
		n += 3 + sovTcpProxy(uint64(m.DebugNumPhvToPkt))
	}
	if m.DebugNumMemToPkt != 0 {
		n += 3 + sovTcpProxy(uint64(m.DebugNumMemToPkt))
	}
	return n
}

func (m *TcpProxyCbGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyCbGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyGlobalStatsGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Dummy != 0 {
		n += 1 + sovTcpProxy(uint64(m.Dummy))
	}
	return n
}

func (m *TcpProxyGlobalStatsGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTcpProxy(uint64(l))
		}
	}
	return n
}

func (m *TcpProxyGlobalStatsGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTcpProxy(uint64(m.ApiStatus))
	}
	if m.GlobalStats != nil {
		l = m.GlobalStats.Size()
		n += 1 + l + sovTcpProxy(uint64(l))
	}
	return n
}

func (m *TcpProxyGlobalStats) Size() (n int) {
	var l int
	_ = l
	if m.RnmdrFull != 0 {
		n += 1 + sovTcpProxy(uint64(m.RnmdrFull))
	}
	if m.InvalidSesqDescr != 0 {
		n += 1 + sovTcpProxy(uint64(m.InvalidSesqDescr))
	}
	if m.InvalidRetxSesqDescr != 0 {
		n += 1 + sovTcpProxy(uint64(m.InvalidRetxSesqDescr))
	}
	if m.StretchAck != 0 {
		n += 1 + sovTcpProxy(uint64(m.StretchAck))
	}
	if m.RetxNopSchedule != 0 {
		n += 1 + sovTcpProxy(uint64(m.RetxNopSchedule))
	}
	if m.GcFull != 0 {
		n += 1 + sovTcpProxy(uint64(m.GcFull))
	}
	if m.TlsGcFull != 0 {
		n += 1 + sovTcpProxy(uint64(m.TlsGcFull))
	}
	return n
}

func sovTcpProxy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTcpProxy(x uint64) (n int) {
	return sovTcpProxy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TcpProxySessionFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionFilter == nil {
				m.SessionFilter = &TcpProxySessionFilter{}
			}
			if err := m.SessionFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpproxyFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: tcpproxy_flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: tcpproxy_flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qid1", wireType)
			}
			m.Qid1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qid1 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qid2", wireType)
			}
			m.Qid2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qid2 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowType", wireType)
			}
			m.FlowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxySessionGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpproxyFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpproxyFlow == nil {
				m.TcpproxyFlow = &TcpproxyFlow{}
			}
			if err := m.TcpproxyFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxySessionGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsProxyECDSAKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsProxyECDSAKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsProxyECDSAKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignKeyIdx", wireType)
			}
			m.SignKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignKeyIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsProxyRSAKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsProxyRSAKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsProxyRSAKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignKeyIdx", wireType)
			}
			m.SignKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignKeyIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptKeyIdx", wireType)
			}
			m.DecryptKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecryptKeyIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsProxyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsProxyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsProxyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsymKeyType", wireType)
			}
			m.AsymKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsymKeyType |= (CryptoAsymKeyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertId", wireType)
			}
			m.CertId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustRootId", wireType)
			}
			m.TrustRootId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustRootId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsProxySide", wireType)
			}
			m.TlsProxySide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TlsProxySide |= (TlsProxySide(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcdsaKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsProxyECDSAKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keys = &TlsProxyAction_EcdsaKey{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsProxyRSAKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keys = &TlsProxyAction_RsaKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpProxyActionType", wireType)
			}
			m.TcpProxyActionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpProxyActionType |= (TcpProxyActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyType", wireType)
			}
			m.ProxyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyType |= (ProxyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsProxyAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProxyConfig = &TcpProxyAction_Tls{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleMatchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleMatchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleMatchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpProxyAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpProxyAction == nil {
				m.TcpProxyAction = &TcpProxyAction{}
			}
			if err := m.TcpProxyAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &TcpProxyRuleMatchSpec{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpProxyRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleEntryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleEntryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleEntryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &TcpProxyRuleEntryStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TcpProxyRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpProxyRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TcpProxyRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpcbId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &TcpProxyCbKeyHandle_TcpcbId{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpcbHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &TcpProxyCbKeyHandle_TcpcbHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvNxt", wireType)
			}
			m.RcvNxt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvNxt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndNxt", wireType)
			}
			m.SndNxt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndNxt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndUna", wireType)
			}
			m.SndUna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndUna |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvTsval", wireType)
			}
			m.RcvTsval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvTsval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsRecent", wireType)
			}
			m.TsRecent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsRecent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqBase", wireType)
			}
			m.SerqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SerqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDol", wireType)
			}
			m.DebugDol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqBase", wireType)
			}
			m.SesqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SesqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqPi", wireType)
			}
			m.SesqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqPi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqCi", wireType)
			}
			m.SesqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWnd", wireType)
			}
			m.SndWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndCwnd", wireType)
			}
			m.SndCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndCwnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvMss", wireType)
			}
			m.RcvMss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvMss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			m.SourcePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourcePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPort", wireType)
			}
			m.DestPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderTemplate = append(m.HeaderTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderTemplate == nil {
				m.HeaderTemplate = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLif", wireType)
			}
			m.SourceLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqBase", wireType)
			}
			m.AsesqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AsesqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqPi", wireType)
			}
			m.AsesqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsesqPi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqCi", wireType)
			}
			m.AsesqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsesqCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDolTx", wireType)
			}
			m.DebugDolTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDolTx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderLen", wireType)
			}
			m.HeaderLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingAckSend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PendingAckSend = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7ProxyType", wireType)
			}
			m.L7ProxyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7ProxyType |= (AppRedirType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqRetxCi", wireType)
			}
			m.SesqRetxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqRetxCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxSndUna", wireType)
			}
			m.RetxSndUna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxSndUna |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxTs", wireType)
			}
			m.RxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rto", wireType)
			}
			m.Rto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rto |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndCwndCnt", wireType)
			}
			m.SndCwndCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndCwndCnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDolTblsetaddr", wireType)
			}
			m.DebugDolTblsetaddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDolTblsetaddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqPi", wireType)
			}
			m.SerqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqPi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredFlags", wireType)
			}
			m.PredFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherQid", wireType)
			}
			m.OtherQid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherQid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsOut", wireType)
			}
			m.PacketsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsOut |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoPi", wireType)
			}
			m.RtoPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtoPi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxTimerCi", wireType)
			}
			m.RetxTimerCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxTimerCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoBackoff", wireType)
			}
			m.RtoBackoff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtoBackoff |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuId", wireType)
			}
			m.CpuId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqCi", wireType)
			}
			m.SerqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWnd", wireType)
			}
			m.RcvWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWscale", wireType)
			}
			m.SndWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWscale |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWscale", wireType)
			}
			m.RcvWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWscale |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqTxCi", wireType)
			}
			m.SesqTxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqTxCi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyCbSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpcbHandle", wireType)
			}
			m.TcpcbHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TcpcbHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpcbStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpcbStatus == nil {
				m.TcpcbStatus = &TcpProxyCbStatus{}
			}
			if err := m.TcpcbStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyCbResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyCbDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTcpProxy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTcpProxy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTcpProxy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTcpProxy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &TcpProxyCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyCbGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRcvd", wireType)
			}
			m.BytesRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRcvd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsRcvd", wireType)
			}
			m.PktsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsRcvd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesAlloced", wireType)
			}
			m.PagesAlloced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesAlloced |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescAlloced", wireType)
			}
			m.DescAlloced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescAlloced |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugNumPktToMem", wireType)
			}
			m.DebugNumPktToMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugNumPktToMem |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugNumPhvToMem", wireType)
			}
			m.DebugNumPhvToMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugNumPhvToMem |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomicDelta", wireType)
			}
			m.DebugAtomicDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomicDelta |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic0Incr1247", wireType)
			}
			m.DebugAtomic0Incr1247 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic0Incr1247 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic1Incr247", wireType)
			}
			m.DebugAtomic1Incr247 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic1Incr247 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic2Incr47", wireType)
			}
			m.DebugAtomic2Incr47 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic2Incr47 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic3Incr47", wireType)
			}
			m.DebugAtomic3Incr47 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic3Incr47 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic4Incr7", wireType)
			}
			m.DebugAtomic4Incr7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic4Incr7 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic5Incr7", wireType)
			}
			m.DebugAtomic5Incr7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic5Incr7 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugAtomic6Incr7", wireType)
			}
			m.DebugAtomic6Incr7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugAtomic6Incr7 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesAcked", wireType)
			}
			m.BytesAcked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesAcked |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowPathCnt", wireType)
			}
			m.SlowPathCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowPathCnt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqFullCnt", wireType)
			}
			m.SerqFullCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqFullCnt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OooCnt", wireType)
			}
			m.OooCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OooCnt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsSent", wireType)
			}
			m.PktsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugNumPhvToPkt", wireType)
			}
			m.DebugNumPhvToPkt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugNumPhvToPkt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10004:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugNumMemToPkt", wireType)
			}
			m.DebugNumMemToPkt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugNumMemToPkt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TcpProxyCbSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpProxyCbStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TcpProxyCbStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyCbGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyCbGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyCbGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxyCbGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStatsGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			m.Dummy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dummy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStatsGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyGlobalStatsGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStatsGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalStats == nil {
				m.GlobalStats = &TcpProxyGlobalStats{}
			}
			if err := m.GlobalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RnmdrFull", wireType)
			}
			m.RnmdrFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RnmdrFull |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidSesqDescr", wireType)
			}
			m.InvalidSesqDescr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidSesqDescr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidRetxSesqDescr", wireType)
			}
			m.InvalidRetxSesqDescr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidRetxSesqDescr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StretchAck", wireType)
			}
			m.StretchAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StretchAck |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxNopSchedule", wireType)
			}
			m.RetxNopSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxNopSchedule |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcFull", wireType)
			}
			m.GcFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcFull |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsGcFull", wireType)
			}
			m.TlsGcFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TlsGcFull |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTcpProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTcpProxy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTcpProxy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTcpProxy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTcpProxy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTcpProxy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTcpProxy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTcpProxy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tcp_proxy.proto", fileDescriptorTcpProxy) }

var fileDescriptorTcpProxy = []byte{
	// 2985 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x5b, 0x6f, 0xdb, 0xc8,
	0xf5, 0xb7, 0x7c, 0x91, 0xe5, 0x91, 0x25, 0x3b, 0x63, 0x3b, 0xa6, 0xed, 0xf8, 0x12, 0x66, 0x93,
	0xf8, 0x9f, 0xcd, 0x7a, 0x13, 0xc7, 0x5e, 0x63, 0xaf, 0x7f, 0xc8, 0xb2, 0x93, 0x08, 0x89, 0x2f,
	0x7f, 0x4a, 0xbb, 0xd9, 0x0d, 0xfe, 0x5b, 0x96, 0x22, 0xc7, 0x16, 0x21, 0x8a, 0xa4, 0x39, 0x23,
	0xc7, 0xfa, 0x00, 0x7d, 0x2b, 0x0a, 0xb4, 0x5b, 0xa0, 0x4f, 0x45, 0x1f, 0xfa, 0x35, 0xfa, 0x01,
	0xfa, 0x58, 0xf4, 0x03, 0x04, 0xed, 0x3e, 0xee, 0xe3, 0x3e, 0x16, 0x28, 0x50, 0x9c, 0x99, 0xa1,
	0x48, 0x4a, 0x94, 0xed, 0xed, 0xe6, 0xc9, 0x9a, 0x73, 0xce, 0xef, 0xcc, 0xcc, 0x99, 0x33, 0xe7,
	0x32, 0x34, 0x9a, 0x62, 0xa6, 0xaf, 0xfb, 0x81, 0x77, 0xd1, 0xd9, 0xf0, 0x03, 0x8f, 0x79, 0x78,
	0xa2, 0x4b, 0x58, 0xcc, 0xb3, 0x8e, 0x4f, 0xa8, 0xa0, 0x2f, 0xe6, 0x9a, 0x0d, 0xf1, 0x4b, 0xfd,
	0x4b, 0x06, 0xcd, 0xd5, 0x4c, 0xff, 0x18, 0x64, 0xaa, 0x84, 0x52, 0xdb, 0x73, 0x9f, 0xda, 0x0e,
	0x23, 0x01, 0xbe, 0x8f, 0xb2, 0x34, 0x30, 0x75, 0xdb, 0x57, 0x32, 0x6b, 0x99, 0xf5, 0xfc, 0xe6,
	0xf4, 0x86, 0xd0, 0x50, 0x39, 0x2e, 0x59, 0x56, 0x40, 0x28, 0xd5, 0xc6, 0x68, 0x60, 0x56, 0x7c,
	0x10, 0xb4, 0x28, 0x03, 0xc1, 0xe1, 0x41, 0x82, 0x16, 0x65, 0x15, 0x1f, 0x2f, 0xa0, 0x1c, 0x68,
	0xf4, 0xbd, 0x80, 0x29, 0x23, 0x6b, 0x99, 0xf5, 0x82, 0x36, 0x4e, 0x03, 0xf3, 0xd8, 0x0b, 0x18,
	0xb0, 0x40, 0x07, 0x67, 0x8d, 0x0a, 0x96, 0x45, 0x19, 0x67, 0x2d, 0xa1, 0x89, 0x96, 0xc1, 0xcc,
	0x86, 0x6e, 0x38, 0x8e, 0x32, 0xb6, 0x96, 0x59, 0xcf, 0x69, 0x39, 0x4e, 0x28, 0x39, 0x8e, 0x6a,
	0xa1, 0x85, 0x9e, 0xd5, 0x3f, 0x23, 0x4c, 0x23, 0x67, 0x6d, 0x42, 0x19, 0x7e, 0x86, 0x8a, 0x54,
	0x10, 0xf5, 0x13, 0xbe, 0x27, 0xb9, 0x93, 0xb5, 0x8d, 0xc8, 0x4e, 0xa9, 0x7b, 0xd7, 0x0a, 0x34,
	0x3e, 0x54, 0xff, 0x9e, 0x41, 0x05, 0x66, 0xfa, 0x1c, 0xa1, 0x9f, 0x38, 0xde, 0x1b, 0x8c, 0xd1,
	0xe8, 0x99, 0x6d, 0x3d, 0xe6, 0x0a, 0x47, 0x35, 0xfe, 0x5b, 0xd2, 0x36, 0xb9, 0x15, 0x04, 0x6d,
	0x33, 0x66, 0xc4, 0x91, 0xeb, 0x1a, 0x71, 0xf4, 0x72, 0x23, 0xce, 0xa2, 0x31, 0xca, 0xcd, 0x34,
	0xc6, 0xcd, 0x24, 0x06, 0x40, 0xb5, 0x38, 0x35, 0x2b, 0xa8, 0x7c, 0x00, 0xa6, 0x83, 0xd5, 0xea,
	0xa0, 0x4a, 0x19, 0xe7, 0x9c, 0x1c, 0x10, 0x6a, 0x1d, 0x9f, 0xa8, 0xbf, 0x40, 0xb7, 0x06, 0x9a,
	0xee, 0x80, 0x9e, 0xe2, 0x2f, 0xd0, 0x78, 0x20, 0x46, 0x4a, 0x66, 0x6d, 0x64, 0x3d, 0xbf, 0xf9,
	0xde, 0x60, 0xb3, 0x45, 0x48, 0x2d, 0x04, 0xa9, 0xbf, 0xce, 0xa0, 0xc5, 0x34, 0x31, 0xea, 0x7b,
	0x2e, 0x25, 0xf8, 0x43, 0x84, 0x0c, 0xdf, 0xd6, 0x29, 0x33, 0x58, 0x9b, 0x72, 0x3b, 0x16, 0xbb,
	0x9b, 0x2e, 0xf9, 0x76, 0x95, 0xd3, 0xb5, 0x09, 0x23, 0xfc, 0x89, 0x3f, 0xef, 0x39, 0x03, 0xe9,
	0x6d, 0x4a, 0x6c, 0x55, 0x09, 0xbe, 0x36, 0x19, 0x0e, 0x9f, 0x3a, 0xde, 0x1b, 0xf5, 0xbb, 0x0c,
	0x5a, 0x1e, 0xbc, 0x1c, 0xd8, 0xf0, 0x4f, 0x5e, 0x51, 0x09, 0xe5, 0x02, 0x89, 0x57, 0x86, 0xb9,
	0x89, 0xee, 0x5e, 0x61, 0x22, 0x21, 0xac, 0x75, 0x61, 0xea, 0x16, 0x9a, 0xae, 0x39, 0x94, 0xcb,
	0xed, 0x97, 0xf7, 0xaa, 0xa5, 0x17, 0xa4, 0x83, 0xd7, 0xd0, 0x24, 0xb5, 0x4f, 0x5d, 0xbd, 0x49,
	0x3a, 0xba, 0x6d, 0x5d, 0xf0, 0x95, 0x14, 0x34, 0x04, 0xb4, 0x17, 0xa4, 0x53, 0xb1, 0x2e, 0xd4,
	0xd7, 0xa8, 0x18, 0xa2, 0xb4, 0x6b, 0x62, 0xf0, 0x3d, 0x34, 0x65, 0x11, 0x33, 0xe8, 0xf8, 0xac,
	0x2b, 0x34, 0xcc, 0x85, 0x0a, 0x92, 0x2c, 0x75, 0xbf, 0x1d, 0x8e, 0x94, 0x97, 0x4c, 0x66, 0x7b,
	0x2e, 0xfe, 0x0c, 0x15, 0x0c, 0xda, 0x69, 0x71, 0x1c, 0x77, 0x25, 0x61, 0x1b, 0x45, 0xda, 0xa6,
	0x0c, 0x68, 0xaf, 0x44, 0x3b, 0xad, 0x17, 0xa4, 0x03, 0xae, 0xa5, 0xe5, 0x8d, 0x68, 0x80, 0xe7,
	0xd1, 0xb8, 0x49, 0x02, 0xa6, 0xdb, 0x96, 0x9c, 0x30, 0x0b, 0xc3, 0x8a, 0x85, 0x55, 0x54, 0x60,
	0x41, 0x9b, 0x32, 0x3d, 0xf0, 0x3c, 0xce, 0x16, 0x31, 0x21, 0xcf, 0x89, 0x9a, 0xe7, 0x81, 0x8c,
	0x82, 0xc6, 0x4d, 0xdb, 0x6f, 0x90, 0x80, 0xf2, 0x7b, 0x31, 0xa1, 0x85, 0x43, 0xfc, 0x39, 0x2a,
	0x32, 0x87, 0x0a, 0x5b, 0xeb, 0xd4, 0xb6, 0x08, 0xbf, 0x10, 0xc5, 0xcd, 0xf9, 0xf8, 0x11, 0xc8,
	0x7d, 0x54, 0x6d, 0x8b, 0x68, 0x93, 0x2c, 0x36, 0xc2, 0x9f, 0xa0, 0x09, 0x62, 0x5a, 0xd4, 0x80,
	0x4d, 0xf1, 0x4b, 0x93, 0xdf, 0x5c, 0x4a, 0x41, 0x86, 0x87, 0xf2, 0x7c, 0x48, 0xcb, 0x71, 0x79,
	0x30, 0xf6, 0x16, 0x1a, 0x0f, 0x24, 0x72, 0x9c, 0x23, 0x17, 0x52, 0x90, 0x5a, 0x88, 0xcb, 0x06,
	0x1c, 0xb5, 0x9b, 0x45, 0xa3, 0x2f, 0x48, 0x87, 0x42, 0x30, 0x29, 0x86, 0xbe, 0x21, 0x0d, 0x7c,
	0x8c, 0xe6, 0xba, 0x0a, 0x74, 0x83, 0xd3, 0xe2, 0x86, 0x5e, 0x4e, 0xf1, 0x2a, 0x81, 0xe4, 0xd6,
	0xc6, 0xac, 0x8f, 0x06, 0xbe, 0x2c, 0xb4, 0x71, 0x35, 0xc3, 0x09, 0x5f, 0xe6, 0xb2, 0x1c, 0x39,
	0xe1, 0x87, 0x3f, 0xf1, 0x07, 0x68, 0x84, 0x39, 0x54, 0x46, 0xa9, 0xb4, 0xfd, 0x08, 0xe5, 0xcf,
	0x87, 0x34, 0x90, 0xdb, 0x2d, 0xa2, 0x49, 0xa1, 0xdf, 0xf4, 0xdc, 0x13, 0xfb, 0x54, 0xfd, 0x63,
	0x2c, 0x8d, 0x68, 0x6d, 0x87, 0x1c, 0x40, 0x80, 0xae, 0xfa, 0xc4, 0x84, 0xe3, 0x0f, 0xda, 0x0e,
	0x81, 0xf3, 0x15, 0xc1, 0x32, 0x0b, 0xc3, 0x8a, 0x85, 0xef, 0xa1, 0x31, 0x1e, 0xc6, 0x7b, 0xb2,
	0x46, 0x17, 0xad, 0x09, 0x36, 0x2e, 0xa3, 0xe9, 0x5e, 0xe3, 0xa4, 0x2d, 0x33, 0x61, 0x03, 0xad,
	0x98, 0xb4, 0x89, 0xfa, 0xcf, 0x0c, 0x9a, 0x8e, 0xaf, 0x8f, 0x2f, 0xed, 0x00, 0x15, 0xc0, 0xa5,
	0xbd, 0x40, 0x6f, 0x18, 0xae, 0xe5, 0x10, 0x99, 0x1e, 0x16, 0x36, 0x9a, 0x8d, 0x8d, 0xb8, 0x30,
	0x9c, 0x23, 0x17, 0xd8, 0x2d, 0xfe, 0xf8, 0x76, 0x15, 0x9d, 0x13, 0xd7, 0x36, 0xc9, 0x27, 0x4d,
	0xd2, 0xd1, 0xf2, 0x4d, 0xd2, 0x39, 0x0a, 0x04, 0x13, 0x3f, 0x45, 0xc5, 0xf3, 0xe0, 0x84, 0xdf,
	0x12, 0xa9, 0x2f, 0xdc, 0x59, 0xb3, 0xb1, 0xf1, 0x55, 0x70, 0x92, 0xae, 0x26, 0x20, 0x27, 0xda,
	0xe4, 0x79, 0x8c, 0x8b, 0x3f, 0x42, 0x63, 0x60, 0x22, 0x38, 0x8c, 0x91, 0x01, 0xd9, 0x2a, 0x61,
	0x62, 0x4d, 0x88, 0xab, 0x47, 0xe8, 0x66, 0x9c, 0x1f, 0x0b, 0xe5, 0xdb, 0xbd, 0xa1, 0x7c, 0x69,
	0x80, 0x4e, 0xae, 0xae, 0x1b, 0xc1, 0x1f, 0x22, 0x9c, 0x60, 0x8a, 0xa8, 0x77, 0x13, 0x65, 0x63,
	0xe6, 0xca, 0x6a, 0x72, 0xa4, 0xfe, 0x26, 0x83, 0x66, 0x93, 0xf3, 0xcb, 0x48, 0xff, 0xbf, 0xd7,
	0x89, 0xab, 0xbb, 0xc5, 0x1f, 0xde, 0xae, 0xc6, 0xe4, 0xe2, 0x71, 0x76, 0x1b, 0x65, 0x25, 0x58,
	0x18, 0x74, 0x79, 0xd0, 0xea, 0x05, 0x52, 0x0a, 0xab, 0x5f, 0xa1, 0xf9, 0xb4, 0xf5, 0x80, 0x41,
	0x3e, 0x8d, 0x45, 0x6e, 0x61, 0x91, 0xd5, 0x01, 0x3a, 0x53, 0x62, 0xf6, 0xeb, 0xa8, 0xe6, 0x00,
	0x89, 0x3d, 0xe2, 0x10, 0x16, 0x5a, 0x1b, 0xb2, 0xd4, 0x4f, 0xf3, 0xa9, 0x84, 0x0f, 0xc5, 0x93,
	0x72, 0x9f, 0xee, 0x6b, 0x27, 0xe5, 0x3e, 0x64, 0x74, 0xa4, 0x56, 0x94, 0x93, 0xe3, 0x52, 0xf2,
	0xa4, 0x9e, 0x5e, 0xeb, 0xa4, 0xe6, 0x7e, 0x7c, 0xbb, 0x7a, 0x43, 0x7a, 0x6f, 0xea, 0x81, 0xa9,
	0xf5, 0x28, 0xd5, 0xf6, 0xcf, 0x02, 0xdb, 0x28, 0xf5, 0xd9, 0xff, 0xee, 0x15, 0xfb, 0xe8, 0x3b,
	0x85, 0x57, 0x49, 0x6f, 0x8f, 0x95, 0x7d, 0x3f, 0xf3, 0x08, 0xbe, 0x4e, 0x1e, 0x6f, 0xb2, 0x28,
	0xfa, 0xb4, 0xd7, 0xfe, 0xb7, 0x07, 0xac, 0x3b, 0xad, 0x22, 0xf2, 0x93, 0x4b, 0xde, 0x77, 0x59,
	0xd0, 0x01, 0x8b, 0x51, 0xbc, 0x8e, 0xa6, 0xdd, 0x76, 0x4b, 0x07, 0x55, 0xb2, 0xf2, 0xa4, 0x32,
	0x85, 0x17, 0xdd, 0x76, 0xab, 0x66, 0xfa, 0xb2, 0x88, 0xa0, 0xf8, 0x21, 0xc2, 0x20, 0xe9, 0xb1,
	0x06, 0x09, 0x22, 0x59, 0x91, 0x58, 0x41, 0xc7, 0x11, 0x30, 0x42, 0x69, 0xf5, 0x25, 0xba, 0xd1,
	0x7b, 0x41, 0x28, 0xde, 0x41, 0x63, 0x70, 0x64, 0xf4, 0x8a, 0x1d, 0x44, 0xcb, 0xd3, 0x84, 0xbc,
	0xfa, 0xef, 0x4c, 0xf2, 0x46, 0xc5, 0xcb, 0xb9, 0x77, 0xe4, 0x3a, 0xf8, 0x43, 0x34, 0x4a, 0x7d,
	0x62, 0xca, 0x9b, 0x7e, 0x69, 0x9c, 0xe2, 0x82, 0xb1, 0xe0, 0x30, 0xf2, 0x13, 0x82, 0x03, 0xde,
	0x0c, 0x8d, 0x20, 0xca, 0xed, 0x5b, 0x97, 0xa0, 0xba, 0xfb, 0xff, 0xff, 0xe4, 0xe5, 0xe9, 0x29,
	0x1f, 0xbf, 0xe8, 0xf3, 0x69, 0xf5, 0x32, 0xdf, 0xe8, 0x73, 0xe8, 0x06, 0x9a, 0x09, 0x85, 0xca,
	0xf5, 0x28, 0x1b, 0x2c, 0xa1, 0x1c, 0x33, 0x7d, 0xb3, 0x1e, 0x26, 0xd0, 0xc2, 0xf3, 0x21, 0x6d,
	0x9c, 0x53, 0x2a, 0x16, 0xbe, 0x83, 0x26, 0x05, 0x33, 0x96, 0x70, 0xb2, 0xcf, 0x87, 0xb4, 0x3c,
	0xa7, 0xca, 0x6c, 0x33, 0xd5, 0x73, 0x1f, 0xd4, 0x7f, 0xa1, 0xa8, 0x02, 0x29, 0xd7, 0x79, 0x2a,
	0xdc, 0x4d, 0xbf, 0x33, 0x2b, 0x29, 0x3b, 0x88, 0x2d, 0x2e, 0x99, 0xff, 0x20, 0xd3, 0x9b, 0xe7,
	0xba, 0x7b, 0xc1, 0xc2, 0x42, 0x2f, 0x30, 0xcf, 0x0f, 0x2f, 0x18, 0x30, 0xa8, 0x6b, 0x71, 0x86,
	0x28, 0xf1, 0xb2, 0xd4, 0xb5, 0x62, 0x8c, 0xb6, 0x6b, 0xc8, 0xa6, 0x0f, 0x18, 0x5f, 0xba, 0x06,
	0x34, 0x2e, 0xa0, 0x8a, 0xd1, 0x73, 0xc3, 0x91, 0x8d, 0x4e, 0x2e, 0x30, 0xcf, 0x6b, 0x30, 0x06,
	0x26, 0xa3, 0x7a, 0x40, 0x4c, 0xe2, 0x86, 0xfd, 0x4e, 0x8e, 0x51, 0x8d, 0x8f, 0x81, 0x49, 0x49,
	0x70, 0xa6, 0xd7, 0x0d, 0x2a, 0x5a, 0x9e, 0xac, 0x96, 0x03, 0xc2, 0xae, 0x41, 0xc1, 0x96, 0x13,
	0x16, 0xa9, 0xb7, 0x4f, 0x75, 0xcb, 0x73, 0x94, 0x9c, 0x40, 0x72, 0xc2, 0x9e, 0xe7, 0x08, 0x24,
	0x95, 0xc8, 0x89, 0x10, 0x49, 0x05, 0x12, 0x56, 0x0a, 0x4c, 0xdf, 0x56, 0x90, 0x5c, 0x29, 0xa1,
	0x67, 0xc7, 0x76, 0x97, 0x61, 0xda, 0x4a, 0x3e, 0x62, 0x94, 0xed, 0x70, 0x6f, 0x6f, 0x5c, 0x4b,
	0x99, 0xec, 0xee, 0xed, 0x95, 0x6b, 0xf1, 0x2e, 0xd8, 0xb5, 0x74, 0x13, 0x38, 0x05, 0xd9, 0x05,
	0xbb, 0x56, 0xf9, 0x8d, 0x6b, 0x85, 0x16, 0x6c, 0x51, 0xaa, 0x14, 0xbb, 0x16, 0x3c, 0xa0, 0x14,
	0xaf, 0xa2, 0x3c, 0xf5, 0xda, 0x81, 0x49, 0x44, 0x87, 0x3c, 0x25, 0xab, 0x7b, 0x4e, 0x0a, 0x9b,
	0x64, 0x8b, 0x84, 0x0d, 0xf4, 0x74, 0xb8, 0x33, 0xd9, 0x41, 0xdf, 0x47, 0x53, 0x0d, 0x62, 0x58,
	0x24, 0xd0, 0x19, 0x69, 0xf9, 0x8e, 0xc1, 0x88, 0x72, 0x63, 0x2d, 0xb3, 0x3e, 0xa9, 0x15, 0x05,
	0xb9, 0x26, 0xa9, 0xbc, 0xb7, 0x64, 0xc0, 0xc6, 0xb2, 0xb7, 0x84, 0x01, 0x5e, 0x46, 0x72, 0x26,
	0xdd, 0xb1, 0x4f, 0x94, 0x19, 0xce, 0x9a, 0x10, 0x94, 0x97, 0xf6, 0x09, 0xb0, 0x8d, 0xc8, 0x70,
	0xb3, 0xdc, 0x70, 0x13, 0x46, 0xd7, 0x72, 0x0b, 0x28, 0x67, 0x84, 0xa6, 0x9b, 0x13, 0xdb, 0x35,
	0xa4, 0xed, 0xba, 0x2c, 0xd3, 0x56, 0x6e, 0xc6, 0x58, 0x65, 0x1b, 0xfa, 0x99, 0xee, 0x49, 0xe9,
	0xec, 0x42, 0x99, 0x17, 0x3b, 0x0e, 0x0f, 0xab, 0x76, 0x01, 0xd3, 0xca, 0x4d, 0x39, 0xc4, 0x55,
	0x14, 0xb1, 0x2a, 0x41, 0x79, 0x49, 0x5c, 0x88, 0xa8, 0x3e, 0x71, 0x2d, 0xdb, 0x3d, 0xd5, 0x0d,
	0xb3, 0xa9, 0x53, 0xe2, 0x5a, 0xca, 0x02, 0x7f, 0x3c, 0x28, 0x4a, 0x7a, 0xc9, 0x6c, 0x56, 0x89,
	0x6b, 0xe1, 0x1d, 0x54, 0x70, 0x76, 0xf4, 0x58, 0xb5, 0xbc, 0xc8, 0x83, 0xd7, 0x4c, 0x37, 0x78,
	0xf9, 0x1a, 0xb1, 0xec, 0x40, 0x34, 0x36, 0xce, 0x4e, 0xb7, 0x7a, 0xe6, 0x3d, 0x17, 0xac, 0x3e,
	0x20, 0xec, 0x02, 0xb6, 0xb0, 0x24, 0x4f, 0x85, 0xd0, 0x33, 0x8d, 0xb0, 0x0b, 0xb1, 0x0b, 0xce,
	0x0c, 0x9d, 0xfc, 0x16, 0x2f, 0x80, 0x11, 0xd0, 0xaa, 0xc2, 0xd1, 0x67, 0xd0, 0x58, 0x70, 0xa1,
	0x33, 0xaa, 0x2c, 0x8b, 0x47, 0x83, 0xe0, 0xa2, 0x46, 0xf1, 0x34, 0x1a, 0x09, 0x98, 0xa7, 0xac,
	0x70, 0x12, 0xfc, 0xe4, 0x53, 0x49, 0x9f, 0xd1, 0x4d, 0x97, 0x29, 0xab, 0x72, 0x2a, 0xe1, 0x37,
	0x65, 0x97, 0xe1, 0x47, 0x68, 0x36, 0x66, 0xb0, 0xba, 0x43, 0x09, 0x33, 0x2c, 0x2b, 0x50, 0xd6,
	0xb8, 0x24, 0xee, 0x1a, 0xae, 0xcb, 0x11, 0x9e, 0x1b, 0xf0, 0x73, 0xb9, 0x1d, 0x7a, 0x6e, 0x00,
	0xc7, 0xb2, 0x0c, 0xbd, 0x03, 0xb1, 0xf4, 0x13, 0xc7, 0x38, 0xa5, 0x8a, 0x2a, 0x2c, 0x0b, 0x94,
	0xa7, 0x40, 0x00, 0x57, 0x13, 0xd9, 0xe7, 0xcc, 0xb6, 0x94, 0x3b, 0xc2, 0xd5, 0x38, 0xe1, 0xff,
	0x6c, 0x0b, 0x1c, 0xd5, 0x37, 0xcc, 0x26, 0x61, 0x54, 0xf7, 0xda, 0x4c, 0x79, 0x4f, 0xac, 0x53,
	0x92, 0x8e, 0xda, 0x0c, 0xcf, 0xa1, 0x6c, 0xc0, 0x3c, 0x98, 0xf4, 0xae, 0xf0, 0xb1, 0x80, 0x79,
	0xc7, 0x36, 0xf4, 0x82, 0xdc, 0x52, 0xcc, 0x6e, 0x91, 0x00, 0x8c, 0x79, 0x4f, 0xf4, 0x82, 0x40,
	0xac, 0x01, 0xad, 0x6c, 0x83, 0x6e, 0x80, 0xd6, 0x0d, 0xb3, 0xe9, 0x9d, 0x9c, 0x28, 0xf7, 0x85,
	0xee, 0x80, 0x79, 0xbb, 0x82, 0x02, 0xba, 0x4d, 0xbf, 0x0d, 0x81, 0x72, 0x5d, 0xe8, 0x36, 0xfd,
	0x76, 0xc5, 0xea, 0x6e, 0xd4, 0xb4, 0x95, 0xff, 0x89, 0x36, 0x2a, 0xae, 0x28, 0x5c, 0x37, 0xb8,
	0x88, 0x0f, 0xba, 0xd7, 0x0d, 0xae, 0x28, 0x78, 0x3c, 0xdc, 0x5d, 0x6a, 0x1a, 0x0e, 0x51, 0xde,
	0x97, 0x1e, 0xef, 0x5a, 0xaf, 0x38, 0x01, 0xd8, 0x1c, 0x27, 0xd8, 0x0f, 0x05, 0x1b, 0xa0, 0x82,
	0x7d, 0x0b, 0x71, 0x1f, 0xd0, 0x85, 0x57, 0x7c, 0x20, 0x2c, 0x04, 0x94, 0xda, 0x45, 0xd9, 0x56,
	0x5f, 0x44, 0x55, 0x72, 0xb9, 0x1e, 0xab, 0x2c, 0x9e, 0xf4, 0x56, 0x16, 0x0b, 0xa9, 0xb1, 0x37,
	0x59, 0xa1, 0x6f, 0x47, 0x5d, 0x4d, 0xb9, 0x2e, 0x33, 0xe8, 0xed, 0x9e, 0x9c, 0x20, 0xaa, 0xf4,
	0x78, 0x46, 0x50, 0x7f, 0x95, 0x89, 0x2a, 0x7b, 0x58, 0xc4, 0x7f, 0xfb, 0x24, 0xf3, 0x45, 0x38,
	0x55, 0xa2, 0x3c, 0x5f, 0x4a, 0x5f, 0xb8, 0x40, 0x8b, 0x75, 0xc8, 0x3a, 0x51, 0x8b, 0x9a, 0xc6,
	0x68, 0x19, 0x60, 0x8c, 0x8f, 0xfb, 0x72, 0xe9, 0x72, 0xaa, 0xd2, 0x94, 0x34, 0xfa, 0x6d, 0x54,
	0xa3, 0x94, 0xeb, 0xc9, 0xda, 0xfc, 0x1d, 0x24, 0x39, 0xf5, 0x75, 0x54, 0x03, 0xf4, 0xa8, 0x87,
	0x75, 0x7f, 0xd6, 0x7b, 0x88, 0x6a, 0xaa, 0xee, 0x01, 0xc5, 0xf9, 0x21, 0x5a, 0xea, 0x97, 0x19,
	0xfc, 0x3e, 0x35, 0x72, 0xc5, 0xf1, 0xa8, 0xaf, 0xe3, 0xae, 0x16, 0x2b, 0x90, 0xdf, 0x85, 0x1d,
	0x6a, 0x71, 0x33, 0x27, 0x6b, 0xe4, 0x8f, 0x7b, 0x8d, 0xb0, 0x9a, 0xaa, 0x38, 0xad, 0x42, 0xfe,
	0xf3, 0x38, 0x9a, 0x4a, 0xba, 0x0c, 0x85, 0xdb, 0x56, 0xef, 0x30, 0x42, 0xf5, 0xc0, 0x3c, 0x0f,
	0xdf, 0x10, 0x26, 0x38, 0x45, 0x33, 0xcf, 0x2d, 0x08, 0x47, 0x7e, 0x93, 0x49, 0xae, 0x78, 0x7a,
	0xcd, 0x01, 0x81, 0x33, 0xef, 0xa0, 0x82, 0x6f, 0x9c, 0x12, 0xaa, 0x1b, 0x8e, 0xe3, 0x99, 0x44,
	0x3c, 0x31, 0x8d, 0x6a, 0x93, 0x9c, 0x58, 0x12, 0x34, 0xb8, 0x30, 0x16, 0xa1, 0x66, 0x57, 0x66,
	0x94, 0xcb, 0xe4, 0x81, 0x16, 0x8a, 0x6c, 0x84, 0xd1, 0x15, 0x6a, 0x6f, 0xbf, 0xc9, 0x74, 0xe6,
	0xe9, 0x2d, 0xd2, 0xe2, 0xa5, 0xc9, 0xa8, 0x36, 0xcd, 0x79, 0x87, 0xed, 0xd6, 0x71, 0x93, 0xd5,
	0xbc, 0x03, 0xd2, 0xea, 0x91, 0x6f, 0x9c, 0x87, 0xf2, 0xd9, 0x1e, 0xf9, 0xc6, 0xb9, 0x90, 0x7f,
	0x88, 0x44, 0x84, 0xd6, 0x0d, 0xe6, 0xb5, 0x6c, 0x53, 0xb7, 0x88, 0xc3, 0x0c, 0x59, 0xa1, 0x08,
	0xe9, 0x12, 0x67, 0xec, 0x01, 0x1d, 0x6f, 0xa1, 0x9b, 0x71, 0xe9, 0x47, 0xba, 0xed, 0x9a, 0xc1,
	0xe3, 0xcd, 0xad, 0x1d, 0x5e, 0xb6, 0x14, 0xb4, 0xd9, 0x18, 0xe2, 0x51, 0x45, 0xf2, 0xf0, 0x26,
	0x9a, 0x8b, 0xa3, 0x1e, 0x73, 0x14, 0x80, 0x44, 0x41, 0x33, 0x13, 0x03, 0x3d, 0xae, 0x08, 0x56,
	0x94, 0x55, 0x04, 0x66, 0x93, 0x63, 0xb6, 0x76, 0x64, 0xa9, 0x83, 0x63, 0x90, 0xcd, 0x0a, 0xe7,
	0xf4, 0x22, 0x9e, 0x84, 0x88, 0xc9, 0x3e, 0xc4, 0x13, 0x89, 0xd8, 0x40, 0x33, 0x71, 0xc4, 0x16,
	0x47, 0xec, 0xc8, 0xd2, 0xe8, 0x46, 0x0c, 0xb0, 0x05, 0x80, 0x3e, 0xf9, 0x6d, 0x29, 0x5f, 0xec,
	0x93, 0xdf, 0x4e, 0x95, 0xff, 0x48, 0xca, 0x4f, 0xf5, 0xc9, 0x7f, 0x24, 0xe4, 0x57, 0x51, 0x5e,
	0xf8, 0x1b, 0x24, 0x2d, 0x8b, 0x17, 0x53, 0xa3, 0x9a, 0x70, 0xc1, 0x12, 0x50, 0x20, 0x57, 0x51,
	0xc7, 0x7b, 0xa3, 0xfb, 0x06, 0x6b, 0xf0, 0x6c, 0x7c, 0x43, 0x38, 0x0c, 0x10, 0x8f, 0x0d, 0xd6,
	0x80, 0x74, 0x0c, 0x32, 0x90, 0x73, 0x4e, 0xda, 0x8e, 0xc3, 0x65, 0xb0, 0x94, 0x21, 0xc1, 0xd9,
	0xd3, 0xb6, 0xe3, 0x80, 0xcc, 0x3c, 0x1a, 0xf7, 0x3c, 0x8f, 0x73, 0x67, 0xc4, 0xcb, 0x98, 0xe7,
	0x79, 0xc0, 0x58, 0x09, 0x3d, 0x9e, 0x42, 0x85, 0xfb, 0xdb, 0xc3, 0x98, 0xcb, 0x57, 0xa1, 0xc6,
	0xbd, 0x25, 0x5d, 0x9e, 0xb3, 0x7f, 0x77, 0x18, 0xf9, 0x3c, 0xe7, 0x7e, 0x98, 0xe2, 0x7b, 0x7e,
	0x93, 0x29, 0xdf, 0x1d, 0xa6, 0x38, 0xdf, 0x71, 0xb3, 0x07, 0xd0, 0x22, 0xad, 0x10, 0xf0, 0xfb,
	0x1e, 0xc0, 0x01, 0x69, 0x71, 0x80, 0xfa, 0x36, 0x13, 0x8f, 0xdb, 0x3f, 0xeb, 0x51, 0xff, 0x83,
	0x44, 0xbb, 0x77, 0x49, 0xca, 0x13, 0xcd, 0xde, 0x93, 0x9e, 0x66, 0xef, 0xd2, 0x54, 0x13, 0xb6,
	0x7a, 0x8f, 0x92, 0xad, 0xde, 0xe2, 0x40, 0x4c, 0xb7, 0xd1, 0xfb, 0x1a, 0x29, 0xa9, 0xfb, 0x13,
	0x21, 0xbe, 0x37, 0x35, 0xad, 0x0d, 0x0e, 0x6f, 0x7d, 0xd9, 0x69, 0x3b, 0x7a, 0x19, 0x79, 0xe6,
	0x78, 0x75, 0xc3, 0xe1, 0xf3, 0xc6, 0x62, 0xf3, 0x2c, 0x1a, 0xb3, 0xda, 0xad, 0x56, 0x47, 0xb6,
	0xff, 0x62, 0xa0, 0x9e, 0xa0, 0xb5, 0x4b, 0x61, 0xb0, 0xb0, 0xdd, 0xde, 0xb0, 0xbb, 0x9e, 0xb2,
	0xae, 0x54, 0x74, 0x14, 0x7f, 0xff, 0x90, 0x41, 0xb7, 0x07, 0x89, 0xfe, 0xac, 0x0f, 0x25, 0x93,
	0xa7, 0x5c, 0x9b, 0x2e, 0x0e, 0x62, 0x78, 0x60, 0xbe, 0x89, 0x4d, 0xaa, 0xe5, 0x4f, 0xa3, 0x81,
	0xfa, 0xa7, 0xe1, 0xa8, 0x3d, 0x8e, 0x09, 0xf1, 0x5a, 0xcc, 0x6d, 0x59, 0x01, 0xbf, 0x69, 0x61,
	0x76, 0xe0, 0x14, 0xb8, 0x66, 0x10, 0x58, 0x6d, 0xf7, 0xdc, 0x70, 0x6c, 0x4b, 0xe7, 0x35, 0x19,
	0x04, 0xf5, 0x40, 0xa6, 0x89, 0x69, 0xc9, 0xa9, 0x12, 0x7a, 0xb6, 0x07, 0x74, 0xbc, 0x8d, 0xe6,
	0x43, 0x69, 0x51, 0xb7, 0x47, 0x10, 0x91, 0x38, 0x66, 0x25, 0x1b, 0xea, 0xfb, 0x08, 0x06, 0xdd,
	0x19, 0x0b, 0x08, 0xff, 0x46, 0x69, 0x36, 0x65, 0xfe, 0x40, 0x92, 0x54, 0x32, 0x9b, 0xf8, 0x01,
	0xba, 0xc1, 0xf5, 0xb9, 0x9e, 0xaf, 0x53, 0xb3, 0x41, 0xac, 0xb6, 0x43, 0x64, 0xee, 0x98, 0x02,
	0xc6, 0xa1, 0xe7, 0x57, 0x25, 0x19, 0xa2, 0xc2, 0xa9, 0x29, 0x76, 0x23, 0xb2, 0x45, 0xf6, 0xd4,
	0xe4, 0x5b, 0x59, 0x41, 0x79, 0xe6, 0x50, 0x3d, 0x64, 0x8e, 0x8b, 0xad, 0x32, 0x87, 0x3e, 0xe3,
	0xfc, 0x07, 0x9d, 0xa8, 0xa6, 0x8b, 0x7d, 0x08, 0x58, 0x41, 0x8b, 0xb5, 0xf2, 0xb1, 0x7e, 0xac,
	0x1d, 0x7d, 0xfd, 0x8d, 0x5e, 0x2a, 0xd7, 0x2a, 0x47, 0x87, 0x7a, 0xed, 0x9b, 0xe3, 0x7d, 0xfd,
	0xf0, 0xe8, 0x70, 0x7f, 0x7a, 0x08, 0xaf, 0xa1, 0x5b, 0xe9, 0xfc, 0xfd, 0xc3, 0xd2, 0xee, 0xcb,
	0xfd, 0xe9, 0x0c, 0xbe, 0x8d, 0x96, 0xd3, 0x25, 0xf6, 0x2a, 0x55, 0x2e, 0x32, 0xfc, 0xe0, 0x5b,
	0x34, 0x19, 0xff, 0xd4, 0x82, 0xe7, 0xd1, 0x4c, 0xed, 0x65, 0x55, 0x42, 0xaa, 0x95, 0xbd, 0xee,
	0x6c, 0x0b, 0x68, 0xae, 0x87, 0x51, 0x7e, 0x59, 0xd9, 0x3f, 0xac, 0x4d, 0x67, 0x52, 0x58, 0xd5,
	0x7d, 0xed, 0xab, 0x7d, 0x6d, 0x7a, 0x78, 0xf3, 0x87, 0x71, 0x94, 0x0b, 0xb7, 0x86, 0xbf, 0x4d,
	0x3e, 0x4a, 0x97, 0x03, 0x02, 0x3d, 0xea, 0xed, 0x81, 0xcf, 0xb7, 0xe1, 0xfd, 0x58, 0x54, 0xaf,
	0x78, 0xe1, 0x3d, 0xa0, 0xa7, 0xea, 0x50, 0xaf, 0xfa, 0x2f, 0x7d, 0xeb, 0x9d, 0xaa, 0xb7, 0x93,
	0xea, 0x45, 0x91, 0x87, 0xef, 0x5f, 0xe7, 0x11, 0x17, 0x26, 0x59, 0xbf, 0xd6, 0x2b, 0xa9, 0x98,
	0xea, 0x97, 0x51, 0x29, 0x25, 0x1f, 0x9d, 0xf0, 0x7b, 0x57, 0x3e, 0x56, 0xc2, 0x24, 0x77, 0xaf,
	0x7e, 0xb6, 0x12, 0x33, 0xbc, 0x8a, 0x77, 0x1f, 0xf2, 0x20, 0x56, 0x07, 0xd4, 0xe9, 0x5d, 0xed,
	0x6b, 0x97, 0x16, 0xf2, 0x29, 0x8a, 0xe5, 0x11, 0xbc, 0x13, 0xc5, 0x66, 0x5c, 0xb1, 0x34, 0xfe,
	0xdd, 0xab, 0x4b, 0x74, 0x50, 0x7f, 0xef, 0x52, 0xb1, 0xf8, 0x24, 0xaf, 0x51, 0x21, 0x91, 0x06,
	0xb0, 0x7a, 0x45, 0xfd, 0x0b, 0xea, 0xef, 0x5c, 0x95, 0x44, 0xfa, 0xfc, 0x27, 0xfa, 0xae, 0x9c,
	0xea, 0x3f, 0x69, 0xdf, 0xf4, 0x53, 0xfd, 0x27, 0xf5, 0x63, 0xb8, 0x3a, 0x84, 0xdb, 0xd1, 0x6b,
	0x75, 0x32, 0x15, 0xe0, 0xf7, 0xaf, 0x9b, 0x58, 0x60, 0xca, 0x87, 0xd7, 0x10, 0x8e, 0x4d, 0xbb,
	0x7b, 0xf3, 0xaf, 0xdf, 0xaf, 0x64, 0xfe, 0xf6, 0xfd, 0x4a, 0xe6, 0x1f, 0xdf, 0xaf, 0x64, 0x5e,
	0xe7, 0x1a, 0x86, 0xc3, 0xff, 0x51, 0xa5, 0x9e, 0xe5, 0x7f, 0x9e, 0xfc, 0x27, 0x00, 0x00, 0xff,
	0xff, 0x62, 0xe5, 0x67, 0xcd, 0xe4, 0x22, 0x00, 0x00,
}
