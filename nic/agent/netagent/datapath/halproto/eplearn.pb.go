// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eplearn.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EpLearnType int32

const (
	EpLearnType_LEARN_TYPE_NONE   EpLearnType = 0
	EpLearnType_LEARN_TYPE_LOCAL  EpLearnType = 1
	EpLearnType_LEARN_TYPE_GLOBAL EpLearnType = 2
	EpLearnType_LEARN_TYPE_ANY    EpLearnType = 3
)

var EpLearnType_name = map[int32]string{
	0: "LEARN_TYPE_NONE",
	1: "LEARN_TYPE_LOCAL",
	2: "LEARN_TYPE_GLOBAL",
	3: "LEARN_TYPE_ANY",
}
var EpLearnType_value = map[string]int32{
	"LEARN_TYPE_NONE":   0,
	"LEARN_TYPE_LOCAL":  1,
	"LEARN_TYPE_GLOBAL": 2,
	"LEARN_TYPE_ANY":    3,
}

func (x EpLearnType) String() string {
	return proto.EnumName(EpLearnType_name, int32(x))
}
func (EpLearnType) EnumDescriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{0} }

type DhcpTransactionState int32

const (
	DhcpTransactionState_STATE_NONE       DhcpTransactionState = 0
	DhcpTransactionState_STATE_SELECTING  DhcpTransactionState = 1
	DhcpTransactionState_STATE_REQUESTING DhcpTransactionState = 2
	DhcpTransactionState_STATE_BOUND      DhcpTransactionState = 3
	DhcpTransactionState_STATE_RENEWING   DhcpTransactionState = 4
	DhcpTransactionState_STATE_REBINDING  DhcpTransactionState = 5
)

var DhcpTransactionState_name = map[int32]string{
	0: "STATE_NONE",
	1: "STATE_SELECTING",
	2: "STATE_REQUESTING",
	3: "STATE_BOUND",
	4: "STATE_RENEWING",
	5: "STATE_REBINDING",
}
var DhcpTransactionState_value = map[string]int32{
	"STATE_NONE":       0,
	"STATE_SELECTING":  1,
	"STATE_REQUESTING": 2,
	"STATE_BOUND":      3,
	"STATE_RENEWING":   4,
	"STATE_REBINDING":  5,
}

func (x DhcpTransactionState) String() string {
	return proto.EnumName(DhcpTransactionState_name, int32(x))
}
func (DhcpTransactionState) EnumDescriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{1} }

// DhcpSpec Cfg
type EplearnDhcpCfg struct {
	TrustedServers []*IPAddress `protobuf:"bytes,1,rep,name=trusted_servers,json=trustedServers" json:"trusted_servers,omitempty"`
}

func (m *EplearnDhcpCfg) Reset()                    { *m = EplearnDhcpCfg{} }
func (m *EplearnDhcpCfg) String() string            { return proto.CompactTextString(m) }
func (*EplearnDhcpCfg) ProtoMessage()               {}
func (*EplearnDhcpCfg) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{0} }

func (m *EplearnDhcpCfg) GetTrustedServers() []*IPAddress {
	if m != nil {
		return m.TrustedServers
	}
	return nil
}

// Arp/Ndp Cfg
type EplearnArpCfg struct {
	EntryTimeout uint32 `protobuf:"varint,1,opt,name=entry_timeout,json=entryTimeout,proto3" json:"entry_timeout,omitempty"`
}

func (m *EplearnArpCfg) Reset()                    { *m = EplearnArpCfg{} }
func (m *EplearnArpCfg) String() string            { return proto.CompactTextString(m) }
func (*EplearnArpCfg) ProtoMessage()               {}
func (*EplearnArpCfg) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{1} }

func (m *EplearnArpCfg) GetEntryTimeout() uint32 {
	if m != nil {
		return m.EntryTimeout
	}
	return 0
}

// Arp/Ndp Cfg
type EplearnFlowMissCfg struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *EplearnFlowMissCfg) Reset()                    { *m = EplearnFlowMissCfg{} }
func (m *EplearnFlowMissCfg) String() string            { return proto.CompactTextString(m) }
func (*EplearnFlowMissCfg) ProtoMessage()               {}
func (*EplearnFlowMissCfg) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{2} }

func (m *EplearnFlowMissCfg) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type EplearnCfg struct {
	LearnType           EpLearnType         `protobuf:"varint,1,opt,name=learn_type,json=learnType,proto3,enum=eplearn.EpLearnType" json:"learn_type,omitempty"`
	DropOnStaticMisatch bool                `protobuf:"varint,2,opt,name=drop_on_static_misatch,json=dropOnStaticMisatch,proto3" json:"drop_on_static_misatch,omitempty"`
	Arp                 *EplearnArpCfg      `protobuf:"bytes,3,opt,name=arp" json:"arp,omitempty"`
	Dhcp                *EplearnDhcpCfg     `protobuf:"bytes,4,opt,name=dhcp" json:"dhcp,omitempty"`
	Fmiss               *EplearnFlowMissCfg `protobuf:"bytes,5,opt,name=fmiss" json:"fmiss,omitempty"`
}

func (m *EplearnCfg) Reset()                    { *m = EplearnCfg{} }
func (m *EplearnCfg) String() string            { return proto.CompactTextString(m) }
func (*EplearnCfg) ProtoMessage()               {}
func (*EplearnCfg) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{3} }

func (m *EplearnCfg) GetLearnType() EpLearnType {
	if m != nil {
		return m.LearnType
	}
	return EpLearnType_LEARN_TYPE_NONE
}

func (m *EplearnCfg) GetDropOnStaticMisatch() bool {
	if m != nil {
		return m.DropOnStaticMisatch
	}
	return false
}

func (m *EplearnCfg) GetArp() *EplearnArpCfg {
	if m != nil {
		return m.Arp
	}
	return nil
}

func (m *EplearnCfg) GetDhcp() *EplearnDhcpCfg {
	if m != nil {
		return m.Dhcp
	}
	return nil
}

func (m *EplearnCfg) GetFmiss() *EplearnFlowMissCfg {
	if m != nil {
		return m.Fmiss
	}
	return nil
}

type ArpStats struct {
	NumIpLearnt uint32 `protobuf:"varint,1,opt,name=num_ip_learnt,json=numIpLearnt,proto3" json:"num_ip_learnt,omitempty"`
	NumSpoofs   uint32 `protobuf:"varint,2,opt,name=num_spoofs,json=numSpoofs,proto3" json:"num_spoofs,omitempty"`
	NumDaiFails uint32 `protobuf:"varint,3,opt,name=num_dai_fails,json=numDaiFails,proto3" json:"num_dai_fails,omitempty"`
}

func (m *ArpStats) Reset()                    { *m = ArpStats{} }
func (m *ArpStats) String() string            { return proto.CompactTextString(m) }
func (*ArpStats) ProtoMessage()               {}
func (*ArpStats) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{4} }

func (m *ArpStats) GetNumIpLearnt() uint32 {
	if m != nil {
		return m.NumIpLearnt
	}
	return 0
}

func (m *ArpStats) GetNumSpoofs() uint32 {
	if m != nil {
		return m.NumSpoofs
	}
	return 0
}

func (m *ArpStats) GetNumDaiFails() uint32 {
	if m != nil {
		return m.NumDaiFails
	}
	return 0
}

type DhcpStats struct {
	NumIpLearnt uint32 `protobuf:"varint,1,opt,name=num_ip_learnt,json=numIpLearnt,proto3" json:"num_ip_learnt,omitempty"`
	NumNwFails  uint32 `protobuf:"varint,2,opt,name=num_nw_fails,json=numNwFails,proto3" json:"num_nw_fails,omitempty"`
}

func (m *DhcpStats) Reset()                    { *m = DhcpStats{} }
func (m *DhcpStats) String() string            { return proto.CompactTextString(m) }
func (*DhcpStats) ProtoMessage()               {}
func (*DhcpStats) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{5} }

func (m *DhcpStats) GetNumIpLearnt() uint32 {
	if m != nil {
		return m.NumIpLearnt
	}
	return 0
}

func (m *DhcpStats) GetNumNwFails() uint32 {
	if m != nil {
		return m.NumNwFails
	}
	return 0
}

type L2EplearnStats struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,1,opt,name=l2Segment_key_handle,json=l2SegmentKeyHandle" json:"l2Segment_key_handle,omitempty"`
	ArpStats           *ArpStats           `protobuf:"bytes,2,opt,name=arp_stats,json=arpStats" json:"arp_stats,omitempty"`
	DhcpStats          *DhcpStats          `protobuf:"bytes,3,opt,name=dhcp_stats,json=dhcpStats" json:"dhcp_stats,omitempty"`
}

func (m *L2EplearnStats) Reset()                    { *m = L2EplearnStats{} }
func (m *L2EplearnStats) String() string            { return proto.CompactTextString(m) }
func (*L2EplearnStats) ProtoMessage()               {}
func (*L2EplearnStats) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{6} }

func (m *L2EplearnStats) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

func (m *L2EplearnStats) GetArpStats() *ArpStats {
	if m != nil {
		return m.ArpStats
	}
	return nil
}

func (m *L2EplearnStats) GetDhcpStats() *DhcpStats {
	if m != nil {
		return m.DhcpStats
	}
	return nil
}

type DhcpStatus struct {
	State         DhcpTransactionState `protobuf:"varint,1,opt,name=state,proto3,enum=eplearn.DhcpTransactionState" json:"state,omitempty"`
	Xid           uint32               `protobuf:"varint,2,opt,name=xid,proto3" json:"xid,omitempty"`
	RenewalTime   uint32               `protobuf:"varint,3,opt,name=renewal_time,json=renewalTime,proto3" json:"renewal_time,omitempty"`
	RebindingTime uint32               `protobuf:"varint,4,opt,name=rebinding_time,json=rebindingTime,proto3" json:"rebinding_time,omitempty"`
	IpAddr        *IPAddress           `protobuf:"bytes,5,opt,name=ip_addr,json=ipAddr" json:"ip_addr,omitempty"`
	SubnetMask    *IPAddress           `protobuf:"bytes,6,opt,name=subnet_mask,json=subnetMask" json:"subnet_mask,omitempty"`
	GatewayIp     *IPAddress           `protobuf:"bytes,7,opt,name=gateway_ip,json=gatewayIp" json:"gateway_ip,omitempty"`
}

func (m *DhcpStatus) Reset()                    { *m = DhcpStatus{} }
func (m *DhcpStatus) String() string            { return proto.CompactTextString(m) }
func (*DhcpStatus) ProtoMessage()               {}
func (*DhcpStatus) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{7} }

func (m *DhcpStatus) GetState() DhcpTransactionState {
	if m != nil {
		return m.State
	}
	return DhcpTransactionState_STATE_NONE
}

func (m *DhcpStatus) GetXid() uint32 {
	if m != nil {
		return m.Xid
	}
	return 0
}

func (m *DhcpStatus) GetRenewalTime() uint32 {
	if m != nil {
		return m.RenewalTime
	}
	return 0
}

func (m *DhcpStatus) GetRebindingTime() uint32 {
	if m != nil {
		return m.RebindingTime
	}
	return 0
}

func (m *DhcpStatus) GetIpAddr() *IPAddress {
	if m != nil {
		return m.IpAddr
	}
	return nil
}

func (m *DhcpStatus) GetSubnetMask() *IPAddress {
	if m != nil {
		return m.SubnetMask
	}
	return nil
}

func (m *DhcpStatus) GetGatewayIp() *IPAddress {
	if m != nil {
		return m.GatewayIp
	}
	return nil
}

type ArpStatus struct {
	EntryActive  bool   `protobuf:"varint,1,opt,name=entry_active,json=entryActive,proto3" json:"entry_active,omitempty"`
	EntryTimeout uint32 `protobuf:"varint,2,opt,name=entry_timeout,json=entryTimeout,proto3" json:"entry_timeout,omitempty"`
}

func (m *ArpStatus) Reset()                    { *m = ArpStatus{} }
func (m *ArpStatus) String() string            { return proto.CompactTextString(m) }
func (*ArpStatus) ProtoMessage()               {}
func (*ArpStatus) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{8} }

func (m *ArpStatus) GetEntryActive() bool {
	if m != nil {
		return m.EntryActive
	}
	return false
}

func (m *ArpStatus) GetEntryTimeout() uint32 {
	if m != nil {
		return m.EntryTimeout
	}
	return 0
}

type EplearnStats struct {
	NumDhcpTrans  uint32 `protobuf:"varint,1,opt,name=num_dhcp_trans,json=numDhcpTrans,proto3" json:"num_dhcp_trans,omitempty"`
	NumArpTrans   uint32 `protobuf:"varint,2,opt,name=num_arp_trans,json=numArpTrans,proto3" json:"num_arp_trans,omitempty"`
	NumDhcpErrors uint32 `protobuf:"varint,3,opt,name=num_dhcp_errors,json=numDhcpErrors,proto3" json:"num_dhcp_errors,omitempty"`
	NumArpErrors  uint32 `protobuf:"varint,4,opt,name=num_arp_errors,json=numArpErrors,proto3" json:"num_arp_errors,omitempty"`
}

func (m *EplearnStats) Reset()                    { *m = EplearnStats{} }
func (m *EplearnStats) String() string            { return proto.CompactTextString(m) }
func (*EplearnStats) ProtoMessage()               {}
func (*EplearnStats) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{9} }

func (m *EplearnStats) GetNumDhcpTrans() uint32 {
	if m != nil {
		return m.NumDhcpTrans
	}
	return 0
}

func (m *EplearnStats) GetNumArpTrans() uint32 {
	if m != nil {
		return m.NumArpTrans
	}
	return 0
}

func (m *EplearnStats) GetNumDhcpErrors() uint32 {
	if m != nil {
		return m.NumDhcpErrors
	}
	return 0
}

func (m *EplearnStats) GetNumArpErrors() uint32 {
	if m != nil {
		return m.NumArpErrors
	}
	return 0
}

type EplearnStatus struct {
	DhcpStatus *DhcpStatus `protobuf:"bytes,1,opt,name=dhcp_status,json=dhcpStatus" json:"dhcp_status,omitempty"`
	ArpStatus  *ArpStatus  `protobuf:"bytes,2,opt,name=arp_status,json=arpStatus" json:"arp_status,omitempty"`
}

func (m *EplearnStatus) Reset()                    { *m = EplearnStatus{} }
func (m *EplearnStatus) String() string            { return proto.CompactTextString(m) }
func (*EplearnStatus) ProtoMessage()               {}
func (*EplearnStatus) Descriptor() ([]byte, []int) { return fileDescriptorEplearn, []int{10} }

func (m *EplearnStatus) GetDhcpStatus() *DhcpStatus {
	if m != nil {
		return m.DhcpStatus
	}
	return nil
}

func (m *EplearnStatus) GetArpStatus() *ArpStatus {
	if m != nil {
		return m.ArpStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*EplearnDhcpCfg)(nil), "eplearn.EplearnDhcpCfg")
	proto.RegisterType((*EplearnArpCfg)(nil), "eplearn.EplearnArpCfg")
	proto.RegisterType((*EplearnFlowMissCfg)(nil), "eplearn.EplearnFlowMissCfg")
	proto.RegisterType((*EplearnCfg)(nil), "eplearn.EplearnCfg")
	proto.RegisterType((*ArpStats)(nil), "eplearn.ArpStats")
	proto.RegisterType((*DhcpStats)(nil), "eplearn.DhcpStats")
	proto.RegisterType((*L2EplearnStats)(nil), "eplearn.L2EplearnStats")
	proto.RegisterType((*DhcpStatus)(nil), "eplearn.DhcpStatus")
	proto.RegisterType((*ArpStatus)(nil), "eplearn.ArpStatus")
	proto.RegisterType((*EplearnStats)(nil), "eplearn.EplearnStats")
	proto.RegisterType((*EplearnStatus)(nil), "eplearn.EplearnStatus")
	proto.RegisterEnum("eplearn.EpLearnType", EpLearnType_name, EpLearnType_value)
	proto.RegisterEnum("eplearn.DhcpTransactionState", DhcpTransactionState_name, DhcpTransactionState_value)
}
func (m *EplearnDhcpCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnDhcpCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrustedServers) > 0 {
		for _, msg := range m.TrustedServers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEplearn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EplearnArpCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnArpCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntryTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.EntryTimeout))
	}
	return i, nil
}

func (m *EplearnFlowMissCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnFlowMissCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EplearnCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LearnType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.LearnType))
	}
	if m.DropOnStaticMisatch {
		dAtA[i] = 0x10
		i++
		if m.DropOnStaticMisatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Arp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.Arp.Size()))
		n1, err := m.Arp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Dhcp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.Dhcp.Size()))
		n2, err := m.Dhcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Fmiss != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.Fmiss.Size()))
		n3, err := m.Fmiss.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ArpStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArpStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumIpLearnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumIpLearnt))
	}
	if m.NumSpoofs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumSpoofs))
	}
	if m.NumDaiFails != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumDaiFails))
	}
	return i, nil
}

func (m *DhcpStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DhcpStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumIpLearnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumIpLearnt))
	}
	if m.NumNwFails != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumNwFails))
	}
	return i, nil
}

func (m *L2EplearnStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2EplearnStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L2SegmentKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.L2SegmentKeyHandle.Size()))
		n4, err := m.L2SegmentKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ArpStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.ArpStats.Size()))
		n5, err := m.ArpStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DhcpStats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.DhcpStats.Size()))
		n6, err := m.DhcpStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DhcpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DhcpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.State))
	}
	if m.Xid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.Xid))
	}
	if m.RenewalTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.RenewalTime))
	}
	if m.RebindingTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.RebindingTime))
	}
	if m.IpAddr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.IpAddr.Size()))
		n7, err := m.IpAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.SubnetMask != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.SubnetMask.Size()))
		n8, err := m.SubnetMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.GatewayIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.GatewayIp.Size()))
		n9, err := m.GatewayIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ArpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntryActive {
		dAtA[i] = 0x8
		i++
		if m.EntryActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EntryTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.EntryTimeout))
	}
	return i, nil
}

func (m *EplearnStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumDhcpTrans != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumDhcpTrans))
	}
	if m.NumArpTrans != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumArpTrans))
	}
	if m.NumDhcpErrors != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumDhcpErrors))
	}
	if m.NumArpErrors != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.NumArpErrors))
	}
	return i, nil
}

func (m *EplearnStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EplearnStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DhcpStatus != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.DhcpStatus.Size()))
		n10, err := m.DhcpStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ArpStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEplearn(dAtA, i, uint64(m.ArpStatus.Size()))
		n11, err := m.ArpStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintEplearn(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EplearnDhcpCfg) Size() (n int) {
	var l int
	_ = l
	if len(m.TrustedServers) > 0 {
		for _, e := range m.TrustedServers {
			l = e.Size()
			n += 1 + l + sovEplearn(uint64(l))
		}
	}
	return n
}

func (m *EplearnArpCfg) Size() (n int) {
	var l int
	_ = l
	if m.EntryTimeout != 0 {
		n += 1 + sovEplearn(uint64(m.EntryTimeout))
	}
	return n
}

func (m *EplearnFlowMissCfg) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *EplearnCfg) Size() (n int) {
	var l int
	_ = l
	if m.LearnType != 0 {
		n += 1 + sovEplearn(uint64(m.LearnType))
	}
	if m.DropOnStaticMisatch {
		n += 2
	}
	if m.Arp != nil {
		l = m.Arp.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.Dhcp != nil {
		l = m.Dhcp.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.Fmiss != nil {
		l = m.Fmiss.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	return n
}

func (m *ArpStats) Size() (n int) {
	var l int
	_ = l
	if m.NumIpLearnt != 0 {
		n += 1 + sovEplearn(uint64(m.NumIpLearnt))
	}
	if m.NumSpoofs != 0 {
		n += 1 + sovEplearn(uint64(m.NumSpoofs))
	}
	if m.NumDaiFails != 0 {
		n += 1 + sovEplearn(uint64(m.NumDaiFails))
	}
	return n
}

func (m *DhcpStats) Size() (n int) {
	var l int
	_ = l
	if m.NumIpLearnt != 0 {
		n += 1 + sovEplearn(uint64(m.NumIpLearnt))
	}
	if m.NumNwFails != 0 {
		n += 1 + sovEplearn(uint64(m.NumNwFails))
	}
	return n
}

func (m *L2EplearnStats) Size() (n int) {
	var l int
	_ = l
	if m.L2SegmentKeyHandle != nil {
		l = m.L2SegmentKeyHandle.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.ArpStats != nil {
		l = m.ArpStats.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.DhcpStats != nil {
		l = m.DhcpStats.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	return n
}

func (m *DhcpStatus) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovEplearn(uint64(m.State))
	}
	if m.Xid != 0 {
		n += 1 + sovEplearn(uint64(m.Xid))
	}
	if m.RenewalTime != 0 {
		n += 1 + sovEplearn(uint64(m.RenewalTime))
	}
	if m.RebindingTime != 0 {
		n += 1 + sovEplearn(uint64(m.RebindingTime))
	}
	if m.IpAddr != nil {
		l = m.IpAddr.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.SubnetMask != nil {
		l = m.SubnetMask.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.GatewayIp != nil {
		l = m.GatewayIp.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	return n
}

func (m *ArpStatus) Size() (n int) {
	var l int
	_ = l
	if m.EntryActive {
		n += 2
	}
	if m.EntryTimeout != 0 {
		n += 1 + sovEplearn(uint64(m.EntryTimeout))
	}
	return n
}

func (m *EplearnStats) Size() (n int) {
	var l int
	_ = l
	if m.NumDhcpTrans != 0 {
		n += 1 + sovEplearn(uint64(m.NumDhcpTrans))
	}
	if m.NumArpTrans != 0 {
		n += 1 + sovEplearn(uint64(m.NumArpTrans))
	}
	if m.NumDhcpErrors != 0 {
		n += 1 + sovEplearn(uint64(m.NumDhcpErrors))
	}
	if m.NumArpErrors != 0 {
		n += 1 + sovEplearn(uint64(m.NumArpErrors))
	}
	return n
}

func (m *EplearnStatus) Size() (n int) {
	var l int
	_ = l
	if m.DhcpStatus != nil {
		l = m.DhcpStatus.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	if m.ArpStatus != nil {
		l = m.ArpStatus.Size()
		n += 1 + l + sovEplearn(uint64(l))
	}
	return n
}

func sovEplearn(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEplearn(x uint64) (n int) {
	return sovEplearn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EplearnDhcpCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnDhcpCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnDhcpCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedServers = append(m.TrustedServers, &IPAddress{})
			if err := m.TrustedServers[len(m.TrustedServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EplearnArpCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnArpCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnArpCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTimeout", wireType)
			}
			m.EntryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EplearnFlowMissCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnFlowMissCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnFlowMissCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EplearnCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnType", wireType)
			}
			m.LearnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnType |= (EpLearnType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOnStaticMisatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOnStaticMisatch = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arp == nil {
				m.Arp = &EplearnArpCfg{}
			}
			if err := m.Arp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dhcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dhcp == nil {
				m.Dhcp = &EplearnDhcpCfg{}
			}
			if err := m.Dhcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fmiss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fmiss == nil {
				m.Fmiss = &EplearnFlowMissCfg{}
			}
			if err := m.Fmiss.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArpStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArpStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArpStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIpLearnt", wireType)
			}
			m.NumIpLearnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumIpLearnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSpoofs", wireType)
			}
			m.NumSpoofs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSpoofs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDaiFails", wireType)
			}
			m.NumDaiFails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDaiFails |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DhcpStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DhcpStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DhcpStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIpLearnt", wireType)
			}
			m.NumIpLearnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumIpLearnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNwFails", wireType)
			}
			m.NumNwFails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNwFails |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2EplearnStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2EplearnStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2EplearnStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegmentKeyHandle == nil {
				m.L2SegmentKeyHandle = &L2SegmentKeyHandle{}
			}
			if err := m.L2SegmentKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArpStats == nil {
				m.ArpStats = &ArpStats{}
			}
			if err := m.ArpStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpStats == nil {
				m.DhcpStats = &DhcpStats{}
			}
			if err := m.DhcpStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DhcpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DhcpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DhcpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DhcpTransactionState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xid", wireType)
			}
			m.Xid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewalTime", wireType)
			}
			m.RenewalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RenewalTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebindingTime", wireType)
			}
			m.RebindingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebindingTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpAddr == nil {
				m.IpAddr = &IPAddress{}
			}
			if err := m.IpAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetMask == nil {
				m.SubnetMask = &IPAddress{}
			}
			if err := m.SubnetMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayIp == nil {
				m.GatewayIp = &IPAddress{}
			}
			if err := m.GatewayIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryActive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryTimeout", wireType)
			}
			m.EntryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EplearnStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDhcpTrans", wireType)
			}
			m.NumDhcpTrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDhcpTrans |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumArpTrans", wireType)
			}
			m.NumArpTrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumArpTrans |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDhcpErrors", wireType)
			}
			m.NumDhcpErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDhcpErrors |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumArpErrors", wireType)
			}
			m.NumArpErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumArpErrors |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EplearnStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EplearnStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EplearnStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpStatus == nil {
				m.DhcpStatus = &DhcpStatus{}
			}
			if err := m.DhcpStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEplearn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArpStatus == nil {
				m.ArpStatus = &ArpStatus{}
			}
			if err := m.ArpStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEplearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEplearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEplearn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEplearn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEplearn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEplearn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEplearn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEplearn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEplearn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEplearn   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("eplearn.proto", fileDescriptorEplearn) }

var fileDescriptorEplearn = []byte{
	// 921 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x86, 0x43, 0xc9, 0x17, 0xe9, 0xd0, 0x92, 0x98, 0xb1, 0x9b, 0x12, 0x2e, 0x62, 0xb8, 0xec,
	0x05, 0x6e, 0x0a, 0xa8, 0xb0, 0x9c, 0x4d, 0x97, 0xb4, 0xcd, 0x24, 0x42, 0x68, 0x2a, 0xa1, 0x14,
	0x14, 0xe9, 0x86, 0x18, 0x8b, 0x63, 0x8b, 0x10, 0x45, 0xb2, 0x33, 0x64, 0x14, 0xed, 0xba, 0xef,
	0x0b, 0xf4, 0x09, 0xba, 0xea, 0x2b, 0x74, 0xdf, 0x65, 0x1f, 0xa1, 0x70, 0x5f, 0xa4, 0x98, 0x1b,
	0xa3, 0xd8, 0x09, 0x90, 0x95, 0x86, 0xff, 0x7c, 0xe7, 0x9c, 0x99, 0x33, 0xff, 0x8c, 0xa0, 0x43,
	0x8a, 0x94, 0x60, 0x9a, 0xf5, 0x0b, 0x9a, 0x97, 0x39, 0xda, 0x56, 0x9f, 0xfb, 0x66, 0xb9, 0x2a,
	0x08, 0x93, 0xea, 0x7e, 0x6b, 0x3e, 0x93, 0x23, 0xe7, 0x39, 0x74, 0x3d, 0x49, 0x9c, 0xcf, 0xa6,
	0xc5, 0xd9, 0xd5, 0x35, 0xfa, 0x11, 0x7a, 0x25, 0xad, 0x58, 0x49, 0xe2, 0x88, 0x11, 0xfa, 0x86,
	0x50, 0x66, 0x1b, 0x87, 0xcd, 0x23, 0x73, 0x60, 0xf5, 0x65, 0x8a, 0xe1, 0x0b, 0x37, 0x8e, 0x29,
	0x61, 0x2c, 0xec, 0x2a, 0x70, 0x2c, 0x39, 0xe7, 0x31, 0x74, 0x54, 0x32, 0x97, 0x8a, 0x5c, 0x5f,
	0x41, 0x87, 0x64, 0x25, 0x5d, 0x45, 0x65, 0xb2, 0x20, 0x79, 0x55, 0xda, 0xc6, 0xa1, 0x71, 0xd4,
	0x09, 0x77, 0x84, 0x38, 0x91, 0x9a, 0xd3, 0x07, 0xa4, 0xa2, 0x9e, 0xa4, 0xf9, 0xf2, 0x22, 0x61,
	0x8c, 0x87, 0xda, 0xb0, 0x4d, 0x32, 0x7c, 0x99, 0x92, 0x58, 0x04, 0xb5, 0x42, 0xfd, 0xe9, 0xfc,
	0xda, 0x00, 0x50, 0x01, 0x1c, 0x3c, 0x01, 0x10, 0xe3, 0x88, 0xaf, 0x4e, 0xb0, 0xdd, 0xc1, 0x5e,
	0x5f, 0x77, 0xc1, 0x2b, 0x7c, 0xfe, 0x3b, 0x59, 0x15, 0x24, 0x6c, 0xa7, 0x7a, 0x88, 0x4e, 0xe0,
	0x41, 0x4c, 0xf3, 0x22, 0xca, 0xb3, 0x88, 0x95, 0xb8, 0x4c, 0xa6, 0xd1, 0x22, 0x61, 0xb8, 0x9c,
	0xce, 0xec, 0x86, 0x28, 0xb6, 0xcb, 0x67, 0x47, 0xd9, 0x58, 0xcc, 0x5d, 0xc8, 0x29, 0x74, 0x04,
	0x4d, 0x4c, 0x0b, 0xbb, 0x79, 0x68, 0x1c, 0x99, 0x83, 0x07, 0x6b, 0x25, 0xd6, 0xb6, 0x1c, 0x72,
	0x04, 0x7d, 0x0f, 0x1b, 0xf1, 0x6c, 0x5a, 0xd8, 0x1b, 0x02, 0xfd, 0xfc, 0x36, 0xaa, 0x5a, 0x1d,
	0x0a, 0x08, 0x1d, 0xc3, 0xe6, 0xd5, 0x22, 0x61, 0xcc, 0xde, 0x14, 0xf4, 0x17, 0xb7, 0xe9, 0xb5,
	0xae, 0x84, 0x92, 0x74, 0x7e, 0x81, 0x96, 0x4b, 0x0b, 0xbe, 0x3a, 0x86, 0x1c, 0xe8, 0x64, 0xd5,
	0x22, 0x4a, 0x8a, 0x48, 0xd0, 0xba, 0xc7, 0x66, 0x56, 0x2d, 0x86, 0x72, 0xf3, 0x25, 0x7a, 0x08,
	0xc0, 0x19, 0x56, 0xe4, 0xf9, 0x15, 0x13, 0x5b, 0xec, 0x84, 0xed, 0xac, 0x5a, 0x8c, 0x85, 0xa0,
	0x53, 0xc4, 0x38, 0x89, 0xae, 0x70, 0x92, 0x32, 0xb1, 0x45, 0x99, 0xe2, 0x1c, 0x27, 0x4f, 0xb8,
	0xe4, 0xbc, 0x84, 0x36, 0x5f, 0xf6, 0xa7, 0xd7, 0x3c, 0x84, 0x1d, 0xce, 0x64, 0x4b, 0x95, 0x53,
	0x56, 0xe5, 0xeb, 0x08, 0x96, 0x32, 0xe5, 0x5f, 0x06, 0x74, 0xfd, 0x81, 0xda, 0xa5, 0x4c, 0xfc,
	0x0c, 0xf6, 0xd2, 0xc1, 0x98, 0x5c, 0x2f, 0x48, 0x56, 0x46, 0x73, 0xb2, 0x8a, 0x66, 0x38, 0x8b,
	0x53, 0x79, 0xac, 0xbc, 0xe7, 0xf3, 0x59, 0xdf, 0xd7, 0xf3, 0xcf, 0xc9, 0xea, 0x99, 0x98, 0x0d,
	0x51, 0x7a, 0x47, 0x43, 0x7d, 0x68, 0x63, 0x5a, 0x88, 0xd3, 0x95, 0xb5, 0xcd, 0xc1, 0xfd, 0xba,
	0xb3, 0xba, 0x79, 0x61, 0x0b, 0xeb, 0x36, 0x1e, 0x03, 0xf0, 0xd3, 0x50, 0x01, 0xf2, 0x8c, 0x51,
	0x1d, 0x50, 0x6f, 0x3d, 0x6c, 0xc7, 0x7a, 0xe8, 0xfc, 0xd9, 0x00, 0xd0, 0x13, 0x15, 0x43, 0x27,
	0xb0, 0xc9, 0x83, 0xb5, 0x07, 0x1f, 0xbe, 0x17, 0x3c, 0xa1, 0x38, 0x63, 0x78, 0x5a, 0x26, 0xb9,
	0xd8, 0x29, 0x09, 0x25, 0x8b, 0x2c, 0x68, 0xbe, 0x4d, 0x62, 0xd5, 0x1c, 0x3e, 0x44, 0x5f, 0xc2,
	0x0e, 0x25, 0x19, 0x59, 0xe2, 0x54, 0xdc, 0x1a, 0x7d, 0x16, 0x4a, 0xe3, 0x97, 0x06, 0x7d, 0x03,
	0x5d, 0x4a, 0x2e, 0x93, 0x2c, 0x4e, 0xb2, 0x6b, 0x09, 0x6d, 0x08, 0xa8, 0x53, 0xab, 0x02, 0xfb,
	0x0e, 0xb6, 0x93, 0x22, 0xc2, 0x71, 0x4c, 0x95, 0xb5, 0xee, 0xde, 0xe0, 0xad, 0xa4, 0xe0, 0x43,
	0x74, 0x0c, 0x26, 0xab, 0x2e, 0x33, 0x52, 0x46, 0x0b, 0xcc, 0xe6, 0xf6, 0xd6, 0x47, 0x70, 0x90,
	0xd0, 0x05, 0x66, 0x73, 0xf4, 0x03, 0xc0, 0x35, 0x2e, 0xc9, 0x12, 0xaf, 0xa2, 0xa4, 0xb0, 0xb7,
	0x3f, 0x12, 0xd1, 0x56, 0xcc, 0xb0, 0x70, 0xc6, 0xd0, 0x56, 0x7d, 0xaf, 0x18, 0xdf, 0xa5, 0x7c,
	0x19, 0x78, 0x4f, 0xde, 0x10, 0x75, 0xc7, 0x4d, 0xa1, 0xb9, 0x42, 0xba, 0xfb, 0x78, 0x34, 0x3e,
	0xf0, 0x78, 0xfc, 0x61, 0xc0, 0xce, 0x7b, 0x0e, 0xfa, 0x1a, 0xba, 0xc2, 0xcb, 0xfc, 0x2c, 0x4b,
	0xde, 0x74, 0xfd, 0xe6, 0x70, 0x33, 0xeb, 0x83, 0xd0, 0x06, 0xe6, 0x0e, 0x91, 0x50, 0xa3, 0x36,
	0xb0, 0x4b, 0x15, 0xf3, 0x2d, 0xf4, 0xea, 0x4c, 0x84, 0xd2, 0x9c, 0xea, 0x7b, 0xd1, 0x51, 0xa9,
	0x3c, 0x21, 0xea, 0x8a, 0x3c, 0x97, 0xc2, 0x36, 0xea, 0x8a, 0x2e, 0x55, 0x94, 0xf3, 0xb6, 0x7e,
	0x1b, 0x55, 0x07, 0x1e, 0x83, 0x59, 0x1b, 0xae, 0x62, 0xca, 0xe1, 0xbb, 0x77, 0x1c, 0x57, 0xb1,
	0x10, 0xe2, 0x77, 0x26, 0x3b, 0x06, 0xd0, 0xb6, 0xae, 0xb4, 0xaf, 0xd1, 0x6d, 0x5f, 0x57, 0x2c,
	0x6c, 0x63, 0x3d, 0x7c, 0x34, 0x05, 0x73, 0xed, 0x15, 0x44, 0xbb, 0xd0, 0xf3, 0x3d, 0x37, 0x0c,
	0xa2, 0xc9, 0xeb, 0x17, 0x5e, 0x14, 0x8c, 0x02, 0xcf, 0xba, 0x87, 0xf6, 0xc0, 0x5a, 0x13, 0xfd,
	0xd1, 0x99, 0xeb, 0x5b, 0x06, 0xfa, 0x0c, 0xee, 0xaf, 0xa9, 0x4f, 0xfd, 0xd1, 0xa9, 0xeb, 0x5b,
	0x0d, 0x84, 0xa0, 0xbb, 0x26, 0xbb, 0xc1, 0x6b, 0xab, 0xf9, 0xe8, 0x37, 0x03, 0xf6, 0x3e, 0xe4,
	0x73, 0xd4, 0x05, 0x18, 0x4f, 0xdc, 0x49, 0x5d, 0x69, 0x17, 0x7a, 0xf2, 0x7b, 0xec, 0xf9, 0xde,
	0xd9, 0x64, 0x18, 0x3c, 0xb5, 0x0c, 0x5e, 0x5e, 0x8a, 0xa1, 0xf7, 0xf2, 0x95, 0x37, 0x16, 0x6a,
	0x03, 0xf5, 0xc0, 0x94, 0xea, 0xe9, 0xe8, 0x55, 0x70, 0x6e, 0x35, 0x79, 0x61, 0x8d, 0x05, 0xde,
	0x4f, 0x1c, 0xda, 0x78, 0x97, 0x2f, 0xf4, 0x4e, 0x87, 0xc1, 0x39, 0x17, 0x37, 0x4f, 0xf7, 0xff,
	0xbe, 0x39, 0x30, 0xfe, 0xb9, 0x39, 0x30, 0xfe, 0xbd, 0x39, 0x30, 0x7e, 0xff, 0xef, 0xe0, 0xde,
	0xcf, 0xad, 0x19, 0x4e, 0xc5, 0x3f, 0xde, 0xe5, 0x96, 0xf8, 0x39, 0xf9, 0x3f, 0x00, 0x00, 0xff,
	0xff, 0x8d, 0xbb, 0x91, 0x0c, 0x29, 0x07, 0x00, 0x00,
}
