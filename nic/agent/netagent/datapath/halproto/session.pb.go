// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/proto/hal/session.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Types of NAT
type NatType int32

const (
	NatType_NAT_TYPE_NONE      NatType = 0
	NatType_NAT_TYPE_SNAT      NatType = 1
	NatType_NAT_TYPE_DNAT      NatType = 2
	NatType_NAT_TYPE_TWICE_NAT NatType = 3
)

var NatType_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_SNAT",
	2: "NAT_TYPE_DNAT",
	3: "NAT_TYPE_TWICE_NAT",
}
var NatType_value = map[string]int32{
	"NAT_TYPE_NONE":      0,
	"NAT_TYPE_SNAT":      1,
	"NAT_TYPE_DNAT":      2,
	"NAT_TYPE_TWICE_NAT": 3,
}

func (x NatType) String() string {
	return proto.EnumName(NatType_name, int32(x))
}
func (NatType) EnumDescriptor() ([]byte, []int) { return fileDescriptor17, []int{0} }

// Flow actions
type FlowAction int32

const (
	FlowAction_FLOW_ACTION_NONE  FlowAction = 0
	FlowAction_FLOW_ACTION_ALLOW FlowAction = 1
	FlowAction_FLOW_ACTION_DROP  FlowAction = 2
)

var FlowAction_name = map[int32]string{
	0: "FLOW_ACTION_NONE",
	1: "FLOW_ACTION_ALLOW",
	2: "FLOW_ACTION_DROP",
}
var FlowAction_value = map[string]int32{
	"FLOW_ACTION_NONE":  0,
	"FLOW_ACTION_ALLOW": 1,
	"FLOW_ACTION_DROP":  2,
}

func (x FlowAction) String() string {
	return proto.EnumName(FlowAction_name, int32(x))
}
func (FlowAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor17, []int{1} }

// Flow TCP states
// TODO: Srini, please define all other states
type FlowTCPState int32

const (
	FlowTCPState_FLOW_TCP_STATE_INIT           FlowTCPState = 0
	FlowTCPState_FLOW_TCP_STATE_SYN_RCVD       FlowTCPState = 1
	FlowTCPState_FLOW_TCP_STATE_ACK_RCVD       FlowTCPState = 2
	FlowTCPState_FLOW_TCP_STATE_SYN_ACK_RCVD   FlowTCPState = 3
	FlowTCPState_FLOW_TCP_STATE_ESTABLISHED    FlowTCPState = 4
	FlowTCPState_FLOW_TCP_STATE_FIN_RCVD       FlowTCPState = 5
	FlowTCPState_FLOW_TCP_STATE_BIDIR_FIN_RCVD FlowTCPState = 6
	FlowTCPState_FLOW_TCP_STATE_RESET          FlowTCPState = 7
)

var FlowTCPState_name = map[int32]string{
	0: "FLOW_TCP_STATE_INIT",
	1: "FLOW_TCP_STATE_SYN_RCVD",
	2: "FLOW_TCP_STATE_ACK_RCVD",
	3: "FLOW_TCP_STATE_SYN_ACK_RCVD",
	4: "FLOW_TCP_STATE_ESTABLISHED",
	5: "FLOW_TCP_STATE_FIN_RCVD",
	6: "FLOW_TCP_STATE_BIDIR_FIN_RCVD",
	7: "FLOW_TCP_STATE_RESET",
}
var FlowTCPState_value = map[string]int32{
	"FLOW_TCP_STATE_INIT":           0,
	"FLOW_TCP_STATE_SYN_RCVD":       1,
	"FLOW_TCP_STATE_ACK_RCVD":       2,
	"FLOW_TCP_STATE_SYN_ACK_RCVD":   3,
	"FLOW_TCP_STATE_ESTABLISHED":    4,
	"FLOW_TCP_STATE_FIN_RCVD":       5,
	"FLOW_TCP_STATE_BIDIR_FIN_RCVD": 6,
	"FLOW_TCP_STATE_RESET":          7,
}

func (x FlowTCPState) String() string {
	return proto.EnumName(FlowTCPState_name, int32(x))
}
func (FlowTCPState) EnumDescriptor() ([]byte, []int) { return fileDescriptor17, []int{2} }

// App Types ... In sync with p4/nw/include/defines.h
// TODO: Revisit once we decide if flow drives app_id or service_lif
type FlowType int32

const (
	FlowType_FLOW_TYPE_NONE        FlowType = 0
	FlowType_FLOW_TYPE_CLASSIC_NIC FlowType = 1
	FlowType_FLOW_TYPE_RDMA        FlowType = 2
	FlowType_FLOW_TYPE_TCPTLS      FlowType = 3
	FlowType_FLOW_TYPE_IPSEC       FlowType = 4
	FlowType_FLOW_TYPE_NDE         FlowType = 5
	FlowType_FLOW_TYPE_STORAGE     FlowType = 6
	FlowType_FLOW_TYPE_TELEMETRY   FlowType = 7
)

var FlowType_name = map[int32]string{
	0: "FLOW_TYPE_NONE",
	1: "FLOW_TYPE_CLASSIC_NIC",
	2: "FLOW_TYPE_RDMA",
	3: "FLOW_TYPE_TCPTLS",
	4: "FLOW_TYPE_IPSEC",
	5: "FLOW_TYPE_NDE",
	6: "FLOW_TYPE_STORAGE",
	7: "FLOW_TYPE_TELEMETRY",
}
var FlowType_value = map[string]int32{
	"FLOW_TYPE_NONE":        0,
	"FLOW_TYPE_CLASSIC_NIC": 1,
	"FLOW_TYPE_RDMA":        2,
	"FLOW_TYPE_TCPTLS":      3,
	"FLOW_TYPE_IPSEC":       4,
	"FLOW_TYPE_NDE":         5,
	"FLOW_TYPE_STORAGE":     6,
	"FLOW_TYPE_TELEMETRY":   7,
}

func (x FlowType) String() string {
	return proto.EnumName(FlowType_name, int32(x))
}
func (FlowType) EnumDescriptor() ([]byte, []int) { return fileDescriptor17, []int{3} }

// Key for L2 flows (i.e, non-IP flows)
type FlowKeyL2 struct {
	Smac        uint64 `protobuf:"fixed64,1,opt,name=smac" json:"smac,omitempty"`
	Dmac        uint64 `protobuf:"fixed64,2,opt,name=dmac" json:"dmac,omitempty"`
	EtherType   uint32 `protobuf:"varint,4,opt,name=ether_type,json=etherType" json:"ether_type,omitempty"`
	L2SegmentId uint32 `protobuf:"varint,3,opt,name=l2_segment_id,json=l2SegmentId" json:"l2_segment_id,omitempty"`
}

func (m *FlowKeyL2) Reset()                    { *m = FlowKeyL2{} }
func (m *FlowKeyL2) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyL2) ProtoMessage()               {}
func (*FlowKeyL2) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{0} }

func (m *FlowKeyL2) GetSmac() uint64 {
	if m != nil {
		return m.Smac
	}
	return 0
}

func (m *FlowKeyL2) GetDmac() uint64 {
	if m != nil {
		return m.Dmac
	}
	return 0
}

func (m *FlowKeyL2) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

func (m *FlowKeyL2) GetL2SegmentId() uint32 {
	if m != nil {
		return m.L2SegmentId
	}
	return 0
}

type FlowKeyTcpUdpInfo struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport" json:"dport,omitempty"`
}

func (m *FlowKeyTcpUdpInfo) Reset()                    { *m = FlowKeyTcpUdpInfo{} }
func (m *FlowKeyTcpUdpInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyTcpUdpInfo) ProtoMessage()               {}
func (*FlowKeyTcpUdpInfo) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{1} }

func (m *FlowKeyTcpUdpInfo) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FlowKeyTcpUdpInfo) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type FlowKeyICMPInfo struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Id   uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *FlowKeyICMPInfo) Reset()                    { *m = FlowKeyICMPInfo{} }
func (m *FlowKeyICMPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyICMPInfo) ProtoMessage()               {}
func (*FlowKeyICMPInfo) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{2} }

func (m *FlowKeyICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type FlowKeyESPInfo struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi" json:"spi,omitempty"`
}

func (m *FlowKeyESPInfo) Reset()                    { *m = FlowKeyESPInfo{} }
func (m *FlowKeyESPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyESPInfo) ProtoMessage()               {}
func (*FlowKeyESPInfo) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{3} }

func (m *FlowKeyESPInfo) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

// Key for IPv4 flows
type FlowKeyV4 struct {
	Sip     uint32     `protobuf:"fixed32,1,opt,name=sip" json:"sip,omitempty"`
	Dip     uint32     `protobuf:"fixed32,2,opt,name=dip" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV4_TcpUdp
	//	*FlowKeyV4_Icmp
	//	*FlowKeyV4_Esp
	L4Fields isFlowKeyV4_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV4) Reset()                    { *m = FlowKeyV4{} }
func (m *FlowKeyV4) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV4) ProtoMessage()               {}
func (*FlowKeyV4) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{4} }

type isFlowKeyV4_L4Fields interface {
	isFlowKeyV4_L4Fields()
}

type FlowKeyV4_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV4_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV4_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV4_TcpUdp) isFlowKeyV4_L4Fields() {}
func (*FlowKeyV4_Icmp) isFlowKeyV4_L4Fields()   {}
func (*FlowKeyV4_Esp) isFlowKeyV4_L4Fields()    {}

func (m *FlowKeyV4) GetL4Fields() isFlowKeyV4_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV4) GetSip() uint32 {
	if m != nil {
		return m.Sip
	}
	return 0
}

func (m *FlowKeyV4) GetDip() uint32 {
	if m != nil {
		return m.Dip
	}
	return 0
}

func (m *FlowKeyV4) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV4) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV4) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV4) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV4) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV4_OneofMarshaler, _FlowKeyV4_OneofUnmarshaler, _FlowKeyV4_OneofSizer, []interface{}{
		(*FlowKeyV4_TcpUdp)(nil),
		(*FlowKeyV4_Icmp)(nil),
		(*FlowKeyV4_Esp)(nil),
	}
}

func _FlowKeyV4_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV4_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV4_Esp:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV4.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV4_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV4)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV4_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for IPv6 flows
type FlowKeyV6 struct {
	Sip     *IPAddress `protobuf:"bytes,1,opt,name=sip" json:"sip,omitempty"`
	Dip     *IPAddress `protobuf:"bytes,2,opt,name=dip" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV6_TcpUdp
	//	*FlowKeyV6_Icmp
	//	*FlowKeyV6_Esp
	L4Fields isFlowKeyV6_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV6) Reset()                    { *m = FlowKeyV6{} }
func (m *FlowKeyV6) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV6) ProtoMessage()               {}
func (*FlowKeyV6) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{5} }

type isFlowKeyV6_L4Fields interface {
	isFlowKeyV6_L4Fields()
}

type FlowKeyV6_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV6_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV6_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV6_TcpUdp) isFlowKeyV6_L4Fields() {}
func (*FlowKeyV6_Icmp) isFlowKeyV6_L4Fields()   {}
func (*FlowKeyV6_Esp) isFlowKeyV6_L4Fields()    {}

func (m *FlowKeyV6) GetL4Fields() isFlowKeyV6_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV6) GetSip() *IPAddress {
	if m != nil {
		return m.Sip
	}
	return nil
}

func (m *FlowKeyV6) GetDip() *IPAddress {
	if m != nil {
		return m.Dip
	}
	return nil
}

func (m *FlowKeyV6) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV6) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV6) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV6) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV6) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV6_OneofMarshaler, _FlowKeyV6_OneofUnmarshaler, _FlowKeyV6_OneofSizer, []interface{}{
		(*FlowKeyV6_TcpUdp)(nil),
		(*FlowKeyV6_Icmp)(nil),
		(*FlowKeyV6_Esp)(nil),
	}
}

func _FlowKeyV6_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV6_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV6_Esp:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV6.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV6_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV6)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV6_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowKey is the key for uni-directional flow
type FlowKey struct {
	// Types that are valid to be assigned to FlowKey:
	//	*FlowKey_L2Key
	//	*FlowKey_V4Key
	//	*FlowKey_V6Key
	FlowKey isFlowKey_FlowKey `protobuf_oneof:"flow_key"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{6} }

type isFlowKey_FlowKey interface {
	isFlowKey_FlowKey()
}

type FlowKey_L2Key struct {
	L2Key *FlowKeyL2 `protobuf:"bytes,1,opt,name=l2_key,json=l2Key,oneof"`
}
type FlowKey_V4Key struct {
	V4Key *FlowKeyV4 `protobuf:"bytes,2,opt,name=v4_key,json=v4Key,oneof"`
}
type FlowKey_V6Key struct {
	V6Key *FlowKeyV6 `protobuf:"bytes,3,opt,name=v6_key,json=v6Key,oneof"`
}

func (*FlowKey_L2Key) isFlowKey_FlowKey() {}
func (*FlowKey_V4Key) isFlowKey_FlowKey() {}
func (*FlowKey_V6Key) isFlowKey_FlowKey() {}

func (m *FlowKey) GetFlowKey() isFlowKey_FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowKey) GetL2Key() *FlowKeyL2 {
	if x, ok := m.GetFlowKey().(*FlowKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *FlowKey) GetV4Key() *FlowKeyV4 {
	if x, ok := m.GetFlowKey().(*FlowKey_V4Key); ok {
		return x.V4Key
	}
	return nil
}

func (m *FlowKey) GetV6Key() *FlowKeyV6 {
	if x, ok := m.GetFlowKey().(*FlowKey_V6Key); ok {
		return x.V6Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKey_OneofMarshaler, _FlowKey_OneofUnmarshaler, _FlowKey_OneofSizer, []interface{}{
		(*FlowKey_L2Key)(nil),
		(*FlowKey_V4Key)(nil),
		(*FlowKey_V6Key)(nil),
	}
}

func _FlowKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *FlowKey_V4Key:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V4Key); err != nil {
			return err
		}
	case *FlowKey_V6Key:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V6Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKey.FlowKey has unexpected type %T", x)
	}
	return nil
}

func _FlowKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKey)
	switch tag {
	case 1: // flow_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyL2)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_L2Key{msg}
		return true, err
	case 2: // flow_key.v4_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV4)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V4Key{msg}
		return true, err
	case 3: // flow_key.v6_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV6)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V6Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V4Key:
		s := proto.Size(x.V4Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V6Key:
		s := proto.Size(x.V6Key)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
type FlowInfo struct {
	FlowAction        FlowAction         `protobuf:"varint,1,opt,name=flow_action,json=flowAction,enum=session.FlowAction" json:"flow_action,omitempty"`
	NatType           NatType            `protobuf:"varint,2,opt,name=nat_type,json=natType,enum=session.NatType" json:"nat_type,omitempty"`
	NatSip            *IPAddress         `protobuf:"bytes,3,opt,name=nat_sip,json=natSip" json:"nat_sip,omitempty"`
	NatSport          uint32             `protobuf:"varint,4,opt,name=nat_sport,json=natSport" json:"nat_sport,omitempty"`
	NatDip            *IPAddress         `protobuf:"bytes,5,opt,name=nat_dip,json=natDip" json:"nat_dip,omitempty"`
	NatDport          uint32             `protobuf:"varint,6,opt,name=nat_dport,json=natDport" json:"nat_dport,omitempty"`
	TcpState          FlowTCPState       `protobuf:"varint,7,opt,name=tcp_state,json=tcpState,enum=session.FlowTCPState" json:"tcp_state,omitempty"`
	InQosActions      *QOSActions        `protobuf:"bytes,8,opt,name=in_qos_actions,json=inQosActions" json:"in_qos_actions,omitempty"`
	EgQosActions      *QOSActions        `protobuf:"bytes,9,opt,name=eg_qos_actions,json=egQosActions" json:"eg_qos_actions,omitempty"`
	IngMirrorSessions []*MirrorSessionId `protobuf:"bytes,10,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty"`
	EgrMirrorSessions []*MirrorSessionId `protobuf:"bytes,11,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty"`
}

func (m *FlowInfo) Reset()                    { *m = FlowInfo{} }
func (m *FlowInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowInfo) ProtoMessage()               {}
func (*FlowInfo) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{7} }

func (m *FlowInfo) GetFlowAction() FlowAction {
	if m != nil {
		return m.FlowAction
	}
	return FlowAction_FLOW_ACTION_NONE
}

func (m *FlowInfo) GetNatType() NatType {
	if m != nil {
		return m.NatType
	}
	return NatType_NAT_TYPE_NONE
}

func (m *FlowInfo) GetNatSip() *IPAddress {
	if m != nil {
		return m.NatSip
	}
	return nil
}

func (m *FlowInfo) GetNatSport() uint32 {
	if m != nil {
		return m.NatSport
	}
	return 0
}

func (m *FlowInfo) GetNatDip() *IPAddress {
	if m != nil {
		return m.NatDip
	}
	return nil
}

func (m *FlowInfo) GetNatDport() uint32 {
	if m != nil {
		return m.NatDport
	}
	return 0
}

func (m *FlowInfo) GetTcpState() FlowTCPState {
	if m != nil {
		return m.TcpState
	}
	return FlowTCPState_FLOW_TCP_STATE_INIT
}

func (m *FlowInfo) GetInQosActions() *QOSActions {
	if m != nil {
		return m.InQosActions
	}
	return nil
}

func (m *FlowInfo) GetEgQosActions() *QOSActions {
	if m != nil {
		return m.EgQosActions
	}
	return nil
}

func (m *FlowInfo) GetIngMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *FlowInfo) GetEgrMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
type ConnTrackInfo struct {
	FlowCreateTs  uint64 `protobuf:"fixed64,1,opt,name=flow_create_ts,json=flowCreateTs" json:"flow_create_ts,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes" json:"flow_bytes,omitempty"`
	FlowPackets   uint32 `protobuf:"fixed32,3,opt,name=flow_packets,json=flowPackets" json:"flow_packets,omitempty"`
	ExceptionBits uint32 `protobuf:"fixed32,4,opt,name=exception_bits,json=exceptionBits" json:"exception_bits,omitempty"`
	TcpSeqNum     uint32 `protobuf:"fixed32,5,opt,name=tcp_seq_num,json=tcpSeqNum" json:"tcp_seq_num,omitempty"`
	TcpAckNum     uint32 `protobuf:"fixed32,6,opt,name=tcp_ack_num,json=tcpAckNum" json:"tcp_ack_num,omitempty"`
	TcpWinSz      uint32 `protobuf:"varint,7,opt,name=tcp_win_sz,json=tcpWinSz" json:"tcp_win_sz,omitempty"`
	TcpWinScale   uint32 `protobuf:"varint,8,opt,name=tcp_win_scale,json=tcpWinScale" json:"tcp_win_scale,omitempty"`
	TcpMss        uint32 `protobuf:"varint,9,opt,name=tcp_mss,json=tcpMss" json:"tcp_mss,omitempty"`
}

func (m *ConnTrackInfo) Reset()                    { *m = ConnTrackInfo{} }
func (m *ConnTrackInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnTrackInfo) ProtoMessage()               {}
func (*ConnTrackInfo) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{8} }

func (m *ConnTrackInfo) GetFlowCreateTs() uint64 {
	if m != nil {
		return m.FlowCreateTs
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *ConnTrackInfo) GetExceptionBits() uint32 {
	if m != nil {
		return m.ExceptionBits
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpSeqNum() uint32 {
	if m != nil {
		return m.TcpSeqNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpAckNum() uint32 {
	if m != nil {
		return m.TcpAckNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinSz() uint32 {
	if m != nil {
		return m.TcpWinSz
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinScale() uint32 {
	if m != nil {
		return m.TcpWinScale
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpMss() uint32 {
	if m != nil {
		return m.TcpMss
	}
	return 0
}

// FlowData captures all the flow information
type FlowData struct {
	FlowInfo      *FlowInfo      `protobuf:"bytes,1,opt,name=flow_info,json=flowInfo" json:"flow_info,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
}

func (m *FlowData) Reset()                    { *m = FlowData{} }
func (m *FlowData) String() string            { return proto.CompactTextString(m) }
func (*FlowData) ProtoMessage()               {}
func (*FlowData) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{9} }

func (m *FlowData) GetFlowInfo() *FlowInfo {
	if m != nil {
		return m.FlowInfo
	}
	return nil
}

func (m *FlowData) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
type FlowSpec struct {
	FlowKey  *FlowKey  `protobuf:"bytes,1,opt,name=flow_key,json=flowKey" json:"flow_key,omitempty"`
	FlowData *FlowData `protobuf:"bytes,2,opt,name=flow_data,json=flowData" json:"flow_data,omitempty"`
}

func (m *FlowSpec) Reset()                    { *m = FlowSpec{} }
func (m *FlowSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowSpec) ProtoMessage()               {}
func (*FlowSpec) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{10} }

func (m *FlowSpec) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowSpec) GetFlowData() *FlowData {
	if m != nil {
		return m.FlowData
	}
	return nil
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
type SessionSpec struct {
	Meta             *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionId        uint32      `protobuf:"fixed32,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	ConnTrackEn      bool        `protobuf:"varint,3,opt,name=conn_track_en,json=connTrackEn" json:"conn_track_en,omitempty"`
	TcpTsOption      bool        `protobuf:"varint,4,opt,name=tcp_ts_option,json=tcpTsOption" json:"tcp_ts_option,omitempty"`
	IflowSynAckDelta int32       `protobuf:"zigzag32,5,opt,name=iflow_syn_ack_delta,json=iflowSynAckDelta" json:"iflow_syn_ack_delta,omitempty"`
	InitiatorFlow    *FlowSpec   `protobuf:"bytes,6,opt,name=initiator_flow,json=initiatorFlow" json:"initiator_flow,omitempty"`
	ResponderFlow    *FlowSpec   `protobuf:"bytes,7,opt,name=responder_flow,json=responderFlow" json:"responder_flow,omitempty"`
}

func (m *SessionSpec) Reset()                    { *m = SessionSpec{} }
func (m *SessionSpec) String() string            { return proto.CompactTextString(m) }
func (*SessionSpec) ProtoMessage()               {}
func (*SessionSpec) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{11} }

func (m *SessionSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionSpec) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SessionSpec) GetTcpTsOption() bool {
	if m != nil {
		return m.TcpTsOption
	}
	return false
}

func (m *SessionSpec) GetIflowSynAckDelta() int32 {
	if m != nil {
		return m.IflowSynAckDelta
	}
	return 0
}

func (m *SessionSpec) GetInitiatorFlow() *FlowSpec {
	if m != nil {
		return m.InitiatorFlow
	}
	return nil
}

func (m *SessionSpec) GetResponderFlow() *FlowSpec {
	if m != nil {
		return m.ResponderFlow
	}
	return nil
}

// SessionRequestMsg is batched session request message
type SessionRequestMsg struct {
	Request []*SessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionRequestMsg) Reset()                    { *m = SessionRequestMsg{} }
func (m *SessionRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionRequestMsg) ProtoMessage()               {}
func (*SessionRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{12} }

func (m *SessionRequestMsg) GetRequest() []*SessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
type FlowStatus struct {
	FlowHandle    uint64         `protobuf:"fixed64,1,opt,name=flow_handle,json=flowHandle" json:"flow_handle,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
	FlowColl      bool           `protobuf:"varint,3,opt,name=flow_coll,json=flowColl" json:"flow_coll,omitempty"`
}

func (m *FlowStatus) Reset()                    { *m = FlowStatus{} }
func (m *FlowStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowStatus) ProtoMessage()               {}
func (*FlowStatus) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{13} }

func (m *FlowStatus) GetFlowHandle() uint64 {
	if m != nil {
		return m.FlowHandle
	}
	return 0
}

func (m *FlowStatus) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

func (m *FlowStatus) GetFlowColl() bool {
	if m != nil {
		return m.FlowColl
	}
	return false
}

// SessionStatus captures the operational status of the session
type SessionStatus struct {
	SessionHandle uint64      `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
	IflowStatus   *FlowStatus `protobuf:"bytes,2,opt,name=iflow_status,json=iflowStatus" json:"iflow_status,omitempty"`
	RflowStatus   *FlowStatus `protobuf:"bytes,3,opt,name=rflow_status,json=rflowStatus" json:"rflow_status,omitempty"`
}

func (m *SessionStatus) Reset()                    { *m = SessionStatus{} }
func (m *SessionStatus) String() string            { return proto.CompactTextString(m) }
func (*SessionStatus) ProtoMessage()               {}
func (*SessionStatus) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{14} }

func (m *SessionStatus) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

func (m *SessionStatus) GetIflowStatus() *FlowStatus {
	if m != nil {
		return m.IflowStatus
	}
	return nil
}

func (m *SessionStatus) GetRflowStatus() *FlowStatus {
	if m != nil {
		return m.RflowStatus
	}
	return nil
}

// SessionResponse is the response to one SessionSpec
type SessionResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *SessionStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SessionResponse) Reset()                    { *m = SessionResponse{} }
func (m *SessionResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionResponse) ProtoMessage()               {}
func (*SessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{15} }

func (m *SessionResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SessionResponseMsg is the response to SessionRequestMsg
type SessionResponseMsg struct {
	Response []*SessionResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionResponseMsg) Reset()                    { *m = SessionResponseMsg{} }
func (m *SessionResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionResponseMsg) ProtoMessage()               {}
func (*SessionResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{16} }

func (m *SessionResponseMsg) GetResponse() []*SessionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SessionDeleteRequest is used to delete a session
type SessionDeleteRequest struct {
	Meta          *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionHandle uint64      `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
}

func (m *SessionDeleteRequest) Reset()                    { *m = SessionDeleteRequest{} }
func (m *SessionDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequest) ProtoMessage()               {}
func (*SessionDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{17} }

func (m *SessionDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionDeleteRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionDeleteRequestMsg is batched session delete request
type SessionDeleteRequestMsg struct {
	Request []*SessionDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionDeleteRequestMsg) Reset()                    { *m = SessionDeleteRequestMsg{} }
func (m *SessionDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequestMsg) ProtoMessage()               {}
func (*SessionDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{18} }

func (m *SessionDeleteRequestMsg) GetRequest() []*SessionDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
type SessionDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SessionDeleteResponseMsg) Reset()                    { *m = SessionDeleteResponseMsg{} }
func (m *SessionDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteResponseMsg) ProtoMessage()               {}
func (*SessionDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{19} }

func (m *SessionDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// SessionGetRequest  is used to get information about a session
type SessionGetRequest struct {
	Meta          *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionHandle uint64      `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
}

func (m *SessionGetRequest) Reset()                    { *m = SessionGetRequest{} }
func (m *SessionGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequest) ProtoMessage()               {}
func (*SessionGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{20} }

func (m *SessionGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionGetRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionGetRequestMsg  is batched get request
type SessionGetRequestMsg struct {
	Request []*SessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionGetRequestMsg) Reset()                    { *m = SessionGetRequestMsg{} }
func (m *SessionGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequestMsg) ProtoMessage()               {}
func (*SessionGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{21} }

func (m *SessionGetRequestMsg) GetRequest() []*SessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStats contains all the stats collected per flow
// TODO - Srini please add all that we have in P4 for now
type FlowStats struct {
	FlowPackets   uint32 `protobuf:"fixed32,1,opt,name=flow_packets,json=flowPackets" json:"flow_packets,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes" json:"flow_bytes,omitempty"`
	RexmitPackets uint32 `protobuf:"fixed32,3,opt,name=rexmit_packets,json=rexmitPackets" json:"rexmit_packets,omitempty"`
}

func (m *FlowStats) Reset()                    { *m = FlowStats{} }
func (m *FlowStats) String() string            { return proto.CompactTextString(m) }
func (*FlowStats) ProtoMessage()               {}
func (*FlowStats) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{22} }

func (m *FlowStats) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *FlowStats) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *FlowStats) GetRexmitPackets() uint32 {
	if m != nil {
		return m.RexmitPackets
	}
	return 0
}

// SessionStats captures statistics of all its constituent flows
type SessionStats struct {
	FlowStats []*FlowStats `protobuf:"bytes,1,rep,name=flow_stats,json=flowStats" json:"flow_stats,omitempty"`
}

func (m *SessionStats) Reset()                    { *m = SessionStats{} }
func (m *SessionStats) String() string            { return proto.CompactTextString(m) }
func (*SessionStats) ProtoMessage()               {}
func (*SessionStats) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{23} }

func (m *SessionStats) GetFlowStats() []*FlowStats {
	if m != nil {
		return m.FlowStats
	}
	return nil
}

// SessionGetResponse is response to one SessionGetRequest
type SessionGetResponse struct {
	SessionSpec   *SessionSpec   `protobuf:"bytes,1,opt,name=session_spec,json=sessionSpec" json:"session_spec,omitempty"`
	SessionStatus *SessionStatus `protobuf:"bytes,2,opt,name=session_status,json=sessionStatus" json:"session_status,omitempty"`
	SessionStats  *SessionStats  `protobuf:"bytes,3,opt,name=session_stats,json=sessionStats" json:"session_stats,omitempty"`
}

func (m *SessionGetResponse) Reset()                    { *m = SessionGetResponse{} }
func (m *SessionGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponse) ProtoMessage()               {}
func (*SessionGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{24} }

func (m *SessionGetResponse) GetSessionSpec() *SessionSpec {
	if m != nil {
		return m.SessionSpec
	}
	return nil
}

func (m *SessionGetResponse) GetSessionStatus() *SessionStatus {
	if m != nil {
		return m.SessionStatus
	}
	return nil
}

func (m *SessionGetResponse) GetSessionStats() *SessionStats {
	if m != nil {
		return m.SessionStats
	}
	return nil
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
type SessionGetResponseMsg struct {
	Response []*SessionGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionGetResponseMsg) Reset()                    { *m = SessionGetResponseMsg{} }
func (m *SessionGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponseMsg) ProtoMessage()               {}
func (*SessionGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor17, []int{25} }

func (m *SessionGetResponseMsg) GetResponse() []*SessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowKeyL2)(nil), "session.FlowKeyL2")
	proto.RegisterType((*FlowKeyTcpUdpInfo)(nil), "session.FlowKeyTcpUdpInfo")
	proto.RegisterType((*FlowKeyICMPInfo)(nil), "session.FlowKeyICMPInfo")
	proto.RegisterType((*FlowKeyESPInfo)(nil), "session.FlowKeyESPInfo")
	proto.RegisterType((*FlowKeyV4)(nil), "session.FlowKeyV4")
	proto.RegisterType((*FlowKeyV6)(nil), "session.FlowKeyV6")
	proto.RegisterType((*FlowKey)(nil), "session.FlowKey")
	proto.RegisterType((*FlowInfo)(nil), "session.FlowInfo")
	proto.RegisterType((*ConnTrackInfo)(nil), "session.ConnTrackInfo")
	proto.RegisterType((*FlowData)(nil), "session.FlowData")
	proto.RegisterType((*FlowSpec)(nil), "session.FlowSpec")
	proto.RegisterType((*SessionSpec)(nil), "session.SessionSpec")
	proto.RegisterType((*SessionRequestMsg)(nil), "session.SessionRequestMsg")
	proto.RegisterType((*FlowStatus)(nil), "session.FlowStatus")
	proto.RegisterType((*SessionStatus)(nil), "session.SessionStatus")
	proto.RegisterType((*SessionResponse)(nil), "session.SessionResponse")
	proto.RegisterType((*SessionResponseMsg)(nil), "session.SessionResponseMsg")
	proto.RegisterType((*SessionDeleteRequest)(nil), "session.SessionDeleteRequest")
	proto.RegisterType((*SessionDeleteRequestMsg)(nil), "session.SessionDeleteRequestMsg")
	proto.RegisterType((*SessionDeleteResponseMsg)(nil), "session.SessionDeleteResponseMsg")
	proto.RegisterType((*SessionGetRequest)(nil), "session.SessionGetRequest")
	proto.RegisterType((*SessionGetRequestMsg)(nil), "session.SessionGetRequestMsg")
	proto.RegisterType((*FlowStats)(nil), "session.FlowStats")
	proto.RegisterType((*SessionStats)(nil), "session.SessionStats")
	proto.RegisterType((*SessionGetResponse)(nil), "session.SessionGetResponse")
	proto.RegisterType((*SessionGetResponseMsg)(nil), "session.SessionGetResponseMsg")
	proto.RegisterEnum("session.NatType", NatType_name, NatType_value)
	proto.RegisterEnum("session.FlowAction", FlowAction_name, FlowAction_value)
	proto.RegisterEnum("session.FlowTCPState", FlowTCPState_name, FlowTCPState_value)
	proto.RegisterEnum("session.FlowType", FlowType_name, FlowType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Session service

type SessionClient interface {
	SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error)
	SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error)
	SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error)
}

type sessionClient struct {
	cc *grpc.ClientConn
}

func NewSessionClient(cc *grpc.ClientConn) SessionClient {
	return &sessionClient{cc}
}

func (c *sessionClient) SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error) {
	out := new(SessionResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error) {
	out := new(SessionDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error) {
	out := new(SessionGetResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Session service

type SessionServer interface {
	SessionCreate(context.Context, *SessionRequestMsg) (*SessionResponseMsg, error)
	SessionDelete(context.Context, *SessionDeleteRequestMsg) (*SessionDeleteResponseMsg, error)
	SessionGet(context.Context, *SessionGetRequestMsg) (*SessionGetResponseMsg, error)
}

func RegisterSessionServer(s *grpc.Server, srv SessionServer) {
	s.RegisterService(&_Session_serviceDesc, srv)
}

func _Session_SessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionCreate(ctx, req.(*SessionRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionDelete(ctx, req.(*SessionDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionGet(ctx, req.(*SessionGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Session_serviceDesc = grpc.ServiceDesc{
	ServiceName: "session.Session",
	HandlerType: (*SessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SessionCreate",
			Handler:    _Session_SessionCreate_Handler,
		},
		{
			MethodName: "SessionDelete",
			Handler:    _Session_SessionDelete_Handler,
		},
		{
			MethodName: "SessionGet",
			Handler:    _Session_SessionGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/session.proto",
}

func init() { proto.RegisterFile("nic/proto/hal/session.proto", fileDescriptor17) }

var fileDescriptor17 = []byte{
	// 1854 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x51, 0x6f, 0xdb, 0xc8,
	0xf1, 0xb7, 0x24, 0x5b, 0x92, 0x47, 0x96, 0x43, 0xaf, 0xed, 0x58, 0x7f, 0xfb, 0xef, 0x5c, 0x42,
	0x34, 0xc0, 0x35, 0x69, 0x1d, 0x54, 0xf5, 0xf9, 0x8a, 0x02, 0x6d, 0x21, 0x4b, 0xca, 0x59, 0x89,
	0x2c, 0xe9, 0x96, 0x6c, 0x82, 0xdc, 0x0b, 0xc1, 0x50, 0x6b, 0x85, 0x35, 0x45, 0xd2, 0xdc, 0x75,
	0x72, 0xce, 0x47, 0xe8, 0x67, 0xe8, 0x53, 0x1f, 0xfa, 0x15, 0x8a, 0xa2, 0x40, 0x9f, 0xfb, 0xa1,
	0x0e, 0x45, 0xb1, 0xb3, 0x4b, 0x4a, 0xa2, 0xe5, 0xe4, 0x80, 0xa2, 0x2f, 0x7d, 0xd2, 0xee, 0xcc,
	0x6f, 0x66, 0x67, 0x67, 0x7e, 0x33, 0x4b, 0x08, 0x0e, 0x42, 0xdf, 0x7b, 0x16, 0x27, 0x91, 0x88,
	0x9e, 0xbd, 0x73, 0x83, 0x67, 0x9c, 0x71, 0xee, 0x47, 0xe1, 0x11, 0x4a, 0x48, 0x45, 0x6f, 0xf7,
	0x77, 0x67, 0x28, 0x71, 0x13, 0x33, 0xae, 0xf4, 0xfb, 0x7b, 0x8b, 0xc6, 0x57, 0x51, 0xaa, 0x38,
	0x5c, 0x54, 0x08, 0x16, 0xb0, 0x29, 0x13, 0xc9, 0x8d, 0x52, 0x9b, 0xef, 0x61, 0xfd, 0x79, 0x10,
	0x7d, 0x78, 0xc9, 0x6e, 0xfa, 0x4d, 0x42, 0x60, 0x95, 0x4f, 0x5d, 0xaf, 0x51, 0x78, 0x58, 0xf8,
	0xb2, 0x4c, 0x71, 0x2d, 0x65, 0x63, 0x29, 0x2b, 0x2a, 0x99, 0x5c, 0x93, 0x43, 0x00, 0x26, 0xde,
	0xb1, 0xc4, 0x91, 0x11, 0x34, 0x56, 0x1f, 0x16, 0xbe, 0xac, 0xd3, 0x75, 0x94, 0xd8, 0x37, 0x31,
	0x23, 0x26, 0xd4, 0x83, 0xa6, 0xc3, 0xd9, 0x64, 0xca, 0x42, 0xe1, 0xf8, 0xe3, 0x46, 0x09, 0x11,
	0xb5, 0xa0, 0x69, 0x29, 0x59, 0x6f, 0x6c, 0xfe, 0x0e, 0xb6, 0xf4, 0xb9, 0xb6, 0x17, 0xff, 0x7e,
	0x1c, 0xf7, 0xc2, 0x8b, 0x88, 0xec, 0xc0, 0x1a, 0x8f, 0xa3, 0x44, 0x60, 0x00, 0x75, 0xaa, 0x36,
	0x52, 0x3a, 0x46, 0x69, 0x51, 0x49, 0x71, 0x63, 0xf6, 0xe0, 0x9e, 0x76, 0xd0, 0x6b, 0x9f, 0x8f,
	0xd0, 0x9c, 0xc0, 0x2a, 0x06, 0xa4, 0xac, 0x71, 0x2d, 0x65, 0x5e, 0x34, 0x66, 0xda, 0x16, 0xd7,
	0x64, 0x13, 0x8a, 0x59, 0x50, 0x45, 0x7f, 0x6c, 0x9a, 0xb0, 0xa9, 0x5d, 0x75, 0x2d, 0xe5, 0xc9,
	0x80, 0x12, 0x8f, 0x7d, 0xed, 0x48, 0x2e, 0xcd, 0x7f, 0x15, 0xb2, 0x44, 0xbd, 0x3a, 0x46, 0xbd,
	0x1f, 0xa3, 0xbe, 0x42, 0xe5, 0x52, 0x4a, 0xc6, 0x7e, 0x8c, 0xc7, 0x54, 0xa8, 0x5c, 0x92, 0x9f,
	0x41, 0xd5, 0x8f, 0x1d, 0xcc, 0x32, 0x9e, 0xb5, 0xd9, 0xdc, 0x3a, 0x52, 0x15, 0xeb, 0x8d, 0x46,
	0x52, 0xea, 0x45, 0x01, 0xad, 0xf8, 0x31, 0xae, 0xc9, 0x57, 0x50, 0x11, 0x5e, 0xec, 0x5c, 0x8f,
	0x63, 0xcc, 0x67, 0xad, 0xb9, 0x7f, 0x94, 0x12, 0xe0, 0x56, 0x9e, 0xce, 0x56, 0x68, 0x59, 0xe0,
	0x8e, 0x1c, 0xc1, 0xaa, 0xef, 0x4d, 0xe3, 0xc6, 0x1a, 0xda, 0x34, 0xf2, 0x36, 0x69, 0x6a, 0xce,
	0x56, 0x28, 0xe2, 0xc8, 0x53, 0x28, 0x31, 0x1e, 0x37, 0xca, 0x08, 0xdf, 0xcb, 0xc3, 0xf5, 0xf5,
	0xcf, 0x56, 0xa8, 0x44, 0x9d, 0xd6, 0x60, 0x3d, 0x38, 0x76, 0x2e, 0x7c, 0x16, 0x8c, 0xb9, 0xf9,
	0xe7, 0xe2, 0x2c, 0x01, 0x27, 0xc4, 0x9c, 0x25, 0xa0, 0xd6, 0x34, 0xb2, 0x7b, 0xb5, 0xc6, 0xe3,
	0x84, 0x71, 0xae, 0x52, 0x62, 0xce, 0x52, 0xb2, 0x14, 0xf3, 0x3f, 0x98, 0xa4, 0x3f, 0x15, 0xa0,
	0xa2, 0x61, 0xe4, 0x29, 0x94, 0x83, 0xa6, 0x73, 0xc9, 0x6e, 0x74, 0x96, 0x48, 0xde, 0x51, 0xbf,
	0x79, 0xb6, 0x42, 0xd7, 0x82, 0xa6, 0x06, 0xbf, 0x3f, 0x46, 0x70, 0x71, 0x39, 0xf8, 0xd5, 0xb1,
	0x04, 0xbf, 0x3f, 0x4e, 0xc1, 0x27, 0x08, 0x2e, 0xdd, 0x01, 0x3e, 0x41, 0xf0, 0xc9, 0x4b, 0x76,
	0x73, 0x0a, 0x50, 0xbd, 0x08, 0xa2, 0x0f, 0x12, 0x6e, 0xfe, 0x75, 0x15, 0xaa, 0x12, 0x82, 0x1c,
	0x3f, 0x86, 0x1a, 0x2a, 0x5c, 0x4f, 0xf8, 0x51, 0x88, 0x41, 0x6e, 0x36, 0xb7, 0x17, 0x5c, 0xb5,
	0x50, 0x45, 0xe1, 0x22, 0x5b, 0x93, 0xa7, 0x50, 0x0d, 0x5d, 0xa1, 0x1a, 0xbf, 0x88, 0x26, 0x46,
	0x66, 0x32, 0x70, 0x85, 0xec, 0x7f, 0x5a, 0x09, 0xd5, 0x82, 0xfc, 0x14, 0xe4, 0xd2, 0x91, 0x4c,
	0x29, 0xdd, 0xc1, 0x82, 0x72, 0xe8, 0x0a, 0xcb, 0x8f, 0xc9, 0x01, 0xac, 0x23, 0x14, 0x1b, 0x5d,
	0x4d, 0x14, 0x79, 0x90, 0x85, 0x13, 0x40, 0xfb, 0x91, 0x6c, 0x5a, 0xfb, 0x84, 0x9f, 0xce, 0xcc,
	0x8f, 0x1a, 0x18, 0xe5, 0xcc, 0x4f, 0x07, 0xfd, 0x34, 0x61, 0x5d, 0xf2, 0x87, 0x0b, 0x57, 0xb0,
	0x46, 0x05, 0xa3, 0xdf, 0x5d, 0xb8, 0xb0, 0xdd, 0x1e, 0x59, 0x52, 0x49, 0xab, 0xc2, 0x8b, 0x71,
	0x45, 0xbe, 0x82, 0x4d, 0x3f, 0x74, 0xae, 0x22, 0xae, 0x13, 0xc5, 0x1b, 0x55, 0x0c, 0xe1, 0xde,
	0x91, 0x9c, 0xb1, 0xdf, 0x0e, 0x2d, 0x95, 0x18, 0x4e, 0x37, 0xfc, 0xf0, 0xdb, 0x88, 0xeb, 0x9d,
	0x34, 0x63, 0x93, 0x05, 0xb3, 0xf5, 0x3b, 0xcc, 0xd8, 0x64, 0xce, 0xec, 0x05, 0x6c, 0xfb, 0xe1,
	0xc4, 0x99, 0xfa, 0x49, 0x12, 0x25, 0x8e, 0x0e, 0x8d, 0x37, 0xe0, 0x61, 0x09, 0xd9, 0x3e, 0x9b,
	0xde, 0xe7, 0x88, 0xb0, 0x14, 0xa0, 0x37, 0xa6, 0x5b, 0x7e, 0x38, 0x59, 0x90, 0xa1, 0x2f, 0x36,
	0x49, 0x6e, 0xf9, 0xaa, 0x7d, 0xde, 0x17, 0x9b, 0x24, 0x8b, 0xbe, 0xcc, 0xbf, 0x15, 0xa1, 0xde,
	0x8e, 0xc2, 0xd0, 0x4e, 0x5c, 0xef, 0x12, 0xe9, 0xf3, 0x13, 0xd8, 0x44, 0xfa, 0x78, 0x09, 0x73,
	0x05, 0x73, 0x04, 0xd7, 0xaf, 0xc6, 0x86, 0x94, 0xb6, 0x51, 0x68, 0x73, 0xf9, 0x52, 0x20, 0xea,
	0xed, 0x8d, 0x60, 0x5c, 0xbf, 0x21, 0xeb, 0x52, 0x72, 0x2a, 0x05, 0xe4, 0x11, 0x20, 0xdc, 0x89,
	0x5d, 0xef, 0x92, 0x09, 0x8e, 0x2c, 0xa9, 0x50, 0xe4, 0xe5, 0x48, 0x89, 0xc8, 0x63, 0xd8, 0x64,
	0xdf, 0x7b, 0x2c, 0x96, 0xf9, 0x71, 0xde, 0xfa, 0x82, 0x23, 0x3b, 0x2a, 0xb4, 0x9e, 0x49, 0x4f,
	0x7d, 0xc1, 0xc9, 0x03, 0xa8, 0x61, 0x69, 0xd9, 0x95, 0x13, 0x5e, 0x4f, 0x91, 0x26, 0x15, 0x2a,
	0xab, 0x6d, 0xb1, 0xab, 0xc1, 0xf5, 0x34, 0xd5, 0xbb, 0xde, 0x25, 0xea, 0xcb, 0x99, 0xbe, 0xe5,
	0x5d, 0x4a, 0xfd, 0xff, 0x03, 0x48, 0xfd, 0x07, 0x3f, 0x74, 0xf8, 0x47, 0xe4, 0x46, 0x1d, 0x49,
	0xf0, 0xda, 0x0f, 0xad, 0x8f, 0xf2, 0x45, 0xcb, 0xb4, 0x9e, 0x1b, 0x30, 0xe4, 0x40, 0x9d, 0xd6,
	0x34, 0x40, 0x8a, 0xc8, 0x9e, 0x1a, 0x4e, 0x53, 0xae, 0x4a, 0x5d, 0xc7, 0xf1, 0x73, 0xce, 0xb9,
	0xf9, 0x51, 0x35, 0x5d, 0xc7, 0x15, 0x2e, 0x39, 0x02, 0xbc, 0xbd, 0xe3, 0x87, 0x17, 0x91, 0x9e,
	0x0b, 0x5b, 0x0b, 0x0c, 0x94, 0xb9, 0xa5, 0xd8, 0xb1, 0x98, 0xe5, 0xdf, 0xc2, 0x3d, 0x2f, 0x0a,
	0x43, 0x47, 0xc8, 0xbc, 0x2b, 0x2b, 0x35, 0x20, 0xee, 0x67, 0x56, 0x0b, 0x65, 0xa1, 0x75, 0x6f,
	0x7e, 0x6b, 0x4e, 0xd4, 0xd9, 0x56, 0xcc, 0x3c, 0xd9, 0xba, 0xe9, 0x24, 0xc8, 0x06, 0x77, 0x6e,
	0x70, 0xd0, 0xca, 0x85, 0x9e, 0x5e, 0x69, 0xa0, 0x63, 0x57, 0xb8, 0xfa, 0xc8, 0xc5, 0x40, 0xe5,
	0x75, 0x54, 0xa0, 0x72, 0x65, 0xfe, 0xa3, 0x08, 0x35, 0xcd, 0x16, 0x3c, 0xec, 0x31, 0xac, 0x4e,
	0x99, 0x70, 0xb3, 0x3b, 0xaa, 0x7e, 0x1d, 0xbe, 0xfd, 0x03, 0xf3, 0xc4, 0x39, 0x13, 0x2e, 0x45,
	0xb5, 0xe4, 0x87, 0x76, 0x2a, 0xbf, 0x13, 0xd4, 0xeb, 0xb9, 0xce, 0x53, 0x26, 0xca, 0xbc, 0xcf,
	0x5d, 0x9f, 0x85, 0x48, 0x90, 0x2a, 0xad, 0x65, 0x97, 0xec, 0x86, 0x69, 0x6d, 0x04, 0x77, 0x22,
	0xa4, 0x03, 0xf2, 0xa3, 0x8a, 0xb5, 0xb1, 0xf9, 0x10, 0x45, 0xe4, 0xe7, 0xb0, 0xed, 0xe3, 0x75,
	0xf8, 0x4d, 0x88, 0x1c, 0x18, 0xb3, 0x40, 0xb8, 0xc8, 0x92, 0x2d, 0x6a, 0xa0, 0xca, 0xba, 0x09,
	0x5b, 0xde, 0x65, 0x47, 0xca, 0xc9, 0xaf, 0x64, 0xcf, 0xfb, 0xc2, 0x77, 0x45, 0x94, 0x38, 0x52,
	0xa9, 0xdf, 0x82, 0xc5, 0x0c, 0xc8, 0x7b, 0xd2, 0x7a, 0x06, 0x94, 0x22, 0x69, 0x99, 0x30, 0x1e,
	0x47, 0xe1, 0x98, 0x69, 0xcb, 0xca, 0x9d, 0x96, 0x19, 0x50, 0x8a, 0xcc, 0x36, 0x6c, 0xe9, 0xfc,
	0x51, 0x76, 0x75, 0xcd, 0xb8, 0x38, 0xe7, 0x13, 0x72, 0x04, 0x95, 0x44, 0xed, 0x1a, 0x05, 0x6c,
	0xdb, 0x9d, 0xcc, 0xcf, 0x5c, 0xb2, 0x69, 0x0a, 0x32, 0xff, 0x58, 0x00, 0xc0, 0x03, 0x84, 0x2b,
	0xae, 0x39, 0xf9, 0x42, 0x8f, 0xf8, 0x77, 0x6e, 0x38, 0x0e, 0x98, 0x6e, 0x50, 0x6c, 0xc8, 0x33,
	0x94, 0xfc, 0xa7, 0xf4, 0x92, 0xd3, 0x56, 0x0d, 0x81, 0x28, 0x08, 0x74, 0x6d, 0x90, 0x12, 0xed,
	0x28, 0x08, 0xcc, 0xbf, 0x14, 0xa0, 0x9e, 0x46, 0xa9, 0xe2, 0x79, 0x0c, 0x9b, 0x69, 0xb5, 0x17,
	0x42, 0xaa, 0x6b, 0xa9, 0x8e, 0xea, 0x04, 0x36, 0x74, 0xb5, 0xd0, 0x4c, 0x87, 0xb4, 0xf8, 0x34,
	0x29, 0x8f, 0xb4, 0xa6, 0x6a, 0xa7, 0xdc, 0x9f, 0xc0, 0x46, 0x32, 0x6f, 0x57, 0xfa, 0x84, 0x5d,
	0x32, 0xb3, 0x33, 0x13, 0xb8, 0x97, 0xa5, 0x5e, 0x96, 0x84, 0x33, 0xf2, 0x0c, 0xc0, 0x8d, 0xfd,
	0xd4, 0x51, 0x41, 0x3f, 0x74, 0x8a, 0xc4, 0xad, 0xd8, 0xd7, 0x5e, 0xd6, 0xdd, 0x74, 0x49, 0x8e,
	0xa0, 0xbc, 0x10, 0xed, 0xfd, 0x5b, 0x85, 0x52, 0x26, 0x1a, 0x65, 0xbe, 0x00, 0x92, 0x3b, 0x53,
	0xd6, 0xfb, 0x18, 0xaa, 0x89, 0xde, 0xea, 0x82, 0x37, 0xf2, 0x7e, 0x52, 0x38, 0xcd, 0x90, 0xe6,
	0x18, 0x76, 0xb4, 0xb2, 0xc3, 0x02, 0x26, 0x98, 0x26, 0xd0, 0x8f, 0xed, 0xc1, 0xdb, 0x55, 0x29,
	0x2e, 0xa9, 0x8a, 0x49, 0x61, 0x6f, 0xd9, 0x29, 0x32, 0xec, 0xaf, 0xf3, 0x34, 0x3d, 0xcc, 0x47,
	0xbd, 0x60, 0x32, 0xe3, 0xeb, 0x4b, 0x68, 0xe4, 0x00, 0xb3, 0x5c, 0xe4, 0x4b, 0x50, 0xfa, 0x4c,
	0x09, 0x4c, 0x37, 0xeb, 0xa0, 0x6f, 0x98, 0xf8, 0xef, 0xe4, 0xa0, 0x9f, 0x65, 0x7a, 0x76, 0x84,
	0xaa, 0x5b, 0x2e, 0x01, 0xfb, 0xf9, 0x04, 0xcc, 0xf0, 0xb3, 0xdb, 0x0b, 0xf5, 0x45, 0x2d, 0xc3,
	0xbf, 0xfd, 0x14, 0x16, 0x6e, 0x3f, 0x85, 0x9f, 0x79, 0x4c, 0x1f, 0xcb, 0xd9, 0xf3, 0xfd, 0xd4,
	0x17, 0xb9, 0xe7, 0xb4, 0xae, 0xa4, 0xda, 0x8b, 0xd9, 0x82, 0x8d, 0x39, 0x4a, 0x72, 0xf2, 0x0b,
	0xed, 0x55, 0x26, 0x9a, 0xeb, 0xf0, 0xc9, 0xad, 0x9e, 0xe1, 0xea, 0x24, 0x5c, 0x9a, 0xff, 0x2c,
	0x64, 0xec, 0xc5, 0x7b, 0xe9, 0xa6, 0xf9, 0x1a, 0x36, 0xd2, 0x24, 0xf2, 0x98, 0x79, 0x3a, 0xe7,
	0xcb, 0x47, 0x56, 0x8d, 0xcf, 0x3d, 0x16, 0xbf, 0x99, 0x65, 0xff, 0x47, 0x35, 0x51, 0x5a, 0x15,
	0xdd, 0x7b, 0xbf, 0x86, 0xfa, 0xbc, 0x79, 0xda, 0xf8, 0xbb, 0xcb, 0xac, 0x39, 0xdd, 0x98, 0x33,
	0xe6, 0xe6, 0x08, 0x76, 0x6f, 0xdf, 0x44, 0x71, 0x3a, 0xdf, 0x8a, 0x07, 0x4b, 0x6b, 0x9a, 0xef,
	0xc6, 0x27, 0xdf, 0x41, 0x45, 0x7f, 0x08, 0x93, 0x2d, 0xa8, 0x0f, 0x5a, 0xb6, 0x63, 0xbf, 0x19,
	0x75, 0x9d, 0xc1, 0x70, 0xd0, 0x35, 0x56, 0x16, 0x44, 0xd6, 0xa0, 0x65, 0x1b, 0x85, 0x05, 0x51,
	0x47, 0x8a, 0x8a, 0xe4, 0x3e, 0x90, 0x4c, 0x64, 0xbf, 0xee, 0xb5, 0xbb, 0x8e, 0x94, 0x97, 0x9e,
	0x0c, 0xd5, 0x78, 0xd7, 0xdf, 0xe2, 0x3b, 0x60, 0x3c, 0xef, 0x0f, 0x5f, 0x3b, 0xad, 0xb6, 0xdd,
	0x1b, 0x0e, 0xd2, 0x13, 0x76, 0x61, 0x6b, 0x5e, 0xda, 0xea, 0xf7, 0x87, 0xaf, 0x8d, 0x42, 0x1e,
	0xdc, 0xa1, 0xc3, 0x91, 0x51, 0x7c, 0xf2, 0x43, 0x01, 0x36, 0xe6, 0x3f, 0x7c, 0xc9, 0x1e, 0x6c,
	0x23, 0xcc, 0x6e, 0x8f, 0x1c, 0xcb, 0x6e, 0xd9, 0x5d, 0xa7, 0x37, 0xe8, 0xd9, 0xc6, 0x0a, 0x39,
	0x80, 0xbd, 0x9c, 0xc2, 0x7a, 0x33, 0x70, 0x68, 0xfb, 0x55, 0xc7, 0x28, 0x2c, 0x51, 0xb6, 0xda,
	0x2f, 0x95, 0xb2, 0x48, 0xbe, 0x80, 0x83, 0x25, 0x96, 0x19, 0xa0, 0x44, 0x1e, 0xc0, 0x7e, 0x0e,
	0xd0, 0xb5, 0xec, 0xd6, 0x69, 0xbf, 0x67, 0x9d, 0x75, 0x3b, 0xc6, 0xea, 0x12, 0xef, 0xcf, 0x7b,
	0xfa, 0xe8, 0x35, 0xf2, 0x08, 0x0e, 0x73, 0xca, 0xd3, 0x5e, 0xa7, 0x47, 0x67, 0x90, 0x32, 0x69,
	0xc0, 0x4e, 0x0e, 0x42, 0xbb, 0x56, 0xd7, 0x36, 0x2a, 0x4f, 0xfe, 0x5e, 0x50, 0xdf, 0x47, 0xb6,
	0xfa, 0xab, 0x60, 0x53, 0xc1, 0xe6, 0xca, 0xf5, 0x7f, 0xb0, 0x3b, 0x93, 0xb5, 0xfb, 0x2d, 0xcb,
	0xea, 0xb5, 0x9d, 0x41, 0xaf, 0x6d, 0x14, 0x16, 0xe1, 0xb4, 0x73, 0xde, 0x32, 0x8a, 0x59, 0x92,
	0x55, 0xe1, 0xda, 0x23, 0xbb, 0x6f, 0x19, 0x25, 0xb2, 0x0d, 0xf7, 0x66, 0xd2, 0xde, 0xc8, 0xea,
	0xb6, 0x8d, 0x55, 0x59, 0xf5, 0xb9, 0xd3, 0x3a, 0x5d, 0x63, 0x2d, 0xab, 0x9c, 0x22, 0x87, 0x3d,
	0xa4, 0xad, 0x6f, 0xba, 0x46, 0x79, 0x56, 0x12, 0x74, 0xda, 0xed, 0x77, 0xcf, 0xbb, 0x36, 0x7d,
	0x63, 0x54, 0x9a, 0x3f, 0x14, 0xa0, 0xa2, 0xa9, 0x48, 0x5e, 0x64, 0x6f, 0xad, 0xfa, 0xf6, 0x26,
	0xfb, 0xb7, 0x1f, 0x8e, 0x74, 0x5c, 0xed, 0x1f, 0xdc, 0xf5, 0xa8, 0x9c, 0xf3, 0x89, 0xb9, 0x42,
	0x5e, 0x65, 0xbe, 0xd4, 0x54, 0x26, 0x0f, 0x3f, 0x39, 0xce, 0xa5, 0xc7, 0x47, 0x77, 0x21, 0xe6,
	0xfd, 0x9e, 0x03, 0xcc, 0x3a, 0x87, 0x1c, 0xde, 0x3d, 0x22, 0xa5, 0xc7, 0x07, 0x9f, 0xe8, 0x36,
	0x74, 0x77, 0x0a, 0xdf, 0x55, 0xdf, 0xb9, 0x01, 0xfe, 0x77, 0xf0, 0xb6, 0x8c, 0x3f, 0xbf, 0xfc,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x46, 0xbf, 0x7d, 0xfa, 0x44, 0x13, 0x00, 0x00,
}
