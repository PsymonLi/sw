// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: session.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Types of NAT
type NatType int32

const (
	NatType_NAT_TYPE_NONE      NatType = 0
	NatType_NAT_TYPE_SNAT      NatType = 1
	NatType_NAT_TYPE_DNAT      NatType = 2
	NatType_NAT_TYPE_TWICE_NAT NatType = 3
)

var NatType_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_SNAT",
	2: "NAT_TYPE_DNAT",
	3: "NAT_TYPE_TWICE_NAT",
}
var NatType_value = map[string]int32{
	"NAT_TYPE_NONE":      0,
	"NAT_TYPE_SNAT":      1,
	"NAT_TYPE_DNAT":      2,
	"NAT_TYPE_TWICE_NAT": 3,
}

func (x NatType) String() string {
	return proto.EnumName(NatType_name, int32(x))
}
func (NatType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSession, []int{0} }

// Flow actions
type FlowAction int32

const (
	FlowAction_FLOW_ACTION_NONE  FlowAction = 0
	FlowAction_FLOW_ACTION_ALLOW FlowAction = 1
	FlowAction_FLOW_ACTION_DROP  FlowAction = 2
)

var FlowAction_name = map[int32]string{
	0: "FLOW_ACTION_NONE",
	1: "FLOW_ACTION_ALLOW",
	2: "FLOW_ACTION_DROP",
}
var FlowAction_value = map[string]int32{
	"FLOW_ACTION_NONE":  0,
	"FLOW_ACTION_ALLOW": 1,
	"FLOW_ACTION_DROP":  2,
}

func (x FlowAction) String() string {
	return proto.EnumName(FlowAction_name, int32(x))
}
func (FlowAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorSession, []int{1} }

// Flow TCP states
// TODO: Srini, please define all other states
type FlowTCPState int32

const (
	FlowTCPState_FLOW_TCP_STATE_INIT           FlowTCPState = 0
	FlowTCPState_FLOW_TCP_STATE_SYN_RCVD       FlowTCPState = 1
	FlowTCPState_FLOW_TCP_STATE_ACK_RCVD       FlowTCPState = 2
	FlowTCPState_FLOW_TCP_STATE_SYN_ACK_RCVD   FlowTCPState = 3
	FlowTCPState_FLOW_TCP_STATE_ESTABLISHED    FlowTCPState = 4
	FlowTCPState_FLOW_TCP_STATE_FIN_RCVD       FlowTCPState = 5
	FlowTCPState_FLOW_TCP_STATE_BIDIR_FIN_RCVD FlowTCPState = 6
	FlowTCPState_FLOW_TCP_STATE_RESET          FlowTCPState = 7
)

var FlowTCPState_name = map[int32]string{
	0: "FLOW_TCP_STATE_INIT",
	1: "FLOW_TCP_STATE_SYN_RCVD",
	2: "FLOW_TCP_STATE_ACK_RCVD",
	3: "FLOW_TCP_STATE_SYN_ACK_RCVD",
	4: "FLOW_TCP_STATE_ESTABLISHED",
	5: "FLOW_TCP_STATE_FIN_RCVD",
	6: "FLOW_TCP_STATE_BIDIR_FIN_RCVD",
	7: "FLOW_TCP_STATE_RESET",
}
var FlowTCPState_value = map[string]int32{
	"FLOW_TCP_STATE_INIT":           0,
	"FLOW_TCP_STATE_SYN_RCVD":       1,
	"FLOW_TCP_STATE_ACK_RCVD":       2,
	"FLOW_TCP_STATE_SYN_ACK_RCVD":   3,
	"FLOW_TCP_STATE_ESTABLISHED":    4,
	"FLOW_TCP_STATE_FIN_RCVD":       5,
	"FLOW_TCP_STATE_BIDIR_FIN_RCVD": 6,
	"FLOW_TCP_STATE_RESET":          7,
}

func (x FlowTCPState) String() string {
	return proto.EnumName(FlowTCPState_name, int32(x))
}
func (FlowTCPState) EnumDescriptor() ([]byte, []int) { return fileDescriptorSession, []int{2} }

// App Types ... In sync with p4/nw/include/defines.h
// TODO: Revisit once we decide if flow drives app_id or service_lif
type FlowType int32

const (
	FlowType_FLOW_TYPE_NONE        FlowType = 0
	FlowType_FLOW_TYPE_CLASSIC_NIC FlowType = 1
	FlowType_FLOW_TYPE_RDMA        FlowType = 2
	FlowType_FLOW_TYPE_TCPTLS      FlowType = 3
	FlowType_FLOW_TYPE_IPSEC       FlowType = 4
	FlowType_FLOW_TYPE_NDE         FlowType = 5
	FlowType_FLOW_TYPE_STORAGE     FlowType = 6
	FlowType_FLOW_TYPE_TELEMETRY   FlowType = 7
)

var FlowType_name = map[int32]string{
	0: "FLOW_TYPE_NONE",
	1: "FLOW_TYPE_CLASSIC_NIC",
	2: "FLOW_TYPE_RDMA",
	3: "FLOW_TYPE_TCPTLS",
	4: "FLOW_TYPE_IPSEC",
	5: "FLOW_TYPE_NDE",
	6: "FLOW_TYPE_STORAGE",
	7: "FLOW_TYPE_TELEMETRY",
}
var FlowType_value = map[string]int32{
	"FLOW_TYPE_NONE":        0,
	"FLOW_TYPE_CLASSIC_NIC": 1,
	"FLOW_TYPE_RDMA":        2,
	"FLOW_TYPE_TCPTLS":      3,
	"FLOW_TYPE_IPSEC":       4,
	"FLOW_TYPE_NDE":         5,
	"FLOW_TYPE_STORAGE":     6,
	"FLOW_TYPE_TELEMETRY":   7,
}

func (x FlowType) String() string {
	return proto.EnumName(FlowType_name, int32(x))
}
func (FlowType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSession, []int{3} }

// Key for L2 flows (i.e, non-IP flows)
type FlowKeyL2 struct {
	Smac        uint64 `protobuf:"fixed64,1,opt,name=smac,proto3" json:"smac,omitempty"`
	Dmac        uint64 `protobuf:"fixed64,2,opt,name=dmac,proto3" json:"dmac,omitempty"`
	EtherType   uint32 `protobuf:"varint,4,opt,name=ether_type,json=etherType,proto3" json:"ether_type,omitempty"`
	L2SegmentId uint32 `protobuf:"varint,3,opt,name=l2_segment_id,json=l2SegmentId,proto3" json:"l2_segment_id,omitempty"`
}

func (m *FlowKeyL2) Reset()                    { *m = FlowKeyL2{} }
func (m *FlowKeyL2) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyL2) ProtoMessage()               {}
func (*FlowKeyL2) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{0} }

func (m *FlowKeyL2) GetSmac() uint64 {
	if m != nil {
		return m.Smac
	}
	return 0
}

func (m *FlowKeyL2) GetDmac() uint64 {
	if m != nil {
		return m.Dmac
	}
	return 0
}

func (m *FlowKeyL2) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

func (m *FlowKeyL2) GetL2SegmentId() uint32 {
	if m != nil {
		return m.L2SegmentId
	}
	return 0
}

type FlowKeyTcpUdpInfo struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport,proto3" json:"dport,omitempty"`
}

func (m *FlowKeyTcpUdpInfo) Reset()                    { *m = FlowKeyTcpUdpInfo{} }
func (m *FlowKeyTcpUdpInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyTcpUdpInfo) ProtoMessage()               {}
func (*FlowKeyTcpUdpInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{1} }

func (m *FlowKeyTcpUdpInfo) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FlowKeyTcpUdpInfo) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type FlowKeyICMPInfo struct {
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Id   uint32 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *FlowKeyICMPInfo) Reset()                    { *m = FlowKeyICMPInfo{} }
func (m *FlowKeyICMPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyICMPInfo) ProtoMessage()               {}
func (*FlowKeyICMPInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{2} }

func (m *FlowKeyICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type FlowKeyESPInfo struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi,proto3" json:"spi,omitempty"`
}

func (m *FlowKeyESPInfo) Reset()                    { *m = FlowKeyESPInfo{} }
func (m *FlowKeyESPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyESPInfo) ProtoMessage()               {}
func (*FlowKeyESPInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{3} }

func (m *FlowKeyESPInfo) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

// Key for IPv4 flows
type FlowKeyV4 struct {
	Sip     uint32     `protobuf:"fixed32,1,opt,name=sip,proto3" json:"sip,omitempty"`
	Dip     uint32     `protobuf:"fixed32,2,opt,name=dip,proto3" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,proto3,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV4_TcpUdp
	//	*FlowKeyV4_Icmp
	//	*FlowKeyV4_Esp
	L4Fields isFlowKeyV4_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV4) Reset()                    { *m = FlowKeyV4{} }
func (m *FlowKeyV4) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV4) ProtoMessage()               {}
func (*FlowKeyV4) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{4} }

type isFlowKeyV4_L4Fields interface {
	isFlowKeyV4_L4Fields()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowKeyV4_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV4_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV4_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV4_TcpUdp) isFlowKeyV4_L4Fields() {}
func (*FlowKeyV4_Icmp) isFlowKeyV4_L4Fields()   {}
func (*FlowKeyV4_Esp) isFlowKeyV4_L4Fields()    {}

func (m *FlowKeyV4) GetL4Fields() isFlowKeyV4_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV4) GetSip() uint32 {
	if m != nil {
		return m.Sip
	}
	return 0
}

func (m *FlowKeyV4) GetDip() uint32 {
	if m != nil {
		return m.Dip
	}
	return 0
}

func (m *FlowKeyV4) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV4) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV4) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV4) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV4) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV4_OneofMarshaler, _FlowKeyV4_OneofUnmarshaler, _FlowKeyV4_OneofSizer, []interface{}{
		(*FlowKeyV4_TcpUdp)(nil),
		(*FlowKeyV4_Icmp)(nil),
		(*FlowKeyV4_Esp)(nil),
	}
}

func _FlowKeyV4_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV4_Icmp:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV4_Esp:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV4.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV4_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV4)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV4_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for IPv6 flows
type FlowKeyV6 struct {
	Sip     *IPAddress `protobuf:"bytes,1,opt,name=sip" json:"sip,omitempty"`
	Dip     *IPAddress `protobuf:"bytes,2,opt,name=dip" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,proto3,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV6_TcpUdp
	//	*FlowKeyV6_Icmp
	//	*FlowKeyV6_Esp
	L4Fields isFlowKeyV6_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV6) Reset()                    { *m = FlowKeyV6{} }
func (m *FlowKeyV6) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV6) ProtoMessage()               {}
func (*FlowKeyV6) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{5} }

type isFlowKeyV6_L4Fields interface {
	isFlowKeyV6_L4Fields()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowKeyV6_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV6_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV6_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV6_TcpUdp) isFlowKeyV6_L4Fields() {}
func (*FlowKeyV6_Icmp) isFlowKeyV6_L4Fields()   {}
func (*FlowKeyV6_Esp) isFlowKeyV6_L4Fields()    {}

func (m *FlowKeyV6) GetL4Fields() isFlowKeyV6_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV6) GetSip() *IPAddress {
	if m != nil {
		return m.Sip
	}
	return nil
}

func (m *FlowKeyV6) GetDip() *IPAddress {
	if m != nil {
		return m.Dip
	}
	return nil
}

func (m *FlowKeyV6) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV6) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV6) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV6) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV6) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV6_OneofMarshaler, _FlowKeyV6_OneofUnmarshaler, _FlowKeyV6_OneofSizer, []interface{}{
		(*FlowKeyV6_TcpUdp)(nil),
		(*FlowKeyV6_Icmp)(nil),
		(*FlowKeyV6_Esp)(nil),
	}
}

func _FlowKeyV6_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV6_Icmp:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV6_Esp:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV6.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV6_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV6)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV6_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowKey is the key for uni-directional flow
type FlowKey struct {
	// Types that are valid to be assigned to FlowKey:
	//	*FlowKey_L2Key
	//	*FlowKey_V4Key
	//	*FlowKey_V6Key
	FlowKey isFlowKey_FlowKey `protobuf_oneof:"flow_key"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{6} }

type isFlowKey_FlowKey interface {
	isFlowKey_FlowKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowKey_L2Key struct {
	L2Key *FlowKeyL2 `protobuf:"bytes,1,opt,name=l2_key,json=l2Key,oneof"`
}
type FlowKey_V4Key struct {
	V4Key *FlowKeyV4 `protobuf:"bytes,2,opt,name=v4_key,json=v4Key,oneof"`
}
type FlowKey_V6Key struct {
	V6Key *FlowKeyV6 `protobuf:"bytes,3,opt,name=v6_key,json=v6Key,oneof"`
}

func (*FlowKey_L2Key) isFlowKey_FlowKey() {}
func (*FlowKey_V4Key) isFlowKey_FlowKey() {}
func (*FlowKey_V6Key) isFlowKey_FlowKey() {}

func (m *FlowKey) GetFlowKey() isFlowKey_FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowKey) GetL2Key() *FlowKeyL2 {
	if x, ok := m.GetFlowKey().(*FlowKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *FlowKey) GetV4Key() *FlowKeyV4 {
	if x, ok := m.GetFlowKey().(*FlowKey_V4Key); ok {
		return x.V4Key
	}
	return nil
}

func (m *FlowKey) GetV6Key() *FlowKeyV6 {
	if x, ok := m.GetFlowKey().(*FlowKey_V6Key); ok {
		return x.V6Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKey_OneofMarshaler, _FlowKey_OneofUnmarshaler, _FlowKey_OneofSizer, []interface{}{
		(*FlowKey_L2Key)(nil),
		(*FlowKey_V4Key)(nil),
		(*FlowKey_V6Key)(nil),
	}
}

func _FlowKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *FlowKey_V4Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V4Key); err != nil {
			return err
		}
	case *FlowKey_V6Key:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V6Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKey.FlowKey has unexpected type %T", x)
	}
	return nil
}

func _FlowKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKey)
	switch tag {
	case 1: // flow_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyL2)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_L2Key{msg}
		return true, err
	case 2: // flow_key.v4_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV4)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V4Key{msg}
		return true, err
	case 3: // flow_key.v6_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV6)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V6Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V4Key:
		s := proto.Size(x.V4Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V6Key:
		s := proto.Size(x.V6Key)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
type FlowInfo struct {
	FlowAction        FlowAction         `protobuf:"varint,1,opt,name=flow_action,json=flowAction,proto3,enum=session.FlowAction" json:"flow_action,omitempty"`
	NatType           NatType            `protobuf:"varint,2,opt,name=nat_type,json=natType,proto3,enum=session.NatType" json:"nat_type,omitempty"`
	NatSip            *IPAddress         `protobuf:"bytes,3,opt,name=nat_sip,json=natSip" json:"nat_sip,omitempty"`
	NatSport          uint32             `protobuf:"varint,4,opt,name=nat_sport,json=natSport,proto3" json:"nat_sport,omitempty"`
	NatDip            *IPAddress         `protobuf:"bytes,5,opt,name=nat_dip,json=natDip" json:"nat_dip,omitempty"`
	NatDport          uint32             `protobuf:"varint,6,opt,name=nat_dport,json=natDport,proto3" json:"nat_dport,omitempty"`
	NatDmac           uint64             `protobuf:"fixed64,7,opt,name=nat_dmac,json=natDmac,proto3" json:"nat_dmac,omitempty"`
	TcpState          FlowTCPState       `protobuf:"varint,8,opt,name=tcp_state,json=tcpState,proto3,enum=session.FlowTCPState" json:"tcp_state,omitempty"`
	InQosActions      *QOSActions        `protobuf:"bytes,9,opt,name=in_qos_actions,json=inQosActions" json:"in_qos_actions,omitempty"`
	EgQosActions      *QOSActions        `protobuf:"bytes,10,opt,name=eg_qos_actions,json=egQosActions" json:"eg_qos_actions,omitempty"`
	IngMirrorSessions []*MirrorSessionId `protobuf:"bytes,11,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty"`
	EgrMirrorSessions []*MirrorSessionId `protobuf:"bytes,12,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty"`
}

func (m *FlowInfo) Reset()                    { *m = FlowInfo{} }
func (m *FlowInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowInfo) ProtoMessage()               {}
func (*FlowInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{7} }

func (m *FlowInfo) GetFlowAction() FlowAction {
	if m != nil {
		return m.FlowAction
	}
	return FlowAction_FLOW_ACTION_NONE
}

func (m *FlowInfo) GetNatType() NatType {
	if m != nil {
		return m.NatType
	}
	return NatType_NAT_TYPE_NONE
}

func (m *FlowInfo) GetNatSip() *IPAddress {
	if m != nil {
		return m.NatSip
	}
	return nil
}

func (m *FlowInfo) GetNatSport() uint32 {
	if m != nil {
		return m.NatSport
	}
	return 0
}

func (m *FlowInfo) GetNatDip() *IPAddress {
	if m != nil {
		return m.NatDip
	}
	return nil
}

func (m *FlowInfo) GetNatDport() uint32 {
	if m != nil {
		return m.NatDport
	}
	return 0
}

func (m *FlowInfo) GetNatDmac() uint64 {
	if m != nil {
		return m.NatDmac
	}
	return 0
}

func (m *FlowInfo) GetTcpState() FlowTCPState {
	if m != nil {
		return m.TcpState
	}
	return FlowTCPState_FLOW_TCP_STATE_INIT
}

func (m *FlowInfo) GetInQosActions() *QOSActions {
	if m != nil {
		return m.InQosActions
	}
	return nil
}

func (m *FlowInfo) GetEgQosActions() *QOSActions {
	if m != nil {
		return m.EgQosActions
	}
	return nil
}

func (m *FlowInfo) GetIngMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *FlowInfo) GetEgrMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
type ConnTrackInfo struct {
	FlowCreateTs  uint64 `protobuf:"fixed64,1,opt,name=flow_create_ts,json=flowCreateTs,proto3" json:"flow_create_ts,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes,proto3" json:"flow_bytes,omitempty"`
	FlowPackets   uint32 `protobuf:"fixed32,3,opt,name=flow_packets,json=flowPackets,proto3" json:"flow_packets,omitempty"`
	ExceptionBits uint32 `protobuf:"fixed32,4,opt,name=exception_bits,json=exceptionBits,proto3" json:"exception_bits,omitempty"`
	TcpSeqNum     uint32 `protobuf:"fixed32,5,opt,name=tcp_seq_num,json=tcpSeqNum,proto3" json:"tcp_seq_num,omitempty"`
	TcpAckNum     uint32 `protobuf:"fixed32,6,opt,name=tcp_ack_num,json=tcpAckNum,proto3" json:"tcp_ack_num,omitempty"`
	TcpWinSz      uint32 `protobuf:"varint,7,opt,name=tcp_win_sz,json=tcpWinSz,proto3" json:"tcp_win_sz,omitempty"`
	TcpWinScale   uint32 `protobuf:"varint,8,opt,name=tcp_win_scale,json=tcpWinScale,proto3" json:"tcp_win_scale,omitempty"`
	TcpMss        uint32 `protobuf:"varint,9,opt,name=tcp_mss,json=tcpMss,proto3" json:"tcp_mss,omitempty"`
}

func (m *ConnTrackInfo) Reset()                    { *m = ConnTrackInfo{} }
func (m *ConnTrackInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnTrackInfo) ProtoMessage()               {}
func (*ConnTrackInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{8} }

func (m *ConnTrackInfo) GetFlowCreateTs() uint64 {
	if m != nil {
		return m.FlowCreateTs
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *ConnTrackInfo) GetExceptionBits() uint32 {
	if m != nil {
		return m.ExceptionBits
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpSeqNum() uint32 {
	if m != nil {
		return m.TcpSeqNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpAckNum() uint32 {
	if m != nil {
		return m.TcpAckNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinSz() uint32 {
	if m != nil {
		return m.TcpWinSz
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinScale() uint32 {
	if m != nil {
		return m.TcpWinScale
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpMss() uint32 {
	if m != nil {
		return m.TcpMss
	}
	return 0
}

// FlowData captures all the flow information
type FlowData struct {
	FlowInfo      *FlowInfo      `protobuf:"bytes,1,opt,name=flow_info,json=flowInfo" json:"flow_info,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
}

func (m *FlowData) Reset()                    { *m = FlowData{} }
func (m *FlowData) String() string            { return proto.CompactTextString(m) }
func (*FlowData) ProtoMessage()               {}
func (*FlowData) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{9} }

func (m *FlowData) GetFlowInfo() *FlowInfo {
	if m != nil {
		return m.FlowInfo
	}
	return nil
}

func (m *FlowData) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
type FlowSpec struct {
	FlowKey  *FlowKey  `protobuf:"bytes,1,opt,name=flow_key,json=flowKey" json:"flow_key,omitempty"`
	FlowData *FlowData `protobuf:"bytes,2,opt,name=flow_data,json=flowData" json:"flow_data,omitempty"`
}

func (m *FlowSpec) Reset()                    { *m = FlowSpec{} }
func (m *FlowSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowSpec) ProtoMessage()               {}
func (*FlowSpec) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{10} }

func (m *FlowSpec) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowSpec) GetFlowData() *FlowData {
	if m != nil {
		return m.FlowData
	}
	return nil
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
type SessionSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// session_id is unique session identifier
	SessionId         uint32    `protobuf:"fixed32,2,opt,name=session_id,json=sessionId,proto3" json:"key"`
	ConnTrackEn       bool      `protobuf:"varint,3,opt,name=conn_track_en,json=connTrackEn,proto3" json:"conn_track_en,omitempty"`
	TcpTsOption       bool      `protobuf:"varint,4,opt,name=tcp_ts_option,json=tcpTsOption,proto3" json:"tcp_ts_option,omitempty"`
	TcpSackPermOption bool      `protobuf:"varint,5,opt,name=tcp_sack_perm_option,json=tcpSackPermOption,proto3" json:"tcp_sack_perm_option,omitempty"`
	IflowSynAckDelta  int32     `protobuf:"zigzag32,6,opt,name=iflow_syn_ack_delta,json=iflowSynAckDelta,proto3" json:"iflow_syn_ack_delta,omitempty"`
	InitiatorFlow     *FlowSpec `protobuf:"bytes,7,opt,name=initiator_flow,json=initiatorFlow" json:"initiator_flow,omitempty"`
	ResponderFlow     *FlowSpec `protobuf:"bytes,8,opt,name=responder_flow,json=responderFlow" json:"responder_flow,omitempty"`
}

func (m *SessionSpec) Reset()                    { *m = SessionSpec{} }
func (m *SessionSpec) String() string            { return proto.CompactTextString(m) }
func (*SessionSpec) ProtoMessage()               {}
func (*SessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{11} }

func (m *SessionSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionSpec) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SessionSpec) GetTcpTsOption() bool {
	if m != nil {
		return m.TcpTsOption
	}
	return false
}

func (m *SessionSpec) GetTcpSackPermOption() bool {
	if m != nil {
		return m.TcpSackPermOption
	}
	return false
}

func (m *SessionSpec) GetIflowSynAckDelta() int32 {
	if m != nil {
		return m.IflowSynAckDelta
	}
	return 0
}

func (m *SessionSpec) GetInitiatorFlow() *FlowSpec {
	if m != nil {
		return m.InitiatorFlow
	}
	return nil
}

func (m *SessionSpec) GetResponderFlow() *FlowSpec {
	if m != nil {
		return m.ResponderFlow
	}
	return nil
}

// SessionRequestMsg is batched session request message
type SessionRequestMsg struct {
	Request []*SessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionRequestMsg) Reset()                    { *m = SessionRequestMsg{} }
func (m *SessionRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionRequestMsg) ProtoMessage()               {}
func (*SessionRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{12} }

func (m *SessionRequestMsg) GetRequest() []*SessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
type FlowStatus struct {
	FlowHandle    uint64         `protobuf:"fixed64,1,opt,name=flow_handle,json=flowHandle,proto3" json:"flow_handle,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
	FlowColl      bool           `protobuf:"varint,3,opt,name=flow_coll,json=flowColl,proto3" json:"flow_coll,omitempty"`
	FlowHash      uint32         `protobuf:"varint,4,opt,name=flow_hash,json=flowHash,proto3" json:"flow_hash,omitempty"`
}

func (m *FlowStatus) Reset()                    { *m = FlowStatus{} }
func (m *FlowStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowStatus) ProtoMessage()               {}
func (*FlowStatus) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{13} }

func (m *FlowStatus) GetFlowHandle() uint64 {
	if m != nil {
		return m.FlowHandle
	}
	return 0
}

func (m *FlowStatus) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

func (m *FlowStatus) GetFlowColl() bool {
	if m != nil {
		return m.FlowColl
	}
	return false
}

func (m *FlowStatus) GetFlowHash() uint32 {
	if m != nil {
		return m.FlowHash
	}
	return 0
}

// TFTPInfo captures the operational status of TFTP ALG session
type TFTPALGInfo struct {
	ParseError    uint32 `protobuf:"varint,1,opt,name=parse_error,json=parseError,proto3" json:"parse_error,omitempty"`
	UnknownOpcode uint32 `protobuf:"varint,2,opt,name=unknown_opcode,json=unknownOpcode,proto3" json:"unknown_opcode,omitempty"`
}

func (m *TFTPALGInfo) Reset()                    { *m = TFTPALGInfo{} }
func (m *TFTPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*TFTPALGInfo) ProtoMessage()               {}
func (*TFTPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{14} }

func (m *TFTPALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

func (m *TFTPALGInfo) GetUnknownOpcode() uint32 {
	if m != nil {
		return m.UnknownOpcode
	}
	return 0
}

// RPCInfo captures the operational status of SUNRPC/MSFT RPC ALG session
type RPCALGInfo struct {
	ParseError  uint32 `protobuf:"varint,1,opt,name=parse_error,json=parseError,proto3" json:"parse_error,omitempty"`
	NumDataSess uint32 `protobuf:"varint,2,opt,name=num_data_sess,json=numDataSess,proto3" json:"num_data_sess,omitempty"`
}

func (m *RPCALGInfo) Reset()                    { *m = RPCALGInfo{} }
func (m *RPCALGInfo) String() string            { return proto.CompactTextString(m) }
func (*RPCALGInfo) ProtoMessage()               {}
func (*RPCALGInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{15} }

func (m *RPCALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

func (m *RPCALGInfo) GetNumDataSess() uint32 {
	if m != nil {
		return m.NumDataSess
	}
	return 0
}

// SIPInfo captures the operational status of SIP ALG session
type SIPALGInfo struct {
	ParseError uint32 `protobuf:"varint,1,opt,name=parse_error,json=parseError,proto3" json:"parse_error,omitempty"`
}

func (m *SIPALGInfo) Reset()                    { *m = SIPALGInfo{} }
func (m *SIPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*SIPALGInfo) ProtoMessage()               {}
func (*SIPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{16} }

func (m *SIPALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

// SessionStatus captures the operational status of the session
type SessionStatus struct {
	SessionHandle uint64      `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	IflowStatus   *FlowStatus `protobuf:"bytes,2,opt,name=iflow_status,json=iflowStatus" json:"iflow_status,omitempty"`
	RflowStatus   *FlowStatus `protobuf:"bytes,3,opt,name=rflow_status,json=rflowStatus" json:"rflow_status,omitempty"`
	Alg           ALGName     `protobuf:"varint,4,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
	// Types that are valid to be assigned to AlgInfo:
	//	*SessionStatus_TftpInfo
	//	*SessionStatus_RpcInfo
	//	*SessionStatus_SipInfo
	AlgInfo isSessionStatus_AlgInfo `protobuf_oneof:"alg_info"`
}

func (m *SessionStatus) Reset()                    { *m = SessionStatus{} }
func (m *SessionStatus) String() string            { return proto.CompactTextString(m) }
func (*SessionStatus) ProtoMessage()               {}
func (*SessionStatus) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{17} }

type isSessionStatus_AlgInfo interface {
	isSessionStatus_AlgInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionStatus_TftpInfo struct {
	TftpInfo *TFTPALGInfo `protobuf:"bytes,5,opt,name=tftp_info,json=tftpInfo,oneof"`
}
type SessionStatus_RpcInfo struct {
	RpcInfo *RPCALGInfo `protobuf:"bytes,6,opt,name=rpc_info,json=rpcInfo,oneof"`
}
type SessionStatus_SipInfo struct {
	SipInfo *SIPALGInfo `protobuf:"bytes,7,opt,name=sip_info,json=sipInfo,oneof"`
}

func (*SessionStatus_TftpInfo) isSessionStatus_AlgInfo() {}
func (*SessionStatus_RpcInfo) isSessionStatus_AlgInfo()  {}
func (*SessionStatus_SipInfo) isSessionStatus_AlgInfo()  {}

func (m *SessionStatus) GetAlgInfo() isSessionStatus_AlgInfo {
	if m != nil {
		return m.AlgInfo
	}
	return nil
}

func (m *SessionStatus) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

func (m *SessionStatus) GetIflowStatus() *FlowStatus {
	if m != nil {
		return m.IflowStatus
	}
	return nil
}

func (m *SessionStatus) GetRflowStatus() *FlowStatus {
	if m != nil {
		return m.RflowStatus
	}
	return nil
}

func (m *SessionStatus) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

func (m *SessionStatus) GetTftpInfo() *TFTPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_TftpInfo); ok {
		return x.TftpInfo
	}
	return nil
}

func (m *SessionStatus) GetRpcInfo() *RPCALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_RpcInfo); ok {
		return x.RpcInfo
	}
	return nil
}

func (m *SessionStatus) GetSipInfo() *SIPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_SipInfo); ok {
		return x.SipInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SessionStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SessionStatus_OneofMarshaler, _SessionStatus_OneofUnmarshaler, _SessionStatus_OneofSizer, []interface{}{
		(*SessionStatus_TftpInfo)(nil),
		(*SessionStatus_RpcInfo)(nil),
		(*SessionStatus_SipInfo)(nil),
	}
}

func _SessionStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SessionStatus)
	// alg_info
	switch x := m.AlgInfo.(type) {
	case *SessionStatus_TftpInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TftpInfo); err != nil {
			return err
		}
	case *SessionStatus_RpcInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RpcInfo); err != nil {
			return err
		}
	case *SessionStatus_SipInfo:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SipInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SessionStatus.AlgInfo has unexpected type %T", x)
	}
	return nil
}

func _SessionStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SessionStatus)
	switch tag {
	case 5: // alg_info.tftp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TFTPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_TftpInfo{msg}
		return true, err
	case 6: // alg_info.rpc_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RPCALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_RpcInfo{msg}
		return true, err
	case 7: // alg_info.sip_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SIPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_SipInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SessionStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SessionStatus)
	// alg_info
	switch x := m.AlgInfo.(type) {
	case *SessionStatus_TftpInfo:
		s := proto.Size(x.TftpInfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_RpcInfo:
		s := proto.Size(x.RpcInfo)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_SipInfo:
		s := proto.Size(x.SipInfo)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SessionResponse is the response to one SessionSpec
type SessionResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *SessionStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SessionResponse) Reset()                    { *m = SessionResponse{} }
func (m *SessionResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionResponse) ProtoMessage()               {}
func (*SessionResponse) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{18} }

func (m *SessionResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SessionResponseMsg is the response to SessionRequestMsg
type SessionResponseMsg struct {
	Response []*SessionResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionResponseMsg) Reset()                    { *m = SessionResponseMsg{} }
func (m *SessionResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionResponseMsg) ProtoMessage()               {}
func (*SessionResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{19} }

func (m *SessionResponseMsg) GetResponse() []*SessionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SessionDeleteRequest is used to delete a session
type SessionDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// session_handle is the handle of the session
	SessionHandle uint64 `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle,proto3" json:"key"`
}

func (m *SessionDeleteRequest) Reset()                    { *m = SessionDeleteRequest{} }
func (m *SessionDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequest) ProtoMessage()               {}
func (*SessionDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{20} }

func (m *SessionDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionDeleteRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionDeleteRequestMsg is batched session delete request
type SessionDeleteRequestMsg struct {
	Request []*SessionDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionDeleteRequestMsg) Reset()                    { *m = SessionDeleteRequestMsg{} }
func (m *SessionDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequestMsg) ProtoMessage()               {}
func (*SessionDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{21} }

func (m *SessionDeleteRequestMsg) GetRequest() []*SessionDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
type SessionDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SessionDeleteResponseMsg) Reset()                    { *m = SessionDeleteResponseMsg{} }
func (m *SessionDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteResponseMsg) ProtoMessage()               {}
func (*SessionDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{22} }

func (m *SessionDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// SessionGetRequest  is used to get information about a session
type SessionGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// session_handle is the handle of the session
	SessionHandle uint64 `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle,proto3" json:"key"`
}

func (m *SessionGetRequest) Reset()                    { *m = SessionGetRequest{} }
func (m *SessionGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequest) ProtoMessage()               {}
func (*SessionGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{23} }

func (m *SessionGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionGetRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionGetRequestMsg  is batched get request
type SessionGetRequestMsg struct {
	Request []*SessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionGetRequestMsg) Reset()                    { *m = SessionGetRequestMsg{} }
func (m *SessionGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequestMsg) ProtoMessage()               {}
func (*SessionGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{24} }

func (m *SessionGetRequestMsg) GetRequest() []*SessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStats contains all the stats collected per flow
// TODO - Srini please add all that we have in P4 for now
type FlowStats struct {
	FlowPackets   uint32 `protobuf:"fixed32,1,opt,name=flow_packets,json=flowPackets,proto3" json:"flow_packets,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes,proto3" json:"flow_bytes,omitempty"`
	RexmitPackets uint32 `protobuf:"fixed32,3,opt,name=rexmit_packets,json=rexmitPackets,proto3" json:"rexmit_packets,omitempty"`
}

func (m *FlowStats) Reset()                    { *m = FlowStats{} }
func (m *FlowStats) String() string            { return proto.CompactTextString(m) }
func (*FlowStats) ProtoMessage()               {}
func (*FlowStats) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{25} }

func (m *FlowStats) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *FlowStats) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *FlowStats) GetRexmitPackets() uint32 {
	if m != nil {
		return m.RexmitPackets
	}
	return 0
}

// SessionStats captures statistics of all its constituent flows
type SessionStats struct {
	FlowStats []*FlowStats `protobuf:"bytes,1,rep,name=flow_stats,json=flowStats" json:"flow_stats,omitempty"`
}

func (m *SessionStats) Reset()                    { *m = SessionStats{} }
func (m *SessionStats) String() string            { return proto.CompactTextString(m) }
func (*SessionStats) ProtoMessage()               {}
func (*SessionStats) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{26} }

func (m *SessionStats) GetFlowStats() []*FlowStats {
	if m != nil {
		return m.FlowStats
	}
	return nil
}

// SessionGetResponse is response to one SessionGetRequest
type SessionGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *SessionSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SessionStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SessionStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SessionGetResponse) Reset()                    { *m = SessionGetResponse{} }
func (m *SessionGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponse) ProtoMessage()               {}
func (*SessionGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{27} }

func (m *SessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionGetResponse) GetSpec() *SessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SessionGetResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SessionGetResponse) GetStats() *SessionStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
type SessionGetResponseMsg struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Response  []*SessionGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *SessionGetResponseMsg) Reset()                    { *m = SessionGetResponseMsg{} }
func (m *SessionGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponseMsg) ProtoMessage()               {}
func (*SessionGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorSession, []int{28} }

func (m *SessionGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionGetResponseMsg) GetResponse() []*SessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowKeyL2)(nil), "session.FlowKeyL2")
	proto.RegisterType((*FlowKeyTcpUdpInfo)(nil), "session.FlowKeyTcpUdpInfo")
	proto.RegisterType((*FlowKeyICMPInfo)(nil), "session.FlowKeyICMPInfo")
	proto.RegisterType((*FlowKeyESPInfo)(nil), "session.FlowKeyESPInfo")
	proto.RegisterType((*FlowKeyV4)(nil), "session.FlowKeyV4")
	proto.RegisterType((*FlowKeyV6)(nil), "session.FlowKeyV6")
	proto.RegisterType((*FlowKey)(nil), "session.FlowKey")
	proto.RegisterType((*FlowInfo)(nil), "session.FlowInfo")
	proto.RegisterType((*ConnTrackInfo)(nil), "session.ConnTrackInfo")
	proto.RegisterType((*FlowData)(nil), "session.FlowData")
	proto.RegisterType((*FlowSpec)(nil), "session.FlowSpec")
	proto.RegisterType((*SessionSpec)(nil), "session.SessionSpec")
	proto.RegisterType((*SessionRequestMsg)(nil), "session.SessionRequestMsg")
	proto.RegisterType((*FlowStatus)(nil), "session.FlowStatus")
	proto.RegisterType((*TFTPALGInfo)(nil), "session.TFTPALGInfo")
	proto.RegisterType((*RPCALGInfo)(nil), "session.RPCALGInfo")
	proto.RegisterType((*SIPALGInfo)(nil), "session.SIPALGInfo")
	proto.RegisterType((*SessionStatus)(nil), "session.SessionStatus")
	proto.RegisterType((*SessionResponse)(nil), "session.SessionResponse")
	proto.RegisterType((*SessionResponseMsg)(nil), "session.SessionResponseMsg")
	proto.RegisterType((*SessionDeleteRequest)(nil), "session.SessionDeleteRequest")
	proto.RegisterType((*SessionDeleteRequestMsg)(nil), "session.SessionDeleteRequestMsg")
	proto.RegisterType((*SessionDeleteResponseMsg)(nil), "session.SessionDeleteResponseMsg")
	proto.RegisterType((*SessionGetRequest)(nil), "session.SessionGetRequest")
	proto.RegisterType((*SessionGetRequestMsg)(nil), "session.SessionGetRequestMsg")
	proto.RegisterType((*FlowStats)(nil), "session.FlowStats")
	proto.RegisterType((*SessionStats)(nil), "session.SessionStats")
	proto.RegisterType((*SessionGetResponse)(nil), "session.SessionGetResponse")
	proto.RegisterType((*SessionGetResponseMsg)(nil), "session.SessionGetResponseMsg")
	proto.RegisterEnum("session.NatType", NatType_name, NatType_value)
	proto.RegisterEnum("session.FlowAction", FlowAction_name, FlowAction_value)
	proto.RegisterEnum("session.FlowTCPState", FlowTCPState_name, FlowTCPState_value)
	proto.RegisterEnum("session.FlowType", FlowType_name, FlowType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Session service

type SessionClient interface {
	SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error)
	SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error)
	SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error)
}

type sessionClient struct {
	cc *grpc.ClientConn
}

func NewSessionClient(cc *grpc.ClientConn) SessionClient {
	return &sessionClient{cc}
}

func (c *sessionClient) SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error) {
	out := new(SessionResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error) {
	out := new(SessionDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error) {
	out := new(SessionGetResponseMsg)
	err := grpc.Invoke(ctx, "/session.Session/SessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Session service

type SessionServer interface {
	SessionCreate(context.Context, *SessionRequestMsg) (*SessionResponseMsg, error)
	SessionDelete(context.Context, *SessionDeleteRequestMsg) (*SessionDeleteResponseMsg, error)
	SessionGet(context.Context, *SessionGetRequestMsg) (*SessionGetResponseMsg, error)
}

func RegisterSessionServer(s *grpc.Server, srv SessionServer) {
	s.RegisterService(&_Session_serviceDesc, srv)
}

func _Session_SessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionCreate(ctx, req.(*SessionRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionDelete(ctx, req.(*SessionDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/session.Session/SessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionGet(ctx, req.(*SessionGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Session_serviceDesc = grpc.ServiceDesc{
	ServiceName: "session.Session",
	HandlerType: (*SessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SessionCreate",
			Handler:    _Session_SessionCreate_Handler,
		},
		{
			MethodName: "SessionDelete",
			Handler:    _Session_SessionDelete_Handler,
		},
		{
			MethodName: "SessionGet",
			Handler:    _Session_SessionGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session.proto",
}

func (m *FlowKeyL2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyL2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Smac != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.Smac))
	}
	if m.Dmac != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.Dmac))
	}
	if m.L2SegmentId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.L2SegmentId))
	}
	if m.EtherType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.EtherType))
	}
	return i, nil
}

func (m *FlowKeyTcpUdpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyTcpUdpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sport != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Dport))
	}
	return i, nil
}

func (m *FlowKeyICMPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyICMPInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Code))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *FlowKeyESPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyESPInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Spi))
	}
	return i, nil
}

func (m *FlowKeyV4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyV4) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sip != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.Sip))
	}
	if m.Dip != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.Dip))
	}
	if m.IpProto != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.IpProto))
	}
	if m.L4Fields != nil {
		nn1, err := m.L4Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *FlowKeyV4_TcpUdp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpUdp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpUdp.Size()))
		n2, err := m.TcpUdp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *FlowKeyV4_Icmp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Icmp.Size()))
		n3, err := m.Icmp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *FlowKeyV4_Esp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Esp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Esp.Size()))
		n4, err := m.Esp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *FlowKeyV6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKeyV6) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sip != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Sip.Size()))
		n5, err := m.Sip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Dip != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Dip.Size()))
		n6, err := m.Dip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.IpProto != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.IpProto))
	}
	if m.L4Fields != nil {
		nn7, err := m.L4Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *FlowKeyV6_TcpUdp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpUdp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpUdp.Size()))
		n8, err := m.TcpUdp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *FlowKeyV6_Icmp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Icmp.Size()))
		n9, err := m.Icmp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *FlowKeyV6_Esp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Esp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Esp.Size()))
		n10, err := m.Esp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *FlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowKey != nil {
		nn11, err := m.FlowKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *FlowKey_L2Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.L2Key.Size()))
		n12, err := m.L2Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *FlowKey_V4Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V4Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.V4Key.Size()))
		n13, err := m.V4Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *FlowKey_V6Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V6Key != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.V6Key.Size()))
		n14, err := m.V6Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *FlowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.FlowAction))
	}
	if m.NatType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NatType))
	}
	if m.NatSip != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NatSip.Size()))
		n15, err := m.NatSip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.NatSport != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NatSport))
	}
	if m.NatDip != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NatDip.Size()))
		n16, err := m.NatDip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.NatDport != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NatDport))
	}
	if m.NatDmac != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.NatDmac))
	}
	if m.TcpState != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpState))
	}
	if m.InQosActions != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.InQosActions.Size()))
		n17, err := m.InQosActions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.EgQosActions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.EgQosActions.Size()))
		n18, err := m.EgQosActions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, msg := range m.IngMirrorSessions {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, msg := range m.EgrMirrorSessions {
			dAtA[i] = 0x62
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ConnTrackInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnTrackInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowCreateTs != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.FlowCreateTs))
	}
	if m.FlowBytes != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.FlowBytes))
	}
	if m.FlowPackets != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.FlowPackets))
	}
	if m.ExceptionBits != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.ExceptionBits))
	}
	if m.TcpSeqNum != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.TcpSeqNum))
	}
	if m.TcpAckNum != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.TcpAckNum))
	}
	if m.TcpWinSz != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpWinSz))
	}
	if m.TcpWinScale != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpWinScale))
	}
	if m.TcpMss != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TcpMss))
	}
	return i, nil
}

func (m *FlowData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.FlowInfo.Size()))
		n19, err := m.FlowInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ConnTrackInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ConnTrackInfo.Size()))
		n20, err := m.ConnTrackInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *FlowSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.FlowKey.Size()))
		n21, err := m.FlowKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.FlowData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.FlowData.Size()))
		n22, err := m.FlowData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *SessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Meta.Size()))
		n23, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.SessionId))
	}
	if m.ConnTrackEn {
		dAtA[i] = 0x18
		i++
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpTsOption {
		dAtA[i] = 0x20
		i++
		if m.TcpTsOption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpSackPermOption {
		dAtA[i] = 0x28
		i++
		if m.TcpSackPermOption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IflowSynAckDelta != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSession(dAtA, i, uint64((uint32(m.IflowSynAckDelta)<<1)^uint32((m.IflowSynAckDelta>>31))))
	}
	if m.InitiatorFlow != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.InitiatorFlow.Size()))
		n24, err := m.InitiatorFlow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ResponderFlow != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ResponderFlow.Size()))
		n25, err := m.ResponderFlow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SessionRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.FlowHandle))
	}
	if m.ConnTrackInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ConnTrackInfo.Size()))
		n26, err := m.ConnTrackInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.FlowColl {
		dAtA[i] = 0x18
		i++
		if m.FlowColl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FlowHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.FlowHash))
	}
	return i, nil
}

func (m *TFTPALGInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFTPALGInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParseError != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ParseError))
	}
	if m.UnknownOpcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.UnknownOpcode))
	}
	return i, nil
}

func (m *RPCALGInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPCALGInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParseError != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ParseError))
	}
	if m.NumDataSess != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.NumDataSess))
	}
	return i, nil
}

func (m *SIPALGInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIPALGInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParseError != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ParseError))
	}
	return i, nil
}

func (m *SessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.SessionHandle))
	}
	if m.IflowStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.IflowStatus.Size()))
		n27, err := m.IflowStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.RflowStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.RflowStatus.Size()))
		n28, err := m.RflowStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Alg != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Alg))
	}
	if m.AlgInfo != nil {
		nn29, err := m.AlgInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	return i, nil
}

func (m *SessionStatus_TftpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TftpInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.TftpInfo.Size()))
		n30, err := m.TftpInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *SessionStatus_RpcInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RpcInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.RpcInfo.Size()))
		n31, err := m.RpcInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *SessionStatus_SipInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SipInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.SipInfo.Size()))
		n32, err := m.SipInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *SessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Status.Size()))
		n33, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *SessionResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Meta.Size()))
		n34, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.SessionHandle != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.SessionHandle))
	}
	return i, nil
}

func (m *SessionDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA36 := make([]byte, len(m.ApiStatus)*10)
		var j35 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	return i, nil
}

func (m *SessionGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Meta.Size()))
		n37, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.SessionHandle != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.SessionHandle))
	}
	return i, nil
}

func (m *SessionGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowPackets != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.FlowPackets))
	}
	if m.FlowBytes != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Session(dAtA, i, uint64(m.FlowBytes))
	}
	if m.RexmitPackets != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Session(dAtA, i, uint32(m.RexmitPackets))
	}
	return i, nil
}

func (m *SessionStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowStats) > 0 {
		for _, msg := range m.FlowStats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Spec.Size()))
		n38, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Status.Size()))
		n39, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.Stats.Size()))
		n40, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *SessionGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Session(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Session(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSession(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlowKeyL2) Size() (n int) {
	var l int
	_ = l
	if m.Smac != 0 {
		n += 9
	}
	if m.Dmac != 0 {
		n += 9
	}
	if m.L2SegmentId != 0 {
		n += 1 + sovSession(uint64(m.L2SegmentId))
	}
	if m.EtherType != 0 {
		n += 1 + sovSession(uint64(m.EtherType))
	}
	return n
}

func (m *FlowKeyTcpUdpInfo) Size() (n int) {
	var l int
	_ = l
	if m.Sport != 0 {
		n += 1 + sovSession(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovSession(uint64(m.Dport))
	}
	return n
}

func (m *FlowKeyICMPInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSession(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovSession(uint64(m.Code))
	}
	if m.Id != 0 {
		n += 1 + sovSession(uint64(m.Id))
	}
	return n
}

func (m *FlowKeyESPInfo) Size() (n int) {
	var l int
	_ = l
	if m.Spi != 0 {
		n += 1 + sovSession(uint64(m.Spi))
	}
	return n
}

func (m *FlowKeyV4) Size() (n int) {
	var l int
	_ = l
	if m.Sip != 0 {
		n += 5
	}
	if m.Dip != 0 {
		n += 5
	}
	if m.IpProto != 0 {
		n += 1 + sovSession(uint64(m.IpProto))
	}
	if m.L4Fields != nil {
		n += m.L4Fields.Size()
	}
	return n
}

func (m *FlowKeyV4_TcpUdp) Size() (n int) {
	var l int
	_ = l
	if m.TcpUdp != nil {
		l = m.TcpUdp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKeyV4_Icmp) Size() (n int) {
	var l int
	_ = l
	if m.Icmp != nil {
		l = m.Icmp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKeyV4_Esp) Size() (n int) {
	var l int
	_ = l
	if m.Esp != nil {
		l = m.Esp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKeyV6) Size() (n int) {
	var l int
	_ = l
	if m.Sip != nil {
		l = m.Sip.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Dip != nil {
		l = m.Dip.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.IpProto != 0 {
		n += 1 + sovSession(uint64(m.IpProto))
	}
	if m.L4Fields != nil {
		n += m.L4Fields.Size()
	}
	return n
}

func (m *FlowKeyV6_TcpUdp) Size() (n int) {
	var l int
	_ = l
	if m.TcpUdp != nil {
		l = m.TcpUdp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKeyV6_Icmp) Size() (n int) {
	var l int
	_ = l
	if m.Icmp != nil {
		l = m.Icmp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKeyV6_Esp) Size() (n int) {
	var l int
	_ = l
	if m.Esp != nil {
		l = m.Esp.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKey) Size() (n int) {
	var l int
	_ = l
	if m.FlowKey != nil {
		n += m.FlowKey.Size()
	}
	return n
}

func (m *FlowKey_L2Key) Size() (n int) {
	var l int
	_ = l
	if m.L2Key != nil {
		l = m.L2Key.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKey_V4Key) Size() (n int) {
	var l int
	_ = l
	if m.V4Key != nil {
		l = m.V4Key.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowKey_V6Key) Size() (n int) {
	var l int
	_ = l
	if m.V6Key != nil {
		l = m.V6Key.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *FlowInfo) Size() (n int) {
	var l int
	_ = l
	if m.FlowAction != 0 {
		n += 1 + sovSession(uint64(m.FlowAction))
	}
	if m.NatType != 0 {
		n += 1 + sovSession(uint64(m.NatType))
	}
	if m.NatSip != nil {
		l = m.NatSip.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.NatSport != 0 {
		n += 1 + sovSession(uint64(m.NatSport))
	}
	if m.NatDip != nil {
		l = m.NatDip.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.NatDport != 0 {
		n += 1 + sovSession(uint64(m.NatDport))
	}
	if m.NatDmac != 0 {
		n += 9
	}
	if m.TcpState != 0 {
		n += 1 + sovSession(uint64(m.TcpState))
	}
	if m.InQosActions != nil {
		l = m.InQosActions.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.EgQosActions != nil {
		l = m.EgQosActions.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, e := range m.IngMirrorSessions {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, e := range m.EgrMirrorSessions {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *ConnTrackInfo) Size() (n int) {
	var l int
	_ = l
	if m.FlowCreateTs != 0 {
		n += 9
	}
	if m.FlowBytes != 0 {
		n += 9
	}
	if m.FlowPackets != 0 {
		n += 5
	}
	if m.ExceptionBits != 0 {
		n += 5
	}
	if m.TcpSeqNum != 0 {
		n += 5
	}
	if m.TcpAckNum != 0 {
		n += 5
	}
	if m.TcpWinSz != 0 {
		n += 1 + sovSession(uint64(m.TcpWinSz))
	}
	if m.TcpWinScale != 0 {
		n += 1 + sovSession(uint64(m.TcpWinScale))
	}
	if m.TcpMss != 0 {
		n += 1 + sovSession(uint64(m.TcpMss))
	}
	return n
}

func (m *FlowData) Size() (n int) {
	var l int
	_ = l
	if m.FlowInfo != nil {
		l = m.FlowInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.ConnTrackInfo != nil {
		l = m.ConnTrackInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}

func (m *FlowSpec) Size() (n int) {
	var l int
	_ = l
	if m.FlowKey != nil {
		l = m.FlowKey.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.FlowData != nil {
		l = m.FlowData.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}

func (m *SessionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.SessionId != 0 {
		n += 5
	}
	if m.ConnTrackEn {
		n += 2
	}
	if m.TcpTsOption {
		n += 2
	}
	if m.TcpSackPermOption {
		n += 2
	}
	if m.IflowSynAckDelta != 0 {
		n += 1 + sozSession(uint64(m.IflowSynAckDelta))
	}
	if m.InitiatorFlow != nil {
		l = m.InitiatorFlow.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.ResponderFlow != nil {
		l = m.ResponderFlow.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}

func (m *SessionRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *FlowStatus) Size() (n int) {
	var l int
	_ = l
	if m.FlowHandle != 0 {
		n += 9
	}
	if m.ConnTrackInfo != nil {
		l = m.ConnTrackInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.FlowColl {
		n += 2
	}
	if m.FlowHash != 0 {
		n += 1 + sovSession(uint64(m.FlowHash))
	}
	return n
}

func (m *TFTPALGInfo) Size() (n int) {
	var l int
	_ = l
	if m.ParseError != 0 {
		n += 1 + sovSession(uint64(m.ParseError))
	}
	if m.UnknownOpcode != 0 {
		n += 1 + sovSession(uint64(m.UnknownOpcode))
	}
	return n
}

func (m *RPCALGInfo) Size() (n int) {
	var l int
	_ = l
	if m.ParseError != 0 {
		n += 1 + sovSession(uint64(m.ParseError))
	}
	if m.NumDataSess != 0 {
		n += 1 + sovSession(uint64(m.NumDataSess))
	}
	return n
}

func (m *SIPALGInfo) Size() (n int) {
	var l int
	_ = l
	if m.ParseError != 0 {
		n += 1 + sovSession(uint64(m.ParseError))
	}
	return n
}

func (m *SessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.SessionHandle != 0 {
		n += 9
	}
	if m.IflowStatus != nil {
		l = m.IflowStatus.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.RflowStatus != nil {
		l = m.RflowStatus.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Alg != 0 {
		n += 1 + sovSession(uint64(m.Alg))
	}
	if m.AlgInfo != nil {
		n += m.AlgInfo.Size()
	}
	return n
}

func (m *SessionStatus_TftpInfo) Size() (n int) {
	var l int
	_ = l
	if m.TftpInfo != nil {
		l = m.TftpInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *SessionStatus_RpcInfo) Size() (n int) {
	var l int
	_ = l
	if m.RpcInfo != nil {
		l = m.RpcInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *SessionStatus_SipInfo) Size() (n int) {
	var l int
	_ = l
	if m.SipInfo != nil {
		l = m.SipInfo.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}
func (m *SessionResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}

func (m *SessionResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *SessionDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.SessionHandle != 0 {
		n += 9
	}
	return n
}

func (m *SessionDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *SessionDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovSession(uint64(e))
		}
		n += 1 + sovSession(uint64(l)) + l
	}
	return n
}

func (m *SessionGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.SessionHandle != 0 {
		n += 9
	}
	return n
}

func (m *SessionGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *FlowStats) Size() (n int) {
	var l int
	_ = l
	if m.FlowPackets != 0 {
		n += 5
	}
	if m.FlowBytes != 0 {
		n += 9
	}
	if m.RexmitPackets != 0 {
		n += 5
	}
	return n
}

func (m *SessionStats) Size() (n int) {
	var l int
	_ = l
	if len(m.FlowStats) > 0 {
		for _, e := range m.FlowStats {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func (m *SessionGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	return n
}

func (m *SessionGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	return n
}

func sovSession(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSession(x uint64) (n int) {
	return sovSession(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowKeyL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smac", wireType)
			}
			m.Smac = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Smac = uint64(dAtA[iNdEx-8])
			m.Smac |= uint64(dAtA[iNdEx-7]) << 8
			m.Smac |= uint64(dAtA[iNdEx-6]) << 16
			m.Smac |= uint64(dAtA[iNdEx-5]) << 24
			m.Smac |= uint64(dAtA[iNdEx-4]) << 32
			m.Smac |= uint64(dAtA[iNdEx-3]) << 40
			m.Smac |= uint64(dAtA[iNdEx-2]) << 48
			m.Smac |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dmac", wireType)
			}
			m.Dmac = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Dmac = uint64(dAtA[iNdEx-8])
			m.Dmac |= uint64(dAtA[iNdEx-7]) << 8
			m.Dmac |= uint64(dAtA[iNdEx-6]) << 16
			m.Dmac |= uint64(dAtA[iNdEx-5]) << 24
			m.Dmac |= uint64(dAtA[iNdEx-4]) << 32
			m.Dmac |= uint64(dAtA[iNdEx-3]) << 40
			m.Dmac |= uint64(dAtA[iNdEx-2]) << 48
			m.Dmac |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentId", wireType)
			}
			m.L2SegmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2SegmentId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			m.EtherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtherType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKeyTcpUdpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyTcpUdpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyTcpUdpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKeyICMPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyICMPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyICMPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKeyESPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyESPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyESPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKeyV4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyV4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyV4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sip", wireType)
			}
			m.Sip = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Sip = uint32(dAtA[iNdEx-4])
			m.Sip |= uint32(dAtA[iNdEx-3]) << 8
			m.Sip |= uint32(dAtA[iNdEx-2]) << 16
			m.Sip |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dip", wireType)
			}
			m.Dip = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Dip = uint32(dAtA[iNdEx-4])
			m.Dip |= uint32(dAtA[iNdEx-3]) << 8
			m.Dip |= uint32(dAtA[iNdEx-2]) << 16
			m.Dip |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProto", wireType)
			}
			m.IpProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProto |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUdp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyTcpUdpInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV4_TcpUdp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyICMPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV4_Icmp{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyESPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV4_Esp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKeyV6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKeyV6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKeyV6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sip == nil {
				m.Sip = &IPAddress{}
			}
			if err := m.Sip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dip == nil {
				m.Dip = &IPAddress{}
			}
			if err := m.Dip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProto", wireType)
			}
			m.IpProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProto |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUdp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyTcpUdpInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV6_TcpUdp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyICMPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV6_Icmp{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyESPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Fields = &FlowKeyV6_Esp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyL2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowKey = &FlowKey_L2Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyV4{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowKey = &FlowKey_V4Key{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowKeyV6{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowKey = &FlowKey_V6Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAction", wireType)
			}
			m.FlowAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowAction |= (FlowAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatType", wireType)
			}
			m.NatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatType |= (NatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatSip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatSip == nil {
				m.NatSip = &IPAddress{}
			}
			if err := m.NatSip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatSport", wireType)
			}
			m.NatSport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatSport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatDip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatDip == nil {
				m.NatDip = &IPAddress{}
			}
			if err := m.NatDip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatDport", wireType)
			}
			m.NatDport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatDport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatDmac", wireType)
			}
			m.NatDmac = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.NatDmac = uint64(dAtA[iNdEx-8])
			m.NatDmac |= uint64(dAtA[iNdEx-7]) << 8
			m.NatDmac |= uint64(dAtA[iNdEx-6]) << 16
			m.NatDmac |= uint64(dAtA[iNdEx-5]) << 24
			m.NatDmac |= uint64(dAtA[iNdEx-4]) << 32
			m.NatDmac |= uint64(dAtA[iNdEx-3]) << 40
			m.NatDmac |= uint64(dAtA[iNdEx-2]) << 48
			m.NatDmac |= uint64(dAtA[iNdEx-1]) << 56
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpState", wireType)
			}
			m.TcpState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpState |= (FlowTCPState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InQosActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InQosActions == nil {
				m.InQosActions = &QOSActions{}
			}
			if err := m.InQosActions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgQosActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgQosActions == nil {
				m.EgQosActions = &QOSActions{}
			}
			if err := m.EgQosActions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngMirrorSessions = append(m.IngMirrorSessions, &MirrorSessionId{})
			if err := m.IngMirrorSessions[len(m.IngMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgrMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgrMirrorSessions = append(m.EgrMirrorSessions, &MirrorSessionId{})
			if err := m.EgrMirrorSessions[len(m.EgrMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnTrackInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnTrackInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnTrackInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCreateTs", wireType)
			}
			m.FlowCreateTs = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.FlowCreateTs = uint64(dAtA[iNdEx-8])
			m.FlowCreateTs |= uint64(dAtA[iNdEx-7]) << 8
			m.FlowCreateTs |= uint64(dAtA[iNdEx-6]) << 16
			m.FlowCreateTs |= uint64(dAtA[iNdEx-5]) << 24
			m.FlowCreateTs |= uint64(dAtA[iNdEx-4]) << 32
			m.FlowCreateTs |= uint64(dAtA[iNdEx-3]) << 40
			m.FlowCreateTs |= uint64(dAtA[iNdEx-2]) << 48
			m.FlowCreateTs |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowBytes", wireType)
			}
			m.FlowBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.FlowBytes = uint64(dAtA[iNdEx-8])
			m.FlowBytes |= uint64(dAtA[iNdEx-7]) << 8
			m.FlowBytes |= uint64(dAtA[iNdEx-6]) << 16
			m.FlowBytes |= uint64(dAtA[iNdEx-5]) << 24
			m.FlowBytes |= uint64(dAtA[iNdEx-4]) << 32
			m.FlowBytes |= uint64(dAtA[iNdEx-3]) << 40
			m.FlowBytes |= uint64(dAtA[iNdEx-2]) << 48
			m.FlowBytes |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowPackets", wireType)
			}
			m.FlowPackets = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.FlowPackets = uint32(dAtA[iNdEx-4])
			m.FlowPackets |= uint32(dAtA[iNdEx-3]) << 8
			m.FlowPackets |= uint32(dAtA[iNdEx-2]) << 16
			m.FlowPackets |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptionBits", wireType)
			}
			m.ExceptionBits = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ExceptionBits = uint32(dAtA[iNdEx-4])
			m.ExceptionBits |= uint32(dAtA[iNdEx-3]) << 8
			m.ExceptionBits |= uint32(dAtA[iNdEx-2]) << 16
			m.ExceptionBits |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSeqNum", wireType)
			}
			m.TcpSeqNum = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TcpSeqNum = uint32(dAtA[iNdEx-4])
			m.TcpSeqNum |= uint32(dAtA[iNdEx-3]) << 8
			m.TcpSeqNum |= uint32(dAtA[iNdEx-2]) << 16
			m.TcpSeqNum |= uint32(dAtA[iNdEx-1]) << 24
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckNum", wireType)
			}
			m.TcpAckNum = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TcpAckNum = uint32(dAtA[iNdEx-4])
			m.TcpAckNum |= uint32(dAtA[iNdEx-3]) << 8
			m.TcpAckNum |= uint32(dAtA[iNdEx-2]) << 16
			m.TcpAckNum |= uint32(dAtA[iNdEx-1]) << 24
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpWinSz", wireType)
			}
			m.TcpWinSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpWinSz |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpWinScale", wireType)
			}
			m.TcpWinScale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpWinScale |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMss", wireType)
			}
			m.TcpMss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowInfo == nil {
				m.FlowInfo = &FlowInfo{}
			}
			if err := m.FlowInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnTrackInfo == nil {
				m.ConnTrackInfo = &ConnTrackInfo{}
			}
			if err := m.ConnTrackInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowKey == nil {
				m.FlowKey = &FlowKey{}
			}
			if err := m.FlowKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowData == nil {
				m.FlowData = &FlowData{}
			}
			if err := m.FlowData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.SessionId = uint32(dAtA[iNdEx-4])
			m.SessionId |= uint32(dAtA[iNdEx-3]) << 8
			m.SessionId |= uint32(dAtA[iNdEx-2]) << 16
			m.SessionId |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTsOption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpTsOption = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackPermOption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpSackPermOption = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IflowSynAckDelta", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IflowSynAckDelta = v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorFlow == nil {
				m.InitiatorFlow = &FlowSpec{}
			}
			if err := m.InitiatorFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponderFlow == nil {
				m.ResponderFlow = &FlowSpec{}
			}
			if err := m.ResponderFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SessionSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowHandle", wireType)
			}
			m.FlowHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.FlowHandle = uint64(dAtA[iNdEx-8])
			m.FlowHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.FlowHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.FlowHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.FlowHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.FlowHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.FlowHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.FlowHandle |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnTrackInfo == nil {
				m.ConnTrackInfo = &ConnTrackInfo{}
			}
			if err := m.ConnTrackInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowColl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowColl = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowHash", wireType)
			}
			m.FlowHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowHash |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TFTPALGInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFTPALGInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFTPALGInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseError", wireType)
			}
			m.ParseError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParseError |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownOpcode", wireType)
			}
			m.UnknownOpcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnknownOpcode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPCALGInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCALGInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCALGInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseError", wireType)
			}
			m.ParseError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParseError |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDataSess", wireType)
			}
			m.NumDataSess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDataSess |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIPALGInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIPALGInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIPALGInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseError", wireType)
			}
			m.ParseError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParseError |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			m.SessionHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SessionHandle = uint64(dAtA[iNdEx-8])
			m.SessionHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.SessionHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.SessionHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.SessionHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.SessionHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.SessionHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.SessionHandle |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IflowStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IflowStatus == nil {
				m.IflowStatus = &FlowStatus{}
			}
			if err := m.IflowStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RflowStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RflowStatus == nil {
				m.RflowStatus = &FlowStatus{}
			}
			if err := m.RflowStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TftpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TFTPALGInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgInfo = &SessionStatus_TftpInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RPCALGInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgInfo = &SessionStatus_RpcInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SipInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SIPALGInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgInfo = &SessionStatus_SipInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SessionStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SessionResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			m.SessionHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SessionHandle = uint64(dAtA[iNdEx-8])
			m.SessionHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.SessionHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.SessionHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.SessionHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.SessionHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.SessionHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.SessionHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SessionDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSession
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSession
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSession
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSession
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			m.SessionHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SessionHandle = uint64(dAtA[iNdEx-8])
			m.SessionHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.SessionHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.SessionHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.SessionHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.SessionHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.SessionHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.SessionHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SessionGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowPackets", wireType)
			}
			m.FlowPackets = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.FlowPackets = uint32(dAtA[iNdEx-4])
			m.FlowPackets |= uint32(dAtA[iNdEx-3]) << 8
			m.FlowPackets |= uint32(dAtA[iNdEx-2]) << 16
			m.FlowPackets |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowBytes", wireType)
			}
			m.FlowBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.FlowBytes = uint64(dAtA[iNdEx-8])
			m.FlowBytes |= uint64(dAtA[iNdEx-7]) << 8
			m.FlowBytes |= uint64(dAtA[iNdEx-6]) << 16
			m.FlowBytes |= uint64(dAtA[iNdEx-5]) << 24
			m.FlowBytes |= uint64(dAtA[iNdEx-4]) << 32
			m.FlowBytes |= uint64(dAtA[iNdEx-3]) << 40
			m.FlowBytes |= uint64(dAtA[iNdEx-2]) << 48
			m.FlowBytes |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RexmitPackets", wireType)
			}
			m.RexmitPackets = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.RexmitPackets = uint32(dAtA[iNdEx-4])
			m.RexmitPackets |= uint32(dAtA[iNdEx-3]) << 8
			m.RexmitPackets |= uint32(dAtA[iNdEx-2]) << 16
			m.RexmitPackets |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowStats = append(m.FlowStats, &FlowStats{})
			if err := m.FlowStats[len(m.FlowStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SessionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SessionStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SessionStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SessionGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSession(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSession
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSession
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSession
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSession(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSession = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSession   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("session.proto", fileDescriptorSession) }

var fileDescriptorSession = []byte{
	// 2104 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcd, 0x72, 0xdb, 0xc8,
	0x11, 0x16, 0x48, 0x89, 0x3f, 0x4d, 0x91, 0xa2, 0xc6, 0xb2, 0xcd, 0x95, 0x63, 0xd9, 0x46, 0xc5,
	0x29, 0xc7, 0xce, 0x6a, 0x13, 0xae, 0x56, 0x9b, 0x53, 0x52, 0x14, 0x49, 0x5b, 0xb4, 0x29, 0x92,
	0x1e, 0x60, 0xed, 0xf2, 0x5e, 0x50, 0x30, 0x38, 0xa2, 0xb0, 0x02, 0x01, 0x18, 0x03, 0xd9, 0x2b,
	0xdf, 0xf2, 0x16, 0x39, 0xe4, 0x94, 0x4b, 0x9e, 0x21, 0x95, 0x17, 0xc8, 0x21, 0x87, 0x54, 0x1e,
	0x20, 0x95, 0x72, 0x6e, 0xa9, 0xca, 0x3d, 0x87, 0xad, 0x54, 0x6a, 0x7a, 0x06, 0x20, 0x09, 0x51,
	0xb6, 0x2b, 0xa9, 0x5c, 0xf6, 0xc4, 0x99, 0xee, 0xaf, 0x7b, 0x66, 0xba, 0xbf, 0xee, 0x19, 0x10,
	0xaa, 0x9c, 0x71, 0xee, 0x06, 0xfe, 0x6e, 0x18, 0x05, 0x71, 0x40, 0x8a, 0x6a, 0xba, 0x5d, 0x89,
	0xcf, 0x43, 0xc6, 0xa5, 0x74, 0xbb, 0xfc, 0x2a, 0x48, 0x86, 0x1b, 0x31, 0xf3, 0xd8, 0x94, 0xc5,
	0xd1, 0xb9, 0x12, 0x54, 0xfc, 0x37, 0x9c, 0x39, 0x72, 0xa2, 0xbf, 0x86, 0xf2, 0x43, 0x2f, 0x78,
	0xf3, 0x84, 0x9d, 0xf7, 0x9b, 0x84, 0xc0, 0x2a, 0x9f, 0xda, 0x4e, 0x43, 0xbb, 0xad, 0xdd, 0x2b,
	0x50, 0x1c, 0x0b, 0xd9, 0x58, 0xc8, 0x72, 0x52, 0x26, 0xc6, 0x44, 0x87, 0xaa, 0xd7, 0xb4, 0x38,
	0x9b, 0x4c, 0x99, 0x1f, 0x5b, 0xee, 0xb8, 0x91, 0xbf, 0xad, 0xdd, 0xab, 0xd2, 0x8a, 0xd7, 0x34,
	0xa4, 0xac, 0x37, 0x26, 0x37, 0x01, 0x58, 0x7c, 0xc2, 0x22, 0x4b, 0x6c, 0xab, 0xb1, 0x8a, 0x80,
	0x32, 0x4a, 0xcc, 0xf3, 0x90, 0xe9, 0xbf, 0x84, 0x4d, 0xb5, 0xae, 0xe9, 0x84, 0x5f, 0x8d, 0xc3,
	0x9e, 0x7f, 0x1c, 0x90, 0x2d, 0x58, 0xe3, 0x61, 0x10, 0xc5, 0xb8, 0x81, 0x2a, 0x95, 0x13, 0x21,
	0x1d, 0xa3, 0x34, 0x27, 0xa5, 0x38, 0xd1, 0x7b, 0xb0, 0xa1, 0x1c, 0xf4, 0xda, 0x47, 0x23, 0x34,
	0x27, 0xb0, 0x8a, 0x8b, 0x49, 0x6b, 0x1c, 0x0b, 0x99, 0x13, 0x8c, 0x99, 0xb2, 0xc5, 0x31, 0xa9,
	0x41, 0x2e, 0xdd, 0x73, 0xce, 0x1d, 0xeb, 0x3a, 0xd4, 0x94, 0xab, 0xae, 0x21, 0x3d, 0xd5, 0x21,
	0xcf, 0x43, 0x57, 0x39, 0x12, 0x43, 0xfd, 0xdf, 0x5a, 0x1a, 0xa8, 0x67, 0x7b, 0xa8, 0x77, 0x43,
	0xd4, 0x17, 0xa9, 0x18, 0x0a, 0xc9, 0xd8, 0x0d, 0x71, 0x99, 0x22, 0x15, 0x43, 0xf2, 0x13, 0x28,
	0xb9, 0xa1, 0x85, 0x51, 0xc6, 0xb5, 0x6a, 0xcd, 0xcd, 0x5d, 0x99, 0xa2, 0xde, 0x68, 0x24, 0xa4,
	0x4e, 0xe0, 0xd1, 0xa2, 0x1b, 0xe2, 0x98, 0x7c, 0x01, 0xc5, 0xd8, 0x09, 0xad, 0xb3, 0x71, 0x88,
	0xb1, 0xaa, 0x34, 0xb7, 0x77, 0x93, 0x3c, 0x5f, 0x88, 0xd3, 0xe1, 0x0a, 0x2d, 0xc4, 0x38, 0x23,
	0xbb, 0xb0, 0xea, 0x3a, 0xd3, 0xb0, 0xb1, 0x86, 0x36, 0x8d, 0xac, 0x4d, 0x12, 0x9a, 0xc3, 0x15,
	0x8a, 0x38, 0xf2, 0x00, 0xf2, 0x8c, 0x87, 0x8d, 0x02, 0xc2, 0xaf, 0x67, 0xe1, 0xea, 0xf8, 0x87,
	0x2b, 0x54, 0xa0, 0x0e, 0x2a, 0x50, 0xf6, 0xf6, 0xac, 0x63, 0x97, 0x79, 0x63, 0xae, 0xff, 0x36,
	0x37, 0x0b, 0xc0, 0x3e, 0xd1, 0x67, 0x01, 0xa8, 0x34, 0xeb, 0xe9, 0xb9, 0x5a, 0xe3, 0x71, 0xc4,
	0x38, 0x97, 0x21, 0xd1, 0x67, 0x21, 0x59, 0x8a, 0xf9, 0x1e, 0x06, 0xe9, 0x37, 0x1a, 0x14, 0x15,
	0x8c, 0x3c, 0x80, 0x82, 0xd7, 0xb4, 0x4e, 0xd9, 0xb9, 0x8a, 0x12, 0xc9, 0x3a, 0xea, 0x37, 0x0f,
	0x57, 0xe8, 0x9a, 0xd7, 0x54, 0xe0, 0xd7, 0x7b, 0x08, 0xce, 0x2d, 0x07, 0x3f, 0xdb, 0x13, 0xe0,
	0xd7, 0x7b, 0x09, 0x78, 0x1f, 0xc1, 0xf9, 0x4b, 0xc0, 0xfb, 0x08, 0xde, 0x7f, 0xc2, 0xce, 0x0f,
	0x00, 0x4a, 0xc7, 0x5e, 0xf0, 0x46, 0xc0, 0xf5, 0xbf, 0xac, 0x42, 0x49, 0x40, 0x90, 0xe3, 0x7b,
	0x50, 0x41, 0x85, 0xed, 0xc4, 0x6e, 0xe0, 0xe3, 0x26, 0x6b, 0xcd, 0x2b, 0x0b, 0xae, 0x5a, 0xa8,
	0xa2, 0x70, 0x9c, 0x8e, 0xc9, 0x03, 0x28, 0xf9, 0x76, 0x2c, 0x8b, 0x3a, 0x87, 0x26, 0xf5, 0xd4,
	0x64, 0x60, 0xc7, 0xa2, 0xb6, 0x69, 0xd1, 0x97, 0x03, 0xf2, 0x63, 0x10, 0x43, 0x4b, 0x30, 0x25,
	0x7f, 0x09, 0x0b, 0x0a, 0xbe, 0x1d, 0x1b, 0x6e, 0x48, 0x6e, 0x40, 0x19, 0xa1, 0x58, 0xe8, 0xb2,
	0x5b, 0x88, 0x85, 0x0c, 0xec, 0x00, 0xca, 0x8f, 0x60, 0xd3, 0xda, 0x7b, 0xfc, 0x74, 0x66, 0x7e,
	0x64, 0xc3, 0x28, 0xa4, 0x7e, 0x3a, 0xe8, 0xe7, 0x13, 0xb9, 0x79, 0xec, 0x67, 0x45, 0xec, 0x67,
	0xc2, 0x6f, 0x47, 0xb4, 0xb4, 0x26, 0x94, 0x05, 0xb5, 0x78, 0x6c, 0xc7, 0xac, 0x51, 0xc2, 0x83,
	0x5d, 0x5d, 0x88, 0x85, 0xd9, 0x1e, 0x19, 0x42, 0x49, 0x4b, 0xb1, 0x13, 0xe2, 0x88, 0x7c, 0x01,
	0x35, 0xd7, 0xb7, 0x5e, 0x05, 0x5c, 0xc5, 0x90, 0x37, 0xca, 0xb8, 0xbb, 0x8d, 0x5d, 0xd1, 0x7d,
	0x9f, 0x0e, 0x0d, 0x19, 0x33, 0x4e, 0xd7, 0x5d, 0xff, 0x69, 0xc0, 0xd5, 0x4c, 0x98, 0xb1, 0xc9,
	0x82, 0x19, 0x5c, 0x62, 0xc6, 0x26, 0x73, 0x66, 0x8f, 0xe1, 0x8a, 0xeb, 0x4f, 0xac, 0xa9, 0x1b,
	0x45, 0x41, 0x64, 0xa9, 0xad, 0xf1, 0x46, 0xe5, 0x76, 0x1e, 0x0b, 0x61, 0xd6, 0xe5, 0x8f, 0x10,
	0x61, 0x48, 0x40, 0x6f, 0x4c, 0x37, 0x5d, 0x7f, 0xb2, 0x20, 0x43, 0x5f, 0x6c, 0x12, 0x5d, 0xf0,
	0xb5, 0xfe, 0x61, 0x5f, 0x6c, 0x12, 0x2d, 0xfa, 0xd2, 0x7f, 0x9f, 0x83, 0x6a, 0x3b, 0xf0, 0x7d,
	0x33, 0xb2, 0x9d, 0x53, 0x64, 0xd6, 0x0f, 0xa1, 0x86, 0xcc, 0x72, 0x22, 0x66, 0xc7, 0xcc, 0x8a,
	0xb9, 0xba, 0x50, 0xd6, 0x85, 0xb4, 0x8d, 0x42, 0x93, 0x8b, 0x0b, 0x02, 0x51, 0x2f, 0xcf, 0x63,
	0xc6, 0xd5, 0xf5, 0x52, 0x16, 0x92, 0x03, 0x21, 0x20, 0x77, 0x00, 0xe1, 0x56, 0x68, 0x3b, 0xa7,
	0x2c, 0xe6, 0x48, 0xa0, 0x22, 0x45, 0xca, 0x8e, 0xa4, 0x88, 0xdc, 0x85, 0x1a, 0xfb, 0xd6, 0x61,
	0xa1, 0x88, 0x8f, 0xf5, 0xd2, 0x8d, 0x39, 0x12, 0xa7, 0x48, 0xab, 0xa9, 0xf4, 0xc0, 0x8d, 0x39,
	0xd9, 0x81, 0x0a, 0xa6, 0x96, 0xbd, 0xb2, 0xfc, 0xb3, 0x29, 0x32, 0xa8, 0x48, 0x45, 0xb6, 0x0d,
	0xf6, 0x6a, 0x70, 0x36, 0x4d, 0xf4, 0xb6, 0x73, 0x8a, 0xfa, 0x42, 0xaa, 0x6f, 0x39, 0xa7, 0x42,
	0xff, 0x03, 0x00, 0xa1, 0x7f, 0xe3, 0xfa, 0x16, 0x7f, 0x8b, 0xbc, 0xa9, 0x22, 0x09, 0x9e, 0xbb,
	0xbe, 0xf1, 0x56, 0xdc, 0x85, 0xa9, 0xd6, 0xb1, 0x3d, 0x49, 0x9e, 0x2a, 0xad, 0x28, 0x80, 0x10,
	0x91, 0xeb, 0xb2, 0x6f, 0x4d, 0xb9, 0x64, 0x48, 0x15, 0x3b, 0xd3, 0x11, 0xe7, 0xfa, 0x5b, 0x59,
	0x8f, 0x1d, 0x3b, 0xb6, 0xc9, 0x2e, 0xe0, 0xe9, 0x2d, 0xd7, 0x3f, 0x0e, 0x54, 0xcb, 0xd8, 0x5c,
	0x60, 0xa0, 0x88, 0x2d, 0xc5, 0x62, 0xc6, 0x28, 0xff, 0x02, 0x36, 0x9c, 0xc0, 0xf7, 0xad, 0x58,
	0xc4, 0x5d, 0x5a, 0xc9, 0xde, 0x71, 0x2d, 0xb5, 0x5a, 0x48, 0x0b, 0xad, 0x3a, 0xf3, 0x53, 0x7d,
	0x22, 0xd7, 0x36, 0x42, 0xe6, 0x88, 0xaa, 0x4e, 0x9a, 0x44, 0xda, 0xd3, 0x33, 0x3d, 0x85, 0x16,
	0x8f, 0x55, 0x63, 0x4b, 0x36, 0x3a, 0xb6, 0x63, 0x5b, 0x2d, 0xb9, 0xb8, 0x51, 0x71, 0x1c, 0xb9,
	0x51, 0x31, 0xd2, 0xff, 0x95, 0x83, 0x8a, 0x62, 0x0b, 0x2e, 0x76, 0x17, 0x56, 0xa7, 0x2c, 0xb6,
	0xd3, 0x33, 0xca, 0x52, 0x1e, 0xbe, 0xfc, 0x86, 0x39, 0xf1, 0x11, 0x8b, 0x6d, 0x8a, 0x6a, 0xf2,
	0x23, 0x00, 0xe5, 0x54, 0xbc, 0x30, 0xf0, 0x62, 0x3d, 0x28, 0xfe, 0xe3, 0xaf, 0xb7, 0xf2, 0xa7,
	0xec, 0x9c, 0x96, 0x79, 0x42, 0x49, 0x91, 0x80, 0xb9, 0x38, 0x30, 0x1f, 0x99, 0x52, 0xa2, 0x95,
	0xf4, 0xb4, 0x5d, 0x3f, 0x49, 0x52, 0xcc, 0xad, 0x00, 0x79, 0x81, 0x44, 0x29, 0x61, 0x92, 0x4c,
	0x3e, 0x44, 0x11, 0xf9, 0x0c, 0xb6, 0x90, 0x26, 0xc2, 0x4b, 0xc8, 0xa2, 0x69, 0x02, 0x5d, 0x43,
	0xe8, 0xa6, 0xe0, 0x8b, 0xed, 0x9c, 0x8e, 0x58, 0x34, 0x55, 0x06, 0x9f, 0xc2, 0x15, 0x17, 0x03,
	0xc1, 0xcf, 0x7d, 0x64, 0xcf, 0x98, 0x79, 0xb1, 0x8d, 0xfc, 0xd9, 0xa4, 0x75, 0x54, 0x19, 0xe7,
	0x7e, 0xcb, 0x39, 0xed, 0x08, 0x39, 0xf9, 0xb9, 0xe8, 0x16, 0x6e, 0xec, 0xda, 0x71, 0x10, 0x59,
	0x42, 0x89, 0x54, 0xca, 0xc6, 0x4e, 0x44, 0x88, 0x56, 0x53, 0xa0, 0x10, 0x09, 0xcb, 0x88, 0xf1,
	0x30, 0xf0, 0xc7, 0x4c, 0x59, 0x96, 0x2e, 0xb5, 0x4c, 0x81, 0x42, 0xa4, 0xb7, 0x61, 0x53, 0x45,
	0x9e, 0xb2, 0x57, 0x67, 0x8c, 0xc7, 0x47, 0x7c, 0x42, 0x76, 0xa1, 0x18, 0xc9, 0x59, 0x43, 0xc3,
	0x82, 0xdf, 0x4a, 0xfd, 0xcc, 0xa5, 0x89, 0x26, 0x20, 0xfd, 0x77, 0x1a, 0x00, 0x2e, 0x10, 0xdb,
	0xf1, 0x19, 0x27, 0xb7, 0xd4, 0xbd, 0x71, 0x62, 0xfb, 0x63, 0x8f, 0xa9, 0xd2, 0xc6, 0x52, 0x3e,
	0x44, 0xc9, 0xff, 0x4a, 0x4c, 0xd1, 0xc2, 0x65, 0xfb, 0x08, 0x3c, 0x4f, 0x25, 0x13, 0xc9, 0xd4,
	0x0e, 0x3c, 0x2f, 0x55, 0x9e, 0xd8, 0xfc, 0x24, 0xb9, 0x27, 0xe4, 0xda, 0xfc, 0x44, 0xff, 0x0a,
	0x2a, 0xe6, 0x43, 0x73, 0xd4, 0xea, 0x3f, 0x42, 0x47, 0xb7, 0xa0, 0x12, 0xda, 0x11, 0x67, 0x16,
	0x13, 0x0d, 0x4b, 0xbd, 0xe6, 0x00, 0x45, 0x5d, 0x21, 0x11, 0x0d, 0xe4, 0xcc, 0x3f, 0xf5, 0x83,
	0x37, 0xbe, 0x15, 0x84, 0x73, 0xcf, 0xc4, 0xaa, 0x92, 0x0e, 0x51, 0xa8, 0x3f, 0x05, 0xa0, 0xa3,
	0xf6, 0x47, 0x7b, 0xd5, 0xa1, 0xea, 0x9f, 0x4d, 0xb1, 0x3c, 0xb0, 0xb5, 0x2a, 0xa7, 0x15, 0xff,
	0x6c, 0x2a, 0xea, 0x41, 0xc4, 0x58, 0xff, 0x14, 0xc0, 0xe8, 0x7d, 0xf4, 0x46, 0xf5, 0x7f, 0xe6,
	0xa0, 0x9a, 0xe4, 0x46, 0x66, 0xe1, 0x2e, 0xd4, 0x92, 0xea, 0x58, 0x48, 0x44, 0xf2, 0x75, 0xa0,
	0x72, 0xb1, 0x0f, 0xeb, 0x8a, 0xa3, 0x68, 0xa6, 0x12, 0xb1, 0x78, 0xcb, 0x4b, 0x8f, 0xb4, 0x22,
	0x19, 0x2b, 0xdd, 0xef, 0xc3, 0x7a, 0x34, 0x6f, 0x97, 0x7f, 0x8f, 0x5d, 0x34, 0x67, 0x77, 0x1b,
	0xf2, 0xb6, 0x37, 0xc1, 0xc4, 0xd4, 0x9a, 0xb5, 0x5d, 0xf9, 0xa5, 0xd1, 0xea, 0x3f, 0x1a, 0xd8,
	0x53, 0x46, 0x85, 0x8a, 0x7c, 0x0e, 0xe5, 0xf8, 0x38, 0x0e, 0x25, 0x2f, 0xe4, 0x6d, 0x3e, 0xe3,
	0xdf, 0x5c, 0xf6, 0x0e, 0x57, 0x68, 0x49, 0x00, 0x31, 0x40, 0x3f, 0x85, 0x52, 0x14, 0x3a, 0xd2,
	0xa6, 0x90, 0xd9, 0xca, 0x2c, 0x35, 0x87, 0x2b, 0xb4, 0x18, 0x85, 0x4e, 0x62, 0xc1, 0x5d, 0xb5,
	0x4a, 0x31, 0x63, 0x31, 0x8b, 0xbc, 0xb0, 0xe0, 0x2e, 0xae, 0x21, 0x1e, 0x4a, 0xb6, 0x37, 0x41,
	0x0b, 0x3d, 0x82, 0x8d, 0xb4, 0x6e, 0x44, 0x3d, 0x71, 0x46, 0x3e, 0x03, 0xb0, 0x43, 0x37, 0x89,
	0x87, 0xa6, 0x9e, 0x3e, 0xb2, 0x77, 0xb5, 0x42, 0x57, 0x05, 0xa3, 0x6c, 0x27, 0x43, 0xb2, 0x0b,
	0x85, 0x85, 0xa0, 0x5f, 0xbb, 0x50, 0x65, 0xd2, 0x44, 0xa1, 0xf4, 0xc7, 0x40, 0x32, 0x6b, 0x8a,
	0x62, 0xdd, 0x83, 0x52, 0xa4, 0xa6, 0xaa, 0x5a, 0x1b, 0x59, 0x3f, 0x09, 0x9c, 0xa6, 0x48, 0x7d,
	0x0a, 0x5b, 0x4a, 0xd9, 0x61, 0x1e, 0x8b, 0x99, 0xaa, 0xfe, 0x8f, 0x6d, 0xbd, 0xbb, 0x17, 0xc8,
	0x85, 0xd7, 0xf3, 0xac, 0xfd, 0x2e, 0xb2, 0x4c, 0xa7, 0x70, 0x7d, 0xd9, 0x72, 0x62, 0xff, 0x5f,
	0x66, 0x9b, 0xcd, 0xcd, 0xec, 0xf6, 0x17, 0x4c, 0x66, 0x5d, 0xe7, 0x09, 0x34, 0x32, 0x80, 0x59,
	0x50, 0xb2, 0xb9, 0xc8, 0x7f, 0x20, 0x17, 0xfa, 0x37, 0x69, 0x1f, 0x7c, 0xc4, 0xe2, 0xff, 0x73,
	0x30, 0xfa, 0x69, 0xec, 0x67, 0x6b, 0xc9, 0x4c, 0x66, 0x22, 0xb1, 0x9d, 0x8d, 0xc4, 0x0c, 0x3f,
	0x0b, 0x43, 0x2c, 0xbf, 0xba, 0xc4, 0x39, 0x2e, 0xbe, 0x89, 0xb4, 0x8b, 0x6f, 0xa2, 0x0f, 0xbc,
	0xaa, 0xee, 0x8a, 0xab, 0xe4, 0xdb, 0xa9, 0x1b, 0x67, 0xde, 0x55, 0x55, 0x29, 0x55, 0x5e, 0xf4,
	0x16, 0xac, 0xcf, 0x91, 0x94, 0x93, 0x9f, 0x29, 0xaf, 0x22, 0xe2, 0x5c, 0x6d, 0x9f, 0x5c, 0x68,
	0x06, 0x5c, 0xae, 0x84, 0x43, 0xfd, 0x4f, 0x5a, 0xca, 0x67, 0x3c, 0xd7, 0x7f, 0x5b, 0x46, 0xf7,
	0x60, 0x95, 0x87, 0xcc, 0x51, 0x45, 0xb4, 0xfc, 0xaa, 0x42, 0xc4, 0x5c, 0xc1, 0xe5, 0x3f, 0xa6,
	0xe0, 0xc8, 0x03, 0x58, 0x93, 0xe7, 0x91, 0xdf, 0x92, 0x57, 0x97, 0xc1, 0x39, 0x95, 0x18, 0xfd,
	0x57, 0x1a, 0x5c, 0xbd, 0x78, 0x9c, 0x65, 0x64, 0xfc, 0xe0, 0x89, 0xbe, 0x9c, 0x2b, 0xe9, 0x1c,
	0x86, 0xf2, 0xc6, 0x52, 0x26, 0x64, 0xab, 0xfa, 0xfe, 0xd7, 0x50, 0x54, 0x9f, 0x58, 0x64, 0x13,
	0xaa, 0x83, 0x96, 0x69, 0x99, 0x2f, 0x46, 0x5d, 0x6b, 0x30, 0x1c, 0x74, 0xeb, 0x2b, 0x0b, 0x22,
	0x63, 0xd0, 0x32, 0xeb, 0xda, 0x82, 0xa8, 0x23, 0x44, 0x39, 0x72, 0x0d, 0x48, 0x2a, 0x32, 0x9f,
	0xf7, 0xda, 0x5d, 0x4b, 0xc8, 0xf3, 0xf7, 0x87, 0xf2, 0x8e, 0x57, 0x5f, 0x79, 0x5b, 0x50, 0x7f,
	0xd8, 0x1f, 0x3e, 0xb7, 0x5a, 0x6d, 0xb3, 0x37, 0x1c, 0x24, 0x2b, 0x5c, 0x85, 0xcd, 0x79, 0x69,
	0xab, 0xdf, 0x1f, 0x3e, 0xaf, 0x6b, 0x59, 0x70, 0x87, 0x0e, 0x47, 0xf5, 0xdc, 0xfd, 0xef, 0x34,
	0x58, 0x9f, 0xff, 0x6e, 0x22, 0xd7, 0xe1, 0x0a, 0xc2, 0xcc, 0xf6, 0xc8, 0x32, 0xcc, 0x96, 0xd9,
	0xb5, 0x7a, 0x83, 0x9e, 0x59, 0x5f, 0x21, 0x37, 0xe0, 0x7a, 0x46, 0x61, 0xbc, 0x18, 0x58, 0xb4,
	0xfd, 0xac, 0x53, 0xd7, 0x96, 0x28, 0x5b, 0xed, 0x27, 0x52, 0x99, 0x23, 0xb7, 0xe0, 0xc6, 0x12,
	0xcb, 0x14, 0x90, 0x27, 0x3b, 0xb0, 0x9d, 0x01, 0x74, 0x0d, 0xb3, 0x75, 0xd0, 0xef, 0x19, 0x87,
	0xdd, 0x4e, 0x7d, 0x75, 0x89, 0xf7, 0x87, 0x3d, 0xb5, 0xf4, 0x1a, 0xb9, 0x03, 0x37, 0x33, 0xca,
	0x83, 0x5e, 0xa7, 0x47, 0x67, 0x90, 0x02, 0x69, 0xc0, 0x56, 0x06, 0x42, 0xbb, 0x46, 0xd7, 0xac,
	0x17, 0xef, 0xff, 0x41, 0x93, 0xcf, 0x6b, 0x53, 0xfe, 0x09, 0x55, 0x93, 0xb0, 0xb9, 0x74, 0x7d,
	0x02, 0x57, 0x67, 0xb2, 0x76, 0xbf, 0x65, 0x18, 0xbd, 0xb6, 0x35, 0xe8, 0xb5, 0xeb, 0xda, 0x22,
	0x9c, 0x76, 0x8e, 0x5a, 0xf5, 0x5c, 0x1a, 0x64, 0x99, 0xb8, 0xf6, 0xc8, 0xec, 0x1b, 0xf5, 0x3c,
	0xb9, 0x02, 0x1b, 0x33, 0x69, 0x6f, 0x64, 0x74, 0xdb, 0xf5, 0x55, 0x91, 0xf5, 0xb9, 0xd5, 0x3a,
	0xdd, 0xfa, 0x5a, 0x9a, 0x39, 0x49, 0x0e, 0x73, 0x48, 0x5b, 0x8f, 0xba, 0xf5, 0xc2, 0x2c, 0x25,
	0xe8, 0xb4, 0xdb, 0xef, 0x1e, 0x75, 0x4d, 0xfa, 0xa2, 0x5e, 0x6c, 0x7e, 0xa7, 0x41, 0x51, 0x51,
	0x91, 0x3c, 0x4e, 0x9f, 0x1e, 0xf2, 0xd3, 0x8d, 0x6c, 0x5f, 0xbc, 0x80, 0x92, 0x26, 0xb7, 0x7d,
	0xe3, 0xb2, 0xcb, 0xe9, 0x88, 0x4f, 0xf4, 0x15, 0xf2, 0x2c, 0xf5, 0x25, 0x9b, 0x3a, 0xb9, 0xfd,
	0xde, 0xdb, 0x40, 0x78, 0xbc, 0x73, 0x19, 0x62, 0xde, 0xef, 0x11, 0xc0, 0xac, 0x72, 0xc8, 0xcd,
	0xcb, 0x1b, 0xab, 0xf0, 0xb8, 0xf3, 0x9e, 0x6a, 0x43, 0x77, 0x07, 0xdb, 0x7f, 0x7c, 0xb7, 0xa3,
	0xfd, 0xf9, 0xdd, 0x8e, 0xf6, 0xb7, 0x77, 0x3b, 0xda, 0xaf, 0xff, 0xbe, 0xb3, 0xf2, 0x75, 0xe9,
	0xc4, 0xf6, 0xf0, 0x5f, 0xaa, 0x97, 0x05, 0xfc, 0xf9, 0xfc, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xf4, 0x87, 0x11, 0x11, 0x87, 0x15, 0x00, 0x00,
}
