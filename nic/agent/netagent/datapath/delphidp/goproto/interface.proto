//------------------------------------------------------------------------------
// protobuf specification for Interface HAL APIs
//------------------------------------------------------------------------------

syntax = "proto3";

import public "gogo.proto";
import "delphi.proto";

package intf;
option go_package="goproto";



// IP protocol numbers
enum IPProtocol {
  IPPROTO_NONE          = 0;
  IPPROTO_ICMP          = 1;
  IPPROTO_IPV4          = 4;
  IPPROTO_TCP           = 6;
  IPPROTO_UDP           = 17;
  IPPROTO_GRE           = 47;
  IPPROTO_ESP           = 50;
  IPPROTO_AH            = 51;
  IPPROTO_ICMPV6        = 58;
}

// ICMP message types
// TBD - add more here !!
enum ICMPMsgType {
  ICMP_MSG_TYPE_NONE = 0;
  ICMP_MSG_TYPE_ECHO = 1;
}

// API return codes (more descriptive than protobuf enums)
enum ApiStatus {
  API_STATUS_OK                           = 0;     // success
  API_STATUS_ERR                          = 1;     // catch-all error
  API_STATUS_INVALID_ARG                  = 2;     // invalid argument
  API_STATUS_EXISTS_ALREADY               = 3;     // object already exists
  API_STATUS_OUT_OF_MEM                   = 4;     // out of memory
  API_STATUS_NOT_FOUND                    = 5;     // object not found
  API_STATUS_OUT_OF_RESOURCE              = 6;     // out of resource
  API_STATUS_ENCAP_INVALID                = 7;     // encap invalid
  API_STATUS_VRF_ID_INVALID               = 8;     // invalid tenant id
  API_STATUS_L2_SEGMENT_ID_INVALID        = 9;    // invalid L2 segment id
  API_STATUS_INTERFACE_ID_INVALID         = 10;    // invalid interface id
  API_STATUS_IF_TYPE_INVALID              = 11;    // invalid inteface type
  API_STATUS_IF_INFO_INVALID              = 12;    // invalid interface info
  API_STATUS_IF_L2SEGMENT_INVALID         = 13;    // invalid L2 segment in interface spec
  API_STATUS_IF_ENIC_INFO_INVALID         = 14;    // invalid enic info in interface spec
  API_STATUS_IF_ENIC_TYPE_INVALID         = 15;    // invalid enic type in interface spec
  API_STATUS_IF_LIF_INFO_NOT_INVALID      = 16;    // lif info not valid
  API_STATUS_IF_LIFQ_INFO_NOT_INVALID     = 17;    // lif queue info not valid
  API_STATUS_FLOW_KEY_INVALID             = 18;    // flow key invalid
  API_STATUS_FLOW_INFO_INVALID            = 19;    // flow information invalid
  API_STATUS_HANDLE_INVALID               = 20;    // HAL handle passed is invalid
  API_STATUS_HW_PROG_ERR                  = 21;    // hardware programming error
  API_STATUS_LIF_ID_INVALID               = 22;    // invalid LIF id
  API_STATUS_NWSEC_PROFILE_ID_INVALID     = 23;    // security profile id invalid
  API_STATUS_TLS_CB_ID_INVALID            = 24;    // invalid TLS CB id
  API_STATUS_TCP_CB_ID_INVALID            = 25;    // invalid TCP CB id
  API_STATUS_ACL_ID_INVALID               = 26;    // invalid ACL id
  API_STATUS_WRING_ID_INVALID             = 27;    // invalid WRING id
  API_STATUS_WRING_TYPE_INVALID           = 28;    // invalid WRING type
  API_STATUS_PROXY_TYPE_INVALID           = 29;    // invalid Proxy Service type
  API_STATUS_IPSEC_CB_ID_INVALID          = 30;    // invalid IPSEC CB id
  API_STATUS_L4LB_KEY_INVALID             = 31;    // invalid L4LB key
  API_STATUS_CPU_CB_ID_INVALID            = 32;    // invalid CPU CB id
  API_STATUS_PROXY_NOT_ENABLED            = 33;    // proxy service not enabled
  API_STATUS_CFG_DB_ERR                   = 34;    // config database inconsistency
  API_STATUS_SECURITY_GROUP_ID_INVALID    = 35;    // Security group id invalid
  API_STATUS_SECURITY_POLICY_ID_INVALID   = 36;    // Security Group id invalid
  API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID = 37;    // ep update with no key and hdl
  API_STATUS_DOS_POLICY_ID_INVALID        = 38;    // dos policy id invalid
  API_STATUS_RAWR_CB_ID_INVALID           = 39;    // invalid Raw Redirect CB id
  API_STATUS_OBJECT_IN_USE                = 40;    // object is in use
  API_STATUS_RAWC_CB_ID_INVALID           = 41;    // invalid Raw Chain CB id
  API_STATUS_PORT_ID_INVALID              = 42;    // invalid port number
  API_STATUS_PORT_TYPE_INVALID            = 43;    // invalid port type
  API_STATUS_PORT_SPEED_INVALID           = 44;    // invalid port speed
  API_STATUS_PORT_NUM_LANES_INVALID       = 45;    // invalid num lanes for port
  API_STATUS_MC_ENTRY_ID_INVALID          = 46;    // invalid mc_entry id
  API_STATUS_PROXYR_CB_ID_INVALID         = 47;    // invalid Proxy Redirect CB id
  API_STATUS_PROXYC_CB_ID_INVALID         = 48;    // invalid Proxy Chain CB id
  API_STATUS_HW_READ_ERROR                = 49;    // hardware read error
  API_STATUS_HW_WRITE_ERROR               = 50;    // hardware write error
  API_STATUS_L2_SEGMENT_TYPE_INVALID      = 51;    // L2 Segment set to invalide type
  API_STATUS_NAT_POOL_KEY_INVALID         = 52;    // invalid NAT pool key
  API_STATUS_NAT_MAPPING_KEY_INVALID      = 53;    // invalid NAT mapping key
}

// common meta object that is part of all other top level objects
// TODO: should we add last updated timestamp, revision etc. here ?
message ObjectMeta {
  fixed64        vrf_id = 1;     // vrf identifier
}

// Types of Vrfs
enum VrfType {
  VRF_TYPE_NONE          = 0;
  VRF_TYPE_INFRA         = 1;    // infra Vrf
  VRF_TYPE_CUSTOMER      = 2;    // customer Vrf
}

// Types of L2 segments
enum L2SegmentType {
  L2_SEGMENT_TYPE_NONE   = 0;
  L2_SEGMENT_PRIMARY     = 1;    // primary VLAN of PVLAN
  L2_SEGMENT_ISOLATED    = 2;    // isolated VLAN of PVLAN
}

// Supported wire encaps for the L2 segments
enum encapType {
  ENCAP_TYPE_NONE               = 0;
  ENCAP_TYPE_DOT1Q              = 1;    // .1q encapsulation
  ENCAP_TYPE_VXLAN              = 2;    // VXLAN encapsulation
  ENCAP_TYPE_IP_IN_IP           = 3;    // IP-in-IP encapsulation
  ENCAP_TYPE_GRE                = 4;    // GRE encapsulation
  ENCAP_TYPE_IPSEC              = 5;    // IPSec tunnel encapsulation
}

// EncapInfo captures wire encap information
message EncapInfo {
  encapType        encap_type  = 1;    // wire encap type
  uint32           encap_value = 2;    // encap value (vlan/vnid etc.)
}

// IP address families
enum IPAddressFamily {
  IP_AF_NONE     = 0;
  IP_AF_INET     = 1;    // IPv4
  IP_AF_INET6    = 2;    // IPv6
}

// IP address object
message IPAddress {
  IPAddressFamily    ip_af   = 1[(gogoproto.moretags) = "venice:mandatory"];      // IP address family
    fixed32          v4_addr = 2;      // IPv4 address
    bytes            v6_addr = 3;      // IPv6 address  (TODO: need better representation here)
}

// IP Range
message IPRange {
  IPAddress    low_ipaddr  = 1;    // start ip address
  IPAddress    high_ipaddr = 2;    // end ip address
}

// IP Prefix object
message IPPrefix {
  IPAddress    address       = 1;      // IP address
  uint32       prefix_len    = 2[(gogoproto.moretags) = "venice:range:0-128"];      // prefix length
}

enum IPAddressType {
  IP_ADDRESS_NONE           = 0;
  IP_ADDRESS_IPV4_ANY       = 1;  // any IPv4 address
  IP_ADDRESS_IPV6_ANY       = 2;  // any IPv6 address
  IP_ADDRESS_ANY            = 3;  // any IP address
  IP_ADDRESS_IPV4_MULTICAST = 4;  // any IPv4 multicast address
  IP_ADDRESS_IPV6_MULTICAST = 5;  // any IPv6 multicast address
  IP_ADDRESS_MULTICAST      = 6;  // any IP multicast address
  IP_ADDRESS_V6_LINK_LOCAL  = 7;  // IPv6 link local address
}

// IPSubnet represents an IPv4 or IPv6 subnet
message IPSubnet {
     IPPrefix ipv4_subnet      = 1;     // V4 Subnet
     IPPrefix ipv6_subnet      = 2;     // V6 Subnet
}

// AddressRange represents an IPv4 or IPv6 address range
message AddressRange {
     IPRange ipv4_range       = 1;  // V4 address range
     IPRange ipv6_range       = 2;  // V6 address range
}

// Address object is the prefix or range
message Address {
    IPSubnet      prefix     = 1;    // v4 or v6 address prefix
    AddressRange  addr_range      = 2;    // v4 or v6 address range
}

message IPAddressObj {
    IPAddressType   iptype        = 1;
    Address         address     = 2;
  bool negate                     = 3;
}

// PortRange object has low and high end of the port ranges
message L4PortRange {
  uint32    port_low  = 1 [(gogoproto.moretags) = "venice:range:0-65535"];   // port range start
  uint32    port_high = 2 [(gogoproto.moretags) = "venice:range:0-65535"];   // port range end
}


message Empty {}

// Types of Work Ring
enum WRingType {
  WRING_TYPE_NONE             = 0;
  WRING_TYPE_SERQ             = 1;
  WRING_TYPE_NMDR_TX          = 2;
  WRING_TYPE_NMDR_RX          = 3;
  WRING_TYPE_NMPR_SMALL_TX    = 4;
  WRING_TYPE_NMPR_SMALL_RX    = 5;
  WRING_TYPE_NMPR_BIG_TX      = 6;
  WRING_TYPE_NMPR_BIG_RX      = 7;
  WRING_TYPE_BSQ              = 8;
  WRING_TYPE_BRQ              = 9;
  WRING_TYPE_SESQ             = 10;
  WRING_TYPE_IPSECCBQ         = 11;
  WRING_TYPE_ARQRX            = 12;
  WRING_TYPE_ASQ              = 13;
  WRING_TYPE_ASESQ            = 14;
  WRING_TYPE_RAWRCB           = 15;
  WRING_TYPE_IPSECCBQ_BARCO   = 16;
  WRING_TYPE_APP_REDIR_RAWC   = 17;
  WRING_TYPE_APP_REDIR_PROXYR = 18;
  WRING_TYPE_APP_REDIR_PROXYC = 19;
  WRING_TYPE_NMDR_RX_GC       = 20;
  WRING_TYPE_NMDR_TX_GC       = 21;
  WRING_TYPE_ARQTX            = 22;
  WRING_TYPE_ASCQ             = 23;
  WRING_TYPE_CPUDR            = 24;
  WRING_TYPE_CPUPR            = 25;
  WRING_TYPE_IPSEC_NMDR_TX    = 26;
  WRING_TYPE_IPSEC_NMDR_RX    = 27;
  WRING_TYPE_IPSEC_NMPR_TX    = 28;
  WRING_TYPE_IPSEC_NMPR_RX    = 29;
  WRING_TYPE_IPSEC_BIG_NMDR_TX  = 30;
  WRING_TYPE_IPSEC_BIG_NMDR_RX  = 31;
  WRING_TYPE_IPSEC_BIG_NMPR_TX  = 32;
  WRING_TYPE_IPSEC_BIG_NMPR_RX  = 33;
  WRING_TYPE_NMDPR_SMALL_TX   = 34;
  WRING_TYPE_NMDPR_SMALL_RX   = 35;
  WRING_TYPE_NMDPR_BIG_TX     = 36;
  WRING_TYPE_NMDPR_BIG_RX     = 37;

}

// Types of Proxy Service
enum ProxyType {
  PROXY_TYPE_NONE                     = 0;
  PROXY_TYPE_TCP                      = 1;
  PROXY_TYPE_TLS                      = 2;
  PROXY_TYPE_IPSEC                    = 3;
  PROXY_TYPE_GC                       = 4;
  PROXY_TYPE_CPU                      = 5;
  PROXY_TYPE_IPFIX                    = 6;
  PROXY_TYPE_APP_REDIR                = 7;
  PROXY_TYPE_P4PT                     = 8;
  PROXY_TYPE_APP_REDIR_PROXY_TCP      = 9;
  PROXY_TYPE_APP_REDIR_SPAN           = 10;
  PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN = 11;
}

// Types of Cryptographic Asymmetric keys
enum CryptoAsymKeyType {
    CRYPTO_ASYM_KEY_TYPE_ECDSA  = 0;
    CRYPTO_ASYM_KEY_TYPE_RSA    = 1;
}

// Types of Cryptographic keys
enum CryptoKeyType {
    CRYPTO_KEY_TYPE_AES128      = 0;
    CRYPTO_KEY_TYPE_AES192      = 1;
    CRYPTO_KEY_TYPE_AES256      = 2;
    CRYPTO_KEY_TYPE_DES         = 3;
    CRYPTO_KEY_TYPE_CHACHA20    = 4;
    CRYPTO_KEY_TYPE_POLY1305    = 5;
    CRYPTO_KEY_TYPE_HMAC        = 6;
}

// Types of Barco Rings
enum BarcoRings {
    BARCO_RING_ASYM             = 0;
    BARCO_RING_GCM0             = 1;
    BARCO_RING_GCM1             = 2;
    BARCO_RING_XTS0             = 3;
    BARCO_RING_XTS1             = 4;
    BARCO_RING_MPP0             = 5;
    BARCO_RING_MPP1             = 6;
    BARCO_RING_MPP2             = 7;
    BARCO_RING_MPP3             = 8;
    BARCO_RING_MPP4             = 9;
    BARCO_RING_MPP5             = 10;
    BARCO_RING_MPP6             = 11;
    BARCO_RING_MPP7             = 12;
    BARCO_RING_CP               = 13;
    BARCO_RING_CP_HOT           = 14;
    BARCO_RING_DC               = 15;
    BARCO_RING_DC_HOT           = 16;
}

enum AppRedirType {
    APP_REDIR_TYPE_NONE         = 0;
    APP_REDIR_TYPE_REDIRECT     = 1;
    APP_REDIR_TYPE_SPAN         = 2;
}

// Types of CPU CB/QIDs
enum CpucbId {
    CPUCB_ID_FLOWMISS      = 0;
    CPUCB_ID_TCP_CLOSE     = 1;
    CPUCB_ID_RELIABLE_COPY = 2;
    CPUCB_ID_NACL_REDIRECT = 3;
    CPUCB_ID_QUIESCE       = 4;
    CPUCB_ID_NACL_LOG      = 5;
    CPUCB_ID_FTE_SPAN      = 6;
}

message DropReasons {
  bool      drop_malformed_pkt                      = 1;        // malformed pkt drop
  bool      drop_input_mapping                      = 2;        // input mapping table miss
  bool      drop_input_mapping_dejavu               = 3;        // deja-vu drop
  bool      drop_flow_hit                           = 4;        // flow hit drop
  bool      drop_flow_miss                          = 5;        // flow miss drop
  bool      drop_nacl                               = 6;        // nacl drop
  bool      drop_ipsg                               = 7;        // ipsg drop
  bool      drop_ip_normalization                   = 8;        // ip norm. drop
  bool      drop_tcp_normalization                  = 9;        // tcp norm. drop
  bool      drop_tcp_rst_with_invalid_ack_num       = 10;       // rst with invalid ack num
  bool      drop_tcp_non_syn_first_pkt              = 11;       // non-syn first pkt
  bool      drop_icmp_normalization                 = 12;       // icmp norm. drop
  bool      drop_input_properties_miss              = 13;       // input properties miss
  bool      drop_tcp_out_of_window                  = 14;       // tcp OOW drop
  bool      drop_tcp_split_handshake                = 15;       // split handshake drop
  bool      drop_tcp_win_zero_drop                  = 16;       // tcp win. zero
  bool      drop_tcp_data_after_fin                 = 17;       // tcp data after fin
  bool      drop_tcp_non_rst_pkt_after_rst          = 18;       // tcp non rst
  bool      drop_tcp_invalid_responder_first_pkt    = 19;       // tcp invalid resp.
  bool      drop_tcp_unexpected_pkt                 = 20;       // tcp unexpected packet
  bool      drop_src_lif_mismatch                   = 21;
  bool      drop_parser_icrc_error                  = 22;       // RDMA ICRC Errors
  bool      drop_parse_len_error                    = 23;       // Packet Length Errors
  bool      drop_hardware_error                     = 24;
}

message EgressDropReasons {
  bool      drop_output_mapping                     = 1;        // output mapping table miss
  bool      drop_prune_src_port                     = 2;        // prune source port drop
  bool      drop_mirror                             = 3;        // mirror drop
  bool      drop_policer                            = 4;        // policer drop
  bool      drop_copp                               = 5;        // copp drop
  bool      drop_checksum_err                       = 6;        // checksum error drop
}

// FTE Span Match Selectors
enum FTESpanMatchSelector {
  SRC_LPORT             = 0;
  DST_LPORT             = 1;
  DROP_REASON           = 2;
  FLOW_LKUP_DIR         = 3;
  FLOW_LKUP_TYPE        = 4;
  FLOW_LKUP_VRF         = 5;
  FLOW_LKUP_SRC         = 6;
  FLOW_LKUP_DST         = 7;
  FLOW_LKUP_PROTO       = 8;
  FLOW_LKUP_SPORT       = 9;
  FLOW_LKUP_DPORT       = 10;
  ETH_DMAC              = 11;
  FROM_CPU              = 12;
}

// VrfKeyHandle is used to operate on a vrf either by its key or handle
message VrfKeyHandle {
    uint64     vrf_id     = 1;   // unique vrf id allocated by app
    fixed64    vrf_handle = 2;    // vrf handle returned by HAL
}


// L2SegmentKeyHandle is used to operate on a L2 segment either by its
// segment id or HAL allocated handle
message L2SegmentKeyHandle {
    uint64     segment_id        = 1;     // App allocated unique L2 segment id
                                          // NOTE:
                                          // 1. this is unique across all types of L2 segments
                                          // 2. this is allocated by the HAL app
    fixed64    l2segment_handle  = 2;     // id of the L2 segment returned by HAL
}

// PortKeyHandle uniquely identifies a Port
message PortKeyHandle {
    fixed32   port_id       = 1;     // app allocated unique (across all ports) port id
    fixed64   port_handle   = 2;     // id of port returned by HAL
}

// LifKeyHandle uniquely identifies a LIF
message LifKeyHandle {
    fixed64         LifId     = 1;     // app allocated unique LIF id
    fixed64         LifHandle = 2;     // id of interface returned by HAL
}

// InterfaceKeyHandle uniquely identifies a Interface
message InterfaceKeyHandle {
    fixed64         InterfaceId = 1;     // app allocated unique (across all interface types) interface id
    fixed64         IfHandle    = 2;     // id of interface returned by HAL
}


// Filter Type
enum FilterType {
    FILTER_NONE         = 0; // None
    FILTER_LIF          = 1; // (Lif, *, *) Filter
    FILTER_LIF_MAC      = 2; // (Lif, Mac, *) Filter
    FILTER_LIF_VLAN     = 3; // (Lif, *, Vlan) Filter
    FILTER_LIF_MAC_VLAN = 4; // (Lif, Mac, Vlan) Filter
}

// Filter key
message FilterKey {
     LifKeyHandle     lif_key_or_handle   = 1;    // filter on lif
    FilterType          filter_type         = 2;    // type decides which of mac, vlan are valid
    uint64              mac_address         = 3;    // allow packets to this mac
    uint32              vlan_id             = 4;    // allow packets to this vlan
}

// Interface service definition
service Interface {
  // LIF related APIs
  rpc LifCreate(LifRequestMsg) returns (LifResponseMsg) {}
  rpc LifUpdate(LifRequestMsg) returns (LifResponseMsg) {}
  rpc LifDelete(LifDeleteRequestMsg) returns (LifDeleteResponseMsg) {}

  // Queue state related APIs
  rpc LifSetQState(SetQStateRequestMsg) returns (SetQStateResponseMsg) {}

  // common APIs for all interfaces
  rpc InterfaceCreate (InterfaceRequestMsg) returns (InterfaceResponseMsg) {}
  rpc InterfaceUpdate (InterfaceRequestMsg) returns (InterfaceResponseMsg) {}
  rpc InterfaceDelete (InterfaceDeleteRequestMsg) returns (InterfaceDeleteResponseMsg) {}
  rpc InterfaceGet (InterfaceGetRequestMsg) returns (InterfaceGetResponseMsg) {}

  // APIs specific to Uplinks
  rpc AddL2SegmentOnUplink (InterfaceL2SegmentRequestMsg) returns (InterfaceL2SegmentResponseMsg) {}
  rpc DelL2SegmentOnUplink (InterfaceL2SegmentRequestMsg) returns (InterfaceL2SegmentResponseMsg) {}
}

//  IntfStatus status reflects the current status of Interface
enum  IntfStatus {
  IF_STATUS_NONE    = 0;
  IF_STATUS_UP      = 1;
  IF_STATUS_DOWN    = 2;
}

//------------------------------------------------------------------------------
// LIF represents a connection point to ASIC, every connection to ASIC is
// exposed as a LIF (both uplinks and southbound links towards either workloads
// or host or VSS/DVS etc. Before creating any other kind of interface. LIFs are
// associated with a number of queues of different types and how to carve them
// is upto software. First LIFs need to be created and other interface types are
// tied to corresponding LIF. There is a many-to-1 relation between other types
// of interfaces and a LIF.
//------------------------------------------------------------------------------

// Different purposes of LIF queues. This is not the same as
// Queue type (type_num field in LifQStateMapEntry). This is
// application (e.g. TCP, RDMA, Storage) specific and is specified
// on a per LIF per Queue Type bases. In other words, for one LIF
// type 0 can be TX Queue and for another LIF type 0 can be RX Queue.
enum  LifQueuePurpose {
  LIF_QUEUE_PURPOSE_NONE      = 0;    // Queue disabled.
  LIF_QUEUE_PURPOSE_ADMIN     = 1;    // Admin Queue
  LIF_QUEUE_PURPOSE_TX        = 2;    // Tx Queue
  LIF_QUEUE_PURPOSE_RX        = 3;    // Rx Queue
  LIF_QUEUE_PURPOSE_RDMA_SEND = 4;    // RDMA send Queue
  LIF_QUEUE_PURPOSE_RDMA_RECV = 5;    // RDMA receive Queue
  LIF_QUEUE_PURPOSE_CQ        = 6;    // Completion Queue
  LIF_QUEUE_PURPOSE_EQ        = 7;    // Event Queue
  LIF_QUEUE_PURPOSE_NVME      = 8;    // Both SQ/CQ use this.
  LIF_QUEUE_PURPOSE_STORAGE   = 9;    // All the PVM queues.
  LIF_QUEUE_PURPOSE_VIRTIO_TX = 10;
  LIF_QUEUE_PURPOSE_VIRTIO_RX = 11;

  // Add more purposes as needed.
}

// A single entry in the LIF to Qstate map.
// This entry represents a single type.
// Everything except type puspose is used by the hardware.
message LifQStateMapEntry {
  // type_num is the type as defined by Capri hardware in the
  // LIF -> Qstate array entry. There are 8 types numbered 0-7.
  // There can be at most one entry per type_num.
  // TODO: How does a user know what number to use here unless
  // it is enumerated or purpose is clear ???
  uint32                type_num = 1;

  // This entry represents the size of the Q state
  // used by this type. This number represents the size
  // as 2^(5+size). e.g. for a size of 64, the size field
  // would be 1 i.e. 2^(5+1) = 64.
  // Max value for size today is 7 i.e. 4096 bytes.
  uint32                size     = 2;

  // entries field represent number of queues as a
  // power of 2. So a value of 3 means 8 queues.
  // Max value for entries today is 24 i.e. 16M queues.
  uint32                entries  = 3;

  // Queue purpose is not needed by the hardware. It is used
  // internally by the HAL/FTE.
   LifQueuePurpose           purpose  = 4;
}

// Packet filters to receive traffic
message PktFilter {
    bool    receive_broadcast     = 1;    // Receive Broadcast
    bool    receive_all_multicast = 2;    // Receive all Multicast
    bool    receive_promiscuous   = 3;    // Receive Unknown Unicast
}

// LIF object
message LifSpec {
  option (delphi.update_event) = true;
  delphi.ObjectMeta          Meta                       = 1;

  // key_or_handle is LIF's key or handle
   LifKeyHandle            key_or_handle               = 2 [(gogoproto.moretags) = "venice:key"];
   InterfaceKeyHandle      pinned_uplink_if_key_handle = 3 [(gogoproto.moretags) = "venice:ref,venice:constraints={intf.InterfaceSpec.type=interface_pb2.IF_TYPE_UPLINK}" ];
   IntfStatus                   admin_status                = 4;    // admin status of the interface
  LifQStateMapEntry lif_qstate_map              = 5;    // LIF -> Qstate map.
  bool                       vlan_strip_en               = 6;    // LIF vlan strip enable
  bool                       vlan_insert_en              = 7;    // Ingress vlan tag in p4plus_to_p4 hdr
  bool                       enable_rdma                 = 8;    // RDMA: enable RDMA on LIF
  bool                       is_management               = 9 [(gogoproto.moretags) = "venice:immutable"];    // Set for MNICs and Management NICs.
  PktFilter                  packet_filter               = 10;   // Packet filters
  uint32                     hw_lif_id                   = 11;   // hw lif id. Zero will make Hal allocate it
  uint32                     rdma_max_keys               = 12;   // RDMA: max key entries
  uint32                     rdma_max_ahs                = 13;
  uint32                     rdma_max_pt_entries         = 14;   // RDMA: max pt entries
  QStateSetReq      lif_qstate                  = 15;   // Initialize Qstate
  LifRssSpec                 rss                         = 16;   // ETH: LIF RSS configuration
}

// LifRequestMsg is batched request used to create/update of LIFs
message LifRequestMsg {
   LifSpec    request = 1;    // batch of requests
}

// LifStatus represents the operational status of LIF
message LifStatus {
  option (delphi.update_event) = true;
  delphi.ObjectMeta   Meta = 1;
   LifKeyHandle     key_or_handle = 2 [(gogoproto.moretags) = "venice:key"];

   IntfStatus    lif_status = 3;    // currrent status of the interface
  fixed64     lif_handle = 4;    // id of the interface returned by HAL
  uint64      hw_lif_id  = 5;    // Hardware Lif Id
}

// LifQstate entries
message LifQState {
  uint32 type_num   = 1;  // Queue type
  uint64 addr       = 2;  // Address of QState in HBM.
}

// LifRdmaData entries
message LifRdmaData {
  uint64 pt_base_addr = 1;  // Page Table Base Addr
  uint64 kt_base_addr = 2;  // Key Table Base Addr
  uint64 at_base_addr = 3;  // AH Table Base Addr
}

// LifResponse response to one LifSpec
message LifResponse {
  ApiStatus     api_status      = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  LifStatus           status          = 2;    // operational status
  LifQState  qstate          = 3;    // Qstate Address info
  bool                rdma_data_valid = 4; // RDMA data valid only this bit is set
  LifRdmaData         rdma_data       = 5;    // RDMA data - valid only when rdma is enabled
}

// LifResponseMsg is response to LifRequestMsg
message LifResponseMsg {
  LifResponse    response = 1;    // batch of responses
}

message QStateGetReq {
  uint64 lif_handle = 1;
  uint32 type_num   = 2;  // Queue type
  uint32 qid        = 3;  // Queue ID within type

  // Amount of data to return in the corresponding
  // QStateGetResp::queue_state buffer. By default
  // All the data is returned (based on the size of this
  // queue type_num). But can be limited by the caller.
  // Setting this value to be greater than the actual
  // size has no effect.
  uint32 ret_data_size = 4;
}

message QStateGetResp {
  // TODO: what is user to make out of this error_code if it is non-zero ??
  //       why this is not using  ApiStatus ???
  int32 error_code  = 1;  // 0 = success, otherwise errno.
  uint64 q_addr     = 2;  // Address of the queue in HBM.
  bytes queue_state = 3;  // Actual Queue state data.
}

message GetQStateResponseMsg {
  QStateGetResp resps = 1;
}

// A P4ProgLabel is used to get the PC offset for
// Queue state.
message P4ProgLabel {
  string handle = 1;
  string prog_name = 2;
  string label = 3;
}

message QStateSetReq {
  uint64 lif_handle = 1;
  uint32 type_num   = 2;  // Queue type
  uint32 qid        = 3;  // Queue ID within type

  // If present, PC Offset is filled by the implementation
  // based on the label.
  P4ProgLabel label = 4;

  // Actual queue state to be written. Can be less than the
  // actual qstate size. But has to be greater than 0.
  bytes queue_state = 5;
}

message SetQStateRequestMsg {
  QStateSetReq reqs = 1;
}

message QStateSetResp {
  // TODO: what is user to make out of this error_code if it is non-zero ??
  //       why this is not using  ApiStatus ??
  int32 error_code = 1;  // 0 = success, otherwise errno.
}

message SetQStateResponseMsg {
  QStateSetResp resps = 1;
}

// LifDeleteRequest  is used to delete a LIF object
message LifDeleteRequest {
  // key_or_handle is LIF's unique identifier for deletion
   LifKeyHandle key_or_handle  = 1 [(gogoproto.moretags) = "venice:key"];
}

// LifDeleteRequestMsg is used to delete a batch of LIFs
message LifDeleteRequestMsg {
  LifDeleteRequest    request = 1;    // batched delete request
}

// LifDeleteResponse is response to LIF delete request
message LifDeleteResponse {
  ApiStatus    api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
}

// LifDeleteResponseMsg is batched response to LifDeleteRequestMsg
message LifDeleteResponseMsg {
  LifDeleteResponse response = 1;
}

// check which stats will be done by p4 and which will be done by p4+
message LifTxStats {
  uint64           frames_ok           = 1;
  uint64           unicast_frames_ok   = 2;
  uint64           multicast_brames_ok = 3;
  uint64           broadcast_brames_ok = 4;
  uint64           bytes_ok            = 5;
  uint64           unicast_bytes_ok    = 6;
  uint64           multicast_bytes_ok  = 7;
  uint64           broadcast_bytes_ok  = 8;
  uint64           tso                 = 9;
}

message LifRxStats {
  uint64           frames_total        = 1;
  uint64           frames_ok           = 2;
  uint64           unicast_frames_ok   = 3;
  uint64           multicast_frames_ok = 4;
  uint64           broadcast_frames_ok = 5;
  uint64           bytes_ok            = 6;
  uint64           unicast_bytes_ok    = 7;
  uint64           multicast_bytes_ok  = 8;
  uint64           broadcast_bytes_ok  = 9;
  uint64           drops               = 10;
  uint64           no_bufs             = 11;
  uint64           errors              = 12;
  uint64           rss                 = 13;
  uint64           crc_errors          = 14;
  uint64           frames_64           = 15;
  uint64           frames_127          = 16;
  uint64           frames_255          = 17;
  uint64           frames_511          = 18;
  uint64           frames_1024         = 19;
  uint64           frames_1518         = 20;
  uint64           frames_to_max       = 21;
}

// LifRssConfig is used to set Lif's RSS configuration
message LifRssSpec {
  uint32        lif_type      = 1;    // RSS type
  bytes         key       = 2;    // RSS key/seed
  bytes         indir     = 3;    // RSS indirection entries
}

// types of interfaces
enum  IntfType {
  IF_TYPE_NONE         = 0;
  IF_TYPE_ENIC         = 1;    // interface connected to workload/endpoint(s)
  IF_TYPE_UPLINK       = 2;    // interface representing NIC uplink(s)
  IF_TYPE_UPLINK_PC    = 3;    // interface representing NIC uplink port channel
  IF_TYPE_TUNNEL       = 4;    // interface representing tunnel
  IF_TYPE_CPU          = 5;    // interface representing CPU
  IF_TYPE_APP_REDIR    = 6;    // interface representing App Redirect
}

//------------------------------------------------------------------------------
// if interface type is IF_TYPE_ENIC, one of the following vnic types must be
// set. IF_ENIC_TYPE_XXX identifies how a workload is attached to asic
//------------------------------------------------------------------------------
enum IntfEnicType {
  IF_ENIC_TYPE_NONE     = 0;
  IF_ENIC_TYPE_USEG     = 1;    // workload interface used in inline useg mode
  IF_ENIC_TYPE_PVLAN    = 2;    // workload attachment used in PVLAN mode
  IF_ENIC_TYPE_DIRECT   = 3;    // workload attachment used for SR-IOV,
                                // VSS/DVS connectivity etc.
  IF_ENIC_TYPE_CLASSIC  = 4;    // enics in classic mode
  IF_ENIC_TYPE_GFT      = 5;    // enics in gft mode
}

message EnicInfo {
     L2SegmentKeyHandle l2segment_key_handle = 1 [(gogoproto.moretags) = "venice:ref"]; // user (external) l2segment
    fixed64               mac_address          = 2; // MAC address of the endpoint
    uint32                encap_vlan_id        = 3; // Encap Vlan
}

message EnicClassicInfo {
     L2SegmentKeyHandle l2segment_key_handle = 1 [(gogoproto.moretags) = "venice:ref"]; // classic: l2segs allowed on the enic
    uint64  native_l2segment_id                         = 2;
}

// mandatory attributes expected if interface type is IF_TYPE_ENIC
message IfEnicInfo {
  IntfEnicType            enic_type                   = 1 [(gogoproto.moretags) = "venice:mandatory"]; // type of enic interface
   LifKeyHandle       lif_key_or_handle           = 2 [(gogoproto.moretags) = "venice:ref"]; // LIF identifier for this interface
   InterfaceKeyHandle pinned_uplink_if_key_handle = 3 [(gogoproto.moretags) = "venice:ref"]; // uplink this enic is pinned to
      EnicInfo          enic_info                   = 4 [(gogoproto.moretags) = "venice:constraints={intf.IfEnicInfo.enic_type==interface_pb2.IF_ENIC_TYPE_USEG}"]; // enic info for non-classic types
      EnicClassicInfo   classic_enic_info           = 5 [(gogoproto.moretags) = "venice:constraints={intf.IfEnicInfo.enic_type==interface_pb2.IF_ENIC_TYPE_CLASSIC}"];
}

// mandatory attributes expected if interface type is IF_TYPE_UPLINK
message IfUplinkInfo {
  uint32           port_num              = 1  [(gogoproto.moretags) = "venice:mandatory"]; // uplink port number
  uint64           native_l2segment_id   = 2; // L2 segment to map the packets to, if they are untagged
  bool             is_oob_management     = 3 [(gogoproto.moretags) = "venice:immutable"];  // Set for OOB port
}

message IfUplinkPCInfo {
  // mandatory attributes expected if interface type is IF_TYPE_UPLINK_PC
  uint64                         native_l2segment_id   = 1;    // L2 segment to map the packets to, if they are untagged
   InterfaceKeyHandle member_if_key_handle  = 2 [(gogoproto.moretags) = "venice:ref,venice:constraints={intf.InterfaceSpec.type=interface_pb2.IF_TYPE_UPLINK}"];
}

//------------------------------------------------------------------------------
// if interface type is IF_TYPE_TUNNEL, one of the following encap types must be
// set.
//------------------------------------------------------------------------------
enum IntfTunnelEncapType {
  IF_TUNNEL_ENCAP_TYPE_NONE     = 0;
  IF_TUNNEL_ENCAP_TYPE_VXLAN    = 1;
  IF_TUNNEL_ENCAP_TYPE_GRE      = 2;
}

message IfTunnelVxlanInfo {
   IPAddress   local_tep           = 1;
   IPAddress   remote_tep          = 2;
}

message IfTunnelGREInfo {
   IPAddress   source          = 1;
   IPAddress   destination     = 2;
  uint32            mtu             = 3;
  uint32            ttl             = 4;
}

message IfTunnelInfo {
  IntfTunnelEncapType     encap_type      = 1;
    IfTunnelVxlanInfo   vxlan_info      = 2 [(gogoproto.moretags) = "venice:constraints={intf.IfTunnelInfo.encap_type==interface_pb2.IF_TUNNEL_ENCAP_TYPE_VXLAN}"];
    IfTunnelGREInfo     gre_info        = 3 [(gogoproto.moretags) = "venice:constraints={intf.IfTunnelInfo.encap_type==interface_pb2.IF_TUNNEL_ENCAP_TYPE_GRE}"];
   VrfKeyHandle       vrf_key_handle  = 4 [(gogoproto.moretags) = "venice:ref"];
}

// attributes for CPU If
message IfCPUInfo {
   LifKeyHandle lif_key_or_handle   = 2 [(gogoproto.moretags) = "venice:ref"];    // LIF identifier for this interface
}

// attributes for App Redirect If
message IfAppRedirInfo {
   LifKeyHandle lif_key_or_handle   = 2 [(gogoproto.moretags) = "venice:ref"];    // LIF identifier for this interface
}

// InterfaceSpec is used to add or update of an interface
message InterfaceSpec {
  option (delphi.update_event) = true;
  delphi.ObjectMeta       Meta         = 1;

   InterfaceKeyHandle key_or_handle  = 2 [(gogoproto.moretags) = "venice:key"];     // interface being created/updated
   IntfType             if_type              = 3 [(gogoproto.moretags) = "venice:immutable"];     // type of interface
   IntfStatus           admin_status      = 4;     // admin status of the interface
    IfEnicInfo       if_enic_info      = 5 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_ENIC}"];     // enic data if interface type is IF_TYPE_ENIC
    IfUplinkInfo     if_uplink_info    = 6 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_UPLINK}"];     // uplink port number if interface type is IF_TYPE_UPLINK
    IfUplinkPCInfo   if_uplink_pc_info = 7 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_UPLINK_PC}"];     // uplink port channel number if interface type is IF_TYPE_UPLINK_PC
    IfTunnelInfo     if_tunnel_info    = 8 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_TUNNEL}"];     // tunnel interface information
    IfCPUInfo        if_cpu_info       = 9 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_CPU}"];     // cpu interface informaton
    IfAppRedirInfo   if_app_redir_info = 10 [(gogoproto.moretags) = "venice:constraints={intf.InterfaceSpec.type==interface_pb2.IF_TYPE_APP_REDIR}"];     // app redirect interface informaton
}

// InterfaceRequestMsg is batched request message that is used to do
// create/update of interface(s)
message InterfaceRequestMsg {
  InterfaceSpec    request = 1;    // batch of requests
}

// Uplink/Uplink PC's response
message UplinkResponseInfo {
    uint32      uplink_lport_id = 1;    // Uplink/Uplink PC's lport id
    uint32      hw_lif_id       = 2;    // hw lif id for Uplink/UplinkPC
    uint32      uplink_idx      = 3;    // Unique id for every Uplink/Uplink PC. Used to maintain l2seg membership
    uint32      num_l2segs      = 4;    // number of l2segs configured on this uplink
    uint32      hw_port_num     = 5;    // hw port number. aka tm_oport.
}

// Enic <-> L2seg membership info
message EnicL2SegInfo {
   L2SegmentKeyHandle     l2segment_key_or_handle = 1 [(gogoproto.moretags) = "venice:ref"];
  uint32                    inp_prop_idx            = 2;
}

message SmartEnicInfo {
  uint32      inp_prop_mac_vlan_idx_host  = 1;    // Input prop. Mac Vlan table idx from host packets
  uint32      inp_prop_mac_vlan_idx_net   = 2;    // Input prop. Mac Vlan table idx from network packets
}

message ClassicEnicInfo {
  uint32      inp_prop_nat_l2seg_classic  = 1;    // Input prop. table idx for native l2seg. Classic mode
  EnicL2SegInfo membership_info  = 2;    // L2seg membership info for Enic. Classic mode
}

// Enic's response
message EnicResponseInfo {
  uint32                enic_lport_id               = 1;    // Enic's lport id
  uint32                uplink_if_handle            = 2;    // Enic's uplink if handle
    SmartEnicInfo       smart_enic_info             = 3;
    ClassicEnicInfo     classic_enic_info           = 4;
}

// CPU If's response
message CpuIfResponseInfo {
    uint32  cpu_lport_id = 1;   // CPU Lport id
}

// Tunnel If's response
message TunnelIfResponseInfo {
  uint32   inp_map_nat_idx = 1;    // GIPo termination entries in Input Mappnig Native table
                                            //  1. Inner IPv4
                                            //  2. Inner IPv6
                                            //  3. Inner MAC
  uint32   inp_map_tnl_idx = 2;    // GIPo termination entries in Input Mappnig Tunnel table
                                            //  1. Inner IPv4
                                            //  2. Inner IPv6
                                            //  3. Inner MAC
  uint32            tunnel_rw_idx   = 3;    // Tunnel Rewrite table idx
}

// App redir if's response
message AppRedirIfInfo {
    uint32 LportId = 1;
}

// InterfaceStatus represents the current status of the interface
message InterfaceStatus {
  option (delphi.update_event) = true;
  delphi.ObjectMeta         Meta              = 1;

   InterfaceKeyHandle key_or_handle         = 2 [(gogoproto.moretags) = "venice:key"];     // interface being created/updated
   IntfStatus                  if_status         = 3;    // currrent status of the interface
  fixed64                   if_handle         = 4;    // id of the interface returned by HAL
    UplinkResponseInfo      uplink_info       = 5;    // Uplink/Uplink PC info
    EnicResponseInfo        enic_info         = 6;    // Enic's info
    CpuIfResponseInfo       cpu_info          = 7;    // CPU If's info
    TunnelIfResponseInfo    tunnel_info       = 8;    // Tunnel If's info
    AppRedirIfInfo          app_redir_info    = 9;    // App Redir info
}

// InterfaceResponse is response to one InterfaceSpec
message InterfaceResponse {
   ApiStatus    api_status  = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  InterfaceStatus    status      = 2;    // operational status
}

// InterfaceResponseMsg is response to InterfaceRequestMsg
message InterfaceResponseMsg {
  InterfaceResponse    response = 1;    // batch of responses
}

// InterfaceDeleteRequest is used to delete a interface object
message InterfaceDeleteRequest {
   InterfaceKeyHandle    key_or_handle = 1 [(gogoproto.moretags) = "venice:key"];    // interface being deleted
}

// InterfaceDeleteRequestMsg is used to delete a batch of interfaces
message InterfaceDeleteRequestMsg {
  InterfaceDeleteRequest    request = 1;   // batched delete request
}

// InterfaceDeleteResponse is batched response to InterfaceDeleteRequest
message InterfaceDeleteResponse {
   ApiStatus    api_status = 1 [(gogoproto.moretags) = "venice:api_status"];      // API status code
}

// InterfaceDeleteResponseMsg is batched response to InterfaceDeleteRequestMsg
message InterfaceDeleteResponseMsg {
  InterfaceDeleteResponse Response = 1;
}

// InterfaceStats captures all the statistics of given interface
message InterfaceStats {
  fixed32    num_tx_packets = 1;    // Tx Packets from this interface
  fixed32    num_tx_bytes   = 2;    // Tx Bytes from this interface
  fixed32    num_rx_packets = 3;    // Rx Packets to this interface
  fixed32    num_rx_bytes   = 4;    // Rx Bytes to this interface
}

// InterfaceGetRequest is used to get information about a interface
message InterfaceGetRequest {
   InterfaceKeyHandle    key_or_handle = 1 [(gogoproto.moretags) = "venice:key"];    // interface key or handle
}

// InterfaceGetRequestMsg is batched GET request for interfaces
message InterfaceGetRequestMsg {
  InterfaceGetRequest    request = 1;    // batched get request
}

// InterfaceGetResponse captures all the information about a interface
message InterfaceGetResponse {
   ApiStatus    api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  InterfaceSpec      spec       = 2;    // interface specification/configuration
  InterfaceStatus    status     = 3;    // interface status
  InterfaceStats     stats      = 4;    // interface statistics
}

// InterfaceGetResponseMsg is response to InterfaceGetRequestMsg
message InterfaceGetResponseMsg {
   ApiStatus                  api_status   = 1;    // API status code
  InterfaceGetResponse    response     = 2;    // batched get response
}

// InterfaceL2SegmentSpec carries the user vlan that is being added or deleted
// on an uplink interface or uplink PC
message InterfaceL2SegmentSpec {
   L2SegmentKeyHandle    l2segment_key_or_handle = 1 [(gogoproto.moretags) = "venice:ref"];    // L2 segment Id corresponding to the vlan
   InterfaceKeyHandle    if_key_handle           = 2 [(gogoproto.moretags) = "venice:ref"];    // Uplink/Uplink PC key or handle
}

// InterfaceL2SegmentRequestMsg is batched request message to bring vlans
// on interfaces
message InterfaceL2SegmentRequestMsg {
  InterfaceL2SegmentSpec    request = 1;    // batched request
}

// InterfaceL2SegmentResponse is response to InterfaceL2SegmentSpec
message InterfaceL2SegmentResponse {
   ApiStatus       api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
}

// InterfaceL2SegmentResponseMsg is batched response to InterfaceL2SegmentResponse
message InterfaceL2SegmentResponseMsg {
  InterfaceL2SegmentResponse    response = 1;    // batched response
}
