// Code generated by protoc-gen-go. DO NOT EDIT.
// source: interface.proto

/*
Package goproto is a generated protocol buffer package.

It is generated from these files:
	interface.proto

It has these top-level messages:
	ObjectMeta_
	EncapInfo_
	IPAddress_
	IPRange_
	IPPrefix_
	IPSubnet_
	AddressRange_
	Address_
	IPAddressObj_
	L4PortRange_
	Empty_
	DropReasons_
	EgressDropReasons_
	VrfKeyHandle_
	L2SegmentKeyHandle_
	PortKeyHandle_
	LifKeyHandle_
	InterfaceKeyHandle_
	FilterKey_
	LifQStateMapEntry_
	PktFilter_
	LifSpec_
	LifRequestMsg_
	LifStatus_
	LifQState_
	LifRdmaData_
	LifResponse_
	LifResponseMsg_
	QStateGetReq_
	QStateGetResp_
	GetQStateResponseMsg_
	P4ProgLabel_
	QStateSetReq_
	SetQStateRequestMsg_
	QStateSetResp_
	SetQStateResponseMsg_
	LifDeleteRequest_
	LifDeleteRequestMsg_
	LifDeleteResponse_
	LifDeleteResponseMsg_
	LifTxStats_
	LifRxStats_
	LifRssSpec_
	EnicInfo_
	EnicClassicInfo_
	IfEnicInfo_
	IfUplinkInfo_
	IfUplinkPCInfo_
	IfTunnelVxlanInfo_
	IfTunnelGREInfo_
	IfTunnelInfo_
	IfCPUInfo_
	IfAppRedirInfo_
	InterfaceSpec_
	InterfaceRequestMsg_
	UplinkResponseInfo_
	EnicL2SegInfo_
	SmartEnicInfo_
	ClassicEnicInfo_
	EnicResponseInfo_
	CpuIfResponseInfo_
	TunnelIfResponseInfo_
	AppRedirIfInfo_
	InterfaceStatus_
	InterfaceResponse_
	InterfaceResponseMsg_
	InterfaceDeleteRequest_
	InterfaceDeleteRequestMsg_
	InterfaceDeleteResponse_
	InterfaceDeleteResponseMsg_
	InterfaceStats_
	InterfaceGetRequest_
	InterfaceGetRequestMsg_
	InterfaceGetResponse_
	InterfaceGetResponseMsg_
	InterfaceL2SegmentSpec_
	InterfaceL2SegmentRequestMsg_
	InterfaceL2SegmentResponse_
	InterfaceL2SegmentResponseMsg_
*/
package goproto

import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gogoproto "github.com/gogo/protobuf/gogoproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// goproto_enum_prefix from public import gogo.proto
var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

// goproto_enum_stringer from public import gogo.proto
var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

// enum_stringer from public import gogo.proto
var E_EnumStringer = gogoproto.E_EnumStringer

// enum_customname from public import gogo.proto
var E_EnumCustomname = gogoproto.E_EnumCustomname

// enumdecl from public import gogo.proto
var E_Enumdecl = gogoproto.E_Enumdecl

// enumvalue_customname from public import gogo.proto
var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

// goproto_getters_all from public import gogo.proto
var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

// goproto_enum_prefix_all from public import gogo.proto
var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

// goproto_stringer_all from public import gogo.proto
var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

// verbose_equal_all from public import gogo.proto
var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

// face_all from public import gogo.proto
var E_FaceAll = gogoproto.E_FaceAll

// gostring_all from public import gogo.proto
var E_GostringAll = gogoproto.E_GostringAll

// populate_all from public import gogo.proto
var E_PopulateAll = gogoproto.E_PopulateAll

// stringer_all from public import gogo.proto
var E_StringerAll = gogoproto.E_StringerAll

// onlyone_all from public import gogo.proto
var E_OnlyoneAll = gogoproto.E_OnlyoneAll

// equal_all from public import gogo.proto
var E_EqualAll = gogoproto.E_EqualAll

// description_all from public import gogo.proto
var E_DescriptionAll = gogoproto.E_DescriptionAll

// testgen_all from public import gogo.proto
var E_TestgenAll = gogoproto.E_TestgenAll

// benchgen_all from public import gogo.proto
var E_BenchgenAll = gogoproto.E_BenchgenAll

// marshaler_all from public import gogo.proto
var E_MarshalerAll = gogoproto.E_MarshalerAll

// unmarshaler_all from public import gogo.proto
var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

// stable_marshaler_all from public import gogo.proto
var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

// sizer_all from public import gogo.proto
var E_SizerAll = gogoproto.E_SizerAll

// goproto_enum_stringer_all from public import gogo.proto
var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

// enum_stringer_all from public import gogo.proto
var E_EnumStringerAll = gogoproto.E_EnumStringerAll

// unsafe_marshaler_all from public import gogo.proto
var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

// unsafe_unmarshaler_all from public import gogo.proto
var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

// goproto_extensions_map_all from public import gogo.proto
var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

// goproto_unrecognized_all from public import gogo.proto
var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

// gogoproto_import from public import gogo.proto
var E_GogoprotoImport = gogoproto.E_GogoprotoImport

// protosizer_all from public import gogo.proto
var E_ProtosizerAll = gogoproto.E_ProtosizerAll

// compare_all from public import gogo.proto
var E_CompareAll = gogoproto.E_CompareAll

// typedecl_all from public import gogo.proto
var E_TypedeclAll = gogoproto.E_TypedeclAll

// enumdecl_all from public import gogo.proto
var E_EnumdeclAll = gogoproto.E_EnumdeclAll

// goproto_registration from public import gogo.proto
var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

// goproto_getters from public import gogo.proto
var E_GoprotoGetters = gogoproto.E_GoprotoGetters

// goproto_stringer from public import gogo.proto
var E_GoprotoStringer = gogoproto.E_GoprotoStringer

// verbose_equal from public import gogo.proto
var E_VerboseEqual = gogoproto.E_VerboseEqual

// face from public import gogo.proto
var E_Face = gogoproto.E_Face

// gostring from public import gogo.proto
var E_Gostring = gogoproto.E_Gostring

// populate from public import gogo.proto
var E_Populate = gogoproto.E_Populate

// stringer from public import gogo.proto
var E_Stringer = gogoproto.E_Stringer

// onlyone from public import gogo.proto
var E_Onlyone = gogoproto.E_Onlyone

// equal from public import gogo.proto
var E_Equal = gogoproto.E_Equal

// description from public import gogo.proto
var E_Description = gogoproto.E_Description

// testgen from public import gogo.proto
var E_Testgen = gogoproto.E_Testgen

// benchgen from public import gogo.proto
var E_Benchgen = gogoproto.E_Benchgen

// marshaler from public import gogo.proto
var E_Marshaler = gogoproto.E_Marshaler

// unmarshaler from public import gogo.proto
var E_Unmarshaler = gogoproto.E_Unmarshaler

// stable_marshaler from public import gogo.proto
var E_StableMarshaler = gogoproto.E_StableMarshaler

// sizer from public import gogo.proto
var E_Sizer = gogoproto.E_Sizer

// unsafe_marshaler from public import gogo.proto
var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

// unsafe_unmarshaler from public import gogo.proto
var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

// goproto_extensions_map from public import gogo.proto
var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

// goproto_unrecognized from public import gogo.proto
var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

// protosizer from public import gogo.proto
var E_Protosizer = gogoproto.E_Protosizer

// compare from public import gogo.proto
var E_Compare = gogoproto.E_Compare

// typedecl from public import gogo.proto
var E_Typedecl = gogoproto.E_Typedecl

// nullable from public import gogo.proto
var E_Nullable = gogoproto.E_Nullable

// embed from public import gogo.proto
var E_Embed = gogoproto.E_Embed

// customtype from public import gogo.proto
var E_Customtype = gogoproto.E_Customtype

// customname from public import gogo.proto
var E_Customname = gogoproto.E_Customname

// jsontag from public import gogo.proto
var E_Jsontag = gogoproto.E_Jsontag

// moretags from public import gogo.proto
var E_Moretags = gogoproto.E_Moretags

// casttype from public import gogo.proto
var E_Casttype = gogoproto.E_Casttype

// castkey from public import gogo.proto
var E_Castkey = gogoproto.E_Castkey

// castvalue from public import gogo.proto
var E_Castvalue = gogoproto.E_Castvalue

// stdtime from public import gogo.proto
var E_Stdtime = gogoproto.E_Stdtime

// stdduration from public import gogo.proto
var E_Stdduration = gogoproto.E_Stdduration

// IP protocol numbers
type IPProtocol int32

const (
	IPProtocol_IPPROTO_NONE   IPProtocol = 0
	IPProtocol_IPPROTO_ICMP   IPProtocol = 1
	IPProtocol_IPPROTO_IPV4   IPProtocol = 4
	IPProtocol_IPPROTO_TCP    IPProtocol = 6
	IPProtocol_IPPROTO_UDP    IPProtocol = 17
	IPProtocol_IPPROTO_GRE    IPProtocol = 47
	IPProtocol_IPPROTO_ESP    IPProtocol = 50
	IPProtocol_IPPROTO_AH     IPProtocol = 51
	IPProtocol_IPPROTO_ICMPV6 IPProtocol = 58
)

var IPProtocol_name = map[int32]string{
	0:  "IPPROTO_NONE",
	1:  "IPPROTO_ICMP",
	4:  "IPPROTO_IPV4",
	6:  "IPPROTO_TCP",
	17: "IPPROTO_UDP",
	47: "IPPROTO_GRE",
	50: "IPPROTO_ESP",
	51: "IPPROTO_AH",
	58: "IPPROTO_ICMPV6",
}
var IPProtocol_value = map[string]int32{
	"IPPROTO_NONE":   0,
	"IPPROTO_ICMP":   1,
	"IPPROTO_IPV4":   4,
	"IPPROTO_TCP":    6,
	"IPPROTO_UDP":    17,
	"IPPROTO_GRE":    47,
	"IPPROTO_ESP":    50,
	"IPPROTO_AH":     51,
	"IPPROTO_ICMPV6": 58,
}

func (x IPProtocol) String() string {
	return proto.EnumName(IPProtocol_name, int32(x))
}
func (IPProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ICMP message types
// TBD - add more here !!
type ICMPMsgType int32

const (
	ICMPMsgType_ICMP_MSG_TYPE_NONE ICMPMsgType = 0
	ICMPMsgType_ICMP_MSG_TYPE_ECHO ICMPMsgType = 1
)

var ICMPMsgType_name = map[int32]string{
	0: "ICMP_MSG_TYPE_NONE",
	1: "ICMP_MSG_TYPE_ECHO",
}
var ICMPMsgType_value = map[string]int32{
	"ICMP_MSG_TYPE_NONE": 0,
	"ICMP_MSG_TYPE_ECHO": 1,
}

func (x ICMPMsgType) String() string {
	return proto.EnumName(ICMPMsgType_name, int32(x))
}
func (ICMPMsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// API return codes (more descriptive than protobuf enums)
type ApiStatus int32

const (
	ApiStatus_API_STATUS_OK                           ApiStatus = 0
	ApiStatus_API_STATUS_ERR                          ApiStatus = 1
	ApiStatus_API_STATUS_INVALID_ARG                  ApiStatus = 2
	ApiStatus_API_STATUS_EXISTS_ALREADY               ApiStatus = 3
	ApiStatus_API_STATUS_OUT_OF_MEM                   ApiStatus = 4
	ApiStatus_API_STATUS_NOT_FOUND                    ApiStatus = 5
	ApiStatus_API_STATUS_OUT_OF_RESOURCE              ApiStatus = 6
	ApiStatus_API_STATUS_ENCAP_INVALID                ApiStatus = 7
	ApiStatus_API_STATUS_VRF_ID_INVALID               ApiStatus = 8
	ApiStatus_API_STATUS_L2_SEGMENT_ID_INVALID        ApiStatus = 9
	ApiStatus_API_STATUS_INTERFACE_ID_INVALID         ApiStatus = 10
	ApiStatus_API_STATUS_IF_TYPE_INVALID              ApiStatus = 11
	ApiStatus_API_STATUS_IF_INFO_INVALID              ApiStatus = 12
	ApiStatus_API_STATUS_IF_L2SEGMENT_INVALID         ApiStatus = 13
	ApiStatus_API_STATUS_IF_ENIC_INFO_INVALID         ApiStatus = 14
	ApiStatus_API_STATUS_IF_ENIC_TYPE_INVALID         ApiStatus = 15
	ApiStatus_API_STATUS_IF_LIF_INFO_NOT_INVALID      ApiStatus = 16
	ApiStatus_API_STATUS_IF_LIFQ_INFO_NOT_INVALID     ApiStatus = 17
	ApiStatus_API_STATUS_FLOW_KEY_INVALID             ApiStatus = 18
	ApiStatus_API_STATUS_FLOW_INFO_INVALID            ApiStatus = 19
	ApiStatus_API_STATUS_HANDLE_INVALID               ApiStatus = 20
	ApiStatus_API_STATUS_HW_PROG_ERR                  ApiStatus = 21
	ApiStatus_API_STATUS_LIF_ID_INVALID               ApiStatus = 22
	ApiStatus_API_STATUS_NWSEC_PROFILE_ID_INVALID     ApiStatus = 23
	ApiStatus_API_STATUS_TLS_CB_ID_INVALID            ApiStatus = 24
	ApiStatus_API_STATUS_TCP_CB_ID_INVALID            ApiStatus = 25
	ApiStatus_API_STATUS_ACL_ID_INVALID               ApiStatus = 26
	ApiStatus_API_STATUS_WRING_ID_INVALID             ApiStatus = 27
	ApiStatus_API_STATUS_WRING_TYPE_INVALID           ApiStatus = 28
	ApiStatus_API_STATUS_PROXY_TYPE_INVALID           ApiStatus = 29
	ApiStatus_API_STATUS_IPSEC_CB_ID_INVALID          ApiStatus = 30
	ApiStatus_API_STATUS_L4LB_KEY_INVALID             ApiStatus = 31
	ApiStatus_API_STATUS_CPU_CB_ID_INVALID            ApiStatus = 32
	ApiStatus_API_STATUS_PROXY_NOT_ENABLED            ApiStatus = 33
	ApiStatus_API_STATUS_CFG_DB_ERR                   ApiStatus = 34
	ApiStatus_API_STATUS_SECURITY_GROUP_ID_INVALID    ApiStatus = 35
	ApiStatus_API_STATUS_SECURITY_POLICY_ID_INVALID   ApiStatus = 36
	ApiStatus_API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID ApiStatus = 37
	ApiStatus_API_STATUS_DOS_POLICY_ID_INVALID        ApiStatus = 38
	ApiStatus_API_STATUS_RAWR_CB_ID_INVALID           ApiStatus = 39
	ApiStatus_API_STATUS_OBJECT_IN_USE                ApiStatus = 40
	ApiStatus_API_STATUS_RAWC_CB_ID_INVALID           ApiStatus = 41
	ApiStatus_API_STATUS_PORT_ID_INVALID              ApiStatus = 42
	ApiStatus_API_STATUS_PORT_TYPE_INVALID            ApiStatus = 43
	ApiStatus_API_STATUS_PORT_SPEED_INVALID           ApiStatus = 44
	ApiStatus_API_STATUS_PORT_NUM_LANES_INVALID       ApiStatus = 45
	ApiStatus_API_STATUS_MC_ENTRY_ID_INVALID          ApiStatus = 46
	ApiStatus_API_STATUS_PROXYR_CB_ID_INVALID         ApiStatus = 47
	ApiStatus_API_STATUS_PROXYC_CB_ID_INVALID         ApiStatus = 48
	ApiStatus_API_STATUS_HW_READ_ERROR                ApiStatus = 49
	ApiStatus_API_STATUS_HW_WRITE_ERROR               ApiStatus = 50
	ApiStatus_API_STATUS_L2_SEGMENT_TYPE_INVALID      ApiStatus = 51
	ApiStatus_API_STATUS_NAT_POOL_KEY_INVALID         ApiStatus = 52
	ApiStatus_API_STATUS_NAT_MAPPING_KEY_INVALID      ApiStatus = 53
)

var ApiStatus_name = map[int32]string{
	0:  "API_STATUS_OK",
	1:  "API_STATUS_ERR",
	2:  "API_STATUS_INVALID_ARG",
	3:  "API_STATUS_EXISTS_ALREADY",
	4:  "API_STATUS_OUT_OF_MEM",
	5:  "API_STATUS_NOT_FOUND",
	6:  "API_STATUS_OUT_OF_RESOURCE",
	7:  "API_STATUS_ENCAP_INVALID",
	8:  "API_STATUS_VRF_ID_INVALID",
	9:  "API_STATUS_L2_SEGMENT_ID_INVALID",
	10: "API_STATUS_INTERFACE_ID_INVALID",
	11: "API_STATUS_IF_TYPE_INVALID",
	12: "API_STATUS_IF_INFO_INVALID",
	13: "API_STATUS_IF_L2SEGMENT_INVALID",
	14: "API_STATUS_IF_ENIC_INFO_INVALID",
	15: "API_STATUS_IF_ENIC_TYPE_INVALID",
	16: "API_STATUS_IF_LIF_INFO_NOT_INVALID",
	17: "API_STATUS_IF_LIFQ_INFO_NOT_INVALID",
	18: "API_STATUS_FLOW_KEY_INVALID",
	19: "API_STATUS_FLOW_INFO_INVALID",
	20: "API_STATUS_HANDLE_INVALID",
	21: "API_STATUS_HW_PROG_ERR",
	22: "API_STATUS_LIF_ID_INVALID",
	23: "API_STATUS_NWSEC_PROFILE_ID_INVALID",
	24: "API_STATUS_TLS_CB_ID_INVALID",
	25: "API_STATUS_TCP_CB_ID_INVALID",
	26: "API_STATUS_ACL_ID_INVALID",
	27: "API_STATUS_WRING_ID_INVALID",
	28: "API_STATUS_WRING_TYPE_INVALID",
	29: "API_STATUS_PROXY_TYPE_INVALID",
	30: "API_STATUS_IPSEC_CB_ID_INVALID",
	31: "API_STATUS_L4LB_KEY_INVALID",
	32: "API_STATUS_CPU_CB_ID_INVALID",
	33: "API_STATUS_PROXY_NOT_ENABLED",
	34: "API_STATUS_CFG_DB_ERR",
	35: "API_STATUS_SECURITY_GROUP_ID_INVALID",
	36: "API_STATUS_SECURITY_POLICY_ID_INVALID",
	37: "API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID",
	38: "API_STATUS_DOS_POLICY_ID_INVALID",
	39: "API_STATUS_RAWR_CB_ID_INVALID",
	40: "API_STATUS_OBJECT_IN_USE",
	41: "API_STATUS_RAWC_CB_ID_INVALID",
	42: "API_STATUS_PORT_ID_INVALID",
	43: "API_STATUS_PORT_TYPE_INVALID",
	44: "API_STATUS_PORT_SPEED_INVALID",
	45: "API_STATUS_PORT_NUM_LANES_INVALID",
	46: "API_STATUS_MC_ENTRY_ID_INVALID",
	47: "API_STATUS_PROXYR_CB_ID_INVALID",
	48: "API_STATUS_PROXYC_CB_ID_INVALID",
	49: "API_STATUS_HW_READ_ERROR",
	50: "API_STATUS_HW_WRITE_ERROR",
	51: "API_STATUS_L2_SEGMENT_TYPE_INVALID",
	52: "API_STATUS_NAT_POOL_KEY_INVALID",
	53: "API_STATUS_NAT_MAPPING_KEY_INVALID",
}
var ApiStatus_value = map[string]int32{
	"API_STATUS_OK":                           0,
	"API_STATUS_ERR":                          1,
	"API_STATUS_INVALID_ARG":                  2,
	"API_STATUS_EXISTS_ALREADY":               3,
	"API_STATUS_OUT_OF_MEM":                   4,
	"API_STATUS_NOT_FOUND":                    5,
	"API_STATUS_OUT_OF_RESOURCE":              6,
	"API_STATUS_ENCAP_INVALID":                7,
	"API_STATUS_VRF_ID_INVALID":               8,
	"API_STATUS_L2_SEGMENT_ID_INVALID":        9,
	"API_STATUS_INTERFACE_ID_INVALID":         10,
	"API_STATUS_IF_TYPE_INVALID":              11,
	"API_STATUS_IF_INFO_INVALID":              12,
	"API_STATUS_IF_L2SEGMENT_INVALID":         13,
	"API_STATUS_IF_ENIC_INFO_INVALID":         14,
	"API_STATUS_IF_ENIC_TYPE_INVALID":         15,
	"API_STATUS_IF_LIF_INFO_NOT_INVALID":      16,
	"API_STATUS_IF_LIFQ_INFO_NOT_INVALID":     17,
	"API_STATUS_FLOW_KEY_INVALID":             18,
	"API_STATUS_FLOW_INFO_INVALID":            19,
	"API_STATUS_HANDLE_INVALID":               20,
	"API_STATUS_HW_PROG_ERR":                  21,
	"API_STATUS_LIF_ID_INVALID":               22,
	"API_STATUS_NWSEC_PROFILE_ID_INVALID":     23,
	"API_STATUS_TLS_CB_ID_INVALID":            24,
	"API_STATUS_TCP_CB_ID_INVALID":            25,
	"API_STATUS_ACL_ID_INVALID":               26,
	"API_STATUS_WRING_ID_INVALID":             27,
	"API_STATUS_WRING_TYPE_INVALID":           28,
	"API_STATUS_PROXY_TYPE_INVALID":           29,
	"API_STATUS_IPSEC_CB_ID_INVALID":          30,
	"API_STATUS_L4LB_KEY_INVALID":             31,
	"API_STATUS_CPU_CB_ID_INVALID":            32,
	"API_STATUS_PROXY_NOT_ENABLED":            33,
	"API_STATUS_CFG_DB_ERR":                   34,
	"API_STATUS_SECURITY_GROUP_ID_INVALID":    35,
	"API_STATUS_SECURITY_POLICY_ID_INVALID":   36,
	"API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID": 37,
	"API_STATUS_DOS_POLICY_ID_INVALID":        38,
	"API_STATUS_RAWR_CB_ID_INVALID":           39,
	"API_STATUS_OBJECT_IN_USE":                40,
	"API_STATUS_RAWC_CB_ID_INVALID":           41,
	"API_STATUS_PORT_ID_INVALID":              42,
	"API_STATUS_PORT_TYPE_INVALID":            43,
	"API_STATUS_PORT_SPEED_INVALID":           44,
	"API_STATUS_PORT_NUM_LANES_INVALID":       45,
	"API_STATUS_MC_ENTRY_ID_INVALID":          46,
	"API_STATUS_PROXYR_CB_ID_INVALID":         47,
	"API_STATUS_PROXYC_CB_ID_INVALID":         48,
	"API_STATUS_HW_READ_ERROR":                49,
	"API_STATUS_HW_WRITE_ERROR":               50,
	"API_STATUS_L2_SEGMENT_TYPE_INVALID":      51,
	"API_STATUS_NAT_POOL_KEY_INVALID":         52,
	"API_STATUS_NAT_MAPPING_KEY_INVALID":      53,
}

func (x ApiStatus) String() string {
	return proto.EnumName(ApiStatus_name, int32(x))
}
func (ApiStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Types of Vrfs
type VrfType int32

const (
	VrfType_VRF_TYPE_NONE     VrfType = 0
	VrfType_VRF_TYPE_INFRA    VrfType = 1
	VrfType_VRF_TYPE_CUSTOMER VrfType = 2
)

var VrfType_name = map[int32]string{
	0: "VRF_TYPE_NONE",
	1: "VRF_TYPE_INFRA",
	2: "VRF_TYPE_CUSTOMER",
}
var VrfType_value = map[string]int32{
	"VRF_TYPE_NONE":     0,
	"VRF_TYPE_INFRA":    1,
	"VRF_TYPE_CUSTOMER": 2,
}

func (x VrfType) String() string {
	return proto.EnumName(VrfType_name, int32(x))
}
func (VrfType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Types of L2 segments
type L2SegmentType int32

const (
	L2SegmentType_L2_SEGMENT_TYPE_NONE L2SegmentType = 0
	L2SegmentType_L2_SEGMENT_PRIMARY   L2SegmentType = 1
	L2SegmentType_L2_SEGMENT_ISOLATED  L2SegmentType = 2
)

var L2SegmentType_name = map[int32]string{
	0: "L2_SEGMENT_TYPE_NONE",
	1: "L2_SEGMENT_PRIMARY",
	2: "L2_SEGMENT_ISOLATED",
}
var L2SegmentType_value = map[string]int32{
	"L2_SEGMENT_TYPE_NONE": 0,
	"L2_SEGMENT_PRIMARY":   1,
	"L2_SEGMENT_ISOLATED":  2,
}

func (x L2SegmentType) String() string {
	return proto.EnumName(L2SegmentType_name, int32(x))
}
func (L2SegmentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Supported wire encaps for the L2 segments
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE     EncapType = 0
	EncapType_ENCAP_TYPE_DOT1Q    EncapType = 1
	EncapType_ENCAP_TYPE_VXLAN    EncapType = 2
	EncapType_ENCAP_TYPE_IP_IN_IP EncapType = 3
	EncapType_ENCAP_TYPE_GRE      EncapType = 4
	EncapType_ENCAP_TYPE_IPSEC    EncapType = 5
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_DOT1Q",
	2: "ENCAP_TYPE_VXLAN",
	3: "ENCAP_TYPE_IP_IN_IP",
	4: "ENCAP_TYPE_GRE",
	5: "ENCAP_TYPE_IPSEC",
}
var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":     0,
	"ENCAP_TYPE_DOT1Q":    1,
	"ENCAP_TYPE_VXLAN":    2,
	"ENCAP_TYPE_IP_IN_IP": 3,
	"ENCAP_TYPE_GRE":      4,
	"ENCAP_TYPE_IPSEC":    5,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}
func (EncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// IP address families
type IPAddressFamily int32

const (
	IPAddressFamily_IP_AF_NONE  IPAddressFamily = 0
	IPAddressFamily_IP_AF_INET  IPAddressFamily = 1
	IPAddressFamily_IP_AF_INET6 IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}
var IPAddressFamily_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type IPAddressType int32

const (
	IPAddressType_IP_ADDRESS_NONE           IPAddressType = 0
	IPAddressType_IP_ADDRESS_IPV4_ANY       IPAddressType = 1
	IPAddressType_IP_ADDRESS_IPV6_ANY       IPAddressType = 2
	IPAddressType_IP_ADDRESS_ANY            IPAddressType = 3
	IPAddressType_IP_ADDRESS_IPV4_MULTICAST IPAddressType = 4
	IPAddressType_IP_ADDRESS_IPV6_MULTICAST IPAddressType = 5
	IPAddressType_IP_ADDRESS_MULTICAST      IPAddressType = 6
	IPAddressType_IP_ADDRESS_V6_LINK_LOCAL  IPAddressType = 7
)

var IPAddressType_name = map[int32]string{
	0: "IP_ADDRESS_NONE",
	1: "IP_ADDRESS_IPV4_ANY",
	2: "IP_ADDRESS_IPV6_ANY",
	3: "IP_ADDRESS_ANY",
	4: "IP_ADDRESS_IPV4_MULTICAST",
	5: "IP_ADDRESS_IPV6_MULTICAST",
	6: "IP_ADDRESS_MULTICAST",
	7: "IP_ADDRESS_V6_LINK_LOCAL",
}
var IPAddressType_value = map[string]int32{
	"IP_ADDRESS_NONE":           0,
	"IP_ADDRESS_IPV4_ANY":       1,
	"IP_ADDRESS_IPV6_ANY":       2,
	"IP_ADDRESS_ANY":            3,
	"IP_ADDRESS_IPV4_MULTICAST": 4,
	"IP_ADDRESS_IPV6_MULTICAST": 5,
	"IP_ADDRESS_MULTICAST":      6,
	"IP_ADDRESS_V6_LINK_LOCAL":  7,
}

func (x IPAddressType) String() string {
	return proto.EnumName(IPAddressType_name, int32(x))
}
func (IPAddressType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// Types of Work Ring
type WRingType int32

const (
	WRingType_WRING_TYPE_NONE              WRingType = 0
	WRingType_WRING_TYPE_SERQ              WRingType = 1
	WRingType_WRING_TYPE_NMDR_TX           WRingType = 2
	WRingType_WRING_TYPE_NMDR_RX           WRingType = 3
	WRingType_WRING_TYPE_NMPR_SMALL_TX     WRingType = 4
	WRingType_WRING_TYPE_NMPR_SMALL_RX     WRingType = 5
	WRingType_WRING_TYPE_NMPR_BIG_TX       WRingType = 6
	WRingType_WRING_TYPE_NMPR_BIG_RX       WRingType = 7
	WRingType_WRING_TYPE_BSQ               WRingType = 8
	WRingType_WRING_TYPE_BRQ               WRingType = 9
	WRingType_WRING_TYPE_SESQ              WRingType = 10
	WRingType_WRING_TYPE_IPSECCBQ          WRingType = 11
	WRingType_WRING_TYPE_ARQRX             WRingType = 12
	WRingType_WRING_TYPE_ASQ               WRingType = 13
	WRingType_WRING_TYPE_ASESQ             WRingType = 14
	WRingType_WRING_TYPE_RAWRCB            WRingType = 15
	WRingType_WRING_TYPE_IPSECCBQ_BARCO    WRingType = 16
	WRingType_WRING_TYPE_APP_REDIR_RAWC    WRingType = 17
	WRingType_WRING_TYPE_APP_REDIR_PROXYR  WRingType = 18
	WRingType_WRING_TYPE_APP_REDIR_PROXYC  WRingType = 19
	WRingType_WRING_TYPE_NMDR_RX_GC        WRingType = 20
	WRingType_WRING_TYPE_NMDR_TX_GC        WRingType = 21
	WRingType_WRING_TYPE_ARQTX             WRingType = 22
	WRingType_WRING_TYPE_ASCQ              WRingType = 23
	WRingType_WRING_TYPE_CPUDR             WRingType = 24
	WRingType_WRING_TYPE_CPUPR             WRingType = 25
	WRingType_WRING_TYPE_IPSEC_NMDR_TX     WRingType = 26
	WRingType_WRING_TYPE_IPSEC_NMDR_RX     WRingType = 27
	WRingType_WRING_TYPE_IPSEC_NMPR_TX     WRingType = 28
	WRingType_WRING_TYPE_IPSEC_NMPR_RX     WRingType = 29
	WRingType_WRING_TYPE_IPSEC_BIG_NMDR_TX WRingType = 30
	WRingType_WRING_TYPE_IPSEC_BIG_NMDR_RX WRingType = 31
	WRingType_WRING_TYPE_IPSEC_BIG_NMPR_TX WRingType = 32
	WRingType_WRING_TYPE_IPSEC_BIG_NMPR_RX WRingType = 33
	WRingType_WRING_TYPE_NMDPR_SMALL_TX    WRingType = 34
	WRingType_WRING_TYPE_NMDPR_SMALL_RX    WRingType = 35
	WRingType_WRING_TYPE_NMDPR_BIG_TX      WRingType = 36
	WRingType_WRING_TYPE_NMDPR_BIG_RX      WRingType = 37
)

var WRingType_name = map[int32]string{
	0:  "WRING_TYPE_NONE",
	1:  "WRING_TYPE_SERQ",
	2:  "WRING_TYPE_NMDR_TX",
	3:  "WRING_TYPE_NMDR_RX",
	4:  "WRING_TYPE_NMPR_SMALL_TX",
	5:  "WRING_TYPE_NMPR_SMALL_RX",
	6:  "WRING_TYPE_NMPR_BIG_TX",
	7:  "WRING_TYPE_NMPR_BIG_RX",
	8:  "WRING_TYPE_BSQ",
	9:  "WRING_TYPE_BRQ",
	10: "WRING_TYPE_SESQ",
	11: "WRING_TYPE_IPSECCBQ",
	12: "WRING_TYPE_ARQRX",
	13: "WRING_TYPE_ASQ",
	14: "WRING_TYPE_ASESQ",
	15: "WRING_TYPE_RAWRCB",
	16: "WRING_TYPE_IPSECCBQ_BARCO",
	17: "WRING_TYPE_APP_REDIR_RAWC",
	18: "WRING_TYPE_APP_REDIR_PROXYR",
	19: "WRING_TYPE_APP_REDIR_PROXYC",
	20: "WRING_TYPE_NMDR_RX_GC",
	21: "WRING_TYPE_NMDR_TX_GC",
	22: "WRING_TYPE_ARQTX",
	23: "WRING_TYPE_ASCQ",
	24: "WRING_TYPE_CPUDR",
	25: "WRING_TYPE_CPUPR",
	26: "WRING_TYPE_IPSEC_NMDR_TX",
	27: "WRING_TYPE_IPSEC_NMDR_RX",
	28: "WRING_TYPE_IPSEC_NMPR_TX",
	29: "WRING_TYPE_IPSEC_NMPR_RX",
	30: "WRING_TYPE_IPSEC_BIG_NMDR_TX",
	31: "WRING_TYPE_IPSEC_BIG_NMDR_RX",
	32: "WRING_TYPE_IPSEC_BIG_NMPR_TX",
	33: "WRING_TYPE_IPSEC_BIG_NMPR_RX",
	34: "WRING_TYPE_NMDPR_SMALL_TX",
	35: "WRING_TYPE_NMDPR_SMALL_RX",
	36: "WRING_TYPE_NMDPR_BIG_TX",
	37: "WRING_TYPE_NMDPR_BIG_RX",
}
var WRingType_value = map[string]int32{
	"WRING_TYPE_NONE":              0,
	"WRING_TYPE_SERQ":              1,
	"WRING_TYPE_NMDR_TX":           2,
	"WRING_TYPE_NMDR_RX":           3,
	"WRING_TYPE_NMPR_SMALL_TX":     4,
	"WRING_TYPE_NMPR_SMALL_RX":     5,
	"WRING_TYPE_NMPR_BIG_TX":       6,
	"WRING_TYPE_NMPR_BIG_RX":       7,
	"WRING_TYPE_BSQ":               8,
	"WRING_TYPE_BRQ":               9,
	"WRING_TYPE_SESQ":              10,
	"WRING_TYPE_IPSECCBQ":          11,
	"WRING_TYPE_ARQRX":             12,
	"WRING_TYPE_ASQ":               13,
	"WRING_TYPE_ASESQ":             14,
	"WRING_TYPE_RAWRCB":            15,
	"WRING_TYPE_IPSECCBQ_BARCO":    16,
	"WRING_TYPE_APP_REDIR_RAWC":    17,
	"WRING_TYPE_APP_REDIR_PROXYR":  18,
	"WRING_TYPE_APP_REDIR_PROXYC":  19,
	"WRING_TYPE_NMDR_RX_GC":        20,
	"WRING_TYPE_NMDR_TX_GC":        21,
	"WRING_TYPE_ARQTX":             22,
	"WRING_TYPE_ASCQ":              23,
	"WRING_TYPE_CPUDR":             24,
	"WRING_TYPE_CPUPR":             25,
	"WRING_TYPE_IPSEC_NMDR_TX":     26,
	"WRING_TYPE_IPSEC_NMDR_RX":     27,
	"WRING_TYPE_IPSEC_NMPR_TX":     28,
	"WRING_TYPE_IPSEC_NMPR_RX":     29,
	"WRING_TYPE_IPSEC_BIG_NMDR_TX": 30,
	"WRING_TYPE_IPSEC_BIG_NMDR_RX": 31,
	"WRING_TYPE_IPSEC_BIG_NMPR_TX": 32,
	"WRING_TYPE_IPSEC_BIG_NMPR_RX": 33,
	"WRING_TYPE_NMDPR_SMALL_TX":    34,
	"WRING_TYPE_NMDPR_SMALL_RX":    35,
	"WRING_TYPE_NMDPR_BIG_TX":      36,
	"WRING_TYPE_NMDPR_BIG_RX":      37,
}

func (x WRingType) String() string {
	return proto.EnumName(WRingType_name, int32(x))
}
func (WRingType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// Types of Proxy Service
type ProxyType int32

const (
	ProxyType_PROXY_TYPE_NONE                     ProxyType = 0
	ProxyType_PROXY_TYPE_TCP                      ProxyType = 1
	ProxyType_PROXY_TYPE_TLS                      ProxyType = 2
	ProxyType_PROXY_TYPE_IPSEC                    ProxyType = 3
	ProxyType_PROXY_TYPE_GC                       ProxyType = 4
	ProxyType_PROXY_TYPE_CPU                      ProxyType = 5
	ProxyType_PROXY_TYPE_IPFIX                    ProxyType = 6
	ProxyType_PROXY_TYPE_APP_REDIR                ProxyType = 7
	ProxyType_PROXY_TYPE_P4PT                     ProxyType = 8
	ProxyType_PROXY_TYPE_APP_REDIR_PROXY_TCP      ProxyType = 9
	ProxyType_PROXY_TYPE_APP_REDIR_SPAN           ProxyType = 10
	ProxyType_PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN ProxyType = 11
)

var ProxyType_name = map[int32]string{
	0:  "PROXY_TYPE_NONE",
	1:  "PROXY_TYPE_TCP",
	2:  "PROXY_TYPE_TLS",
	3:  "PROXY_TYPE_IPSEC",
	4:  "PROXY_TYPE_GC",
	5:  "PROXY_TYPE_CPU",
	6:  "PROXY_TYPE_IPFIX",
	7:  "PROXY_TYPE_APP_REDIR",
	8:  "PROXY_TYPE_P4PT",
	9:  "PROXY_TYPE_APP_REDIR_PROXY_TCP",
	10: "PROXY_TYPE_APP_REDIR_SPAN",
	11: "PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN",
}
var ProxyType_value = map[string]int32{
	"PROXY_TYPE_NONE":                     0,
	"PROXY_TYPE_TCP":                      1,
	"PROXY_TYPE_TLS":                      2,
	"PROXY_TYPE_IPSEC":                    3,
	"PROXY_TYPE_GC":                       4,
	"PROXY_TYPE_CPU":                      5,
	"PROXY_TYPE_IPFIX":                    6,
	"PROXY_TYPE_APP_REDIR":                7,
	"PROXY_TYPE_P4PT":                     8,
	"PROXY_TYPE_APP_REDIR_PROXY_TCP":      9,
	"PROXY_TYPE_APP_REDIR_SPAN":           10,
	"PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN": 11,
}

func (x ProxyType) String() string {
	return proto.EnumName(ProxyType_name, int32(x))
}
func (ProxyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// Types of Cryptographic Asymmetric keys
type CryptoAsymKeyType int32

const (
	CryptoAsymKeyType_CRYPTO_ASYM_KEY_TYPE_ECDSA CryptoAsymKeyType = 0
	CryptoAsymKeyType_CRYPTO_ASYM_KEY_TYPE_RSA   CryptoAsymKeyType = 1
)

var CryptoAsymKeyType_name = map[int32]string{
	0: "CRYPTO_ASYM_KEY_TYPE_ECDSA",
	1: "CRYPTO_ASYM_KEY_TYPE_RSA",
}
var CryptoAsymKeyType_value = map[string]int32{
	"CRYPTO_ASYM_KEY_TYPE_ECDSA": 0,
	"CRYPTO_ASYM_KEY_TYPE_RSA":   1,
}

func (x CryptoAsymKeyType) String() string {
	return proto.EnumName(CryptoAsymKeyType_name, int32(x))
}
func (CryptoAsymKeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Types of Cryptographic keys
type CryptoKeyType int32

const (
	CryptoKeyType_CRYPTO_KEY_TYPE_AES128   CryptoKeyType = 0
	CryptoKeyType_CRYPTO_KEY_TYPE_AES192   CryptoKeyType = 1
	CryptoKeyType_CRYPTO_KEY_TYPE_AES256   CryptoKeyType = 2
	CryptoKeyType_CRYPTO_KEY_TYPE_DES      CryptoKeyType = 3
	CryptoKeyType_CRYPTO_KEY_TYPE_CHACHA20 CryptoKeyType = 4
	CryptoKeyType_CRYPTO_KEY_TYPE_POLY1305 CryptoKeyType = 5
	CryptoKeyType_CRYPTO_KEY_TYPE_HMAC     CryptoKeyType = 6
)

var CryptoKeyType_name = map[int32]string{
	0: "CRYPTO_KEY_TYPE_AES128",
	1: "CRYPTO_KEY_TYPE_AES192",
	2: "CRYPTO_KEY_TYPE_AES256",
	3: "CRYPTO_KEY_TYPE_DES",
	4: "CRYPTO_KEY_TYPE_CHACHA20",
	5: "CRYPTO_KEY_TYPE_POLY1305",
	6: "CRYPTO_KEY_TYPE_HMAC",
}
var CryptoKeyType_value = map[string]int32{
	"CRYPTO_KEY_TYPE_AES128":   0,
	"CRYPTO_KEY_TYPE_AES192":   1,
	"CRYPTO_KEY_TYPE_AES256":   2,
	"CRYPTO_KEY_TYPE_DES":      3,
	"CRYPTO_KEY_TYPE_CHACHA20": 4,
	"CRYPTO_KEY_TYPE_POLY1305": 5,
	"CRYPTO_KEY_TYPE_HMAC":     6,
}

func (x CryptoKeyType) String() string {
	return proto.EnumName(CryptoKeyType_name, int32(x))
}
func (CryptoKeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// Types of Barco Rings
type BarcoRings int32

const (
	BarcoRings_BARCO_RING_ASYM   BarcoRings = 0
	BarcoRings_BARCO_RING_GCM0   BarcoRings = 1
	BarcoRings_BARCO_RING_GCM1   BarcoRings = 2
	BarcoRings_BARCO_RING_XTS0   BarcoRings = 3
	BarcoRings_BARCO_RING_XTS1   BarcoRings = 4
	BarcoRings_BARCO_RING_MPP0   BarcoRings = 5
	BarcoRings_BARCO_RING_MPP1   BarcoRings = 6
	BarcoRings_BARCO_RING_MPP2   BarcoRings = 7
	BarcoRings_BARCO_RING_MPP3   BarcoRings = 8
	BarcoRings_BARCO_RING_MPP4   BarcoRings = 9
	BarcoRings_BARCO_RING_MPP5   BarcoRings = 10
	BarcoRings_BARCO_RING_MPP6   BarcoRings = 11
	BarcoRings_BARCO_RING_MPP7   BarcoRings = 12
	BarcoRings_BARCO_RING_CP     BarcoRings = 13
	BarcoRings_BARCO_RING_CP_HOT BarcoRings = 14
	BarcoRings_BARCO_RING_DC     BarcoRings = 15
	BarcoRings_BARCO_RING_DC_HOT BarcoRings = 16
)

var BarcoRings_name = map[int32]string{
	0:  "BARCO_RING_ASYM",
	1:  "BARCO_RING_GCM0",
	2:  "BARCO_RING_GCM1",
	3:  "BARCO_RING_XTS0",
	4:  "BARCO_RING_XTS1",
	5:  "BARCO_RING_MPP0",
	6:  "BARCO_RING_MPP1",
	7:  "BARCO_RING_MPP2",
	8:  "BARCO_RING_MPP3",
	9:  "BARCO_RING_MPP4",
	10: "BARCO_RING_MPP5",
	11: "BARCO_RING_MPP6",
	12: "BARCO_RING_MPP7",
	13: "BARCO_RING_CP",
	14: "BARCO_RING_CP_HOT",
	15: "BARCO_RING_DC",
	16: "BARCO_RING_DC_HOT",
}
var BarcoRings_value = map[string]int32{
	"BARCO_RING_ASYM":   0,
	"BARCO_RING_GCM0":   1,
	"BARCO_RING_GCM1":   2,
	"BARCO_RING_XTS0":   3,
	"BARCO_RING_XTS1":   4,
	"BARCO_RING_MPP0":   5,
	"BARCO_RING_MPP1":   6,
	"BARCO_RING_MPP2":   7,
	"BARCO_RING_MPP3":   8,
	"BARCO_RING_MPP4":   9,
	"BARCO_RING_MPP5":   10,
	"BARCO_RING_MPP6":   11,
	"BARCO_RING_MPP7":   12,
	"BARCO_RING_CP":     13,
	"BARCO_RING_CP_HOT": 14,
	"BARCO_RING_DC":     15,
	"BARCO_RING_DC_HOT": 16,
}

func (x BarcoRings) String() string {
	return proto.EnumName(BarcoRings_name, int32(x))
}
func (BarcoRings) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type AppRedirType int32

const (
	AppRedirType_APP_REDIR_TYPE_NONE     AppRedirType = 0
	AppRedirType_APP_REDIR_TYPE_REDIRECT AppRedirType = 1
	AppRedirType_APP_REDIR_TYPE_SPAN     AppRedirType = 2
)

var AppRedirType_name = map[int32]string{
	0: "APP_REDIR_TYPE_NONE",
	1: "APP_REDIR_TYPE_REDIRECT",
	2: "APP_REDIR_TYPE_SPAN",
}
var AppRedirType_value = map[string]int32{
	"APP_REDIR_TYPE_NONE":     0,
	"APP_REDIR_TYPE_REDIRECT": 1,
	"APP_REDIR_TYPE_SPAN":     2,
}

func (x AppRedirType) String() string {
	return proto.EnumName(AppRedirType_name, int32(x))
}
func (AppRedirType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// Types of CPU CB/QIDs
type CpucbId int32

const (
	CpucbId_CPUCB_ID_FLOWMISS      CpucbId = 0
	CpucbId_CPUCB_ID_TCP_CLOSE     CpucbId = 1
	CpucbId_CPUCB_ID_RELIABLE_COPY CpucbId = 2
	CpucbId_CPUCB_ID_NACL_REDIRECT CpucbId = 3
	CpucbId_CPUCB_ID_QUIESCE       CpucbId = 4
	CpucbId_CPUCB_ID_NACL_LOG      CpucbId = 5
	CpucbId_CPUCB_ID_FTE_SPAN      CpucbId = 6
)

var CpucbId_name = map[int32]string{
	0: "CPUCB_ID_FLOWMISS",
	1: "CPUCB_ID_TCP_CLOSE",
	2: "CPUCB_ID_RELIABLE_COPY",
	3: "CPUCB_ID_NACL_REDIRECT",
	4: "CPUCB_ID_QUIESCE",
	5: "CPUCB_ID_NACL_LOG",
	6: "CPUCB_ID_FTE_SPAN",
}
var CpucbId_value = map[string]int32{
	"CPUCB_ID_FLOWMISS":      0,
	"CPUCB_ID_TCP_CLOSE":     1,
	"CPUCB_ID_RELIABLE_COPY": 2,
	"CPUCB_ID_NACL_REDIRECT": 3,
	"CPUCB_ID_QUIESCE":       4,
	"CPUCB_ID_NACL_LOG":      5,
	"CPUCB_ID_FTE_SPAN":      6,
}

func (x CpucbId) String() string {
	return proto.EnumName(CpucbId_name, int32(x))
}
func (CpucbId) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// FTE Span Match Selectors
type FTESpanMatchSelector int32

const (
	FTESpanMatchSelector_SRC_LPORT       FTESpanMatchSelector = 0
	FTESpanMatchSelector_DST_LPORT       FTESpanMatchSelector = 1
	FTESpanMatchSelector_DROP_REASON     FTESpanMatchSelector = 2
	FTESpanMatchSelector_FLOW_LKUP_DIR   FTESpanMatchSelector = 3
	FTESpanMatchSelector_FLOW_LKUP_TYPE  FTESpanMatchSelector = 4
	FTESpanMatchSelector_FLOW_LKUP_VRF   FTESpanMatchSelector = 5
	FTESpanMatchSelector_FLOW_LKUP_SRC   FTESpanMatchSelector = 6
	FTESpanMatchSelector_FLOW_LKUP_DST   FTESpanMatchSelector = 7
	FTESpanMatchSelector_FLOW_LKUP_PROTO FTESpanMatchSelector = 8
	FTESpanMatchSelector_FLOW_LKUP_SPORT FTESpanMatchSelector = 9
	FTESpanMatchSelector_FLOW_LKUP_DPORT FTESpanMatchSelector = 10
	FTESpanMatchSelector_ETH_DMAC        FTESpanMatchSelector = 11
	FTESpanMatchSelector_FROM_CPU        FTESpanMatchSelector = 12
)

var FTESpanMatchSelector_name = map[int32]string{
	0:  "SRC_LPORT",
	1:  "DST_LPORT",
	2:  "DROP_REASON",
	3:  "FLOW_LKUP_DIR",
	4:  "FLOW_LKUP_TYPE",
	5:  "FLOW_LKUP_VRF",
	6:  "FLOW_LKUP_SRC",
	7:  "FLOW_LKUP_DST",
	8:  "FLOW_LKUP_PROTO",
	9:  "FLOW_LKUP_SPORT",
	10: "FLOW_LKUP_DPORT",
	11: "ETH_DMAC",
	12: "FROM_CPU",
}
var FTESpanMatchSelector_value = map[string]int32{
	"SRC_LPORT":       0,
	"DST_LPORT":       1,
	"DROP_REASON":     2,
	"FLOW_LKUP_DIR":   3,
	"FLOW_LKUP_TYPE":  4,
	"FLOW_LKUP_VRF":   5,
	"FLOW_LKUP_SRC":   6,
	"FLOW_LKUP_DST":   7,
	"FLOW_LKUP_PROTO": 8,
	"FLOW_LKUP_SPORT": 9,
	"FLOW_LKUP_DPORT": 10,
	"ETH_DMAC":        11,
	"FROM_CPU":        12,
}

func (x FTESpanMatchSelector) String() string {
	return proto.EnumName(FTESpanMatchSelector_name, int32(x))
}
func (FTESpanMatchSelector) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// Filter Type
type FilterType int32

const (
	FilterType_FILTER_NONE         FilterType = 0
	FilterType_FILTER_LIF          FilterType = 1
	FilterType_FILTER_LIF_MAC      FilterType = 2
	FilterType_FILTER_LIF_VLAN     FilterType = 3
	FilterType_FILTER_LIF_MAC_VLAN FilterType = 4
)

var FilterType_name = map[int32]string{
	0: "FILTER_NONE",
	1: "FILTER_LIF",
	2: "FILTER_LIF_MAC",
	3: "FILTER_LIF_VLAN",
	4: "FILTER_LIF_MAC_VLAN",
}
var FilterType_value = map[string]int32{
	"FILTER_NONE":         0,
	"FILTER_LIF":          1,
	"FILTER_LIF_MAC":      2,
	"FILTER_LIF_VLAN":     3,
	"FILTER_LIF_MAC_VLAN": 4,
}

func (x FilterType) String() string {
	return proto.EnumName(FilterType_name, int32(x))
}
func (FilterType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

//  IntfStatus status reflects the current status of Interface
type IntfStatus int32

const (
	IntfStatus_IF_STATUS_NONE IntfStatus = 0
	IntfStatus_IF_STATUS_UP   IntfStatus = 1
	IntfStatus_IF_STATUS_DOWN IntfStatus = 2
)

var IntfStatus_name = map[int32]string{
	0: "IF_STATUS_NONE",
	1: "IF_STATUS_UP",
	2: "IF_STATUS_DOWN",
}
var IntfStatus_value = map[string]int32{
	"IF_STATUS_NONE": 0,
	"IF_STATUS_UP":   1,
	"IF_STATUS_DOWN": 2,
}

func (x IntfStatus) String() string {
	return proto.EnumName(IntfStatus_name, int32(x))
}
func (IntfStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// Different purposes of LIF queues. This is not the same as
// Queue type (type_num field in LifQStateMapEntry). This is
// application (e.g. TCP, RDMA, Storage) specific and is specified
// on a per LIF per Queue Type bases. In other words, for one LIF
// type 0 can be TX Queue and for another LIF type 0 can be RX Queue.
type LifQueuePurpose int32

const (
	LifQueuePurpose_LIF_QUEUE_PURPOSE_NONE      LifQueuePurpose = 0
	LifQueuePurpose_LIF_QUEUE_PURPOSE_ADMIN     LifQueuePurpose = 1
	LifQueuePurpose_LIF_QUEUE_PURPOSE_TX        LifQueuePurpose = 2
	LifQueuePurpose_LIF_QUEUE_PURPOSE_RX        LifQueuePurpose = 3
	LifQueuePurpose_LIF_QUEUE_PURPOSE_RDMA_SEND LifQueuePurpose = 4
	LifQueuePurpose_LIF_QUEUE_PURPOSE_RDMA_RECV LifQueuePurpose = 5
	LifQueuePurpose_LIF_QUEUE_PURPOSE_CQ        LifQueuePurpose = 6
	LifQueuePurpose_LIF_QUEUE_PURPOSE_EQ        LifQueuePurpose = 7
	LifQueuePurpose_LIF_QUEUE_PURPOSE_NVME      LifQueuePurpose = 8
	LifQueuePurpose_LIF_QUEUE_PURPOSE_STORAGE   LifQueuePurpose = 9
	LifQueuePurpose_LIF_QUEUE_PURPOSE_VIRTIO_TX LifQueuePurpose = 10
	LifQueuePurpose_LIF_QUEUE_PURPOSE_VIRTIO_RX LifQueuePurpose = 11
)

var LifQueuePurpose_name = map[int32]string{
	0:  "LIF_QUEUE_PURPOSE_NONE",
	1:  "LIF_QUEUE_PURPOSE_ADMIN",
	2:  "LIF_QUEUE_PURPOSE_TX",
	3:  "LIF_QUEUE_PURPOSE_RX",
	4:  "LIF_QUEUE_PURPOSE_RDMA_SEND",
	5:  "LIF_QUEUE_PURPOSE_RDMA_RECV",
	6:  "LIF_QUEUE_PURPOSE_CQ",
	7:  "LIF_QUEUE_PURPOSE_EQ",
	8:  "LIF_QUEUE_PURPOSE_NVME",
	9:  "LIF_QUEUE_PURPOSE_STORAGE",
	10: "LIF_QUEUE_PURPOSE_VIRTIO_TX",
	11: "LIF_QUEUE_PURPOSE_VIRTIO_RX",
}
var LifQueuePurpose_value = map[string]int32{
	"LIF_QUEUE_PURPOSE_NONE":      0,
	"LIF_QUEUE_PURPOSE_ADMIN":     1,
	"LIF_QUEUE_PURPOSE_TX":        2,
	"LIF_QUEUE_PURPOSE_RX":        3,
	"LIF_QUEUE_PURPOSE_RDMA_SEND": 4,
	"LIF_QUEUE_PURPOSE_RDMA_RECV": 5,
	"LIF_QUEUE_PURPOSE_CQ":        6,
	"LIF_QUEUE_PURPOSE_EQ":        7,
	"LIF_QUEUE_PURPOSE_NVME":      8,
	"LIF_QUEUE_PURPOSE_STORAGE":   9,
	"LIF_QUEUE_PURPOSE_VIRTIO_TX": 10,
	"LIF_QUEUE_PURPOSE_VIRTIO_RX": 11,
}

func (x LifQueuePurpose) String() string {
	return proto.EnumName(LifQueuePurpose_name, int32(x))
}
func (LifQueuePurpose) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

// types of interfaces
type IntfType int32

const (
	IntfType_IF_TYPE_NONE      IntfType = 0
	IntfType_IF_TYPE_ENIC      IntfType = 1
	IntfType_IF_TYPE_UPLINK    IntfType = 2
	IntfType_IF_TYPE_UPLINK_PC IntfType = 3
	IntfType_IF_TYPE_TUNNEL    IntfType = 4
	IntfType_IF_TYPE_CPU       IntfType = 5
	IntfType_IF_TYPE_APP_REDIR IntfType = 6
)

var IntfType_name = map[int32]string{
	0: "IF_TYPE_NONE",
	1: "IF_TYPE_ENIC",
	2: "IF_TYPE_UPLINK",
	3: "IF_TYPE_UPLINK_PC",
	4: "IF_TYPE_TUNNEL",
	5: "IF_TYPE_CPU",
	6: "IF_TYPE_APP_REDIR",
}
var IntfType_value = map[string]int32{
	"IF_TYPE_NONE":      0,
	"IF_TYPE_ENIC":      1,
	"IF_TYPE_UPLINK":    2,
	"IF_TYPE_UPLINK_PC": 3,
	"IF_TYPE_TUNNEL":    4,
	"IF_TYPE_CPU":       5,
	"IF_TYPE_APP_REDIR": 6,
}

func (x IntfType) String() string {
	return proto.EnumName(IntfType_name, int32(x))
}
func (IntfType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

// ------------------------------------------------------------------------------
// if interface type is IF_TYPE_ENIC, one of the following vnic types must be
// set. IF_ENIC_TYPE_XXX identifies how a workload is attached to asic
// ------------------------------------------------------------------------------
type IntfEnicType int32

const (
	IntfEnicType_IF_ENIC_TYPE_NONE   IntfEnicType = 0
	IntfEnicType_IF_ENIC_TYPE_USEG   IntfEnicType = 1
	IntfEnicType_IF_ENIC_TYPE_PVLAN  IntfEnicType = 2
	IntfEnicType_IF_ENIC_TYPE_DIRECT IntfEnicType = 3
	// VSS/DVS connectivity etc.
	IntfEnicType_IF_ENIC_TYPE_CLASSIC IntfEnicType = 4
	IntfEnicType_IF_ENIC_TYPE_GFT     IntfEnicType = 5
)

var IntfEnicType_name = map[int32]string{
	0: "IF_ENIC_TYPE_NONE",
	1: "IF_ENIC_TYPE_USEG",
	2: "IF_ENIC_TYPE_PVLAN",
	3: "IF_ENIC_TYPE_DIRECT",
	4: "IF_ENIC_TYPE_CLASSIC",
	5: "IF_ENIC_TYPE_GFT",
}
var IntfEnicType_value = map[string]int32{
	"IF_ENIC_TYPE_NONE":    0,
	"IF_ENIC_TYPE_USEG":    1,
	"IF_ENIC_TYPE_PVLAN":   2,
	"IF_ENIC_TYPE_DIRECT":  3,
	"IF_ENIC_TYPE_CLASSIC": 4,
	"IF_ENIC_TYPE_GFT":     5,
}

func (x IntfEnicType) String() string {
	return proto.EnumName(IntfEnicType_name, int32(x))
}
func (IntfEnicType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

// ------------------------------------------------------------------------------
// if interface type is IF_TYPE_TUNNEL, one of the following encap types must be
// set.
// ------------------------------------------------------------------------------
type IntfTunnelEncapType int32

const (
	IntfTunnelEncapType_IF_TUNNEL_ENCAP_TYPE_NONE  IntfTunnelEncapType = 0
	IntfTunnelEncapType_IF_TUNNEL_ENCAP_TYPE_VXLAN IntfTunnelEncapType = 1
	IntfTunnelEncapType_IF_TUNNEL_ENCAP_TYPE_GRE   IntfTunnelEncapType = 2
)

var IntfTunnelEncapType_name = map[int32]string{
	0: "IF_TUNNEL_ENCAP_TYPE_NONE",
	1: "IF_TUNNEL_ENCAP_TYPE_VXLAN",
	2: "IF_TUNNEL_ENCAP_TYPE_GRE",
}
var IntfTunnelEncapType_value = map[string]int32{
	"IF_TUNNEL_ENCAP_TYPE_NONE":  0,
	"IF_TUNNEL_ENCAP_TYPE_VXLAN": 1,
	"IF_TUNNEL_ENCAP_TYPE_GRE":   2,
}

func (x IntfTunnelEncapType) String() string {
	return proto.EnumName(IntfTunnelEncapType_name, int32(x))
}
func (IntfTunnelEncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

// common meta object that is part of all other top level objects
// TODO: should we add last updated timestamp, revision etc. here ?
type ObjectMeta_ struct {
	VrfId uint64 `protobuf:"fixed64,1,opt,name=vrf_id,json=vrfId" json:"vrf_id,omitempty"`
}

func (m *ObjectMeta_) Reset()                    { *m = ObjectMeta_{} }
func (m *ObjectMeta_) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta_) ProtoMessage()               {}
func (*ObjectMeta_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObjectMeta_) GetVrfId() uint64 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

// EncapInfo captures wire encap information
type EncapInfo_ struct {
	EncapType  EncapType `protobuf:"varint,1,opt,name=encap_type,json=encapType,enum=intf.EncapType" json:"encap_type,omitempty"`
	EncapValue uint32    `protobuf:"varint,2,opt,name=encap_value,json=encapValue" json:"encap_value,omitempty"`
}

func (m *EncapInfo_) Reset()                    { *m = EncapInfo_{} }
func (m *EncapInfo_) String() string            { return proto.CompactTextString(m) }
func (*EncapInfo_) ProtoMessage()               {}
func (*EncapInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EncapInfo_) GetEncapType() EncapType {
	if m != nil {
		return m.EncapType
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *EncapInfo_) GetEncapValue() uint32 {
	if m != nil {
		return m.EncapValue
	}
	return 0
}

// IP address object
type IPAddress_ struct {
	IpAf   IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,enum=intf.IPAddressFamily" json:"ip_af,omitempty"`
	V4Addr uint32          `protobuf:"fixed32,2,opt,name=v4_addr,json=v4Addr" json:"v4_addr,omitempty"`
	V6Addr []byte          `protobuf:"bytes,3,opt,name=v6_addr,json=v6Addr,proto3" json:"v6_addr,omitempty"`
}

func (m *IPAddress_) Reset()                    { *m = IPAddress_{} }
func (m *IPAddress_) String() string            { return proto.CompactTextString(m) }
func (*IPAddress_) ProtoMessage()               {}
func (*IPAddress_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *IPAddress_) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPAddress_) GetV4Addr() uint32 {
	if m != nil {
		return m.V4Addr
	}
	return 0
}

func (m *IPAddress_) GetV6Addr() []byte {
	if m != nil {
		return m.V6Addr
	}
	return nil
}

// IP Range
type IPRange_ struct {
	LowIpaddr  *IPAddress_ `protobuf:"bytes,1,opt,name=low_ipaddr,json=lowIpaddr" json:"low_ipaddr,omitempty"`
	HighIpaddr *IPAddress_ `protobuf:"bytes,2,opt,name=high_ipaddr,json=highIpaddr" json:"high_ipaddr,omitempty"`
}

func (m *IPRange_) Reset()                    { *m = IPRange_{} }
func (m *IPRange_) String() string            { return proto.CompactTextString(m) }
func (*IPRange_) ProtoMessage()               {}
func (*IPRange_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IPRange_) GetLowIpaddr() *IPAddress_ {
	if m != nil {
		return m.LowIpaddr
	}
	return nil
}

func (m *IPRange_) GetHighIpaddr() *IPAddress_ {
	if m != nil {
		return m.HighIpaddr
	}
	return nil
}

// IP Prefix object
type IPPrefix_ struct {
	Address   *IPAddress_ `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	PrefixLen uint32      `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen" json:"prefix_len,omitempty"`
}

func (m *IPPrefix_) Reset()                    { *m = IPPrefix_{} }
func (m *IPPrefix_) String() string            { return proto.CompactTextString(m) }
func (*IPPrefix_) ProtoMessage()               {}
func (*IPPrefix_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *IPPrefix_) GetAddress() *IPAddress_ {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPPrefix_) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// IPSubnet represents an IPv4 or IPv6 subnet
type IPSubnet_ struct {
	Ipv4Subnet *IPPrefix_ `protobuf:"bytes,1,opt,name=ipv4_subnet,json=ipv4Subnet" json:"ipv4_subnet,omitempty"`
	Ipv6Subnet *IPPrefix_ `protobuf:"bytes,2,opt,name=ipv6_subnet,json=ipv6Subnet" json:"ipv6_subnet,omitempty"`
}

func (m *IPSubnet_) Reset()                    { *m = IPSubnet_{} }
func (m *IPSubnet_) String() string            { return proto.CompactTextString(m) }
func (*IPSubnet_) ProtoMessage()               {}
func (*IPSubnet_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *IPSubnet_) GetIpv4Subnet() *IPPrefix_ {
	if m != nil {
		return m.Ipv4Subnet
	}
	return nil
}

func (m *IPSubnet_) GetIpv6Subnet() *IPPrefix_ {
	if m != nil {
		return m.Ipv6Subnet
	}
	return nil
}

// AddressRange represents an IPv4 or IPv6 address range
type AddressRange_ struct {
	Ipv4Range *IPRange_ `protobuf:"bytes,1,opt,name=ipv4_range,json=ipv4Range" json:"ipv4_range,omitempty"`
	Ipv6Range *IPRange_ `protobuf:"bytes,2,opt,name=ipv6_range,json=ipv6Range" json:"ipv6_range,omitempty"`
}

func (m *AddressRange_) Reset()                    { *m = AddressRange_{} }
func (m *AddressRange_) String() string            { return proto.CompactTextString(m) }
func (*AddressRange_) ProtoMessage()               {}
func (*AddressRange_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *AddressRange_) GetIpv4Range() *IPRange_ {
	if m != nil {
		return m.Ipv4Range
	}
	return nil
}

func (m *AddressRange_) GetIpv6Range() *IPRange_ {
	if m != nil {
		return m.Ipv6Range
	}
	return nil
}

// Address object is the prefix or range
type Address_ struct {
	Prefix    *IPSubnet_     `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	AddrRange *AddressRange_ `protobuf:"bytes,2,opt,name=addr_range,json=addrRange" json:"addr_range,omitempty"`
}

func (m *Address_) Reset()                    { *m = Address_{} }
func (m *Address_) String() string            { return proto.CompactTextString(m) }
func (*Address_) ProtoMessage()               {}
func (*Address_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Address_) GetPrefix() *IPSubnet_ {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Address_) GetAddrRange() *AddressRange_ {
	if m != nil {
		return m.AddrRange
	}
	return nil
}

type IPAddressObj_ struct {
	Iptype  IPAddressType `protobuf:"varint,1,opt,name=iptype,enum=intf.IPAddressType" json:"iptype,omitempty"`
	Address *Address_     `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Negate  bool          `protobuf:"varint,3,opt,name=negate" json:"negate,omitempty"`
}

func (m *IPAddressObj_) Reset()                    { *m = IPAddressObj_{} }
func (m *IPAddressObj_) String() string            { return proto.CompactTextString(m) }
func (*IPAddressObj_) ProtoMessage()               {}
func (*IPAddressObj_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *IPAddressObj_) GetIptype() IPAddressType {
	if m != nil {
		return m.Iptype
	}
	return IPAddressType_IP_ADDRESS_NONE
}

func (m *IPAddressObj_) GetAddress() *Address_ {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPAddressObj_) GetNegate() bool {
	if m != nil {
		return m.Negate
	}
	return false
}

// PortRange object has low and high end of the port ranges
type L4PortRange_ struct {
	PortLow  uint32 `protobuf:"varint,1,opt,name=port_low,json=portLow" json:"port_low,omitempty"`
	PortHigh uint32 `protobuf:"varint,2,opt,name=port_high,json=portHigh" json:"port_high,omitempty"`
}

func (m *L4PortRange_) Reset()                    { *m = L4PortRange_{} }
func (m *L4PortRange_) String() string            { return proto.CompactTextString(m) }
func (*L4PortRange_) ProtoMessage()               {}
func (*L4PortRange_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *L4PortRange_) GetPortLow() uint32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *L4PortRange_) GetPortHigh() uint32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

type Empty_ struct {
}

func (m *Empty_) Reset()                    { *m = Empty_{} }
func (m *Empty_) String() string            { return proto.CompactTextString(m) }
func (*Empty_) ProtoMessage()               {}
func (*Empty_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type DropReasons_ struct {
	DropMalformedPkt                bool `protobuf:"varint,1,opt,name=drop_malformed_pkt,json=dropMalformedPkt" json:"drop_malformed_pkt,omitempty"`
	DropInputMapping                bool `protobuf:"varint,2,opt,name=drop_input_mapping,json=dropInputMapping" json:"drop_input_mapping,omitempty"`
	DropInputMappingDejavu          bool `protobuf:"varint,3,opt,name=drop_input_mapping_dejavu,json=dropInputMappingDejavu" json:"drop_input_mapping_dejavu,omitempty"`
	DropFlowHit                     bool `protobuf:"varint,4,opt,name=drop_flow_hit,json=dropFlowHit" json:"drop_flow_hit,omitempty"`
	DropFlowMiss                    bool `protobuf:"varint,5,opt,name=drop_flow_miss,json=dropFlowMiss" json:"drop_flow_miss,omitempty"`
	DropNacl                        bool `protobuf:"varint,6,opt,name=drop_nacl,json=dropNacl" json:"drop_nacl,omitempty"`
	DropIpsg                        bool `protobuf:"varint,7,opt,name=drop_ipsg,json=dropIpsg" json:"drop_ipsg,omitempty"`
	DropIpNormalization             bool `protobuf:"varint,8,opt,name=drop_ip_normalization,json=dropIpNormalization" json:"drop_ip_normalization,omitempty"`
	DropTcpNormalization            bool `protobuf:"varint,9,opt,name=drop_tcp_normalization,json=dropTcpNormalization" json:"drop_tcp_normalization,omitempty"`
	DropTcpRstWithInvalidAckNum     bool `protobuf:"varint,10,opt,name=drop_tcp_rst_with_invalid_ack_num,json=dropTcpRstWithInvalidAckNum" json:"drop_tcp_rst_with_invalid_ack_num,omitempty"`
	DropTcpNonSynFirstPkt           bool `protobuf:"varint,11,opt,name=drop_tcp_non_syn_first_pkt,json=dropTcpNonSynFirstPkt" json:"drop_tcp_non_syn_first_pkt,omitempty"`
	DropIcmpNormalization           bool `protobuf:"varint,12,opt,name=drop_icmp_normalization,json=dropIcmpNormalization" json:"drop_icmp_normalization,omitempty"`
	DropInputPropertiesMiss         bool `protobuf:"varint,13,opt,name=drop_input_properties_miss,json=dropInputPropertiesMiss" json:"drop_input_properties_miss,omitempty"`
	DropTcpOutOfWindow              bool `protobuf:"varint,14,opt,name=drop_tcp_out_of_window,json=dropTcpOutOfWindow" json:"drop_tcp_out_of_window,omitempty"`
	DropTcpSplitHandshake           bool `protobuf:"varint,15,opt,name=drop_tcp_split_handshake,json=dropTcpSplitHandshake" json:"drop_tcp_split_handshake,omitempty"`
	DropTcpWinZeroDrop              bool `protobuf:"varint,16,opt,name=drop_tcp_win_zero_drop,json=dropTcpWinZeroDrop" json:"drop_tcp_win_zero_drop,omitempty"`
	DropTcpDataAfterFin             bool `protobuf:"varint,17,opt,name=drop_tcp_data_after_fin,json=dropTcpDataAfterFin" json:"drop_tcp_data_after_fin,omitempty"`
	DropTcpNonRstPktAfterRst        bool `protobuf:"varint,18,opt,name=drop_tcp_non_rst_pkt_after_rst,json=dropTcpNonRstPktAfterRst" json:"drop_tcp_non_rst_pkt_after_rst,omitempty"`
	DropTcpInvalidResponderFirstPkt bool `protobuf:"varint,19,opt,name=drop_tcp_invalid_responder_first_pkt,json=dropTcpInvalidResponderFirstPkt" json:"drop_tcp_invalid_responder_first_pkt,omitempty"`
	DropTcpUnexpectedPkt            bool `protobuf:"varint,20,opt,name=drop_tcp_unexpected_pkt,json=dropTcpUnexpectedPkt" json:"drop_tcp_unexpected_pkt,omitempty"`
	DropSrcLifMismatch              bool `protobuf:"varint,21,opt,name=drop_src_lif_mismatch,json=dropSrcLifMismatch" json:"drop_src_lif_mismatch,omitempty"`
	DropParserIcrcError             bool `protobuf:"varint,22,opt,name=drop_parser_icrc_error,json=dropParserIcrcError" json:"drop_parser_icrc_error,omitempty"`
	DropParseLenError               bool `protobuf:"varint,23,opt,name=drop_parse_len_error,json=dropParseLenError" json:"drop_parse_len_error,omitempty"`
	DropHardwareError               bool `protobuf:"varint,24,opt,name=drop_hardware_error,json=dropHardwareError" json:"drop_hardware_error,omitempty"`
}

func (m *DropReasons_) Reset()                    { *m = DropReasons_{} }
func (m *DropReasons_) String() string            { return proto.CompactTextString(m) }
func (*DropReasons_) ProtoMessage()               {}
func (*DropReasons_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DropReasons_) GetDropMalformedPkt() bool {
	if m != nil {
		return m.DropMalformedPkt
	}
	return false
}

func (m *DropReasons_) GetDropInputMapping() bool {
	if m != nil {
		return m.DropInputMapping
	}
	return false
}

func (m *DropReasons_) GetDropInputMappingDejavu() bool {
	if m != nil {
		return m.DropInputMappingDejavu
	}
	return false
}

func (m *DropReasons_) GetDropFlowHit() bool {
	if m != nil {
		return m.DropFlowHit
	}
	return false
}

func (m *DropReasons_) GetDropFlowMiss() bool {
	if m != nil {
		return m.DropFlowMiss
	}
	return false
}

func (m *DropReasons_) GetDropNacl() bool {
	if m != nil {
		return m.DropNacl
	}
	return false
}

func (m *DropReasons_) GetDropIpsg() bool {
	if m != nil {
		return m.DropIpsg
	}
	return false
}

func (m *DropReasons_) GetDropIpNormalization() bool {
	if m != nil {
		return m.DropIpNormalization
	}
	return false
}

func (m *DropReasons_) GetDropTcpNormalization() bool {
	if m != nil {
		return m.DropTcpNormalization
	}
	return false
}

func (m *DropReasons_) GetDropTcpRstWithInvalidAckNum() bool {
	if m != nil {
		return m.DropTcpRstWithInvalidAckNum
	}
	return false
}

func (m *DropReasons_) GetDropTcpNonSynFirstPkt() bool {
	if m != nil {
		return m.DropTcpNonSynFirstPkt
	}
	return false
}

func (m *DropReasons_) GetDropIcmpNormalization() bool {
	if m != nil {
		return m.DropIcmpNormalization
	}
	return false
}

func (m *DropReasons_) GetDropInputPropertiesMiss() bool {
	if m != nil {
		return m.DropInputPropertiesMiss
	}
	return false
}

func (m *DropReasons_) GetDropTcpOutOfWindow() bool {
	if m != nil {
		return m.DropTcpOutOfWindow
	}
	return false
}

func (m *DropReasons_) GetDropTcpSplitHandshake() bool {
	if m != nil {
		return m.DropTcpSplitHandshake
	}
	return false
}

func (m *DropReasons_) GetDropTcpWinZeroDrop() bool {
	if m != nil {
		return m.DropTcpWinZeroDrop
	}
	return false
}

func (m *DropReasons_) GetDropTcpDataAfterFin() bool {
	if m != nil {
		return m.DropTcpDataAfterFin
	}
	return false
}

func (m *DropReasons_) GetDropTcpNonRstPktAfterRst() bool {
	if m != nil {
		return m.DropTcpNonRstPktAfterRst
	}
	return false
}

func (m *DropReasons_) GetDropTcpInvalidResponderFirstPkt() bool {
	if m != nil {
		return m.DropTcpInvalidResponderFirstPkt
	}
	return false
}

func (m *DropReasons_) GetDropTcpUnexpectedPkt() bool {
	if m != nil {
		return m.DropTcpUnexpectedPkt
	}
	return false
}

func (m *DropReasons_) GetDropSrcLifMismatch() bool {
	if m != nil {
		return m.DropSrcLifMismatch
	}
	return false
}

func (m *DropReasons_) GetDropParserIcrcError() bool {
	if m != nil {
		return m.DropParserIcrcError
	}
	return false
}

func (m *DropReasons_) GetDropParseLenError() bool {
	if m != nil {
		return m.DropParseLenError
	}
	return false
}

func (m *DropReasons_) GetDropHardwareError() bool {
	if m != nil {
		return m.DropHardwareError
	}
	return false
}

type EgressDropReasons_ struct {
	DropOutputMapping bool `protobuf:"varint,1,opt,name=drop_output_mapping,json=dropOutputMapping" json:"drop_output_mapping,omitempty"`
	DropPruneSrcPort  bool `protobuf:"varint,2,opt,name=drop_prune_src_port,json=dropPruneSrcPort" json:"drop_prune_src_port,omitempty"`
	DropMirror        bool `protobuf:"varint,3,opt,name=drop_mirror,json=dropMirror" json:"drop_mirror,omitempty"`
	DropPolicer       bool `protobuf:"varint,4,opt,name=drop_policer,json=dropPolicer" json:"drop_policer,omitempty"`
	DropCopp          bool `protobuf:"varint,5,opt,name=drop_copp,json=dropCopp" json:"drop_copp,omitempty"`
	DropChecksumErr   bool `protobuf:"varint,6,opt,name=drop_checksum_err,json=dropChecksumErr" json:"drop_checksum_err,omitempty"`
}

func (m *EgressDropReasons_) Reset()                    { *m = EgressDropReasons_{} }
func (m *EgressDropReasons_) String() string            { return proto.CompactTextString(m) }
func (*EgressDropReasons_) ProtoMessage()               {}
func (*EgressDropReasons_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *EgressDropReasons_) GetDropOutputMapping() bool {
	if m != nil {
		return m.DropOutputMapping
	}
	return false
}

func (m *EgressDropReasons_) GetDropPruneSrcPort() bool {
	if m != nil {
		return m.DropPruneSrcPort
	}
	return false
}

func (m *EgressDropReasons_) GetDropMirror() bool {
	if m != nil {
		return m.DropMirror
	}
	return false
}

func (m *EgressDropReasons_) GetDropPolicer() bool {
	if m != nil {
		return m.DropPolicer
	}
	return false
}

func (m *EgressDropReasons_) GetDropCopp() bool {
	if m != nil {
		return m.DropCopp
	}
	return false
}

func (m *EgressDropReasons_) GetDropChecksumErr() bool {
	if m != nil {
		return m.DropChecksumErr
	}
	return false
}

// VrfKeyHandle is used to operate on a vrf either by its key or handle
type VrfKeyHandle_ struct {
	VrfId     uint64 `protobuf:"varint,1,opt,name=vrf_id,json=vrfId" json:"vrf_id,omitempty"`
	VrfHandle uint64 `protobuf:"fixed64,2,opt,name=vrf_handle,json=vrfHandle" json:"vrf_handle,omitempty"`
}

func (m *VrfKeyHandle_) Reset()                    { *m = VrfKeyHandle_{} }
func (m *VrfKeyHandle_) String() string            { return proto.CompactTextString(m) }
func (*VrfKeyHandle_) ProtoMessage()               {}
func (*VrfKeyHandle_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *VrfKeyHandle_) GetVrfId() uint64 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

func (m *VrfKeyHandle_) GetVrfHandle() uint64 {
	if m != nil {
		return m.VrfHandle
	}
	return 0
}

// L2SegmentKeyHandle is used to operate on a L2 segment either by its
// segment id or HAL allocated handle
type L2SegmentKeyHandle_ struct {
	SegmentId uint64 `protobuf:"varint,1,opt,name=segment_id,json=segmentId" json:"segment_id,omitempty"`
	// NOTE:
	// 1. this is unique across all types of L2 segments
	// 2. this is allocated by the HAL app
	L2SegmentHandle uint64 `protobuf:"fixed64,2,opt,name=l2segment_handle,json=l2segmentHandle" json:"l2segment_handle,omitempty"`
}

func (m *L2SegmentKeyHandle_) Reset()                    { *m = L2SegmentKeyHandle_{} }
func (m *L2SegmentKeyHandle_) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentKeyHandle_) ProtoMessage()               {}
func (*L2SegmentKeyHandle_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *L2SegmentKeyHandle_) GetSegmentId() uint64 {
	if m != nil {
		return m.SegmentId
	}
	return 0
}

func (m *L2SegmentKeyHandle_) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

// PortKeyHandle uniquely identifies a Port
type PortKeyHandle_ struct {
	PortId     uint32 `protobuf:"fixed32,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	PortHandle uint64 `protobuf:"fixed64,2,opt,name=port_handle,json=portHandle" json:"port_handle,omitempty"`
}

func (m *PortKeyHandle_) Reset()                    { *m = PortKeyHandle_{} }
func (m *PortKeyHandle_) String() string            { return proto.CompactTextString(m) }
func (*PortKeyHandle_) ProtoMessage()               {}
func (*PortKeyHandle_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PortKeyHandle_) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *PortKeyHandle_) GetPortHandle() uint64 {
	if m != nil {
		return m.PortHandle
	}
	return 0
}

// LifKeyHandle uniquely identifies a LIF
type LifKeyHandle_ struct {
	LifId     uint64 `protobuf:"fixed64,1,opt,name=LifId" json:"LifId,omitempty"`
	LifHandle uint64 `protobuf:"fixed64,2,opt,name=LifHandle" json:"LifHandle,omitempty"`
}

func (m *LifKeyHandle_) Reset()                    { *m = LifKeyHandle_{} }
func (m *LifKeyHandle_) String() string            { return proto.CompactTextString(m) }
func (*LifKeyHandle_) ProtoMessage()               {}
func (*LifKeyHandle_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *LifKeyHandle_) GetLifId() uint64 {
	if m != nil {
		return m.LifId
	}
	return 0
}

func (m *LifKeyHandle_) GetLifHandle() uint64 {
	if m != nil {
		return m.LifHandle
	}
	return 0
}

// InterfaceKeyHandle uniquely identifies a Interface
type InterfaceKeyHandle_ struct {
	InterfaceId uint64 `protobuf:"fixed64,1,opt,name=InterfaceId" json:"InterfaceId,omitempty"`
	IfHandle    uint64 `protobuf:"fixed64,2,opt,name=IfHandle" json:"IfHandle,omitempty"`
}

func (m *InterfaceKeyHandle_) Reset()                    { *m = InterfaceKeyHandle_{} }
func (m *InterfaceKeyHandle_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceKeyHandle_) ProtoMessage()               {}
func (*InterfaceKeyHandle_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *InterfaceKeyHandle_) GetInterfaceId() uint64 {
	if m != nil {
		return m.InterfaceId
	}
	return 0
}

func (m *InterfaceKeyHandle_) GetIfHandle() uint64 {
	if m != nil {
		return m.IfHandle
	}
	return 0
}

// Filter key
type FilterKey_ struct {
	LifKeyOrHandle *LifKeyHandle_ `protobuf:"bytes,1,opt,name=lif_key_or_handle,json=lifKeyOrHandle" json:"lif_key_or_handle,omitempty"`
	FilterType     FilterType     `protobuf:"varint,2,opt,name=filter_type,json=filterType,enum=intf.FilterType" json:"filter_type,omitempty"`
	MacAddress     uint64         `protobuf:"varint,3,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	VlanId         uint32         `protobuf:"varint,4,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
}

func (m *FilterKey_) Reset()                    { *m = FilterKey_{} }
func (m *FilterKey_) String() string            { return proto.CompactTextString(m) }
func (*FilterKey_) ProtoMessage()               {}
func (*FilterKey_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *FilterKey_) GetLifKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.LifKeyOrHandle
	}
	return nil
}

func (m *FilterKey_) GetFilterType() FilterType {
	if m != nil {
		return m.FilterType
	}
	return FilterType_FILTER_NONE
}

func (m *FilterKey_) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *FilterKey_) GetVlanId() uint32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

// A single entry in the LIF to Qstate map.
// This entry represents a single type.
// Everything except type puspose is used by the hardware.
type LifQStateMapEntry_ struct {
	// type_num is the type as defined by Capri hardware in the
	// LIF -> Qstate array entry. There are 8 types numbered 0-7.
	// There can be at most one entry per type_num.
	// TODO: How does a user know what number to use here unless
	// it is enumerated or purpose is clear ???
	TypeNum uint32 `protobuf:"varint,1,opt,name=type_num,json=typeNum" json:"type_num,omitempty"`
	// This entry represents the size of the Q state
	// used by this type. This number represents the size
	// as 2^(5+size). e.g. for a size of 64, the size field
	// would be 1 i.e. 2^(5+1) = 64.
	// Max value for size today is 7 i.e. 4096 bytes.
	Size uint32 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// entries field represent number of queues as a
	// power of 2. So a value of 3 means 8 queues.
	// Max value for entries today is 24 i.e. 16M queues.
	Entries uint32 `protobuf:"varint,3,opt,name=entries" json:"entries,omitempty"`
	// Queue purpose is not needed by the hardware. It is used
	// internally by the HAL/FTE.
	Purpose LifQueuePurpose `protobuf:"varint,4,opt,name=purpose,enum=intf.LifQueuePurpose" json:"purpose,omitempty"`
}

func (m *LifQStateMapEntry_) Reset()                    { *m = LifQStateMapEntry_{} }
func (m *LifQStateMapEntry_) String() string            { return proto.CompactTextString(m) }
func (*LifQStateMapEntry_) ProtoMessage()               {}
func (*LifQStateMapEntry_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LifQStateMapEntry_) GetTypeNum() uint32 {
	if m != nil {
		return m.TypeNum
	}
	return 0
}

func (m *LifQStateMapEntry_) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *LifQStateMapEntry_) GetEntries() uint32 {
	if m != nil {
		return m.Entries
	}
	return 0
}

func (m *LifQStateMapEntry_) GetPurpose() LifQueuePurpose {
	if m != nil {
		return m.Purpose
	}
	return LifQueuePurpose_LIF_QUEUE_PURPOSE_NONE
}

// Packet filters to receive traffic
type PktFilter_ struct {
	ReceiveBroadcast    bool `protobuf:"varint,1,opt,name=receive_broadcast,json=receiveBroadcast" json:"receive_broadcast,omitempty"`
	ReceiveAllMulticast bool `protobuf:"varint,2,opt,name=receive_all_multicast,json=receiveAllMulticast" json:"receive_all_multicast,omitempty"`
	ReceivePromiscuous  bool `protobuf:"varint,3,opt,name=receive_promiscuous,json=receivePromiscuous" json:"receive_promiscuous,omitempty"`
}

func (m *PktFilter_) Reset()                    { *m = PktFilter_{} }
func (m *PktFilter_) String() string            { return proto.CompactTextString(m) }
func (*PktFilter_) ProtoMessage()               {}
func (*PktFilter_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PktFilter_) GetReceiveBroadcast() bool {
	if m != nil {
		return m.ReceiveBroadcast
	}
	return false
}

func (m *PktFilter_) GetReceiveAllMulticast() bool {
	if m != nil {
		return m.ReceiveAllMulticast
	}
	return false
}

func (m *PktFilter_) GetReceivePromiscuous() bool {
	if m != nil {
		return m.ReceivePromiscuous
	}
	return false
}

// LIF object
type LifSpec_ struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	// key_or_handle is LIF's key or handle
	KeyOrHandle             *LifKeyHandle_       `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	PinnedUplinkIfKeyHandle *InterfaceKeyHandle_ `protobuf:"bytes,3,opt,name=pinned_uplink_if_key_handle,json=pinnedUplinkIfKeyHandle" json:"pinned_uplink_if_key_handle,omitempty"`
	AdminStatus             IntfStatus           `protobuf:"varint,4,opt,name=admin_status,json=adminStatus,enum=intf.IntfStatus" json:"admin_status,omitempty"`
	LifQstateMap            *LifQStateMapEntry_  `protobuf:"bytes,5,opt,name=lif_qstate_map,json=lifQstateMap" json:"lif_qstate_map,omitempty"`
	VlanStripEn             bool                 `protobuf:"varint,6,opt,name=vlan_strip_en,json=vlanStripEn" json:"vlan_strip_en,omitempty"`
	VlanInsertEn            bool                 `protobuf:"varint,7,opt,name=vlan_insert_en,json=vlanInsertEn" json:"vlan_insert_en,omitempty"`
	EnableRdma              bool                 `protobuf:"varint,8,opt,name=enable_rdma,json=enableRdma" json:"enable_rdma,omitempty"`
	IsManagement            bool                 `protobuf:"varint,9,opt,name=is_management,json=isManagement" json:"is_management,omitempty"`
	PacketFilter            *PktFilter_          `protobuf:"bytes,10,opt,name=packet_filter,json=packetFilter" json:"packet_filter,omitempty"`
	HwLifId                 uint32               `protobuf:"varint,11,opt,name=hw_lif_id,json=hwLifId" json:"hw_lif_id,omitempty"`
	RdmaMaxKeys             uint32               `protobuf:"varint,12,opt,name=rdma_max_keys,json=rdmaMaxKeys" json:"rdma_max_keys,omitempty"`
	RdmaMaxAhs              uint32               `protobuf:"varint,13,opt,name=rdma_max_ahs,json=rdmaMaxAhs" json:"rdma_max_ahs,omitempty"`
	RdmaMaxPtEntries        uint32               `protobuf:"varint,14,opt,name=rdma_max_pt_entries,json=rdmaMaxPtEntries" json:"rdma_max_pt_entries,omitempty"`
	LifQstate               *QStateSetReq_       `protobuf:"bytes,15,opt,name=lif_qstate,json=lifQstate" json:"lif_qstate,omitempty"`
	Rss                     *LifRssSpec_         `protobuf:"bytes,16,opt,name=rss" json:"rss,omitempty"`
}

func (m *LifSpec_) Reset()                    { *m = LifSpec_{} }
func (m *LifSpec_) String() string            { return proto.CompactTextString(m) }
func (*LifSpec_) ProtoMessage()               {}
func (*LifSpec_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *LifSpec_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *LifSpec_) GetKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *LifSpec_) GetPinnedUplinkIfKeyHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.PinnedUplinkIfKeyHandle
	}
	return nil
}

func (m *LifSpec_) GetAdminStatus() IntfStatus {
	if m != nil {
		return m.AdminStatus
	}
	return IntfStatus_IF_STATUS_NONE
}

func (m *LifSpec_) GetLifQstateMap() *LifQStateMapEntry_ {
	if m != nil {
		return m.LifQstateMap
	}
	return nil
}

func (m *LifSpec_) GetVlanStripEn() bool {
	if m != nil {
		return m.VlanStripEn
	}
	return false
}

func (m *LifSpec_) GetVlanInsertEn() bool {
	if m != nil {
		return m.VlanInsertEn
	}
	return false
}

func (m *LifSpec_) GetEnableRdma() bool {
	if m != nil {
		return m.EnableRdma
	}
	return false
}

func (m *LifSpec_) GetIsManagement() bool {
	if m != nil {
		return m.IsManagement
	}
	return false
}

func (m *LifSpec_) GetPacketFilter() *PktFilter_ {
	if m != nil {
		return m.PacketFilter
	}
	return nil
}

func (m *LifSpec_) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *LifSpec_) GetRdmaMaxKeys() uint32 {
	if m != nil {
		return m.RdmaMaxKeys
	}
	return 0
}

func (m *LifSpec_) GetRdmaMaxAhs() uint32 {
	if m != nil {
		return m.RdmaMaxAhs
	}
	return 0
}

func (m *LifSpec_) GetRdmaMaxPtEntries() uint32 {
	if m != nil {
		return m.RdmaMaxPtEntries
	}
	return 0
}

func (m *LifSpec_) GetLifQstate() *QStateSetReq_ {
	if m != nil {
		return m.LifQstate
	}
	return nil
}

func (m *LifSpec_) GetRss() *LifRssSpec_ {
	if m != nil {
		return m.Rss
	}
	return nil
}

// LifRequestMsg is batched request used to create/update of LIFs
type LifRequestMsg_ struct {
	Request *LifSpec_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *LifRequestMsg_) Reset()                    { *m = LifRequestMsg_{} }
func (m *LifRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*LifRequestMsg_) ProtoMessage()               {}
func (*LifRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *LifRequestMsg_) GetRequest() *LifSpec_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// LifStatus represents the operational status of LIF
type LifStatus_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle *LifKeyHandle_     `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	LifStatus   IntfStatus         `protobuf:"varint,3,opt,name=lif_status,json=lifStatus,enum=intf.IntfStatus" json:"lif_status,omitempty"`
	LifHandle   uint64             `protobuf:"fixed64,4,opt,name=lif_handle,json=lifHandle" json:"lif_handle,omitempty"`
	HwLifId     uint64             `protobuf:"varint,5,opt,name=hw_lif_id,json=hwLifId" json:"hw_lif_id,omitempty"`
}

func (m *LifStatus_) Reset()                    { *m = LifStatus_{} }
func (m *LifStatus_) String() string            { return proto.CompactTextString(m) }
func (*LifStatus_) ProtoMessage()               {}
func (*LifStatus_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *LifStatus_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *LifStatus_) GetKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *LifStatus_) GetLifStatus() IntfStatus {
	if m != nil {
		return m.LifStatus
	}
	return IntfStatus_IF_STATUS_NONE
}

func (m *LifStatus_) GetLifHandle() uint64 {
	if m != nil {
		return m.LifHandle
	}
	return 0
}

func (m *LifStatus_) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

// LifQstate entries
type LifQState_ struct {
	TypeNum uint32 `protobuf:"varint,1,opt,name=type_num,json=typeNum" json:"type_num,omitempty"`
	Addr    uint64 `protobuf:"varint,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *LifQState_) Reset()                    { *m = LifQState_{} }
func (m *LifQState_) String() string            { return proto.CompactTextString(m) }
func (*LifQState_) ProtoMessage()               {}
func (*LifQState_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *LifQState_) GetTypeNum() uint32 {
	if m != nil {
		return m.TypeNum
	}
	return 0
}

func (m *LifQState_) GetAddr() uint64 {
	if m != nil {
		return m.Addr
	}
	return 0
}

// LifRdmaData entries
type LifRdmaData_ struct {
	PtBaseAddr uint64 `protobuf:"varint,1,opt,name=pt_base_addr,json=ptBaseAddr" json:"pt_base_addr,omitempty"`
	KtBaseAddr uint64 `protobuf:"varint,2,opt,name=kt_base_addr,json=ktBaseAddr" json:"kt_base_addr,omitempty"`
	AtBaseAddr uint64 `protobuf:"varint,3,opt,name=at_base_addr,json=atBaseAddr" json:"at_base_addr,omitempty"`
}

func (m *LifRdmaData_) Reset()                    { *m = LifRdmaData_{} }
func (m *LifRdmaData_) String() string            { return proto.CompactTextString(m) }
func (*LifRdmaData_) ProtoMessage()               {}
func (*LifRdmaData_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *LifRdmaData_) GetPtBaseAddr() uint64 {
	if m != nil {
		return m.PtBaseAddr
	}
	return 0
}

func (m *LifRdmaData_) GetKtBaseAddr() uint64 {
	if m != nil {
		return m.KtBaseAddr
	}
	return 0
}

func (m *LifRdmaData_) GetAtBaseAddr() uint64 {
	if m != nil {
		return m.AtBaseAddr
	}
	return 0
}

// LifResponse response to one LifSpec
type LifResponse_ struct {
	ApiStatus     ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
	Status        *LifStatus_   `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Qstate        *LifQState_   `protobuf:"bytes,3,opt,name=qstate" json:"qstate,omitempty"`
	RdmaDataValid bool          `protobuf:"varint,4,opt,name=rdma_data_valid,json=rdmaDataValid" json:"rdma_data_valid,omitempty"`
	RdmaData      *LifRdmaData_ `protobuf:"bytes,5,opt,name=rdma_data,json=rdmaData" json:"rdma_data,omitempty"`
}

func (m *LifResponse_) Reset()                    { *m = LifResponse_{} }
func (m *LifResponse_) String() string            { return proto.CompactTextString(m) }
func (*LifResponse_) ProtoMessage()               {}
func (*LifResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *LifResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LifResponse_) GetStatus() *LifStatus_ {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *LifResponse_) GetQstate() *LifQState_ {
	if m != nil {
		return m.Qstate
	}
	return nil
}

func (m *LifResponse_) GetRdmaDataValid() bool {
	if m != nil {
		return m.RdmaDataValid
	}
	return false
}

func (m *LifResponse_) GetRdmaData() *LifRdmaData_ {
	if m != nil {
		return m.RdmaData
	}
	return nil
}

// LifResponseMsg is response to LifRequestMsg
type LifResponseMsg_ struct {
	Response *LifResponse_ `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
}

func (m *LifResponseMsg_) Reset()                    { *m = LifResponseMsg_{} }
func (m *LifResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*LifResponseMsg_) ProtoMessage()               {}
func (*LifResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *LifResponseMsg_) GetResponse() *LifResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

type QStateGetReq_ struct {
	LifHandle uint64 `protobuf:"varint,1,opt,name=lif_handle,json=lifHandle" json:"lif_handle,omitempty"`
	TypeNum   uint32 `protobuf:"varint,2,opt,name=type_num,json=typeNum" json:"type_num,omitempty"`
	Qid       uint32 `protobuf:"varint,3,opt,name=qid" json:"qid,omitempty"`
	// Amount of data to return in the corresponding
	// QStateGetResp::queue_state buffer. By default
	// All the data is returned (based on the size of this
	// queue type_num). But can be limited by the caller.
	// Setting this value to be greater than the actual
	// size has no effect.
	RetDataSize uint32 `protobuf:"varint,4,opt,name=ret_data_size,json=retDataSize" json:"ret_data_size,omitempty"`
}

func (m *QStateGetReq_) Reset()                    { *m = QStateGetReq_{} }
func (m *QStateGetReq_) String() string            { return proto.CompactTextString(m) }
func (*QStateGetReq_) ProtoMessage()               {}
func (*QStateGetReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *QStateGetReq_) GetLifHandle() uint64 {
	if m != nil {
		return m.LifHandle
	}
	return 0
}

func (m *QStateGetReq_) GetTypeNum() uint32 {
	if m != nil {
		return m.TypeNum
	}
	return 0
}

func (m *QStateGetReq_) GetQid() uint32 {
	if m != nil {
		return m.Qid
	}
	return 0
}

func (m *QStateGetReq_) GetRetDataSize() uint32 {
	if m != nil {
		return m.RetDataSize
	}
	return 0
}

type QStateGetResp_ struct {
	// TODO: what is user to make out of this error_code if it is non-zero ??
	//       why this is not using  ApiStatus ???
	ErrorCode  int32  `protobuf:"varint,1,opt,name=error_code,json=errorCode" json:"error_code,omitempty"`
	QAddr      uint64 `protobuf:"varint,2,opt,name=q_addr,json=qAddr" json:"q_addr,omitempty"`
	QueueState []byte `protobuf:"bytes,3,opt,name=queue_state,json=queueState,proto3" json:"queue_state,omitempty"`
}

func (m *QStateGetResp_) Reset()                    { *m = QStateGetResp_{} }
func (m *QStateGetResp_) String() string            { return proto.CompactTextString(m) }
func (*QStateGetResp_) ProtoMessage()               {}
func (*QStateGetResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *QStateGetResp_) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *QStateGetResp_) GetQAddr() uint64 {
	if m != nil {
		return m.QAddr
	}
	return 0
}

func (m *QStateGetResp_) GetQueueState() []byte {
	if m != nil {
		return m.QueueState
	}
	return nil
}

type GetQStateResponseMsg_ struct {
	Resps *QStateGetResp_ `protobuf:"bytes,1,opt,name=resps" json:"resps,omitempty"`
}

func (m *GetQStateResponseMsg_) Reset()                    { *m = GetQStateResponseMsg_{} }
func (m *GetQStateResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*GetQStateResponseMsg_) ProtoMessage()               {}
func (*GetQStateResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *GetQStateResponseMsg_) GetResps() *QStateGetResp_ {
	if m != nil {
		return m.Resps
	}
	return nil
}

// A P4ProgLabel is used to get the PC offset for
// Queue state.
type P4ProgLabel_ struct {
	Handle   string `protobuf:"bytes,1,opt,name=handle" json:"handle,omitempty"`
	ProgName string `protobuf:"bytes,2,opt,name=prog_name,json=progName" json:"prog_name,omitempty"`
	Label    string `protobuf:"bytes,3,opt,name=label" json:"label,omitempty"`
}

func (m *P4ProgLabel_) Reset()                    { *m = P4ProgLabel_{} }
func (m *P4ProgLabel_) String() string            { return proto.CompactTextString(m) }
func (*P4ProgLabel_) ProtoMessage()               {}
func (*P4ProgLabel_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *P4ProgLabel_) GetHandle() string {
	if m != nil {
		return m.Handle
	}
	return ""
}

func (m *P4ProgLabel_) GetProgName() string {
	if m != nil {
		return m.ProgName
	}
	return ""
}

func (m *P4ProgLabel_) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type QStateSetReq_ struct {
	LifHandle uint64 `protobuf:"varint,1,opt,name=lif_handle,json=lifHandle" json:"lif_handle,omitempty"`
	TypeNum   uint32 `protobuf:"varint,2,opt,name=type_num,json=typeNum" json:"type_num,omitempty"`
	Qid       uint32 `protobuf:"varint,3,opt,name=qid" json:"qid,omitempty"`
	// If present, PC Offset is filled by the implementation
	// based on the label.
	Label *P4ProgLabel_ `protobuf:"bytes,4,opt,name=label" json:"label,omitempty"`
	// Actual queue state to be written. Can be less than the
	// actual qstate size. But has to be greater than 0.
	QueueState []byte `protobuf:"bytes,5,opt,name=queue_state,json=queueState,proto3" json:"queue_state,omitempty"`
}

func (m *QStateSetReq_) Reset()                    { *m = QStateSetReq_{} }
func (m *QStateSetReq_) String() string            { return proto.CompactTextString(m) }
func (*QStateSetReq_) ProtoMessage()               {}
func (*QStateSetReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *QStateSetReq_) GetLifHandle() uint64 {
	if m != nil {
		return m.LifHandle
	}
	return 0
}

func (m *QStateSetReq_) GetTypeNum() uint32 {
	if m != nil {
		return m.TypeNum
	}
	return 0
}

func (m *QStateSetReq_) GetQid() uint32 {
	if m != nil {
		return m.Qid
	}
	return 0
}

func (m *QStateSetReq_) GetLabel() *P4ProgLabel_ {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *QStateSetReq_) GetQueueState() []byte {
	if m != nil {
		return m.QueueState
	}
	return nil
}

type SetQStateRequestMsg_ struct {
	Reqs *QStateSetReq_ `protobuf:"bytes,1,opt,name=reqs" json:"reqs,omitempty"`
}

func (m *SetQStateRequestMsg_) Reset()                    { *m = SetQStateRequestMsg_{} }
func (m *SetQStateRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*SetQStateRequestMsg_) ProtoMessage()               {}
func (*SetQStateRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *SetQStateRequestMsg_) GetReqs() *QStateSetReq_ {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type QStateSetResp_ struct {
	// TODO: what is user to make out of this error_code if it is non-zero ??
	//       why this is not using  ApiStatus ??
	ErrorCode int32 `protobuf:"varint,1,opt,name=error_code,json=errorCode" json:"error_code,omitempty"`
}

func (m *QStateSetResp_) Reset()                    { *m = QStateSetResp_{} }
func (m *QStateSetResp_) String() string            { return proto.CompactTextString(m) }
func (*QStateSetResp_) ProtoMessage()               {}
func (*QStateSetResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *QStateSetResp_) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type SetQStateResponseMsg_ struct {
	Resps *QStateSetResp_ `protobuf:"bytes,1,opt,name=resps" json:"resps,omitempty"`
}

func (m *SetQStateResponseMsg_) Reset()                    { *m = SetQStateResponseMsg_{} }
func (m *SetQStateResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*SetQStateResponseMsg_) ProtoMessage()               {}
func (*SetQStateResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *SetQStateResponseMsg_) GetResps() *QStateSetResp_ {
	if m != nil {
		return m.Resps
	}
	return nil
}

// LifDeleteRequest  is used to delete a LIF object
type LifDeleteRequest_ struct {
	// key_or_handle is LIF's unique identifier for deletion
	KeyOrHandle *LifKeyHandle_ `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *LifDeleteRequest_) Reset()                    { *m = LifDeleteRequest_{} }
func (m *LifDeleteRequest_) String() string            { return proto.CompactTextString(m) }
func (*LifDeleteRequest_) ProtoMessage()               {}
func (*LifDeleteRequest_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *LifDeleteRequest_) GetKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// LifDeleteRequestMsg is used to delete a batch of LIFs
type LifDeleteRequestMsg_ struct {
	Request *LifDeleteRequest_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *LifDeleteRequestMsg_) Reset()                    { *m = LifDeleteRequestMsg_{} }
func (m *LifDeleteRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*LifDeleteRequestMsg_) ProtoMessage()               {}
func (*LifDeleteRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *LifDeleteRequestMsg_) GetRequest() *LifDeleteRequest_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// LifDeleteResponse is response to LIF delete request
type LifDeleteResponse_ struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
}

func (m *LifDeleteResponse_) Reset()                    { *m = LifDeleteResponse_{} }
func (m *LifDeleteResponse_) String() string            { return proto.CompactTextString(m) }
func (*LifDeleteResponse_) ProtoMessage()               {}
func (*LifDeleteResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *LifDeleteResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// LifDeleteResponseMsg is batched response to LifDeleteRequestMsg
type LifDeleteResponseMsg_ struct {
	Response *LifDeleteResponse_ `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
}

func (m *LifDeleteResponseMsg_) Reset()                    { *m = LifDeleteResponseMsg_{} }
func (m *LifDeleteResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*LifDeleteResponseMsg_) ProtoMessage()               {}
func (*LifDeleteResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *LifDeleteResponseMsg_) GetResponse() *LifDeleteResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

// check which stats will be done by p4 and which will be done by p4+
type LifTxStats_ struct {
	FramesOk          uint64 `protobuf:"varint,1,opt,name=frames_ok,json=framesOk" json:"frames_ok,omitempty"`
	UnicastFramesOk   uint64 `protobuf:"varint,2,opt,name=unicast_frames_ok,json=unicastFramesOk" json:"unicast_frames_ok,omitempty"`
	MulticastBramesOk uint64 `protobuf:"varint,3,opt,name=multicast_brames_ok,json=multicastBramesOk" json:"multicast_brames_ok,omitempty"`
	BroadcastBramesOk uint64 `protobuf:"varint,4,opt,name=broadcast_brames_ok,json=broadcastBramesOk" json:"broadcast_brames_ok,omitempty"`
	BytesOk           uint64 `protobuf:"varint,5,opt,name=bytes_ok,json=bytesOk" json:"bytes_ok,omitempty"`
	UnicastBytesOk    uint64 `protobuf:"varint,6,opt,name=unicast_bytes_ok,json=unicastBytesOk" json:"unicast_bytes_ok,omitempty"`
	MulticastBytesOk  uint64 `protobuf:"varint,7,opt,name=multicast_bytes_ok,json=multicastBytesOk" json:"multicast_bytes_ok,omitempty"`
	BroadcastBytesOk  uint64 `protobuf:"varint,8,opt,name=broadcast_bytes_ok,json=broadcastBytesOk" json:"broadcast_bytes_ok,omitempty"`
	Tso               uint64 `protobuf:"varint,9,opt,name=tso" json:"tso,omitempty"`
}

func (m *LifTxStats_) Reset()                    { *m = LifTxStats_{} }
func (m *LifTxStats_) String() string            { return proto.CompactTextString(m) }
func (*LifTxStats_) ProtoMessage()               {}
func (*LifTxStats_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *LifTxStats_) GetFramesOk() uint64 {
	if m != nil {
		return m.FramesOk
	}
	return 0
}

func (m *LifTxStats_) GetUnicastFramesOk() uint64 {
	if m != nil {
		return m.UnicastFramesOk
	}
	return 0
}

func (m *LifTxStats_) GetMulticastBramesOk() uint64 {
	if m != nil {
		return m.MulticastBramesOk
	}
	return 0
}

func (m *LifTxStats_) GetBroadcastBramesOk() uint64 {
	if m != nil {
		return m.BroadcastBramesOk
	}
	return 0
}

func (m *LifTxStats_) GetBytesOk() uint64 {
	if m != nil {
		return m.BytesOk
	}
	return 0
}

func (m *LifTxStats_) GetUnicastBytesOk() uint64 {
	if m != nil {
		return m.UnicastBytesOk
	}
	return 0
}

func (m *LifTxStats_) GetMulticastBytesOk() uint64 {
	if m != nil {
		return m.MulticastBytesOk
	}
	return 0
}

func (m *LifTxStats_) GetBroadcastBytesOk() uint64 {
	if m != nil {
		return m.BroadcastBytesOk
	}
	return 0
}

func (m *LifTxStats_) GetTso() uint64 {
	if m != nil {
		return m.Tso
	}
	return 0
}

type LifRxStats_ struct {
	FramesTotal       uint64 `protobuf:"varint,1,opt,name=frames_total,json=framesTotal" json:"frames_total,omitempty"`
	FramesOk          uint64 `protobuf:"varint,2,opt,name=frames_ok,json=framesOk" json:"frames_ok,omitempty"`
	UnicastFramesOk   uint64 `protobuf:"varint,3,opt,name=unicast_frames_ok,json=unicastFramesOk" json:"unicast_frames_ok,omitempty"`
	MulticastFramesOk uint64 `protobuf:"varint,4,opt,name=multicast_frames_ok,json=multicastFramesOk" json:"multicast_frames_ok,omitempty"`
	BroadcastFramesOk uint64 `protobuf:"varint,5,opt,name=broadcast_frames_ok,json=broadcastFramesOk" json:"broadcast_frames_ok,omitempty"`
	BytesOk           uint64 `protobuf:"varint,6,opt,name=bytes_ok,json=bytesOk" json:"bytes_ok,omitempty"`
	UnicastBytesOk    uint64 `protobuf:"varint,7,opt,name=unicast_bytes_ok,json=unicastBytesOk" json:"unicast_bytes_ok,omitempty"`
	MulticastBytesOk  uint64 `protobuf:"varint,8,opt,name=multicast_bytes_ok,json=multicastBytesOk" json:"multicast_bytes_ok,omitempty"`
	BroadcastBytesOk  uint64 `protobuf:"varint,9,opt,name=broadcast_bytes_ok,json=broadcastBytesOk" json:"broadcast_bytes_ok,omitempty"`
	Drops             uint64 `protobuf:"varint,10,opt,name=drops" json:"drops,omitempty"`
	NoBufs            uint64 `protobuf:"varint,11,opt,name=no_bufs,json=noBufs" json:"no_bufs,omitempty"`
	Errors            uint64 `protobuf:"varint,12,opt,name=errors" json:"errors,omitempty"`
	Rss               uint64 `protobuf:"varint,13,opt,name=rss" json:"rss,omitempty"`
	CrcErrors         uint64 `protobuf:"varint,14,opt,name=crc_errors,json=crcErrors" json:"crc_errors,omitempty"`
	Frames_64         uint64 `protobuf:"varint,15,opt,name=frames_64,json=frames64" json:"frames_64,omitempty"`
	Frames_127        uint64 `protobuf:"varint,16,opt,name=frames_127,json=frames127" json:"frames_127,omitempty"`
	Frames_255        uint64 `protobuf:"varint,17,opt,name=frames_255,json=frames255" json:"frames_255,omitempty"`
	Frames_511        uint64 `protobuf:"varint,18,opt,name=frames_511,json=frames511" json:"frames_511,omitempty"`
	Frames_1024       uint64 `protobuf:"varint,19,opt,name=frames_1024,json=frames1024" json:"frames_1024,omitempty"`
	Frames_1518       uint64 `protobuf:"varint,20,opt,name=frames_1518,json=frames1518" json:"frames_1518,omitempty"`
	FramesToMax       uint64 `protobuf:"varint,21,opt,name=frames_to_max,json=framesToMax" json:"frames_to_max,omitempty"`
}

func (m *LifRxStats_) Reset()                    { *m = LifRxStats_{} }
func (m *LifRxStats_) String() string            { return proto.CompactTextString(m) }
func (*LifRxStats_) ProtoMessage()               {}
func (*LifRxStats_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *LifRxStats_) GetFramesTotal() uint64 {
	if m != nil {
		return m.FramesTotal
	}
	return 0
}

func (m *LifRxStats_) GetFramesOk() uint64 {
	if m != nil {
		return m.FramesOk
	}
	return 0
}

func (m *LifRxStats_) GetUnicastFramesOk() uint64 {
	if m != nil {
		return m.UnicastFramesOk
	}
	return 0
}

func (m *LifRxStats_) GetMulticastFramesOk() uint64 {
	if m != nil {
		return m.MulticastFramesOk
	}
	return 0
}

func (m *LifRxStats_) GetBroadcastFramesOk() uint64 {
	if m != nil {
		return m.BroadcastFramesOk
	}
	return 0
}

func (m *LifRxStats_) GetBytesOk() uint64 {
	if m != nil {
		return m.BytesOk
	}
	return 0
}

func (m *LifRxStats_) GetUnicastBytesOk() uint64 {
	if m != nil {
		return m.UnicastBytesOk
	}
	return 0
}

func (m *LifRxStats_) GetMulticastBytesOk() uint64 {
	if m != nil {
		return m.MulticastBytesOk
	}
	return 0
}

func (m *LifRxStats_) GetBroadcastBytesOk() uint64 {
	if m != nil {
		return m.BroadcastBytesOk
	}
	return 0
}

func (m *LifRxStats_) GetDrops() uint64 {
	if m != nil {
		return m.Drops
	}
	return 0
}

func (m *LifRxStats_) GetNoBufs() uint64 {
	if m != nil {
		return m.NoBufs
	}
	return 0
}

func (m *LifRxStats_) GetErrors() uint64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

func (m *LifRxStats_) GetRss() uint64 {
	if m != nil {
		return m.Rss
	}
	return 0
}

func (m *LifRxStats_) GetCrcErrors() uint64 {
	if m != nil {
		return m.CrcErrors
	}
	return 0
}

func (m *LifRxStats_) GetFrames_64() uint64 {
	if m != nil {
		return m.Frames_64
	}
	return 0
}

func (m *LifRxStats_) GetFrames_127() uint64 {
	if m != nil {
		return m.Frames_127
	}
	return 0
}

func (m *LifRxStats_) GetFrames_255() uint64 {
	if m != nil {
		return m.Frames_255
	}
	return 0
}

func (m *LifRxStats_) GetFrames_511() uint64 {
	if m != nil {
		return m.Frames_511
	}
	return 0
}

func (m *LifRxStats_) GetFrames_1024() uint64 {
	if m != nil {
		return m.Frames_1024
	}
	return 0
}

func (m *LifRxStats_) GetFrames_1518() uint64 {
	if m != nil {
		return m.Frames_1518
	}
	return 0
}

func (m *LifRxStats_) GetFramesToMax() uint64 {
	if m != nil {
		return m.FramesToMax
	}
	return 0
}

// LifRssConfig is used to set Lif's RSS configuration
type LifRssSpec_ struct {
	LifType uint32 `protobuf:"varint,1,opt,name=lif_type,json=lifType" json:"lif_type,omitempty"`
	Key     []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Indir   []byte `protobuf:"bytes,3,opt,name=indir,proto3" json:"indir,omitempty"`
}

func (m *LifRssSpec_) Reset()                    { *m = LifRssSpec_{} }
func (m *LifRssSpec_) String() string            { return proto.CompactTextString(m) }
func (*LifRssSpec_) ProtoMessage()               {}
func (*LifRssSpec_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *LifRssSpec_) GetLifType() uint32 {
	if m != nil {
		return m.LifType
	}
	return 0
}

func (m *LifRssSpec_) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LifRssSpec_) GetIndir() []byte {
	if m != nil {
		return m.Indir
	}
	return nil
}

type EnicInfo_ struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle_ `protobuf:"bytes,1,opt,name=l2segment_key_handle,json=l2segmentKeyHandle" json:"l2segment_key_handle,omitempty"`
	MacAddress         uint64               `protobuf:"fixed64,2,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	EncapVlanId        uint32               `protobuf:"varint,3,opt,name=encap_vlan_id,json=encapVlanId" json:"encap_vlan_id,omitempty"`
}

func (m *EnicInfo_) Reset()                    { *m = EnicInfo_{} }
func (m *EnicInfo_) String() string            { return proto.CompactTextString(m) }
func (*EnicInfo_) ProtoMessage()               {}
func (*EnicInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *EnicInfo_) GetL2SegmentKeyHandle() *L2SegmentKeyHandle_ {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

func (m *EnicInfo_) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *EnicInfo_) GetEncapVlanId() uint32 {
	if m != nil {
		return m.EncapVlanId
	}
	return 0
}

type EnicClassicInfo_ struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle_ `protobuf:"bytes,1,opt,name=l2segment_key_handle,json=l2segmentKeyHandle" json:"l2segment_key_handle,omitempty"`
	NativeL2SegmentId  uint64               `protobuf:"varint,2,opt,name=native_l2segment_id,json=nativeL2segmentId" json:"native_l2segment_id,omitempty"`
}

func (m *EnicClassicInfo_) Reset()                    { *m = EnicClassicInfo_{} }
func (m *EnicClassicInfo_) String() string            { return proto.CompactTextString(m) }
func (*EnicClassicInfo_) ProtoMessage()               {}
func (*EnicClassicInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *EnicClassicInfo_) GetL2SegmentKeyHandle() *L2SegmentKeyHandle_ {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

func (m *EnicClassicInfo_) GetNativeL2SegmentId() uint64 {
	if m != nil {
		return m.NativeL2SegmentId
	}
	return 0
}

// mandatory attributes expected if interface type is IF_TYPE_ENIC
type IfEnicInfo_ struct {
	EnicType                IntfEnicType         `protobuf:"varint,1,opt,name=enic_type,json=enicType,enum=intf.IntfEnicType" json:"enic_type,omitempty"`
	LifKeyOrHandle          *LifKeyHandle_       `protobuf:"bytes,2,opt,name=lif_key_or_handle,json=lifKeyOrHandle" json:"lif_key_or_handle,omitempty"`
	PinnedUplinkIfKeyHandle *InterfaceKeyHandle_ `protobuf:"bytes,3,opt,name=pinned_uplink_if_key_handle,json=pinnedUplinkIfKeyHandle" json:"pinned_uplink_if_key_handle,omitempty"`
	EnicInfo                *EnicInfo_           `protobuf:"bytes,4,opt,name=enic_info,json=enicInfo" json:"enic_info,omitempty"`
	ClassicEnicInfo         *EnicClassicInfo_    `protobuf:"bytes,5,opt,name=classic_enic_info,json=classicEnicInfo" json:"classic_enic_info,omitempty"`
}

func (m *IfEnicInfo_) Reset()                    { *m = IfEnicInfo_{} }
func (m *IfEnicInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfEnicInfo_) ProtoMessage()               {}
func (*IfEnicInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *IfEnicInfo_) GetEnicType() IntfEnicType {
	if m != nil {
		return m.EnicType
	}
	return IntfEnicType_IF_ENIC_TYPE_NONE
}

func (m *IfEnicInfo_) GetLifKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.LifKeyOrHandle
	}
	return nil
}

func (m *IfEnicInfo_) GetPinnedUplinkIfKeyHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.PinnedUplinkIfKeyHandle
	}
	return nil
}

func (m *IfEnicInfo_) GetEnicInfo() *EnicInfo_ {
	if m != nil {
		return m.EnicInfo
	}
	return nil
}

func (m *IfEnicInfo_) GetClassicEnicInfo() *EnicClassicInfo_ {
	if m != nil {
		return m.ClassicEnicInfo
	}
	return nil
}

// mandatory attributes expected if interface type is IF_TYPE_UPLINK
type IfUplinkInfo_ struct {
	PortNum           uint32 `protobuf:"varint,1,opt,name=port_num,json=portNum" json:"port_num,omitempty"`
	NativeL2SegmentId uint64 `protobuf:"varint,2,opt,name=native_l2segment_id,json=nativeL2segmentId" json:"native_l2segment_id,omitempty"`
	IsOobManagement   bool   `protobuf:"varint,3,opt,name=is_oob_management,json=isOobManagement" json:"is_oob_management,omitempty"`
}

func (m *IfUplinkInfo_) Reset()                    { *m = IfUplinkInfo_{} }
func (m *IfUplinkInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfUplinkInfo_) ProtoMessage()               {}
func (*IfUplinkInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *IfUplinkInfo_) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

func (m *IfUplinkInfo_) GetNativeL2SegmentId() uint64 {
	if m != nil {
		return m.NativeL2SegmentId
	}
	return 0
}

func (m *IfUplinkInfo_) GetIsOobManagement() bool {
	if m != nil {
		return m.IsOobManagement
	}
	return false
}

type IfUplinkPCInfo_ struct {
	// mandatory attributes expected if interface type is IF_TYPE_UPLINK_PC
	NativeL2SegmentId uint64               `protobuf:"varint,1,opt,name=native_l2segment_id,json=nativeL2segmentId" json:"native_l2segment_id,omitempty"`
	MemberIfKeyHandle *InterfaceKeyHandle_ `protobuf:"bytes,2,opt,name=member_if_key_handle,json=memberIfKeyHandle" json:"member_if_key_handle,omitempty"`
}

func (m *IfUplinkPCInfo_) Reset()                    { *m = IfUplinkPCInfo_{} }
func (m *IfUplinkPCInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfUplinkPCInfo_) ProtoMessage()               {}
func (*IfUplinkPCInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *IfUplinkPCInfo_) GetNativeL2SegmentId() uint64 {
	if m != nil {
		return m.NativeL2SegmentId
	}
	return 0
}

func (m *IfUplinkPCInfo_) GetMemberIfKeyHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.MemberIfKeyHandle
	}
	return nil
}

type IfTunnelVxlanInfo_ struct {
	LocalTep  *IPAddress_ `protobuf:"bytes,1,opt,name=local_tep,json=localTep" json:"local_tep,omitempty"`
	RemoteTep *IPAddress_ `protobuf:"bytes,2,opt,name=remote_tep,json=remoteTep" json:"remote_tep,omitempty"`
}

func (m *IfTunnelVxlanInfo_) Reset()                    { *m = IfTunnelVxlanInfo_{} }
func (m *IfTunnelVxlanInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfTunnelVxlanInfo_) ProtoMessage()               {}
func (*IfTunnelVxlanInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *IfTunnelVxlanInfo_) GetLocalTep() *IPAddress_ {
	if m != nil {
		return m.LocalTep
	}
	return nil
}

func (m *IfTunnelVxlanInfo_) GetRemoteTep() *IPAddress_ {
	if m != nil {
		return m.RemoteTep
	}
	return nil
}

type IfTunnelGREInfo_ struct {
	Source      *IPAddress_ `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Destination *IPAddress_ `protobuf:"bytes,2,opt,name=destination" json:"destination,omitempty"`
	Mtu         uint32      `protobuf:"varint,3,opt,name=mtu" json:"mtu,omitempty"`
	Ttl         uint32      `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *IfTunnelGREInfo_) Reset()                    { *m = IfTunnelGREInfo_{} }
func (m *IfTunnelGREInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfTunnelGREInfo_) ProtoMessage()               {}
func (*IfTunnelGREInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *IfTunnelGREInfo_) GetSource() *IPAddress_ {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *IfTunnelGREInfo_) GetDestination() *IPAddress_ {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *IfTunnelGREInfo_) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *IfTunnelGREInfo_) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type IfTunnelInfo_ struct {
	EncapType    IntfTunnelEncapType `protobuf:"varint,1,opt,name=encap_type,json=encapType,enum=intf.IntfTunnelEncapType" json:"encap_type,omitempty"`
	VxlanInfo    *IfTunnelVxlanInfo_ `protobuf:"bytes,2,opt,name=vxlan_info,json=vxlanInfo" json:"vxlan_info,omitempty"`
	GreInfo      *IfTunnelGREInfo_   `protobuf:"bytes,3,opt,name=gre_info,json=greInfo" json:"gre_info,omitempty"`
	VrfKeyHandle *VrfKeyHandle_      `protobuf:"bytes,4,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
}

func (m *IfTunnelInfo_) Reset()                    { *m = IfTunnelInfo_{} }
func (m *IfTunnelInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfTunnelInfo_) ProtoMessage()               {}
func (*IfTunnelInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *IfTunnelInfo_) GetEncapType() IntfTunnelEncapType {
	if m != nil {
		return m.EncapType
	}
	return IntfTunnelEncapType_IF_TUNNEL_ENCAP_TYPE_NONE
}

func (m *IfTunnelInfo_) GetVxlanInfo() *IfTunnelVxlanInfo_ {
	if m != nil {
		return m.VxlanInfo
	}
	return nil
}

func (m *IfTunnelInfo_) GetGreInfo() *IfTunnelGREInfo_ {
	if m != nil {
		return m.GreInfo
	}
	return nil
}

func (m *IfTunnelInfo_) GetVrfKeyHandle() *VrfKeyHandle_ {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// attributes for CPU If
type IfCPUInfo_ struct {
	LifKeyOrHandle *LifKeyHandle_ `protobuf:"bytes,2,opt,name=lif_key_or_handle,json=lifKeyOrHandle" json:"lif_key_or_handle,omitempty"`
}

func (m *IfCPUInfo_) Reset()                    { *m = IfCPUInfo_{} }
func (m *IfCPUInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfCPUInfo_) ProtoMessage()               {}
func (*IfCPUInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *IfCPUInfo_) GetLifKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.LifKeyOrHandle
	}
	return nil
}

// attributes for App Redirect If
type IfAppRedirInfo_ struct {
	LifKeyOrHandle *LifKeyHandle_ `protobuf:"bytes,2,opt,name=lif_key_or_handle,json=lifKeyOrHandle" json:"lif_key_or_handle,omitempty"`
}

func (m *IfAppRedirInfo_) Reset()                    { *m = IfAppRedirInfo_{} }
func (m *IfAppRedirInfo_) String() string            { return proto.CompactTextString(m) }
func (*IfAppRedirInfo_) ProtoMessage()               {}
func (*IfAppRedirInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *IfAppRedirInfo_) GetLifKeyOrHandle() *LifKeyHandle_ {
	if m != nil {
		return m.LifKeyOrHandle
	}
	return nil
}

// InterfaceSpec is used to add or update of an interface
type InterfaceSpec_ struct {
	Meta           *delphi.ObjectMeta   `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle    *InterfaceKeyHandle_ `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	IfType         IntfType             `protobuf:"varint,3,opt,name=if_type,json=ifType,enum=intf.IntfType" json:"if_type,omitempty"`
	AdminStatus    IntfStatus           `protobuf:"varint,4,opt,name=admin_status,json=adminStatus,enum=intf.IntfStatus" json:"admin_status,omitempty"`
	IfEnicInfo     *IfEnicInfo_         `protobuf:"bytes,5,opt,name=if_enic_info,json=ifEnicInfo" json:"if_enic_info,omitempty"`
	IfUplinkInfo   *IfUplinkInfo_       `protobuf:"bytes,6,opt,name=if_uplink_info,json=ifUplinkInfo" json:"if_uplink_info,omitempty"`
	IfUplinkPcInfo *IfUplinkPCInfo_     `protobuf:"bytes,7,opt,name=if_uplink_pc_info,json=ifUplinkPcInfo" json:"if_uplink_pc_info,omitempty"`
	IfTunnelInfo   *IfTunnelInfo_       `protobuf:"bytes,8,opt,name=if_tunnel_info,json=ifTunnelInfo" json:"if_tunnel_info,omitempty"`
	IfCpuInfo      *IfCPUInfo_          `protobuf:"bytes,9,opt,name=if_cpu_info,json=ifCpuInfo" json:"if_cpu_info,omitempty"`
	IfAppRedirInfo *IfAppRedirInfo_     `protobuf:"bytes,10,opt,name=if_app_redir_info,json=ifAppRedirInfo" json:"if_app_redir_info,omitempty"`
}

func (m *InterfaceSpec_) Reset()                    { *m = InterfaceSpec_{} }
func (m *InterfaceSpec_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec_) ProtoMessage()               {}
func (*InterfaceSpec_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *InterfaceSpec_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *InterfaceSpec_) GetKeyOrHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *InterfaceSpec_) GetIfType() IntfType {
	if m != nil {
		return m.IfType
	}
	return IntfType_IF_TYPE_NONE
}

func (m *InterfaceSpec_) GetAdminStatus() IntfStatus {
	if m != nil {
		return m.AdminStatus
	}
	return IntfStatus_IF_STATUS_NONE
}

func (m *InterfaceSpec_) GetIfEnicInfo() *IfEnicInfo_ {
	if m != nil {
		return m.IfEnicInfo
	}
	return nil
}

func (m *InterfaceSpec_) GetIfUplinkInfo() *IfUplinkInfo_ {
	if m != nil {
		return m.IfUplinkInfo
	}
	return nil
}

func (m *InterfaceSpec_) GetIfUplinkPcInfo() *IfUplinkPCInfo_ {
	if m != nil {
		return m.IfUplinkPcInfo
	}
	return nil
}

func (m *InterfaceSpec_) GetIfTunnelInfo() *IfTunnelInfo_ {
	if m != nil {
		return m.IfTunnelInfo
	}
	return nil
}

func (m *InterfaceSpec_) GetIfCpuInfo() *IfCPUInfo_ {
	if m != nil {
		return m.IfCpuInfo
	}
	return nil
}

func (m *InterfaceSpec_) GetIfAppRedirInfo() *IfAppRedirInfo_ {
	if m != nil {
		return m.IfAppRedirInfo
	}
	return nil
}

// InterfaceRequestMsg is batched request message that is used to do
// create/update of interface(s)
type InterfaceRequestMsg_ struct {
	Request *InterfaceSpec_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *InterfaceRequestMsg_) Reset()                    { *m = InterfaceRequestMsg_{} }
func (m *InterfaceRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceRequestMsg_) ProtoMessage()               {}
func (*InterfaceRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *InterfaceRequestMsg_) GetRequest() *InterfaceSpec_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// Uplink/Uplink PC's response
type UplinkResponseInfo_ struct {
	UplinkLportId uint32 `protobuf:"varint,1,opt,name=uplink_lport_id,json=uplinkLportId" json:"uplink_lport_id,omitempty"`
	HwLifId       uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId" json:"hw_lif_id,omitempty"`
	UplinkIdx     uint32 `protobuf:"varint,3,opt,name=uplink_idx,json=uplinkIdx" json:"uplink_idx,omitempty"`
	NumL2Segs     uint32 `protobuf:"varint,4,opt,name=num_l2segs,json=numL2segs" json:"num_l2segs,omitempty"`
	HwPortNum     uint32 `protobuf:"varint,5,opt,name=hw_port_num,json=hwPortNum" json:"hw_port_num,omitempty"`
}

func (m *UplinkResponseInfo_) Reset()                    { *m = UplinkResponseInfo_{} }
func (m *UplinkResponseInfo_) String() string            { return proto.CompactTextString(m) }
func (*UplinkResponseInfo_) ProtoMessage()               {}
func (*UplinkResponseInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *UplinkResponseInfo_) GetUplinkLportId() uint32 {
	if m != nil {
		return m.UplinkLportId
	}
	return 0
}

func (m *UplinkResponseInfo_) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *UplinkResponseInfo_) GetUplinkIdx() uint32 {
	if m != nil {
		return m.UplinkIdx
	}
	return 0
}

func (m *UplinkResponseInfo_) GetNumL2Segs() uint32 {
	if m != nil {
		return m.NumL2Segs
	}
	return 0
}

func (m *UplinkResponseInfo_) GetHwPortNum() uint32 {
	if m != nil {
		return m.HwPortNum
	}
	return 0
}

// Enic <-> L2seg membership info
type EnicL2SegInfo_ struct {
	L2SegmentKeyOrHandle *L2SegmentKeyHandle_ `protobuf:"bytes,1,opt,name=l2segment_key_or_handle,json=l2segmentKeyOrHandle" json:"l2segment_key_or_handle,omitempty"`
	InpPropIdx           uint32               `protobuf:"varint,2,opt,name=inp_prop_idx,json=inpPropIdx" json:"inp_prop_idx,omitempty"`
}

func (m *EnicL2SegInfo_) Reset()                    { *m = EnicL2SegInfo_{} }
func (m *EnicL2SegInfo_) String() string            { return proto.CompactTextString(m) }
func (*EnicL2SegInfo_) ProtoMessage()               {}
func (*EnicL2SegInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *EnicL2SegInfo_) GetL2SegmentKeyOrHandle() *L2SegmentKeyHandle_ {
	if m != nil {
		return m.L2SegmentKeyOrHandle
	}
	return nil
}

func (m *EnicL2SegInfo_) GetInpPropIdx() uint32 {
	if m != nil {
		return m.InpPropIdx
	}
	return 0
}

type SmartEnicInfo_ struct {
	InpPropMacVlanIdxHost uint32 `protobuf:"varint,1,opt,name=inp_prop_mac_vlan_idx_host,json=inpPropMacVlanIdxHost" json:"inp_prop_mac_vlan_idx_host,omitempty"`
	InpPropMacVlanIdxNet  uint32 `protobuf:"varint,2,opt,name=inp_prop_mac_vlan_idx_net,json=inpPropMacVlanIdxNet" json:"inp_prop_mac_vlan_idx_net,omitempty"`
}

func (m *SmartEnicInfo_) Reset()                    { *m = SmartEnicInfo_{} }
func (m *SmartEnicInfo_) String() string            { return proto.CompactTextString(m) }
func (*SmartEnicInfo_) ProtoMessage()               {}
func (*SmartEnicInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *SmartEnicInfo_) GetInpPropMacVlanIdxHost() uint32 {
	if m != nil {
		return m.InpPropMacVlanIdxHost
	}
	return 0
}

func (m *SmartEnicInfo_) GetInpPropMacVlanIdxNet() uint32 {
	if m != nil {
		return m.InpPropMacVlanIdxNet
	}
	return 0
}

type ClassicEnicInfo_ struct {
	InpPropNatL2SegClassic uint32          `protobuf:"varint,1,opt,name=inp_prop_nat_l2seg_classic,json=inpPropNatL2segClassic" json:"inp_prop_nat_l2seg_classic,omitempty"`
	MembershipInfo         *EnicL2SegInfo_ `protobuf:"bytes,2,opt,name=membership_info,json=membershipInfo" json:"membership_info,omitempty"`
}

func (m *ClassicEnicInfo_) Reset()                    { *m = ClassicEnicInfo_{} }
func (m *ClassicEnicInfo_) String() string            { return proto.CompactTextString(m) }
func (*ClassicEnicInfo_) ProtoMessage()               {}
func (*ClassicEnicInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *ClassicEnicInfo_) GetInpPropNatL2SegClassic() uint32 {
	if m != nil {
		return m.InpPropNatL2SegClassic
	}
	return 0
}

func (m *ClassicEnicInfo_) GetMembershipInfo() *EnicL2SegInfo_ {
	if m != nil {
		return m.MembershipInfo
	}
	return nil
}

// Enic's response
type EnicResponseInfo_ struct {
	EnicLportId     uint32            `protobuf:"varint,1,opt,name=enic_lport_id,json=enicLportId" json:"enic_lport_id,omitempty"`
	UplinkIfHandle  uint32            `protobuf:"varint,2,opt,name=uplink_if_handle,json=uplinkIfHandle" json:"uplink_if_handle,omitempty"`
	SmartEnicInfo   *SmartEnicInfo_   `protobuf:"bytes,3,opt,name=smart_enic_info,json=smartEnicInfo" json:"smart_enic_info,omitempty"`
	ClassicEnicInfo *ClassicEnicInfo_ `protobuf:"bytes,4,opt,name=classic_enic_info,json=classicEnicInfo" json:"classic_enic_info,omitempty"`
}

func (m *EnicResponseInfo_) Reset()                    { *m = EnicResponseInfo_{} }
func (m *EnicResponseInfo_) String() string            { return proto.CompactTextString(m) }
func (*EnicResponseInfo_) ProtoMessage()               {}
func (*EnicResponseInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *EnicResponseInfo_) GetEnicLportId() uint32 {
	if m != nil {
		return m.EnicLportId
	}
	return 0
}

func (m *EnicResponseInfo_) GetUplinkIfHandle() uint32 {
	if m != nil {
		return m.UplinkIfHandle
	}
	return 0
}

func (m *EnicResponseInfo_) GetSmartEnicInfo() *SmartEnicInfo_ {
	if m != nil {
		return m.SmartEnicInfo
	}
	return nil
}

func (m *EnicResponseInfo_) GetClassicEnicInfo() *ClassicEnicInfo_ {
	if m != nil {
		return m.ClassicEnicInfo
	}
	return nil
}

// CPU If's response
type CpuIfResponseInfo_ struct {
	CpuLportId uint32 `protobuf:"varint,1,opt,name=cpu_lport_id,json=cpuLportId" json:"cpu_lport_id,omitempty"`
}

func (m *CpuIfResponseInfo_) Reset()                    { *m = CpuIfResponseInfo_{} }
func (m *CpuIfResponseInfo_) String() string            { return proto.CompactTextString(m) }
func (*CpuIfResponseInfo_) ProtoMessage()               {}
func (*CpuIfResponseInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *CpuIfResponseInfo_) GetCpuLportId() uint32 {
	if m != nil {
		return m.CpuLportId
	}
	return 0
}

// Tunnel If's response
type TunnelIfResponseInfo_ struct {
	InpMapNatIdx uint32 `protobuf:"varint,1,opt,name=inp_map_nat_idx,json=inpMapNatIdx" json:"inp_map_nat_idx,omitempty"`
	//  1. Inner IPv4
	//  2. Inner IPv6
	//  3. Inner MAC
	InpMapTnlIdx uint32 `protobuf:"varint,2,opt,name=inp_map_tnl_idx,json=inpMapTnlIdx" json:"inp_map_tnl_idx,omitempty"`
	//  1. Inner IPv4
	//  2. Inner IPv6
	//  3. Inner MAC
	TunnelRwIdx uint32 `protobuf:"varint,3,opt,name=tunnel_rw_idx,json=tunnelRwIdx" json:"tunnel_rw_idx,omitempty"`
}

func (m *TunnelIfResponseInfo_) Reset()                    { *m = TunnelIfResponseInfo_{} }
func (m *TunnelIfResponseInfo_) String() string            { return proto.CompactTextString(m) }
func (*TunnelIfResponseInfo_) ProtoMessage()               {}
func (*TunnelIfResponseInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *TunnelIfResponseInfo_) GetInpMapNatIdx() uint32 {
	if m != nil {
		return m.InpMapNatIdx
	}
	return 0
}

func (m *TunnelIfResponseInfo_) GetInpMapTnlIdx() uint32 {
	if m != nil {
		return m.InpMapTnlIdx
	}
	return 0
}

func (m *TunnelIfResponseInfo_) GetTunnelRwIdx() uint32 {
	if m != nil {
		return m.TunnelRwIdx
	}
	return 0
}

// App redir if's response
type AppRedirIfInfo_ struct {
	LportId uint32 `protobuf:"varint,1,opt,name=LportId" json:"LportId,omitempty"`
}

func (m *AppRedirIfInfo_) Reset()                    { *m = AppRedirIfInfo_{} }
func (m *AppRedirIfInfo_) String() string            { return proto.CompactTextString(m) }
func (*AppRedirIfInfo_) ProtoMessage()               {}
func (*AppRedirIfInfo_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *AppRedirIfInfo_) GetLportId() uint32 {
	if m != nil {
		return m.LportId
	}
	return 0
}

// InterfaceStatus represents the current status of the interface
type InterfaceStatus_ struct {
	Meta         *delphi.ObjectMeta     `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle  *InterfaceKeyHandle_   `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	IfStatus     IntfStatus             `protobuf:"varint,3,opt,name=if_status,json=ifStatus,enum=intf.IntfStatus" json:"if_status,omitempty"`
	IfHandle     uint64                 `protobuf:"fixed64,4,opt,name=if_handle,json=ifHandle" json:"if_handle,omitempty"`
	UplinkInfo   *UplinkResponseInfo_   `protobuf:"bytes,5,opt,name=uplink_info,json=uplinkInfo" json:"uplink_info,omitempty"`
	EnicInfo     *EnicResponseInfo_     `protobuf:"bytes,6,opt,name=enic_info,json=enicInfo" json:"enic_info,omitempty"`
	CpuInfo      *CpuIfResponseInfo_    `protobuf:"bytes,7,opt,name=cpu_info,json=cpuInfo" json:"cpu_info,omitempty"`
	TunnelInfo   *TunnelIfResponseInfo_ `protobuf:"bytes,8,opt,name=tunnel_info,json=tunnelInfo" json:"tunnel_info,omitempty"`
	AppRedirInfo *AppRedirIfInfo_       `protobuf:"bytes,9,opt,name=app_redir_info,json=appRedirInfo" json:"app_redir_info,omitempty"`
}

func (m *InterfaceStatus_) Reset()                    { *m = InterfaceStatus_{} }
func (m *InterfaceStatus_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStatus_) ProtoMessage()               {}
func (*InterfaceStatus_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *InterfaceStatus_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *InterfaceStatus_) GetKeyOrHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *InterfaceStatus_) GetIfStatus() IntfStatus {
	if m != nil {
		return m.IfStatus
	}
	return IntfStatus_IF_STATUS_NONE
}

func (m *InterfaceStatus_) GetIfHandle() uint64 {
	if m != nil {
		return m.IfHandle
	}
	return 0
}

func (m *InterfaceStatus_) GetUplinkInfo() *UplinkResponseInfo_ {
	if m != nil {
		return m.UplinkInfo
	}
	return nil
}

func (m *InterfaceStatus_) GetEnicInfo() *EnicResponseInfo_ {
	if m != nil {
		return m.EnicInfo
	}
	return nil
}

func (m *InterfaceStatus_) GetCpuInfo() *CpuIfResponseInfo_ {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *InterfaceStatus_) GetTunnelInfo() *TunnelIfResponseInfo_ {
	if m != nil {
		return m.TunnelInfo
	}
	return nil
}

func (m *InterfaceStatus_) GetAppRedirInfo() *AppRedirIfInfo_ {
	if m != nil {
		return m.AppRedirInfo
	}
	return nil
}

// InterfaceResponse is response to one InterfaceSpec
type InterfaceResponse_ struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
	Status    *InterfaceStatus_ `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *InterfaceResponse_) Reset()                    { *m = InterfaceResponse_{} }
func (m *InterfaceResponse_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceResponse_) ProtoMessage()               {}
func (*InterfaceResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *InterfaceResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceResponse_) GetStatus() *InterfaceStatus_ {
	if m != nil {
		return m.Status
	}
	return nil
}

// InterfaceResponseMsg is response to InterfaceRequestMsg
type InterfaceResponseMsg_ struct {
	Response *InterfaceResponse_ `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
}

func (m *InterfaceResponseMsg_) Reset()                    { *m = InterfaceResponseMsg_{} }
func (m *InterfaceResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceResponseMsg_) ProtoMessage()               {}
func (*InterfaceResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *InterfaceResponseMsg_) GetResponse() *InterfaceResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

// InterfaceDeleteRequest is used to delete a interface object
type InterfaceDeleteRequest_ struct {
	KeyOrHandle *InterfaceKeyHandle_ `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *InterfaceDeleteRequest_) Reset()                    { *m = InterfaceDeleteRequest_{} }
func (m *InterfaceDeleteRequest_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteRequest_) ProtoMessage()               {}
func (*InterfaceDeleteRequest_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *InterfaceDeleteRequest_) GetKeyOrHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// InterfaceDeleteRequestMsg is used to delete a batch of interfaces
type InterfaceDeleteRequestMsg_ struct {
	Request *InterfaceDeleteRequest_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *InterfaceDeleteRequestMsg_) Reset()                    { *m = InterfaceDeleteRequestMsg_{} }
func (m *InterfaceDeleteRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteRequestMsg_) ProtoMessage()               {}
func (*InterfaceDeleteRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *InterfaceDeleteRequestMsg_) GetRequest() *InterfaceDeleteRequest_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// InterfaceDeleteResponse is batched response to InterfaceDeleteRequest
type InterfaceDeleteResponse_ struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
}

func (m *InterfaceDeleteResponse_) Reset()                    { *m = InterfaceDeleteResponse_{} }
func (m *InterfaceDeleteResponse_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteResponse_) ProtoMessage()               {}
func (*InterfaceDeleteResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *InterfaceDeleteResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// InterfaceDeleteResponseMsg is batched response to InterfaceDeleteRequestMsg
type InterfaceDeleteResponseMsg_ struct {
	Response *InterfaceDeleteResponse_ `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
}

func (m *InterfaceDeleteResponseMsg_) Reset()                    { *m = InterfaceDeleteResponseMsg_{} }
func (m *InterfaceDeleteResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteResponseMsg_) ProtoMessage()               {}
func (*InterfaceDeleteResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func (m *InterfaceDeleteResponseMsg_) GetResponse() *InterfaceDeleteResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

// InterfaceStats captures all the statistics of given interface
type InterfaceStats_ struct {
	NumTxPackets uint32 `protobuf:"fixed32,1,opt,name=num_tx_packets,json=numTxPackets" json:"num_tx_packets,omitempty"`
	NumTxBytes   uint32 `protobuf:"fixed32,2,opt,name=num_tx_bytes,json=numTxBytes" json:"num_tx_bytes,omitempty"`
	NumRxPackets uint32 `protobuf:"fixed32,3,opt,name=num_rx_packets,json=numRxPackets" json:"num_rx_packets,omitempty"`
	NumRxBytes   uint32 `protobuf:"fixed32,4,opt,name=num_rx_bytes,json=numRxBytes" json:"num_rx_bytes,omitempty"`
}

func (m *InterfaceStats_) Reset()                    { *m = InterfaceStats_{} }
func (m *InterfaceStats_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStats_) ProtoMessage()               {}
func (*InterfaceStats_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *InterfaceStats_) GetNumTxPackets() uint32 {
	if m != nil {
		return m.NumTxPackets
	}
	return 0
}

func (m *InterfaceStats_) GetNumTxBytes() uint32 {
	if m != nil {
		return m.NumTxBytes
	}
	return 0
}

func (m *InterfaceStats_) GetNumRxPackets() uint32 {
	if m != nil {
		return m.NumRxPackets
	}
	return 0
}

func (m *InterfaceStats_) GetNumRxBytes() uint32 {
	if m != nil {
		return m.NumRxBytes
	}
	return 0
}

// InterfaceGetRequest is used to get information about a interface
type InterfaceGetRequest_ struct {
	KeyOrHandle *InterfaceKeyHandle_ `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *InterfaceGetRequest_) Reset()                    { *m = InterfaceGetRequest_{} }
func (m *InterfaceGetRequest_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetRequest_) ProtoMessage()               {}
func (*InterfaceGetRequest_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *InterfaceGetRequest_) GetKeyOrHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// InterfaceGetRequestMsg is batched GET request for interfaces
type InterfaceGetRequestMsg_ struct {
	Request *InterfaceGetRequest_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *InterfaceGetRequestMsg_) Reset()                    { *m = InterfaceGetRequestMsg_{} }
func (m *InterfaceGetRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetRequestMsg_) ProtoMessage()               {}
func (*InterfaceGetRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *InterfaceGetRequestMsg_) GetRequest() *InterfaceGetRequest_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// InterfaceGetResponse captures all the information about a interface
type InterfaceGetResponse_ struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
	Spec      *InterfaceSpec_   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *InterfaceStatus_ `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *InterfaceStats_  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *InterfaceGetResponse_) Reset()                    { *m = InterfaceGetResponse_{} }
func (m *InterfaceGetResponse_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetResponse_) ProtoMessage()               {}
func (*InterfaceGetResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *InterfaceGetResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceGetResponse_) GetSpec() *InterfaceSpec_ {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *InterfaceGetResponse_) GetStatus() *InterfaceStatus_ {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *InterfaceGetResponse_) GetStats() *InterfaceStats_ {
	if m != nil {
		return m.Stats
	}
	return nil
}

// InterfaceGetResponseMsg is response to InterfaceGetRequestMsg
type InterfaceGetResponseMsg_ struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
	Response  *InterfaceGetResponse_ `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
}

func (m *InterfaceGetResponseMsg_) Reset()                    { *m = InterfaceGetResponseMsg_{} }
func (m *InterfaceGetResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetResponseMsg_) ProtoMessage()               {}
func (*InterfaceGetResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

func (m *InterfaceGetResponseMsg_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceGetResponseMsg_) GetResponse() *InterfaceGetResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

// InterfaceL2SegmentSpec carries the user vlan that is being added or deleted
// on an uplink interface or uplink PC
type InterfaceL2SegmentSpec_ struct {
	L2SegmentKeyOrHandle *L2SegmentKeyHandle_ `protobuf:"bytes,1,opt,name=l2segment_key_or_handle,json=l2segmentKeyOrHandle" json:"l2segment_key_or_handle,omitempty"`
	IfKeyHandle          *InterfaceKeyHandle_ `protobuf:"bytes,2,opt,name=if_key_handle,json=ifKeyHandle" json:"if_key_handle,omitempty"`
}

func (m *InterfaceL2SegmentSpec_) Reset()                    { *m = InterfaceL2SegmentSpec_{} }
func (m *InterfaceL2SegmentSpec_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceL2SegmentSpec_) ProtoMessage()               {}
func (*InterfaceL2SegmentSpec_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *InterfaceL2SegmentSpec_) GetL2SegmentKeyOrHandle() *L2SegmentKeyHandle_ {
	if m != nil {
		return m.L2SegmentKeyOrHandle
	}
	return nil
}

func (m *InterfaceL2SegmentSpec_) GetIfKeyHandle() *InterfaceKeyHandle_ {
	if m != nil {
		return m.IfKeyHandle
	}
	return nil
}

// InterfaceL2SegmentRequestMsg is batched request message to bring vlans
// on interfaces
type InterfaceL2SegmentRequestMsg_ struct {
	Request *InterfaceL2SegmentSpec_ `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
}

func (m *InterfaceL2SegmentRequestMsg_) Reset()                    { *m = InterfaceL2SegmentRequestMsg_{} }
func (m *InterfaceL2SegmentRequestMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceL2SegmentRequestMsg_) ProtoMessage()               {}
func (*InterfaceL2SegmentRequestMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

func (m *InterfaceL2SegmentRequestMsg_) GetRequest() *InterfaceL2SegmentSpec_ {
	if m != nil {
		return m.Request
	}
	return nil
}

// InterfaceL2SegmentResponse is response to InterfaceL2SegmentSpec
type InterfaceL2SegmentResponse_ struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=intf.ApiStatus" json:"api_status,omitempty"`
}

func (m *InterfaceL2SegmentResponse_) Reset()                    { *m = InterfaceL2SegmentResponse_{} }
func (m *InterfaceL2SegmentResponse_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceL2SegmentResponse_) ProtoMessage()               {}
func (*InterfaceL2SegmentResponse_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *InterfaceL2SegmentResponse_) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// InterfaceL2SegmentResponseMsg is batched response to InterfaceL2SegmentResponse
type InterfaceL2SegmentResponseMsg_ struct {
	Response *InterfaceL2SegmentResponse_ `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
}

func (m *InterfaceL2SegmentResponseMsg_) Reset()                    { *m = InterfaceL2SegmentResponseMsg_{} }
func (m *InterfaceL2SegmentResponseMsg_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceL2SegmentResponseMsg_) ProtoMessage()               {}
func (*InterfaceL2SegmentResponseMsg_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

func (m *InterfaceL2SegmentResponseMsg_) GetResponse() *InterfaceL2SegmentResponse_ {
	if m != nil {
		return m.Response
	}
	return nil
}

type delphiWrapper interface {
	bubbleSave()
}

type IPAddress struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	ip_af     IPAddressFamily
	v4_addr   uint32
	v6_addr   []byte
}

func (o *IPAddress) Getip_af() IPAddressFamily {
	return o.ip_af
}

func (o *IPAddress) Setip_af(val IPAddressFamily) {
	o.ip_af = val
	o.bubbleSave()
}

func (o *IPAddress) Getv4_addr() uint32 {
	return o.v4_addr
}

func (o *IPAddress) Setv4_addr(val uint32) {
	o.v4_addr = val
	o.bubbleSave()
}

func (o *IPAddress) Getv6_addr() []byte {
	return o.v6_addr
}

func (o *IPAddress) Setv6_addr(val []byte) {
	o.v6_addr = val
	o.bubbleSave()
}

func (o *IPAddress) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IPAddress) save() {
}

func NewIPAddress(sdkClient clientApi.Client) *IPAddress {
	w := &IPAddress{}
	w.sdkClient = sdkClient
	return w
}

func childNewIPAddress(parent delphiWrapper, sdkClient clientApi.Client) *IPAddress {
	w := NewIPAddress(sdkClient)
	w.parent = parent
	return w
}

func childNewIPAddressWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IPAddress) *IPAddress {
	w := childNewIPAddress(parent, sdkClient)
	w.ip_af = value.ip_af
	w.v4_addr = value.v4_addr
	w.v6_addr = value.v6_addr
	return w
}

func (o *IPAddress) GetProtoMsg() *IPAddress_ {
	if o == nil {
		return &IPAddress_{}
	}

	return &IPAddress_{
		IpAf:   o.ip_af,
		V4Addr: o.v4_addr,
		V6Addr: o.v6_addr,
	}
}

func (o *IPAddress) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIPAddressFromMessage(msg *IPAddress_) *IPAddress {
	if msg == nil {
		return &IPAddress{}
	}

	return &IPAddress{
		ip_af:   msg.IpAf,
		v4_addr: msg.V4Addr,
		v6_addr: msg.V6Addr,
	}
}

type InterfaceGetResponseMsg struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
	response   *InterfaceGetResponse
}

func (o *InterfaceGetResponseMsg) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *InterfaceGetResponseMsg) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *InterfaceGetResponseMsg) Getresponse() *InterfaceGetResponse {
	return o.response
}

func (o *InterfaceGetResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceGetResponseMsg) save() {
}

func NewInterfaceGetResponseMsg(sdkClient clientApi.Client) *InterfaceGetResponseMsg {
	w := &InterfaceGetResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewInterfaceGetResponse(w, sdkClient)
	return w
}

func childNewInterfaceGetResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceGetResponseMsg {
	w := NewInterfaceGetResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceGetResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceGetResponseMsg) *InterfaceGetResponseMsg {
	w := childNewInterfaceGetResponseMsg(parent, sdkClient)
	w.api_status = value.api_status
	w.response = childNewInterfaceGetResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *InterfaceGetResponseMsg) GetProtoMsg() *InterfaceGetResponseMsg_ {
	if o == nil {
		return &InterfaceGetResponseMsg_{}
	}

	return &InterfaceGetResponseMsg_{
		ApiStatus: o.api_status,
		Response:  o.response.GetProtoMsg(),
	}
}

func (o *InterfaceGetResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceGetResponseMsgFromMessage(msg *InterfaceGetResponseMsg_) *InterfaceGetResponseMsg {
	if msg == nil {
		return &InterfaceGetResponseMsg{}
	}

	return &InterfaceGetResponseMsg{
		api_status: msg.ApiStatus,
		response:   newInterfaceGetResponseFromMessage(msg.Response),
	}
}

type InterfaceResponse struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
	status     *InterfaceStatus
}

func (o *InterfaceResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *InterfaceResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *InterfaceResponse) Getstatus() *InterfaceStatus {
	return o.status
}

func (o *InterfaceResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceResponse) save() {
}

func NewInterfaceResponse(sdkClient clientApi.Client) *InterfaceResponse {
	w := &InterfaceResponse{}
	w.sdkClient = sdkClient
	w.status = childNewInterfaceStatus(w, sdkClient)
	return w
}

func childNewInterfaceResponse(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceResponse {
	w := NewInterfaceResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceResponse) *InterfaceResponse {
	w := childNewInterfaceResponse(parent, sdkClient)
	w.api_status = value.api_status
	w.status = childNewInterfaceStatusWithValue(w, sdkClient, value.status)
	return w
}

func (o *InterfaceResponse) GetProtoMsg() *InterfaceResponse_ {
	if o == nil {
		return &InterfaceResponse_{}
	}

	return &InterfaceResponse_{
		ApiStatus: o.api_status,
		Status:    o.status.GetProtoMsg(),
	}
}

func (o *InterfaceResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceResponseFromMessage(msg *InterfaceResponse_) *InterfaceResponse {
	if msg == nil {
		return &InterfaceResponse{}
	}

	return &InterfaceResponse{
		api_status: msg.ApiStatus,
		status:     newInterfaceStatusFromMessage(msg.Status),
	}
}

type InterfaceL2SegmentRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *InterfaceL2SegmentSpec
}

func (o *InterfaceL2SegmentRequestMsg) Getrequest() *InterfaceL2SegmentSpec {
	return o.request
}

func (o *InterfaceL2SegmentRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceL2SegmentRequestMsg) save() {
}

func NewInterfaceL2SegmentRequestMsg(sdkClient clientApi.Client) *InterfaceL2SegmentRequestMsg {
	w := &InterfaceL2SegmentRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewInterfaceL2SegmentSpec(w, sdkClient)
	return w
}

func childNewInterfaceL2SegmentRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceL2SegmentRequestMsg {
	w := NewInterfaceL2SegmentRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceL2SegmentRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceL2SegmentRequestMsg) *InterfaceL2SegmentRequestMsg {
	w := childNewInterfaceL2SegmentRequestMsg(parent, sdkClient)
	w.request = childNewInterfaceL2SegmentSpecWithValue(w, sdkClient, value.request)
	return w
}

func (o *InterfaceL2SegmentRequestMsg) GetProtoMsg() *InterfaceL2SegmentRequestMsg_ {
	if o == nil {
		return &InterfaceL2SegmentRequestMsg_{}
	}

	return &InterfaceL2SegmentRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *InterfaceL2SegmentRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceL2SegmentRequestMsgFromMessage(msg *InterfaceL2SegmentRequestMsg_) *InterfaceL2SegmentRequestMsg {
	if msg == nil {
		return &InterfaceL2SegmentRequestMsg{}
	}

	return &InterfaceL2SegmentRequestMsg{
		request: newInterfaceL2SegmentSpecFromMessage(msg.Request),
	}
}

type VrfKeyHandle struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	vrf_id     uint64
	vrf_handle uint64
}

func (o *VrfKeyHandle) Getvrf_id() uint64 {
	return o.vrf_id
}

func (o *VrfKeyHandle) Setvrf_id(val uint64) {
	o.vrf_id = val
	o.bubbleSave()
}

func (o *VrfKeyHandle) Getvrf_handle() uint64 {
	return o.vrf_handle
}

func (o *VrfKeyHandle) Setvrf_handle(val uint64) {
	o.vrf_handle = val
	o.bubbleSave()
}

func (o *VrfKeyHandle) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *VrfKeyHandle) save() {
}

func NewVrfKeyHandle(sdkClient clientApi.Client) *VrfKeyHandle {
	w := &VrfKeyHandle{}
	w.sdkClient = sdkClient
	return w
}

func childNewVrfKeyHandle(parent delphiWrapper, sdkClient clientApi.Client) *VrfKeyHandle {
	w := NewVrfKeyHandle(sdkClient)
	w.parent = parent
	return w
}

func childNewVrfKeyHandleWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *VrfKeyHandle) *VrfKeyHandle {
	w := childNewVrfKeyHandle(parent, sdkClient)
	w.vrf_id = value.vrf_id
	w.vrf_handle = value.vrf_handle
	return w
}

func (o *VrfKeyHandle) GetProtoMsg() *VrfKeyHandle_ {
	if o == nil {
		return &VrfKeyHandle_{}
	}

	return &VrfKeyHandle_{
		VrfId:     o.vrf_id,
		VrfHandle: o.vrf_handle,
	}
}

func (o *VrfKeyHandle) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newVrfKeyHandleFromMessage(msg *VrfKeyHandle_) *VrfKeyHandle {
	if msg == nil {
		return &VrfKeyHandle{}
	}

	return &VrfKeyHandle{
		vrf_id:     msg.VrfId,
		vrf_handle: msg.VrfHandle,
	}
}

type QStateGetResp struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	error_code  int32
	q_addr      uint64
	queue_state []byte
}

func (o *QStateGetResp) Geterror_code() int32 {
	return o.error_code
}

func (o *QStateGetResp) Seterror_code(val int32) {
	o.error_code = val
	o.bubbleSave()
}

func (o *QStateGetResp) Getq_addr() uint64 {
	return o.q_addr
}

func (o *QStateGetResp) Setq_addr(val uint64) {
	o.q_addr = val
	o.bubbleSave()
}

func (o *QStateGetResp) Getqueue_state() []byte {
	return o.queue_state
}

func (o *QStateGetResp) Setqueue_state(val []byte) {
	o.queue_state = val
	o.bubbleSave()
}

func (o *QStateGetResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *QStateGetResp) save() {
}

func NewQStateGetResp(sdkClient clientApi.Client) *QStateGetResp {
	w := &QStateGetResp{}
	w.sdkClient = sdkClient
	return w
}

func childNewQStateGetResp(parent delphiWrapper, sdkClient clientApi.Client) *QStateGetResp {
	w := NewQStateGetResp(sdkClient)
	w.parent = parent
	return w
}

func childNewQStateGetRespWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *QStateGetResp) *QStateGetResp {
	w := childNewQStateGetResp(parent, sdkClient)
	w.error_code = value.error_code
	w.q_addr = value.q_addr
	w.queue_state = value.queue_state
	return w
}

func (o *QStateGetResp) GetProtoMsg() *QStateGetResp_ {
	if o == nil {
		return &QStateGetResp_{}
	}

	return &QStateGetResp_{
		ErrorCode:  o.error_code,
		QAddr:      o.q_addr,
		QueueState: o.queue_state,
	}
}

func (o *QStateGetResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newQStateGetRespFromMessage(msg *QStateGetResp_) *QStateGetResp {
	if msg == nil {
		return &QStateGetResp{}
	}

	return &QStateGetResp{
		error_code:  msg.ErrorCode,
		q_addr:      msg.QAddr,
		queue_state: msg.QueueState,
	}
}

type IfTunnelInfo struct {
	sdkClient      clientApi.Client
	parent         delphiWrapper
	encap_type     IntfTunnelEncapType
	vxlan_info     *IfTunnelVxlanInfo
	gre_info       *IfTunnelGREInfo
	vrf_key_handle *VrfKeyHandle
}

func (o *IfTunnelInfo) Getencap_type() IntfTunnelEncapType {
	return o.encap_type
}

func (o *IfTunnelInfo) Setencap_type(val IntfTunnelEncapType) {
	o.encap_type = val
	o.bubbleSave()
}

func (o *IfTunnelInfo) Getvxlan_info() *IfTunnelVxlanInfo {
	return o.vxlan_info
}

func (o *IfTunnelInfo) Getgre_info() *IfTunnelGREInfo {
	return o.gre_info
}

func (o *IfTunnelInfo) Getvrf_key_handle() *VrfKeyHandle {
	return o.vrf_key_handle
}

func (o *IfTunnelInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfTunnelInfo) save() {
}

func NewIfTunnelInfo(sdkClient clientApi.Client) *IfTunnelInfo {
	w := &IfTunnelInfo{}
	w.sdkClient = sdkClient
	w.vxlan_info = childNewIfTunnelVxlanInfo(w, sdkClient)
	w.gre_info = childNewIfTunnelGREInfo(w, sdkClient)
	w.vrf_key_handle = childNewVrfKeyHandle(w, sdkClient)
	return w
}

func childNewIfTunnelInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfTunnelInfo {
	w := NewIfTunnelInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfTunnelInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfTunnelInfo) *IfTunnelInfo {
	w := childNewIfTunnelInfo(parent, sdkClient)
	w.encap_type = value.encap_type
	w.vxlan_info = childNewIfTunnelVxlanInfoWithValue(w, sdkClient, value.vxlan_info)
	w.gre_info = childNewIfTunnelGREInfoWithValue(w, sdkClient, value.gre_info)
	w.vrf_key_handle = childNewVrfKeyHandleWithValue(w, sdkClient, value.vrf_key_handle)
	return w
}

func (o *IfTunnelInfo) GetProtoMsg() *IfTunnelInfo_ {
	if o == nil {
		return &IfTunnelInfo_{}
	}

	return &IfTunnelInfo_{
		EncapType:    o.encap_type,
		VxlanInfo:    o.vxlan_info.GetProtoMsg(),
		GreInfo:      o.gre_info.GetProtoMsg(),
		VrfKeyHandle: o.vrf_key_handle.GetProtoMsg(),
	}
}

func (o *IfTunnelInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfTunnelInfoFromMessage(msg *IfTunnelInfo_) *IfTunnelInfo {
	if msg == nil {
		return &IfTunnelInfo{}
	}

	return &IfTunnelInfo{
		encap_type:     msg.EncapType,
		vxlan_info:     newIfTunnelVxlanInfoFromMessage(msg.VxlanInfo),
		gre_info:       newIfTunnelGREInfoFromMessage(msg.GreInfo),
		vrf_key_handle: newVrfKeyHandleFromMessage(msg.VrfKeyHandle),
	}
}

type AppRedirIfInfo struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	lportId   uint32
}

func (o *AppRedirIfInfo) GetLportId() uint32 {
	return o.lportId
}

func (o *AppRedirIfInfo) SetLportId(val uint32) {
	o.lportId = val
	o.bubbleSave()
}

func (o *AppRedirIfInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *AppRedirIfInfo) save() {
}

func NewAppRedirIfInfo(sdkClient clientApi.Client) *AppRedirIfInfo {
	w := &AppRedirIfInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewAppRedirIfInfo(parent delphiWrapper, sdkClient clientApi.Client) *AppRedirIfInfo {
	w := NewAppRedirIfInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewAppRedirIfInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *AppRedirIfInfo) *AppRedirIfInfo {
	w := childNewAppRedirIfInfo(parent, sdkClient)
	w.lportId = value.lportId
	return w
}

func (o *AppRedirIfInfo) GetProtoMsg() *AppRedirIfInfo_ {
	if o == nil {
		return &AppRedirIfInfo_{}
	}

	return &AppRedirIfInfo_{
		LportId: o.lportId,
	}
}

func (o *AppRedirIfInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newAppRedirIfInfoFromMessage(msg *AppRedirIfInfo_) *AppRedirIfInfo {
	if msg == nil {
		return &AppRedirIfInfo{}
	}

	return &AppRedirIfInfo{
		lportId: msg.LportId,
	}
}

type LifQState struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	type_num  uint32
	addr      uint64
}

func (o *LifQState) Gettype_num() uint32 {
	return o.type_num
}

func (o *LifQState) Settype_num(val uint32) {
	o.type_num = val
	o.bubbleSave()
}

func (o *LifQState) Getaddr() uint64 {
	return o.addr
}

func (o *LifQState) Setaddr(val uint64) {
	o.addr = val
	o.bubbleSave()
}

func (o *LifQState) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifQState) save() {
}

func NewLifQState(sdkClient clientApi.Client) *LifQState {
	w := &LifQState{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifQState(parent delphiWrapper, sdkClient clientApi.Client) *LifQState {
	w := NewLifQState(sdkClient)
	w.parent = parent
	return w
}

func childNewLifQStateWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifQState) *LifQState {
	w := childNewLifQState(parent, sdkClient)
	w.type_num = value.type_num
	w.addr = value.addr
	return w
}

func (o *LifQState) GetProtoMsg() *LifQState_ {
	if o == nil {
		return &LifQState_{}
	}

	return &LifQState_{
		TypeNum: o.type_num,
		Addr:    o.addr,
	}
}

func (o *LifQState) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifQStateFromMessage(msg *LifQState_) *LifQState {
	if msg == nil {
		return &LifQState{}
	}

	return &LifQState{
		type_num: msg.TypeNum,
		addr:     msg.Addr,
	}
}

type SetQStateResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	resps     *QStateSetResp
}

func (o *SetQStateResponseMsg) Getresps() *QStateSetResp {
	return o.resps
}

func (o *SetQStateResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *SetQStateResponseMsg) save() {
}

func NewSetQStateResponseMsg(sdkClient clientApi.Client) *SetQStateResponseMsg {
	w := &SetQStateResponseMsg{}
	w.sdkClient = sdkClient
	w.resps = childNewQStateSetResp(w, sdkClient)
	return w
}

func childNewSetQStateResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *SetQStateResponseMsg {
	w := NewSetQStateResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewSetQStateResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *SetQStateResponseMsg) *SetQStateResponseMsg {
	w := childNewSetQStateResponseMsg(parent, sdkClient)
	w.resps = childNewQStateSetRespWithValue(w, sdkClient, value.resps)
	return w
}

func (o *SetQStateResponseMsg) GetProtoMsg() *SetQStateResponseMsg_ {
	if o == nil {
		return &SetQStateResponseMsg_{}
	}

	return &SetQStateResponseMsg_{
		Resps: o.resps.GetProtoMsg(),
	}
}

func (o *SetQStateResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newSetQStateResponseMsgFromMessage(msg *SetQStateResponseMsg_) *SetQStateResponseMsg {
	if msg == nil {
		return &SetQStateResponseMsg{}
	}

	return &SetQStateResponseMsg{
		resps: newQStateSetRespFromMessage(msg.Resps),
	}
}

type EnicInfo struct {
	sdkClient            clientApi.Client
	parent               delphiWrapper
	l2segment_key_handle *L2SegmentKeyHandle
	mac_address          uint64
	encap_vlan_id        uint32
}

func (o *EnicInfo) Getl2segment_key_handle() *L2SegmentKeyHandle {
	return o.l2segment_key_handle
}

func (o *EnicInfo) Getmac_address() uint64 {
	return o.mac_address
}

func (o *EnicInfo) Setmac_address(val uint64) {
	o.mac_address = val
	o.bubbleSave()
}

func (o *EnicInfo) Getencap_vlan_id() uint32 {
	return o.encap_vlan_id
}

func (o *EnicInfo) Setencap_vlan_id(val uint32) {
	o.encap_vlan_id = val
	o.bubbleSave()
}

func (o *EnicInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EnicInfo) save() {
}

func NewEnicInfo(sdkClient clientApi.Client) *EnicInfo {
	w := &EnicInfo{}
	w.sdkClient = sdkClient
	w.l2segment_key_handle = childNewL2SegmentKeyHandle(w, sdkClient)
	return w
}

func childNewEnicInfo(parent delphiWrapper, sdkClient clientApi.Client) *EnicInfo {
	w := NewEnicInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewEnicInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EnicInfo) *EnicInfo {
	w := childNewEnicInfo(parent, sdkClient)
	w.l2segment_key_handle = childNewL2SegmentKeyHandleWithValue(w, sdkClient, value.l2segment_key_handle)
	w.mac_address = value.mac_address
	w.encap_vlan_id = value.encap_vlan_id
	return w
}

func (o *EnicInfo) GetProtoMsg() *EnicInfo_ {
	if o == nil {
		return &EnicInfo_{}
	}

	return &EnicInfo_{
		L2SegmentKeyHandle: o.l2segment_key_handle.GetProtoMsg(),
		MacAddress:         o.mac_address,
		EncapVlanId:        o.encap_vlan_id,
	}
}

func (o *EnicInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEnicInfoFromMessage(msg *EnicInfo_) *EnicInfo {
	if msg == nil {
		return &EnicInfo{}
	}

	return &EnicInfo{
		l2segment_key_handle: newL2SegmentKeyHandleFromMessage(msg.L2SegmentKeyHandle),
		mac_address:          msg.MacAddress,
		encap_vlan_id:        msg.EncapVlanId,
	}
}

type EnicClassicInfo struct {
	sdkClient            clientApi.Client
	parent               delphiWrapper
	l2segment_key_handle *L2SegmentKeyHandle
	native_l2segment_id  uint64
}

func (o *EnicClassicInfo) Getl2segment_key_handle() *L2SegmentKeyHandle {
	return o.l2segment_key_handle
}

func (o *EnicClassicInfo) Getnative_l2segment_id() uint64 {
	return o.native_l2segment_id
}

func (o *EnicClassicInfo) Setnative_l2segment_id(val uint64) {
	o.native_l2segment_id = val
	o.bubbleSave()
}

func (o *EnicClassicInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EnicClassicInfo) save() {
}

func NewEnicClassicInfo(sdkClient clientApi.Client) *EnicClassicInfo {
	w := &EnicClassicInfo{}
	w.sdkClient = sdkClient
	w.l2segment_key_handle = childNewL2SegmentKeyHandle(w, sdkClient)
	return w
}

func childNewEnicClassicInfo(parent delphiWrapper, sdkClient clientApi.Client) *EnicClassicInfo {
	w := NewEnicClassicInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewEnicClassicInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EnicClassicInfo) *EnicClassicInfo {
	w := childNewEnicClassicInfo(parent, sdkClient)
	w.l2segment_key_handle = childNewL2SegmentKeyHandleWithValue(w, sdkClient, value.l2segment_key_handle)
	w.native_l2segment_id = value.native_l2segment_id
	return w
}

func (o *EnicClassicInfo) GetProtoMsg() *EnicClassicInfo_ {
	if o == nil {
		return &EnicClassicInfo_{}
	}

	return &EnicClassicInfo_{
		L2SegmentKeyHandle: o.l2segment_key_handle.GetProtoMsg(),
		NativeL2SegmentId:  o.native_l2segment_id,
	}
}

func (o *EnicClassicInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEnicClassicInfoFromMessage(msg *EnicClassicInfo_) *EnicClassicInfo {
	if msg == nil {
		return &EnicClassicInfo{}
	}

	return &EnicClassicInfo{
		l2segment_key_handle: newL2SegmentKeyHandleFromMessage(msg.L2SegmentKeyHandle),
		native_l2segment_id:  msg.NativeL2SegmentId,
	}
}

type LifTxStats struct {
	sdkClient           clientApi.Client
	parent              delphiWrapper
	frames_ok           uint64
	unicast_frames_ok   uint64
	multicast_brames_ok uint64
	broadcast_brames_ok uint64
	bytes_ok            uint64
	unicast_bytes_ok    uint64
	multicast_bytes_ok  uint64
	broadcast_bytes_ok  uint64
	tso                 uint64
}

func (o *LifTxStats) Getframes_ok() uint64 {
	return o.frames_ok
}

func (o *LifTxStats) Setframes_ok(val uint64) {
	o.frames_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getunicast_frames_ok() uint64 {
	return o.unicast_frames_ok
}

func (o *LifTxStats) Setunicast_frames_ok(val uint64) {
	o.unicast_frames_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getmulticast_brames_ok() uint64 {
	return o.multicast_brames_ok
}

func (o *LifTxStats) Setmulticast_brames_ok(val uint64) {
	o.multicast_brames_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getbroadcast_brames_ok() uint64 {
	return o.broadcast_brames_ok
}

func (o *LifTxStats) Setbroadcast_brames_ok(val uint64) {
	o.broadcast_brames_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getbytes_ok() uint64 {
	return o.bytes_ok
}

func (o *LifTxStats) Setbytes_ok(val uint64) {
	o.bytes_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getunicast_bytes_ok() uint64 {
	return o.unicast_bytes_ok
}

func (o *LifTxStats) Setunicast_bytes_ok(val uint64) {
	o.unicast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getmulticast_bytes_ok() uint64 {
	return o.multicast_bytes_ok
}

func (o *LifTxStats) Setmulticast_bytes_ok(val uint64) {
	o.multicast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Getbroadcast_bytes_ok() uint64 {
	return o.broadcast_bytes_ok
}

func (o *LifTxStats) Setbroadcast_bytes_ok(val uint64) {
	o.broadcast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifTxStats) Gettso() uint64 {
	return o.tso
}

func (o *LifTxStats) Settso(val uint64) {
	o.tso = val
	o.bubbleSave()
}

func (o *LifTxStats) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifTxStats) save() {
}

func NewLifTxStats(sdkClient clientApi.Client) *LifTxStats {
	w := &LifTxStats{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifTxStats(parent delphiWrapper, sdkClient clientApi.Client) *LifTxStats {
	w := NewLifTxStats(sdkClient)
	w.parent = parent
	return w
}

func childNewLifTxStatsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifTxStats) *LifTxStats {
	w := childNewLifTxStats(parent, sdkClient)
	w.frames_ok = value.frames_ok
	w.unicast_frames_ok = value.unicast_frames_ok
	w.multicast_brames_ok = value.multicast_brames_ok
	w.broadcast_brames_ok = value.broadcast_brames_ok
	w.bytes_ok = value.bytes_ok
	w.unicast_bytes_ok = value.unicast_bytes_ok
	w.multicast_bytes_ok = value.multicast_bytes_ok
	w.broadcast_bytes_ok = value.broadcast_bytes_ok
	w.tso = value.tso
	return w
}

func (o *LifTxStats) GetProtoMsg() *LifTxStats_ {
	if o == nil {
		return &LifTxStats_{}
	}

	return &LifTxStats_{
		FramesOk:          o.frames_ok,
		UnicastFramesOk:   o.unicast_frames_ok,
		MulticastBramesOk: o.multicast_brames_ok,
		BroadcastBramesOk: o.broadcast_brames_ok,
		BytesOk:           o.bytes_ok,
		UnicastBytesOk:    o.unicast_bytes_ok,
		MulticastBytesOk:  o.multicast_bytes_ok,
		BroadcastBytesOk:  o.broadcast_bytes_ok,
		Tso:               o.tso,
	}
}

func (o *LifTxStats) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifTxStatsFromMessage(msg *LifTxStats_) *LifTxStats {
	if msg == nil {
		return &LifTxStats{}
	}

	return &LifTxStats{
		frames_ok:           msg.FramesOk,
		unicast_frames_ok:   msg.UnicastFramesOk,
		multicast_brames_ok: msg.MulticastBramesOk,
		broadcast_brames_ok: msg.BroadcastBramesOk,
		bytes_ok:            msg.BytesOk,
		unicast_bytes_ok:    msg.UnicastBytesOk,
		multicast_bytes_ok:  msg.MulticastBytesOk,
		broadcast_bytes_ok:  msg.BroadcastBytesOk,
		tso:                 msg.Tso,
	}
}

type IfEnicInfo struct {
	sdkClient                   clientApi.Client
	parent                      delphiWrapper
	enic_type                   IntfEnicType
	lif_key_or_handle           *LifKeyHandle
	pinned_uplink_if_key_handle *InterfaceKeyHandle
	enic_info                   *EnicInfo
	classic_enic_info           *EnicClassicInfo
}

func (o *IfEnicInfo) Getenic_type() IntfEnicType {
	return o.enic_type
}

func (o *IfEnicInfo) Setenic_type(val IntfEnicType) {
	o.enic_type = val
	o.bubbleSave()
}

func (o *IfEnicInfo) Getlif_key_or_handle() *LifKeyHandle {
	return o.lif_key_or_handle
}

func (o *IfEnicInfo) Getpinned_uplink_if_key_handle() *InterfaceKeyHandle {
	return o.pinned_uplink_if_key_handle
}

func (o *IfEnicInfo) Getenic_info() *EnicInfo {
	return o.enic_info
}

func (o *IfEnicInfo) Getclassic_enic_info() *EnicClassicInfo {
	return o.classic_enic_info
}

func (o *IfEnicInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfEnicInfo) save() {
}

func NewIfEnicInfo(sdkClient clientApi.Client) *IfEnicInfo {
	w := &IfEnicInfo{}
	w.sdkClient = sdkClient
	w.lif_key_or_handle = childNewLifKeyHandle(w, sdkClient)
	w.pinned_uplink_if_key_handle = childNewInterfaceKeyHandle(w, sdkClient)
	w.enic_info = childNewEnicInfo(w, sdkClient)
	w.classic_enic_info = childNewEnicClassicInfo(w, sdkClient)
	return w
}

func childNewIfEnicInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfEnicInfo {
	w := NewIfEnicInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfEnicInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfEnicInfo) *IfEnicInfo {
	w := childNewIfEnicInfo(parent, sdkClient)
	w.enic_type = value.enic_type
	w.lif_key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.lif_key_or_handle)
	w.pinned_uplink_if_key_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.pinned_uplink_if_key_handle)
	w.enic_info = childNewEnicInfoWithValue(w, sdkClient, value.enic_info)
	w.classic_enic_info = childNewEnicClassicInfoWithValue(w, sdkClient, value.classic_enic_info)
	return w
}

func (o *IfEnicInfo) GetProtoMsg() *IfEnicInfo_ {
	if o == nil {
		return &IfEnicInfo_{}
	}

	return &IfEnicInfo_{
		EnicType:                o.enic_type,
		LifKeyOrHandle:          o.lif_key_or_handle.GetProtoMsg(),
		PinnedUplinkIfKeyHandle: o.pinned_uplink_if_key_handle.GetProtoMsg(),
		EnicInfo:                o.enic_info.GetProtoMsg(),
		ClassicEnicInfo:         o.classic_enic_info.GetProtoMsg(),
	}
}

func (o *IfEnicInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfEnicInfoFromMessage(msg *IfEnicInfo_) *IfEnicInfo {
	if msg == nil {
		return &IfEnicInfo{}
	}

	return &IfEnicInfo{
		enic_type:                   msg.EnicType,
		lif_key_or_handle:           newLifKeyHandleFromMessage(msg.LifKeyOrHandle),
		pinned_uplink_if_key_handle: newInterfaceKeyHandleFromMessage(msg.PinnedUplinkIfKeyHandle),
		enic_info:                   newEnicInfoFromMessage(msg.EnicInfo),
		classic_enic_info:           newEnicClassicInfoFromMessage(msg.ClassicEnicInfo),
	}
}

type EnicL2SegInfo struct {
	sdkClient               clientApi.Client
	parent                  delphiWrapper
	l2segment_key_or_handle *L2SegmentKeyHandle
	inp_prop_idx            uint32
}

func (o *EnicL2SegInfo) Getl2segment_key_or_handle() *L2SegmentKeyHandle {
	return o.l2segment_key_or_handle
}

func (o *EnicL2SegInfo) Getinp_prop_idx() uint32 {
	return o.inp_prop_idx
}

func (o *EnicL2SegInfo) Setinp_prop_idx(val uint32) {
	o.inp_prop_idx = val
	o.bubbleSave()
}

func (o *EnicL2SegInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EnicL2SegInfo) save() {
}

func NewEnicL2SegInfo(sdkClient clientApi.Client) *EnicL2SegInfo {
	w := &EnicL2SegInfo{}
	w.sdkClient = sdkClient
	w.l2segment_key_or_handle = childNewL2SegmentKeyHandle(w, sdkClient)
	return w
}

func childNewEnicL2SegInfo(parent delphiWrapper, sdkClient clientApi.Client) *EnicL2SegInfo {
	w := NewEnicL2SegInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewEnicL2SegInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EnicL2SegInfo) *EnicL2SegInfo {
	w := childNewEnicL2SegInfo(parent, sdkClient)
	w.l2segment_key_or_handle = childNewL2SegmentKeyHandleWithValue(w, sdkClient, value.l2segment_key_or_handle)
	w.inp_prop_idx = value.inp_prop_idx
	return w
}

func (o *EnicL2SegInfo) GetProtoMsg() *EnicL2SegInfo_ {
	if o == nil {
		return &EnicL2SegInfo_{}
	}

	return &EnicL2SegInfo_{
		L2SegmentKeyOrHandle: o.l2segment_key_or_handle.GetProtoMsg(),
		InpPropIdx:           o.inp_prop_idx,
	}
}

func (o *EnicL2SegInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEnicL2SegInfoFromMessage(msg *EnicL2SegInfo_) *EnicL2SegInfo {
	if msg == nil {
		return &EnicL2SegInfo{}
	}

	return &EnicL2SegInfo{
		l2segment_key_or_handle: newL2SegmentKeyHandleFromMessage(msg.L2SegmentKeyOrHandle),
		inp_prop_idx:            msg.InpPropIdx,
	}
}

type TunnelIfResponseInfo struct {
	sdkClient       clientApi.Client
	parent          delphiWrapper
	inp_map_nat_idx uint32
	inp_map_tnl_idx uint32
	tunnel_rw_idx   uint32
}

func (o *TunnelIfResponseInfo) Getinp_map_nat_idx() uint32 {
	return o.inp_map_nat_idx
}

func (o *TunnelIfResponseInfo) Setinp_map_nat_idx(val uint32) {
	o.inp_map_nat_idx = val
	o.bubbleSave()
}

func (o *TunnelIfResponseInfo) Getinp_map_tnl_idx() uint32 {
	return o.inp_map_tnl_idx
}

func (o *TunnelIfResponseInfo) Setinp_map_tnl_idx(val uint32) {
	o.inp_map_tnl_idx = val
	o.bubbleSave()
}

func (o *TunnelIfResponseInfo) Gettunnel_rw_idx() uint32 {
	return o.tunnel_rw_idx
}

func (o *TunnelIfResponseInfo) Settunnel_rw_idx(val uint32) {
	o.tunnel_rw_idx = val
	o.bubbleSave()
}

func (o *TunnelIfResponseInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *TunnelIfResponseInfo) save() {
}

func NewTunnelIfResponseInfo(sdkClient clientApi.Client) *TunnelIfResponseInfo {
	w := &TunnelIfResponseInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewTunnelIfResponseInfo(parent delphiWrapper, sdkClient clientApi.Client) *TunnelIfResponseInfo {
	w := NewTunnelIfResponseInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewTunnelIfResponseInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *TunnelIfResponseInfo) *TunnelIfResponseInfo {
	w := childNewTunnelIfResponseInfo(parent, sdkClient)
	w.inp_map_nat_idx = value.inp_map_nat_idx
	w.inp_map_tnl_idx = value.inp_map_tnl_idx
	w.tunnel_rw_idx = value.tunnel_rw_idx
	return w
}

func (o *TunnelIfResponseInfo) GetProtoMsg() *TunnelIfResponseInfo_ {
	if o == nil {
		return &TunnelIfResponseInfo_{}
	}

	return &TunnelIfResponseInfo_{
		InpMapNatIdx: o.inp_map_nat_idx,
		InpMapTnlIdx: o.inp_map_tnl_idx,
		TunnelRwIdx:  o.tunnel_rw_idx,
	}
}

func (o *TunnelIfResponseInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newTunnelIfResponseInfoFromMessage(msg *TunnelIfResponseInfo_) *TunnelIfResponseInfo {
	if msg == nil {
		return &TunnelIfResponseInfo{}
	}

	return &TunnelIfResponseInfo{
		inp_map_nat_idx: msg.InpMapNatIdx,
		inp_map_tnl_idx: msg.InpMapTnlIdx,
		tunnel_rw_idx:   msg.TunnelRwIdx,
	}
}

type LifKeyHandle struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	lifId     uint64
	lifHandle uint64
}

func (o *LifKeyHandle) GetLifId() uint64 {
	return o.lifId
}

func (o *LifKeyHandle) SetLifId(val uint64) {
	o.lifId = val
	o.bubbleSave()
}

func (o *LifKeyHandle) GetLifHandle() uint64 {
	return o.lifHandle
}

func (o *LifKeyHandle) SetLifHandle(val uint64) {
	o.lifHandle = val
	o.bubbleSave()
}

func (o *LifKeyHandle) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifKeyHandle) save() {
}

func NewLifKeyHandle(sdkClient clientApi.Client) *LifKeyHandle {
	w := &LifKeyHandle{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifKeyHandle(parent delphiWrapper, sdkClient clientApi.Client) *LifKeyHandle {
	w := NewLifKeyHandle(sdkClient)
	w.parent = parent
	return w
}

func childNewLifKeyHandleWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifKeyHandle) *LifKeyHandle {
	w := childNewLifKeyHandle(parent, sdkClient)
	w.lifId = value.lifId
	w.lifHandle = value.lifHandle
	return w
}

func (o *LifKeyHandle) GetProtoMsg() *LifKeyHandle_ {
	if o == nil {
		return &LifKeyHandle_{}
	}

	return &LifKeyHandle_{
		LifId:     o.lifId,
		LifHandle: o.lifHandle,
	}
}

func (o *LifKeyHandle) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifKeyHandleFromMessage(msg *LifKeyHandle_) *LifKeyHandle {
	if msg == nil {
		return &LifKeyHandle{}
	}

	return &LifKeyHandle{
		lifId:     msg.LifId,
		lifHandle: msg.LifHandle,
	}
}

type InterfaceKeyHandle struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	interfaceId uint64
	ifHandle    uint64
}

func (o *InterfaceKeyHandle) GetInterfaceId() uint64 {
	return o.interfaceId
}

func (o *InterfaceKeyHandle) SetInterfaceId(val uint64) {
	o.interfaceId = val
	o.bubbleSave()
}

func (o *InterfaceKeyHandle) GetIfHandle() uint64 {
	return o.ifHandle
}

func (o *InterfaceKeyHandle) SetIfHandle(val uint64) {
	o.ifHandle = val
	o.bubbleSave()
}

func (o *InterfaceKeyHandle) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceKeyHandle) save() {
}

func NewInterfaceKeyHandle(sdkClient clientApi.Client) *InterfaceKeyHandle {
	w := &InterfaceKeyHandle{}
	w.sdkClient = sdkClient
	return w
}

func childNewInterfaceKeyHandle(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceKeyHandle {
	w := NewInterfaceKeyHandle(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceKeyHandleWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceKeyHandle) *InterfaceKeyHandle {
	w := childNewInterfaceKeyHandle(parent, sdkClient)
	w.interfaceId = value.interfaceId
	w.ifHandle = value.ifHandle
	return w
}

func (o *InterfaceKeyHandle) GetProtoMsg() *InterfaceKeyHandle_ {
	if o == nil {
		return &InterfaceKeyHandle_{}
	}

	return &InterfaceKeyHandle_{
		InterfaceId: o.interfaceId,
		IfHandle:    o.ifHandle,
	}
}

func (o *InterfaceKeyHandle) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceKeyHandleFromMessage(msg *InterfaceKeyHandle_) *InterfaceKeyHandle {
	if msg == nil {
		return &InterfaceKeyHandle{}
	}

	return &InterfaceKeyHandle{
		interfaceId: msg.InterfaceId,
		ifHandle:    msg.IfHandle,
	}
}

type LifResponse struct {
	sdkClient       clientApi.Client
	parent          delphiWrapper
	api_status      ApiStatus
	status          *LifStatus
	qstate          *LifQState
	rdma_data_valid bool
	rdma_data       *LifRdmaData
}

func (o *LifResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *LifResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *LifResponse) Getstatus() *LifStatus {
	return o.status
}

func (o *LifResponse) Getqstate() *LifQState {
	return o.qstate
}

func (o *LifResponse) Getrdma_data_valid() bool {
	return o.rdma_data_valid
}

func (o *LifResponse) Setrdma_data_valid(val bool) {
	o.rdma_data_valid = val
	o.bubbleSave()
}

func (o *LifResponse) Getrdma_data() *LifRdmaData {
	return o.rdma_data
}

func (o *LifResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifResponse) save() {
}

func NewLifResponse(sdkClient clientApi.Client) *LifResponse {
	w := &LifResponse{}
	w.sdkClient = sdkClient
	w.status = childNewLifStatus(w, sdkClient)
	w.qstate = childNewLifQState(w, sdkClient)
	w.rdma_data = childNewLifRdmaData(w, sdkClient)
	return w
}

func childNewLifResponse(parent delphiWrapper, sdkClient clientApi.Client) *LifResponse {
	w := NewLifResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewLifResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifResponse) *LifResponse {
	w := childNewLifResponse(parent, sdkClient)
	w.api_status = value.api_status
	w.status = childNewLifStatusWithValue(w, sdkClient, value.status)
	w.qstate = childNewLifQStateWithValue(w, sdkClient, value.qstate)
	w.rdma_data_valid = value.rdma_data_valid
	w.rdma_data = childNewLifRdmaDataWithValue(w, sdkClient, value.rdma_data)
	return w
}

func (o *LifResponse) GetProtoMsg() *LifResponse_ {
	if o == nil {
		return &LifResponse_{}
	}

	return &LifResponse_{
		ApiStatus:     o.api_status,
		Status:        o.status.GetProtoMsg(),
		Qstate:        o.qstate.GetProtoMsg(),
		RdmaDataValid: o.rdma_data_valid,
		RdmaData:      o.rdma_data.GetProtoMsg(),
	}
}

func (o *LifResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifResponseFromMessage(msg *LifResponse_) *LifResponse {
	if msg == nil {
		return &LifResponse{}
	}

	return &LifResponse{
		api_status:      msg.ApiStatus,
		status:          newLifStatusFromMessage(msg.Status),
		qstate:          newLifQStateFromMessage(msg.Qstate),
		rdma_data_valid: msg.RdmaDataValid,
		rdma_data:       newLifRdmaDataFromMessage(msg.RdmaData),
	}
}

type SetQStateRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	reqs      *QStateSetReq
}

func (o *SetQStateRequestMsg) Getreqs() *QStateSetReq {
	return o.reqs
}

func (o *SetQStateRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *SetQStateRequestMsg) save() {
}

func NewSetQStateRequestMsg(sdkClient clientApi.Client) *SetQStateRequestMsg {
	w := &SetQStateRequestMsg{}
	w.sdkClient = sdkClient
	w.reqs = childNewQStateSetReq(w, sdkClient)
	return w
}

func childNewSetQStateRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *SetQStateRequestMsg {
	w := NewSetQStateRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewSetQStateRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *SetQStateRequestMsg) *SetQStateRequestMsg {
	w := childNewSetQStateRequestMsg(parent, sdkClient)
	w.reqs = childNewQStateSetReqWithValue(w, sdkClient, value.reqs)
	return w
}

func (o *SetQStateRequestMsg) GetProtoMsg() *SetQStateRequestMsg_ {
	if o == nil {
		return &SetQStateRequestMsg_{}
	}

	return &SetQStateRequestMsg_{
		Reqs: o.reqs.GetProtoMsg(),
	}
}

func (o *SetQStateRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newSetQStateRequestMsgFromMessage(msg *SetQStateRequestMsg_) *SetQStateRequestMsg {
	if msg == nil {
		return &SetQStateRequestMsg{}
	}

	return &SetQStateRequestMsg{
		reqs: newQStateSetReqFromMessage(msg.Reqs),
	}
}

type InterfaceStats struct {
	sdkClient      clientApi.Client
	parent         delphiWrapper
	num_tx_packets uint32
	num_tx_bytes   uint32
	num_rx_packets uint32
	num_rx_bytes   uint32
}

func (o *InterfaceStats) Getnum_tx_packets() uint32 {
	return o.num_tx_packets
}

func (o *InterfaceStats) Setnum_tx_packets(val uint32) {
	o.num_tx_packets = val
	o.bubbleSave()
}

func (o *InterfaceStats) Getnum_tx_bytes() uint32 {
	return o.num_tx_bytes
}

func (o *InterfaceStats) Setnum_tx_bytes(val uint32) {
	o.num_tx_bytes = val
	o.bubbleSave()
}

func (o *InterfaceStats) Getnum_rx_packets() uint32 {
	return o.num_rx_packets
}

func (o *InterfaceStats) Setnum_rx_packets(val uint32) {
	o.num_rx_packets = val
	o.bubbleSave()
}

func (o *InterfaceStats) Getnum_rx_bytes() uint32 {
	return o.num_rx_bytes
}

func (o *InterfaceStats) Setnum_rx_bytes(val uint32) {
	o.num_rx_bytes = val
	o.bubbleSave()
}

func (o *InterfaceStats) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceStats) save() {
}

func NewInterfaceStats(sdkClient clientApi.Client) *InterfaceStats {
	w := &InterfaceStats{}
	w.sdkClient = sdkClient
	return w
}

func childNewInterfaceStats(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceStats {
	w := NewInterfaceStats(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceStatsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceStats) *InterfaceStats {
	w := childNewInterfaceStats(parent, sdkClient)
	w.num_tx_packets = value.num_tx_packets
	w.num_tx_bytes = value.num_tx_bytes
	w.num_rx_packets = value.num_rx_packets
	w.num_rx_bytes = value.num_rx_bytes
	return w
}

func (o *InterfaceStats) GetProtoMsg() *InterfaceStats_ {
	if o == nil {
		return &InterfaceStats_{}
	}

	return &InterfaceStats_{
		NumTxPackets: o.num_tx_packets,
		NumTxBytes:   o.num_tx_bytes,
		NumRxPackets: o.num_rx_packets,
		NumRxBytes:   o.num_rx_bytes,
	}
}

func (o *InterfaceStats) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceStatsFromMessage(msg *InterfaceStats_) *InterfaceStats {
	if msg == nil {
		return &InterfaceStats{}
	}

	return &InterfaceStats{
		num_tx_packets: msg.NumTxPackets,
		num_tx_bytes:   msg.NumTxBytes,
		num_rx_packets: msg.NumRxPackets,
		num_rx_bytes:   msg.NumRxBytes,
	}
}

type CpuIfResponseInfo struct {
	sdkClient    clientApi.Client
	parent       delphiWrapper
	cpu_lport_id uint32
}

func (o *CpuIfResponseInfo) Getcpu_lport_id() uint32 {
	return o.cpu_lport_id
}

func (o *CpuIfResponseInfo) Setcpu_lport_id(val uint32) {
	o.cpu_lport_id = val
	o.bubbleSave()
}

func (o *CpuIfResponseInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *CpuIfResponseInfo) save() {
}

func NewCpuIfResponseInfo(sdkClient clientApi.Client) *CpuIfResponseInfo {
	w := &CpuIfResponseInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewCpuIfResponseInfo(parent delphiWrapper, sdkClient clientApi.Client) *CpuIfResponseInfo {
	w := NewCpuIfResponseInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewCpuIfResponseInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *CpuIfResponseInfo) *CpuIfResponseInfo {
	w := childNewCpuIfResponseInfo(parent, sdkClient)
	w.cpu_lport_id = value.cpu_lport_id
	return w
}

func (o *CpuIfResponseInfo) GetProtoMsg() *CpuIfResponseInfo_ {
	if o == nil {
		return &CpuIfResponseInfo_{}
	}

	return &CpuIfResponseInfo_{
		CpuLportId: o.cpu_lport_id,
	}
}

func (o *CpuIfResponseInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newCpuIfResponseInfoFromMessage(msg *CpuIfResponseInfo_) *CpuIfResponseInfo {
	if msg == nil {
		return &CpuIfResponseInfo{}
	}

	return &CpuIfResponseInfo{
		cpu_lport_id: msg.CpuLportId,
	}
}

type IPRange struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	low_ipaddr  *IPAddress
	high_ipaddr *IPAddress
}

func (o *IPRange) Getlow_ipaddr() *IPAddress {
	return o.low_ipaddr
}

func (o *IPRange) Gethigh_ipaddr() *IPAddress {
	return o.high_ipaddr
}

func (o *IPRange) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IPRange) save() {
}

func NewIPRange(sdkClient clientApi.Client) *IPRange {
	w := &IPRange{}
	w.sdkClient = sdkClient
	w.low_ipaddr = childNewIPAddress(w, sdkClient)
	w.high_ipaddr = childNewIPAddress(w, sdkClient)
	return w
}

func childNewIPRange(parent delphiWrapper, sdkClient clientApi.Client) *IPRange {
	w := NewIPRange(sdkClient)
	w.parent = parent
	return w
}

func childNewIPRangeWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IPRange) *IPRange {
	w := childNewIPRange(parent, sdkClient)
	w.low_ipaddr = childNewIPAddressWithValue(w, sdkClient, value.low_ipaddr)
	w.high_ipaddr = childNewIPAddressWithValue(w, sdkClient, value.high_ipaddr)
	return w
}

func (o *IPRange) GetProtoMsg() *IPRange_ {
	if o == nil {
		return &IPRange_{}
	}

	return &IPRange_{
		LowIpaddr:  o.low_ipaddr.GetProtoMsg(),
		HighIpaddr: o.high_ipaddr.GetProtoMsg(),
	}
}

func (o *IPRange) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIPRangeFromMessage(msg *IPRange_) *IPRange {
	if msg == nil {
		return &IPRange{}
	}

	return &IPRange{
		low_ipaddr:  newIPAddressFromMessage(msg.LowIpaddr),
		high_ipaddr: newIPAddressFromMessage(msg.HighIpaddr),
	}
}

type IPSubnet struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	ipv4_subnet *IPPrefix
	ipv6_subnet *IPPrefix
}

func (o *IPSubnet) Getipv4_subnet() *IPPrefix {
	return o.ipv4_subnet
}

func (o *IPSubnet) Getipv6_subnet() *IPPrefix {
	return o.ipv6_subnet
}

func (o *IPSubnet) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IPSubnet) save() {
}

func NewIPSubnet(sdkClient clientApi.Client) *IPSubnet {
	w := &IPSubnet{}
	w.sdkClient = sdkClient
	w.ipv4_subnet = childNewIPPrefix(w, sdkClient)
	w.ipv6_subnet = childNewIPPrefix(w, sdkClient)
	return w
}

func childNewIPSubnet(parent delphiWrapper, sdkClient clientApi.Client) *IPSubnet {
	w := NewIPSubnet(sdkClient)
	w.parent = parent
	return w
}

func childNewIPSubnetWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IPSubnet) *IPSubnet {
	w := childNewIPSubnet(parent, sdkClient)
	w.ipv4_subnet = childNewIPPrefixWithValue(w, sdkClient, value.ipv4_subnet)
	w.ipv6_subnet = childNewIPPrefixWithValue(w, sdkClient, value.ipv6_subnet)
	return w
}

func (o *IPSubnet) GetProtoMsg() *IPSubnet_ {
	if o == nil {
		return &IPSubnet_{}
	}

	return &IPSubnet_{
		Ipv4Subnet: o.ipv4_subnet.GetProtoMsg(),
		Ipv6Subnet: o.ipv6_subnet.GetProtoMsg(),
	}
}

func (o *IPSubnet) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIPSubnetFromMessage(msg *IPSubnet_) *IPSubnet {
	if msg == nil {
		return &IPSubnet{}
	}

	return &IPSubnet{
		ipv4_subnet: newIPPrefixFromMessage(msg.Ipv4Subnet),
		ipv6_subnet: newIPPrefixFromMessage(msg.Ipv6Subnet),
	}
}

type EgressDropReasons struct {
	sdkClient           clientApi.Client
	parent              delphiWrapper
	drop_output_mapping bool
	drop_prune_src_port bool
	drop_mirror         bool
	drop_policer        bool
	drop_copp           bool
	drop_checksum_err   bool
}

func (o *EgressDropReasons) Getdrop_output_mapping() bool {
	return o.drop_output_mapping
}

func (o *EgressDropReasons) Setdrop_output_mapping(val bool) {
	o.drop_output_mapping = val
	o.bubbleSave()
}

func (o *EgressDropReasons) Getdrop_prune_src_port() bool {
	return o.drop_prune_src_port
}

func (o *EgressDropReasons) Setdrop_prune_src_port(val bool) {
	o.drop_prune_src_port = val
	o.bubbleSave()
}

func (o *EgressDropReasons) Getdrop_mirror() bool {
	return o.drop_mirror
}

func (o *EgressDropReasons) Setdrop_mirror(val bool) {
	o.drop_mirror = val
	o.bubbleSave()
}

func (o *EgressDropReasons) Getdrop_policer() bool {
	return o.drop_policer
}

func (o *EgressDropReasons) Setdrop_policer(val bool) {
	o.drop_policer = val
	o.bubbleSave()
}

func (o *EgressDropReasons) Getdrop_copp() bool {
	return o.drop_copp
}

func (o *EgressDropReasons) Setdrop_copp(val bool) {
	o.drop_copp = val
	o.bubbleSave()
}

func (o *EgressDropReasons) Getdrop_checksum_err() bool {
	return o.drop_checksum_err
}

func (o *EgressDropReasons) Setdrop_checksum_err(val bool) {
	o.drop_checksum_err = val
	o.bubbleSave()
}

func (o *EgressDropReasons) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EgressDropReasons) save() {
}

func NewEgressDropReasons(sdkClient clientApi.Client) *EgressDropReasons {
	w := &EgressDropReasons{}
	w.sdkClient = sdkClient
	return w
}

func childNewEgressDropReasons(parent delphiWrapper, sdkClient clientApi.Client) *EgressDropReasons {
	w := NewEgressDropReasons(sdkClient)
	w.parent = parent
	return w
}

func childNewEgressDropReasonsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EgressDropReasons) *EgressDropReasons {
	w := childNewEgressDropReasons(parent, sdkClient)
	w.drop_output_mapping = value.drop_output_mapping
	w.drop_prune_src_port = value.drop_prune_src_port
	w.drop_mirror = value.drop_mirror
	w.drop_policer = value.drop_policer
	w.drop_copp = value.drop_copp
	w.drop_checksum_err = value.drop_checksum_err
	return w
}

func (o *EgressDropReasons) GetProtoMsg() *EgressDropReasons_ {
	if o == nil {
		return &EgressDropReasons_{}
	}

	return &EgressDropReasons_{
		DropOutputMapping: o.drop_output_mapping,
		DropPruneSrcPort:  o.drop_prune_src_port,
		DropMirror:        o.drop_mirror,
		DropPolicer:       o.drop_policer,
		DropCopp:          o.drop_copp,
		DropChecksumErr:   o.drop_checksum_err,
	}
}

func (o *EgressDropReasons) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEgressDropReasonsFromMessage(msg *EgressDropReasons_) *EgressDropReasons {
	if msg == nil {
		return &EgressDropReasons{}
	}

	return &EgressDropReasons{
		drop_output_mapping: msg.DropOutputMapping,
		drop_prune_src_port: msg.DropPruneSrcPort,
		drop_mirror:         msg.DropMirror,
		drop_policer:        msg.DropPolicer,
		drop_copp:           msg.DropCopp,
		drop_checksum_err:   msg.DropChecksumErr,
	}
}

type LifDeleteRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *LifDeleteRequest
}

func (o *LifDeleteRequestMsg) Getrequest() *LifDeleteRequest {
	return o.request
}

func (o *LifDeleteRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifDeleteRequestMsg) save() {
}

func NewLifDeleteRequestMsg(sdkClient clientApi.Client) *LifDeleteRequestMsg {
	w := &LifDeleteRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewLifDeleteRequest(w, sdkClient)
	return w
}

func childNewLifDeleteRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *LifDeleteRequestMsg {
	w := NewLifDeleteRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewLifDeleteRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifDeleteRequestMsg) *LifDeleteRequestMsg {
	w := childNewLifDeleteRequestMsg(parent, sdkClient)
	w.request = childNewLifDeleteRequestWithValue(w, sdkClient, value.request)
	return w
}

func (o *LifDeleteRequestMsg) GetProtoMsg() *LifDeleteRequestMsg_ {
	if o == nil {
		return &LifDeleteRequestMsg_{}
	}

	return &LifDeleteRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *LifDeleteRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifDeleteRequestMsgFromMessage(msg *LifDeleteRequestMsg_) *LifDeleteRequestMsg {
	if msg == nil {
		return &LifDeleteRequestMsg{}
	}

	return &LifDeleteRequestMsg{
		request: newLifDeleteRequestFromMessage(msg.Request),
	}
}

type LifQStateMapEntry struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	type_num  uint32
	size      uint32
	entries   uint32
	purpose   LifQueuePurpose
}

func (o *LifQStateMapEntry) Gettype_num() uint32 {
	return o.type_num
}

func (o *LifQStateMapEntry) Settype_num(val uint32) {
	o.type_num = val
	o.bubbleSave()
}

func (o *LifQStateMapEntry) Getsize() uint32 {
	return o.size
}

func (o *LifQStateMapEntry) Setsize(val uint32) {
	o.size = val
	o.bubbleSave()
}

func (o *LifQStateMapEntry) Getentries() uint32 {
	return o.entries
}

func (o *LifQStateMapEntry) Setentries(val uint32) {
	o.entries = val
	o.bubbleSave()
}

func (o *LifQStateMapEntry) Getpurpose() LifQueuePurpose {
	return o.purpose
}

func (o *LifQStateMapEntry) Setpurpose(val LifQueuePurpose) {
	o.purpose = val
	o.bubbleSave()
}

func (o *LifQStateMapEntry) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifQStateMapEntry) save() {
}

func NewLifQStateMapEntry(sdkClient clientApi.Client) *LifQStateMapEntry {
	w := &LifQStateMapEntry{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifQStateMapEntry(parent delphiWrapper, sdkClient clientApi.Client) *LifQStateMapEntry {
	w := NewLifQStateMapEntry(sdkClient)
	w.parent = parent
	return w
}

func childNewLifQStateMapEntryWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifQStateMapEntry) *LifQStateMapEntry {
	w := childNewLifQStateMapEntry(parent, sdkClient)
	w.type_num = value.type_num
	w.size = value.size
	w.entries = value.entries
	w.purpose = value.purpose
	return w
}

func (o *LifQStateMapEntry) GetProtoMsg() *LifQStateMapEntry_ {
	if o == nil {
		return &LifQStateMapEntry_{}
	}

	return &LifQStateMapEntry_{
		TypeNum: o.type_num,
		Size:    o.size,
		Entries: o.entries,
		Purpose: o.purpose,
	}
}

func (o *LifQStateMapEntry) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifQStateMapEntryFromMessage(msg *LifQStateMapEntry_) *LifQStateMapEntry {
	if msg == nil {
		return &LifQStateMapEntry{}
	}

	return &LifQStateMapEntry{
		type_num: msg.TypeNum,
		size:     msg.Size,
		entries:  msg.Entries,
		purpose:  msg.Purpose,
	}
}

type LifSpec struct {
	sdkClient                   clientApi.Client
	parent                      delphiWrapper
	meta                        *delphi.ObjectMeta
	key_or_handle               *LifKeyHandle
	pinned_uplink_if_key_handle *InterfaceKeyHandle
	admin_status                IntfStatus
	lif_qstate_map              *LifQStateMapEntry
	vlan_strip_en               bool
	vlan_insert_en              bool
	enable_rdma                 bool
	is_management               bool
	packet_filter               *PktFilter
	hw_lif_id                   uint32
	rdma_max_keys               uint32
	rdma_max_ahs                uint32
	rdma_max_pt_entries         uint32
	lif_qstate                  *QStateSetReq
	rss                         *LifRssSpec
}

func (o *LifSpec) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *LifSpec) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *LifSpec) Getkey_or_handle() *LifKeyHandle {
	return o.key_or_handle
}

func (o *LifSpec) Getpinned_uplink_if_key_handle() *InterfaceKeyHandle {
	return o.pinned_uplink_if_key_handle
}

func (o *LifSpec) Getadmin_status() IntfStatus {
	return o.admin_status
}

func (o *LifSpec) Setadmin_status(val IntfStatus) {
	o.admin_status = val
	o.bubbleSave()
}

func (o *LifSpec) Getlif_qstate_map() *LifQStateMapEntry {
	return o.lif_qstate_map
}

func (o *LifSpec) Getvlan_strip_en() bool {
	return o.vlan_strip_en
}

func (o *LifSpec) Setvlan_strip_en(val bool) {
	o.vlan_strip_en = val
	o.bubbleSave()
}

func (o *LifSpec) Getvlan_insert_en() bool {
	return o.vlan_insert_en
}

func (o *LifSpec) Setvlan_insert_en(val bool) {
	o.vlan_insert_en = val
	o.bubbleSave()
}

func (o *LifSpec) Getenable_rdma() bool {
	return o.enable_rdma
}

func (o *LifSpec) Setenable_rdma(val bool) {
	o.enable_rdma = val
	o.bubbleSave()
}

func (o *LifSpec) Getis_management() bool {
	return o.is_management
}

func (o *LifSpec) Setis_management(val bool) {
	o.is_management = val
	o.bubbleSave()
}

func (o *LifSpec) Getpacket_filter() *PktFilter {
	return o.packet_filter
}

func (o *LifSpec) Gethw_lif_id() uint32 {
	return o.hw_lif_id
}

func (o *LifSpec) Sethw_lif_id(val uint32) {
	o.hw_lif_id = val
	o.bubbleSave()
}

func (o *LifSpec) Getrdma_max_keys() uint32 {
	return o.rdma_max_keys
}

func (o *LifSpec) Setrdma_max_keys(val uint32) {
	o.rdma_max_keys = val
	o.bubbleSave()
}

func (o *LifSpec) Getrdma_max_ahs() uint32 {
	return o.rdma_max_ahs
}

func (o *LifSpec) Setrdma_max_ahs(val uint32) {
	o.rdma_max_ahs = val
	o.bubbleSave()
}

func (o *LifSpec) Getrdma_max_pt_entries() uint32 {
	return o.rdma_max_pt_entries
}

func (o *LifSpec) Setrdma_max_pt_entries(val uint32) {
	o.rdma_max_pt_entries = val
	o.bubbleSave()
}

func (o *LifSpec) Getlif_qstate() *QStateSetReq {
	return o.lif_qstate
}

func (o *LifSpec) Getrss() *LifRssSpec {
	return o.rss
}

func (o *LifSpec) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifSpec) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *LifSpec) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewLifSpec(sdkClient clientApi.Client) *LifSpec {
	w := &LifSpec{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "LifSpec",
	}
	w.key_or_handle = childNewLifKeyHandle(w, sdkClient)
	w.pinned_uplink_if_key_handle = childNewInterfaceKeyHandle(w, sdkClient)
	w.lif_qstate_map = childNewLifQStateMapEntry(w, sdkClient)
	w.packet_filter = childNewPktFilter(w, sdkClient)
	w.lif_qstate = childNewQStateSetReq(w, sdkClient)
	w.rss = childNewLifRssSpec(w, sdkClient)
	return w
}

func NewLifSpecWithKey(sdkClient clientApi.Client, key *LifKeyHandle) *LifSpec {
	w := NewLifSpec(sdkClient)
	w.key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, key)
	return w
}

func NewLifSpecFromMessage(sdkClient clientApi.Client, msg *LifSpec_) *LifSpec {
	obj := newLifSpecFromMessage(msg)
	obj.sdkClient = sdkClient
	obj.meta = &delphi.ObjectMeta{
		Kind: "LifSpec",
	}

	obj.bubbleSave()
	return obj
}

func GetLifSpec(sdkClient clientApi.Client, key *LifKeyHandle) *LifSpec {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("LifSpec", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*LifSpec)
	if !ok {
		panic("Couldn't cast to LifSpec")
	}
	return o
}

func childNewLifSpec(parent delphiWrapper, sdkClient clientApi.Client) *LifSpec {
	w := NewLifSpec(sdkClient)
	w.parent = parent
	return w
}

func childNewLifSpecWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifSpec) *LifSpec {
	w := childNewLifSpec(parent, sdkClient)
	w.key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	w.pinned_uplink_if_key_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.pinned_uplink_if_key_handle)
	w.admin_status = value.admin_status
	w.lif_qstate_map = childNewLifQStateMapEntryWithValue(w, sdkClient, value.lif_qstate_map)
	w.vlan_strip_en = value.vlan_strip_en
	w.vlan_insert_en = value.vlan_insert_en
	w.enable_rdma = value.enable_rdma
	w.is_management = value.is_management
	w.packet_filter = childNewPktFilterWithValue(w, sdkClient, value.packet_filter)
	w.hw_lif_id = value.hw_lif_id
	w.rdma_max_keys = value.rdma_max_keys
	w.rdma_max_ahs = value.rdma_max_ahs
	w.rdma_max_pt_entries = value.rdma_max_pt_entries
	w.lif_qstate = childNewQStateSetReqWithValue(w, sdkClient, value.lif_qstate)
	w.rss = childNewLifRssSpecWithValue(w, sdkClient, value.rss)
	return w
}

func (o *LifSpec) GetProtoMsg() *LifSpec_ {
	if o == nil {
		return &LifSpec_{}
	}

	return &LifSpec_{
		Meta:                    o.meta,
		KeyOrHandle:             o.key_or_handle.GetProtoMsg(),
		PinnedUplinkIfKeyHandle: o.pinned_uplink_if_key_handle.GetProtoMsg(),
		AdminStatus:             o.admin_status,
		LifQstateMap:            o.lif_qstate_map.GetProtoMsg(),
		VlanStripEn:             o.vlan_strip_en,
		VlanInsertEn:            o.vlan_insert_en,
		EnableRdma:              o.enable_rdma,
		IsManagement:            o.is_management,
		PacketFilter:            o.packet_filter.GetProtoMsg(),
		HwLifId:                 o.hw_lif_id,
		RdmaMaxKeys:             o.rdma_max_keys,
		RdmaMaxAhs:              o.rdma_max_ahs,
		RdmaMaxPtEntries:        o.rdma_max_pt_entries,
		LifQstate:               o.lif_qstate.GetProtoMsg(),
		Rss:                     o.rss.GetProtoMsg(),
	}
}

func (o *LifSpec) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *LifSpec) GetKeyString() string {
	return obj.key_or_handle.GetProtoMsg().String()
}

func (obj *LifSpec) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(LifSpecReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnLifSpecCreate(obj)
			} else {
				rctr.OnLifSpecUpdate(obj)
			}
		} else {
			rctr.OnLifSpecDelete(obj)
		}
	}
}

type LifSpecReactor interface {
	OnLifSpecCreate(obj *LifSpec)
	OnLifSpecUpdate(obj *LifSpec)
	OnLifSpecDelete(obj *LifSpec)
}

func (obj *LifSpec) GetPath() string {
	return "LifSpec" + "|" + obj.GetKeyString()
}

func newLifSpecFromMessage(msg *LifSpec_) *LifSpec {
	if msg == nil {
		return &LifSpec{}
	}

	return &LifSpec{
		meta:                        msg.Meta,
		key_or_handle:               newLifKeyHandleFromMessage(msg.KeyOrHandle),
		pinned_uplink_if_key_handle: newInterfaceKeyHandleFromMessage(msg.PinnedUplinkIfKeyHandle),
		admin_status:                msg.AdminStatus,
		lif_qstate_map:              newLifQStateMapEntryFromMessage(msg.LifQstateMap),
		vlan_strip_en:               msg.VlanStripEn,
		vlan_insert_en:              msg.VlanInsertEn,
		enable_rdma:                 msg.EnableRdma,
		is_management:               msg.IsManagement,
		packet_filter:               newPktFilterFromMessage(msg.PacketFilter),
		hw_lif_id:                   msg.HwLifId,
		rdma_max_keys:               msg.RdmaMaxKeys,
		rdma_max_ahs:                msg.RdmaMaxAhs,
		rdma_max_pt_entries:         msg.RdmaMaxPtEntries,
		lif_qstate:                  newQStateSetReqFromMessage(msg.LifQstate),
		rss:                         newLifRssSpecFromMessage(msg.Rss),
	}
}

func lifSpecFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg LifSpec_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newLifSpecFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func LifSpecMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("LifSpec", mode)
}

func LifSpecMountKey(client clientApi.Client, key *LifKeyHandle, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("LifSpec", keyString, mode)
}

func LifSpecWatch(client clientApi.Client, reactor LifSpecReactor) {
	client.WatchKind("LifSpec", reactor)
}

type LifSpecIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *LifSpecIterator) Next() *LifSpec {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*LifSpec)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func LifSpecList(client clientApi.Client) *LifSpecIterator {
	return &LifSpecIterator{
		objects: client.List("LifSpec"),
		cur:     0,
	}
}

type GetQStateResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	resps     *QStateGetResp
}

func (o *GetQStateResponseMsg) Getresps() *QStateGetResp {
	return o.resps
}

func (o *GetQStateResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *GetQStateResponseMsg) save() {
}

func NewGetQStateResponseMsg(sdkClient clientApi.Client) *GetQStateResponseMsg {
	w := &GetQStateResponseMsg{}
	w.sdkClient = sdkClient
	w.resps = childNewQStateGetResp(w, sdkClient)
	return w
}

func childNewGetQStateResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *GetQStateResponseMsg {
	w := NewGetQStateResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewGetQStateResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *GetQStateResponseMsg) *GetQStateResponseMsg {
	w := childNewGetQStateResponseMsg(parent, sdkClient)
	w.resps = childNewQStateGetRespWithValue(w, sdkClient, value.resps)
	return w
}

func (o *GetQStateResponseMsg) GetProtoMsg() *GetQStateResponseMsg_ {
	if o == nil {
		return &GetQStateResponseMsg_{}
	}

	return &GetQStateResponseMsg_{
		Resps: o.resps.GetProtoMsg(),
	}
}

func (o *GetQStateResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newGetQStateResponseMsgFromMessage(msg *GetQStateResponseMsg_) *GetQStateResponseMsg {
	if msg == nil {
		return &GetQStateResponseMsg{}
	}

	return &GetQStateResponseMsg{
		resps: newQStateGetRespFromMessage(msg.Resps),
	}
}

type InterfaceResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	response  *InterfaceResponse
}

func (o *InterfaceResponseMsg) Getresponse() *InterfaceResponse {
	return o.response
}

func (o *InterfaceResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceResponseMsg) save() {
}

func NewInterfaceResponseMsg(sdkClient clientApi.Client) *InterfaceResponseMsg {
	w := &InterfaceResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewInterfaceResponse(w, sdkClient)
	return w
}

func childNewInterfaceResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceResponseMsg {
	w := NewInterfaceResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceResponseMsg) *InterfaceResponseMsg {
	w := childNewInterfaceResponseMsg(parent, sdkClient)
	w.response = childNewInterfaceResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *InterfaceResponseMsg) GetProtoMsg() *InterfaceResponseMsg_ {
	if o == nil {
		return &InterfaceResponseMsg_{}
	}

	return &InterfaceResponseMsg_{
		Response: o.response.GetProtoMsg(),
	}
}

func (o *InterfaceResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceResponseMsgFromMessage(msg *InterfaceResponseMsg_) *InterfaceResponseMsg {
	if msg == nil {
		return &InterfaceResponseMsg{}
	}

	return &InterfaceResponseMsg{
		response: newInterfaceResponseFromMessage(msg.Response),
	}
}

type PortKeyHandle struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	port_id     uint32
	port_handle uint64
}

func (o *PortKeyHandle) Getport_id() uint32 {
	return o.port_id
}

func (o *PortKeyHandle) Setport_id(val uint32) {
	o.port_id = val
	o.bubbleSave()
}

func (o *PortKeyHandle) Getport_handle() uint64 {
	return o.port_handle
}

func (o *PortKeyHandle) Setport_handle(val uint64) {
	o.port_handle = val
	o.bubbleSave()
}

func (o *PortKeyHandle) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *PortKeyHandle) save() {
}

func NewPortKeyHandle(sdkClient clientApi.Client) *PortKeyHandle {
	w := &PortKeyHandle{}
	w.sdkClient = sdkClient
	return w
}

func childNewPortKeyHandle(parent delphiWrapper, sdkClient clientApi.Client) *PortKeyHandle {
	w := NewPortKeyHandle(sdkClient)
	w.parent = parent
	return w
}

func childNewPortKeyHandleWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *PortKeyHandle) *PortKeyHandle {
	w := childNewPortKeyHandle(parent, sdkClient)
	w.port_id = value.port_id
	w.port_handle = value.port_handle
	return w
}

func (o *PortKeyHandle) GetProtoMsg() *PortKeyHandle_ {
	if o == nil {
		return &PortKeyHandle_{}
	}

	return &PortKeyHandle_{
		PortId:     o.port_id,
		PortHandle: o.port_handle,
	}
}

func (o *PortKeyHandle) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newPortKeyHandleFromMessage(msg *PortKeyHandle_) *PortKeyHandle {
	if msg == nil {
		return &PortKeyHandle{}
	}

	return &PortKeyHandle{
		port_id:     msg.PortId,
		port_handle: msg.PortHandle,
	}
}

type LifResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	response  *LifResponse
}

func (o *LifResponseMsg) Getresponse() *LifResponse {
	return o.response
}

func (o *LifResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifResponseMsg) save() {
}

func NewLifResponseMsg(sdkClient clientApi.Client) *LifResponseMsg {
	w := &LifResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewLifResponse(w, sdkClient)
	return w
}

func childNewLifResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *LifResponseMsg {
	w := NewLifResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewLifResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifResponseMsg) *LifResponseMsg {
	w := childNewLifResponseMsg(parent, sdkClient)
	w.response = childNewLifResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *LifResponseMsg) GetProtoMsg() *LifResponseMsg_ {
	if o == nil {
		return &LifResponseMsg_{}
	}

	return &LifResponseMsg_{
		Response: o.response.GetProtoMsg(),
	}
}

func (o *LifResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifResponseMsgFromMessage(msg *LifResponseMsg_) *LifResponseMsg {
	if msg == nil {
		return &LifResponseMsg{}
	}

	return &LifResponseMsg{
		response: newLifResponseFromMessage(msg.Response),
	}
}

type LifRssSpec struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	lif_type  uint32
	key       []byte
	indir     []byte
}

func (o *LifRssSpec) Getlif_type() uint32 {
	return o.lif_type
}

func (o *LifRssSpec) Setlif_type(val uint32) {
	o.lif_type = val
	o.bubbleSave()
}

func (o *LifRssSpec) Getkey() []byte {
	return o.key
}

func (o *LifRssSpec) Setkey(val []byte) {
	o.key = val
	o.bubbleSave()
}

func (o *LifRssSpec) Getindir() []byte {
	return o.indir
}

func (o *LifRssSpec) Setindir(val []byte) {
	o.indir = val
	o.bubbleSave()
}

func (o *LifRssSpec) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifRssSpec) save() {
}

func NewLifRssSpec(sdkClient clientApi.Client) *LifRssSpec {
	w := &LifRssSpec{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifRssSpec(parent delphiWrapper, sdkClient clientApi.Client) *LifRssSpec {
	w := NewLifRssSpec(sdkClient)
	w.parent = parent
	return w
}

func childNewLifRssSpecWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifRssSpec) *LifRssSpec {
	w := childNewLifRssSpec(parent, sdkClient)
	w.lif_type = value.lif_type
	w.key = value.key
	w.indir = value.indir
	return w
}

func (o *LifRssSpec) GetProtoMsg() *LifRssSpec_ {
	if o == nil {
		return &LifRssSpec_{}
	}

	return &LifRssSpec_{
		LifType: o.lif_type,
		Key:     o.key,
		Indir:   o.indir,
	}
}

func (o *LifRssSpec) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifRssSpecFromMessage(msg *LifRssSpec_) *LifRssSpec {
	if msg == nil {
		return &LifRssSpec{}
	}

	return &LifRssSpec{
		lif_type: msg.LifType,
		key:      msg.Key,
		indir:    msg.Indir,
	}
}

type InterfaceDeleteResponse struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
}

func (o *InterfaceDeleteResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *InterfaceDeleteResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *InterfaceDeleteResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceDeleteResponse) save() {
}

func NewInterfaceDeleteResponse(sdkClient clientApi.Client) *InterfaceDeleteResponse {
	w := &InterfaceDeleteResponse{}
	w.sdkClient = sdkClient
	return w
}

func childNewInterfaceDeleteResponse(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceDeleteResponse {
	w := NewInterfaceDeleteResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceDeleteResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceDeleteResponse) *InterfaceDeleteResponse {
	w := childNewInterfaceDeleteResponse(parent, sdkClient)
	w.api_status = value.api_status
	return w
}

func (o *InterfaceDeleteResponse) GetProtoMsg() *InterfaceDeleteResponse_ {
	if o == nil {
		return &InterfaceDeleteResponse_{}
	}

	return &InterfaceDeleteResponse_{
		ApiStatus: o.api_status,
	}
}

func (o *InterfaceDeleteResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceDeleteResponseFromMessage(msg *InterfaceDeleteResponse_) *InterfaceDeleteResponse {
	if msg == nil {
		return &InterfaceDeleteResponse{}
	}

	return &InterfaceDeleteResponse{
		api_status: msg.ApiStatus,
	}
}

type EncapInfo struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	encap_type  EncapType
	encap_value uint32
}

func (o *EncapInfo) Getencap_type() EncapType {
	return o.encap_type
}

func (o *EncapInfo) Setencap_type(val EncapType) {
	o.encap_type = val
	o.bubbleSave()
}

func (o *EncapInfo) Getencap_value() uint32 {
	return o.encap_value
}

func (o *EncapInfo) Setencap_value(val uint32) {
	o.encap_value = val
	o.bubbleSave()
}

func (o *EncapInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EncapInfo) save() {
}

func NewEncapInfo(sdkClient clientApi.Client) *EncapInfo {
	w := &EncapInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewEncapInfo(parent delphiWrapper, sdkClient clientApi.Client) *EncapInfo {
	w := NewEncapInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewEncapInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EncapInfo) *EncapInfo {
	w := childNewEncapInfo(parent, sdkClient)
	w.encap_type = value.encap_type
	w.encap_value = value.encap_value
	return w
}

func (o *EncapInfo) GetProtoMsg() *EncapInfo_ {
	if o == nil {
		return &EncapInfo_{}
	}

	return &EncapInfo_{
		EncapType:  o.encap_type,
		EncapValue: o.encap_value,
	}
}

func (o *EncapInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEncapInfoFromMessage(msg *EncapInfo_) *EncapInfo {
	if msg == nil {
		return &EncapInfo{}
	}

	return &EncapInfo{
		encap_type:  msg.EncapType,
		encap_value: msg.EncapValue,
	}
}

type FilterKey struct {
	sdkClient         clientApi.Client
	parent            delphiWrapper
	lif_key_or_handle *LifKeyHandle
	filter_type       FilterType
	mac_address       uint64
	vlan_id           uint32
}

func (o *FilterKey) Getlif_key_or_handle() *LifKeyHandle {
	return o.lif_key_or_handle
}

func (o *FilterKey) Getfilter_type() FilterType {
	return o.filter_type
}

func (o *FilterKey) Setfilter_type(val FilterType) {
	o.filter_type = val
	o.bubbleSave()
}

func (o *FilterKey) Getmac_address() uint64 {
	return o.mac_address
}

func (o *FilterKey) Setmac_address(val uint64) {
	o.mac_address = val
	o.bubbleSave()
}

func (o *FilterKey) Getvlan_id() uint32 {
	return o.vlan_id
}

func (o *FilterKey) Setvlan_id(val uint32) {
	o.vlan_id = val
	o.bubbleSave()
}

func (o *FilterKey) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *FilterKey) save() {
}

func NewFilterKey(sdkClient clientApi.Client) *FilterKey {
	w := &FilterKey{}
	w.sdkClient = sdkClient
	w.lif_key_or_handle = childNewLifKeyHandle(w, sdkClient)
	return w
}

func childNewFilterKey(parent delphiWrapper, sdkClient clientApi.Client) *FilterKey {
	w := NewFilterKey(sdkClient)
	w.parent = parent
	return w
}

func childNewFilterKeyWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *FilterKey) *FilterKey {
	w := childNewFilterKey(parent, sdkClient)
	w.lif_key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.lif_key_or_handle)
	w.filter_type = value.filter_type
	w.mac_address = value.mac_address
	w.vlan_id = value.vlan_id
	return w
}

func (o *FilterKey) GetProtoMsg() *FilterKey_ {
	if o == nil {
		return &FilterKey_{}
	}

	return &FilterKey_{
		LifKeyOrHandle: o.lif_key_or_handle.GetProtoMsg(),
		FilterType:     o.filter_type,
		MacAddress:     o.mac_address,
		VlanId:         o.vlan_id,
	}
}

func (o *FilterKey) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newFilterKeyFromMessage(msg *FilterKey_) *FilterKey {
	if msg == nil {
		return &FilterKey{}
	}

	return &FilterKey{
		lif_key_or_handle: newLifKeyHandleFromMessage(msg.LifKeyOrHandle),
		filter_type:       msg.FilterType,
		mac_address:       msg.MacAddress,
		vlan_id:           msg.VlanId,
	}
}

type QStateSetReq struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	lif_handle  uint64
	type_num    uint32
	qid         uint32
	label       *P4ProgLabel
	queue_state []byte
}

func (o *QStateSetReq) Getlif_handle() uint64 {
	return o.lif_handle
}

func (o *QStateSetReq) Setlif_handle(val uint64) {
	o.lif_handle = val
	o.bubbleSave()
}

func (o *QStateSetReq) Gettype_num() uint32 {
	return o.type_num
}

func (o *QStateSetReq) Settype_num(val uint32) {
	o.type_num = val
	o.bubbleSave()
}

func (o *QStateSetReq) Getqid() uint32 {
	return o.qid
}

func (o *QStateSetReq) Setqid(val uint32) {
	o.qid = val
	o.bubbleSave()
}

func (o *QStateSetReq) Getlabel() *P4ProgLabel {
	return o.label
}

func (o *QStateSetReq) Getqueue_state() []byte {
	return o.queue_state
}

func (o *QStateSetReq) Setqueue_state(val []byte) {
	o.queue_state = val
	o.bubbleSave()
}

func (o *QStateSetReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *QStateSetReq) save() {
}

func NewQStateSetReq(sdkClient clientApi.Client) *QStateSetReq {
	w := &QStateSetReq{}
	w.sdkClient = sdkClient
	w.label = childNewP4ProgLabel(w, sdkClient)
	return w
}

func childNewQStateSetReq(parent delphiWrapper, sdkClient clientApi.Client) *QStateSetReq {
	w := NewQStateSetReq(sdkClient)
	w.parent = parent
	return w
}

func childNewQStateSetReqWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *QStateSetReq) *QStateSetReq {
	w := childNewQStateSetReq(parent, sdkClient)
	w.lif_handle = value.lif_handle
	w.type_num = value.type_num
	w.qid = value.qid
	w.label = childNewP4ProgLabelWithValue(w, sdkClient, value.label)
	w.queue_state = value.queue_state
	return w
}

func (o *QStateSetReq) GetProtoMsg() *QStateSetReq_ {
	if o == nil {
		return &QStateSetReq_{}
	}

	return &QStateSetReq_{
		LifHandle:  o.lif_handle,
		TypeNum:    o.type_num,
		Qid:        o.qid,
		Label:      o.label.GetProtoMsg(),
		QueueState: o.queue_state,
	}
}

func (o *QStateSetReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newQStateSetReqFromMessage(msg *QStateSetReq_) *QStateSetReq {
	if msg == nil {
		return &QStateSetReq{}
	}

	return &QStateSetReq{
		lif_handle:  msg.LifHandle,
		type_num:    msg.TypeNum,
		qid:         msg.Qid,
		label:       newP4ProgLabelFromMessage(msg.Label),
		queue_state: msg.QueueState,
	}
}

type InterfaceRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *InterfaceSpec
}

func (o *InterfaceRequestMsg) Getrequest() *InterfaceSpec {
	return o.request
}

func (o *InterfaceRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceRequestMsg) save() {
}

func NewInterfaceRequestMsg(sdkClient clientApi.Client) *InterfaceRequestMsg {
	w := &InterfaceRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewInterfaceSpec(w, sdkClient)
	return w
}

func childNewInterfaceRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceRequestMsg {
	w := NewInterfaceRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceRequestMsg) *InterfaceRequestMsg {
	w := childNewInterfaceRequestMsg(parent, sdkClient)
	w.request = childNewInterfaceSpecWithValue(w, sdkClient, value.request)
	return w
}

func (o *InterfaceRequestMsg) GetProtoMsg() *InterfaceRequestMsg_ {
	if o == nil {
		return &InterfaceRequestMsg_{}
	}

	return &InterfaceRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *InterfaceRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceRequestMsgFromMessage(msg *InterfaceRequestMsg_) *InterfaceRequestMsg {
	if msg == nil {
		return &InterfaceRequestMsg{}
	}

	return &InterfaceRequestMsg{
		request: newInterfaceSpecFromMessage(msg.Request),
	}
}

type LifDeleteResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	response  *LifDeleteResponse
}

func (o *LifDeleteResponseMsg) Getresponse() *LifDeleteResponse {
	return o.response
}

func (o *LifDeleteResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifDeleteResponseMsg) save() {
}

func NewLifDeleteResponseMsg(sdkClient clientApi.Client) *LifDeleteResponseMsg {
	w := &LifDeleteResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewLifDeleteResponse(w, sdkClient)
	return w
}

func childNewLifDeleteResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *LifDeleteResponseMsg {
	w := NewLifDeleteResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewLifDeleteResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifDeleteResponseMsg) *LifDeleteResponseMsg {
	w := childNewLifDeleteResponseMsg(parent, sdkClient)
	w.response = childNewLifDeleteResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *LifDeleteResponseMsg) GetProtoMsg() *LifDeleteResponseMsg_ {
	if o == nil {
		return &LifDeleteResponseMsg_{}
	}

	return &LifDeleteResponseMsg_{
		Response: o.response.GetProtoMsg(),
	}
}

func (o *LifDeleteResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifDeleteResponseMsgFromMessage(msg *LifDeleteResponseMsg_) *LifDeleteResponseMsg {
	if msg == nil {
		return &LifDeleteResponseMsg{}
	}

	return &LifDeleteResponseMsg{
		response: newLifDeleteResponseFromMessage(msg.Response),
	}
}

type InterfaceDeleteRequest struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	key_or_handle *InterfaceKeyHandle
}

func (o *InterfaceDeleteRequest) Getkey_or_handle() *InterfaceKeyHandle {
	return o.key_or_handle
}

func (o *InterfaceDeleteRequest) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceDeleteRequest) save() {
}

func NewInterfaceDeleteRequest(sdkClient clientApi.Client) *InterfaceDeleteRequest {
	w := &InterfaceDeleteRequest{}
	w.sdkClient = sdkClient
	w.key_or_handle = childNewInterfaceKeyHandle(w, sdkClient)
	return w
}

func childNewInterfaceDeleteRequest(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceDeleteRequest {
	w := NewInterfaceDeleteRequest(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceDeleteRequestWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceDeleteRequest) *InterfaceDeleteRequest {
	w := childNewInterfaceDeleteRequest(parent, sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	return w
}

func (o *InterfaceDeleteRequest) GetProtoMsg() *InterfaceDeleteRequest_ {
	if o == nil {
		return &InterfaceDeleteRequest_{}
	}

	return &InterfaceDeleteRequest_{
		KeyOrHandle: o.key_or_handle.GetProtoMsg(),
	}
}

func (o *InterfaceDeleteRequest) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceDeleteRequestFromMessage(msg *InterfaceDeleteRequest_) *InterfaceDeleteRequest {
	if msg == nil {
		return &InterfaceDeleteRequest{}
	}

	return &InterfaceDeleteRequest{
		key_or_handle: newInterfaceKeyHandleFromMessage(msg.KeyOrHandle),
	}
}

type InterfaceDeleteResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	response  *InterfaceDeleteResponse
}

func (o *InterfaceDeleteResponseMsg) GetResponse() *InterfaceDeleteResponse {
	return o.response
}

func (o *InterfaceDeleteResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceDeleteResponseMsg) save() {
}

func NewInterfaceDeleteResponseMsg(sdkClient clientApi.Client) *InterfaceDeleteResponseMsg {
	w := &InterfaceDeleteResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewInterfaceDeleteResponse(w, sdkClient)
	return w
}

func childNewInterfaceDeleteResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceDeleteResponseMsg {
	w := NewInterfaceDeleteResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceDeleteResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceDeleteResponseMsg) *InterfaceDeleteResponseMsg {
	w := childNewInterfaceDeleteResponseMsg(parent, sdkClient)
	w.response = childNewInterfaceDeleteResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *InterfaceDeleteResponseMsg) GetProtoMsg() *InterfaceDeleteResponseMsg_ {
	if o == nil {
		return &InterfaceDeleteResponseMsg_{}
	}

	return &InterfaceDeleteResponseMsg_{
		Response: o.response.GetProtoMsg(),
	}
}

func (o *InterfaceDeleteResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceDeleteResponseMsgFromMessage(msg *InterfaceDeleteResponseMsg_) *InterfaceDeleteResponseMsg {
	if msg == nil {
		return &InterfaceDeleteResponseMsg{}
	}

	return &InterfaceDeleteResponseMsg{
		response: newInterfaceDeleteResponseFromMessage(msg.Response),
	}
}

type InterfaceGetRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *InterfaceGetRequest
}

func (o *InterfaceGetRequestMsg) Getrequest() *InterfaceGetRequest {
	return o.request
}

func (o *InterfaceGetRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceGetRequestMsg) save() {
}

func NewInterfaceGetRequestMsg(sdkClient clientApi.Client) *InterfaceGetRequestMsg {
	w := &InterfaceGetRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewInterfaceGetRequest(w, sdkClient)
	return w
}

func childNewInterfaceGetRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceGetRequestMsg {
	w := NewInterfaceGetRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceGetRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceGetRequestMsg) *InterfaceGetRequestMsg {
	w := childNewInterfaceGetRequestMsg(parent, sdkClient)
	w.request = childNewInterfaceGetRequestWithValue(w, sdkClient, value.request)
	return w
}

func (o *InterfaceGetRequestMsg) GetProtoMsg() *InterfaceGetRequestMsg_ {
	if o == nil {
		return &InterfaceGetRequestMsg_{}
	}

	return &InterfaceGetRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *InterfaceGetRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceGetRequestMsgFromMessage(msg *InterfaceGetRequestMsg_) *InterfaceGetRequestMsg {
	if msg == nil {
		return &InterfaceGetRequestMsg{}
	}

	return &InterfaceGetRequestMsg{
		request: newInterfaceGetRequestFromMessage(msg.Request),
	}
}

type ObjectMeta struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	vrf_id    uint64
}

func (o *ObjectMeta) Getvrf_id() uint64 {
	return o.vrf_id
}

func (o *ObjectMeta) Setvrf_id(val uint64) {
	o.vrf_id = val
	o.bubbleSave()
}

func (o *ObjectMeta) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *ObjectMeta) save() {
}

func NewObjectMeta(sdkClient clientApi.Client) *ObjectMeta {
	w := &ObjectMeta{}
	w.sdkClient = sdkClient
	return w
}

func childNewObjectMeta(parent delphiWrapper, sdkClient clientApi.Client) *ObjectMeta {
	w := NewObjectMeta(sdkClient)
	w.parent = parent
	return w
}

func childNewObjectMetaWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *ObjectMeta) *ObjectMeta {
	w := childNewObjectMeta(parent, sdkClient)
	w.vrf_id = value.vrf_id
	return w
}

func (o *ObjectMeta) GetProtoMsg() *ObjectMeta_ {
	if o == nil {
		return &ObjectMeta_{}
	}

	return &ObjectMeta_{
		VrfId: o.vrf_id,
	}
}

func (o *ObjectMeta) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newObjectMetaFromMessage(msg *ObjectMeta_) *ObjectMeta {
	if msg == nil {
		return &ObjectMeta{}
	}

	return &ObjectMeta{
		vrf_id: msg.VrfId,
	}
}

type L4PortRange struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	port_low  uint32
	port_high uint32
}

func (o *L4PortRange) Getport_low() uint32 {
	return o.port_low
}

func (o *L4PortRange) Setport_low(val uint32) {
	o.port_low = val
	o.bubbleSave()
}

func (o *L4PortRange) Getport_high() uint32 {
	return o.port_high
}

func (o *L4PortRange) Setport_high(val uint32) {
	o.port_high = val
	o.bubbleSave()
}

func (o *L4PortRange) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *L4PortRange) save() {
}

func NewL4PortRange(sdkClient clientApi.Client) *L4PortRange {
	w := &L4PortRange{}
	w.sdkClient = sdkClient
	return w
}

func childNewL4PortRange(parent delphiWrapper, sdkClient clientApi.Client) *L4PortRange {
	w := NewL4PortRange(sdkClient)
	w.parent = parent
	return w
}

func childNewL4PortRangeWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *L4PortRange) *L4PortRange {
	w := childNewL4PortRange(parent, sdkClient)
	w.port_low = value.port_low
	w.port_high = value.port_high
	return w
}

func (o *L4PortRange) GetProtoMsg() *L4PortRange_ {
	if o == nil {
		return &L4PortRange_{}
	}

	return &L4PortRange_{
		PortLow:  o.port_low,
		PortHigh: o.port_high,
	}
}

func (o *L4PortRange) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newL4PortRangeFromMessage(msg *L4PortRange_) *L4PortRange {
	if msg == nil {
		return &L4PortRange{}
	}

	return &L4PortRange{
		port_low:  msg.PortLow,
		port_high: msg.PortHigh,
	}
}

type LifRdmaData struct {
	sdkClient    clientApi.Client
	parent       delphiWrapper
	pt_base_addr uint64
	kt_base_addr uint64
	at_base_addr uint64
}

func (o *LifRdmaData) Getpt_base_addr() uint64 {
	return o.pt_base_addr
}

func (o *LifRdmaData) Setpt_base_addr(val uint64) {
	o.pt_base_addr = val
	o.bubbleSave()
}

func (o *LifRdmaData) Getkt_base_addr() uint64 {
	return o.kt_base_addr
}

func (o *LifRdmaData) Setkt_base_addr(val uint64) {
	o.kt_base_addr = val
	o.bubbleSave()
}

func (o *LifRdmaData) Getat_base_addr() uint64 {
	return o.at_base_addr
}

func (o *LifRdmaData) Setat_base_addr(val uint64) {
	o.at_base_addr = val
	o.bubbleSave()
}

func (o *LifRdmaData) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifRdmaData) save() {
}

func NewLifRdmaData(sdkClient clientApi.Client) *LifRdmaData {
	w := &LifRdmaData{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifRdmaData(parent delphiWrapper, sdkClient clientApi.Client) *LifRdmaData {
	w := NewLifRdmaData(sdkClient)
	w.parent = parent
	return w
}

func childNewLifRdmaDataWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifRdmaData) *LifRdmaData {
	w := childNewLifRdmaData(parent, sdkClient)
	w.pt_base_addr = value.pt_base_addr
	w.kt_base_addr = value.kt_base_addr
	w.at_base_addr = value.at_base_addr
	return w
}

func (o *LifRdmaData) GetProtoMsg() *LifRdmaData_ {
	if o == nil {
		return &LifRdmaData_{}
	}

	return &LifRdmaData_{
		PtBaseAddr: o.pt_base_addr,
		KtBaseAddr: o.kt_base_addr,
		AtBaseAddr: o.at_base_addr,
	}
}

func (o *LifRdmaData) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifRdmaDataFromMessage(msg *LifRdmaData_) *LifRdmaData {
	if msg == nil {
		return &LifRdmaData{}
	}

	return &LifRdmaData{
		pt_base_addr: msg.PtBaseAddr,
		kt_base_addr: msg.KtBaseAddr,
		at_base_addr: msg.AtBaseAddr,
	}
}

type QStateSetResp struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	error_code int32
}

func (o *QStateSetResp) Geterror_code() int32 {
	return o.error_code
}

func (o *QStateSetResp) Seterror_code(val int32) {
	o.error_code = val
	o.bubbleSave()
}

func (o *QStateSetResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *QStateSetResp) save() {
}

func NewQStateSetResp(sdkClient clientApi.Client) *QStateSetResp {
	w := &QStateSetResp{}
	w.sdkClient = sdkClient
	return w
}

func childNewQStateSetResp(parent delphiWrapper, sdkClient clientApi.Client) *QStateSetResp {
	w := NewQStateSetResp(sdkClient)
	w.parent = parent
	return w
}

func childNewQStateSetRespWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *QStateSetResp) *QStateSetResp {
	w := childNewQStateSetResp(parent, sdkClient)
	w.error_code = value.error_code
	return w
}

func (o *QStateSetResp) GetProtoMsg() *QStateSetResp_ {
	if o == nil {
		return &QStateSetResp_{}
	}

	return &QStateSetResp_{
		ErrorCode: o.error_code,
	}
}

func (o *QStateSetResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newQStateSetRespFromMessage(msg *QStateSetResp_) *QStateSetResp {
	if msg == nil {
		return &QStateSetResp{}
	}

	return &QStateSetResp{
		error_code: msg.ErrorCode,
	}
}

type LifDeleteResponse struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
}

func (o *LifDeleteResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *LifDeleteResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *LifDeleteResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifDeleteResponse) save() {
}

func NewLifDeleteResponse(sdkClient clientApi.Client) *LifDeleteResponse {
	w := &LifDeleteResponse{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifDeleteResponse(parent delphiWrapper, sdkClient clientApi.Client) *LifDeleteResponse {
	w := NewLifDeleteResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewLifDeleteResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifDeleteResponse) *LifDeleteResponse {
	w := childNewLifDeleteResponse(parent, sdkClient)
	w.api_status = value.api_status
	return w
}

func (o *LifDeleteResponse) GetProtoMsg() *LifDeleteResponse_ {
	if o == nil {
		return &LifDeleteResponse_{}
	}

	return &LifDeleteResponse_{
		ApiStatus: o.api_status,
	}
}

func (o *LifDeleteResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifDeleteResponseFromMessage(msg *LifDeleteResponse_) *LifDeleteResponse {
	if msg == nil {
		return &LifDeleteResponse{}
	}

	return &LifDeleteResponse{
		api_status: msg.ApiStatus,
	}
}

type IfUplinkPCInfo struct {
	sdkClient            clientApi.Client
	parent               delphiWrapper
	native_l2segment_id  uint64
	member_if_key_handle *InterfaceKeyHandle
}

func (o *IfUplinkPCInfo) Getnative_l2segment_id() uint64 {
	return o.native_l2segment_id
}

func (o *IfUplinkPCInfo) Setnative_l2segment_id(val uint64) {
	o.native_l2segment_id = val
	o.bubbleSave()
}

func (o *IfUplinkPCInfo) Getmember_if_key_handle() *InterfaceKeyHandle {
	return o.member_if_key_handle
}

func (o *IfUplinkPCInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfUplinkPCInfo) save() {
}

func NewIfUplinkPCInfo(sdkClient clientApi.Client) *IfUplinkPCInfo {
	w := &IfUplinkPCInfo{}
	w.sdkClient = sdkClient
	w.member_if_key_handle = childNewInterfaceKeyHandle(w, sdkClient)
	return w
}

func childNewIfUplinkPCInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfUplinkPCInfo {
	w := NewIfUplinkPCInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfUplinkPCInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfUplinkPCInfo) *IfUplinkPCInfo {
	w := childNewIfUplinkPCInfo(parent, sdkClient)
	w.native_l2segment_id = value.native_l2segment_id
	w.member_if_key_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.member_if_key_handle)
	return w
}

func (o *IfUplinkPCInfo) GetProtoMsg() *IfUplinkPCInfo_ {
	if o == nil {
		return &IfUplinkPCInfo_{}
	}

	return &IfUplinkPCInfo_{
		NativeL2SegmentId: o.native_l2segment_id,
		MemberIfKeyHandle: o.member_if_key_handle.GetProtoMsg(),
	}
}

func (o *IfUplinkPCInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfUplinkPCInfoFromMessage(msg *IfUplinkPCInfo_) *IfUplinkPCInfo {
	if msg == nil {
		return &IfUplinkPCInfo{}
	}

	return &IfUplinkPCInfo{
		native_l2segment_id:  msg.NativeL2SegmentId,
		member_if_key_handle: newInterfaceKeyHandleFromMessage(msg.MemberIfKeyHandle),
	}
}

type AddressRange struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	ipv4_range *IPRange
	ipv6_range *IPRange
}

func (o *AddressRange) Getipv4_range() *IPRange {
	return o.ipv4_range
}

func (o *AddressRange) Getipv6_range() *IPRange {
	return o.ipv6_range
}

func (o *AddressRange) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *AddressRange) save() {
}

func NewAddressRange(sdkClient clientApi.Client) *AddressRange {
	w := &AddressRange{}
	w.sdkClient = sdkClient
	w.ipv4_range = childNewIPRange(w, sdkClient)
	w.ipv6_range = childNewIPRange(w, sdkClient)
	return w
}

func childNewAddressRange(parent delphiWrapper, sdkClient clientApi.Client) *AddressRange {
	w := NewAddressRange(sdkClient)
	w.parent = parent
	return w
}

func childNewAddressRangeWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *AddressRange) *AddressRange {
	w := childNewAddressRange(parent, sdkClient)
	w.ipv4_range = childNewIPRangeWithValue(w, sdkClient, value.ipv4_range)
	w.ipv6_range = childNewIPRangeWithValue(w, sdkClient, value.ipv6_range)
	return w
}

func (o *AddressRange) GetProtoMsg() *AddressRange_ {
	if o == nil {
		return &AddressRange_{}
	}

	return &AddressRange_{
		Ipv4Range: o.ipv4_range.GetProtoMsg(),
		Ipv6Range: o.ipv6_range.GetProtoMsg(),
	}
}

func (o *AddressRange) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newAddressRangeFromMessage(msg *AddressRange_) *AddressRange {
	if msg == nil {
		return &AddressRange{}
	}

	return &AddressRange{
		ipv4_range: newIPRangeFromMessage(msg.Ipv4Range),
		ipv6_range: newIPRangeFromMessage(msg.Ipv6Range),
	}
}

type IPAddressObj struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	iptype    IPAddressType
	address   *Address
	negate    bool
}

func (o *IPAddressObj) Getiptype() IPAddressType {
	return o.iptype
}

func (o *IPAddressObj) Setiptype(val IPAddressType) {
	o.iptype = val
	o.bubbleSave()
}

func (o *IPAddressObj) Getaddress() *Address {
	return o.address
}

func (o *IPAddressObj) Getnegate() bool {
	return o.negate
}

func (o *IPAddressObj) Setnegate(val bool) {
	o.negate = val
	o.bubbleSave()
}

func (o *IPAddressObj) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IPAddressObj) save() {
}

func NewIPAddressObj(sdkClient clientApi.Client) *IPAddressObj {
	w := &IPAddressObj{}
	w.sdkClient = sdkClient
	w.address = childNewAddress(w, sdkClient)
	return w
}

func childNewIPAddressObj(parent delphiWrapper, sdkClient clientApi.Client) *IPAddressObj {
	w := NewIPAddressObj(sdkClient)
	w.parent = parent
	return w
}

func childNewIPAddressObjWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IPAddressObj) *IPAddressObj {
	w := childNewIPAddressObj(parent, sdkClient)
	w.iptype = value.iptype
	w.address = childNewAddressWithValue(w, sdkClient, value.address)
	w.negate = value.negate
	return w
}

func (o *IPAddressObj) GetProtoMsg() *IPAddressObj_ {
	if o == nil {
		return &IPAddressObj_{}
	}

	return &IPAddressObj_{
		Iptype:  o.iptype,
		Address: o.address.GetProtoMsg(),
		Negate:  o.negate,
	}
}

func (o *IPAddressObj) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIPAddressObjFromMessage(msg *IPAddressObj_) *IPAddressObj {
	if msg == nil {
		return &IPAddressObj{}
	}

	return &IPAddressObj{
		iptype:  msg.Iptype,
		address: newAddressFromMessage(msg.Address),
		negate:  msg.Negate,
	}
}

type L2SegmentKeyHandle struct {
	sdkClient        clientApi.Client
	parent           delphiWrapper
	segment_id       uint64
	l2segment_handle uint64
}

func (o *L2SegmentKeyHandle) Getsegment_id() uint64 {
	return o.segment_id
}

func (o *L2SegmentKeyHandle) Setsegment_id(val uint64) {
	o.segment_id = val
	o.bubbleSave()
}

func (o *L2SegmentKeyHandle) Getl2segment_handle() uint64 {
	return o.l2segment_handle
}

func (o *L2SegmentKeyHandle) Setl2segment_handle(val uint64) {
	o.l2segment_handle = val
	o.bubbleSave()
}

func (o *L2SegmentKeyHandle) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *L2SegmentKeyHandle) save() {
}

func NewL2SegmentKeyHandle(sdkClient clientApi.Client) *L2SegmentKeyHandle {
	w := &L2SegmentKeyHandle{}
	w.sdkClient = sdkClient
	return w
}

func childNewL2SegmentKeyHandle(parent delphiWrapper, sdkClient clientApi.Client) *L2SegmentKeyHandle {
	w := NewL2SegmentKeyHandle(sdkClient)
	w.parent = parent
	return w
}

func childNewL2SegmentKeyHandleWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *L2SegmentKeyHandle) *L2SegmentKeyHandle {
	w := childNewL2SegmentKeyHandle(parent, sdkClient)
	w.segment_id = value.segment_id
	w.l2segment_handle = value.l2segment_handle
	return w
}

func (o *L2SegmentKeyHandle) GetProtoMsg() *L2SegmentKeyHandle_ {
	if o == nil {
		return &L2SegmentKeyHandle_{}
	}

	return &L2SegmentKeyHandle_{
		SegmentId:       o.segment_id,
		L2SegmentHandle: o.l2segment_handle,
	}
}

func (o *L2SegmentKeyHandle) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newL2SegmentKeyHandleFromMessage(msg *L2SegmentKeyHandle_) *L2SegmentKeyHandle {
	if msg == nil {
		return &L2SegmentKeyHandle{}
	}

	return &L2SegmentKeyHandle{
		segment_id:       msg.SegmentId,
		l2segment_handle: msg.L2SegmentHandle,
	}
}

type LifStatus struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	meta          *delphi.ObjectMeta
	key_or_handle *LifKeyHandle
	lif_status    IntfStatus
	lif_handle    uint64
	hw_lif_id     uint64
}

func (o *LifStatus) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *LifStatus) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *LifStatus) Getkey_or_handle() *LifKeyHandle {
	return o.key_or_handle
}

func (o *LifStatus) Getlif_status() IntfStatus {
	return o.lif_status
}

func (o *LifStatus) Setlif_status(val IntfStatus) {
	o.lif_status = val
	o.bubbleSave()
}

func (o *LifStatus) Getlif_handle() uint64 {
	return o.lif_handle
}

func (o *LifStatus) Setlif_handle(val uint64) {
	o.lif_handle = val
	o.bubbleSave()
}

func (o *LifStatus) Gethw_lif_id() uint64 {
	return o.hw_lif_id
}

func (o *LifStatus) Sethw_lif_id(val uint64) {
	o.hw_lif_id = val
	o.bubbleSave()
}

func (o *LifStatus) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifStatus) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *LifStatus) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewLifStatus(sdkClient clientApi.Client) *LifStatus {
	w := &LifStatus{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "LifStatus",
	}
	w.key_or_handle = childNewLifKeyHandle(w, sdkClient)
	return w
}

func NewLifStatusWithKey(sdkClient clientApi.Client, key *LifKeyHandle) *LifStatus {
	w := NewLifStatus(sdkClient)
	w.key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, key)
	return w
}

func NewLifStatusFromMessage(sdkClient clientApi.Client, msg *LifStatus_) *LifStatus {
	obj := newLifStatusFromMessage(msg)
	obj.sdkClient = sdkClient
	obj.meta = &delphi.ObjectMeta{
		Kind: "LifStatus",
	}

	obj.bubbleSave()
	return obj
}

func GetLifStatus(sdkClient clientApi.Client, key *LifKeyHandle) *LifStatus {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("LifStatus", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*LifStatus)
	if !ok {
		panic("Couldn't cast to LifStatus")
	}
	return o
}

func childNewLifStatus(parent delphiWrapper, sdkClient clientApi.Client) *LifStatus {
	w := NewLifStatus(sdkClient)
	w.parent = parent
	return w
}

func childNewLifStatusWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifStatus) *LifStatus {
	w := childNewLifStatus(parent, sdkClient)
	w.key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	w.lif_status = value.lif_status
	w.lif_handle = value.lif_handle
	w.hw_lif_id = value.hw_lif_id
	return w
}

func (o *LifStatus) GetProtoMsg() *LifStatus_ {
	if o == nil {
		return &LifStatus_{}
	}

	return &LifStatus_{
		Meta:        o.meta,
		KeyOrHandle: o.key_or_handle.GetProtoMsg(),
		LifStatus:   o.lif_status,
		LifHandle:   o.lif_handle,
		HwLifId:     o.hw_lif_id,
	}
}

func (o *LifStatus) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *LifStatus) GetKeyString() string {
	return obj.key_or_handle.GetProtoMsg().String()
}

func (obj *LifStatus) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(LifStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnLifStatusCreate(obj)
			} else {
				rctr.OnLifStatusUpdate(obj)
			}
		} else {
			rctr.OnLifStatusDelete(obj)
		}
	}
}

type LifStatusReactor interface {
	OnLifStatusCreate(obj *LifStatus)
	OnLifStatusUpdate(obj *LifStatus)
	OnLifStatusDelete(obj *LifStatus)
}

func (obj *LifStatus) GetPath() string {
	return "LifStatus" + "|" + obj.GetKeyString()
}

func newLifStatusFromMessage(msg *LifStatus_) *LifStatus {
	if msg == nil {
		return &LifStatus{}
	}

	return &LifStatus{
		meta:          msg.Meta,
		key_or_handle: newLifKeyHandleFromMessage(msg.KeyOrHandle),
		lif_status:    msg.LifStatus,
		lif_handle:    msg.LifHandle,
		hw_lif_id:     msg.HwLifId,
	}
}

func lifStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg LifStatus_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newLifStatusFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func LifStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("LifStatus", mode)
}

func LifStatusMountKey(client clientApi.Client, key *LifKeyHandle, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("LifStatus", keyString, mode)
}

func LifStatusWatch(client clientApi.Client, reactor LifStatusReactor) {
	client.WatchKind("LifStatus", reactor)
}

type LifStatusIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *LifStatusIterator) Next() *LifStatus {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*LifStatus)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func LifStatusList(client clientApi.Client) *LifStatusIterator {
	return &LifStatusIterator{
		objects: client.List("LifStatus"),
		cur:     0,
	}
}

type PktFilter struct {
	sdkClient             clientApi.Client
	parent                delphiWrapper
	receive_broadcast     bool
	receive_all_multicast bool
	receive_promiscuous   bool
}

func (o *PktFilter) Getreceive_broadcast() bool {
	return o.receive_broadcast
}

func (o *PktFilter) Setreceive_broadcast(val bool) {
	o.receive_broadcast = val
	o.bubbleSave()
}

func (o *PktFilter) Getreceive_all_multicast() bool {
	return o.receive_all_multicast
}

func (o *PktFilter) Setreceive_all_multicast(val bool) {
	o.receive_all_multicast = val
	o.bubbleSave()
}

func (o *PktFilter) Getreceive_promiscuous() bool {
	return o.receive_promiscuous
}

func (o *PktFilter) Setreceive_promiscuous(val bool) {
	o.receive_promiscuous = val
	o.bubbleSave()
}

func (o *PktFilter) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *PktFilter) save() {
}

func NewPktFilter(sdkClient clientApi.Client) *PktFilter {
	w := &PktFilter{}
	w.sdkClient = sdkClient
	return w
}

func childNewPktFilter(parent delphiWrapper, sdkClient clientApi.Client) *PktFilter {
	w := NewPktFilter(sdkClient)
	w.parent = parent
	return w
}

func childNewPktFilterWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *PktFilter) *PktFilter {
	w := childNewPktFilter(parent, sdkClient)
	w.receive_broadcast = value.receive_broadcast
	w.receive_all_multicast = value.receive_all_multicast
	w.receive_promiscuous = value.receive_promiscuous
	return w
}

func (o *PktFilter) GetProtoMsg() *PktFilter_ {
	if o == nil {
		return &PktFilter_{}
	}

	return &PktFilter_{
		ReceiveBroadcast:    o.receive_broadcast,
		ReceiveAllMulticast: o.receive_all_multicast,
		ReceivePromiscuous:  o.receive_promiscuous,
	}
}

func (o *PktFilter) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newPktFilterFromMessage(msg *PktFilter_) *PktFilter {
	if msg == nil {
		return &PktFilter{}
	}

	return &PktFilter{
		receive_broadcast:     msg.ReceiveBroadcast,
		receive_all_multicast: msg.ReceiveAllMulticast,
		receive_promiscuous:   msg.ReceivePromiscuous,
	}
}

type IfCPUInfo struct {
	sdkClient         clientApi.Client
	parent            delphiWrapper
	lif_key_or_handle *LifKeyHandle
}

func (o *IfCPUInfo) Getlif_key_or_handle() *LifKeyHandle {
	return o.lif_key_or_handle
}

func (o *IfCPUInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfCPUInfo) save() {
}

func NewIfCPUInfo(sdkClient clientApi.Client) *IfCPUInfo {
	w := &IfCPUInfo{}
	w.sdkClient = sdkClient
	w.lif_key_or_handle = childNewLifKeyHandle(w, sdkClient)
	return w
}

func childNewIfCPUInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfCPUInfo {
	w := NewIfCPUInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfCPUInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfCPUInfo) *IfCPUInfo {
	w := childNewIfCPUInfo(parent, sdkClient)
	w.lif_key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.lif_key_or_handle)
	return w
}

func (o *IfCPUInfo) GetProtoMsg() *IfCPUInfo_ {
	if o == nil {
		return &IfCPUInfo_{}
	}

	return &IfCPUInfo_{
		LifKeyOrHandle: o.lif_key_or_handle.GetProtoMsg(),
	}
}

func (o *IfCPUInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfCPUInfoFromMessage(msg *IfCPUInfo_) *IfCPUInfo {
	if msg == nil {
		return &IfCPUInfo{}
	}

	return &IfCPUInfo{
		lif_key_or_handle: newLifKeyHandleFromMessage(msg.LifKeyOrHandle),
	}
}

type ClassicEnicInfo struct {
	sdkClient                  clientApi.Client
	parent                     delphiWrapper
	inp_prop_nat_l2seg_classic uint32
	membership_info            *EnicL2SegInfo
}

func (o *ClassicEnicInfo) Getinp_prop_nat_l2seg_classic() uint32 {
	return o.inp_prop_nat_l2seg_classic
}

func (o *ClassicEnicInfo) Setinp_prop_nat_l2seg_classic(val uint32) {
	o.inp_prop_nat_l2seg_classic = val
	o.bubbleSave()
}

func (o *ClassicEnicInfo) Getmembership_info() *EnicL2SegInfo {
	return o.membership_info
}

func (o *ClassicEnicInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *ClassicEnicInfo) save() {
}

func NewClassicEnicInfo(sdkClient clientApi.Client) *ClassicEnicInfo {
	w := &ClassicEnicInfo{}
	w.sdkClient = sdkClient
	w.membership_info = childNewEnicL2SegInfo(w, sdkClient)
	return w
}

func childNewClassicEnicInfo(parent delphiWrapper, sdkClient clientApi.Client) *ClassicEnicInfo {
	w := NewClassicEnicInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewClassicEnicInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *ClassicEnicInfo) *ClassicEnicInfo {
	w := childNewClassicEnicInfo(parent, sdkClient)
	w.inp_prop_nat_l2seg_classic = value.inp_prop_nat_l2seg_classic
	w.membership_info = childNewEnicL2SegInfoWithValue(w, sdkClient, value.membership_info)
	return w
}

func (o *ClassicEnicInfo) GetProtoMsg() *ClassicEnicInfo_ {
	if o == nil {
		return &ClassicEnicInfo_{}
	}

	return &ClassicEnicInfo_{
		InpPropNatL2SegClassic: o.inp_prop_nat_l2seg_classic,
		MembershipInfo:         o.membership_info.GetProtoMsg(),
	}
}

func (o *ClassicEnicInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newClassicEnicInfoFromMessage(msg *ClassicEnicInfo_) *ClassicEnicInfo {
	if msg == nil {
		return &ClassicEnicInfo{}
	}

	return &ClassicEnicInfo{
		inp_prop_nat_l2seg_classic: msg.InpPropNatL2SegClassic,
		membership_info:            newEnicL2SegInfoFromMessage(msg.MembershipInfo),
	}
}

type InterfaceGetResponse struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
	spec       *InterfaceSpec
	status     *InterfaceStatus
	stats      *InterfaceStats
}

func (o *InterfaceGetResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *InterfaceGetResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *InterfaceGetResponse) Getspec() *InterfaceSpec {
	return o.spec
}

func (o *InterfaceGetResponse) Getstatus() *InterfaceStatus {
	return o.status
}

func (o *InterfaceGetResponse) Getstats() *InterfaceStats {
	return o.stats
}

func (o *InterfaceGetResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceGetResponse) save() {
}

func NewInterfaceGetResponse(sdkClient clientApi.Client) *InterfaceGetResponse {
	w := &InterfaceGetResponse{}
	w.sdkClient = sdkClient
	w.spec = childNewInterfaceSpec(w, sdkClient)
	w.status = childNewInterfaceStatus(w, sdkClient)
	w.stats = childNewInterfaceStats(w, sdkClient)
	return w
}

func childNewInterfaceGetResponse(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceGetResponse {
	w := NewInterfaceGetResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceGetResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceGetResponse) *InterfaceGetResponse {
	w := childNewInterfaceGetResponse(parent, sdkClient)
	w.api_status = value.api_status
	w.spec = childNewInterfaceSpecWithValue(w, sdkClient, value.spec)
	w.status = childNewInterfaceStatusWithValue(w, sdkClient, value.status)
	w.stats = childNewInterfaceStatsWithValue(w, sdkClient, value.stats)
	return w
}

func (o *InterfaceGetResponse) GetProtoMsg() *InterfaceGetResponse_ {
	if o == nil {
		return &InterfaceGetResponse_{}
	}

	return &InterfaceGetResponse_{
		ApiStatus: o.api_status,
		Spec:      o.spec.GetProtoMsg(),
		Status:    o.status.GetProtoMsg(),
		Stats:     o.stats.GetProtoMsg(),
	}
}

func (o *InterfaceGetResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceGetResponseFromMessage(msg *InterfaceGetResponse_) *InterfaceGetResponse {
	if msg == nil {
		return &InterfaceGetResponse{}
	}

	return &InterfaceGetResponse{
		api_status: msg.ApiStatus,
		spec:       newInterfaceSpecFromMessage(msg.Spec),
		status:     newInterfaceStatusFromMessage(msg.Status),
		stats:      newInterfaceStatsFromMessage(msg.Stats),
	}
}

type Address struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	prefix     *IPSubnet
	addr_range *AddressRange
}

func (o *Address) Getprefix() *IPSubnet {
	return o.prefix
}

func (o *Address) Getaddr_range() *AddressRange {
	return o.addr_range
}

func (o *Address) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *Address) save() {
}

func NewAddress(sdkClient clientApi.Client) *Address {
	w := &Address{}
	w.sdkClient = sdkClient
	w.prefix = childNewIPSubnet(w, sdkClient)
	w.addr_range = childNewAddressRange(w, sdkClient)
	return w
}

func childNewAddress(parent delphiWrapper, sdkClient clientApi.Client) *Address {
	w := NewAddress(sdkClient)
	w.parent = parent
	return w
}

func childNewAddressWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *Address) *Address {
	w := childNewAddress(parent, sdkClient)
	w.prefix = childNewIPSubnetWithValue(w, sdkClient, value.prefix)
	w.addr_range = childNewAddressRangeWithValue(w, sdkClient, value.addr_range)
	return w
}

func (o *Address) GetProtoMsg() *Address_ {
	if o == nil {
		return &Address_{}
	}

	return &Address_{
		Prefix:    o.prefix.GetProtoMsg(),
		AddrRange: o.addr_range.GetProtoMsg(),
	}
}

func (o *Address) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newAddressFromMessage(msg *Address_) *Address {
	if msg == nil {
		return &Address{}
	}

	return &Address{
		prefix:     newIPSubnetFromMessage(msg.Prefix),
		addr_range: newAddressRangeFromMessage(msg.AddrRange),
	}
}

type LifRxStats struct {
	sdkClient           clientApi.Client
	parent              delphiWrapper
	frames_total        uint64
	frames_ok           uint64
	unicast_frames_ok   uint64
	multicast_frames_ok uint64
	broadcast_frames_ok uint64
	bytes_ok            uint64
	unicast_bytes_ok    uint64
	multicast_bytes_ok  uint64
	broadcast_bytes_ok  uint64
	drops               uint64
	no_bufs             uint64
	errors              uint64
	rss                 uint64
	crc_errors          uint64
	frames_64           uint64
	frames_127          uint64
	frames_255          uint64
	frames_511          uint64
	frames_1024         uint64
	frames_1518         uint64
	frames_to_max       uint64
}

func (o *LifRxStats) Getframes_total() uint64 {
	return o.frames_total
}

func (o *LifRxStats) Setframes_total(val uint64) {
	o.frames_total = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_ok() uint64 {
	return o.frames_ok
}

func (o *LifRxStats) Setframes_ok(val uint64) {
	o.frames_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getunicast_frames_ok() uint64 {
	return o.unicast_frames_ok
}

func (o *LifRxStats) Setunicast_frames_ok(val uint64) {
	o.unicast_frames_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getmulticast_frames_ok() uint64 {
	return o.multicast_frames_ok
}

func (o *LifRxStats) Setmulticast_frames_ok(val uint64) {
	o.multicast_frames_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getbroadcast_frames_ok() uint64 {
	return o.broadcast_frames_ok
}

func (o *LifRxStats) Setbroadcast_frames_ok(val uint64) {
	o.broadcast_frames_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getbytes_ok() uint64 {
	return o.bytes_ok
}

func (o *LifRxStats) Setbytes_ok(val uint64) {
	o.bytes_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getunicast_bytes_ok() uint64 {
	return o.unicast_bytes_ok
}

func (o *LifRxStats) Setunicast_bytes_ok(val uint64) {
	o.unicast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getmulticast_bytes_ok() uint64 {
	return o.multicast_bytes_ok
}

func (o *LifRxStats) Setmulticast_bytes_ok(val uint64) {
	o.multicast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getbroadcast_bytes_ok() uint64 {
	return o.broadcast_bytes_ok
}

func (o *LifRxStats) Setbroadcast_bytes_ok(val uint64) {
	o.broadcast_bytes_ok = val
	o.bubbleSave()
}

func (o *LifRxStats) Getdrops() uint64 {
	return o.drops
}

func (o *LifRxStats) Setdrops(val uint64) {
	o.drops = val
	o.bubbleSave()
}

func (o *LifRxStats) Getno_bufs() uint64 {
	return o.no_bufs
}

func (o *LifRxStats) Setno_bufs(val uint64) {
	o.no_bufs = val
	o.bubbleSave()
}

func (o *LifRxStats) Geterrors() uint64 {
	return o.errors
}

func (o *LifRxStats) Seterrors(val uint64) {
	o.errors = val
	o.bubbleSave()
}

func (o *LifRxStats) Getrss() uint64 {
	return o.rss
}

func (o *LifRxStats) Setrss(val uint64) {
	o.rss = val
	o.bubbleSave()
}

func (o *LifRxStats) Getcrc_errors() uint64 {
	return o.crc_errors
}

func (o *LifRxStats) Setcrc_errors(val uint64) {
	o.crc_errors = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_64() uint64 {
	return o.frames_64
}

func (o *LifRxStats) Setframes_64(val uint64) {
	o.frames_64 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_127() uint64 {
	return o.frames_127
}

func (o *LifRxStats) Setframes_127(val uint64) {
	o.frames_127 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_255() uint64 {
	return o.frames_255
}

func (o *LifRxStats) Setframes_255(val uint64) {
	o.frames_255 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_511() uint64 {
	return o.frames_511
}

func (o *LifRxStats) Setframes_511(val uint64) {
	o.frames_511 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_1024() uint64 {
	return o.frames_1024
}

func (o *LifRxStats) Setframes_1024(val uint64) {
	o.frames_1024 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_1518() uint64 {
	return o.frames_1518
}

func (o *LifRxStats) Setframes_1518(val uint64) {
	o.frames_1518 = val
	o.bubbleSave()
}

func (o *LifRxStats) Getframes_to_max() uint64 {
	return o.frames_to_max
}

func (o *LifRxStats) Setframes_to_max(val uint64) {
	o.frames_to_max = val
	o.bubbleSave()
}

func (o *LifRxStats) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifRxStats) save() {
}

func NewLifRxStats(sdkClient clientApi.Client) *LifRxStats {
	w := &LifRxStats{}
	w.sdkClient = sdkClient
	return w
}

func childNewLifRxStats(parent delphiWrapper, sdkClient clientApi.Client) *LifRxStats {
	w := NewLifRxStats(sdkClient)
	w.parent = parent
	return w
}

func childNewLifRxStatsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifRxStats) *LifRxStats {
	w := childNewLifRxStats(parent, sdkClient)
	w.frames_total = value.frames_total
	w.frames_ok = value.frames_ok
	w.unicast_frames_ok = value.unicast_frames_ok
	w.multicast_frames_ok = value.multicast_frames_ok
	w.broadcast_frames_ok = value.broadcast_frames_ok
	w.bytes_ok = value.bytes_ok
	w.unicast_bytes_ok = value.unicast_bytes_ok
	w.multicast_bytes_ok = value.multicast_bytes_ok
	w.broadcast_bytes_ok = value.broadcast_bytes_ok
	w.drops = value.drops
	w.no_bufs = value.no_bufs
	w.errors = value.errors
	w.rss = value.rss
	w.crc_errors = value.crc_errors
	w.frames_64 = value.frames_64
	w.frames_127 = value.frames_127
	w.frames_255 = value.frames_255
	w.frames_511 = value.frames_511
	w.frames_1024 = value.frames_1024
	w.frames_1518 = value.frames_1518
	w.frames_to_max = value.frames_to_max
	return w
}

func (o *LifRxStats) GetProtoMsg() *LifRxStats_ {
	if o == nil {
		return &LifRxStats_{}
	}

	return &LifRxStats_{
		FramesTotal:       o.frames_total,
		FramesOk:          o.frames_ok,
		UnicastFramesOk:   o.unicast_frames_ok,
		MulticastFramesOk: o.multicast_frames_ok,
		BroadcastFramesOk: o.broadcast_frames_ok,
		BytesOk:           o.bytes_ok,
		UnicastBytesOk:    o.unicast_bytes_ok,
		MulticastBytesOk:  o.multicast_bytes_ok,
		BroadcastBytesOk:  o.broadcast_bytes_ok,
		Drops:             o.drops,
		NoBufs:            o.no_bufs,
		Errors:            o.errors,
		Rss:               o.rss,
		CrcErrors:         o.crc_errors,
		Frames_64:         o.frames_64,
		Frames_127:        o.frames_127,
		Frames_255:        o.frames_255,
		Frames_511:        o.frames_511,
		Frames_1024:       o.frames_1024,
		Frames_1518:       o.frames_1518,
		FramesToMax:       o.frames_to_max,
	}
}

func (o *LifRxStats) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifRxStatsFromMessage(msg *LifRxStats_) *LifRxStats {
	if msg == nil {
		return &LifRxStats{}
	}

	return &LifRxStats{
		frames_total:        msg.FramesTotal,
		frames_ok:           msg.FramesOk,
		unicast_frames_ok:   msg.UnicastFramesOk,
		multicast_frames_ok: msg.MulticastFramesOk,
		broadcast_frames_ok: msg.BroadcastFramesOk,
		bytes_ok:            msg.BytesOk,
		unicast_bytes_ok:    msg.UnicastBytesOk,
		multicast_bytes_ok:  msg.MulticastBytesOk,
		broadcast_bytes_ok:  msg.BroadcastBytesOk,
		drops:               msg.Drops,
		no_bufs:             msg.NoBufs,
		errors:              msg.Errors,
		rss:                 msg.Rss,
		crc_errors:          msg.CrcErrors,
		frames_64:           msg.Frames_64,
		frames_127:          msg.Frames_127,
		frames_255:          msg.Frames_255,
		frames_511:          msg.Frames_511,
		frames_1024:         msg.Frames_1024,
		frames_1518:         msg.Frames_1518,
		frames_to_max:       msg.FramesToMax,
	}
}

type IfTunnelGREInfo struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	source      *IPAddress
	destination *IPAddress
	mtu         uint32
	ttl         uint32
}

func (o *IfTunnelGREInfo) Getsource() *IPAddress {
	return o.source
}

func (o *IfTunnelGREInfo) Getdestination() *IPAddress {
	return o.destination
}

func (o *IfTunnelGREInfo) Getmtu() uint32 {
	return o.mtu
}

func (o *IfTunnelGREInfo) Setmtu(val uint32) {
	o.mtu = val
	o.bubbleSave()
}

func (o *IfTunnelGREInfo) Getttl() uint32 {
	return o.ttl
}

func (o *IfTunnelGREInfo) Setttl(val uint32) {
	o.ttl = val
	o.bubbleSave()
}

func (o *IfTunnelGREInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfTunnelGREInfo) save() {
}

func NewIfTunnelGREInfo(sdkClient clientApi.Client) *IfTunnelGREInfo {
	w := &IfTunnelGREInfo{}
	w.sdkClient = sdkClient
	w.source = childNewIPAddress(w, sdkClient)
	w.destination = childNewIPAddress(w, sdkClient)
	return w
}

func childNewIfTunnelGREInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfTunnelGREInfo {
	w := NewIfTunnelGREInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfTunnelGREInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfTunnelGREInfo) *IfTunnelGREInfo {
	w := childNewIfTunnelGREInfo(parent, sdkClient)
	w.source = childNewIPAddressWithValue(w, sdkClient, value.source)
	w.destination = childNewIPAddressWithValue(w, sdkClient, value.destination)
	w.mtu = value.mtu
	w.ttl = value.ttl
	return w
}

func (o *IfTunnelGREInfo) GetProtoMsg() *IfTunnelGREInfo_ {
	if o == nil {
		return &IfTunnelGREInfo_{}
	}

	return &IfTunnelGREInfo_{
		Source:      o.source.GetProtoMsg(),
		Destination: o.destination.GetProtoMsg(),
		Mtu:         o.mtu,
		Ttl:         o.ttl,
	}
}

func (o *IfTunnelGREInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfTunnelGREInfoFromMessage(msg *IfTunnelGREInfo_) *IfTunnelGREInfo {
	if msg == nil {
		return &IfTunnelGREInfo{}
	}

	return &IfTunnelGREInfo{
		source:      newIPAddressFromMessage(msg.Source),
		destination: newIPAddressFromMessage(msg.Destination),
		mtu:         msg.Mtu,
		ttl:         msg.Ttl,
	}
}

type InterfaceL2SegmentSpec struct {
	sdkClient               clientApi.Client
	parent                  delphiWrapper
	l2segment_key_or_handle *L2SegmentKeyHandle
	if_key_handle           *InterfaceKeyHandle
}

func (o *InterfaceL2SegmentSpec) Getl2segment_key_or_handle() *L2SegmentKeyHandle {
	return o.l2segment_key_or_handle
}

func (o *InterfaceL2SegmentSpec) Getif_key_handle() *InterfaceKeyHandle {
	return o.if_key_handle
}

func (o *InterfaceL2SegmentSpec) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceL2SegmentSpec) save() {
}

func NewInterfaceL2SegmentSpec(sdkClient clientApi.Client) *InterfaceL2SegmentSpec {
	w := &InterfaceL2SegmentSpec{}
	w.sdkClient = sdkClient
	w.l2segment_key_or_handle = childNewL2SegmentKeyHandle(w, sdkClient)
	w.if_key_handle = childNewInterfaceKeyHandle(w, sdkClient)
	return w
}

func childNewInterfaceL2SegmentSpec(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceL2SegmentSpec {
	w := NewInterfaceL2SegmentSpec(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceL2SegmentSpecWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceL2SegmentSpec) *InterfaceL2SegmentSpec {
	w := childNewInterfaceL2SegmentSpec(parent, sdkClient)
	w.l2segment_key_or_handle = childNewL2SegmentKeyHandleWithValue(w, sdkClient, value.l2segment_key_or_handle)
	w.if_key_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.if_key_handle)
	return w
}

func (o *InterfaceL2SegmentSpec) GetProtoMsg() *InterfaceL2SegmentSpec_ {
	if o == nil {
		return &InterfaceL2SegmentSpec_{}
	}

	return &InterfaceL2SegmentSpec_{
		L2SegmentKeyOrHandle: o.l2segment_key_or_handle.GetProtoMsg(),
		IfKeyHandle:          o.if_key_handle.GetProtoMsg(),
	}
}

func (o *InterfaceL2SegmentSpec) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceL2SegmentSpecFromMessage(msg *InterfaceL2SegmentSpec_) *InterfaceL2SegmentSpec {
	if msg == nil {
		return &InterfaceL2SegmentSpec{}
	}

	return &InterfaceL2SegmentSpec{
		l2segment_key_or_handle: newL2SegmentKeyHandleFromMessage(msg.L2SegmentKeyOrHandle),
		if_key_handle:           newInterfaceKeyHandleFromMessage(msg.IfKeyHandle),
	}
}

type InterfaceL2SegmentResponseMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	response  *InterfaceL2SegmentResponse
}

func (o *InterfaceL2SegmentResponseMsg) Getresponse() *InterfaceL2SegmentResponse {
	return o.response
}

func (o *InterfaceL2SegmentResponseMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceL2SegmentResponseMsg) save() {
}

func NewInterfaceL2SegmentResponseMsg(sdkClient clientApi.Client) *InterfaceL2SegmentResponseMsg {
	w := &InterfaceL2SegmentResponseMsg{}
	w.sdkClient = sdkClient
	w.response = childNewInterfaceL2SegmentResponse(w, sdkClient)
	return w
}

func childNewInterfaceL2SegmentResponseMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceL2SegmentResponseMsg {
	w := NewInterfaceL2SegmentResponseMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceL2SegmentResponseMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceL2SegmentResponseMsg) *InterfaceL2SegmentResponseMsg {
	w := childNewInterfaceL2SegmentResponseMsg(parent, sdkClient)
	w.response = childNewInterfaceL2SegmentResponseWithValue(w, sdkClient, value.response)
	return w
}

func (o *InterfaceL2SegmentResponseMsg) GetProtoMsg() *InterfaceL2SegmentResponseMsg_ {
	if o == nil {
		return &InterfaceL2SegmentResponseMsg_{}
	}

	return &InterfaceL2SegmentResponseMsg_{
		Response: o.response.GetProtoMsg(),
	}
}

func (o *InterfaceL2SegmentResponseMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceL2SegmentResponseMsgFromMessage(msg *InterfaceL2SegmentResponseMsg_) *InterfaceL2SegmentResponseMsg {
	if msg == nil {
		return &InterfaceL2SegmentResponseMsg{}
	}

	return &InterfaceL2SegmentResponseMsg{
		response: newInterfaceL2SegmentResponseFromMessage(msg.Response),
	}
}

type IPPrefix struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	address    *IPAddress
	prefix_len uint32
}

func (o *IPPrefix) Getaddress() *IPAddress {
	return o.address
}

func (o *IPPrefix) Getprefix_len() uint32 {
	return o.prefix_len
}

func (o *IPPrefix) Setprefix_len(val uint32) {
	o.prefix_len = val
	o.bubbleSave()
}

func (o *IPPrefix) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IPPrefix) save() {
}

func NewIPPrefix(sdkClient clientApi.Client) *IPPrefix {
	w := &IPPrefix{}
	w.sdkClient = sdkClient
	w.address = childNewIPAddress(w, sdkClient)
	return w
}

func childNewIPPrefix(parent delphiWrapper, sdkClient clientApi.Client) *IPPrefix {
	w := NewIPPrefix(sdkClient)
	w.parent = parent
	return w
}

func childNewIPPrefixWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IPPrefix) *IPPrefix {
	w := childNewIPPrefix(parent, sdkClient)
	w.address = childNewIPAddressWithValue(w, sdkClient, value.address)
	w.prefix_len = value.prefix_len
	return w
}

func (o *IPPrefix) GetProtoMsg() *IPPrefix_ {
	if o == nil {
		return &IPPrefix_{}
	}

	return &IPPrefix_{
		Address:   o.address.GetProtoMsg(),
		PrefixLen: o.prefix_len,
	}
}

func (o *IPPrefix) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIPPrefixFromMessage(msg *IPPrefix_) *IPPrefix {
	if msg == nil {
		return &IPPrefix{}
	}

	return &IPPrefix{
		address:    newIPAddressFromMessage(msg.Address),
		prefix_len: msg.PrefixLen,
	}
}

type IfUplinkInfo struct {
	sdkClient           clientApi.Client
	parent              delphiWrapper
	port_num            uint32
	native_l2segment_id uint64
	is_oob_management   bool
}

func (o *IfUplinkInfo) Getport_num() uint32 {
	return o.port_num
}

func (o *IfUplinkInfo) Setport_num(val uint32) {
	o.port_num = val
	o.bubbleSave()
}

func (o *IfUplinkInfo) Getnative_l2segment_id() uint64 {
	return o.native_l2segment_id
}

func (o *IfUplinkInfo) Setnative_l2segment_id(val uint64) {
	o.native_l2segment_id = val
	o.bubbleSave()
}

func (o *IfUplinkInfo) Getis_oob_management() bool {
	return o.is_oob_management
}

func (o *IfUplinkInfo) Setis_oob_management(val bool) {
	o.is_oob_management = val
	o.bubbleSave()
}

func (o *IfUplinkInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfUplinkInfo) save() {
}

func NewIfUplinkInfo(sdkClient clientApi.Client) *IfUplinkInfo {
	w := &IfUplinkInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewIfUplinkInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfUplinkInfo {
	w := NewIfUplinkInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfUplinkInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfUplinkInfo) *IfUplinkInfo {
	w := childNewIfUplinkInfo(parent, sdkClient)
	w.port_num = value.port_num
	w.native_l2segment_id = value.native_l2segment_id
	w.is_oob_management = value.is_oob_management
	return w
}

func (o *IfUplinkInfo) GetProtoMsg() *IfUplinkInfo_ {
	if o == nil {
		return &IfUplinkInfo_{}
	}

	return &IfUplinkInfo_{
		PortNum:           o.port_num,
		NativeL2SegmentId: o.native_l2segment_id,
		IsOobManagement:   o.is_oob_management,
	}
}

func (o *IfUplinkInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfUplinkInfoFromMessage(msg *IfUplinkInfo_) *IfUplinkInfo {
	if msg == nil {
		return &IfUplinkInfo{}
	}

	return &IfUplinkInfo{
		port_num:            msg.PortNum,
		native_l2segment_id: msg.NativeL2SegmentId,
		is_oob_management:   msg.IsOobManagement,
	}
}

type UplinkResponseInfo struct {
	sdkClient       clientApi.Client
	parent          delphiWrapper
	uplink_lport_id uint32
	hw_lif_id       uint32
	uplink_idx      uint32
	num_l2segs      uint32
	hw_port_num     uint32
}

func (o *UplinkResponseInfo) Getuplink_lport_id() uint32 {
	return o.uplink_lport_id
}

func (o *UplinkResponseInfo) Setuplink_lport_id(val uint32) {
	o.uplink_lport_id = val
	o.bubbleSave()
}

func (o *UplinkResponseInfo) Gethw_lif_id() uint32 {
	return o.hw_lif_id
}

func (o *UplinkResponseInfo) Sethw_lif_id(val uint32) {
	o.hw_lif_id = val
	o.bubbleSave()
}

func (o *UplinkResponseInfo) Getuplink_idx() uint32 {
	return o.uplink_idx
}

func (o *UplinkResponseInfo) Setuplink_idx(val uint32) {
	o.uplink_idx = val
	o.bubbleSave()
}

func (o *UplinkResponseInfo) Getnum_l2segs() uint32 {
	return o.num_l2segs
}

func (o *UplinkResponseInfo) Setnum_l2segs(val uint32) {
	o.num_l2segs = val
	o.bubbleSave()
}

func (o *UplinkResponseInfo) Gethw_port_num() uint32 {
	return o.hw_port_num
}

func (o *UplinkResponseInfo) Sethw_port_num(val uint32) {
	o.hw_port_num = val
	o.bubbleSave()
}

func (o *UplinkResponseInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UplinkResponseInfo) save() {
}

func NewUplinkResponseInfo(sdkClient clientApi.Client) *UplinkResponseInfo {
	w := &UplinkResponseInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewUplinkResponseInfo(parent delphiWrapper, sdkClient clientApi.Client) *UplinkResponseInfo {
	w := NewUplinkResponseInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewUplinkResponseInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UplinkResponseInfo) *UplinkResponseInfo {
	w := childNewUplinkResponseInfo(parent, sdkClient)
	w.uplink_lport_id = value.uplink_lport_id
	w.hw_lif_id = value.hw_lif_id
	w.uplink_idx = value.uplink_idx
	w.num_l2segs = value.num_l2segs
	w.hw_port_num = value.hw_port_num
	return w
}

func (o *UplinkResponseInfo) GetProtoMsg() *UplinkResponseInfo_ {
	if o == nil {
		return &UplinkResponseInfo_{}
	}

	return &UplinkResponseInfo_{
		UplinkLportId: o.uplink_lport_id,
		HwLifId:       o.hw_lif_id,
		UplinkIdx:     o.uplink_idx,
		NumL2Segs:     o.num_l2segs,
		HwPortNum:     o.hw_port_num,
	}
}

func (o *UplinkResponseInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newUplinkResponseInfoFromMessage(msg *UplinkResponseInfo_) *UplinkResponseInfo {
	if msg == nil {
		return &UplinkResponseInfo{}
	}

	return &UplinkResponseInfo{
		uplink_lport_id: msg.UplinkLportId,
		hw_lif_id:       msg.HwLifId,
		uplink_idx:      msg.UplinkIdx,
		num_l2segs:      msg.NumL2Segs,
		hw_port_num:     msg.HwPortNum,
	}
}

type InterfaceStatus struct {
	sdkClient      clientApi.Client
	parent         delphiWrapper
	meta           *delphi.ObjectMeta
	key_or_handle  *InterfaceKeyHandle
	if_status      IntfStatus
	if_handle      uint64
	uplink_info    *UplinkResponseInfo
	enic_info      *EnicResponseInfo
	cpu_info       *CpuIfResponseInfo
	tunnel_info    *TunnelIfResponseInfo
	app_redir_info *AppRedirIfInfo
}

func (o *InterfaceStatus) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *InterfaceStatus) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *InterfaceStatus) Getkey_or_handle() *InterfaceKeyHandle {
	return o.key_or_handle
}

func (o *InterfaceStatus) Getif_status() IntfStatus {
	return o.if_status
}

func (o *InterfaceStatus) Setif_status(val IntfStatus) {
	o.if_status = val
	o.bubbleSave()
}

func (o *InterfaceStatus) Getif_handle() uint64 {
	return o.if_handle
}

func (o *InterfaceStatus) Setif_handle(val uint64) {
	o.if_handle = val
	o.bubbleSave()
}

func (o *InterfaceStatus) Getuplink_info() *UplinkResponseInfo {
	return o.uplink_info
}

func (o *InterfaceStatus) Getenic_info() *EnicResponseInfo {
	return o.enic_info
}

func (o *InterfaceStatus) Getcpu_info() *CpuIfResponseInfo {
	return o.cpu_info
}

func (o *InterfaceStatus) Gettunnel_info() *TunnelIfResponseInfo {
	return o.tunnel_info
}

func (o *InterfaceStatus) Getapp_redir_info() *AppRedirIfInfo {
	return o.app_redir_info
}

func (o *InterfaceStatus) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceStatus) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *InterfaceStatus) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewInterfaceStatus(sdkClient clientApi.Client) *InterfaceStatus {
	w := &InterfaceStatus{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "InterfaceStatus",
	}
	w.key_or_handle = childNewInterfaceKeyHandle(w, sdkClient)
	w.uplink_info = childNewUplinkResponseInfo(w, sdkClient)
	w.enic_info = childNewEnicResponseInfo(w, sdkClient)
	w.cpu_info = childNewCpuIfResponseInfo(w, sdkClient)
	w.tunnel_info = childNewTunnelIfResponseInfo(w, sdkClient)
	w.app_redir_info = childNewAppRedirIfInfo(w, sdkClient)
	return w
}

func NewInterfaceStatusWithKey(sdkClient clientApi.Client, key *InterfaceKeyHandle) *InterfaceStatus {
	w := NewInterfaceStatus(sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, key)
	return w
}

func NewInterfaceStatusFromMessage(sdkClient clientApi.Client, msg *InterfaceStatus_) *InterfaceStatus {
	obj := newInterfaceStatusFromMessage(msg)
	obj.sdkClient = sdkClient
	obj.meta = &delphi.ObjectMeta{
		Kind: "InterfaceStatus",
	}

	obj.bubbleSave()
	return obj
}

func GetInterfaceStatus(sdkClient clientApi.Client, key *InterfaceKeyHandle) *InterfaceStatus {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("InterfaceStatus", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*InterfaceStatus)
	if !ok {
		panic("Couldn't cast to InterfaceStatus")
	}
	return o
}

func childNewInterfaceStatus(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceStatus {
	w := NewInterfaceStatus(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceStatusWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceStatus) *InterfaceStatus {
	w := childNewInterfaceStatus(parent, sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	w.if_status = value.if_status
	w.if_handle = value.if_handle
	w.uplink_info = childNewUplinkResponseInfoWithValue(w, sdkClient, value.uplink_info)
	w.enic_info = childNewEnicResponseInfoWithValue(w, sdkClient, value.enic_info)
	w.cpu_info = childNewCpuIfResponseInfoWithValue(w, sdkClient, value.cpu_info)
	w.tunnel_info = childNewTunnelIfResponseInfoWithValue(w, sdkClient, value.tunnel_info)
	w.app_redir_info = childNewAppRedirIfInfoWithValue(w, sdkClient, value.app_redir_info)
	return w
}

func (o *InterfaceStatus) GetProtoMsg() *InterfaceStatus_ {
	if o == nil {
		return &InterfaceStatus_{}
	}

	return &InterfaceStatus_{
		Meta:         o.meta,
		KeyOrHandle:  o.key_or_handle.GetProtoMsg(),
		IfStatus:     o.if_status,
		IfHandle:     o.if_handle,
		UplinkInfo:   o.uplink_info.GetProtoMsg(),
		EnicInfo:     o.enic_info.GetProtoMsg(),
		CpuInfo:      o.cpu_info.GetProtoMsg(),
		TunnelInfo:   o.tunnel_info.GetProtoMsg(),
		AppRedirInfo: o.app_redir_info.GetProtoMsg(),
	}
}

func (o *InterfaceStatus) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *InterfaceStatus) GetKeyString() string {
	return obj.key_or_handle.GetProtoMsg().String()
}

func (obj *InterfaceStatus) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(InterfaceStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnInterfaceStatusCreate(obj)
			} else {
				rctr.OnInterfaceStatusUpdate(obj)
			}
		} else {
			rctr.OnInterfaceStatusDelete(obj)
		}
	}
}

type InterfaceStatusReactor interface {
	OnInterfaceStatusCreate(obj *InterfaceStatus)
	OnInterfaceStatusUpdate(obj *InterfaceStatus)
	OnInterfaceStatusDelete(obj *InterfaceStatus)
}

func (obj *InterfaceStatus) GetPath() string {
	return "InterfaceStatus" + "|" + obj.GetKeyString()
}

func newInterfaceStatusFromMessage(msg *InterfaceStatus_) *InterfaceStatus {
	if msg == nil {
		return &InterfaceStatus{}
	}

	return &InterfaceStatus{
		meta:           msg.Meta,
		key_or_handle:  newInterfaceKeyHandleFromMessage(msg.KeyOrHandle),
		if_status:      msg.IfStatus,
		if_handle:      msg.IfHandle,
		uplink_info:    newUplinkResponseInfoFromMessage(msg.UplinkInfo),
		enic_info:      newEnicResponseInfoFromMessage(msg.EnicInfo),
		cpu_info:       newCpuIfResponseInfoFromMessage(msg.CpuInfo),
		tunnel_info:    newTunnelIfResponseInfoFromMessage(msg.TunnelInfo),
		app_redir_info: newAppRedirIfInfoFromMessage(msg.AppRedirInfo),
	}
}

func interfaceStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg InterfaceStatus_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newInterfaceStatusFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func InterfaceStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("InterfaceStatus", mode)
}

func InterfaceStatusMountKey(client clientApi.Client, key *InterfaceKeyHandle, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("InterfaceStatus", keyString, mode)
}

func InterfaceStatusWatch(client clientApi.Client, reactor InterfaceStatusReactor) {
	client.WatchKind("InterfaceStatus", reactor)
}

type InterfaceStatusIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *InterfaceStatusIterator) Next() *InterfaceStatus {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*InterfaceStatus)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func InterfaceStatusList(client clientApi.Client) *InterfaceStatusIterator {
	return &InterfaceStatusIterator{
		objects: client.List("InterfaceStatus"),
		cur:     0,
	}
}

type InterfaceL2SegmentResponse struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	api_status ApiStatus
}

func (o *InterfaceL2SegmentResponse) Getapi_status() ApiStatus {
	return o.api_status
}

func (o *InterfaceL2SegmentResponse) Setapi_status(val ApiStatus) {
	o.api_status = val
	o.bubbleSave()
}

func (o *InterfaceL2SegmentResponse) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceL2SegmentResponse) save() {
}

func NewInterfaceL2SegmentResponse(sdkClient clientApi.Client) *InterfaceL2SegmentResponse {
	w := &InterfaceL2SegmentResponse{}
	w.sdkClient = sdkClient
	return w
}

func childNewInterfaceL2SegmentResponse(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceL2SegmentResponse {
	w := NewInterfaceL2SegmentResponse(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceL2SegmentResponseWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceL2SegmentResponse) *InterfaceL2SegmentResponse {
	w := childNewInterfaceL2SegmentResponse(parent, sdkClient)
	w.api_status = value.api_status
	return w
}

func (o *InterfaceL2SegmentResponse) GetProtoMsg() *InterfaceL2SegmentResponse_ {
	if o == nil {
		return &InterfaceL2SegmentResponse_{}
	}

	return &InterfaceL2SegmentResponse_{
		ApiStatus: o.api_status,
	}
}

func (o *InterfaceL2SegmentResponse) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceL2SegmentResponseFromMessage(msg *InterfaceL2SegmentResponse_) *InterfaceL2SegmentResponse {
	if msg == nil {
		return &InterfaceL2SegmentResponse{}
	}

	return &InterfaceL2SegmentResponse{
		api_status: msg.ApiStatus,
	}
}

type DropReasons struct {
	sdkClient                            clientApi.Client
	parent                               delphiWrapper
	drop_malformed_pkt                   bool
	drop_input_mapping                   bool
	drop_input_mapping_dejavu            bool
	drop_flow_hit                        bool
	drop_flow_miss                       bool
	drop_nacl                            bool
	drop_ipsg                            bool
	drop_ip_normalization                bool
	drop_tcp_normalization               bool
	drop_tcp_rst_with_invalid_ack_num    bool
	drop_tcp_non_syn_first_pkt           bool
	drop_icmp_normalization              bool
	drop_input_properties_miss           bool
	drop_tcp_out_of_window               bool
	drop_tcp_split_handshake             bool
	drop_tcp_win_zero_drop               bool
	drop_tcp_data_after_fin              bool
	drop_tcp_non_rst_pkt_after_rst       bool
	drop_tcp_invalid_responder_first_pkt bool
	drop_tcp_unexpected_pkt              bool
	drop_src_lif_mismatch                bool
	drop_parser_icrc_error               bool
	drop_parse_len_error                 bool
	drop_hardware_error                  bool
}

func (o *DropReasons) Getdrop_malformed_pkt() bool {
	return o.drop_malformed_pkt
}

func (o *DropReasons) Setdrop_malformed_pkt(val bool) {
	o.drop_malformed_pkt = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_input_mapping() bool {
	return o.drop_input_mapping
}

func (o *DropReasons) Setdrop_input_mapping(val bool) {
	o.drop_input_mapping = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_input_mapping_dejavu() bool {
	return o.drop_input_mapping_dejavu
}

func (o *DropReasons) Setdrop_input_mapping_dejavu(val bool) {
	o.drop_input_mapping_dejavu = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_flow_hit() bool {
	return o.drop_flow_hit
}

func (o *DropReasons) Setdrop_flow_hit(val bool) {
	o.drop_flow_hit = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_flow_miss() bool {
	return o.drop_flow_miss
}

func (o *DropReasons) Setdrop_flow_miss(val bool) {
	o.drop_flow_miss = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_nacl() bool {
	return o.drop_nacl
}

func (o *DropReasons) Setdrop_nacl(val bool) {
	o.drop_nacl = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_ipsg() bool {
	return o.drop_ipsg
}

func (o *DropReasons) Setdrop_ipsg(val bool) {
	o.drop_ipsg = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_ip_normalization() bool {
	return o.drop_ip_normalization
}

func (o *DropReasons) Setdrop_ip_normalization(val bool) {
	o.drop_ip_normalization = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_normalization() bool {
	return o.drop_tcp_normalization
}

func (o *DropReasons) Setdrop_tcp_normalization(val bool) {
	o.drop_tcp_normalization = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_rst_with_invalid_ack_num() bool {
	return o.drop_tcp_rst_with_invalid_ack_num
}

func (o *DropReasons) Setdrop_tcp_rst_with_invalid_ack_num(val bool) {
	o.drop_tcp_rst_with_invalid_ack_num = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_non_syn_first_pkt() bool {
	return o.drop_tcp_non_syn_first_pkt
}

func (o *DropReasons) Setdrop_tcp_non_syn_first_pkt(val bool) {
	o.drop_tcp_non_syn_first_pkt = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_icmp_normalization() bool {
	return o.drop_icmp_normalization
}

func (o *DropReasons) Setdrop_icmp_normalization(val bool) {
	o.drop_icmp_normalization = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_input_properties_miss() bool {
	return o.drop_input_properties_miss
}

func (o *DropReasons) Setdrop_input_properties_miss(val bool) {
	o.drop_input_properties_miss = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_out_of_window() bool {
	return o.drop_tcp_out_of_window
}

func (o *DropReasons) Setdrop_tcp_out_of_window(val bool) {
	o.drop_tcp_out_of_window = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_split_handshake() bool {
	return o.drop_tcp_split_handshake
}

func (o *DropReasons) Setdrop_tcp_split_handshake(val bool) {
	o.drop_tcp_split_handshake = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_win_zero_drop() bool {
	return o.drop_tcp_win_zero_drop
}

func (o *DropReasons) Setdrop_tcp_win_zero_drop(val bool) {
	o.drop_tcp_win_zero_drop = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_data_after_fin() bool {
	return o.drop_tcp_data_after_fin
}

func (o *DropReasons) Setdrop_tcp_data_after_fin(val bool) {
	o.drop_tcp_data_after_fin = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_non_rst_pkt_after_rst() bool {
	return o.drop_tcp_non_rst_pkt_after_rst
}

func (o *DropReasons) Setdrop_tcp_non_rst_pkt_after_rst(val bool) {
	o.drop_tcp_non_rst_pkt_after_rst = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_invalid_responder_first_pkt() bool {
	return o.drop_tcp_invalid_responder_first_pkt
}

func (o *DropReasons) Setdrop_tcp_invalid_responder_first_pkt(val bool) {
	o.drop_tcp_invalid_responder_first_pkt = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_tcp_unexpected_pkt() bool {
	return o.drop_tcp_unexpected_pkt
}

func (o *DropReasons) Setdrop_tcp_unexpected_pkt(val bool) {
	o.drop_tcp_unexpected_pkt = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_src_lif_mismatch() bool {
	return o.drop_src_lif_mismatch
}

func (o *DropReasons) Setdrop_src_lif_mismatch(val bool) {
	o.drop_src_lif_mismatch = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_parser_icrc_error() bool {
	return o.drop_parser_icrc_error
}

func (o *DropReasons) Setdrop_parser_icrc_error(val bool) {
	o.drop_parser_icrc_error = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_parse_len_error() bool {
	return o.drop_parse_len_error
}

func (o *DropReasons) Setdrop_parse_len_error(val bool) {
	o.drop_parse_len_error = val
	o.bubbleSave()
}

func (o *DropReasons) Getdrop_hardware_error() bool {
	return o.drop_hardware_error
}

func (o *DropReasons) Setdrop_hardware_error(val bool) {
	o.drop_hardware_error = val
	o.bubbleSave()
}

func (o *DropReasons) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *DropReasons) save() {
}

func NewDropReasons(sdkClient clientApi.Client) *DropReasons {
	w := &DropReasons{}
	w.sdkClient = sdkClient
	return w
}

func childNewDropReasons(parent delphiWrapper, sdkClient clientApi.Client) *DropReasons {
	w := NewDropReasons(sdkClient)
	w.parent = parent
	return w
}

func childNewDropReasonsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *DropReasons) *DropReasons {
	w := childNewDropReasons(parent, sdkClient)
	w.drop_malformed_pkt = value.drop_malformed_pkt
	w.drop_input_mapping = value.drop_input_mapping
	w.drop_input_mapping_dejavu = value.drop_input_mapping_dejavu
	w.drop_flow_hit = value.drop_flow_hit
	w.drop_flow_miss = value.drop_flow_miss
	w.drop_nacl = value.drop_nacl
	w.drop_ipsg = value.drop_ipsg
	w.drop_ip_normalization = value.drop_ip_normalization
	w.drop_tcp_normalization = value.drop_tcp_normalization
	w.drop_tcp_rst_with_invalid_ack_num = value.drop_tcp_rst_with_invalid_ack_num
	w.drop_tcp_non_syn_first_pkt = value.drop_tcp_non_syn_first_pkt
	w.drop_icmp_normalization = value.drop_icmp_normalization
	w.drop_input_properties_miss = value.drop_input_properties_miss
	w.drop_tcp_out_of_window = value.drop_tcp_out_of_window
	w.drop_tcp_split_handshake = value.drop_tcp_split_handshake
	w.drop_tcp_win_zero_drop = value.drop_tcp_win_zero_drop
	w.drop_tcp_data_after_fin = value.drop_tcp_data_after_fin
	w.drop_tcp_non_rst_pkt_after_rst = value.drop_tcp_non_rst_pkt_after_rst
	w.drop_tcp_invalid_responder_first_pkt = value.drop_tcp_invalid_responder_first_pkt
	w.drop_tcp_unexpected_pkt = value.drop_tcp_unexpected_pkt
	w.drop_src_lif_mismatch = value.drop_src_lif_mismatch
	w.drop_parser_icrc_error = value.drop_parser_icrc_error
	w.drop_parse_len_error = value.drop_parse_len_error
	w.drop_hardware_error = value.drop_hardware_error
	return w
}

func (o *DropReasons) GetProtoMsg() *DropReasons_ {
	if o == nil {
		return &DropReasons_{}
	}

	return &DropReasons_{
		DropMalformedPkt:                o.drop_malformed_pkt,
		DropInputMapping:                o.drop_input_mapping,
		DropInputMappingDejavu:          o.drop_input_mapping_dejavu,
		DropFlowHit:                     o.drop_flow_hit,
		DropFlowMiss:                    o.drop_flow_miss,
		DropNacl:                        o.drop_nacl,
		DropIpsg:                        o.drop_ipsg,
		DropIpNormalization:             o.drop_ip_normalization,
		DropTcpNormalization:            o.drop_tcp_normalization,
		DropTcpRstWithInvalidAckNum:     o.drop_tcp_rst_with_invalid_ack_num,
		DropTcpNonSynFirstPkt:           o.drop_tcp_non_syn_first_pkt,
		DropIcmpNormalization:           o.drop_icmp_normalization,
		DropInputPropertiesMiss:         o.drop_input_properties_miss,
		DropTcpOutOfWindow:              o.drop_tcp_out_of_window,
		DropTcpSplitHandshake:           o.drop_tcp_split_handshake,
		DropTcpWinZeroDrop:              o.drop_tcp_win_zero_drop,
		DropTcpDataAfterFin:             o.drop_tcp_data_after_fin,
		DropTcpNonRstPktAfterRst:        o.drop_tcp_non_rst_pkt_after_rst,
		DropTcpInvalidResponderFirstPkt: o.drop_tcp_invalid_responder_first_pkt,
		DropTcpUnexpectedPkt:            o.drop_tcp_unexpected_pkt,
		DropSrcLifMismatch:              o.drop_src_lif_mismatch,
		DropParserIcrcError:             o.drop_parser_icrc_error,
		DropParseLenError:               o.drop_parse_len_error,
		DropHardwareError:               o.drop_hardware_error,
	}
}

func (o *DropReasons) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newDropReasonsFromMessage(msg *DropReasons_) *DropReasons {
	if msg == nil {
		return &DropReasons{}
	}

	return &DropReasons{
		drop_malformed_pkt:                   msg.DropMalformedPkt,
		drop_input_mapping:                   msg.DropInputMapping,
		drop_input_mapping_dejavu:            msg.DropInputMappingDejavu,
		drop_flow_hit:                        msg.DropFlowHit,
		drop_flow_miss:                       msg.DropFlowMiss,
		drop_nacl:                            msg.DropNacl,
		drop_ipsg:                            msg.DropIpsg,
		drop_ip_normalization:                msg.DropIpNormalization,
		drop_tcp_normalization:               msg.DropTcpNormalization,
		drop_tcp_rst_with_invalid_ack_num:    msg.DropTcpRstWithInvalidAckNum,
		drop_tcp_non_syn_first_pkt:           msg.DropTcpNonSynFirstPkt,
		drop_icmp_normalization:              msg.DropIcmpNormalization,
		drop_input_properties_miss:           msg.DropInputPropertiesMiss,
		drop_tcp_out_of_window:               msg.DropTcpOutOfWindow,
		drop_tcp_split_handshake:             msg.DropTcpSplitHandshake,
		drop_tcp_win_zero_drop:               msg.DropTcpWinZeroDrop,
		drop_tcp_data_after_fin:              msg.DropTcpDataAfterFin,
		drop_tcp_non_rst_pkt_after_rst:       msg.DropTcpNonRstPktAfterRst,
		drop_tcp_invalid_responder_first_pkt: msg.DropTcpInvalidResponderFirstPkt,
		drop_tcp_unexpected_pkt:              msg.DropTcpUnexpectedPkt,
		drop_src_lif_mismatch:                msg.DropSrcLifMismatch,
		drop_parser_icrc_error:               msg.DropParserIcrcError,
		drop_parse_len_error:                 msg.DropParseLenError,
		drop_hardware_error:                  msg.DropHardwareError,
	}
}

type P4ProgLabel struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	handle    string
	prog_name string
	label     string
}

func (o *P4ProgLabel) Gethandle() string {
	return o.handle
}

func (o *P4ProgLabel) Sethandle(val string) {
	o.handle = val
	o.bubbleSave()
}

func (o *P4ProgLabel) Getprog_name() string {
	return o.prog_name
}

func (o *P4ProgLabel) Setprog_name(val string) {
	o.prog_name = val
	o.bubbleSave()
}

func (o *P4ProgLabel) Getlabel() string {
	return o.label
}

func (o *P4ProgLabel) Setlabel(val string) {
	o.label = val
	o.bubbleSave()
}

func (o *P4ProgLabel) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *P4ProgLabel) save() {
}

func NewP4ProgLabel(sdkClient clientApi.Client) *P4ProgLabel {
	w := &P4ProgLabel{}
	w.sdkClient = sdkClient
	return w
}

func childNewP4ProgLabel(parent delphiWrapper, sdkClient clientApi.Client) *P4ProgLabel {
	w := NewP4ProgLabel(sdkClient)
	w.parent = parent
	return w
}

func childNewP4ProgLabelWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *P4ProgLabel) *P4ProgLabel {
	w := childNewP4ProgLabel(parent, sdkClient)
	w.handle = value.handle
	w.prog_name = value.prog_name
	w.label = value.label
	return w
}

func (o *P4ProgLabel) GetProtoMsg() *P4ProgLabel_ {
	if o == nil {
		return &P4ProgLabel_{}
	}

	return &P4ProgLabel_{
		Handle:   o.handle,
		ProgName: o.prog_name,
		Label:    o.label,
	}
}

func (o *P4ProgLabel) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newP4ProgLabelFromMessage(msg *P4ProgLabel_) *P4ProgLabel {
	if msg == nil {
		return &P4ProgLabel{}
	}

	return &P4ProgLabel{
		handle:    msg.Handle,
		prog_name: msg.ProgName,
		label:     msg.Label,
	}
}

type LifDeleteRequest struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	key_or_handle *LifKeyHandle
}

func (o *LifDeleteRequest) Getkey_or_handle() *LifKeyHandle {
	return o.key_or_handle
}

func (o *LifDeleteRequest) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifDeleteRequest) save() {
}

func NewLifDeleteRequest(sdkClient clientApi.Client) *LifDeleteRequest {
	w := &LifDeleteRequest{}
	w.sdkClient = sdkClient
	w.key_or_handle = childNewLifKeyHandle(w, sdkClient)
	return w
}

func childNewLifDeleteRequest(parent delphiWrapper, sdkClient clientApi.Client) *LifDeleteRequest {
	w := NewLifDeleteRequest(sdkClient)
	w.parent = parent
	return w
}

func childNewLifDeleteRequestWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifDeleteRequest) *LifDeleteRequest {
	w := childNewLifDeleteRequest(parent, sdkClient)
	w.key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	return w
}

func (o *LifDeleteRequest) GetProtoMsg() *LifDeleteRequest_ {
	if o == nil {
		return &LifDeleteRequest_{}
	}

	return &LifDeleteRequest_{
		KeyOrHandle: o.key_or_handle.GetProtoMsg(),
	}
}

func (o *LifDeleteRequest) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifDeleteRequestFromMessage(msg *LifDeleteRequest_) *LifDeleteRequest {
	if msg == nil {
		return &LifDeleteRequest{}
	}

	return &LifDeleteRequest{
		key_or_handle: newLifKeyHandleFromMessage(msg.KeyOrHandle),
	}
}

type InterfaceSpec struct {
	sdkClient         clientApi.Client
	parent            delphiWrapper
	meta              *delphi.ObjectMeta
	key_or_handle     *InterfaceKeyHandle
	if_type           IntfType
	admin_status      IntfStatus
	if_enic_info      *IfEnicInfo
	if_uplink_info    *IfUplinkInfo
	if_uplink_pc_info *IfUplinkPCInfo
	if_tunnel_info    *IfTunnelInfo
	if_cpu_info       *IfCPUInfo
	if_app_redir_info *IfAppRedirInfo
}

func (o *InterfaceSpec) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *InterfaceSpec) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *InterfaceSpec) Getkey_or_handle() *InterfaceKeyHandle {
	return o.key_or_handle
}

func (o *InterfaceSpec) Getif_type() IntfType {
	return o.if_type
}

func (o *InterfaceSpec) Setif_type(val IntfType) {
	o.if_type = val
	o.bubbleSave()
}

func (o *InterfaceSpec) Getadmin_status() IntfStatus {
	return o.admin_status
}

func (o *InterfaceSpec) Setadmin_status(val IntfStatus) {
	o.admin_status = val
	o.bubbleSave()
}

func (o *InterfaceSpec) Getif_enic_info() *IfEnicInfo {
	return o.if_enic_info
}

func (o *InterfaceSpec) Getif_uplink_info() *IfUplinkInfo {
	return o.if_uplink_info
}

func (o *InterfaceSpec) Getif_uplink_pc_info() *IfUplinkPCInfo {
	return o.if_uplink_pc_info
}

func (o *InterfaceSpec) Getif_tunnel_info() *IfTunnelInfo {
	return o.if_tunnel_info
}

func (o *InterfaceSpec) Getif_cpu_info() *IfCPUInfo {
	return o.if_cpu_info
}

func (o *InterfaceSpec) Getif_app_redir_info() *IfAppRedirInfo {
	return o.if_app_redir_info
}

func (o *InterfaceSpec) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceSpec) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *InterfaceSpec) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewInterfaceSpec(sdkClient clientApi.Client) *InterfaceSpec {
	w := &InterfaceSpec{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "InterfaceSpec",
	}
	w.key_or_handle = childNewInterfaceKeyHandle(w, sdkClient)
	w.if_enic_info = childNewIfEnicInfo(w, sdkClient)
	w.if_uplink_info = childNewIfUplinkInfo(w, sdkClient)
	w.if_uplink_pc_info = childNewIfUplinkPCInfo(w, sdkClient)
	w.if_tunnel_info = childNewIfTunnelInfo(w, sdkClient)
	w.if_cpu_info = childNewIfCPUInfo(w, sdkClient)
	w.if_app_redir_info = childNewIfAppRedirInfo(w, sdkClient)
	return w
}

func NewInterfaceSpecWithKey(sdkClient clientApi.Client, key *InterfaceKeyHandle) *InterfaceSpec {
	w := NewInterfaceSpec(sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, key)
	return w
}

func NewInterfaceSpecFromMessage(sdkClient clientApi.Client, msg *InterfaceSpec_) *InterfaceSpec {
	obj := newInterfaceSpecFromMessage(msg)
	obj.sdkClient = sdkClient
	obj.meta = &delphi.ObjectMeta{
		Kind: "InterfaceSpec",
	}

	obj.bubbleSave()
	return obj
}

func GetInterfaceSpec(sdkClient clientApi.Client, key *InterfaceKeyHandle) *InterfaceSpec {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("InterfaceSpec", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*InterfaceSpec)
	if !ok {
		panic("Couldn't cast to InterfaceSpec")
	}
	return o
}

func childNewInterfaceSpec(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceSpec {
	w := NewInterfaceSpec(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceSpecWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceSpec) *InterfaceSpec {
	w := childNewInterfaceSpec(parent, sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	w.if_type = value.if_type
	w.admin_status = value.admin_status
	w.if_enic_info = childNewIfEnicInfoWithValue(w, sdkClient, value.if_enic_info)
	w.if_uplink_info = childNewIfUplinkInfoWithValue(w, sdkClient, value.if_uplink_info)
	w.if_uplink_pc_info = childNewIfUplinkPCInfoWithValue(w, sdkClient, value.if_uplink_pc_info)
	w.if_tunnel_info = childNewIfTunnelInfoWithValue(w, sdkClient, value.if_tunnel_info)
	w.if_cpu_info = childNewIfCPUInfoWithValue(w, sdkClient, value.if_cpu_info)
	w.if_app_redir_info = childNewIfAppRedirInfoWithValue(w, sdkClient, value.if_app_redir_info)
	return w
}

func (o *InterfaceSpec) GetProtoMsg() *InterfaceSpec_ {
	if o == nil {
		return &InterfaceSpec_{}
	}

	return &InterfaceSpec_{
		Meta:           o.meta,
		KeyOrHandle:    o.key_or_handle.GetProtoMsg(),
		IfType:         o.if_type,
		AdminStatus:    o.admin_status,
		IfEnicInfo:     o.if_enic_info.GetProtoMsg(),
		IfUplinkInfo:   o.if_uplink_info.GetProtoMsg(),
		IfUplinkPcInfo: o.if_uplink_pc_info.GetProtoMsg(),
		IfTunnelInfo:   o.if_tunnel_info.GetProtoMsg(),
		IfCpuInfo:      o.if_cpu_info.GetProtoMsg(),
		IfAppRedirInfo: o.if_app_redir_info.GetProtoMsg(),
	}
}

func (o *InterfaceSpec) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *InterfaceSpec) GetKeyString() string {
	return obj.key_or_handle.GetProtoMsg().String()
}

func (obj *InterfaceSpec) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(InterfaceSpecReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnInterfaceSpecCreate(obj)
			} else {
				rctr.OnInterfaceSpecUpdate(obj)
			}
		} else {
			rctr.OnInterfaceSpecDelete(obj)
		}
	}
}

type InterfaceSpecReactor interface {
	OnInterfaceSpecCreate(obj *InterfaceSpec)
	OnInterfaceSpecUpdate(obj *InterfaceSpec)
	OnInterfaceSpecDelete(obj *InterfaceSpec)
}

func (obj *InterfaceSpec) GetPath() string {
	return "InterfaceSpec" + "|" + obj.GetKeyString()
}

func newInterfaceSpecFromMessage(msg *InterfaceSpec_) *InterfaceSpec {
	if msg == nil {
		return &InterfaceSpec{}
	}

	return &InterfaceSpec{
		meta:              msg.Meta,
		key_or_handle:     newInterfaceKeyHandleFromMessage(msg.KeyOrHandle),
		if_type:           msg.IfType,
		admin_status:      msg.AdminStatus,
		if_enic_info:      newIfEnicInfoFromMessage(msg.IfEnicInfo),
		if_uplink_info:    newIfUplinkInfoFromMessage(msg.IfUplinkInfo),
		if_uplink_pc_info: newIfUplinkPCInfoFromMessage(msg.IfUplinkPcInfo),
		if_tunnel_info:    newIfTunnelInfoFromMessage(msg.IfTunnelInfo),
		if_cpu_info:       newIfCPUInfoFromMessage(msg.IfCpuInfo),
		if_app_redir_info: newIfAppRedirInfoFromMessage(msg.IfAppRedirInfo),
	}
}

func interfaceSpecFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg InterfaceSpec_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newInterfaceSpecFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func InterfaceSpecMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("InterfaceSpec", mode)
}

func InterfaceSpecMountKey(client clientApi.Client, key *InterfaceKeyHandle, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("InterfaceSpec", keyString, mode)
}

func InterfaceSpecWatch(client clientApi.Client, reactor InterfaceSpecReactor) {
	client.WatchKind("InterfaceSpec", reactor)
}

type InterfaceSpecIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *InterfaceSpecIterator) Next() *InterfaceSpec {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*InterfaceSpec)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func InterfaceSpecList(client clientApi.Client) *InterfaceSpecIterator {
	return &InterfaceSpecIterator{
		objects: client.List("InterfaceSpec"),
		cur:     0,
	}
}

type LifRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *LifSpec
}

func (o *LifRequestMsg) Getrequest() *LifSpec {
	return o.request
}

func (o *LifRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *LifRequestMsg) save() {
}

func NewLifRequestMsg(sdkClient clientApi.Client) *LifRequestMsg {
	w := &LifRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewLifSpec(w, sdkClient)
	return w
}

func childNewLifRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *LifRequestMsg {
	w := NewLifRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewLifRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *LifRequestMsg) *LifRequestMsg {
	w := childNewLifRequestMsg(parent, sdkClient)
	w.request = childNewLifSpecWithValue(w, sdkClient, value.request)
	return w
}

func (o *LifRequestMsg) GetProtoMsg() *LifRequestMsg_ {
	if o == nil {
		return &LifRequestMsg_{}
	}

	return &LifRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *LifRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newLifRequestMsgFromMessage(msg *LifRequestMsg_) *LifRequestMsg {
	if msg == nil {
		return &LifRequestMsg{}
	}

	return &LifRequestMsg{
		request: newLifSpecFromMessage(msg.Request),
	}
}

type QStateGetReq struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	lif_handle    uint64
	type_num      uint32
	qid           uint32
	ret_data_size uint32
}

func (o *QStateGetReq) Getlif_handle() uint64 {
	return o.lif_handle
}

func (o *QStateGetReq) Setlif_handle(val uint64) {
	o.lif_handle = val
	o.bubbleSave()
}

func (o *QStateGetReq) Gettype_num() uint32 {
	return o.type_num
}

func (o *QStateGetReq) Settype_num(val uint32) {
	o.type_num = val
	o.bubbleSave()
}

func (o *QStateGetReq) Getqid() uint32 {
	return o.qid
}

func (o *QStateGetReq) Setqid(val uint32) {
	o.qid = val
	o.bubbleSave()
}

func (o *QStateGetReq) Getret_data_size() uint32 {
	return o.ret_data_size
}

func (o *QStateGetReq) Setret_data_size(val uint32) {
	o.ret_data_size = val
	o.bubbleSave()
}

func (o *QStateGetReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *QStateGetReq) save() {
}

func NewQStateGetReq(sdkClient clientApi.Client) *QStateGetReq {
	w := &QStateGetReq{}
	w.sdkClient = sdkClient
	return w
}

func childNewQStateGetReq(parent delphiWrapper, sdkClient clientApi.Client) *QStateGetReq {
	w := NewQStateGetReq(sdkClient)
	w.parent = parent
	return w
}

func childNewQStateGetReqWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *QStateGetReq) *QStateGetReq {
	w := childNewQStateGetReq(parent, sdkClient)
	w.lif_handle = value.lif_handle
	w.type_num = value.type_num
	w.qid = value.qid
	w.ret_data_size = value.ret_data_size
	return w
}

func (o *QStateGetReq) GetProtoMsg() *QStateGetReq_ {
	if o == nil {
		return &QStateGetReq_{}
	}

	return &QStateGetReq_{
		LifHandle:   o.lif_handle,
		TypeNum:     o.type_num,
		Qid:         o.qid,
		RetDataSize: o.ret_data_size,
	}
}

func (o *QStateGetReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newQStateGetReqFromMessage(msg *QStateGetReq_) *QStateGetReq {
	if msg == nil {
		return &QStateGetReq{}
	}

	return &QStateGetReq{
		lif_handle:    msg.LifHandle,
		type_num:      msg.TypeNum,
		qid:           msg.Qid,
		ret_data_size: msg.RetDataSize,
	}
}

type IfTunnelVxlanInfo struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	local_tep  *IPAddress
	remote_tep *IPAddress
}

func (o *IfTunnelVxlanInfo) Getlocal_tep() *IPAddress {
	return o.local_tep
}

func (o *IfTunnelVxlanInfo) Getremote_tep() *IPAddress {
	return o.remote_tep
}

func (o *IfTunnelVxlanInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfTunnelVxlanInfo) save() {
}

func NewIfTunnelVxlanInfo(sdkClient clientApi.Client) *IfTunnelVxlanInfo {
	w := &IfTunnelVxlanInfo{}
	w.sdkClient = sdkClient
	w.local_tep = childNewIPAddress(w, sdkClient)
	w.remote_tep = childNewIPAddress(w, sdkClient)
	return w
}

func childNewIfTunnelVxlanInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfTunnelVxlanInfo {
	w := NewIfTunnelVxlanInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfTunnelVxlanInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfTunnelVxlanInfo) *IfTunnelVxlanInfo {
	w := childNewIfTunnelVxlanInfo(parent, sdkClient)
	w.local_tep = childNewIPAddressWithValue(w, sdkClient, value.local_tep)
	w.remote_tep = childNewIPAddressWithValue(w, sdkClient, value.remote_tep)
	return w
}

func (o *IfTunnelVxlanInfo) GetProtoMsg() *IfTunnelVxlanInfo_ {
	if o == nil {
		return &IfTunnelVxlanInfo_{}
	}

	return &IfTunnelVxlanInfo_{
		LocalTep:  o.local_tep.GetProtoMsg(),
		RemoteTep: o.remote_tep.GetProtoMsg(),
	}
}

func (o *IfTunnelVxlanInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfTunnelVxlanInfoFromMessage(msg *IfTunnelVxlanInfo_) *IfTunnelVxlanInfo {
	if msg == nil {
		return &IfTunnelVxlanInfo{}
	}

	return &IfTunnelVxlanInfo{
		local_tep:  newIPAddressFromMessage(msg.LocalTep),
		remote_tep: newIPAddressFromMessage(msg.RemoteTep),
	}
}

type EnicResponseInfo struct {
	sdkClient         clientApi.Client
	parent            delphiWrapper
	enic_lport_id     uint32
	uplink_if_handle  uint32
	smart_enic_info   *SmartEnicInfo
	classic_enic_info *ClassicEnicInfo
}

func (o *EnicResponseInfo) Getenic_lport_id() uint32 {
	return o.enic_lport_id
}

func (o *EnicResponseInfo) Setenic_lport_id(val uint32) {
	o.enic_lport_id = val
	o.bubbleSave()
}

func (o *EnicResponseInfo) Getuplink_if_handle() uint32 {
	return o.uplink_if_handle
}

func (o *EnicResponseInfo) Setuplink_if_handle(val uint32) {
	o.uplink_if_handle = val
	o.bubbleSave()
}

func (o *EnicResponseInfo) Getsmart_enic_info() *SmartEnicInfo {
	return o.smart_enic_info
}

func (o *EnicResponseInfo) Getclassic_enic_info() *ClassicEnicInfo {
	return o.classic_enic_info
}

func (o *EnicResponseInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *EnicResponseInfo) save() {
}

func NewEnicResponseInfo(sdkClient clientApi.Client) *EnicResponseInfo {
	w := &EnicResponseInfo{}
	w.sdkClient = sdkClient
	w.smart_enic_info = childNewSmartEnicInfo(w, sdkClient)
	w.classic_enic_info = childNewClassicEnicInfo(w, sdkClient)
	return w
}

func childNewEnicResponseInfo(parent delphiWrapper, sdkClient clientApi.Client) *EnicResponseInfo {
	w := NewEnicResponseInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewEnicResponseInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *EnicResponseInfo) *EnicResponseInfo {
	w := childNewEnicResponseInfo(parent, sdkClient)
	w.enic_lport_id = value.enic_lport_id
	w.uplink_if_handle = value.uplink_if_handle
	w.smart_enic_info = childNewSmartEnicInfoWithValue(w, sdkClient, value.smart_enic_info)
	w.classic_enic_info = childNewClassicEnicInfoWithValue(w, sdkClient, value.classic_enic_info)
	return w
}

func (o *EnicResponseInfo) GetProtoMsg() *EnicResponseInfo_ {
	if o == nil {
		return &EnicResponseInfo_{}
	}

	return &EnicResponseInfo_{
		EnicLportId:     o.enic_lport_id,
		UplinkIfHandle:  o.uplink_if_handle,
		SmartEnicInfo:   o.smart_enic_info.GetProtoMsg(),
		ClassicEnicInfo: o.classic_enic_info.GetProtoMsg(),
	}
}

func (o *EnicResponseInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEnicResponseInfoFromMessage(msg *EnicResponseInfo_) *EnicResponseInfo {
	if msg == nil {
		return &EnicResponseInfo{}
	}

	return &EnicResponseInfo{
		enic_lport_id:     msg.EnicLportId,
		uplink_if_handle:  msg.UplinkIfHandle,
		smart_enic_info:   newSmartEnicInfoFromMessage(msg.SmartEnicInfo),
		classic_enic_info: newClassicEnicInfoFromMessage(msg.ClassicEnicInfo),
	}
}

type InterfaceGetRequest struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	key_or_handle *InterfaceKeyHandle
}

func (o *InterfaceGetRequest) Getkey_or_handle() *InterfaceKeyHandle {
	return o.key_or_handle
}

func (o *InterfaceGetRequest) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceGetRequest) save() {
}

func NewInterfaceGetRequest(sdkClient clientApi.Client) *InterfaceGetRequest {
	w := &InterfaceGetRequest{}
	w.sdkClient = sdkClient
	w.key_or_handle = childNewInterfaceKeyHandle(w, sdkClient)
	return w
}

func childNewInterfaceGetRequest(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceGetRequest {
	w := NewInterfaceGetRequest(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceGetRequestWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceGetRequest) *InterfaceGetRequest {
	w := childNewInterfaceGetRequest(parent, sdkClient)
	w.key_or_handle = childNewInterfaceKeyHandleWithValue(w, sdkClient, value.key_or_handle)
	return w
}

func (o *InterfaceGetRequest) GetProtoMsg() *InterfaceGetRequest_ {
	if o == nil {
		return &InterfaceGetRequest_{}
	}

	return &InterfaceGetRequest_{
		KeyOrHandle: o.key_or_handle.GetProtoMsg(),
	}
}

func (o *InterfaceGetRequest) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceGetRequestFromMessage(msg *InterfaceGetRequest_) *InterfaceGetRequest {
	if msg == nil {
		return &InterfaceGetRequest{}
	}

	return &InterfaceGetRequest{
		key_or_handle: newInterfaceKeyHandleFromMessage(msg.KeyOrHandle),
	}
}

type Empty struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
}

func (o *Empty) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *Empty) save() {
}

func NewEmpty(sdkClient clientApi.Client) *Empty {
	w := &Empty{}
	w.sdkClient = sdkClient
	return w
}

func childNewEmpty(parent delphiWrapper, sdkClient clientApi.Client) *Empty {
	w := NewEmpty(sdkClient)
	w.parent = parent
	return w
}

func childNewEmptyWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *Empty) *Empty {
	w := childNewEmpty(parent, sdkClient)
	return w
}

func (o *Empty) GetProtoMsg() *Empty_ {
	if o == nil {
		return &Empty_{}
	}

	return &Empty_{}
}

func (o *Empty) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newEmptyFromMessage(msg *Empty_) *Empty {
	if msg == nil {
		return &Empty{}
	}

	return &Empty{}
}

type IfAppRedirInfo struct {
	sdkClient         clientApi.Client
	parent            delphiWrapper
	lif_key_or_handle *LifKeyHandle
}

func (o *IfAppRedirInfo) Getlif_key_or_handle() *LifKeyHandle {
	return o.lif_key_or_handle
}

func (o *IfAppRedirInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IfAppRedirInfo) save() {
}

func NewIfAppRedirInfo(sdkClient clientApi.Client) *IfAppRedirInfo {
	w := &IfAppRedirInfo{}
	w.sdkClient = sdkClient
	w.lif_key_or_handle = childNewLifKeyHandle(w, sdkClient)
	return w
}

func childNewIfAppRedirInfo(parent delphiWrapper, sdkClient clientApi.Client) *IfAppRedirInfo {
	w := NewIfAppRedirInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewIfAppRedirInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IfAppRedirInfo) *IfAppRedirInfo {
	w := childNewIfAppRedirInfo(parent, sdkClient)
	w.lif_key_or_handle = childNewLifKeyHandleWithValue(w, sdkClient, value.lif_key_or_handle)
	return w
}

func (o *IfAppRedirInfo) GetProtoMsg() *IfAppRedirInfo_ {
	if o == nil {
		return &IfAppRedirInfo_{}
	}

	return &IfAppRedirInfo_{
		LifKeyOrHandle: o.lif_key_or_handle.GetProtoMsg(),
	}
}

func (o *IfAppRedirInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIfAppRedirInfoFromMessage(msg *IfAppRedirInfo_) *IfAppRedirInfo {
	if msg == nil {
		return &IfAppRedirInfo{}
	}

	return &IfAppRedirInfo{
		lif_key_or_handle: newLifKeyHandleFromMessage(msg.LifKeyOrHandle),
	}
}

type SmartEnicInfo struct {
	sdkClient                  clientApi.Client
	parent                     delphiWrapper
	inp_prop_mac_vlan_idx_host uint32
	inp_prop_mac_vlan_idx_net  uint32
}

func (o *SmartEnicInfo) Getinp_prop_mac_vlan_idx_host() uint32 {
	return o.inp_prop_mac_vlan_idx_host
}

func (o *SmartEnicInfo) Setinp_prop_mac_vlan_idx_host(val uint32) {
	o.inp_prop_mac_vlan_idx_host = val
	o.bubbleSave()
}

func (o *SmartEnicInfo) Getinp_prop_mac_vlan_idx_net() uint32 {
	return o.inp_prop_mac_vlan_idx_net
}

func (o *SmartEnicInfo) Setinp_prop_mac_vlan_idx_net(val uint32) {
	o.inp_prop_mac_vlan_idx_net = val
	o.bubbleSave()
}

func (o *SmartEnicInfo) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *SmartEnicInfo) save() {
}

func NewSmartEnicInfo(sdkClient clientApi.Client) *SmartEnicInfo {
	w := &SmartEnicInfo{}
	w.sdkClient = sdkClient
	return w
}

func childNewSmartEnicInfo(parent delphiWrapper, sdkClient clientApi.Client) *SmartEnicInfo {
	w := NewSmartEnicInfo(sdkClient)
	w.parent = parent
	return w
}

func childNewSmartEnicInfoWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *SmartEnicInfo) *SmartEnicInfo {
	w := childNewSmartEnicInfo(parent, sdkClient)
	w.inp_prop_mac_vlan_idx_host = value.inp_prop_mac_vlan_idx_host
	w.inp_prop_mac_vlan_idx_net = value.inp_prop_mac_vlan_idx_net
	return w
}

func (o *SmartEnicInfo) GetProtoMsg() *SmartEnicInfo_ {
	if o == nil {
		return &SmartEnicInfo_{}
	}

	return &SmartEnicInfo_{
		InpPropMacVlanIdxHost: o.inp_prop_mac_vlan_idx_host,
		InpPropMacVlanIdxNet:  o.inp_prop_mac_vlan_idx_net,
	}
}

func (o *SmartEnicInfo) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newSmartEnicInfoFromMessage(msg *SmartEnicInfo_) *SmartEnicInfo {
	if msg == nil {
		return &SmartEnicInfo{}
	}

	return &SmartEnicInfo{
		inp_prop_mac_vlan_idx_host: msg.InpPropMacVlanIdxHost,
		inp_prop_mac_vlan_idx_net:  msg.InpPropMacVlanIdxNet,
	}
}

type InterfaceDeleteRequestMsg struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	request   *InterfaceDeleteRequest
}

func (o *InterfaceDeleteRequestMsg) Getrequest() *InterfaceDeleteRequest {
	return o.request
}

func (o *InterfaceDeleteRequestMsg) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceDeleteRequestMsg) save() {
}

func NewInterfaceDeleteRequestMsg(sdkClient clientApi.Client) *InterfaceDeleteRequestMsg {
	w := &InterfaceDeleteRequestMsg{}
	w.sdkClient = sdkClient
	w.request = childNewInterfaceDeleteRequest(w, sdkClient)
	return w
}

func childNewInterfaceDeleteRequestMsg(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceDeleteRequestMsg {
	w := NewInterfaceDeleteRequestMsg(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceDeleteRequestMsgWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceDeleteRequestMsg) *InterfaceDeleteRequestMsg {
	w := childNewInterfaceDeleteRequestMsg(parent, sdkClient)
	w.request = childNewInterfaceDeleteRequestWithValue(w, sdkClient, value.request)
	return w
}

func (o *InterfaceDeleteRequestMsg) GetProtoMsg() *InterfaceDeleteRequestMsg_ {
	if o == nil {
		return &InterfaceDeleteRequestMsg_{}
	}

	return &InterfaceDeleteRequestMsg_{
		Request: o.request.GetProtoMsg(),
	}
}

func (o *InterfaceDeleteRequestMsg) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newInterfaceDeleteRequestMsgFromMessage(msg *InterfaceDeleteRequestMsg_) *InterfaceDeleteRequestMsg {
	if msg == nil {
		return &InterfaceDeleteRequestMsg{}
	}

	return &InterfaceDeleteRequestMsg{
		request: newInterfaceDeleteRequestFromMessage(msg.Request),
	}
}

func init() {
	proto.RegisterType((*ObjectMeta_)(nil), "intf.ObjectMeta_")
	proto.RegisterType((*EncapInfo_)(nil), "intf.EncapInfo_")
	proto.RegisterType((*IPAddress_)(nil), "intf.IPAddress_")
	proto.RegisterType((*IPRange_)(nil), "intf.IPRange_")
	proto.RegisterType((*IPPrefix_)(nil), "intf.IPPrefix_")
	proto.RegisterType((*IPSubnet_)(nil), "intf.IPSubnet_")
	proto.RegisterType((*AddressRange_)(nil), "intf.AddressRange_")
	proto.RegisterType((*Address_)(nil), "intf.Address_")
	proto.RegisterType((*IPAddressObj_)(nil), "intf.IPAddressObj_")
	proto.RegisterType((*L4PortRange_)(nil), "intf.L4PortRange_")
	proto.RegisterType((*Empty_)(nil), "intf.Empty_")
	proto.RegisterType((*DropReasons_)(nil), "intf.DropReasons_")
	proto.RegisterType((*EgressDropReasons_)(nil), "intf.EgressDropReasons_")
	proto.RegisterType((*VrfKeyHandle_)(nil), "intf.VrfKeyHandle_")
	proto.RegisterType((*L2SegmentKeyHandle_)(nil), "intf.L2SegmentKeyHandle_")
	proto.RegisterType((*PortKeyHandle_)(nil), "intf.PortKeyHandle_")
	proto.RegisterType((*LifKeyHandle_)(nil), "intf.LifKeyHandle_")
	proto.RegisterType((*InterfaceKeyHandle_)(nil), "intf.InterfaceKeyHandle_")
	proto.RegisterType((*FilterKey_)(nil), "intf.FilterKey_")
	proto.RegisterType((*LifQStateMapEntry_)(nil), "intf.LifQStateMapEntry_")
	proto.RegisterType((*PktFilter_)(nil), "intf.PktFilter_")
	proto.RegisterType((*LifSpec_)(nil), "intf.LifSpec_")
	proto.RegisterType((*LifRequestMsg_)(nil), "intf.LifRequestMsg_")
	proto.RegisterType((*LifStatus_)(nil), "intf.LifStatus_")
	proto.RegisterType((*LifQState_)(nil), "intf.LifQState_")
	proto.RegisterType((*LifRdmaData_)(nil), "intf.LifRdmaData_")
	proto.RegisterType((*LifResponse_)(nil), "intf.LifResponse_")
	proto.RegisterType((*LifResponseMsg_)(nil), "intf.LifResponseMsg_")
	proto.RegisterType((*QStateGetReq_)(nil), "intf.QStateGetReq_")
	proto.RegisterType((*QStateGetResp_)(nil), "intf.QStateGetResp_")
	proto.RegisterType((*GetQStateResponseMsg_)(nil), "intf.GetQStateResponseMsg_")
	proto.RegisterType((*P4ProgLabel_)(nil), "intf.P4ProgLabel_")
	proto.RegisterType((*QStateSetReq_)(nil), "intf.QStateSetReq_")
	proto.RegisterType((*SetQStateRequestMsg_)(nil), "intf.SetQStateRequestMsg_")
	proto.RegisterType((*QStateSetResp_)(nil), "intf.QStateSetResp_")
	proto.RegisterType((*SetQStateResponseMsg_)(nil), "intf.SetQStateResponseMsg_")
	proto.RegisterType((*LifDeleteRequest_)(nil), "intf.LifDeleteRequest_")
	proto.RegisterType((*LifDeleteRequestMsg_)(nil), "intf.LifDeleteRequestMsg_")
	proto.RegisterType((*LifDeleteResponse_)(nil), "intf.LifDeleteResponse_")
	proto.RegisterType((*LifDeleteResponseMsg_)(nil), "intf.LifDeleteResponseMsg_")
	proto.RegisterType((*LifTxStats_)(nil), "intf.LifTxStats_")
	proto.RegisterType((*LifRxStats_)(nil), "intf.LifRxStats_")
	proto.RegisterType((*LifRssSpec_)(nil), "intf.LifRssSpec_")
	proto.RegisterType((*EnicInfo_)(nil), "intf.EnicInfo_")
	proto.RegisterType((*EnicClassicInfo_)(nil), "intf.EnicClassicInfo_")
	proto.RegisterType((*IfEnicInfo_)(nil), "intf.IfEnicInfo_")
	proto.RegisterType((*IfUplinkInfo_)(nil), "intf.IfUplinkInfo_")
	proto.RegisterType((*IfUplinkPCInfo_)(nil), "intf.IfUplinkPCInfo_")
	proto.RegisterType((*IfTunnelVxlanInfo_)(nil), "intf.IfTunnelVxlanInfo_")
	proto.RegisterType((*IfTunnelGREInfo_)(nil), "intf.IfTunnelGREInfo_")
	proto.RegisterType((*IfTunnelInfo_)(nil), "intf.IfTunnelInfo_")
	proto.RegisterType((*IfCPUInfo_)(nil), "intf.IfCPUInfo_")
	proto.RegisterType((*IfAppRedirInfo_)(nil), "intf.IfAppRedirInfo_")
	proto.RegisterType((*InterfaceSpec_)(nil), "intf.InterfaceSpec_")
	proto.RegisterType((*InterfaceRequestMsg_)(nil), "intf.InterfaceRequestMsg_")
	proto.RegisterType((*UplinkResponseInfo_)(nil), "intf.UplinkResponseInfo_")
	proto.RegisterType((*EnicL2SegInfo_)(nil), "intf.EnicL2SegInfo_")
	proto.RegisterType((*SmartEnicInfo_)(nil), "intf.SmartEnicInfo_")
	proto.RegisterType((*ClassicEnicInfo_)(nil), "intf.ClassicEnicInfo_")
	proto.RegisterType((*EnicResponseInfo_)(nil), "intf.EnicResponseInfo_")
	proto.RegisterType((*CpuIfResponseInfo_)(nil), "intf.CpuIfResponseInfo_")
	proto.RegisterType((*TunnelIfResponseInfo_)(nil), "intf.TunnelIfResponseInfo_")
	proto.RegisterType((*AppRedirIfInfo_)(nil), "intf.AppRedirIfInfo_")
	proto.RegisterType((*InterfaceStatus_)(nil), "intf.InterfaceStatus_")
	proto.RegisterType((*InterfaceResponse_)(nil), "intf.InterfaceResponse_")
	proto.RegisterType((*InterfaceResponseMsg_)(nil), "intf.InterfaceResponseMsg_")
	proto.RegisterType((*InterfaceDeleteRequest_)(nil), "intf.InterfaceDeleteRequest_")
	proto.RegisterType((*InterfaceDeleteRequestMsg_)(nil), "intf.InterfaceDeleteRequestMsg_")
	proto.RegisterType((*InterfaceDeleteResponse_)(nil), "intf.InterfaceDeleteResponse_")
	proto.RegisterType((*InterfaceDeleteResponseMsg_)(nil), "intf.InterfaceDeleteResponseMsg_")
	proto.RegisterType((*InterfaceStats_)(nil), "intf.InterfaceStats_")
	proto.RegisterType((*InterfaceGetRequest_)(nil), "intf.InterfaceGetRequest_")
	proto.RegisterType((*InterfaceGetRequestMsg_)(nil), "intf.InterfaceGetRequestMsg_")
	proto.RegisterType((*InterfaceGetResponse_)(nil), "intf.InterfaceGetResponse_")
	proto.RegisterType((*InterfaceGetResponseMsg_)(nil), "intf.InterfaceGetResponseMsg_")
	proto.RegisterType((*InterfaceL2SegmentSpec_)(nil), "intf.InterfaceL2SegmentSpec_")
	proto.RegisterType((*InterfaceL2SegmentRequestMsg_)(nil), "intf.InterfaceL2SegmentRequestMsg_")
	proto.RegisterType((*InterfaceL2SegmentResponse_)(nil), "intf.InterfaceL2SegmentResponse_")
	proto.RegisterType((*InterfaceL2SegmentResponseMsg_)(nil), "intf.InterfaceL2SegmentResponseMsg_")
	clientApi.RegisterFactory("LifSpec", lifSpecFactory)
	clientApi.RegisterFactory("LifStatus", lifStatusFactory)
	clientApi.RegisterFactory("InterfaceStatus", interfaceStatusFactory)
	clientApi.RegisterFactory("InterfaceSpec", interfaceSpecFactory)
	proto.RegisterEnum("intf.IPProtocol", IPProtocol_name, IPProtocol_value)
	proto.RegisterEnum("intf.ICMPMsgType", ICMPMsgType_name, ICMPMsgType_value)
	proto.RegisterEnum("intf.ApiStatus", ApiStatus_name, ApiStatus_value)
	proto.RegisterEnum("intf.VrfType", VrfType_name, VrfType_value)
	proto.RegisterEnum("intf.L2SegmentType", L2SegmentType_name, L2SegmentType_value)
	proto.RegisterEnum("intf.EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("intf.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("intf.IPAddressType", IPAddressType_name, IPAddressType_value)
	proto.RegisterEnum("intf.WRingType", WRingType_name, WRingType_value)
	proto.RegisterEnum("intf.ProxyType", ProxyType_name, ProxyType_value)
	proto.RegisterEnum("intf.CryptoAsymKeyType", CryptoAsymKeyType_name, CryptoAsymKeyType_value)
	proto.RegisterEnum("intf.CryptoKeyType", CryptoKeyType_name, CryptoKeyType_value)
	proto.RegisterEnum("intf.BarcoRings", BarcoRings_name, BarcoRings_value)
	proto.RegisterEnum("intf.AppRedirType", AppRedirType_name, AppRedirType_value)
	proto.RegisterEnum("intf.CpucbId", CpucbId_name, CpucbId_value)
	proto.RegisterEnum("intf.FTESpanMatchSelector", FTESpanMatchSelector_name, FTESpanMatchSelector_value)
	proto.RegisterEnum("intf.FilterType", FilterType_name, FilterType_value)
	proto.RegisterEnum("intf.IntfStatus", IntfStatus_name, IntfStatus_value)
	proto.RegisterEnum("intf.LifQueuePurpose", LifQueuePurpose_name, LifQueuePurpose_value)
	proto.RegisterEnum("intf.IntfType", IntfType_name, IntfType_value)
	proto.RegisterEnum("intf.IntfEnicType", IntfEnicType_name, IntfEnicType_value)
	proto.RegisterEnum("intf.IntfTunnelEncapType", IntfTunnelEncapType_name, IntfTunnelEncapType_value)
}

func init() { proto.RegisterFile("interface.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 7045 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7c, 0xdd, 0x6f, 0x1b, 0x49,
	0xb6, 0xdf, 0x50, 0xa2, 0x24, 0xf2, 0x90, 0x94, 0x5a, 0x2d, 0xc9, 0x96, 0xe5, 0xb1, 0xe5, 0xe1,
	0x7c, 0x79, 0x35, 0x3b, 0xb2, 0x25, 0x4b, 0x9a, 0x8f, 0xbd, 0x73, 0xb3, 0xfc, 0x68, 0x49, 0x5c,
	0xf3, 0xa3, 0x55, 0x4d, 0xc9, 0xf2, 0xee, 0x5d, 0x54, 0xda, 0x64, 0x53, 0xea, 0x15, 0xd9, 0xdd,
	0xee, 0x6e, 0xca, 0xd2, 0x04, 0x4e, 0xf6, 0x26, 0x79, 0xb9, 0xb8, 0xc8, 0x07, 0x70, 0x13, 0x24,
	0x08, 0x90, 0x04, 0x01, 0x82, 0x3c, 0x04, 0x48, 0x80, 0x04, 0xc1, 0x0d, 0xf2, 0x9a, 0xa7, 0x20,
	0x8f, 0xf7, 0x0f, 0x30, 0x02, 0x04, 0x01, 0x92, 0xa7, 0x60, 0x9d, 0xe7, 0x00, 0x41, 0x7d, 0x74,
	0x77, 0x75, 0x93, 0xf4, 0x8c, 0x27, 0x9e, 0xbb, 0x6f, 0xdd, 0xe7, 0xfc, 0xea, 0xd4, 0xa9, 0x73,
	0x4e, 0x9d, 0x3a, 0x55, 0xd5, 0x24, 0x2c, 0x98, 0x96, 0x6f, 0xb8, 0x3d, 0xbd, 0x63, 0x6c, 0x3a,
	0xae, 0xed, 0xdb, 0x72, 0xda, 0xb4, 0xfc, 0xde, 0x1a, 0x9c, 0xd9, 0x67, 0x36, 0xa3, 0xac, 0xe5,
	0xbb, 0x46, 0xdf, 0x39, 0x37, 0xd9, 0x5b, 0xf1, 0x23, 0xc8, 0xb5, 0x9e, 0xfd, 0xc6, 0xe8, 0xf8,
	0x0d, 0xc3, 0xd7, 0xb1, 0xbc, 0x02, 0xb3, 0x97, 0x6e, 0x0f, 0x9b, 0xdd, 0xd5, 0xd4, 0xbd, 0xd4,
	0xfd, 0x59, 0x34, 0x73, 0xe9, 0xf6, 0x6a, 0xdd, 0xe2, 0xaf, 0x01, 0x14, 0xab, 0xa3, 0x3b, 0x35,
	0xab, 0x67, 0x63, 0x79, 0x13, 0xc0, 0x20, 0x6f, 0xd8, 0xbf, 0x76, 0x0c, 0x0a, 0x9c, 0xdf, 0x5e,
	0xd8, 0x24, 0x1d, 0x6d, 0x52, 0x7a, 0xfb, 0xda, 0x31, 0x50, 0x36, 0x7c, 0x94, 0xd7, 0x21, 0xc7,
	0xf0, 0x97, 0x7a, 0x7f, 0x68, 0xac, 0x4e, 0xdd, 0x4b, 0xdd, 0x2f, 0x20, 0x26, 0xe2, 0x84, 0x50,
	0x8a, 0xbf, 0x4d, 0x01, 0xd4, 0xd4, 0x52, 0xb7, 0xeb, 0x1a, 0x9e, 0x87, 0xe5, 0x9f, 0xc3, 0x8c,
	0xe9, 0x60, 0xbd, 0xc7, 0x45, 0xaf, 0x30, 0xd1, 0x21, 0x60, 0x5f, 0x1f, 0x98, 0xfd, 0xeb, 0xf2,
	0xf2, 0xeb, 0x57, 0xeb, 0xd2, 0xa5, 0x61, 0x99, 0x1d, 0xe3, 0xeb, 0x81, 0x6e, 0x75, 0x75, 0xdf,
	0x76, 0xaf, 0x51, 0xda, 0x74, 0x4a, 0x3d, 0xf9, 0x26, 0xcc, 0x5d, 0xee, 0x60, 0xbd, 0xdb, 0x75,
	0x69, 0x6f, 0x73, 0x68, 0xf6, 0x72, 0x87, 0xb4, 0xa6, 0x8c, 0x3d, 0xc6, 0x98, 0xbe, 0x97, 0xba,
	0x9f, 0x47, 0xb3, 0x97, 0x7b, 0x84, 0x51, 0xb4, 0x20, 0x53, 0x53, 0x91, 0x6e, 0x9d, 0x19, 0x58,
	0x7e, 0x00, 0xd0, 0xb7, 0x5f, 0x60, 0xd3, 0xa1, 0x38, 0xa2, 0x44, 0x6e, 0x5b, 0x4a, 0x28, 0x81,
	0x51, 0xb6, 0x6f, 0xbf, 0xa8, 0x51, 0x88, 0xbc, 0x05, 0xb9, 0x73, 0xf3, 0xec, 0x3c, 0x68, 0x31,
	0x35, 0xa1, 0x05, 0x10, 0x10, 0x6b, 0x52, 0xb4, 0x20, 0x5b, 0x53, 0x55, 0xd7, 0xe8, 0x99, 0x57,
	0x58, 0xde, 0x80, 0x39, 0x9d, 0x81, 0x26, 0xf6, 0x16, 0x00, 0xe4, 0x5d, 0x00, 0x87, 0x35, 0xeb,
	0x1b, 0x16, 0xb3, 0x65, 0xf9, 0xc6, 0xeb, 0x57, 0xeb, 0x32, 0x37, 0x85, 0x4b, 0xc6, 0xf0, 0xf5,
	0xc3, 0xcf, 0xb7, 0xb6, 0xbf, 0x44, 0x59, 0x86, 0xac, 0x1b, 0x56, 0xd1, 0x26, 0xfd, 0x69, 0xc3,
	0x67, 0x96, 0xe1, 0x63, 0xf9, 0x21, 0xe4, 0x4c, 0xe7, 0x72, 0x07, 0x7b, 0xf4, 0x9d, 0xf7, 0xb9,
	0x10, 0xf4, 0xc9, 0xb5, 0x42, 0x40, 0x30, 0xac, 0x09, 0x6f, 0xb1, 0x17, 0xb4, 0x98, 0x9a, 0xdc,
	0x62, 0x8f, 0xb5, 0x28, 0x0e, 0xa0, 0xc0, 0x95, 0xe7, 0x56, 0xfd, 0x1c, 0xa8, 0x40, 0x4c, 0x15,
	0xe4, 0x7d, 0xce, 0x07, 0x12, 0x18, 0x06, 0x65, 0x09, 0x82, 0x3e, 0x73, 0xf8, 0x1e, 0x87, 0x4f,
	0x4d, 0x84, 0xef, 0xd1, 0xe7, 0xe2, 0x19, 0x64, 0xc2, 0xf8, 0xf9, 0x14, 0x66, 0xd9, 0xc0, 0x93,
	0x23, 0xe3, 0xe3, 0x47, 0x9c, 0x2d, 0x6f, 0x03, 0x10, 0xb3, 0xc6, 0xfa, 0x58, 0x62, 0xe0, 0x98,
	0xee, 0x28, 0x4b, 0x60, 0xac, 0xa3, 0xbf, 0x0e, 0x85, 0xd0, 0x2d, 0xad, 0x67, 0xbf, 0xc1, 0xf2,
	0x67, 0x30, 0x6b, 0x3a, 0xc2, 0x4c, 0x58, 0x4a, 0xf8, 0x8e, 0xce, 0x06, 0x0e, 0x91, 0xef, 0x47,
	0x9e, 0x8e, 0x0d, 0x69, 0xd4, 0xcf, 0x37, 0x60, 0xd6, 0x32, 0xce, 0x74, 0xdf, 0xa0, 0x81, 0x9a,
	0x41, 0xfc, 0xad, 0xf8, 0x2d, 0xe4, 0xeb, 0x3b, 0xaa, 0xed, 0xfa, 0xdc, 0xac, 0x8f, 0x20, 0xe3,
	0xd8, 0xae, 0x8f, 0xfb, 0xf6, 0x0b, 0xaa, 0x40, 0xa1, 0xbc, 0xfa, 0xfa, 0xd5, 0xfa, 0x72, 0x22,
	0x1a, 0xf6, 0x76, 0x77, 0x1f, 0xed, 0xa2, 0x39, 0x82, 0xac, 0xdb, 0x2f, 0xe4, 0x5d, 0xc8, 0xd2,
	0x46, 0x24, 0x20, 0x79, 0x0c, 0x4d, 0x6e, 0x45, 0xe5, 0x1f, 0x9a, 0x67, 0xe7, 0xc5, 0x0c, 0xcc,
	0x2a, 0x03, 0xc7, 0xbf, 0xc6, 0xc5, 0xff, 0x93, 0x85, 0x7c, 0xd5, 0xb5, 0x1d, 0x64, 0xe8, 0x9e,
	0x6d, 0x79, 0x58, 0xfe, 0x29, 0xc8, 0x5d, 0xd7, 0x76, 0xf0, 0x40, 0xef, 0xf7, 0x6c, 0x77, 0x60,
	0x74, 0xb1, 0x73, 0xc1, 0x22, 0x2b, 0x83, 0x24, 0xc2, 0x69, 0x04, 0x0c, 0xf5, 0xc2, 0x0f, 0xd1,
	0xa6, 0xe5, 0x0c, 0x7d, 0x3c, 0xd0, 0x1d, 0xc7, 0xb4, 0xce, 0xa8, 0x22, 0x1c, 0x5d, 0x23, 0x8c,
	0x06, 0xa3, 0xcb, 0x5f, 0xc1, 0xad, 0x51, 0x34, 0xee, 0x1a, 0xbf, 0xd1, 0x2f, 0x87, 0xdc, 0x3a,
	0x37, 0x92, 0x8d, 0xaa, 0x94, 0x2b, 0x17, 0xa1, 0x40, 0x9b, 0xf6, 0xc8, 0x84, 0x3e, 0x37, 0xfd,
	0xd5, 0x34, 0x85, 0xe7, 0x08, 0x71, 0xbf, 0x6f, 0xbf, 0x38, 0x34, 0x7d, 0xf9, 0x23, 0x98, 0x8f,
	0x30, 0x03, 0xd3, 0xf3, 0x56, 0x67, 0x28, 0x28, 0x1f, 0x80, 0x1a, 0xa6, 0xe7, 0xc9, 0xb7, 0x21,
	0x4b, 0x51, 0x96, 0xde, 0xe9, 0xaf, 0xce, 0x52, 0x40, 0x86, 0x10, 0x9a, 0x7a, 0xa7, 0x1f, 0x32,
	0x4d, 0xc7, 0x3b, 0x5b, 0x9d, 0x8b, 0x98, 0x35, 0xc7, 0x3b, 0x93, 0xb7, 0x61, 0x85, 0x33, 0xb1,
	0x65, 0xbb, 0x03, 0xbd, 0x6f, 0x7e, 0xab, 0xfb, 0xa6, 0x6d, 0xad, 0x66, 0x28, 0x70, 0x89, 0x01,
	0x9b, 0x22, 0x4b, 0xde, 0x01, 0x3a, 0x22, 0xec, 0x77, 0x92, 0x8d, 0xb2, 0xb4, 0xd1, 0x32, 0xe1,
	0xb6, 0x3b, 0x89, 0x56, 0xfb, 0xf0, 0x41, 0xd8, 0xca, 0xf5, 0x7c, 0xfc, 0xc2, 0xf4, 0xcf, 0xb1,
	0x69, 0x5d, 0xea, 0x7d, 0xb3, 0x8b, 0xf5, 0xce, 0x05, 0xb6, 0x86, 0x83, 0x55, 0xa0, 0x02, 0x6e,
	0x73, 0x01, 0xc8, 0xf3, 0x9f, 0x98, 0xfe, 0x79, 0x8d, 0x81, 0x4a, 0x9d, 0x8b, 0xe6, 0x70, 0x20,
	0x7f, 0x05, 0x6b, 0x42, 0xef, 0x16, 0xf6, 0xae, 0x2d, 0xdc, 0x33, 0x89, 0x44, 0xe2, 0xd4, 0x1c,
	0x15, 0xb0, 0x12, 0x6a, 0x60, 0x69, 0xd7, 0xd6, 0x3e, 0xe1, 0x12, 0xcf, 0xee, 0xc1, 0x4d, 0x36,
	0xd8, 0xce, 0x20, 0xa9, 0x79, 0x3e, 0x6a, 0x57, 0xeb, 0x0c, 0x12, 0xaa, 0xff, 0x8c, 0x77, 0xc9,
	0x7c, 0xec, 0xb8, 0xb6, 0x63, 0xb8, 0xbe, 0x69, 0x78, 0xcc, 0x21, 0x05, 0xda, 0xf4, 0x66, 0xe8,
	0x64, 0x35, 0xe4, 0x53, 0xdf, 0x6c, 0x0b, 0xd6, 0xb2, 0x87, 0x3e, 0xb6, 0x7b, 0xf8, 0x85, 0x69,
	0x75, 0xed, 0x17, 0xab, 0xf3, 0xb4, 0xa1, 0xcc, 0x75, 0x6d, 0x0d, 0xfd, 0x56, 0xef, 0x09, 0xe5,
	0xc8, 0x5f, 0xc0, 0x6a, 0xd8, 0xc6, 0x73, 0xfa, 0xa6, 0x8f, 0xcf, 0x75, 0xab, 0xeb, 0x9d, 0xeb,
	0x17, 0xc6, 0xea, 0x42, 0x6c, 0x84, 0x1a, 0xe1, 0x1e, 0x06, 0xcc, 0x58, 0x67, 0x2f, 0x4c, 0x0b,
	0x7f, 0x6b, 0xb8, 0x36, 0x26, 0x94, 0x55, 0x29, 0xd6, 0xd9, 0x13, 0xd3, 0xfa, 0xa5, 0xe1, 0xda,
	0x64, 0x96, 0xc8, 0x3b, 0xdc, 0x2a, 0xa4, 0x4d, 0x57, 0xf7, 0x75, 0xac, 0xf7, 0x7c, 0xc3, 0xc5,
	0x3d, 0xd3, 0x5a, 0x5d, 0x8c, 0x82, 0xa0, 0xdd, 0x71, 0xaa, 0xba, 0xaf, 0x97, 0x08, 0x6f, 0xdf,
	0xb4, 0xe4, 0x9f, 0xc3, 0xdd, 0x98, 0x1b, 0xb8, 0x03, 0x78, 0x63, 0xd7, 0xf3, 0x57, 0x65, 0xda,
	0x78, 0x35, 0x72, 0x05, 0xa2, 0x5e, 0xa0, 0x12, 0x90, 0xe7, 0xcb, 0x0d, 0xf8, 0x28, 0x94, 0x10,
	0xc4, 0x81, 0x6b, 0x78, 0x8e, 0x6d, 0x75, 0x69, 0xf7, 0x81, 0x4b, 0x97, 0xa8, 0x9c, 0x75, 0x2e,
	0x87, 0x07, 0x03, 0x0a, 0x80, 0xa1, 0x73, 0x77, 0x85, 0x61, 0x0c, 0x2d, 0xe3, 0xca, 0x31, 0x3a,
	0x3e, 0x9f, 0xe9, 0xcb, 0xb1, 0xb0, 0x3c, 0x0e, 0x99, 0xa4, 0xd9, 0x16, 0x9f, 0x00, 0x9e, 0xdb,
	0xc1, 0x7d, 0xb3, 0x47, 0x5c, 0x3a, 0xd0, 0xfd, 0xce, 0xf9, 0xea, 0x4a, 0x64, 0x30, 0xcd, 0xed,
	0xd4, 0xcd, 0x5e, 0x83, 0x73, 0xe4, 0x47, 0xdc, 0xc8, 0x8e, 0xee, 0x7a, 0x86, 0x8b, 0xcd, 0x8e,
	0xdb, 0xc1, 0x86, 0xeb, 0xda, 0xee, 0xea, 0x8d, 0xc8, 0x5e, 0x2a, 0x65, 0xd6, 0x3a, 0x6e, 0x47,
	0x21, 0x2c, 0xf9, 0x01, 0x2c, 0x47, 0x8d, 0xc8, 0xf2, 0xc8, 0x9b, 0xdc, 0xa4, 0x4d, 0x16, 0xc3,
	0x26, 0x75, 0xc3, 0x62, 0x0d, 0x36, 0x81, 0xca, 0xc1, 0xe7, 0xba, 0xdb, 0x7d, 0xa1, 0xbb, 0x06,
	0xc7, 0xaf, 0x46, 0xf8, 0x43, 0xce, 0xa1, 0xf8, 0xe2, 0x6f, 0xa7, 0x40, 0x56, 0xce, 0x48, 0x7a,
	0x8e, 0xe5, 0xbe, 0x40, 0x8c, 0x3d, 0xf4, 0xc5, 0x74, 0x96, 0x8a, 0xc4, 0xb4, 0x28, 0x27, 0xc8,
	0x67, 0x9f, 0x73, 0xbc, 0xe3, 0x0e, 0x2d, 0x83, 0x5a, 0x85, 0x64, 0x58, 0x31, 0xfd, 0xa9, 0x84,
	0xa3, 0xb9, 0x1d, 0x92, 0xe7, 0x49, 0xf9, 0xc4, 0x52, 0xab, 0x49, 0xb5, 0x63, 0x09, 0x0f, 0x68,
	0x4e, 0xa5, 0x14, 0xf9, 0x03, 0xc8, 0x33, 0x79, 0x76, 0xdf, 0xec, 0x18, 0xae, 0x98, 0xe3, 0x54,
	0x46, 0x0a, 0x13, 0x54, 0xc7, 0x76, 0x1c, 0x9e, 0xde, 0x68, 0x82, 0xaa, 0xd8, 0x8e, 0x23, 0x6f,
	0xc0, 0x22, 0x63, 0x9e, 0x1b, 0x9d, 0x0b, 0x6f, 0x38, 0x20, 0x66, 0xe0, 0x29, 0x6e, 0x81, 0x82,
	0x38, 0x5d, 0x71, 0xdd, 0xa2, 0x02, 0x85, 0x13, 0xb7, 0xf7, 0xd8, 0xb8, 0x26, 0x13, 0xa2, 0x6f,
	0x24, 0x2b, 0xc6, 0x34, 0xaf, 0x18, 0xe5, 0x3b, 0x00, 0x84, 0x7c, 0x4e, 0x51, 0x74, 0x68, 0xb3,
	0x28, 0x7b, 0xe9, 0xf6, 0x58, 0xb3, 0x22, 0x86, 0xa5, 0xfa, 0xb6, 0x66, 0x9c, 0x0d, 0x0c, 0xcb,
	0x17, 0x84, 0xdd, 0x01, 0xf0, 0x18, 0x31, 0x12, 0x98, 0xe5, 0x94, 0x5a, 0x57, 0xfe, 0x09, 0x48,
	0xfd, 0xed, 0x00, 0x10, 0x13, 0xbd, 0x10, 0xd2, 0x79, 0x07, 0xbf, 0x80, 0x79, 0x62, 0x3c, 0x41,
	0xf6, 0x4d, 0xa0, 0xcb, 0x5f, 0x20, 0x78, 0x0e, 0xcd, 0x92, 0xd7, 0x5a, 0x97, 0xd8, 0x97, 0x2d,
	0x86, 0xa2, 0x40, 0xa0, 0x8b, 0x1e, 0x93, 0x55, 0x81, 0x42, 0xdd, 0x14, 0xc7, 0xbc, 0x0c, 0x33,
	0x75, 0xb3, 0x57, 0x0b, 0x8b, 0x64, 0xfa, 0x22, 0xbf, 0x0f, 0xd9, 0xba, 0xc9, 0x07, 0x18, 0x8c,
	0x38, 0x24, 0x14, 0x35, 0x58, 0xaa, 0x05, 0xb5, 0xb9, 0x20, 0xea, 0x1e, 0xe4, 0x42, 0x72, 0x28,
	0x50, 0x24, 0xc9, 0x6b, 0x90, 0xa9, 0xc5, 0xa5, 0x86, 0xef, 0xc5, 0xff, 0x94, 0x02, 0xd8, 0x37,
	0xfb, 0xbe, 0xe1, 0x3e, 0x36, 0xae, 0xb1, 0xfc, 0x87, 0xb0, 0x48, 0xe6, 0xd7, 0x85, 0x71, 0x8d,
	0x6d, 0x37, 0x18, 0x4f, 0x4a, 0x2c, 0x6b, 0x62, 0xe3, 0x40, 0xf3, 0x7d, 0xfa, 0xda, 0x72, 0x19,
	0x81, 0xd4, 0xb1, 0x3d, 0x2a, 0x8d, 0x55, 0xf6, 0x53, 0xb4, 0x9e, 0xe1, 0xb5, 0x28, 0xeb, 0x86,
	0x16, 0x33, 0xd0, 0x0b, 0x9f, 0x89, 0xf1, 0x06, 0x7a, 0x07, 0x07, 0x45, 0xcd, 0x34, 0x75, 0x19,
	0x0c, 0xf4, 0x0e, 0xaf, 0x68, 0x68, 0xc5, 0xdd, 0xd7, 0x2d, 0x62, 0xf6, 0x34, 0x2d, 0xfc, 0x67,
	0xc9, 0x6b, 0xad, 0x5b, 0xfc, 0xbb, 0x29, 0x90, 0xeb, 0x66, 0xef, 0x48, 0xf3, 0x75, 0xdf, 0x68,
	0xe8, 0x8e, 0x62, 0xf9, 0xee, 0x35, 0x96, 0x6f, 0x41, 0x86, 0x74, 0x4e, 0x97, 0x2a, 0x5a, 0xcf,
	0xa0, 0x39, 0xf2, 0x4e, 0x96, 0x25, 0x19, 0xd2, 0x9e, 0xf9, 0x6d, 0xb0, 0x81, 0xa0, 0xcf, 0xf2,
	0x2a, 0xcc, 0x19, 0x96, 0xef, 0x9a, 0x06, 0xeb, 0xbb, 0x80, 0x82, 0x57, 0xf9, 0x01, 0xcc, 0x39,
	0x43, 0xd7, 0xb1, 0x3d, 0x83, 0x76, 0x1c, 0xee, 0x23, 0x48, 0x9f, 0x43, 0x63, 0x68, 0xa8, 0x8c,
	0x89, 0x02, 0x54, 0xf1, 0x9f, 0xa5, 0x00, 0xd4, 0x0b, 0x9f, 0x0d, 0x94, 0xd4, 0x75, 0x8b, 0xae,
	0xd1, 0x31, 0xcc, 0x4b, 0x03, 0x3f, 0x73, 0x6d, 0xbd, 0xdb, 0xd1, 0xbd, 0xb0, 0xa0, 0xe1, 0x8c,
	0x72, 0x40, 0x27, 0x6b, 0x7c, 0x00, 0xd6, 0xfb, 0x7d, 0x3c, 0x18, 0xf6, 0x7d, 0x93, 0x36, 0x60,
	0x93, 0x7a, 0x89, 0x33, 0x4b, 0xfd, 0x7e, 0x23, 0x60, 0xc9, 0x0f, 0x20, 0x20, 0x93, 0xf5, 0x6e,
	0x60, 0x7a, 0x9d, 0xa1, 0x3d, 0xf4, 0xf8, 0xfc, 0x96, 0x39, 0x4b, 0x8d, 0x38, 0xc5, 0xdf, 0xcd,
	0x42, 0xa6, 0x6e, 0xf6, 0x34, 0xc7, 0xe8, 0x60, 0xf9, 0x13, 0x48, 0x93, 0x2d, 0x1b, 0x77, 0xaf,
	0xbc, 0xc9, 0x77, 0x75, 0xd1, 0x66, 0x0e, 0x51, 0xbe, 0x7c, 0x00, 0x85, 0x78, 0x3c, 0x4c, 0x4d,
	0x8c, 0x87, 0xf2, 0xfc, 0xeb, 0x57, 0xeb, 0xc0, 0x6b, 0xc0, 0x0b, 0xe3, 0x1a, 0xe5, 0x2e, 0x84,
	0xe0, 0xf8, 0x77, 0x29, 0xb8, 0xed, 0x98, 0x96, 0x65, 0x74, 0xf1, 0xd0, 0xe9, 0x9b, 0xd6, 0x05,
	0xe6, 0xa1, 0xc6, 0xe5, 0x4e, 0x53, 0xb9, 0xb7, 0x78, 0xf5, 0x3b, 0x1a, 0xea, 0xe5, 0xd3, 0xd7,
	0xaf, 0xd6, 0xdb, 0x41, 0x85, 0x69, 0xf4, 0x7e, 0xca, 0x1f, 0x3b, 0xb6, 0xe5, 0xf9, 0xae, 0x6e,
	0x5a, 0xbe, 0xf7, 0xcd, 0x5f, 0x8b, 0x37, 0x26, 0x23, 0xdd, 0x24, 0xde, 0xff, 0x26, 0xdc, 0xd6,
	0x62, 0xe7, 0xd9, 0xf6, 0x66, 0x6d, 0x1f, 0xb7, 0x9f, 0xaa, 0x0a, 0x3e, 0x56, 0xeb, 0xb5, 0xe6,
	0xe3, 0x97, 0xe8, 0x26, 0xd3, 0xeb, 0x98, 0xaa, 0x55, 0x8b, 0x46, 0x24, 0x3f, 0x82, 0xbc, 0xde,
	0x1d, 0x98, 0x16, 0xf6, 0x7c, 0xdd, 0x1f, 0x7a, 0x3c, 0x10, 0xa4, 0x50, 0xc7, 0x9e, 0x46, 0xe9,
	0x28, 0x47, 0x51, 0xec, 0x45, 0xfe, 0x43, 0x20, 0xf3, 0x02, 0x3f, 0x27, 0x6d, 0x0c, 0x92, 0xcd,
	0x69, 0xc2, 0xcc, 0x6d, 0xaf, 0x46, 0xf1, 0x13, 0x8f, 0x59, 0x94, 0xef, 0x9b, 0xbd, 0x23, 0x8f,
	0xd3, 0x48, 0xcd, 0x49, 0x23, 0xde, 0xf3, 0x5d, 0xd3, 0xc1, 0x86, 0xc5, 0x53, 0x69, 0x8e, 0x10,
	0x35, 0x42, 0x53, 0x2c, 0x52, 0x73, 0xb2, 0x59, 0x61, 0x79, 0x86, 0xeb, 0x13, 0x10, 0xab, 0x1a,
	0xf3, 0x74, 0x72, 0x50, 0xa2, 0x62, 0xb1, 0x8d, 0xb3, 0xfe, 0xac, 0x6f, 0x60, 0xb7, 0x3b, 0xd0,
	0x79, 0xbd, 0x08, 0x8c, 0x84, 0xba, 0x03, 0x5d, 0xfe, 0x0a, 0x0a, 0xa6, 0x87, 0x07, 0xba, 0xa5,
	0x9f, 0x19, 0x24, 0xf9, 0xb1, 0xea, 0x30, 0xb6, 0x35, 0x36, 0x07, 0x83, 0xa1, 0x4f, 0x1b, 0xe4,
	0x4d, 0xaf, 0x11, 0x22, 0xe5, 0x5d, 0x28, 0x38, 0x7a, 0xe7, 0xc2, 0xf0, 0x31, 0x9b, 0xcd, 0xb4,
	0x2e, 0x0c, 0x77, 0x9e, 0xd1, 0x3c, 0x40, 0x79, 0x06, 0x63, 0xaf, 0xf2, 0x1a, 0x64, 0xcf, 0x5f,
	0xd0, 0x55, 0xdc, 0xec, 0xd2, 0x4a, 0xb0, 0x80, 0xe6, 0xce, 0x5f, 0xb0, 0x04, 0x58, 0x84, 0x02,
	0xd1, 0x13, 0x0f, 0xf4, 0x2b, 0x12, 0x18, 0x1e, 0xad, 0xf8, 0x0a, 0x28, 0x47, 0x88, 0x0d, 0xfd,
	0xea, 0xb1, 0x71, 0xed, 0xc9, 0xf7, 0x20, 0x1f, 0x62, 0xf4, 0x73, 0x56, 0xd9, 0x15, 0x10, 0x70,
	0x48, 0xe9, 0xdc, 0x23, 0xab, 0x63, 0x88, 0x70, 0x88, 0x69, 0xd8, 0xec, 0x9e, 0xa7, 0x40, 0x89,
	0x03, 0x55, 0x5f, 0xe1, 0xd3, 0x7c, 0x1b, 0x20, 0xf2, 0x16, 0xad, 0xdc, 0xc2, 0xe0, 0x66, 0x6e,
	0xd2, 0x0c, 0x1f, 0x19, 0xcf, 0xc9, 0x7e, 0x3d, 0x70, 0x92, 0xfc, 0x21, 0x4c, 0xbb, 0x9e, 0x47,
	0xeb, 0xb5, 0xdc, 0xf6, 0x62, 0xe8, 0x56, 0xe4, 0x79, 0x74, 0x6e, 0x21, 0xc2, 0xfd, 0x3a, 0xfd,
	0xdb, 0x7f, 0x54, 0x4c, 0x15, 0xbf, 0x86, 0x79, 0xc2, 0x31, 0x9e, 0x0f, 0x0d, 0xcf, 0x6f, 0x78,
	0x67, 0x98, 0x6c, 0xe1, 0x5c, 0xf6, 0x1a, 0xdf, 0xc4, 0x06, 0x33, 0x13, 0x05, 0xec, 0xe2, 0xff,
	0x4e, 0x01, 0x10, 0x2a, 0x0d, 0xab, 0xdf, 0xc3, 0x8c, 0x7d, 0xc0, 0x4c, 0xc3, 0x63, 0x7f, 0x7a,
	0x42, 0xec, 0x13, 0xbb, 0xf0, 0xc8, 0xbf, 0xc3, 0x1a, 0xf0, 0x6e, 0xd3, 0x6c, 0x09, 0xeb, 0x07,
	0x4b, 0x58, 0xdc, 0xf7, 0x33, 0x34, 0xd3, 0x07, 0xbe, 0xe7, 0xd6, 0xfa, 0x19, 0x1d, 0x30, 0xb3,
	0xfb, 0x77, 0xa5, 0xf2, 0xf0, 0xa8, 0x24, 0x8d, 0xe8, 0x73, 0xd1, 0x87, 0x3c, 0x31, 0x75, 0x77,
	0xa0, 0x93, 0x2a, 0x98, 0x2c, 0x8d, 0x79, 0xc7, 0xc7, 0xcf, 0x74, 0xcf, 0xc0, 0xe1, 0x41, 0x4c,
	0x1a, 0x81, 0xe3, 0x97, 0x75, 0xcf, 0xa0, 0xa7, 0x39, 0xf7, 0x20, 0x7f, 0x21, 0x22, 0x98, 0x34,
	0xb8, 0x88, 0x21, 0x74, 0x11, 0xc1, 0xd7, 0x27, 0x3d, 0x44, 0x14, 0xff, 0xe6, 0x14, 0xeb, 0x96,
	0x16, 0xbb, 0x9e, 0x81, 0x65, 0x05, 0x40, 0x77, 0xcc, 0xc0, 0x6a, 0xb1, 0xd3, 0xad, 0x92, 0x63,
	0x32, 0x4b, 0x95, 0x57, 0x5e, 0xbf, 0x5a, 0x5f, 0xe4, 0x76, 0x8f, 0xd0, 0x28, 0xab, 0x07, 0x08,
	0xf9, 0x3e, 0xcc, 0x72, 0x11, 0xb1, 0xe3, 0xa0, 0x28, 0x1e, 0x10, 0xe7, 0x13, 0x24, 0x8f, 0xde,
	0xe9, 0x04, 0x92, 0x1b, 0x12, 0x71, 0xbe, 0xfc, 0x09, 0x2c, 0xd0, 0xa9, 0x41, 0xb7, 0x10, 0xb4,
	0x46, 0xe7, 0xb5, 0x1e, 0x9d, 0x77, 0xc4, 0x6a, 0x27, 0x84, 0x28, 0x3f, 0x80, 0x6c, 0x88, 0xe3,
	0xc9, 0x4b, 0x8e, 0xa2, 0x3c, 0x30, 0x30, 0xca, 0x04, 0xad, 0x8a, 0x25, 0x58, 0x10, 0x6c, 0x40,
	0xc3, 0x7c, 0x13, 0x32, 0x2e, 0x7f, 0x0f, 0x23, 0x36, 0x14, 0x11, 0x18, 0x0b, 0x85, 0x98, 0xe2,
	0xdf, 0x80, 0x02, 0x53, 0xf7, 0x80, 0xcd, 0xb7, 0x44, 0x30, 0xf1, 0x5a, 0x2e, 0x0a, 0x26, 0x31,
	0x38, 0xa6, 0xe2, 0xc1, 0x21, 0xc1, 0xf4, 0x73, 0xb3, 0xcb, 0xd7, 0x73, 0xf2, 0x48, 0x33, 0x8b,
	0xe1, 0xb3, 0x71, 0xd3, 0x12, 0x20, 0xcd, 0x33, 0x8b, 0xe1, 0x13, 0xfd, 0x35, 0xf3, 0x5b, 0xa3,
	0x78, 0x06, 0xf3, 0x82, 0x02, 0x9e, 0x43, 0x35, 0xa0, 0x05, 0x3d, 0xee, 0xd8, 0x5d, 0xa6, 0xc1,
	0x0c, 0xca, 0x52, 0x4a, 0xc5, 0xee, 0x1a, 0xa4, 0x72, 0x7d, 0x2e, 0xc6, 0xcd, 0xcc, 0x73, 0x1a,
	0x32, 0xeb, 0x90, 0x7b, 0x4e, 0xea, 0x03, 0x1c, 0xf9, 0x24, 0x8f, 0x80, 0x92, 0xa8, 0xf8, 0x62,
	0x05, 0x56, 0x0e, 0x0c, 0x9f, 0xf5, 0x15, 0x33, 0xd9, 0x06, 0xcc, 0x10, 0x73, 0x04, 0x87, 0x78,
	0xcb, 0x62, 0x16, 0x0a, 0x94, 0x42, 0x0c, 0x52, 0x7c, 0x0a, 0x79, 0x75, 0x47, 0x75, 0xed, 0xb3,
	0xba, 0xfe, 0xcc, 0xe8, 0x63, 0xf9, 0x06, 0xcc, 0x0a, 0x96, 0xca, 0x22, 0xfe, 0x46, 0x0a, 0x77,
	0xc7, 0xb5, 0xcf, 0xb0, 0xa5, 0x0f, 0x58, 0x22, 0xc8, 0xa2, 0x0c, 0x21, 0x34, 0xf5, 0x81, 0x41,
	0xea, 0xd0, 0x3e, 0x69, 0x4e, 0x95, 0xcc, 0x22, 0xf6, 0x52, 0xfc, 0x57, 0xa9, 0xc0, 0x15, 0xda,
	0x8f, 0xe0, 0x8a, 0xfb, 0x41, 0x9f, 0x69, 0x31, 0x28, 0xc4, 0xb1, 0x70, 0x3d, 0x92, 0x86, 0x9c,
	0x19, 0x31, 0xe4, 0x5f, 0x81, 0x65, 0x2d, 0x32, 0x64, 0x94, 0x61, 0x3f, 0x85, 0xb4, 0x6b, 0x3c,
	0xf7, 0xe2, 0x95, 0x6b, 0x3c, 0x99, 0x53, 0x40, 0xf1, 0x41, 0xe0, 0x72, 0xed, 0xfb, 0xb9, 0x9c,
	0xb8, 0x4e, 0x7b, 0x6b, 0xd7, 0x69, 0x09, 0xd7, 0xfd, 0x11, 0x2c, 0xd6, 0xcd, 0x5e, 0xd5, 0xe8,
	0x1b, 0xa1, 0xda, 0x78, 0x34, 0x69, 0xa7, 0x7e, 0x58, 0xd2, 0x2e, 0xd6, 0x60, 0x39, 0x29, 0x9d,
	0x6a, 0xb8, 0x95, 0x5c, 0x76, 0x6e, 0x86, 0xa2, 0xe3, 0xaa, 0x44, 0xeb, 0xcf, 0xaf, 0x68, 0x81,
	0x1d, 0x70, 0xdf, 0x6d, 0x7e, 0x2b, 0x36, 0x60, 0x65, 0x44, 0x38, 0x55, 0x74, 0x67, 0x24, 0x71,
	0xac, 0x8e, 0x68, 0x3a, 0x9a, 0x3e, 0xfe, 0xd7, 0x14, 0xe4, 0xea, 0x66, 0xaf, 0x7d, 0x45, 0xc4,
	0x7b, 0x98, 0xc4, 0x7d, 0xcf, 0xd5, 0x07, 0x86, 0x87, 0xed, 0x0b, 0x1e, 0xb1, 0x19, 0x46, 0x68,
	0x5d, 0x90, 0x0d, 0xeb, 0xd0, 0xa2, 0x45, 0x34, 0x8e, 0x40, 0x6c, 0x12, 0x2f, 0x70, 0xc6, 0x7e,
	0x80, 0xdd, 0x84, 0xa5, 0xb0, 0x1a, 0xc7, 0xcf, 0x42, 0x34, 0x5b, 0x08, 0x16, 0x43, 0x56, 0x59,
	0xc0, 0x87, 0xe5, 0xbe, 0x80, 0x4f, 0x33, 0x7c, 0xc8, 0x0a, 0xf1, 0xb7, 0x20, 0xf3, 0xec, 0xda,
	0x67, 0x20, 0xbe, 0x26, 0xd2, 0xf7, 0xd6, 0x85, 0x7c, 0x1f, 0xa4, 0x40, 0xcd, 0x10, 0x32, 0x4b,
	0x21, 0xf3, 0x9c, 0x5e, 0xe6, 0xc8, 0x9f, 0x82, 0x2c, 0x28, 0x19, 0x60, 0xe7, 0x28, 0x56, 0x8a,
	0x74, 0x8c, 0xd0, 0x82, 0x8a, 0x01, 0x3a, 0xc3, 0xd0, 0x91, 0x86, 0x1c, 0x2d, 0xc1, 0xb4, 0xef,
	0xd9, 0xb4, 0x32, 0x4c, 0x23, 0xf2, 0x58, 0xfc, 0x8b, 0x19, 0x6a, 0x6b, 0x14, 0xd8, 0xfa, 0x03,
	0xc8, 0x73, 0x33, 0xfa, 0xb6, 0xaf, 0xf7, 0xb9, 0xb9, 0x73, 0x8c, 0xd6, 0x26, 0xa4, 0xb8, 0x3b,
	0xa6, 0xbe, 0x8f, 0x3b, 0xa6, 0xbf, 0x87, 0x3b, 0x7a, 0x49, 0xf3, 0x86, 0xac, 0xfd, 0xb1, 0xee,
	0x88, 0xf0, 0x33, 0x09, 0x77, 0xec, 0x8f, 0x73, 0xc7, 0xec, 0x77, 0xbb, 0x63, 0xee, 0x2d, 0xdc,
	0x91, 0x79, 0x2b, 0x77, 0x64, 0x27, 0xb8, 0x63, 0x19, 0x66, 0xba, 0xae, 0xed, 0x78, 0xb4, 0xde,
	0x4e, 0x23, 0xf6, 0x42, 0x76, 0xc9, 0x96, 0x8d, 0x9f, 0x0d, 0x7b, 0x1e, 0x2d, 0xaa, 0xd3, 0x68,
	0xd6, 0xb2, 0xcb, 0xc3, 0x1e, 0xbd, 0x06, 0xa0, 0xe9, 0x8b, 0x15, 0xd3, 0x69, 0xc4, 0xdf, 0x88,
	0x57, 0x5d, 0x7e, 0x30, 0x9a, 0xa6, 0xf5, 0x2a, 0x49, 0x7d, 0xe1, 0x29, 0x19, 0x2b, 0x97, 0xd3,
	0x28, 0x1b, 0x9c, 0x8d, 0x79, 0x82, 0x07, 0xf7, 0x76, 0x68, 0x99, 0x1c, 0x7a, 0x70, 0x6f, 0x87,
	0xb4, 0xe5, 0xcc, 0xad, 0xed, 0x2f, 0x68, 0x5d, 0x9c, 0x46, 0x1c, 0xbe, 0xb5, 0xfd, 0x85, 0xc0,
	0xde, 0xde, 0xdd, 0xa5, 0x27, 0x96, 0x21, 0x7b, 0x7b, 0x77, 0x57, 0x60, 0xef, 0x6e, 0x6d, 0xd1,
	0x33, 0xc9, 0x90, 0xbd, 0xbb, 0xb5, 0x45, 0xd6, 0x81, 0x40, 0xf8, 0xc3, 0xed, 0x1d, 0x7a, 0xd6,
	0x98, 0x46, 0xbc, 0x05, 0xa1, 0x88, 0x80, 0xdd, 0xad, 0x2f, 0xe9, 0x51, 0x62, 0x04, 0xd8, 0xdd,
	0xfa, 0x92, 0x2c, 0xff, 0x61, 0x80, 0x92, 0x7d, 0x01, 0x3d, 0x38, 0x14, 0x22, 0xb4, 0xa1, 0x5f,
	0x15, 0x55, 0x16, 0xd3, 0xbc, 0x84, 0x27, 0x71, 0x40, 0x96, 0xbc, 0xf0, 0x5e, 0xa6, 0x80, 0xe6,
	0xfa, 0x66, 0x8f, 0x1e, 0x59, 0x48, 0x30, 0x7d, 0x61, 0x5c, 0xd3, 0x28, 0xce, 0x23, 0xf2, 0x48,
	0x7c, 0x62, 0x5a, 0x5d, 0x33, 0xb8, 0x13, 0x64, 0x2f, 0xc5, 0x7f, 0x93, 0x82, 0xac, 0x62, 0x99,
	0x1d, 0x76, 0xe9, 0xf9, 0x2b, 0x58, 0x8e, 0xce, 0x9e, 0x84, 0x6d, 0x6f, 0x4a, 0xdc, 0xf6, 0x8e,
	0x39, 0xd3, 0x8a, 0x65, 0x7b, 0xd7, 0xe8, 0x21, 0x39, 0x14, 0x13, 0xed, 0x53, 0x13, 0xa7, 0x28,
	0xfc, 0x08, 0x4a, 0x38, 0x45, 0x29, 0x42, 0x81, 0x5f, 0xa1, 0xf2, 0xb3, 0x14, 0xb6, 0x22, 0xb3,
	0x7b, 0xd5, 0x13, 0x76, 0xa0, 0xf2, 0xcf, 0x53, 0x20, 0x11, 0x7d, 0x2b, 0x7d, 0xdd, 0xf3, 0xfe,
	0x52, 0xd4, 0xde, 0x84, 0x25, 0x4b, 0xf7, 0xcd, 0x4b, 0x03, 0x47, 0x7d, 0x98, 0x5d, 0x9e, 0x1f,
	0x16, 0x19, 0xab, 0xbe, 0x1d, 0x9e, 0xdf, 0x15, 0xff, 0x6d, 0x1a, 0x72, 0xb5, 0x5e, 0x64, 0x53,
	0x05, 0xb2, 0xa4, 0x03, 0xf1, 0x1e, 0x59, 0x8e, 0xf6, 0x27, 0x04, 0x47, 0x1c, 0x36, 0xe1, 0xa6,
	0x37, 0x63, 0x70, 0xbe, 0xdc, 0x1c, 0x77, 0xec, 0xf5, 0x3d, 0x37, 0x4d, 0x64, 0x68, 0xc9, 0x63,
	0xb0, 0xb3, 0xff, 0xcf, 0x83, 0x8e, 0xa4, 0xfc, 0x89, 0xc7, 0x13, 0x7f, 0x9c, 0xe2, 0x06, 0x30,
	0xad, 0x9e, 0xcd, 0x0b, 0x2a, 0xbe, 0x14, 0x87, 0x46, 0x2a, 0x6b, 0xaf, 0x5f, 0xad, 0xb7, 0x26,
	0x9f, 0x95, 0x84, 0xe6, 0xdc, 0x0c, 0x4d, 0xf9, 0xcd, 0xe8, 0x71, 0x89, 0xd2, 0xac, 0x55, 0xf8,
	0x99, 0x89, 0xa6, 0x1c, 0xbc, 0x64, 0xc6, 0x23, 0xad, 0xe4, 0x7f, 0x92, 0x82, 0xc5, 0x0e, 0x8b,
	0x18, 0x1c, 0xe9, 0xc2, 0x36, 0x0d, 0x37, 0x22, 0x5d, 0xc4, 0xa0, 0x2a, 0x9f, 0xbc, 0x7e, 0xb5,
	0x8e, 0xde, 0x9d, 0x4a, 0x95, 0x7a, 0x49, 0xd3, 0x6a, 0x95, 0x97, 0x68, 0x81, 0x2b, 0x12, 0xb4,
	0x2f, 0xfe, 0xfb, 0x14, 0x14, 0x6a, 0x3d, 0x6e, 0x38, 0x1a, 0x32, 0x0f, 0xf8, 0x75, 0x67, 0xb8,
	0xa7, 0x9c, 0x10, 0x1d, 0xf4, 0xac, 0x97, 0x54, 0xb0, 0x6f, 0x19, 0xa3, 0xf2, 0xcf, 0x61, 0xd1,
	0xf4, 0xb0, 0x6d, 0x3f, 0x13, 0x8f, 0x55, 0xa6, 0xdf, 0x70, 0xac, 0xb2, 0x60, 0x7a, 0x2d, 0xfb,
	0x59, 0x74, 0xb2, 0x52, 0xfc, 0x9f, 0x29, 0x58, 0x08, 0x94, 0x56, 0x2b, 0xc1, 0x27, 0x13, 0x63,
	0xb5, 0x48, 0x4d, 0xd2, 0xe2, 0x5f, 0xa6, 0x60, 0x79, 0x60, 0x0c, 0x9e, 0x19, 0x6e, 0x22, 0xf8,
	0xa6, 0x7e, 0x7f, 0xa7, 0x6c, 0x8b, 0x4c, 0x21, 0x21, 0x80, 0x8b, 0x3e, 0xc8, 0xb5, 0x5e, 0x7b,
	0x68, 0x59, 0x46, 0xff, 0xe4, 0x8a, 0x9e, 0x5c, 0x91, 0xc1, 0x7e, 0x0e, 0xd9, 0xbe, 0xdd, 0xd1,
	0xfb, 0xd8, 0x37, 0x9c, 0x89, 0x1f, 0x34, 0x64, 0x28, 0xa4, 0x6d, 0x38, 0xf2, 0x03, 0x00, 0xd7,
	0x18, 0xd8, 0xbe, 0x41, 0xf1, 0x93, 0x3e, 0x9e, 0xc8, 0x32, 0x4c, 0xdb, 0x70, 0x8a, 0xff, 0x20,
	0x05, 0x52, 0xd0, 0xed, 0x01, 0x52, 0x58, 0xa7, 0x64, 0xbf, 0x6d, 0x0f, 0xdd, 0x8e, 0x31, 0xb1,
	0x47, 0xce, 0x97, 0xb7, 0x21, 0xd7, 0x35, 0x3c, 0xdf, 0xb4, 0xd8, 0xb5, 0xe4, 0xa4, 0x0e, 0x45,
	0x10, 0x59, 0x33, 0x06, 0xfe, 0x30, 0xd8, 0x07, 0x0d, 0xfc, 0x21, 0x2d, 0xab, 0xfc, 0x3e, 0xdf,
	0x88, 0x92, 0xc7, 0xe2, 0x7f, 0x9e, 0x26, 0xc1, 0xca, 0xd4, 0x62, 0x3a, 0x7d, 0x39, 0xe6, 0x43,
	0x99, 0xc8, 0x75, 0x1c, 0xaa, 0x8c, 0xfb, 0x64, 0xe6, 0x1f, 0xa7, 0x00, 0x2e, 0xaf, 0xd8, 0x09,
	0x61, 0xcf, 0xe6, 0x3a, 0xf2, 0x3a, 0x7a, 0xd4, 0xe2, 0x65, 0xfc, 0xfa, 0xd5, 0xfa, 0xaf, 0xde,
	0x30, 0x21, 0x23, 0xa5, 0x36, 0x23, 0x85, 0xc6, 0xcc, 0xc9, 0xf6, 0x71, 0xb3, 0xa9, 0xd4, 0xb1,
	0xd2, 0xac, 0x94, 0x54, 0xe6, 0xfc, 0x93, 0xd3, 0x7a, 0xa9, 0xf9, 0x12, 0x65, 0x2f, 0x83, 0xce,
	0xe4, 0xbf, 0x9f, 0x82, 0xcc, 0x99, 0x6b, 0x30, 0xc5, 0xa6, 0xc5, 0x3c, 0x91, 0xf4, 0x49, 0xf9,
	0xd7, 0xaf, 0x5f, 0xad, 0x3f, 0xfd, 0x51, 0xd4, 0x3a, 0x40, 0xca, 0x4b, 0x34, 0x77, 0xe6, 0x1a,
	0x54, 0xa5, 0x1a, 0xcc, 0x5f, 0xba, 0xb1, 0x69, 0x92, 0x16, 0xb3, 0x7f, 0xec, 0xc2, 0x6a, 0x24,
	0x3b, 0xe7, 0x2f, 0x05, 0x76, 0xf1, 0x8f, 0x00, 0x6a, 0xbd, 0x8a, 0x7a, 0xcc, 0x1c, 0xf8, 0x8e,
	0x57, 0x96, 0xa2, 0x4e, 0x32, 0x43, 0xc9, 0x71, 0x90, 0xd1, 0x35, 0xdd, 0x1f, 0xa7, 0x8b, 0xff,
	0x92, 0x81, 0xf9, 0xd8, 0xd4, 0xfe, 0xfe, 0x07, 0x8f, 0x8d, 0xf1, 0x07, 0x8f, 0xdf, 0x73, 0xa5,
	0x1b, 0x39, 0x7e, 0xfc, 0x06, 0xe6, 0x82, 0x0a, 0x8c, 0x9d, 0x3d, 0xce, 0x0b, 0xa1, 0x9f, 0x5c,
	0xd7, 0xa3, 0x7c, 0x3a, 0xcb, 0xcb, 0xb4, 0x1f, 0x74, 0x76, 0xff, 0xc7, 0x29, 0xc8, 0x9b, 0xbd,
	0x91, 0x85, 0x6c, 0x71, 0x33, 0xb1, 0x32, 0xe1, 0x72, 0xfd, 0xf5, 0xab, 0xf5, 0xc3, 0xb7, 0x49,
	0x8e, 0x13, 0xb2, 0x23, 0x59, 0xc6, 0x5e, 0x22, 0x30, 0x43, 0xd1, 0xf2, 0x9f, 0xa4, 0x60, 0xde,
	0xec, 0x85, 0xb5, 0x03, 0xd1, 0x62, 0x56, 0xf4, 0x67, 0x6c, 0x41, 0x2b, 0x37, 0x5f, 0xbf, 0x5a,
	0xff, 0xc5, 0x3b, 0xd0, 0x23, 0xc8, 0xd2, 0x79, 0x53, 0x10, 0x2f, 0xff, 0x59, 0x0a, 0x16, 0x23,
	0x5d, 0x1c, 0x6e, 0x94, 0x39, 0xaa, 0xce, 0x4a, 0x5c, 0x1d, 0xbe, 0x54, 0x95, 0x8f, 0x5e, 0xbf,
	0x5a, 0x6f, 0xbc, 0x33, 0x85, 0xb0, 0x5a, 0x79, 0x89, 0xe6, 0x03, 0x9d, 0xd4, 0x98, 0x85, 0x7c,
	0x3a, 0xfd, 0x99, 0x4a, 0x99, 0xb8, 0x85, 0x84, 0x2c, 0xfa, 0xce, 0x2c, 0xc4, 0xb2, 0x08, 0xb5,
	0x50, 0x24, 0x5e, 0x7e, 0x09, 0x39, 0xb3, 0x87, 0x3b, 0xce, 0x90, 0xe9, 0x91, 0x8d, 0xad, 0x06,
	0x61, 0x26, 0x28, 0x3f, 0x7e, 0xfd, 0x6a, 0xfd, 0xe0, 0x1d, 0x28, 0x51, 0x51, 0x8f, 0x5f, 0xa2,
	0xac, 0xd9, 0xab, 0x38, 0x43, 0xd1, 0x41, 0xba, 0xe3, 0x60, 0x97, 0x24, 0x05, 0xa6, 0x05, 0xc4,
	0x1d, 0x14, 0xcb, 0x18, 0xef, 0xcc, 0x41, 0x25, 0x55, 0xc5, 0x48, 0xa9, 0xd6, 0x10, 0x75, 0x90,
	0xd8, 0x07, 0x3f, 0xcd, 0xdf, 0x87, 0xe5, 0x50, 0x9a, 0x78, 0x14, 0xb5, 0x99, 0x3c, 0x8a, 0x5a,
	0xde, 0x1c, 0xed, 0x5a, 0x38, 0x87, 0xfa, 0x8f, 0x29, 0x58, 0x62, 0xfe, 0x0f, 0x4e, 0x7e, 0x58,
	0xea, 0xfb, 0x04, 0x16, 0x78, 0x60, 0xf6, 0xc5, 0x9b, 0xf9, 0x02, 0x2a, 0x30, 0x72, 0x9d, 0x5f,
	0xd0, 0xc7, 0xee, 0x1d, 0xa6, 0xe2, 0x77, 0x4e, 0x77, 0x00, 0x82, 0x89, 0xd6, 0xbd, 0xe2, 0xeb,
	0x73, 0x96, 0x51, 0x6a, 0xdd, 0x2b, 0xc2, 0xb6, 0x86, 0x03, 0x56, 0x74, 0x79, 0x7c, 0xb1, 0xce,
	0x5a, 0xc3, 0x01, 0xad, 0xb5, 0x3c, 0xf9, 0x2e, 0xe4, 0xce, 0x5f, 0xe0, 0xb0, 0xa0, 0x9c, 0x61,
	0xfc, 0xf3, 0x17, 0x2a, 0x2b, 0x1e, 0x49, 0xa5, 0x31, 0x4f, 0xe6, 0x35, 0xdd, 0x20, 0x31, 0xa5,
	0xff, 0x2a, 0xdc, 0x8c, 0x6f, 0xa8, 0x92, 0x47, 0x7e, 0x6f, 0xb1, 0xa7, 0x5a, 0x16, 0xf7, 0x54,
	0x61, 0xde, 0xbc, 0x07, 0x79, 0xd3, 0x72, 0xe8, 0x37, 0x50, 0x74, 0x50, 0xfc, 0x7b, 0x59, 0xd3,
	0x72, 0x54, 0xd7, 0x76, 0x6a, 0xdd, 0xab, 0xe2, 0xdf, 0x4e, 0xc1, 0xbc, 0x36, 0xd0, 0x5d, 0x3f,
	0xda, 0x4a, 0x7d, 0x05, 0x6b, 0x61, 0x23, 0xb2, 0x95, 0xe4, 0xfb, 0xc4, 0x2b, 0x7c, 0x6e, 0x73,
	0x37, 0x15, 0xd0, 0x0a, 0x17, 0xd1, 0xd0, 0x3b, 0x6c, 0xcb, 0x78, 0x75, 0x68, 0x7b, 0xbe, 0xfc,
	0x05, 0xdc, 0x1a, 0xdf, 0x34, 0xf8, 0xd2, 0xb3, 0x80, 0x96, 0x47, 0x5a, 0x36, 0x0d, 0xbf, 0xf8,
	0x77, 0x52, 0x20, 0x55, 0xe2, 0x15, 0x3b, 0x96, 0xbf, 0x16, 0x14, 0xb1, 0x74, 0x9f, 0x99, 0x1e,
	0xf3, 0xc2, 0x9e, 0x2b, 0x72, 0x83, 0x8b, 0x6b, 0xea, 0x3e, 0x75, 0x04, 0x17, 0x22, 0x7f, 0x03,
	0x0b, 0xac, 0xc6, 0xf4, 0xce, 0x4d, 0x47, 0xac, 0x7c, 0x96, 0xa3, 0x8d, 0x48, 0xe4, 0x0a, 0x34,
	0x1f, 0x81, 0xe9, 0x6e, 0xe1, 0xbf, 0xa7, 0x60, 0x91, 0x40, 0xe2, 0x51, 0x46, 0xb7, 0xce, 0x66,
	0x27, 0x19, 0x63, 0x39, 0x42, 0x0c, 0x22, 0xec, 0x3e, 0x48, 0xd1, 0x56, 0x4f, 0x58, 0xfc, 0x0a,
	0x68, 0x9e, 0xc7, 0x52, 0x70, 0x56, 0xfe, 0x07, 0xb0, 0xe0, 0x11, 0xcb, 0x0b, 0x4b, 0xcc, 0xb4,
	0xa8, 0x62, 0xdc, 0x2d, 0xa8, 0xe0, 0x89, 0xef, 0x72, 0x79, 0xdc, 0x5e, 0x2b, 0x2d, 0xd6, 0x50,
	0x49, 0x7b, 0x8e, 0xee, 0x89, 0xf6, 0x40, 0x26, 0xc9, 0xa3, 0x17, 0x1f, 0xe5, 0x3d, 0xc8, 0x93,
	0x1c, 0x96, 0x18, 0x24, 0x74, 0x9c, 0x21, 0x1f, 0x63, 0xf1, 0x4f, 0x52, 0xb0, 0xc2, 0xf3, 0x5e,
	0xa2, 0xed, 0xc7, 0xb0, 0x40, 0x5c, 0x36, 0xd0, 0x99, 0xc7, 0x48, 0xcc, 0xb1, 0xe6, 0x24, 0x0e,
	0x1b, 0x3a, 0x71, 0x13, 0x99, 0x4b, 0x02, 0xcc, 0xb7, 0xfa, 0x42, 0x68, 0x72, 0x58, 0xdb, 0xea,
	0x13, 0x58, 0x11, 0x0a, 0x3c, 0xb1, 0xbb, 0x2f, 0x84, 0x49, 0x99, 0x63, 0x44, 0xf4, 0x82, 0x04,
	0xf0, 0x67, 0xb0, 0x10, 0xe6, 0x9b, 0x1e, 0x53, 0x62, 0x15, 0xe6, 0xb8, 0xa6, 0xc1, 0x79, 0x4d,
	0xa0, 0xf8, 0xff, 0x9d, 0x06, 0x29, 0x4a, 0x2d, 0x6f, 0x79, 0x99, 0xfa, 0x8e, 0x6b, 0x9a, 0xcf,
	0x21, 0xfb, 0xdd, 0x37, 0xaa, 0x99, 0xf0, 0x42, 0xf5, 0x36, 0x85, 0xc7, 0xee, 0x53, 0x33, 0xe1,
	0xb5, 0xcb, 0xd7, 0x90, 0x13, 0x6b, 0x84, 0x19, 0x51, 0xb1, 0x31, 0xe9, 0x12, 0xf1, 0x44, 0x47,
	0x03, 0x69, 0x47, 0x3c, 0x38, 0x98, 0x15, 0xef, 0x03, 0x46, 0x26, 0x80, 0xb0, 0xd7, 0x7f, 0x04,
	0x99, 0x70, 0xa1, 0x9b, 0x13, 0xb7, 0x14, 0xa3, 0x01, 0x85, 0xe6, 0x3a, 0x7c, 0x85, 0xfa, 0x03,
	0xc8, 0x8d, 0x2e, 0xd4, 0xb7, 0x59, 0xbb, 0xb1, 0xf1, 0x84, 0xc0, 0x8f, 0x96, 0xd7, 0x9f, 0xc1,
	0x7c, 0x62, 0x6d, 0xcb, 0x8a, 0x6b, 0x5b, 0x22, 0x0a, 0x50, 0x5e, 0x1f, 0x5d, 0x86, 0xfe, 0x34,
	0x05, 0xb2, 0xb0, 0x0e, 0xbd, 0xe3, 0x7b, 0xda, 0xcd, 0xc4, 0x3d, 0xed, 0x8d, 0xe4, 0x5a, 0x16,
	0xbf, 0xad, 0x2d, 0x36, 0x60, 0x65, 0x44, 0x99, 0x37, 0xdf, 0x7b, 0x8c, 0xea, 0x2e, 0xdc, 0x7b,
	0x9c, 0xc3, 0xcd, 0x90, 0x9f, 0xb8, 0x52, 0x6a, 0x8c, 0xbf, 0x52, 0xfa, 0x81, 0xa1, 0x5b, 0x3c,
	0x86, 0xb5, 0xf1, 0x3d, 0x51, 0xed, 0xbf, 0x48, 0xae, 0xe9, 0x77, 0x12, 0xdd, 0x4c, 0xba, 0x64,
	0xd2, 0x61, 0x75, 0x04, 0xf3, 0x8e, 0xaf, 0x9a, 0x9e, 0xc2, 0xed, 0x09, 0x5d, 0x50, 0xd5, 0xbf,
	0x86, 0x0c, 0x8a, 0x1b, 0xfe, 0xee, 0x04, 0xdd, 0x43, 0xf3, 0x07, 0x8f, 0xc5, 0x7f, 0x91, 0x82,
	0x85, 0x98, 0xab, 0x3d, 0x2c, 0x7f, 0x04, 0xf3, 0xa4, 0x66, 0xf0, 0xaf, 0x30, 0xfb, 0xf2, 0xc5,
	0xe3, 0xdf, 0x0b, 0xe6, 0xad, 0xe1, 0xa0, 0x7d, 0xa5, 0x32, 0x1a, 0x49, 0xb8, 0x1c, 0x45, 0x8f,
	0xfc, 0xf9, 0xef, 0x4c, 0x80, 0x62, 0xe8, 0x59, 0x7f, 0x20, 0xc7, 0x8d, 0xe4, 0x4c, 0x87, 0x72,
	0x50, 0x52, 0x8e, 0x1b, 0xc8, 0x49, 0x87, 0x72, 0x10, 0x93, 0x53, 0x34, 0x84, 0x32, 0x8c, 0x5d,
	0xae, 0xff, 0x28, 0xf1, 0xd1, 0x12, 0x22, 0x31, 0xea, 0x86, 0x87, 0x76, 0x22, 0x38, 0xd6, 0x12,
	0x7d, 0x08, 0x6a, 0x45, 0x91, 0xf1, 0x3f, 0x52, 0xc2, 0x54, 0xe1, 0xf7, 0xdf, 0xef, 0xf8, 0x13,
	0x8b, 0xb4, 0xe7, 0x18, 0x9d, 0x78, 0x8d, 0x90, 0x28, 0x42, 0x29, 0x42, 0x98, 0xe4, 0xd3, 0xdf,
	0x67, 0x92, 0xcb, 0x9f, 0xc1, 0x0c, 0x79, 0xf2, 0xf8, 0xda, 0xbc, 0x32, 0x06, 0xee, 0x61, 0xc4,
	0x30, 0xc5, 0xbf, 0x95, 0x12, 0xa6, 0x80, 0x30, 0x4e, 0x5e, 0x2b, 0x7f, 0xf7, 0x50, 0xc5, 0x31,
	0x7d, 0x21, 0x64, 0x91, 0x29, 0x31, 0xd5, 0x8e, 0xb5, 0xa4, 0x90, 0x48, 0xfe, 0x6b, 0x4a, 0xf0,
	0x5f, 0x58, 0x7c, 0xb2, 0x03, 0x80, 0x1f, 0xbf, 0x66, 0x6d, 0x40, 0xe1, 0x2d, 0xcf, 0x29, 0x93,
	0x72, 0x73, 0xc2, 0x29, 0x47, 0xf1, 0x14, 0xee, 0x8c, 0x8e, 0xe5, 0xad, 0xd2, 0x55, 0xdc, 0x02,
	0x51, 0x50, 0x76, 0x85, 0x5c, 0x22, 0x48, 0x7e, 0xc7, 0x19, 0x0b, 0xc3, 0xdd, 0xc9, 0xbd, 0xd0,
	0x01, 0x7c, 0x33, 0xb2, 0x5a, 0x7c, 0x30, 0x69, 0x04, 0x63, 0xbc, 0xbd, 0xf1, 0xaf, 0xe9, 0x2f,
	0xe6, 0x54, 0xd7, 0xf6, 0xed, 0x8e, 0xdd, 0x97, 0x25, 0xc8, 0xd7, 0x54, 0x15, 0xb5, 0xda, 0x2d,
	0xdc, 0x6c, 0x35, 0x15, 0xe9, 0x3d, 0x91, 0x52, 0xab, 0x34, 0x54, 0x29, 0x15, 0xa3, 0xa8, 0x27,
	0x3b, 0x52, 0x5a, 0x5e, 0x80, 0x5c, 0x40, 0x69, 0x57, 0x54, 0x69, 0x56, 0x24, 0x1c, 0x57, 0x55,
	0x69, 0x51, 0x24, 0x1c, 0x20, 0x45, 0x7a, 0x20, 0x12, 0x14, 0x4d, 0x95, 0xb6, 0xe5, 0x79, 0xaa,
	0x07, 0x25, 0x94, 0x0e, 0xa5, 0x47, 0xb2, 0x0c, 0xf3, 0x62, 0xbf, 0x27, 0x7b, 0xd2, 0xd7, 0x1b,
	0xdf, 0x40, 0x8e, 0x3c, 0x37, 0xbc, 0x33, 0x7a, 0xb0, 0x73, 0x03, 0x64, 0xf2, 0x8a, 0x1b, 0xda,
	0x01, 0xdb, 0x88, 0x72, 0x95, 0x47, 0xe8, 0x4a, 0xe5, 0xb0, 0x25, 0xa5, 0x36, 0xfe, 0x7c, 0x1e,
	0xb2, 0xa1, 0xf1, 0xe5, 0x45, 0x28, 0x94, 0xd4, 0x1a, 0xd6, 0xda, 0xa5, 0xf6, 0xb1, 0x86, 0x5b,
	0x8f, 0xa5, 0xf7, 0x48, 0x9f, 0x02, 0x49, 0x41, 0x48, 0x4a, 0xc9, 0x6b, 0x70, 0x43, 0xa0, 0xd5,
	0x9a, 0x27, 0xa5, 0x7a, 0xad, 0x8a, 0x4b, 0xe8, 0x40, 0x9a, 0x92, 0xef, 0xc0, 0x2d, 0x11, 0x7f,
	0x5a, 0xd3, 0xda, 0x1a, 0x2e, 0xd5, 0x91, 0x52, 0xaa, 0x3e, 0x95, 0xa6, 0xe5, 0x5b, 0xb0, 0x22,
	0xf6, 0x70, 0xdc, 0xc6, 0xad, 0x7d, 0xdc, 0x50, 0x1a, 0x52, 0x5a, 0x5e, 0x85, 0x65, 0x81, 0xd5,
	0x6c, 0xb5, 0xf1, 0x7e, 0xeb, 0xb8, 0x59, 0x95, 0x66, 0xe4, 0xbb, 0xb0, 0x36, 0xda, 0x08, 0x29,
	0x5a, 0xeb, 0x18, 0x55, 0x14, 0x69, 0x56, 0x7e, 0x1f, 0x56, 0xc5, 0x3e, 0xe9, 0x49, 0x26, 0xd7,
	0x4a, 0x9a, 0x4b, 0x68, 0x74, 0x82, 0xf6, 0x71, 0xad, 0x1a, 0xb2, 0x33, 0xf2, 0x47, 0x70, 0x4f,
	0x60, 0xd7, 0xb7, 0xb1, 0xa6, 0x1c, 0x34, 0x94, 0x66, 0x5b, 0x44, 0x65, 0xe5, 0x0f, 0x61, 0x3d,
	0x36, 0xe4, 0xb6, 0x82, 0xf6, 0x4b, 0x15, 0x45, 0x04, 0x41, 0x42, 0xcf, 0xe0, 0x28, 0x20, 0xe0,
	0xe7, 0x46, 0xf9, 0xb5, 0xe6, 0x7e, 0x2b, 0xe4, 0xe7, 0x93, 0x9d, 0xec, 0xe3, 0xfa, 0x76, 0xa8,
	0x0c, 0x07, 0x15, 0x46, 0x41, 0xf4, 0xae, 0x27, 0x26, 0x69, 0x7e, 0x02, 0x28, 0xa6, 0xce, 0x82,
	0xfc, 0x09, 0x14, 0x13, 0xdd, 0x05, 0x2a, 0x11, 0xe3, 0x07, 0x38, 0x49, 0xfe, 0x14, 0x3e, 0x1c,
	0xc1, 0x1d, 0x8d, 0x02, 0x17, 0xe5, 0x75, 0xb8, 0x2d, 0x00, 0xf7, 0xeb, 0xad, 0x27, 0xf8, 0xb1,
	0xf2, 0x34, 0x04, 0xc8, 0xf2, 0x3d, 0x78, 0x3f, 0x09, 0x88, 0x29, 0xbe, 0x94, 0x70, 0xd6, 0x61,
	0xa9, 0x59, 0xad, 0x47, 0x2a, 0x2f, 0x27, 0x22, 0xef, 0xf0, 0x09, 0x56, 0x51, 0xeb, 0x80, 0x46,
	0xe5, 0x4a, 0xa2, 0x29, 0x1d, 0x4b, 0xe4, 0x9c, 0x1b, 0x89, 0x51, 0x34, 0x9f, 0x68, 0x4a, 0x85,
	0xb4, 0xde, 0xaf, 0xd5, 0x63, 0x5e, 0xbc, 0x99, 0x50, 0xb2, 0x5d, 0xd7, 0x70, 0xa5, 0x2c, 0x22,
	0x56, 0x93, 0x88, 0x8a, 0x9a, 0x40, 0xdc, 0x4a, 0xe8, 0x52, 0xaa, 0xd4, 0x45, 0xf6, 0x5a, 0xc2,
	0x50, 0x4f, 0x50, 0xad, 0x79, 0x20, 0x02, 0x6e, 0xcb, 0x1f, 0xc0, 0x9d, 0x11, 0x40, 0xcc, 0x7b,
	0xef, 0x27, 0x20, 0x2a, 0x6a, 0x9d, 0x3e, 0x8d, 0x43, 0xee, 0xc8, 0x45, 0xb8, 0x2b, 0x3a, 0x4e,
	0x25, 0x43, 0x8e, 0x6b, 0x7a, 0x37, 0xa1, 0x4a, 0x7d, 0xa7, 0x5e, 0x8e, 0xf9, 0x6c, 0x3d, 0x31,
	0xd8, 0x8a, 0x7a, 0x9c, 0x10, 0x71, 0x2f, 0x81, 0x60, 0x9a, 0x90, 0xc0, 0x50, 0x9a, 0xa5, 0x72,
	0x5d, 0xa9, 0x4a, 0x1f, 0x24, 0x66, 0x7d, 0x65, 0xff, 0x00, 0x57, 0xcb, 0xd4, 0x6b, 0x45, 0xf9,
	0x3e, 0x7c, 0x24, 0xb0, 0x34, 0xa5, 0x72, 0x8c, 0x6a, 0xed, 0xa7, 0xf8, 0x00, 0xb5, 0x8e, 0x55,
	0xb1, 0x9b, 0x0f, 0xe5, 0x9f, 0xc0, 0xc7, 0xe3, 0x90, 0x6a, 0xab, 0x5e, 0xab, 0x3c, 0x15, 0xa1,
	0x1f, 0xc9, 0x9f, 0xc1, 0xa7, 0xb1, 0x84, 0x50, 0x55, 0x5b, 0xb5, 0x66, 0x1b, 0x1f, 0xab, 0x55,
	0x3a, 0xb8, 0xc3, 0x6a, 0x3d, 0x04, 0x7f, 0x9c, 0x48, 0x00, 0xd5, 0x96, 0x36, 0x46, 0xe4, 0x27,
	0x09, 0x73, 0xa3, 0xd2, 0x13, 0x94, 0xb0, 0xc3, 0xa7, 0x89, 0x34, 0xd4, 0x2a, 0xff, 0x42, 0xa9,
	0x90, 0xd9, 0x81, 0x8f, 0x35, 0x45, 0xba, 0x3f, 0x2a, 0x20, 0xe9, 0x8b, 0x9f, 0x24, 0xf2, 0x83,
	0xda, 0x42, 0xb1, 0x24, 0xb4, 0x91, 0x34, 0x34, 0xe1, 0xc7, 0x3c, 0xfe, 0x59, 0x32, 0x28, 0x08,
	0x42, 0x53, 0x15, 0x25, 0x12, 0xf2, 0x53, 0xf9, 0x63, 0xf8, 0x20, 0x09, 0x69, 0x1e, 0x37, 0x70,
	0xbd, 0xd4, 0x54, 0xc2, 0x5c, 0x2e, 0x7d, 0x9e, 0x88, 0x9d, 0x46, 0x05, 0x2b, 0xcd, 0x36, 0x8a,
	0xd9, 0x64, 0x33, 0x91, 0x65, 0xa8, 0xe3, 0x93, 0x56, 0x79, 0x30, 0x0e, 0x94, 0x1c, 0xf9, 0xc3,
	0x84, 0xe9, 0x0e, 0x9f, 0x60, 0xb2, 0x5e, 0x90, 0x08, 0x69, 0x21, 0x69, 0x2b, 0x99, 0x14, 0x9e,
	0x90, 0x09, 0xd1, 0x56, 0x38, 0x7b, 0x3b, 0x91, 0xc7, 0x84, 0x0c, 0x1e, 0x33, 0xce, 0xa3, 0x84,
	0x26, 0xcd, 0x52, 0x1b, 0xab, 0xad, 0x56, 0x3d, 0x16, 0xee, 0x3b, 0x09, 0x61, 0x04, 0xd4, 0x28,
	0xa9, 0x2a, 0x99, 0x7f, 0x22, 0x6e, 0x77, 0xe3, 0x00, 0xe6, 0x4e, 0x5c, 0x76, 0x99, 0xb2, 0x08,
	0x05, 0xb2, 0xaa, 0x88, 0xcb, 0xad, 0x0c, 0xf3, 0x21, 0xa9, 0xd6, 0xdc, 0x47, 0x25, 0x29, 0x25,
	0xaf, 0xc0, 0x62, 0x48, 0xab, 0x1c, 0x6b, 0xed, 0x56, 0x43, 0x41, 0xd2, 0xd4, 0xc6, 0x2f, 0xa1,
	0x10, 0x56, 0x23, 0x54, 0xdc, 0x2a, 0x2c, 0x27, 0xc7, 0x10, 0x2d, 0xe2, 0x02, 0x47, 0x45, 0xb5,
	0x46, 0x09, 0x3d, 0x95, 0x52, 0xf2, 0x4d, 0x58, 0x12, 0xd7, 0x2d, 0xad, 0x55, 0x2f, 0xb5, 0x95,
	0xaa, 0x34, 0xb5, 0xf1, 0xf7, 0xe8, 0x37, 0x10, 0xc1, 0xbd, 0xe7, 0x12, 0x2c, 0x08, 0xb7, 0x7c,
	0x5c, 0xe6, 0x32, 0x48, 0x02, 0xb1, 0xda, 0x6a, 0x6f, 0x1d, 0x49, 0xa9, 0x04, 0x95, 0xde, 0x53,
	0x4a, 0x53, 0xa4, 0x1f, 0x81, 0x5a, 0x23, 0x8b, 0x2c, 0xae, 0xa9, 0xd2, 0x34, 0x19, 0x6e, 0xfc,
	0xfe, 0x50, 0x4a, 0x27, 0x44, 0xd0, 0xe4, 0x23, 0xcd, 0x6c, 0x94, 0x61, 0x21, 0xf1, 0x5f, 0x03,
	0xac, 0xca, 0xc1, 0xa5, 0xfd, 0x40, 0xa3, 0xf0, 0xbd, 0xd6, 0x54, 0xda, 0x52, 0x8a, 0x95, 0x45,
	0xc1, 0xfb, 0x9e, 0x34, 0xb5, 0xf1, 0xdf, 0x52, 0xc2, 0xcf, 0xc4, 0x83, 0x91, 0x11, 0x48, 0xb5,
	0x8a, 0x14, 0x4d, 0x0b, 0xe4, 0xdc, 0x84, 0x25, 0x81, 0x48, 0xca, 0x32, 0x5c, 0x6a, 0x72, 0x73,
	0xc5, 0x19, 0x7b, 0x94, 0x31, 0xc5, 0xea, 0xab, 0x90, 0x41, 0x68, 0xd3, 0x24, 0xf6, 0x92, 0x52,
	0x1a, 0xc7, 0xf5, 0x76, 0xad, 0x52, 0xd2, 0xda, 0x52, 0x7a, 0x94, 0xbd, 0x27, 0xb0, 0x67, 0x88,
	0x2f, 0x05, 0x76, 0xc4, 0xa1, 0x35, 0x8b, 0xc0, 0x39, 0xd9, 0xc3, 0xf4, 0x42, 0xa7, 0xde, 0xaa,
	0x94, 0xea, 0xd2, 0xdc, 0xc6, 0x9f, 0x66, 0x20, 0xfb, 0x04, 0x99, 0xd6, 0x59, 0x30, 0x3c, 0x61,
	0x09, 0xe0, 0xc3, 0x8b, 0x13, 0x35, 0x05, 0x11, 0xbf, 0xdd, 0x00, 0x59, 0x44, 0x36, 0xaa, 0x08,
	0xb7, 0x4f, 0xa5, 0xa9, 0x71, 0x74, 0x74, 0x2a, 0x4d, 0x13, 0x2d, 0x62, 0x74, 0x15, 0x61, 0xad,
	0x51, 0xaa, 0xd7, 0x49, 0xab, 0xf4, 0x64, 0x2e, 0x3a, 0x95, 0x66, 0xc8, 0x5a, 0x9c, 0xe4, 0x96,
	0x6b, 0x07, 0xa4, 0xe5, 0xec, 0x24, 0x1e, 0x3a, 0x95, 0xe6, 0x88, 0x95, 0x05, 0x5e, 0x59, 0x3b,
	0x92, 0x32, 0x49, 0x1a, 0x3a, 0x92, 0xb2, 0x23, 0x03, 0xd4, 0x8e, 0x24, 0x20, 0xbe, 0x13, 0x57,
	0x43, 0x12, 0x55, 0x95, 0xf2, 0x91, 0x94, 0x23, 0xe1, 0x26, 0x30, 0x4a, 0xe8, 0x08, 0x9d, 0x4a,
	0xf9, 0x84, 0xdc, 0x92, 0x76, 0x24, 0x15, 0x92, 0x48, 0x2a, 0x78, 0x9e, 0xcc, 0x4e, 0x81, 0x4a,
	0xf2, 0x7b, 0xa5, 0x2c, 0x2d, 0x10, 0xff, 0x8e, 0xe9, 0x0f, 0x97, 0x4b, 0xa8, 0xd2, 0x92, 0xa4,
	0x04, 0x3b, 0xbc, 0xf4, 0xa1, 0xe9, 0x9d, 0x15, 0x44, 0x63, 0xd9, 0x2c, 0x55, 0x4a, 0xf2, 0x9b,
	0x01, 0x15, 0x69, 0x89, 0xac, 0x9c, 0xa3, 0x8e, 0xc3, 0x07, 0x15, 0x69, 0x79, 0x1c, 0xab, 0x4d,
	0x59, 0x2b, 0xa3, 0xc6, 0x68, 0x9f, 0x4a, 0x37, 0x12, 0x06, 0x2d, 0x69, 0x95, 0x23, 0xe9, 0x66,
	0x02, 0x5a, 0x51, 0x8f, 0xab, 0x48, 0x5a, 0x1d, 0xa5, 0xaa, 0x48, 0xba, 0x95, 0x88, 0x07, 0x56,
	0x4f, 0x04, 0x31, 0xb6, 0x36, 0x99, 0x8b, 0x4e, 0xa5, 0xdb, 0x13, 0xb8, 0x2a, 0x6d, 0xfb, 0xfe,
	0x64, 0x2e, 0x3a, 0x95, 0xee, 0x90, 0x75, 0x6f, 0x84, 0x4b, 0xc2, 0x29, 0xe8, 0xfb, 0xee, 0x9b,
	0x11, 0xe8, 0x94, 0x95, 0x31, 0x13, 0x10, 0x4c, 0x87, 0x7b, 0x6f, 0x46, 0xa0, 0x53, 0xe9, 0x83,
	0x84, 0xb7, 0x9b, 0x8d, 0xaa, 0x38, 0x5d, 0x8a, 0x6f, 0x60, 0xa3, 0x53, 0xe9, 0x43, 0xf9, 0x36,
	0xdc, 0x1c, 0x61, 0xf3, 0x09, 0xf3, 0xd1, 0x44, 0x26, 0x3a, 0x95, 0x3e, 0xde, 0xf8, 0xf3, 0x29,
	0xc8, 0xaa, 0xae, 0x7d, 0x75, 0x1d, 0x64, 0x03, 0xa1, 0xda, 0x8b, 0x16, 0x1c, 0x81, 0x48, 0x76,
	0x9c, 0xa9, 0x24, 0xad, 0xae, 0x49, 0x53, 0xc4, 0xb1, 0x62, 0xa9, 0x48, 0xb3, 0xf2, 0x34, 0x59,
	0xc1, 0x04, 0xea, 0x41, 0x45, 0x4a, 0x27, 0x1a, 0x57, 0xd4, 0x63, 0x69, 0x66, 0xa4, 0xf1, 0x7e,
	0x8d, 0xcc, 0xf5, 0x55, 0x58, 0x16, 0xa8, 0x61, 0x0c, 0x4b, 0x73, 0x09, 0x4d, 0xd5, 0x1d, 0xb5,
	0x2d, 0x65, 0x48, 0x61, 0x31, 0x0e, 0x1e, 0x54, 0xb0, 0x15, 0x55, 0xca, 0x12, 0x4b, 0x8e, 0xc5,
	0x68, 0x6a, 0xa9, 0x29, 0x01, 0x29, 0xe5, 0xdf, 0x2c, 0x82, 0x01, 0x73, 0x1b, 0x47, 0xb0, 0x58,
	0x71, 0xaf, 0x1d, 0xdf, 0x2e, 0x79, 0xd7, 0x83, 0xc7, 0x06, 0xb3, 0xdf, 0x5d, 0x58, 0xab, 0xa0,
	0xa7, 0x2a, 0xd9, 0x54, 0x6b, 0x4f, 0x1b, 0x74, 0x59, 0xe7, 0x3b, 0xe2, 0xaa, 0x56, 0x92, 0xde,
	0x23, 0xb1, 0x38, 0x96, 0x8f, 0xb4, 0x92, 0x94, 0xda, 0xf8, 0x8b, 0x14, 0x14, 0x98, 0xcc, 0x40,
	0xde, 0x1a, 0xdc, 0xe0, 0xf8, 0x10, 0x5a, 0x52, 0xb4, 0xad, 0xed, 0x2f, 0xa5, 0xf7, 0x26, 0xf1,
	0xbe, 0xda, 0x66, 0xbb, 0xe8, 0x31, 0xbc, 0xed, 0xdd, 0x3d, 0xb6, 0xd2, 0x26, 0x79, 0x55, 0x45,
	0x63, 0x09, 0x3b, 0xc9, 0xa8, 0x1c, 0x96, 0x2a, 0x87, 0xa5, 0xed, 0x87, 0x2c, 0x61, 0x27, 0xb9,
	0x6a, 0xab, 0xfe, 0x74, 0xeb, 0xd1, 0xc3, 0x5d, 0xb6, 0x18, 0x25, 0xb9, 0x87, 0x8d, 0x52, 0x45,
	0x9a, 0xdd, 0xf8, 0xdd, 0x14, 0x40, 0x59, 0x77, 0x3b, 0x36, 0x59, 0x72, 0x3c, 0xe2, 0x37, 0x9a,
	0xe0, 0x30, 0x8d, 0x48, 0x62, 0x05, 0xb6, 0xde, 0x08, 0xc4, 0x83, 0x4a, 0xe3, 0xa1, 0x94, 0x1a,
	0x25, 0x6e, 0x49, 0x53, 0x09, 0xe2, 0x69, 0x5b, 0x7b, 0x28, 0x4d, 0x8f, 0x12, 0xb7, 0xa4, 0x74,
	0x82, 0xd8, 0x50, 0xd5, 0x87, 0xd2, 0xcc, 0x28, 0x71, 0x4b, 0x9a, 0x1d, 0x25, 0x6e, 0xb3, 0xf8,
	0x8a, 0x13, 0x1f, 0x49, 0x99, 0x51, 0xe2, 0x0e, 0x5b, 0x4b, 0xe2, 0xc4, 0x5d, 0x09, 0x46, 0x89,
	0x7b, 0x52, 0x6e, 0x94, 0xf8, 0x85, 0x94, 0x27, 0xf3, 0x43, 0x20, 0x56, 0x54, 0xa9, 0x40, 0xd6,
	0x8b, 0x18, 0x09, 0x1f, 0xb6, 0xda, 0xd2, 0x7c, 0x02, 0x59, 0xad, 0x48, 0x0b, 0x09, 0x64, 0xb5,
	0x42, 0x91, 0xd2, 0xc6, 0xaf, 0x21, 0x1f, 0x5c, 0xd0, 0xd0, 0x30, 0xba, 0x09, 0x4b, 0x51, 0x24,
	0x8b, 0x53, 0xfb, 0x36, 0xdc, 0x4c, 0x30, 0xe8, 0xa3, 0x52, 0x69, 0xb3, 0x5a, 0x26, 0xc1, 0xa4,
	0xa1, 0x3f, 0xb5, 0xf1, 0x1f, 0x52, 0x30, 0x57, 0x71, 0x86, 0x9d, 0x67, 0xb5, 0x2e, 0xd1, 0xa0,
	0xa2, 0x1e, 0xb3, 0x9a, 0x9b, 0x6c, 0xba, 0x1b, 0x35, 0x4d, 0x63, 0xe5, 0x64, 0x48, 0xa6, 0x9b,
	0xd8, 0x7a, 0x4b, 0x53, 0x78, 0x60, 0x06, 0x74, 0xa4, 0xd4, 0x6b, 0x64, 0x17, 0x87, 0x2b, 0x2d,
	0x95, 0x94, 0x48, 0x22, 0xaf, 0x49, 0xf6, 0xb5, 0xa1, 0x2e, 0xd3, 0x24, 0x3d, 0x84, 0xbc, 0xa3,
	0xe3, 0x9a, 0xa2, 0x55, 0x48, 0x1d, 0x28, 0x76, 0x4e, 0x5b, 0xd4, 0x5b, 0x07, 0xd2, 0x4c, 0x5c,
	0xa7, 0x36, 0x57, 0x7b, 0x76, 0xe3, 0xb7, 0x53, 0xb0, 0xbc, 0xdf, 0x56, 0x34, 0x47, 0xb7, 0x1a,
	0xba, 0xdf, 0x39, 0xd7, 0x8c, 0xbe, 0xd1, 0xf1, 0x6d, 0x57, 0x2e, 0x40, 0x56, 0x43, 0x15, 0x5c,
	0x27, 0x1b, 0x16, 0xe9, 0x3d, 0xf2, 0x5a, 0xd5, 0xda, 0xfc, 0x95, 0xd6, 0x88, 0x55, 0xd4, 0x22,
	0x76, 0x28, 0x69, 0x2d, 0x52, 0xaa, 0x2e, 0x42, 0x81, 0x1e, 0x2f, 0xd4, 0x1f, 0x1f, 0xab, 0x98,
	0x64, 0x23, 0x5a, 0xa4, 0x46, 0x24, 0x62, 0x2a, 0x29, 0x1d, 0x87, 0x9d, 0xa0, 0x7d, 0x69, 0x26,
	0x4e, 0xd2, 0x50, 0x45, 0x9a, 0x4d, 0x08, 0xd3, 0xda, 0x2c, 0xf4, 0x22, 0x12, 0x3d, 0x92, 0x63,
	0xa1, 0x27, 0x34, 0xa5, 0xaa, 0x65, 0xe3, 0xc4, 0x2a, 0x25, 0x82, 0x9c, 0x87, 0x8c, 0xd2, 0x3e,
	0xc4, 0x55, 0x32, 0xfd, 0x72, 0xe4, 0x6d, 0x1f, 0xb5, 0x1a, 0x34, 0xcb, 0xe6, 0x37, 0xec, 0xe0,
	0x6f, 0x07, 0x68, 0x58, 0x2c, 0x40, 0x6e, 0xbf, 0x56, 0x6f, 0x2b, 0x48, 0x28, 0x8f, 0x39, 0xa1,
	0x5e, 0xdb, 0x67, 0x59, 0x3e, 0x7a, 0xc7, 0x44, 0x20, 0x9d, 0x81, 0x02, 0xed, 0x84, 0x54, 0xef,
	0xd3, 0x24, 0x54, 0xe2, 0x40, 0xc6, 0x48, 0x6f, 0xec, 0x03, 0x44, 0x17, 0xac, 0xb4, 0x08, 0xde,
	0x8f, 0x4e, 0xe1, 0xc2, 0x03, 0xcf, 0x90, 0x76, 0xcc, 0xd7, 0x96, 0x88, 0x52, 0x6d, 0x3d, 0x21,
	0x21, 0xf7, 0xbb, 0x29, 0xfa, 0x4b, 0x47, 0xf1, 0x0f, 0x00, 0x48, 0xbc, 0x90, 0xde, 0x8e, 0x8e,
	0x95, 0x63, 0x05, 0xab, 0xc7, 0x48, 0x6d, 0x69, 0x62, 0x60, 0x8f, 0xf2, 0x4a, 0xd5, 0x46, 0xad,
	0x29, 0xa5, 0xe8, 0x2e, 0x68, 0x84, 0x49, 0x6b, 0xd9, 0xb1, 0x1c, 0x5a, 0xcd, 0xae, 0xc3, 0xed,
	0x31, 0x9c, 0x6a, 0xa3, 0x84, 0x35, 0xa5, 0x59, 0x95, 0xd2, 0x6f, 0x00, 0x20, 0xa5, 0x72, 0xc2,
	0x52, 0xe4, 0x28, 0xa0, 0x72, 0xc4, 0x56, 0xb9, 0x51, 0x8e, 0x72, 0x24, 0xcd, 0x4d, 0x18, 0xe2,
	0x49, 0x43, 0x91, 0x32, 0x64, 0x21, 0x1b, 0xe5, 0x69, 0xed, 0x16, 0x2a, 0x1d, 0x28, 0x52, 0x76,
	0xbc, 0x3e, 0x27, 0x35, 0xd4, 0xae, 0xb5, 0xc8, 0x58, 0xe1, 0x8d, 0x00, 0x74, 0x2a, 0xe5, 0x36,
	0xfe, 0x61, 0x0a, 0x32, 0xc1, 0x37, 0x7f, 0xdc, 0x4d, 0x62, 0xee, 0x10, 0x28, 0x4a, 0xb3, 0x56,
	0x09, 0x1d, 0x27, 0x7c, 0x44, 0x26, 0x4d, 0x91, 0xb9, 0x38, 0xf2, 0x61, 0x19, 0x9b, 0x30, 0xf1,
	0xcf, 0xbb, 0xf8, 0xb1, 0xf6, 0xbe, 0x58, 0x13, 0x08, 0x6d, 0xa3, 0xa5, 0x7f, 0x76, 0xe3, 0x9f,
	0xa6, 0x20, 0x2f, 0xfe, 0xce, 0x80, 0xe3, 0xa2, 0x63, 0x48, 0xae, 0x60, 0x92, 0x7c, 0xac, 0x29,
	0x07, 0x6c, 0x1f, 0x13, 0x23, 0xab, 0x27, 0xe1, 0x0e, 0x34, 0x46, 0x0f, 0x73, 0x0f, 0xd9, 0x68,
	0x8d, 0xf9, 0xec, 0x9d, 0xed, 0x43, 0x63, 0x9c, 0x83, 0xfd, 0xb6, 0x34, 0xb3, 0xe1, 0xd2, 0x7f,
	0x0c, 0x49, 0x7e, 0x25, 0x4c, 0xb7, 0x73, 0xe3, 0x3e, 0x89, 0xe5, 0xda, 0xde, 0x85, 0xb5, 0xc9,
	0x1f, 0xf2, 0x4a, 0x29, 0xba, 0xa9, 0x9b, 0xf0, 0x45, 0xad, 0x34, 0xb5, 0xfd, 0x67, 0xb3, 0x90,
	0x0d, 0x6f, 0x20, 0xe4, 0x2f, 0xe9, 0x3f, 0x9a, 0x54, 0x5c, 0x43, 0xf7, 0x0d, 0x79, 0x49, 0xf8,
	0xf9, 0x6f, 0x70, 0x11, 0xb3, 0xb6, 0x3c, 0xf2, 0x9b, 0xe0, 0x86, 0x77, 0x56, 0x7c, 0x8f, 0xb7,
	0x3c, 0x76, 0xba, 0x6f, 0xdd, 0xb2, 0x4a, 0x5b, 0xb2, 0x1b, 0x5b, 0xf9, 0xd6, 0xf8, 0xdf, 0x38,
	0x92, 0xf6, 0x6b, 0x13, 0x7e, 0x54, 0xc8, 0xa4, 0x1c, 0xd0, 0x1f, 0x75, 0x87, 0xbf, 0xf5, 0x0c,
	0x04, 0x8d, 0xf9, 0xb9, 0x69, 0x20, 0x68, 0xdc, 0xef, 0x42, 0x8b, 0xef, 0xc9, 0xbf, 0x10, 0xee,
	0x87, 0xb9, 0x21, 0x6e, 0x8d, 0x5c, 0xeb, 0x27, 0x65, 0x8d, 0xfb, 0x40, 0x20, 0x21, 0x8b, 0x9b,
	0xe6, 0x07, 0xcb, 0x3a, 0x11, 0x64, 0x71, 0x63, 0xad, 0xbf, 0xe9, 0xc6, 0x9e, 0x48, 0xbc, 0xf7,
	0xc6, 0x6b, 0x71, 0x26, 0xb7, 0x41, 0xe7, 0x44, 0x78, 0xd3, 0x28, 0xbf, 0x3f, 0xf1, 0xa6, 0x97,
	0x48, 0xbc, 0x33, 0xf9, 0x6e, 0x92, 0x89, 0xd3, 0x61, 0xb9, 0xd4, 0xed, 0x86, 0x87, 0x47, 0x2d,
	0x8b, 0x7d, 0xd8, 0x22, 0x17, 0x27, 0x5f, 0x76, 0x85, 0xc2, 0x3f, 0xfc, 0xae, 0x0b, 0xb1, 0xb0,
	0x8b, 0xaa, 0xd1, 0xff, 0x31, 0xbb, 0x28, 0x67, 0x7f, 0x39, 0x77, 0x66, 0xd3, 0xff, 0xcb, 0x54,
	0xdf, 0x7b, 0x36, 0x4b, 0x1f, 0x1e, 0xfd, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70, 0x71, 0x0d,
	0xc4, 0x6b, 0x53, 0x00, 0x00,
}
