// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kh.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Filter Type
type FilterType int32

const (
	FilterType_FILTER_NONE         FilterType = 0
	FilterType_FILTER_LIF          FilterType = 1
	FilterType_FILTER_LIF_MAC      FilterType = 2
	FilterType_FILTER_LIF_VLAN     FilterType = 3
	FilterType_FILTER_LIF_MAC_VLAN FilterType = 4
)

var FilterType_name = map[int32]string{
	0: "FILTER_NONE",
	1: "FILTER_LIF",
	2: "FILTER_LIF_MAC",
	3: "FILTER_LIF_VLAN",
	4: "FILTER_LIF_MAC_VLAN",
}
var FilterType_value = map[string]int32{
	"FILTER_NONE":         0,
	"FILTER_LIF":          1,
	"FILTER_LIF_MAC":      2,
	"FILTER_LIF_VLAN":     3,
	"FILTER_LIF_MAC_VLAN": 4,
}

func (x FilterType) String() string {
	return proto.EnumName(FilterType_name, int32(x))
}
func (FilterType) EnumDescriptor() ([]byte, []int) { return fileDescriptor15, []int{0} }

// QosGroup identifier
type QosGroup int32

const (
	QosGroup_DEFAULT                   QosGroup = 0
	QosGroup_USER_DEFINED_1            QosGroup = 1
	QosGroup_USER_DEFINED_2            QosGroup = 2
	QosGroup_USER_DEFINED_3            QosGroup = 3
	QosGroup_USER_DEFINED_4            QosGroup = 4
	QosGroup_USER_DEFINED_5            QosGroup = 5
	QosGroup_USER_DEFINED_6            QosGroup = 6
	QosGroup_CONTROL                   QosGroup = 7
	QosGroup_SPAN                      QosGroup = 8
	QosGroup_INTERNAL_RX_PROXY_NO_DROP QosGroup = 9
	QosGroup_INTERNAL_RX_PROXY_DROP    QosGroup = 10
	QosGroup_INTERNAL_TX_PROXY_NO_DROP QosGroup = 11
	QosGroup_INTERNAL_TX_PROXY_DROP    QosGroup = 12
	QosGroup_INTERNAL_CPU_COPY         QosGroup = 13
)

var QosGroup_name = map[int32]string{
	0:  "DEFAULT",
	1:  "USER_DEFINED_1",
	2:  "USER_DEFINED_2",
	3:  "USER_DEFINED_3",
	4:  "USER_DEFINED_4",
	5:  "USER_DEFINED_5",
	6:  "USER_DEFINED_6",
	7:  "CONTROL",
	8:  "SPAN",
	9:  "INTERNAL_RX_PROXY_NO_DROP",
	10: "INTERNAL_RX_PROXY_DROP",
	11: "INTERNAL_TX_PROXY_NO_DROP",
	12: "INTERNAL_TX_PROXY_DROP",
	13: "INTERNAL_CPU_COPY",
}
var QosGroup_value = map[string]int32{
	"DEFAULT":                   0,
	"USER_DEFINED_1":            1,
	"USER_DEFINED_2":            2,
	"USER_DEFINED_3":            3,
	"USER_DEFINED_4":            4,
	"USER_DEFINED_5":            5,
	"USER_DEFINED_6":            6,
	"CONTROL":                   7,
	"SPAN":                      8,
	"INTERNAL_RX_PROXY_NO_DROP": 9,
	"INTERNAL_RX_PROXY_DROP":    10,
	"INTERNAL_TX_PROXY_NO_DROP": 11,
	"INTERNAL_TX_PROXY_DROP":    12,
	"INTERNAL_CPU_COPY":         13,
}

func (x QosGroup) String() string {
	return proto.EnumName(QosGroup_name, int32(x))
}
func (QosGroup) EnumDescriptor() ([]byte, []int) { return fileDescriptor15, []int{1} }

// CoppType identifies the type of traffic for the copp policy
type CoppType int32

const (
	CoppType_COPP_TYPE_FLOW_MISS CoppType = 0
	CoppType_COPP_TYPE_ARP       CoppType = 1
	CoppType_COPP_TYPE_DHCP      CoppType = 2
)

var CoppType_name = map[int32]string{
	0: "COPP_TYPE_FLOW_MISS",
	1: "COPP_TYPE_ARP",
	2: "COPP_TYPE_DHCP",
}
var CoppType_value = map[string]int32{
	"COPP_TYPE_FLOW_MISS": 0,
	"COPP_TYPE_ARP":       1,
	"COPP_TYPE_DHCP":      2,
}

func (x CoppType) String() string {
	return proto.EnumName(CoppType_name, int32(x))
}
func (CoppType) EnumDescriptor() ([]byte, []int) { return fileDescriptor15, []int{2} }

// SecurityProfileKeyHandle is used to operate on a security profile
// either by its id or HAL allocated handle
type SecurityProfileKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*SecurityProfileKeyHandle_ProfileId
	//	*SecurityProfileKeyHandle_ProfileHandle
	KeyOrHandle isSecurityProfileKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *SecurityProfileKeyHandle) Reset()                    { *m = SecurityProfileKeyHandle{} }
func (m *SecurityProfileKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileKeyHandle) ProtoMessage()               {}
func (*SecurityProfileKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{0} }

type isSecurityProfileKeyHandle_KeyOrHandle interface{ isSecurityProfileKeyHandle_KeyOrHandle() }

type SecurityProfileKeyHandle_ProfileId struct {
	ProfileId uint32 `protobuf:"varint,1,opt,name=profile_id,json=profileId,oneof"`
}
type SecurityProfileKeyHandle_ProfileHandle struct {
	ProfileHandle uint64 `protobuf:"fixed64,2,opt,name=profile_handle,json=profileHandle,oneof"`
}

func (*SecurityProfileKeyHandle_ProfileId) isSecurityProfileKeyHandle_KeyOrHandle()     {}
func (*SecurityProfileKeyHandle_ProfileHandle) isSecurityProfileKeyHandle_KeyOrHandle() {}

func (m *SecurityProfileKeyHandle) GetKeyOrHandle() isSecurityProfileKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityProfileKeyHandle) GetProfileId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*SecurityProfileKeyHandle_ProfileId); ok {
		return x.ProfileId
	}
	return 0
}

func (m *SecurityProfileKeyHandle) GetProfileHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*SecurityProfileKeyHandle_ProfileHandle); ok {
		return x.ProfileHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityProfileKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityProfileKeyHandle_OneofMarshaler, _SecurityProfileKeyHandle_OneofUnmarshaler, _SecurityProfileKeyHandle_OneofSizer, []interface{}{
		(*SecurityProfileKeyHandle_ProfileId)(nil),
		(*SecurityProfileKeyHandle_ProfileHandle)(nil),
	}
}

func _SecurityProfileKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *SecurityProfileKeyHandle_ProfileId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ProfileId))
	case *SecurityProfileKeyHandle_ProfileHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.ProfileHandle))
	case nil:
	default:
		return fmt.Errorf("SecurityProfileKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _SecurityProfileKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityProfileKeyHandle)
	switch tag {
	case 1: // key_or_handle.profile_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &SecurityProfileKeyHandle_ProfileId{uint32(x)}
		return true, err
	case 2: // key_or_handle.profile_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &SecurityProfileKeyHandle_ProfileHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityProfileKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *SecurityProfileKeyHandle_ProfileId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ProfileId))
	case *SecurityProfileKeyHandle_ProfileHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// CollectorKeyHandle is used to operate on a collector either by its key or handle
type CollectorKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*CollectorKeyHandle_CollectorId
	//	*CollectorKeyHandle_CollectorHandle
	KeyOrHandle isCollectorKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *CollectorKeyHandle) Reset()                    { *m = CollectorKeyHandle{} }
func (m *CollectorKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*CollectorKeyHandle) ProtoMessage()               {}
func (*CollectorKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{1} }

type isCollectorKeyHandle_KeyOrHandle interface{ isCollectorKeyHandle_KeyOrHandle() }

type CollectorKeyHandle_CollectorId struct {
	CollectorId uint64 `protobuf:"varint,1,opt,name=collector_id,json=collectorId,oneof"`
}
type CollectorKeyHandle_CollectorHandle struct {
	CollectorHandle uint64 `protobuf:"fixed64,2,opt,name=collector_handle,json=collectorHandle,oneof"`
}

func (*CollectorKeyHandle_CollectorId) isCollectorKeyHandle_KeyOrHandle()     {}
func (*CollectorKeyHandle_CollectorHandle) isCollectorKeyHandle_KeyOrHandle() {}

func (m *CollectorKeyHandle) GetKeyOrHandle() isCollectorKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CollectorKeyHandle) GetCollectorId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*CollectorKeyHandle_CollectorId); ok {
		return x.CollectorId
	}
	return 0
}

func (m *CollectorKeyHandle) GetCollectorHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*CollectorKeyHandle_CollectorHandle); ok {
		return x.CollectorHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CollectorKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CollectorKeyHandle_OneofMarshaler, _CollectorKeyHandle_OneofUnmarshaler, _CollectorKeyHandle_OneofSizer, []interface{}{
		(*CollectorKeyHandle_CollectorId)(nil),
		(*CollectorKeyHandle_CollectorHandle)(nil),
	}
}

func _CollectorKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CollectorKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CollectorKeyHandle_CollectorId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.CollectorId))
	case *CollectorKeyHandle_CollectorHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.CollectorHandle))
	case nil:
	default:
		return fmt.Errorf("CollectorKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _CollectorKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CollectorKeyHandle)
	switch tag {
	case 1: // key_or_handle.collector_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &CollectorKeyHandle_CollectorId{x}
		return true, err
	case 2: // key_or_handle.collector_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &CollectorKeyHandle_CollectorHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _CollectorKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CollectorKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CollectorKeyHandle_CollectorId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CollectorId))
	case *CollectorKeyHandle_CollectorHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ExportControlKeyHandle is used to operate on a Export Control object either by its key or handle
type ExportControlKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*ExportControlKeyHandle_ExportcontrolId
	//	*ExportControlKeyHandle_ExportcontrolHandle
	KeyOrHandle isExportControlKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *ExportControlKeyHandle) Reset()                    { *m = ExportControlKeyHandle{} }
func (m *ExportControlKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*ExportControlKeyHandle) ProtoMessage()               {}
func (*ExportControlKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{2} }

type isExportControlKeyHandle_KeyOrHandle interface{ isExportControlKeyHandle_KeyOrHandle() }

type ExportControlKeyHandle_ExportcontrolId struct {
	ExportcontrolId uint64 `protobuf:"varint,1,opt,name=exportcontrol_id,json=exportcontrolId,oneof"`
}
type ExportControlKeyHandle_ExportcontrolHandle struct {
	ExportcontrolHandle uint64 `protobuf:"fixed64,2,opt,name=exportcontrol_handle,json=exportcontrolHandle,oneof"`
}

func (*ExportControlKeyHandle_ExportcontrolId) isExportControlKeyHandle_KeyOrHandle()     {}
func (*ExportControlKeyHandle_ExportcontrolHandle) isExportControlKeyHandle_KeyOrHandle() {}

func (m *ExportControlKeyHandle) GetKeyOrHandle() isExportControlKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *ExportControlKeyHandle) GetExportcontrolId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*ExportControlKeyHandle_ExportcontrolId); ok {
		return x.ExportcontrolId
	}
	return 0
}

func (m *ExportControlKeyHandle) GetExportcontrolHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*ExportControlKeyHandle_ExportcontrolHandle); ok {
		return x.ExportcontrolHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ExportControlKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ExportControlKeyHandle_OneofMarshaler, _ExportControlKeyHandle_OneofUnmarshaler, _ExportControlKeyHandle_OneofSizer, []interface{}{
		(*ExportControlKeyHandle_ExportcontrolId)(nil),
		(*ExportControlKeyHandle_ExportcontrolHandle)(nil),
	}
}

func _ExportControlKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ExportControlKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *ExportControlKeyHandle_ExportcontrolId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ExportcontrolId))
	case *ExportControlKeyHandle_ExportcontrolHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.ExportcontrolHandle))
	case nil:
	default:
		return fmt.Errorf("ExportControlKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _ExportControlKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ExportControlKeyHandle)
	switch tag {
	case 1: // key_or_handle.exportcontrol_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &ExportControlKeyHandle_ExportcontrolId{x}
		return true, err
	case 2: // key_or_handle.exportcontrol_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &ExportControlKeyHandle_ExportcontrolHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _ExportControlKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ExportControlKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *ExportControlKeyHandle_ExportcontrolId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ExportcontrolId))
	case *ExportControlKeyHandle_ExportcontrolHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowMonitorRuleKeyHandle is used to operate on a FlowMonitorRule object either by its key or handle
type FlowMonitorRuleKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*FlowMonitorRuleKeyHandle_FlowmonitorruleId
	//	*FlowMonitorRuleKeyHandle_FlowmonitorruleHandle
	KeyOrHandle isFlowMonitorRuleKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *FlowMonitorRuleKeyHandle) Reset()                    { *m = FlowMonitorRuleKeyHandle{} }
func (m *FlowMonitorRuleKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleKeyHandle) ProtoMessage()               {}
func (*FlowMonitorRuleKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{3} }

type isFlowMonitorRuleKeyHandle_KeyOrHandle interface{ isFlowMonitorRuleKeyHandle_KeyOrHandle() }

type FlowMonitorRuleKeyHandle_FlowmonitorruleId struct {
	FlowmonitorruleId uint64 `protobuf:"varint,1,opt,name=flowmonitorrule_id,json=flowmonitorruleId,oneof"`
}
type FlowMonitorRuleKeyHandle_FlowmonitorruleHandle struct {
	FlowmonitorruleHandle uint64 `protobuf:"fixed64,2,opt,name=flowmonitorrule_handle,json=flowmonitorruleHandle,oneof"`
}

func (*FlowMonitorRuleKeyHandle_FlowmonitorruleId) isFlowMonitorRuleKeyHandle_KeyOrHandle()     {}
func (*FlowMonitorRuleKeyHandle_FlowmonitorruleHandle) isFlowMonitorRuleKeyHandle_KeyOrHandle() {}

func (m *FlowMonitorRuleKeyHandle) GetKeyOrHandle() isFlowMonitorRuleKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *FlowMonitorRuleKeyHandle) GetFlowmonitorruleId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*FlowMonitorRuleKeyHandle_FlowmonitorruleId); ok {
		return x.FlowmonitorruleId
	}
	return 0
}

func (m *FlowMonitorRuleKeyHandle) GetFlowmonitorruleHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*FlowMonitorRuleKeyHandle_FlowmonitorruleHandle); ok {
		return x.FlowmonitorruleHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowMonitorRuleKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowMonitorRuleKeyHandle_OneofMarshaler, _FlowMonitorRuleKeyHandle_OneofUnmarshaler, _FlowMonitorRuleKeyHandle_OneofSizer, []interface{}{
		(*FlowMonitorRuleKeyHandle_FlowmonitorruleId)(nil),
		(*FlowMonitorRuleKeyHandle_FlowmonitorruleHandle)(nil),
	}
}

func _FlowMonitorRuleKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowMonitorRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *FlowMonitorRuleKeyHandle_FlowmonitorruleId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.FlowmonitorruleId))
	case *FlowMonitorRuleKeyHandle_FlowmonitorruleHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.FlowmonitorruleHandle))
	case nil:
	default:
		return fmt.Errorf("FlowMonitorRuleKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _FlowMonitorRuleKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowMonitorRuleKeyHandle)
	switch tag {
	case 1: // key_or_handle.flowmonitorrule_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &FlowMonitorRuleKeyHandle_FlowmonitorruleId{x}
		return true, err
	case 2: // key_or_handle.flowmonitorrule_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &FlowMonitorRuleKeyHandle_FlowmonitorruleHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _FlowMonitorRuleKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowMonitorRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *FlowMonitorRuleKeyHandle_FlowmonitorruleId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FlowmonitorruleId))
	case *FlowMonitorRuleKeyHandle_FlowmonitorruleHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DropMonitorRuleKeyHandle is used to operate on a DropMonitorRule object either by its key or handle
type DropMonitorRuleKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*DropMonitorRuleKeyHandle_DropmonitorruleId
	//	*DropMonitorRuleKeyHandle_DropmonitorruleHandle
	KeyOrHandle isDropMonitorRuleKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *DropMonitorRuleKeyHandle) Reset()                    { *m = DropMonitorRuleKeyHandle{} }
func (m *DropMonitorRuleKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*DropMonitorRuleKeyHandle) ProtoMessage()               {}
func (*DropMonitorRuleKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{4} }

type isDropMonitorRuleKeyHandle_KeyOrHandle interface{ isDropMonitorRuleKeyHandle_KeyOrHandle() }

type DropMonitorRuleKeyHandle_DropmonitorruleId struct {
	DropmonitorruleId uint64 `protobuf:"varint,1,opt,name=dropmonitorrule_id,json=dropmonitorruleId,oneof"`
}
type DropMonitorRuleKeyHandle_DropmonitorruleHandle struct {
	DropmonitorruleHandle uint64 `protobuf:"fixed64,2,opt,name=dropmonitorrule_handle,json=dropmonitorruleHandle,oneof"`
}

func (*DropMonitorRuleKeyHandle_DropmonitorruleId) isDropMonitorRuleKeyHandle_KeyOrHandle()     {}
func (*DropMonitorRuleKeyHandle_DropmonitorruleHandle) isDropMonitorRuleKeyHandle_KeyOrHandle() {}

func (m *DropMonitorRuleKeyHandle) GetKeyOrHandle() isDropMonitorRuleKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *DropMonitorRuleKeyHandle) GetDropmonitorruleId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*DropMonitorRuleKeyHandle_DropmonitorruleId); ok {
		return x.DropmonitorruleId
	}
	return 0
}

func (m *DropMonitorRuleKeyHandle) GetDropmonitorruleHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*DropMonitorRuleKeyHandle_DropmonitorruleHandle); ok {
		return x.DropmonitorruleHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DropMonitorRuleKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DropMonitorRuleKeyHandle_OneofMarshaler, _DropMonitorRuleKeyHandle_OneofUnmarshaler, _DropMonitorRuleKeyHandle_OneofSizer, []interface{}{
		(*DropMonitorRuleKeyHandle_DropmonitorruleId)(nil),
		(*DropMonitorRuleKeyHandle_DropmonitorruleHandle)(nil),
	}
}

func _DropMonitorRuleKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DropMonitorRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *DropMonitorRuleKeyHandle_DropmonitorruleId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DropmonitorruleId))
	case *DropMonitorRuleKeyHandle_DropmonitorruleHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.DropmonitorruleHandle))
	case nil:
	default:
		return fmt.Errorf("DropMonitorRuleKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _DropMonitorRuleKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DropMonitorRuleKeyHandle)
	switch tag {
	case 1: // key_or_handle.dropmonitorrule_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &DropMonitorRuleKeyHandle_DropmonitorruleId{x}
		return true, err
	case 2: // key_or_handle.dropmonitorrule_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &DropMonitorRuleKeyHandle_DropmonitorruleHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _DropMonitorRuleKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DropMonitorRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *DropMonitorRuleKeyHandle_DropmonitorruleId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DropmonitorruleId))
	case *DropMonitorRuleKeyHandle_DropmonitorruleHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MirrorSessionKeyHandle is used to operate on a MirrorSession object either by its key or handle
type MirrorSessionKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*MirrorSessionKeyHandle_MirrorsessionId
	//	*MirrorSessionKeyHandle_MirrorsessionHandle
	KeyOrHandle isMirrorSessionKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *MirrorSessionKeyHandle) Reset()                    { *m = MirrorSessionKeyHandle{} }
func (m *MirrorSessionKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionKeyHandle) ProtoMessage()               {}
func (*MirrorSessionKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{5} }

type isMirrorSessionKeyHandle_KeyOrHandle interface{ isMirrorSessionKeyHandle_KeyOrHandle() }

type MirrorSessionKeyHandle_MirrorsessionId struct {
	MirrorsessionId uint64 `protobuf:"varint,1,opt,name=mirrorsession_id,json=mirrorsessionId,oneof"`
}
type MirrorSessionKeyHandle_MirrorsessionHandle struct {
	MirrorsessionHandle uint64 `protobuf:"fixed64,2,opt,name=mirrorsession_handle,json=mirrorsessionHandle,oneof"`
}

func (*MirrorSessionKeyHandle_MirrorsessionId) isMirrorSessionKeyHandle_KeyOrHandle()     {}
func (*MirrorSessionKeyHandle_MirrorsessionHandle) isMirrorSessionKeyHandle_KeyOrHandle() {}

func (m *MirrorSessionKeyHandle) GetKeyOrHandle() isMirrorSessionKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *MirrorSessionKeyHandle) GetMirrorsessionId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*MirrorSessionKeyHandle_MirrorsessionId); ok {
		return x.MirrorsessionId
	}
	return 0
}

func (m *MirrorSessionKeyHandle) GetMirrorsessionHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*MirrorSessionKeyHandle_MirrorsessionHandle); ok {
		return x.MirrorsessionHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MirrorSessionKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MirrorSessionKeyHandle_OneofMarshaler, _MirrorSessionKeyHandle_OneofUnmarshaler, _MirrorSessionKeyHandle_OneofSizer, []interface{}{
		(*MirrorSessionKeyHandle_MirrorsessionId)(nil),
		(*MirrorSessionKeyHandle_MirrorsessionHandle)(nil),
	}
}

func _MirrorSessionKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MirrorSessionKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *MirrorSessionKeyHandle_MirrorsessionId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.MirrorsessionId))
	case *MirrorSessionKeyHandle_MirrorsessionHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.MirrorsessionHandle))
	case nil:
	default:
		return fmt.Errorf("MirrorSessionKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _MirrorSessionKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MirrorSessionKeyHandle)
	switch tag {
	case 1: // key_or_handle.mirrorsession_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &MirrorSessionKeyHandle_MirrorsessionId{x}
		return true, err
	case 2: // key_or_handle.mirrorsession_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &MirrorSessionKeyHandle_MirrorsessionHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _MirrorSessionKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MirrorSessionKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *MirrorSessionKeyHandle_MirrorsessionId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.MirrorsessionId))
	case *MirrorSessionKeyHandle_MirrorsessionHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VrfKeyHandle is used to operate on a vrf either by its key or handle
type VrfKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*VrfKeyHandle_VrfId
	//	*VrfKeyHandle_VrfHandle
	KeyOrHandle isVrfKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *VrfKeyHandle) Reset()                    { *m = VrfKeyHandle{} }
func (m *VrfKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*VrfKeyHandle) ProtoMessage()               {}
func (*VrfKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{6} }

type isVrfKeyHandle_KeyOrHandle interface{ isVrfKeyHandle_KeyOrHandle() }

type VrfKeyHandle_VrfId struct {
	VrfId uint64 `protobuf:"varint,1,opt,name=vrf_id,json=vrfId,oneof"`
}
type VrfKeyHandle_VrfHandle struct {
	VrfHandle uint64 `protobuf:"fixed64,2,opt,name=vrf_handle,json=vrfHandle,oneof"`
}

func (*VrfKeyHandle_VrfId) isVrfKeyHandle_KeyOrHandle()     {}
func (*VrfKeyHandle_VrfHandle) isVrfKeyHandle_KeyOrHandle() {}

func (m *VrfKeyHandle) GetKeyOrHandle() isVrfKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *VrfKeyHandle) GetVrfId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*VrfKeyHandle_VrfId); ok {
		return x.VrfId
	}
	return 0
}

func (m *VrfKeyHandle) GetVrfHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*VrfKeyHandle_VrfHandle); ok {
		return x.VrfHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VrfKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VrfKeyHandle_OneofMarshaler, _VrfKeyHandle_OneofUnmarshaler, _VrfKeyHandle_OneofSizer, []interface{}{
		(*VrfKeyHandle_VrfId)(nil),
		(*VrfKeyHandle_VrfHandle)(nil),
	}
}

func _VrfKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VrfKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *VrfKeyHandle_VrfId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.VrfId))
	case *VrfKeyHandle_VrfHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.VrfHandle))
	case nil:
	default:
		return fmt.Errorf("VrfKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _VrfKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VrfKeyHandle)
	switch tag {
	case 1: // key_or_handle.vrf_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &VrfKeyHandle_VrfId{x}
		return true, err
	case 2: // key_or_handle.vrf_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &VrfKeyHandle_VrfHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _VrfKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VrfKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *VrfKeyHandle_VrfId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.VrfId))
	case *VrfKeyHandle_VrfHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NetworkKey uniquely identifies a network by its key
type NetworkKey struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
	IpPrefix     *IPPrefix     `protobuf:"bytes,2,opt,name=ip_prefix,json=ipPrefix" json:"ip_prefix,omitempty"`
}

func (m *NetworkKey) Reset()                    { *m = NetworkKey{} }
func (m *NetworkKey) String() string            { return proto.CompactTextString(m) }
func (*NetworkKey) ProtoMessage()               {}
func (*NetworkKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{7} }

func (m *NetworkKey) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *NetworkKey) GetIpPrefix() *IPPrefix {
	if m != nil {
		return m.IpPrefix
	}
	return nil
}

// NetworkKeyHandle uniquely identifies a Network
type NetworkKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*NetworkKeyHandle_NwKey
	//	*NetworkKeyHandle_NwHandle
	KeyOrHandle isNetworkKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *NetworkKeyHandle) Reset()                    { *m = NetworkKeyHandle{} }
func (m *NetworkKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*NetworkKeyHandle) ProtoMessage()               {}
func (*NetworkKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{8} }

type isNetworkKeyHandle_KeyOrHandle interface{ isNetworkKeyHandle_KeyOrHandle() }

type NetworkKeyHandle_NwKey struct {
	NwKey *NetworkKey `protobuf:"bytes,1,opt,name=nw_key,json=nwKey,oneof"`
}
type NetworkKeyHandle_NwHandle struct {
	NwHandle uint64 `protobuf:"fixed64,2,opt,name=nw_handle,json=nwHandle,oneof"`
}

func (*NetworkKeyHandle_NwKey) isNetworkKeyHandle_KeyOrHandle()    {}
func (*NetworkKeyHandle_NwHandle) isNetworkKeyHandle_KeyOrHandle() {}

func (m *NetworkKeyHandle) GetKeyOrHandle() isNetworkKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NetworkKeyHandle) GetNwKey() *NetworkKey {
	if x, ok := m.GetKeyOrHandle().(*NetworkKeyHandle_NwKey); ok {
		return x.NwKey
	}
	return nil
}

func (m *NetworkKeyHandle) GetNwHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NetworkKeyHandle_NwHandle); ok {
		return x.NwHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkKeyHandle_OneofMarshaler, _NetworkKeyHandle_OneofUnmarshaler, _NetworkKeyHandle_OneofSizer, []interface{}{
		(*NetworkKeyHandle_NwKey)(nil),
		(*NetworkKeyHandle_NwHandle)(nil),
	}
}

func _NetworkKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NetworkKeyHandle_NwKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NwKey); err != nil {
			return err
		}
	case *NetworkKeyHandle_NwHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.NwHandle))
	case nil:
	default:
		return fmt.Errorf("NetworkKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _NetworkKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkKeyHandle)
	switch tag {
	case 1: // key_or_handle.nw_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &NetworkKeyHandle_NwKey{msg}
		return true, err
	case 2: // key_or_handle.nw_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &NetworkKeyHandle_NwHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NetworkKeyHandle_NwKey:
		s := proto.Size(x.NwKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkKeyHandle_NwHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NexthopKeyHandle uniquely identifies a Nexthop
type NexthopKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*NexthopKeyHandle_NexthopId
	//	*NexthopKeyHandle_NexthopHandle
	KeyOrHandle isNexthopKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *NexthopKeyHandle) Reset()                    { *m = NexthopKeyHandle{} }
func (m *NexthopKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*NexthopKeyHandle) ProtoMessage()               {}
func (*NexthopKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{9} }

type isNexthopKeyHandle_KeyOrHandle interface{ isNexthopKeyHandle_KeyOrHandle() }

type NexthopKeyHandle_NexthopId struct {
	NexthopId uint64 `protobuf:"varint,1,opt,name=nexthop_id,json=nexthopId,oneof"`
}
type NexthopKeyHandle_NexthopHandle struct {
	NexthopHandle uint64 `protobuf:"fixed64,2,opt,name=nexthop_handle,json=nexthopHandle,oneof"`
}

func (*NexthopKeyHandle_NexthopId) isNexthopKeyHandle_KeyOrHandle()     {}
func (*NexthopKeyHandle_NexthopHandle) isNexthopKeyHandle_KeyOrHandle() {}

func (m *NexthopKeyHandle) GetKeyOrHandle() isNexthopKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NexthopKeyHandle) GetNexthopId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NexthopKeyHandle_NexthopId); ok {
		return x.NexthopId
	}
	return 0
}

func (m *NexthopKeyHandle) GetNexthopHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NexthopKeyHandle_NexthopHandle); ok {
		return x.NexthopHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NexthopKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NexthopKeyHandle_OneofMarshaler, _NexthopKeyHandle_OneofUnmarshaler, _NexthopKeyHandle_OneofSizer, []interface{}{
		(*NexthopKeyHandle_NexthopId)(nil),
		(*NexthopKeyHandle_NexthopHandle)(nil),
	}
}

func _NexthopKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NexthopKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NexthopKeyHandle_NexthopId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.NexthopId))
	case *NexthopKeyHandle_NexthopHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.NexthopHandle))
	case nil:
	default:
		return fmt.Errorf("NexthopKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _NexthopKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NexthopKeyHandle)
	switch tag {
	case 1: // key_or_handle.nexthop_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &NexthopKeyHandle_NexthopId{x}
		return true, err
	case 2: // key_or_handle.nexthop_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &NexthopKeyHandle_NexthopHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _NexthopKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NexthopKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NexthopKeyHandle_NexthopId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.NexthopId))
	case *NexthopKeyHandle_NexthopHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteKey uniquely identifies a route by its key
type RouteKey struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
	IpPrefix     *IPPrefix     `protobuf:"bytes,2,opt,name=ip_prefix,json=ipPrefix" json:"ip_prefix,omitempty"`
}

func (m *RouteKey) Reset()                    { *m = RouteKey{} }
func (m *RouteKey) String() string            { return proto.CompactTextString(m) }
func (*RouteKey) ProtoMessage()               {}
func (*RouteKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{10} }

func (m *RouteKey) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *RouteKey) GetIpPrefix() *IPPrefix {
	if m != nil {
		return m.IpPrefix
	}
	return nil
}

// RouteKeyHandle uniquely identifies a Route
type RouteKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*RouteKeyHandle_RouteKey
	//	*RouteKeyHandle_RouteHandle
	KeyOrHandle isRouteKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *RouteKeyHandle) Reset()                    { *m = RouteKeyHandle{} }
func (m *RouteKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*RouteKeyHandle) ProtoMessage()               {}
func (*RouteKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{11} }

type isRouteKeyHandle_KeyOrHandle interface{ isRouteKeyHandle_KeyOrHandle() }

type RouteKeyHandle_RouteKey struct {
	RouteKey *RouteKey `protobuf:"bytes,1,opt,name=route_key,json=routeKey,oneof"`
}
type RouteKeyHandle_RouteHandle struct {
	RouteHandle uint64 `protobuf:"fixed64,2,opt,name=route_handle,json=routeHandle,oneof"`
}

func (*RouteKeyHandle_RouteKey) isRouteKeyHandle_KeyOrHandle()    {}
func (*RouteKeyHandle_RouteHandle) isRouteKeyHandle_KeyOrHandle() {}

func (m *RouteKeyHandle) GetKeyOrHandle() isRouteKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *RouteKeyHandle) GetRouteKey() *RouteKey {
	if x, ok := m.GetKeyOrHandle().(*RouteKeyHandle_RouteKey); ok {
		return x.RouteKey
	}
	return nil
}

func (m *RouteKeyHandle) GetRouteHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*RouteKeyHandle_RouteHandle); ok {
		return x.RouteHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteKeyHandle_OneofMarshaler, _RouteKeyHandle_OneofUnmarshaler, _RouteKeyHandle_OneofSizer, []interface{}{
		(*RouteKeyHandle_RouteKey)(nil),
		(*RouteKeyHandle_RouteHandle)(nil),
	}
}

func _RouteKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *RouteKeyHandle_RouteKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteKey); err != nil {
			return err
		}
	case *RouteKeyHandle_RouteHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.RouteHandle))
	case nil:
	default:
		return fmt.Errorf("RouteKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _RouteKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteKeyHandle)
	switch tag {
	case 1: // key_or_handle.route_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &RouteKeyHandle_RouteKey{msg}
		return true, err
	case 2: // key_or_handle.route_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &RouteKeyHandle_RouteHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _RouteKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *RouteKeyHandle_RouteKey:
		s := proto.Size(x.RouteKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteKeyHandle_RouteHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L2SegmentKeyHandle is used to operate on a L2 segment either by its
// segment id or HAL allocated handle
type L2SegmentKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*L2SegmentKeyHandle_SegmentId
	//	*L2SegmentKeyHandle_L2SegmentHandle
	KeyOrHandle isL2SegmentKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *L2SegmentKeyHandle) Reset()                    { *m = L2SegmentKeyHandle{} }
func (m *L2SegmentKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*L2SegmentKeyHandle) ProtoMessage()               {}
func (*L2SegmentKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{12} }

type isL2SegmentKeyHandle_KeyOrHandle interface{ isL2SegmentKeyHandle_KeyOrHandle() }

type L2SegmentKeyHandle_SegmentId struct {
	SegmentId uint64 `protobuf:"varint,1,opt,name=segment_id,json=segmentId,oneof"`
}
type L2SegmentKeyHandle_L2SegmentHandle struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,2,opt,name=l2segment_handle,json=l2segmentHandle,oneof"`
}

func (*L2SegmentKeyHandle_SegmentId) isL2SegmentKeyHandle_KeyOrHandle()       {}
func (*L2SegmentKeyHandle_L2SegmentHandle) isL2SegmentKeyHandle_KeyOrHandle() {}

func (m *L2SegmentKeyHandle) GetKeyOrHandle() isL2SegmentKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *L2SegmentKeyHandle) GetSegmentId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*L2SegmentKeyHandle_SegmentId); ok {
		return x.SegmentId
	}
	return 0
}

func (m *L2SegmentKeyHandle) GetL2SegmentHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*L2SegmentKeyHandle_L2SegmentHandle); ok {
		return x.L2SegmentHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L2SegmentKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L2SegmentKeyHandle_OneofMarshaler, _L2SegmentKeyHandle_OneofUnmarshaler, _L2SegmentKeyHandle_OneofSizer, []interface{}{
		(*L2SegmentKeyHandle_SegmentId)(nil),
		(*L2SegmentKeyHandle_L2SegmentHandle)(nil),
	}
}

func _L2SegmentKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L2SegmentKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L2SegmentKeyHandle_SegmentId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.SegmentId))
	case *L2SegmentKeyHandle_L2SegmentHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.L2SegmentHandle))
	case nil:
	default:
		return fmt.Errorf("L2SegmentKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _L2SegmentKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L2SegmentKeyHandle)
	switch tag {
	case 1: // key_or_handle.segment_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &L2SegmentKeyHandle_SegmentId{x}
		return true, err
	case 2: // key_or_handle.l2segment_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &L2SegmentKeyHandle_L2SegmentHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _L2SegmentKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L2SegmentKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *L2SegmentKeyHandle_SegmentId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SegmentId))
	case *L2SegmentKeyHandle_L2SegmentHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SecurityPolicyKey struct {
	SecurityPolicyId uint64        `protobuf:"varint,1,opt,name=security_policy_id,json=securityPolicyId" json:"security_policy_id,omitempty"`
	VrfIdOrHandle    *VrfKeyHandle `protobuf:"bytes,2,opt,name=vrf_id_or_handle,json=vrfIdOrHandle" json:"vrf_id_or_handle,omitempty"`
}

func (m *SecurityPolicyKey) Reset()                    { *m = SecurityPolicyKey{} }
func (m *SecurityPolicyKey) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyKey) ProtoMessage()               {}
func (*SecurityPolicyKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{13} }

func (m *SecurityPolicyKey) GetSecurityPolicyId() uint64 {
	if m != nil {
		return m.SecurityPolicyId
	}
	return 0
}

func (m *SecurityPolicyKey) GetVrfIdOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfIdOrHandle
	}
	return nil
}

// SecurityPolicyKeyHandle uniquely identifies a security policy and is used
// to create/update/delete/get secutiry rules
type SecurityPolicyKeyHandle struct {
	// Types that are valid to be assigned to PolicyKeyOrHandle:
	//	*SecurityPolicyKeyHandle_SecurityPolicyKey
	//	*SecurityPolicyKeyHandle_SecurityPolicyHandle
	PolicyKeyOrHandle isSecurityPolicyKeyHandle_PolicyKeyOrHandle `protobuf_oneof:"policy_key_or_handle"`
}

func (m *SecurityPolicyKeyHandle) Reset()                    { *m = SecurityPolicyKeyHandle{} }
func (m *SecurityPolicyKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyKeyHandle) ProtoMessage()               {}
func (*SecurityPolicyKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{14} }

type isSecurityPolicyKeyHandle_PolicyKeyOrHandle interface{ isSecurityPolicyKeyHandle_PolicyKeyOrHandle() }

type SecurityPolicyKeyHandle_SecurityPolicyKey struct {
	SecurityPolicyKey *SecurityPolicyKey `protobuf:"bytes,1,opt,name=security_policy_key,json=securityPolicyKey,oneof"`
}
type SecurityPolicyKeyHandle_SecurityPolicyHandle struct {
	SecurityPolicyHandle uint64 `protobuf:"fixed64,2,opt,name=security_policy_handle,json=securityPolicyHandle,oneof"`
}

func (*SecurityPolicyKeyHandle_SecurityPolicyKey) isSecurityPolicyKeyHandle_PolicyKeyOrHandle()    {}
func (*SecurityPolicyKeyHandle_SecurityPolicyHandle) isSecurityPolicyKeyHandle_PolicyKeyOrHandle() {}

func (m *SecurityPolicyKeyHandle) GetPolicyKeyOrHandle() isSecurityPolicyKeyHandle_PolicyKeyOrHandle {
	if m != nil {
		return m.PolicyKeyOrHandle
	}
	return nil
}

func (m *SecurityPolicyKeyHandle) GetSecurityPolicyKey() *SecurityPolicyKey {
	if x, ok := m.GetPolicyKeyOrHandle().(*SecurityPolicyKeyHandle_SecurityPolicyKey); ok {
		return x.SecurityPolicyKey
	}
	return nil
}

func (m *SecurityPolicyKeyHandle) GetSecurityPolicyHandle() uint64 {
	if x, ok := m.GetPolicyKeyOrHandle().(*SecurityPolicyKeyHandle_SecurityPolicyHandle); ok {
		return x.SecurityPolicyHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityPolicyKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityPolicyKeyHandle_OneofMarshaler, _SecurityPolicyKeyHandle_OneofUnmarshaler, _SecurityPolicyKeyHandle_OneofSizer, []interface{}{
		(*SecurityPolicyKeyHandle_SecurityPolicyKey)(nil),
		(*SecurityPolicyKeyHandle_SecurityPolicyHandle)(nil),
	}
}

func _SecurityPolicyKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityPolicyKeyHandle)
	// policy_key_or_handle
	switch x := m.PolicyKeyOrHandle.(type) {
	case *SecurityPolicyKeyHandle_SecurityPolicyKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecurityPolicyKey); err != nil {
			return err
		}
	case *SecurityPolicyKeyHandle_SecurityPolicyHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.SecurityPolicyHandle))
	case nil:
	default:
		return fmt.Errorf("SecurityPolicyKeyHandle.PolicyKeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _SecurityPolicyKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityPolicyKeyHandle)
	switch tag {
	case 1: // policy_key_or_handle.security_policy_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityPolicyKey)
		err := b.DecodeMessage(msg)
		m.PolicyKeyOrHandle = &SecurityPolicyKeyHandle_SecurityPolicyKey{msg}
		return true, err
	case 2: // policy_key_or_handle.security_policy_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.PolicyKeyOrHandle = &SecurityPolicyKeyHandle_SecurityPolicyHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityPolicyKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityPolicyKeyHandle)
	// policy_key_or_handle
	switch x := m.PolicyKeyOrHandle.(type) {
	case *SecurityPolicyKeyHandle_SecurityPolicyKey:
		s := proto.Size(x.SecurityPolicyKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityPolicyKeyHandle_SecurityPolicyHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SecurityGroupPolicyId struct {
	SecurityGroupId     uint64 `protobuf:"varint,1,opt,name=security_group_id,json=securityGroupId" json:"security_group_id,omitempty"`
	PeerSecurityGroupId uint64 `protobuf:"varint,2,opt,name=peer_security_group_id,json=peerSecurityGroupId" json:"peer_security_group_id,omitempty"`
}

func (m *SecurityGroupPolicyId) Reset()                    { *m = SecurityGroupPolicyId{} }
func (m *SecurityGroupPolicyId) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyId) ProtoMessage()               {}
func (*SecurityGroupPolicyId) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{15} }

func (m *SecurityGroupPolicyId) GetSecurityGroupId() uint64 {
	if m != nil {
		return m.SecurityGroupId
	}
	return 0
}

func (m *SecurityGroupPolicyId) GetPeerSecurityGroupId() uint64 {
	if m != nil {
		return m.PeerSecurityGroupId
	}
	return 0
}

// SecurityGroupKeyPolicyHandle uniquely identifies a security group and is used
// to create/update/delete/get security group Policy
type SecurityGroupPolicyKeyHandle struct {
	// Types that are valid to be assigned to PolicyKeyOrHandle:
	//	*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId
	//	*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle
	PolicyKeyOrHandle isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle `protobuf_oneof:"policy_key_or_handle"`
}

func (m *SecurityGroupPolicyKeyHandle) Reset()                    { *m = SecurityGroupPolicyKeyHandle{} }
func (m *SecurityGroupPolicyKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyKeyHandle) ProtoMessage()               {}
func (*SecurityGroupPolicyKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{16} }

type isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle interface{ isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle() }

type SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId struct {
	SecurityGroupPolicyId *SecurityGroupPolicyId `protobuf:"bytes,1,opt,name=security_group_policy_id,json=securityGroupPolicyId,oneof"`
}
type SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle struct {
	SecurityGroupPolicyHandle uint64 `protobuf:"fixed64,2,opt,name=security_group_policy_handle,json=securityGroupPolicyHandle,oneof"`
}

func (*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId) isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle() {
}
func (*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle) isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle() {
}

func (m *SecurityGroupPolicyKeyHandle) GetPolicyKeyOrHandle() isSecurityGroupPolicyKeyHandle_PolicyKeyOrHandle {
	if m != nil {
		return m.PolicyKeyOrHandle
	}
	return nil
}

func (m *SecurityGroupPolicyKeyHandle) GetSecurityGroupPolicyId() *SecurityGroupPolicyId {
	if x, ok := m.GetPolicyKeyOrHandle().(*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId); ok {
		return x.SecurityGroupPolicyId
	}
	return nil
}

func (m *SecurityGroupPolicyKeyHandle) GetSecurityGroupPolicyHandle() uint64 {
	if x, ok := m.GetPolicyKeyOrHandle().(*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle); ok {
		return x.SecurityGroupPolicyHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityGroupPolicyKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityGroupPolicyKeyHandle_OneofMarshaler, _SecurityGroupPolicyKeyHandle_OneofUnmarshaler, _SecurityGroupPolicyKeyHandle_OneofSizer, []interface{}{
		(*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId)(nil),
		(*SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle)(nil),
	}
}

func _SecurityGroupPolicyKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityGroupPolicyKeyHandle)
	// policy_key_or_handle
	switch x := m.PolicyKeyOrHandle.(type) {
	case *SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecurityGroupPolicyId); err != nil {
			return err
		}
	case *SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.SecurityGroupPolicyHandle))
	case nil:
	default:
		return fmt.Errorf("SecurityGroupPolicyKeyHandle.PolicyKeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _SecurityGroupPolicyKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityGroupPolicyKeyHandle)
	switch tag {
	case 1: // policy_key_or_handle.security_group_policy_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityGroupPolicyId)
		err := b.DecodeMessage(msg)
		m.PolicyKeyOrHandle = &SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId{msg}
		return true, err
	case 2: // policy_key_or_handle.security_group_policy_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.PolicyKeyOrHandle = &SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityGroupPolicyKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityGroupPolicyKeyHandle)
	// policy_key_or_handle
	switch x := m.PolicyKeyOrHandle.(type) {
	case *SecurityGroupPolicyKeyHandle_SecurityGroupPolicyId:
		s := proto.Size(x.SecurityGroupPolicyId)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityGroupPolicyKeyHandle_SecurityGroupPolicyHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// security_group obj definition
// SecurityGroupKeyHandle uniquely identifies a security group and is used
// to create/update/delete/get security groups
type SecurityGroupKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*SecurityGroupKeyHandle_SecurityGroupId
	//	*SecurityGroupKeyHandle_SecurityGroupHandle
	KeyOrHandle isSecurityGroupKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *SecurityGroupKeyHandle) Reset()                    { *m = SecurityGroupKeyHandle{} }
func (m *SecurityGroupKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupKeyHandle) ProtoMessage()               {}
func (*SecurityGroupKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{17} }

type isSecurityGroupKeyHandle_KeyOrHandle interface{ isSecurityGroupKeyHandle_KeyOrHandle() }

type SecurityGroupKeyHandle_SecurityGroupId struct {
	SecurityGroupId uint64 `protobuf:"varint,1,opt,name=security_group_id,json=securityGroupId,oneof"`
}
type SecurityGroupKeyHandle_SecurityGroupHandle struct {
	SecurityGroupHandle uint64 `protobuf:"fixed64,2,opt,name=security_group_handle,json=securityGroupHandle,oneof"`
}

func (*SecurityGroupKeyHandle_SecurityGroupId) isSecurityGroupKeyHandle_KeyOrHandle()     {}
func (*SecurityGroupKeyHandle_SecurityGroupHandle) isSecurityGroupKeyHandle_KeyOrHandle() {}

func (m *SecurityGroupKeyHandle) GetKeyOrHandle() isSecurityGroupKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityGroupKeyHandle) GetSecurityGroupId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*SecurityGroupKeyHandle_SecurityGroupId); ok {
		return x.SecurityGroupId
	}
	return 0
}

func (m *SecurityGroupKeyHandle) GetSecurityGroupHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*SecurityGroupKeyHandle_SecurityGroupHandle); ok {
		return x.SecurityGroupHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityGroupKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityGroupKeyHandle_OneofMarshaler, _SecurityGroupKeyHandle_OneofUnmarshaler, _SecurityGroupKeyHandle_OneofSizer, []interface{}{
		(*SecurityGroupKeyHandle_SecurityGroupId)(nil),
		(*SecurityGroupKeyHandle_SecurityGroupHandle)(nil),
	}
}

func _SecurityGroupKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityGroupKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *SecurityGroupKeyHandle_SecurityGroupId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.SecurityGroupId))
	case *SecurityGroupKeyHandle_SecurityGroupHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.SecurityGroupHandle))
	case nil:
	default:
		return fmt.Errorf("SecurityGroupKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _SecurityGroupKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityGroupKeyHandle)
	switch tag {
	case 1: // key_or_handle.security_group_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &SecurityGroupKeyHandle_SecurityGroupId{x}
		return true, err
	case 2: // key_or_handle.security_group_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &SecurityGroupKeyHandle_SecurityGroupHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityGroupKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityGroupKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *SecurityGroupKeyHandle_SecurityGroupId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SecurityGroupId))
	case *SecurityGroupKeyHandle_SecurityGroupHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PortKeyHandle uniquely identifies a Port
type PortKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*PortKeyHandle_PortId
	//	*PortKeyHandle_PortHandle
	KeyOrHandle isPortKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *PortKeyHandle) Reset()                    { *m = PortKeyHandle{} }
func (m *PortKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*PortKeyHandle) ProtoMessage()               {}
func (*PortKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{18} }

type isPortKeyHandle_KeyOrHandle interface{ isPortKeyHandle_KeyOrHandle() }

type PortKeyHandle_PortId struct {
	PortId uint32 `protobuf:"fixed32,1,opt,name=port_id,json=portId,oneof"`
}
type PortKeyHandle_PortHandle struct {
	PortHandle uint64 `protobuf:"fixed64,2,opt,name=port_handle,json=portHandle,oneof"`
}

func (*PortKeyHandle_PortId) isPortKeyHandle_KeyOrHandle()     {}
func (*PortKeyHandle_PortHandle) isPortKeyHandle_KeyOrHandle() {}

func (m *PortKeyHandle) GetKeyOrHandle() isPortKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *PortKeyHandle) GetPortId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*PortKeyHandle_PortId); ok {
		return x.PortId
	}
	return 0
}

func (m *PortKeyHandle) GetPortHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*PortKeyHandle_PortHandle); ok {
		return x.PortHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortKeyHandle_OneofMarshaler, _PortKeyHandle_OneofUnmarshaler, _PortKeyHandle_OneofSizer, []interface{}{
		(*PortKeyHandle_PortId)(nil),
		(*PortKeyHandle_PortHandle)(nil),
	}
}

func _PortKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *PortKeyHandle_PortId:
		b.EncodeVarint(1<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(x.PortId))
	case *PortKeyHandle_PortHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.PortHandle))
	case nil:
	default:
		return fmt.Errorf("PortKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _PortKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortKeyHandle)
	switch tag {
	case 1: // key_or_handle.port_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &PortKeyHandle_PortId{uint32(x)}
		return true, err
	case 2: // key_or_handle.port_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &PortKeyHandle_PortHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _PortKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *PortKeyHandle_PortId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *PortKeyHandle_PortHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LifKeyHandle uniquely identifies a LIF
type LifKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*LifKeyHandle_LifId
	//	*LifKeyHandle_LifHandle
	KeyOrHandle isLifKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *LifKeyHandle) Reset()                    { *m = LifKeyHandle{} }
func (m *LifKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*LifKeyHandle) ProtoMessage()               {}
func (*LifKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{19} }

type isLifKeyHandle_KeyOrHandle interface{ isLifKeyHandle_KeyOrHandle() }

type LifKeyHandle_LifId struct {
	LifId uint64 `protobuf:"fixed64,1,opt,name=lif_id,json=lifId,oneof"`
}
type LifKeyHandle_LifHandle struct {
	LifHandle uint64 `protobuf:"fixed64,2,opt,name=lif_handle,json=lifHandle,oneof"`
}

func (*LifKeyHandle_LifId) isLifKeyHandle_KeyOrHandle()     {}
func (*LifKeyHandle_LifHandle) isLifKeyHandle_KeyOrHandle() {}

func (m *LifKeyHandle) GetKeyOrHandle() isLifKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *LifKeyHandle) GetLifId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*LifKeyHandle_LifId); ok {
		return x.LifId
	}
	return 0
}

func (m *LifKeyHandle) GetLifHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*LifKeyHandle_LifHandle); ok {
		return x.LifHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LifKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LifKeyHandle_OneofMarshaler, _LifKeyHandle_OneofUnmarshaler, _LifKeyHandle_OneofSizer, []interface{}{
		(*LifKeyHandle_LifId)(nil),
		(*LifKeyHandle_LifHandle)(nil),
	}
}

func _LifKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LifKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *LifKeyHandle_LifId:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.LifId))
	case *LifKeyHandle_LifHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.LifHandle))
	case nil:
	default:
		return fmt.Errorf("LifKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _LifKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LifKeyHandle)
	switch tag {
	case 1: // key_or_handle.lif_id
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &LifKeyHandle_LifId{x}
		return true, err
	case 2: // key_or_handle.lif_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &LifKeyHandle_LifHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _LifKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LifKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *LifKeyHandle_LifId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *LifKeyHandle_LifHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// InterfaceKeyHandle uniquely identifies a Interface
type InterfaceKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*InterfaceKeyHandle_InterfaceId
	//	*InterfaceKeyHandle_IfHandle
	KeyOrHandle isInterfaceKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *InterfaceKeyHandle) Reset()                    { *m = InterfaceKeyHandle{} }
func (m *InterfaceKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*InterfaceKeyHandle) ProtoMessage()               {}
func (*InterfaceKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{20} }

type isInterfaceKeyHandle_KeyOrHandle interface{ isInterfaceKeyHandle_KeyOrHandle() }

type InterfaceKeyHandle_InterfaceId struct {
	InterfaceId uint64 `protobuf:"fixed64,1,opt,name=interface_id,json=interfaceId,oneof"`
}
type InterfaceKeyHandle_IfHandle struct {
	IfHandle uint64 `protobuf:"fixed64,2,opt,name=if_handle,json=ifHandle,oneof"`
}

func (*InterfaceKeyHandle_InterfaceId) isInterfaceKeyHandle_KeyOrHandle() {}
func (*InterfaceKeyHandle_IfHandle) isInterfaceKeyHandle_KeyOrHandle()    {}

func (m *InterfaceKeyHandle) GetKeyOrHandle() isInterfaceKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *InterfaceKeyHandle) GetInterfaceId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*InterfaceKeyHandle_InterfaceId); ok {
		return x.InterfaceId
	}
	return 0
}

func (m *InterfaceKeyHandle) GetIfHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*InterfaceKeyHandle_IfHandle); ok {
		return x.IfHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceKeyHandle_OneofMarshaler, _InterfaceKeyHandle_OneofUnmarshaler, _InterfaceKeyHandle_OneofSizer, []interface{}{
		(*InterfaceKeyHandle_InterfaceId)(nil),
		(*InterfaceKeyHandle_IfHandle)(nil),
	}
}

func _InterfaceKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *InterfaceKeyHandle_InterfaceId:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.InterfaceId))
	case *InterfaceKeyHandle_IfHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.IfHandle))
	case nil:
	default:
		return fmt.Errorf("InterfaceKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _InterfaceKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceKeyHandle)
	switch tag {
	case 1: // key_or_handle.interface_id
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &InterfaceKeyHandle_InterfaceId{x}
		return true, err
	case 2: // key_or_handle.if_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &InterfaceKeyHandle_IfHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *InterfaceKeyHandle_InterfaceId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *InterfaceKeyHandle_IfHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointL2Key is L2 key of the endpoint
// NOTE: An endpoint can have only one L2 key
type EndpointL2Key struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,1,opt,name=l2segment_key_handle,json=l2segmentKeyHandle" json:"l2segment_key_handle,omitempty"`
	MacAddress         uint64              `protobuf:"varint,2,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
}

func (m *EndpointL2Key) Reset()                    { *m = EndpointL2Key{} }
func (m *EndpointL2Key) String() string            { return proto.CompactTextString(m) }
func (*EndpointL2Key) ProtoMessage()               {}
func (*EndpointL2Key) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{21} }

func (m *EndpointL2Key) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

func (m *EndpointL2Key) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

// EndpointL3Key is the L3 key of the endpoint
// NOTE: An endpoint can have many L3 keys
type EndpointL3Key struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
	IpAddress    *IPAddress    `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
}

func (m *EndpointL3Key) Reset()                    { *m = EndpointL3Key{} }
func (m *EndpointL3Key) String() string            { return proto.CompactTextString(m) }
func (*EndpointL3Key) ProtoMessage()               {}
func (*EndpointL3Key) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{22} }

func (m *EndpointL3Key) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointL3Key) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

// Endpoint can be uniquely identified by its L2 or one of its L3 keys
type EndpointKey struct {
	// Types that are valid to be assigned to EndpointL2L3Key:
	//	*EndpointKey_L2Key
	//	*EndpointKey_L3Key
	EndpointL2L3Key isEndpointKey_EndpointL2L3Key `protobuf_oneof:"endpoint_l2_l3_key"`
}

func (m *EndpointKey) Reset()                    { *m = EndpointKey{} }
func (m *EndpointKey) String() string            { return proto.CompactTextString(m) }
func (*EndpointKey) ProtoMessage()               {}
func (*EndpointKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{23} }

type isEndpointKey_EndpointL2L3Key interface{ isEndpointKey_EndpointL2L3Key() }

type EndpointKey_L2Key struct {
	L2Key *EndpointL2Key `protobuf:"bytes,1,opt,name=l2_key,json=l2Key,oneof"`
}
type EndpointKey_L3Key struct {
	L3Key *EndpointL3Key `protobuf:"bytes,2,opt,name=l3_key,json=l3Key,oneof"`
}

func (*EndpointKey_L2Key) isEndpointKey_EndpointL2L3Key() {}
func (*EndpointKey_L3Key) isEndpointKey_EndpointL2L3Key() {}

func (m *EndpointKey) GetEndpointL2L3Key() isEndpointKey_EndpointL2L3Key {
	if m != nil {
		return m.EndpointL2L3Key
	}
	return nil
}

func (m *EndpointKey) GetL2Key() *EndpointL2Key {
	if x, ok := m.GetEndpointL2L3Key().(*EndpointKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *EndpointKey) GetL3Key() *EndpointL3Key {
	if x, ok := m.GetEndpointL2L3Key().(*EndpointKey_L3Key); ok {
		return x.L3Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointKey_OneofMarshaler, _EndpointKey_OneofUnmarshaler, _EndpointKey_OneofSizer, []interface{}{
		(*EndpointKey_L2Key)(nil),
		(*EndpointKey_L3Key)(nil),
	}
}

func _EndpointKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointKey)
	// endpoint_l2_l3_key
	switch x := m.EndpointL2L3Key.(type) {
	case *EndpointKey_L2Key:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *EndpointKey_L3Key:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointKey.EndpointL2L3Key has unexpected type %T", x)
	}
	return nil
}

func _EndpointKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointKey)
	switch tag {
	case 1: // endpoint_l2_l3_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointL2Key)
		err := b.DecodeMessage(msg)
		m.EndpointL2L3Key = &EndpointKey_L2Key{msg}
		return true, err
	case 2: // endpoint_l2_l3_key.l3_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointL3Key)
		err := b.DecodeMessage(msg)
		m.EndpointL2L3Key = &EndpointKey_L3Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointKey)
	// endpoint_l2_l3_key
	switch x := m.EndpointL2L3Key.(type) {
	case *EndpointKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointKey_L3Key:
		s := proto.Size(x.L3Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Endpoint is accessible via its key or handle
type EndpointKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*EndpointKeyHandle_EndpointKey
	//	*EndpointKeyHandle_EndpointHandle
	KeyOrHandle isEndpointKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *EndpointKeyHandle) Reset()                    { *m = EndpointKeyHandle{} }
func (m *EndpointKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EndpointKeyHandle) ProtoMessage()               {}
func (*EndpointKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{24} }

type isEndpointKeyHandle_KeyOrHandle interface{ isEndpointKeyHandle_KeyOrHandle() }

type EndpointKeyHandle_EndpointKey struct {
	EndpointKey *EndpointKey `protobuf:"bytes,1,opt,name=endpoint_key,json=endpointKey,oneof"`
}
type EndpointKeyHandle_EndpointHandle struct {
	EndpointHandle uint64 `protobuf:"fixed64,2,opt,name=endpoint_handle,json=endpointHandle,oneof"`
}

func (*EndpointKeyHandle_EndpointKey) isEndpointKeyHandle_KeyOrHandle()    {}
func (*EndpointKeyHandle_EndpointHandle) isEndpointKeyHandle_KeyOrHandle() {}

func (m *EndpointKeyHandle) GetKeyOrHandle() isEndpointKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointKeyHandle) GetEndpointKey() *EndpointKey {
	if x, ok := m.GetKeyOrHandle().(*EndpointKeyHandle_EndpointKey); ok {
		return x.EndpointKey
	}
	return nil
}

func (m *EndpointKeyHandle) GetEndpointHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*EndpointKeyHandle_EndpointHandle); ok {
		return x.EndpointHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointKeyHandle_OneofMarshaler, _EndpointKeyHandle_OneofUnmarshaler, _EndpointKeyHandle_OneofSizer, []interface{}{
		(*EndpointKeyHandle_EndpointKey)(nil),
		(*EndpointKeyHandle_EndpointHandle)(nil),
	}
}

func _EndpointKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *EndpointKeyHandle_EndpointKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndpointKey); err != nil {
			return err
		}
	case *EndpointKeyHandle_EndpointHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.EndpointHandle))
	case nil:
	default:
		return fmt.Errorf("EndpointKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _EndpointKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointKeyHandle)
	switch tag {
	case 1: // key_or_handle.endpoint_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &EndpointKeyHandle_EndpointKey{msg}
		return true, err
	case 2: // key_or_handle.endpoint_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &EndpointKeyHandle_EndpointHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *EndpointKeyHandle_EndpointKey:
		s := proto.Size(x.EndpointKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointKeyHandle_EndpointHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Filter key
type FilterKey struct {
	LifKeyOrHandle *LifKeyHandle `protobuf:"bytes,1,opt,name=lif_key_or_handle,json=lifKeyOrHandle" json:"lif_key_or_handle,omitempty"`
	Type           FilterType    `protobuf:"varint,2,opt,name=type,enum=kh.FilterType" json:"type,omitempty"`
	MacAddress     uint64        `protobuf:"varint,3,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	VlanId         uint32        `protobuf:"varint,4,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
}

func (m *FilterKey) Reset()                    { *m = FilterKey{} }
func (m *FilterKey) String() string            { return proto.CompactTextString(m) }
func (*FilterKey) ProtoMessage()               {}
func (*FilterKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{25} }

func (m *FilterKey) GetLifKeyOrHandle() *LifKeyHandle {
	if m != nil {
		return m.LifKeyOrHandle
	}
	return nil
}

func (m *FilterKey) GetType() FilterType {
	if m != nil {
		return m.Type
	}
	return FilterType_FILTER_NONE
}

func (m *FilterKey) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *FilterKey) GetVlanId() uint32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

// Filter is accessible via its key or handle
type FilterKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*FilterKeyHandle_FilterKey
	//	*FilterKeyHandle_FilterHandle
	KeyOrHandle isFilterKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *FilterKeyHandle) Reset()                    { *m = FilterKeyHandle{} }
func (m *FilterKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*FilterKeyHandle) ProtoMessage()               {}
func (*FilterKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{26} }

type isFilterKeyHandle_KeyOrHandle interface{ isFilterKeyHandle_KeyOrHandle() }

type FilterKeyHandle_FilterKey struct {
	FilterKey *FilterKey `protobuf:"bytes,1,opt,name=filter_key,json=filterKey,oneof"`
}
type FilterKeyHandle_FilterHandle struct {
	FilterHandle uint64 `protobuf:"fixed64,2,opt,name=filter_handle,json=filterHandle,oneof"`
}

func (*FilterKeyHandle_FilterKey) isFilterKeyHandle_KeyOrHandle()    {}
func (*FilterKeyHandle_FilterHandle) isFilterKeyHandle_KeyOrHandle() {}

func (m *FilterKeyHandle) GetKeyOrHandle() isFilterKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *FilterKeyHandle) GetFilterKey() *FilterKey {
	if x, ok := m.GetKeyOrHandle().(*FilterKeyHandle_FilterKey); ok {
		return x.FilterKey
	}
	return nil
}

func (m *FilterKeyHandle) GetFilterHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*FilterKeyHandle_FilterHandle); ok {
		return x.FilterHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FilterKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FilterKeyHandle_OneofMarshaler, _FilterKeyHandle_OneofUnmarshaler, _FilterKeyHandle_OneofSizer, []interface{}{
		(*FilterKeyHandle_FilterKey)(nil),
		(*FilterKeyHandle_FilterHandle)(nil),
	}
}

func _FilterKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FilterKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *FilterKeyHandle_FilterKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FilterKey); err != nil {
			return err
		}
	case *FilterKeyHandle_FilterHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.FilterHandle))
	case nil:
	default:
		return fmt.Errorf("FilterKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _FilterKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FilterKeyHandle)
	switch tag {
	case 1: // key_or_handle.filter_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FilterKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &FilterKeyHandle_FilterKey{msg}
		return true, err
	case 2: // key_or_handle.filter_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &FilterKeyHandle_FilterHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _FilterKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FilterKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *FilterKeyHandle_FilterKey:
		s := proto.Size(x.FilterKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FilterKeyHandle_FilterHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MulticastEntryKeyIP struct {
	Source *IPAddress `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Group  *IPAddress `protobuf:"bytes,2,opt,name=group" json:"group,omitempty"`
}

func (m *MulticastEntryKeyIP) Reset()                    { *m = MulticastEntryKeyIP{} }
func (m *MulticastEntryKeyIP) String() string            { return proto.CompactTextString(m) }
func (*MulticastEntryKeyIP) ProtoMessage()               {}
func (*MulticastEntryKeyIP) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{27} }

func (m *MulticastEntryKeyIP) GetSource() *IPAddress {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *MulticastEntryKeyIP) GetGroup() *IPAddress {
	if m != nil {
		return m.Group
	}
	return nil
}

type MulticastEntryKeyMac struct {
	Group uint64 `protobuf:"fixed64,1,opt,name=group" json:"group,omitempty"`
}

func (m *MulticastEntryKeyMac) Reset()                    { *m = MulticastEntryKeyMac{} }
func (m *MulticastEntryKeyMac) String() string            { return proto.CompactTextString(m) }
func (*MulticastEntryKeyMac) ProtoMessage()               {}
func (*MulticastEntryKeyMac) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{28} }

func (m *MulticastEntryKeyMac) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

type MulticastEntryKey struct {
	// Types that are valid to be assigned to IpOrMac:
	//	*MulticastEntryKey_Ip
	//	*MulticastEntryKey_Mac
	IpOrMac            isMulticastEntryKey_IpOrMac `protobuf_oneof:"ip_or_mac"`
	L2SegmentKeyHandle *L2SegmentKeyHandle         `protobuf:"bytes,3,opt,name=l2segment_key_handle,json=l2segmentKeyHandle" json:"l2segment_key_handle,omitempty"`
}

func (m *MulticastEntryKey) Reset()                    { *m = MulticastEntryKey{} }
func (m *MulticastEntryKey) String() string            { return proto.CompactTextString(m) }
func (*MulticastEntryKey) ProtoMessage()               {}
func (*MulticastEntryKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{29} }

type isMulticastEntryKey_IpOrMac interface{ isMulticastEntryKey_IpOrMac() }

type MulticastEntryKey_Ip struct {
	Ip *MulticastEntryKeyIP `protobuf:"bytes,1,opt,name=ip,oneof"`
}
type MulticastEntryKey_Mac struct {
	Mac *MulticastEntryKeyMac `protobuf:"bytes,2,opt,name=mac,oneof"`
}

func (*MulticastEntryKey_Ip) isMulticastEntryKey_IpOrMac()  {}
func (*MulticastEntryKey_Mac) isMulticastEntryKey_IpOrMac() {}

func (m *MulticastEntryKey) GetIpOrMac() isMulticastEntryKey_IpOrMac {
	if m != nil {
		return m.IpOrMac
	}
	return nil
}

func (m *MulticastEntryKey) GetIp() *MulticastEntryKeyIP {
	if x, ok := m.GetIpOrMac().(*MulticastEntryKey_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *MulticastEntryKey) GetMac() *MulticastEntryKeyMac {
	if x, ok := m.GetIpOrMac().(*MulticastEntryKey_Mac); ok {
		return x.Mac
	}
	return nil
}

func (m *MulticastEntryKey) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MulticastEntryKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MulticastEntryKey_OneofMarshaler, _MulticastEntryKey_OneofUnmarshaler, _MulticastEntryKey_OneofSizer, []interface{}{
		(*MulticastEntryKey_Ip)(nil),
		(*MulticastEntryKey_Mac)(nil),
	}
}

func _MulticastEntryKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MulticastEntryKey)
	// ip_or_mac
	switch x := m.IpOrMac.(type) {
	case *MulticastEntryKey_Ip:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ip); err != nil {
			return err
		}
	case *MulticastEntryKey_Mac:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mac); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MulticastEntryKey.IpOrMac has unexpected type %T", x)
	}
	return nil
}

func _MulticastEntryKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MulticastEntryKey)
	switch tag {
	case 1: // ip_or_mac.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MulticastEntryKeyIP)
		err := b.DecodeMessage(msg)
		m.IpOrMac = &MulticastEntryKey_Ip{msg}
		return true, err
	case 2: // ip_or_mac.mac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MulticastEntryKeyMac)
		err := b.DecodeMessage(msg)
		m.IpOrMac = &MulticastEntryKey_Mac{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MulticastEntryKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MulticastEntryKey)
	// ip_or_mac
	switch x := m.IpOrMac.(type) {
	case *MulticastEntryKey_Ip:
		s := proto.Size(x.Ip)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MulticastEntryKey_Mac:
		s := proto.Size(x.Mac)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MulticastEntryKeyHandle
type MulticastEntryKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*MulticastEntryKeyHandle_Key
	//	*MulticastEntryKeyHandle_MulticastHandle
	KeyOrHandle isMulticastEntryKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *MulticastEntryKeyHandle) Reset()                    { *m = MulticastEntryKeyHandle{} }
func (m *MulticastEntryKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*MulticastEntryKeyHandle) ProtoMessage()               {}
func (*MulticastEntryKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{30} }

type isMulticastEntryKeyHandle_KeyOrHandle interface{ isMulticastEntryKeyHandle_KeyOrHandle() }

type MulticastEntryKeyHandle_Key struct {
	Key *MulticastEntryKey `protobuf:"bytes,1,opt,name=key,oneof"`
}
type MulticastEntryKeyHandle_MulticastHandle struct {
	MulticastHandle uint64 `protobuf:"fixed64,2,opt,name=multicast_handle,json=multicastHandle,oneof"`
}

func (*MulticastEntryKeyHandle_Key) isMulticastEntryKeyHandle_KeyOrHandle()             {}
func (*MulticastEntryKeyHandle_MulticastHandle) isMulticastEntryKeyHandle_KeyOrHandle() {}

func (m *MulticastEntryKeyHandle) GetKeyOrHandle() isMulticastEntryKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *MulticastEntryKeyHandle) GetKey() *MulticastEntryKey {
	if x, ok := m.GetKeyOrHandle().(*MulticastEntryKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

func (m *MulticastEntryKeyHandle) GetMulticastHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*MulticastEntryKeyHandle_MulticastHandle); ok {
		return x.MulticastHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MulticastEntryKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MulticastEntryKeyHandle_OneofMarshaler, _MulticastEntryKeyHandle_OneofUnmarshaler, _MulticastEntryKeyHandle_OneofSizer, []interface{}{
		(*MulticastEntryKeyHandle_Key)(nil),
		(*MulticastEntryKeyHandle_MulticastHandle)(nil),
	}
}

func _MulticastEntryKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MulticastEntryKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *MulticastEntryKeyHandle_Key:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case *MulticastEntryKeyHandle_MulticastHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.MulticastHandle))
	case nil:
	default:
		return fmt.Errorf("MulticastEntryKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _MulticastEntryKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MulticastEntryKeyHandle)
	switch tag {
	case 1: // key_or_handle.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MulticastEntryKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &MulticastEntryKeyHandle_Key{msg}
		return true, err
	case 2: // key_or_handle.multicast_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &MulticastEntryKeyHandle_MulticastHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _MulticastEntryKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MulticastEntryKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *MulticastEntryKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MulticastEntryKeyHandle_MulticastHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclKeyHandle uniquely identifies a Acl
type AclKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*AclKeyHandle_AclId
	//	*AclKeyHandle_AclHandle
	KeyOrHandle isAclKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *AclKeyHandle) Reset()                    { *m = AclKeyHandle{} }
func (m *AclKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*AclKeyHandle) ProtoMessage()               {}
func (*AclKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{31} }

type isAclKeyHandle_KeyOrHandle interface{ isAclKeyHandle_KeyOrHandle() }

type AclKeyHandle_AclId struct {
	AclId uint32 `protobuf:"fixed32,1,opt,name=acl_id,json=aclId,oneof"`
}
type AclKeyHandle_AclHandle struct {
	AclHandle uint64 `protobuf:"fixed64,2,opt,name=acl_handle,json=aclHandle,oneof"`
}

func (*AclKeyHandle_AclId) isAclKeyHandle_KeyOrHandle()     {}
func (*AclKeyHandle_AclHandle) isAclKeyHandle_KeyOrHandle() {}

func (m *AclKeyHandle) GetKeyOrHandle() isAclKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclKeyHandle) GetAclId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclId); ok {
		return x.AclId
	}
	return 0
}

func (m *AclKeyHandle) GetAclHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclHandle); ok {
		return x.AclHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclKeyHandle_OneofMarshaler, _AclKeyHandle_OneofUnmarshaler, _AclKeyHandle_OneofSizer, []interface{}{
		(*AclKeyHandle_AclId)(nil),
		(*AclKeyHandle_AclHandle)(nil),
	}
}

func _AclKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		b.EncodeVarint(1<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(x.AclId))
	case *AclKeyHandle_AclHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.AclHandle))
	case nil:
	default:
		return fmt.Errorf("AclKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _AclKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclKeyHandle)
	switch tag {
	case 1: // key_or_handle.acl_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &AclKeyHandle_AclId{uint32(x)}
		return true, err
	case 2: // key_or_handle.acl_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &AclKeyHandle_AclHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _AclKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *AclKeyHandle_AclHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GftExactMatchProfileKeyHandle is used to operate on a GFT exact match profile
// either by its profile id or HAL allocated handle
type GftExactMatchProfileKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*GftExactMatchProfileKeyHandle_ProfileId
	//	*GftExactMatchProfileKeyHandle_ProfileHandle
	KeyOrHandle isGftExactMatchProfileKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *GftExactMatchProfileKeyHandle) Reset()                    { *m = GftExactMatchProfileKeyHandle{} }
func (m *GftExactMatchProfileKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*GftExactMatchProfileKeyHandle) ProtoMessage()               {}
func (*GftExactMatchProfileKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{32} }

type isGftExactMatchProfileKeyHandle_KeyOrHandle interface{ isGftExactMatchProfileKeyHandle_KeyOrHandle() }

type GftExactMatchProfileKeyHandle_ProfileId struct {
	ProfileId uint64 `protobuf:"varint,1,opt,name=profile_id,json=profileId,oneof"`
}
type GftExactMatchProfileKeyHandle_ProfileHandle struct {
	ProfileHandle uint64 `protobuf:"fixed64,2,opt,name=profile_handle,json=profileHandle,oneof"`
}

func (*GftExactMatchProfileKeyHandle_ProfileId) isGftExactMatchProfileKeyHandle_KeyOrHandle()     {}
func (*GftExactMatchProfileKeyHandle_ProfileHandle) isGftExactMatchProfileKeyHandle_KeyOrHandle() {}

func (m *GftExactMatchProfileKeyHandle) GetKeyOrHandle() isGftExactMatchProfileKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftExactMatchProfileKeyHandle) GetProfileId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftExactMatchProfileKeyHandle_ProfileId); ok {
		return x.ProfileId
	}
	return 0
}

func (m *GftExactMatchProfileKeyHandle) GetProfileHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftExactMatchProfileKeyHandle_ProfileHandle); ok {
		return x.ProfileHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GftExactMatchProfileKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GftExactMatchProfileKeyHandle_OneofMarshaler, _GftExactMatchProfileKeyHandle_OneofUnmarshaler, _GftExactMatchProfileKeyHandle_OneofSizer, []interface{}{
		(*GftExactMatchProfileKeyHandle_ProfileId)(nil),
		(*GftExactMatchProfileKeyHandle_ProfileHandle)(nil),
	}
}

func _GftExactMatchProfileKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GftExactMatchProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftExactMatchProfileKeyHandle_ProfileId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ProfileId))
	case *GftExactMatchProfileKeyHandle_ProfileHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.ProfileHandle))
	case nil:
	default:
		return fmt.Errorf("GftExactMatchProfileKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _GftExactMatchProfileKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GftExactMatchProfileKeyHandle)
	switch tag {
	case 1: // key_or_handle.profile_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &GftExactMatchProfileKeyHandle_ProfileId{x}
		return true, err
	case 2: // key_or_handle.profile_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &GftExactMatchProfileKeyHandle_ProfileHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _GftExactMatchProfileKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GftExactMatchProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftExactMatchProfileKeyHandle_ProfileId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ProfileId))
	case *GftExactMatchProfileKeyHandle_ProfileHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GftHeaderTranspositionProfileKeyHandle is used to operate on a GFT header
// transposition profile either by its profile id or HAL allocated handle
type GftHeaderTranspositionProfileKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*GftHeaderTranspositionProfileKeyHandle_ProfileId
	//	*GftHeaderTranspositionProfileKeyHandle_ProfileHandle
	KeyOrHandle isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *GftHeaderTranspositionProfileKeyHandle) Reset() {
	*m = GftHeaderTranspositionProfileKeyHandle{}
}
func (m *GftHeaderTranspositionProfileKeyHandle) String() string { return proto.CompactTextString(m) }
func (*GftHeaderTranspositionProfileKeyHandle) ProtoMessage()    {}
func (*GftHeaderTranspositionProfileKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor15, []int{33}
}

type isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle interface{ isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle() }

type GftHeaderTranspositionProfileKeyHandle_ProfileId struct {
	ProfileId uint64 `protobuf:"varint,1,opt,name=profile_id,json=profileId,oneof"`
}
type GftHeaderTranspositionProfileKeyHandle_ProfileHandle struct {
	ProfileHandle uint64 `protobuf:"fixed64,2,opt,name=profile_handle,json=profileHandle,oneof"`
}

func (*GftHeaderTranspositionProfileKeyHandle_ProfileId) isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle() {
}
func (*GftHeaderTranspositionProfileKeyHandle_ProfileHandle) isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle() {
}

func (m *GftHeaderTranspositionProfileKeyHandle) GetKeyOrHandle() isGftHeaderTranspositionProfileKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftHeaderTranspositionProfileKeyHandle) GetProfileId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftHeaderTranspositionProfileKeyHandle_ProfileId); ok {
		return x.ProfileId
	}
	return 0
}

func (m *GftHeaderTranspositionProfileKeyHandle) GetProfileHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftHeaderTranspositionProfileKeyHandle_ProfileHandle); ok {
		return x.ProfileHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GftHeaderTranspositionProfileKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GftHeaderTranspositionProfileKeyHandle_OneofMarshaler, _GftHeaderTranspositionProfileKeyHandle_OneofUnmarshaler, _GftHeaderTranspositionProfileKeyHandle_OneofSizer, []interface{}{
		(*GftHeaderTranspositionProfileKeyHandle_ProfileId)(nil),
		(*GftHeaderTranspositionProfileKeyHandle_ProfileHandle)(nil),
	}
}

func _GftHeaderTranspositionProfileKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GftHeaderTranspositionProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftHeaderTranspositionProfileKeyHandle_ProfileId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ProfileId))
	case *GftHeaderTranspositionProfileKeyHandle_ProfileHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.ProfileHandle))
	case nil:
	default:
		return fmt.Errorf("GftHeaderTranspositionProfileKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _GftHeaderTranspositionProfileKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GftHeaderTranspositionProfileKeyHandle)
	switch tag {
	case 1: // key_or_handle.profile_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &GftHeaderTranspositionProfileKeyHandle_ProfileId{x}
		return true, err
	case 2: // key_or_handle.profile_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &GftHeaderTranspositionProfileKeyHandle_ProfileHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _GftHeaderTranspositionProfileKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GftHeaderTranspositionProfileKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftHeaderTranspositionProfileKeyHandle_ProfileId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ProfileId))
	case *GftHeaderTranspositionProfileKeyHandle_ProfileHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GftExactMatchFlowEntryKeyHandle is used to operate on a GFT exact match
// flow entry either by its entry id or or HAL allocated handle
type GftExactMatchFlowEntryKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*GftExactMatchFlowEntryKeyHandle_FlowEntryId
	//	*GftExactMatchFlowEntryKeyHandle_FlowEntryHandle
	KeyOrHandle isGftExactMatchFlowEntryKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *GftExactMatchFlowEntryKeyHandle) Reset()         { *m = GftExactMatchFlowEntryKeyHandle{} }
func (m *GftExactMatchFlowEntryKeyHandle) String() string { return proto.CompactTextString(m) }
func (*GftExactMatchFlowEntryKeyHandle) ProtoMessage()    {}
func (*GftExactMatchFlowEntryKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor15, []int{34}
}

type isGftExactMatchFlowEntryKeyHandle_KeyOrHandle interface{ isGftExactMatchFlowEntryKeyHandle_KeyOrHandle() }

type GftExactMatchFlowEntryKeyHandle_FlowEntryId struct {
	FlowEntryId uint64 `protobuf:"varint,1,opt,name=flow_entry_id,json=flowEntryId,oneof"`
}
type GftExactMatchFlowEntryKeyHandle_FlowEntryHandle struct {
	FlowEntryHandle uint64 `protobuf:"fixed64,2,opt,name=flow_entry_handle,json=flowEntryHandle,oneof"`
}

func (*GftExactMatchFlowEntryKeyHandle_FlowEntryId) isGftExactMatchFlowEntryKeyHandle_KeyOrHandle() {}
func (*GftExactMatchFlowEntryKeyHandle_FlowEntryHandle) isGftExactMatchFlowEntryKeyHandle_KeyOrHandle() {
}

func (m *GftExactMatchFlowEntryKeyHandle) GetKeyOrHandle() isGftExactMatchFlowEntryKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *GftExactMatchFlowEntryKeyHandle) GetFlowEntryId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftExactMatchFlowEntryKeyHandle_FlowEntryId); ok {
		return x.FlowEntryId
	}
	return 0
}

func (m *GftExactMatchFlowEntryKeyHandle) GetFlowEntryHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*GftExactMatchFlowEntryKeyHandle_FlowEntryHandle); ok {
		return x.FlowEntryHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GftExactMatchFlowEntryKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GftExactMatchFlowEntryKeyHandle_OneofMarshaler, _GftExactMatchFlowEntryKeyHandle_OneofUnmarshaler, _GftExactMatchFlowEntryKeyHandle_OneofSizer, []interface{}{
		(*GftExactMatchFlowEntryKeyHandle_FlowEntryId)(nil),
		(*GftExactMatchFlowEntryKeyHandle_FlowEntryHandle)(nil),
	}
}

func _GftExactMatchFlowEntryKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GftExactMatchFlowEntryKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftExactMatchFlowEntryKeyHandle_FlowEntryId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.FlowEntryId))
	case *GftExactMatchFlowEntryKeyHandle_FlowEntryHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.FlowEntryHandle))
	case nil:
	default:
		return fmt.Errorf("GftExactMatchFlowEntryKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _GftExactMatchFlowEntryKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GftExactMatchFlowEntryKeyHandle)
	switch tag {
	case 1: // key_or_handle.flow_entry_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &GftExactMatchFlowEntryKeyHandle_FlowEntryId{x}
		return true, err
	case 2: // key_or_handle.flow_entry_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &GftExactMatchFlowEntryKeyHandle_FlowEntryHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _GftExactMatchFlowEntryKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GftExactMatchFlowEntryKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *GftExactMatchFlowEntryKeyHandle_FlowEntryId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FlowEntryId))
	case *GftExactMatchFlowEntryKeyHandle_FlowEntryHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NAT pool key object
type NatPoolKey struct {
	VrfKh  *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_kh,json=vrfKh" json:"vrf_kh,omitempty"`
	PoolId uint64        `protobuf:"varint,2,opt,name=pool_id,json=poolId" json:"pool_id,omitempty"`
}

func (m *NatPoolKey) Reset()                    { *m = NatPoolKey{} }
func (m *NatPoolKey) String() string            { return proto.CompactTextString(m) }
func (*NatPoolKey) ProtoMessage()               {}
func (*NatPoolKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{35} }

func (m *NatPoolKey) GetVrfKh() *VrfKeyHandle {
	if m != nil {
		return m.VrfKh
	}
	return nil
}

func (m *NatPoolKey) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

// NAT pool key/handle object
type NatPoolKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*NatPoolKeyHandle_PoolKey
	//	*NatPoolKeyHandle_PoolHandle
	KeyOrHandle isNatPoolKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *NatPoolKeyHandle) Reset()                    { *m = NatPoolKeyHandle{} }
func (m *NatPoolKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*NatPoolKeyHandle) ProtoMessage()               {}
func (*NatPoolKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{36} }

type isNatPoolKeyHandle_KeyOrHandle interface{ isNatPoolKeyHandle_KeyOrHandle() }

type NatPoolKeyHandle_PoolKey struct {
	PoolKey *NatPoolKey `protobuf:"bytes,1,opt,name=pool_key,json=poolKey,oneof"`
}
type NatPoolKeyHandle_PoolHandle struct {
	PoolHandle uint64 `protobuf:"fixed64,2,opt,name=pool_handle,json=poolHandle,oneof"`
}

func (*NatPoolKeyHandle_PoolKey) isNatPoolKeyHandle_KeyOrHandle()    {}
func (*NatPoolKeyHandle_PoolHandle) isNatPoolKeyHandle_KeyOrHandle() {}

func (m *NatPoolKeyHandle) GetKeyOrHandle() isNatPoolKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatPoolKeyHandle) GetPoolKey() *NatPoolKey {
	if x, ok := m.GetKeyOrHandle().(*NatPoolKeyHandle_PoolKey); ok {
		return x.PoolKey
	}
	return nil
}

func (m *NatPoolKeyHandle) GetPoolHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NatPoolKeyHandle_PoolHandle); ok {
		return x.PoolHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NatPoolKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NatPoolKeyHandle_OneofMarshaler, _NatPoolKeyHandle_OneofUnmarshaler, _NatPoolKeyHandle_OneofSizer, []interface{}{
		(*NatPoolKeyHandle_PoolKey)(nil),
		(*NatPoolKeyHandle_PoolHandle)(nil),
	}
}

func _NatPoolKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NatPoolKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatPoolKeyHandle_PoolKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PoolKey); err != nil {
			return err
		}
	case *NatPoolKeyHandle_PoolHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.PoolHandle))
	case nil:
	default:
		return fmt.Errorf("NatPoolKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _NatPoolKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NatPoolKeyHandle)
	switch tag {
	case 1: // key_or_handle.pool_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NatPoolKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &NatPoolKeyHandle_PoolKey{msg}
		return true, err
	case 2: // key_or_handle.pool_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &NatPoolKeyHandle_PoolHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _NatPoolKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NatPoolKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatPoolKeyHandle_PoolKey:
		s := proto.Size(x.PoolKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NatPoolKeyHandle_PoolHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for the NAT policy
type NATPolicyKey struct {
	NatPolicyId    uint64        `protobuf:"varint,1,opt,name=nat_policy_id,json=natPolicyId" json:"nat_policy_id,omitempty"`
	VrfKeyOrHandle *VrfKeyHandle `protobuf:"bytes,2,opt,name=vrf_key_or_handle,json=vrfKeyOrHandle" json:"vrf_key_or_handle,omitempty"`
}

func (m *NATPolicyKey) Reset()                    { *m = NATPolicyKey{} }
func (m *NATPolicyKey) String() string            { return proto.CompactTextString(m) }
func (*NATPolicyKey) ProtoMessage()               {}
func (*NATPolicyKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{37} }

func (m *NATPolicyKey) GetNatPolicyId() uint64 {
	if m != nil {
		return m.NatPolicyId
	}
	return 0
}

func (m *NATPolicyKey) GetVrfKeyOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyOrHandle
	}
	return nil
}

// NatPolicyKeyHandle uniquely identifies a NAT policy and is used
// to create/update/delete/get NAT rules
type NatPolicyKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*NatPolicyKeyHandle_PolicyKey
	//	*NatPolicyKeyHandle_PolicyHandle
	KeyOrHandle isNatPolicyKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *NatPolicyKeyHandle) Reset()                    { *m = NatPolicyKeyHandle{} }
func (m *NatPolicyKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyKeyHandle) ProtoMessage()               {}
func (*NatPolicyKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{38} }

type isNatPolicyKeyHandle_KeyOrHandle interface{ isNatPolicyKeyHandle_KeyOrHandle() }

type NatPolicyKeyHandle_PolicyKey struct {
	PolicyKey *NATPolicyKey `protobuf:"bytes,1,opt,name=policy_key,json=policyKey,oneof"`
}
type NatPolicyKeyHandle_PolicyHandle struct {
	PolicyHandle uint64 `protobuf:"fixed64,2,opt,name=policy_handle,json=policyHandle,oneof"`
}

func (*NatPolicyKeyHandle_PolicyKey) isNatPolicyKeyHandle_KeyOrHandle()    {}
func (*NatPolicyKeyHandle_PolicyHandle) isNatPolicyKeyHandle_KeyOrHandle() {}

func (m *NatPolicyKeyHandle) GetKeyOrHandle() isNatPolicyKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatPolicyKeyHandle) GetPolicyKey() *NATPolicyKey {
	if x, ok := m.GetKeyOrHandle().(*NatPolicyKeyHandle_PolicyKey); ok {
		return x.PolicyKey
	}
	return nil
}

func (m *NatPolicyKeyHandle) GetPolicyHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NatPolicyKeyHandle_PolicyHandle); ok {
		return x.PolicyHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NatPolicyKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NatPolicyKeyHandle_OneofMarshaler, _NatPolicyKeyHandle_OneofUnmarshaler, _NatPolicyKeyHandle_OneofSizer, []interface{}{
		(*NatPolicyKeyHandle_PolicyKey)(nil),
		(*NatPolicyKeyHandle_PolicyHandle)(nil),
	}
}

func _NatPolicyKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NatPolicyKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatPolicyKeyHandle_PolicyKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PolicyKey); err != nil {
			return err
		}
	case *NatPolicyKeyHandle_PolicyHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.PolicyHandle))
	case nil:
	default:
		return fmt.Errorf("NatPolicyKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _NatPolicyKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NatPolicyKeyHandle)
	switch tag {
	case 1: // key_or_handle.policy_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NATPolicyKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &NatPolicyKeyHandle_PolicyKey{msg}
		return true, err
	case 2: // key_or_handle.policy_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &NatPolicyKeyHandle_PolicyHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _NatPolicyKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NatPolicyKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatPolicyKeyHandle_PolicyKey:
		s := proto.Size(x.PolicyKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NatPolicyKeyHandle_PolicyHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Svc object identies an app, while a service can run on multiple IPs
// in general case where the service is spread out, an optional IP address
// specified explicitly to nail a service to particular IP where a single
// instance of service is run. Similarlt, port is not mandatory when only
// single instance of service is running on a given IP and nothing else
type Svc struct {
	VrfKh  *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_kh,json=vrfKh" json:"vrf_kh,omitempty"`
	IpAddr *IPAddress    `protobuf:"bytes,2,opt,name=ip_addr,json=ipAddr" json:"ip_addr,omitempty"`
	Port   uint32        `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
}

func (m *Svc) Reset()                    { *m = Svc{} }
func (m *Svc) String() string            { return proto.CompactTextString(m) }
func (*Svc) ProtoMessage()               {}
func (*Svc) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{39} }

func (m *Svc) GetVrfKh() *VrfKeyHandle {
	if m != nil {
		return m.VrfKh
	}
	return nil
}

func (m *Svc) GetIpAddr() *IPAddress {
	if m != nil {
		return m.IpAddr
	}
	return nil
}

func (m *Svc) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// NatMappingKeyHandle uniquely identifies a NAT mapping and is used
// to create/update/delete/get NAT mappings
type NatMappingKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*NatMappingKeyHandle_Svc
	//	*NatMappingKeyHandle_MappingHandle
	KeyOrHandle isNatMappingKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *NatMappingKeyHandle) Reset()                    { *m = NatMappingKeyHandle{} }
func (m *NatMappingKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*NatMappingKeyHandle) ProtoMessage()               {}
func (*NatMappingKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{40} }

type isNatMappingKeyHandle_KeyOrHandle interface{ isNatMappingKeyHandle_KeyOrHandle() }

type NatMappingKeyHandle_Svc struct {
	Svc *Svc `protobuf:"bytes,1,opt,name=svc,oneof"`
}
type NatMappingKeyHandle_MappingHandle struct {
	MappingHandle uint64 `protobuf:"fixed64,2,opt,name=mapping_handle,json=mappingHandle,oneof"`
}

func (*NatMappingKeyHandle_Svc) isNatMappingKeyHandle_KeyOrHandle()           {}
func (*NatMappingKeyHandle_MappingHandle) isNatMappingKeyHandle_KeyOrHandle() {}

func (m *NatMappingKeyHandle) GetKeyOrHandle() isNatMappingKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatMappingKeyHandle) GetSvc() *Svc {
	if x, ok := m.GetKeyOrHandle().(*NatMappingKeyHandle_Svc); ok {
		return x.Svc
	}
	return nil
}

func (m *NatMappingKeyHandle) GetMappingHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*NatMappingKeyHandle_MappingHandle); ok {
		return x.MappingHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NatMappingKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NatMappingKeyHandle_OneofMarshaler, _NatMappingKeyHandle_OneofUnmarshaler, _NatMappingKeyHandle_OneofSizer, []interface{}{
		(*NatMappingKeyHandle_Svc)(nil),
		(*NatMappingKeyHandle_MappingHandle)(nil),
	}
}

func _NatMappingKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NatMappingKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatMappingKeyHandle_Svc:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Svc); err != nil {
			return err
		}
	case *NatMappingKeyHandle_MappingHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.MappingHandle))
	case nil:
	default:
		return fmt.Errorf("NatMappingKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _NatMappingKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NatMappingKeyHandle)
	switch tag {
	case 1: // key_or_handle.svc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Svc)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &NatMappingKeyHandle_Svc{msg}
		return true, err
	case 2: // key_or_handle.mapping_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &NatMappingKeyHandle_MappingHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _NatMappingKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NatMappingKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *NatMappingKeyHandle_Svc:
		s := proto.Size(x.Svc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NatMappingKeyHandle_MappingHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for the IPSec rule policy
type IPSecRuleKey struct {
	IpsecRuleId    uint64        `protobuf:"varint,1,opt,name=ipsec_rule_id,json=ipsecRuleId" json:"ipsec_rule_id,omitempty"`
	VrfKeyOrHandle *VrfKeyHandle `protobuf:"bytes,2,opt,name=vrf_key_or_handle,json=vrfKeyOrHandle" json:"vrf_key_or_handle,omitempty"`
}

func (m *IPSecRuleKey) Reset()                    { *m = IPSecRuleKey{} }
func (m *IPSecRuleKey) String() string            { return proto.CompactTextString(m) }
func (*IPSecRuleKey) ProtoMessage()               {}
func (*IPSecRuleKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{41} }

func (m *IPSecRuleKey) GetIpsecRuleId() uint64 {
	if m != nil {
		return m.IpsecRuleId
	}
	return 0
}

func (m *IPSecRuleKey) GetVrfKeyOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyOrHandle
	}
	return nil
}

// IpsecRuleKeyHandle uniquely identifies a IPSec rule and is used
// to create/update/delete/get IPSec rules
type IpsecRuleKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*IpsecRuleKeyHandle_RuleKey
	//	*IpsecRuleKeyHandle_RuleHandle
	KeyOrHandle isIpsecRuleKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *IpsecRuleKeyHandle) Reset()                    { *m = IpsecRuleKeyHandle{} }
func (m *IpsecRuleKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*IpsecRuleKeyHandle) ProtoMessage()               {}
func (*IpsecRuleKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{42} }

type isIpsecRuleKeyHandle_KeyOrHandle interface{ isIpsecRuleKeyHandle_KeyOrHandle() }

type IpsecRuleKeyHandle_RuleKey struct {
	RuleKey *IPSecRuleKey `protobuf:"bytes,1,opt,name=rule_key,json=ruleKey,oneof"`
}
type IpsecRuleKeyHandle_RuleHandle struct {
	RuleHandle uint64 `protobuf:"fixed64,2,opt,name=rule_handle,json=ruleHandle,oneof"`
}

func (*IpsecRuleKeyHandle_RuleKey) isIpsecRuleKeyHandle_KeyOrHandle()    {}
func (*IpsecRuleKeyHandle_RuleHandle) isIpsecRuleKeyHandle_KeyOrHandle() {}

func (m *IpsecRuleKeyHandle) GetKeyOrHandle() isIpsecRuleKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecRuleKeyHandle) GetRuleKey() *IPSecRuleKey {
	if x, ok := m.GetKeyOrHandle().(*IpsecRuleKeyHandle_RuleKey); ok {
		return x.RuleKey
	}
	return nil
}

func (m *IpsecRuleKeyHandle) GetRuleHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*IpsecRuleKeyHandle_RuleHandle); ok {
		return x.RuleHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpsecRuleKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpsecRuleKeyHandle_OneofMarshaler, _IpsecRuleKeyHandle_OneofUnmarshaler, _IpsecRuleKeyHandle_OneofSizer, []interface{}{
		(*IpsecRuleKeyHandle_RuleKey)(nil),
		(*IpsecRuleKeyHandle_RuleHandle)(nil),
	}
}

func _IpsecRuleKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpsecRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecRuleKeyHandle_RuleKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuleKey); err != nil {
			return err
		}
	case *IpsecRuleKeyHandle_RuleHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.RuleHandle))
	case nil:
	default:
		return fmt.Errorf("IpsecRuleKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _IpsecRuleKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpsecRuleKeyHandle)
	switch tag {
	case 1: // key_or_handle.rule_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSecRuleKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &IpsecRuleKeyHandle_RuleKey{msg}
		return true, err
	case 2: // key_or_handle.rule_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &IpsecRuleKeyHandle_RuleHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _IpsecRuleKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpsecRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecRuleKeyHandle_RuleKey:
		s := proto.Size(x.RuleKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IpsecRuleKeyHandle_RuleHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IpsecSAEncryptKeyHandle uniquely identifies a IPSec CB and is used
// to create/update/delete/get IPSec CBs
type IpsecSAEncryptKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*IpsecSAEncryptKeyHandle_CbId
	//	*IpsecSAEncryptKeyHandle_CbHandle
	KeyOrHandle    isIpsecSAEncryptKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
	VrfKeyOrHandle *VrfKeyHandle                         `protobuf:"bytes,3,opt,name=vrf_key_or_handle,json=vrfKeyOrHandle" json:"vrf_key_or_handle,omitempty"`
}

func (m *IpsecSAEncryptKeyHandle) Reset()                    { *m = IpsecSAEncryptKeyHandle{} }
func (m *IpsecSAEncryptKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*IpsecSAEncryptKeyHandle) ProtoMessage()               {}
func (*IpsecSAEncryptKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{43} }

type isIpsecSAEncryptKeyHandle_KeyOrHandle interface{ isIpsecSAEncryptKeyHandle_KeyOrHandle() }

type IpsecSAEncryptKeyHandle_CbId struct {
	CbId uint64 `protobuf:"varint,1,opt,name=cb_id,json=cbId,oneof"`
}
type IpsecSAEncryptKeyHandle_CbHandle struct {
	CbHandle uint64 `protobuf:"fixed64,2,opt,name=cb_handle,json=cbHandle,oneof"`
}

func (*IpsecSAEncryptKeyHandle_CbId) isIpsecSAEncryptKeyHandle_KeyOrHandle()     {}
func (*IpsecSAEncryptKeyHandle_CbHandle) isIpsecSAEncryptKeyHandle_KeyOrHandle() {}

func (m *IpsecSAEncryptKeyHandle) GetKeyOrHandle() isIpsecSAEncryptKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecSAEncryptKeyHandle) GetCbId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*IpsecSAEncryptKeyHandle_CbId); ok {
		return x.CbId
	}
	return 0
}

func (m *IpsecSAEncryptKeyHandle) GetCbHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*IpsecSAEncryptKeyHandle_CbHandle); ok {
		return x.CbHandle
	}
	return 0
}

func (m *IpsecSAEncryptKeyHandle) GetVrfKeyOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyOrHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpsecSAEncryptKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpsecSAEncryptKeyHandle_OneofMarshaler, _IpsecSAEncryptKeyHandle_OneofUnmarshaler, _IpsecSAEncryptKeyHandle_OneofSizer, []interface{}{
		(*IpsecSAEncryptKeyHandle_CbId)(nil),
		(*IpsecSAEncryptKeyHandle_CbHandle)(nil),
	}
}

func _IpsecSAEncryptKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpsecSAEncryptKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecSAEncryptKeyHandle_CbId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.CbId))
	case *IpsecSAEncryptKeyHandle_CbHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.CbHandle))
	case nil:
	default:
		return fmt.Errorf("IpsecSAEncryptKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _IpsecSAEncryptKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpsecSAEncryptKeyHandle)
	switch tag {
	case 1: // key_or_handle.cb_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &IpsecSAEncryptKeyHandle_CbId{x}
		return true, err
	case 2: // key_or_handle.cb_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &IpsecSAEncryptKeyHandle_CbHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _IpsecSAEncryptKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpsecSAEncryptKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecSAEncryptKeyHandle_CbId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CbId))
	case *IpsecSAEncryptKeyHandle_CbHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IpsecSADecryptKeyHandle uniquely identifies a IPSec CB and is used
// to create/update/delete/get IPSec CBs
type IpsecSADecryptKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*IpsecSADecryptKeyHandle_CbId
	//	*IpsecSADecryptKeyHandle_CbHandle
	KeyOrHandle    isIpsecSADecryptKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
	VrfKeyOrHandle *VrfKeyHandle                         `protobuf:"bytes,3,opt,name=vrf_key_or_handle,json=vrfKeyOrHandle" json:"vrf_key_or_handle,omitempty"`
}

func (m *IpsecSADecryptKeyHandle) Reset()                    { *m = IpsecSADecryptKeyHandle{} }
func (m *IpsecSADecryptKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*IpsecSADecryptKeyHandle) ProtoMessage()               {}
func (*IpsecSADecryptKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{44} }

type isIpsecSADecryptKeyHandle_KeyOrHandle interface{ isIpsecSADecryptKeyHandle_KeyOrHandle() }

type IpsecSADecryptKeyHandle_CbId struct {
	CbId uint64 `protobuf:"varint,1,opt,name=cb_id,json=cbId,oneof"`
}
type IpsecSADecryptKeyHandle_CbHandle struct {
	CbHandle uint64 `protobuf:"fixed64,2,opt,name=cb_handle,json=cbHandle,oneof"`
}

func (*IpsecSADecryptKeyHandle_CbId) isIpsecSADecryptKeyHandle_KeyOrHandle()     {}
func (*IpsecSADecryptKeyHandle_CbHandle) isIpsecSADecryptKeyHandle_KeyOrHandle() {}

func (m *IpsecSADecryptKeyHandle) GetKeyOrHandle() isIpsecSADecryptKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *IpsecSADecryptKeyHandle) GetCbId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*IpsecSADecryptKeyHandle_CbId); ok {
		return x.CbId
	}
	return 0
}

func (m *IpsecSADecryptKeyHandle) GetCbHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*IpsecSADecryptKeyHandle_CbHandle); ok {
		return x.CbHandle
	}
	return 0
}

func (m *IpsecSADecryptKeyHandle) GetVrfKeyOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyOrHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IpsecSADecryptKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IpsecSADecryptKeyHandle_OneofMarshaler, _IpsecSADecryptKeyHandle_OneofUnmarshaler, _IpsecSADecryptKeyHandle_OneofSizer, []interface{}{
		(*IpsecSADecryptKeyHandle_CbId)(nil),
		(*IpsecSADecryptKeyHandle_CbHandle)(nil),
	}
}

func _IpsecSADecryptKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IpsecSADecryptKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecSADecryptKeyHandle_CbId:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.CbId))
	case *IpsecSADecryptKeyHandle_CbHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.CbHandle))
	case nil:
	default:
		return fmt.Errorf("IpsecSADecryptKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _IpsecSADecryptKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IpsecSADecryptKeyHandle)
	switch tag {
	case 1: // key_or_handle.cb_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &IpsecSADecryptKeyHandle_CbId{x}
		return true, err
	case 2: // key_or_handle.cb_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &IpsecSADecryptKeyHandle_CbHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _IpsecSADecryptKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IpsecSADecryptKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *IpsecSADecryptKeyHandle_CbId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CbId))
	case *IpsecSADecryptKeyHandle_CbHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for the TcpProxy rule policy
type TcpProxyRuleKey struct {
	TcpProxyRuleId uint64        `protobuf:"varint,1,opt,name=tcp_proxy_rule_id,json=tcpProxyRuleId" json:"tcp_proxy_rule_id,omitempty"`
	VrfKeyOrHandle *VrfKeyHandle `protobuf:"bytes,2,opt,name=vrf_key_or_handle,json=vrfKeyOrHandle" json:"vrf_key_or_handle,omitempty"`
}

func (m *TcpProxyRuleKey) Reset()                    { *m = TcpProxyRuleKey{} }
func (m *TcpProxyRuleKey) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleKey) ProtoMessage()               {}
func (*TcpProxyRuleKey) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{45} }

func (m *TcpProxyRuleKey) GetTcpProxyRuleId() uint64 {
	if m != nil {
		return m.TcpProxyRuleId
	}
	return 0
}

func (m *TcpProxyRuleKey) GetVrfKeyOrHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyOrHandle
	}
	return nil
}

// TcpProxyRuleKeyHandle uniquely identifies a TcpProxy rule and is used
// to create/update/delete/get TcpProxy rules
type TcpProxyRuleKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*TcpProxyRuleKeyHandle_RuleKey
	//	*TcpProxyRuleKeyHandle_RuleHandle
	KeyOrHandle isTcpProxyRuleKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *TcpProxyRuleKeyHandle) Reset()                    { *m = TcpProxyRuleKeyHandle{} }
func (m *TcpProxyRuleKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyRuleKeyHandle) ProtoMessage()               {}
func (*TcpProxyRuleKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{46} }

type isTcpProxyRuleKeyHandle_KeyOrHandle interface{ isTcpProxyRuleKeyHandle_KeyOrHandle() }

type TcpProxyRuleKeyHandle_RuleKey struct {
	RuleKey *TcpProxyRuleKey `protobuf:"bytes,1,opt,name=rule_key,json=ruleKey,oneof"`
}
type TcpProxyRuleKeyHandle_RuleHandle struct {
	RuleHandle uint64 `protobuf:"fixed64,2,opt,name=rule_handle,json=ruleHandle,oneof"`
}

func (*TcpProxyRuleKeyHandle_RuleKey) isTcpProxyRuleKeyHandle_KeyOrHandle()    {}
func (*TcpProxyRuleKeyHandle_RuleHandle) isTcpProxyRuleKeyHandle_KeyOrHandle() {}

func (m *TcpProxyRuleKeyHandle) GetKeyOrHandle() isTcpProxyRuleKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *TcpProxyRuleKeyHandle) GetRuleKey() *TcpProxyRuleKey {
	if x, ok := m.GetKeyOrHandle().(*TcpProxyRuleKeyHandle_RuleKey); ok {
		return x.RuleKey
	}
	return nil
}

func (m *TcpProxyRuleKeyHandle) GetRuleHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*TcpProxyRuleKeyHandle_RuleHandle); ok {
		return x.RuleHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TcpProxyRuleKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TcpProxyRuleKeyHandle_OneofMarshaler, _TcpProxyRuleKeyHandle_OneofUnmarshaler, _TcpProxyRuleKeyHandle_OneofSizer, []interface{}{
		(*TcpProxyRuleKeyHandle_RuleKey)(nil),
		(*TcpProxyRuleKeyHandle_RuleHandle)(nil),
	}
}

func _TcpProxyRuleKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TcpProxyRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *TcpProxyRuleKeyHandle_RuleKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuleKey); err != nil {
			return err
		}
	case *TcpProxyRuleKeyHandle_RuleHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.RuleHandle))
	case nil:
	default:
		return fmt.Errorf("TcpProxyRuleKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _TcpProxyRuleKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TcpProxyRuleKeyHandle)
	switch tag {
	case 1: // key_or_handle.rule_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpProxyRuleKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &TcpProxyRuleKeyHandle_RuleKey{msg}
		return true, err
	case 2: // key_or_handle.rule_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &TcpProxyRuleKeyHandle_RuleHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _TcpProxyRuleKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TcpProxyRuleKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *TcpProxyRuleKeyHandle_RuleKey:
		s := proto.Size(x.RuleKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TcpProxyRuleKeyHandle_RuleHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QosClassKeyHandle uniquely identifies a QosClass
type QosClassKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*QosClassKeyHandle_QosGroup
	//	*QosClassKeyHandle_QosClassHandle
	KeyOrHandle isQosClassKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *QosClassKeyHandle) Reset()                    { *m = QosClassKeyHandle{} }
func (m *QosClassKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*QosClassKeyHandle) ProtoMessage()               {}
func (*QosClassKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{47} }

type isQosClassKeyHandle_KeyOrHandle interface{ isQosClassKeyHandle_KeyOrHandle() }

type QosClassKeyHandle_QosGroup struct {
	QosGroup QosGroup `protobuf:"varint,1,opt,name=qos_group,json=qosGroup,enum=kh.QosGroup,oneof"`
}
type QosClassKeyHandle_QosClassHandle struct {
	QosClassHandle uint64 `protobuf:"fixed64,2,opt,name=qos_class_handle,json=qosClassHandle,oneof"`
}

func (*QosClassKeyHandle_QosGroup) isQosClassKeyHandle_KeyOrHandle()       {}
func (*QosClassKeyHandle_QosClassHandle) isQosClassKeyHandle_KeyOrHandle() {}

func (m *QosClassKeyHandle) GetKeyOrHandle() isQosClassKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassKeyHandle) GetQosGroup() QosGroup {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosGroup); ok {
		return x.QosGroup
	}
	return QosGroup_DEFAULT
}

func (m *QosClassKeyHandle) GetQosClassHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosClassHandle); ok {
		return x.QosClassHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosClassKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosClassKeyHandle_OneofMarshaler, _QosClassKeyHandle_OneofUnmarshaler, _QosClassKeyHandle_OneofSizer, []interface{}{
		(*QosClassKeyHandle_QosGroup)(nil),
		(*QosClassKeyHandle_QosClassHandle)(nil),
	}
}

func _QosClassKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.QosClassHandle))
	case nil:
	default:
		return fmt.Errorf("QosClassKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _QosClassKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosClassKeyHandle)
	switch tag {
	case 1: // key_or_handle.qos_group
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &QosClassKeyHandle_QosGroup{QosGroup(x)}
		return true, err
	case 2: // key_or_handle.qos_class_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &QosClassKeyHandle_QosClassHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _QosClassKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// CoppKeyHandle uniquely identifies a Copp
type CoppKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*CoppKeyHandle_CoppType
	//	*CoppKeyHandle_CoppHandle
	KeyOrHandle isCoppKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *CoppKeyHandle) Reset()                    { *m = CoppKeyHandle{} }
func (m *CoppKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*CoppKeyHandle) ProtoMessage()               {}
func (*CoppKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{48} }

type isCoppKeyHandle_KeyOrHandle interface{ isCoppKeyHandle_KeyOrHandle() }

type CoppKeyHandle_CoppType struct {
	CoppType CoppType `protobuf:"varint,1,opt,name=copp_type,json=coppType,enum=kh.CoppType,oneof"`
}
type CoppKeyHandle_CoppHandle struct {
	CoppHandle uint64 `protobuf:"fixed64,2,opt,name=copp_handle,json=coppHandle,oneof"`
}

func (*CoppKeyHandle_CoppType) isCoppKeyHandle_KeyOrHandle()   {}
func (*CoppKeyHandle_CoppHandle) isCoppKeyHandle_KeyOrHandle() {}

func (m *CoppKeyHandle) GetKeyOrHandle() isCoppKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppKeyHandle) GetCoppType() CoppType {
	if x, ok := m.GetKeyOrHandle().(*CoppKeyHandle_CoppType); ok {
		return x.CoppType
	}
	return CoppType_COPP_TYPE_FLOW_MISS
}

func (m *CoppKeyHandle) GetCoppHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*CoppKeyHandle_CoppHandle); ok {
		return x.CoppHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CoppKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CoppKeyHandle_OneofMarshaler, _CoppKeyHandle_OneofUnmarshaler, _CoppKeyHandle_OneofSizer, []interface{}{
		(*CoppKeyHandle_CoppType)(nil),
		(*CoppKeyHandle_CoppHandle)(nil),
	}
}

func _CoppKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CoppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppKeyHandle_CoppType:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.CoppType))
	case *CoppKeyHandle_CoppHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.CoppHandle))
	case nil:
	default:
		return fmt.Errorf("CoppKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _CoppKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CoppKeyHandle)
	switch tag {
	case 1: // key_or_handle.copp_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &CoppKeyHandle_CoppType{CoppType(x)}
		return true, err
	case 2: // key_or_handle.copp_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &CoppKeyHandle_CoppHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _CoppKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CoppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppKeyHandle_CoppType:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CoppType))
	case *CoppKeyHandle_CoppHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AppKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*AppKeyHandle_AppId
	//	*AppKeyHandle_AppHandle
	KeyOrHandle isAppKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *AppKeyHandle) Reset()                    { *m = AppKeyHandle{} }
func (m *AppKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*AppKeyHandle) ProtoMessage()               {}
func (*AppKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{49} }

type isAppKeyHandle_KeyOrHandle interface{ isAppKeyHandle_KeyOrHandle() }

type AppKeyHandle_AppId struct {
	AppId uint64 `protobuf:"fixed64,1,opt,name=app_id,json=appId,oneof"`
}
type AppKeyHandle_AppHandle struct {
	AppHandle uint64 `protobuf:"fixed64,2,opt,name=app_handle,json=appHandle,oneof"`
}

func (*AppKeyHandle_AppId) isAppKeyHandle_KeyOrHandle()     {}
func (*AppKeyHandle_AppHandle) isAppKeyHandle_KeyOrHandle() {}

func (m *AppKeyHandle) GetKeyOrHandle() isAppKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AppKeyHandle) GetAppId() uint64 {
	if x, ok := m.GetKeyOrHandle().(*AppKeyHandle_AppId); ok {
		return x.AppId
	}
	return 0
}

func (m *AppKeyHandle) GetAppHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*AppKeyHandle_AppHandle); ok {
		return x.AppHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AppKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AppKeyHandle_OneofMarshaler, _AppKeyHandle_OneofUnmarshaler, _AppKeyHandle_OneofSizer, []interface{}{
		(*AppKeyHandle_AppId)(nil),
		(*AppKeyHandle_AppHandle)(nil),
	}
}

func _AppKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AppKeyHandle_AppId:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.AppId))
	case *AppKeyHandle_AppHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.AppHandle))
	case nil:
	default:
		return fmt.Errorf("AppKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _AppKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AppKeyHandle)
	switch tag {
	case 1: // key_or_handle.app_id
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &AppKeyHandle_AppId{x}
		return true, err
	case 2: // key_or_handle.app_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &AppKeyHandle_AppHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _AppKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AppKeyHandle_AppId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *AppKeyHandle_AppHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SecurityProfileKeyHandle)(nil), "halproto.SecurityProfileKeyHandle")
	proto.RegisterType((*CollectorKeyHandle)(nil), "halproto.CollectorKeyHandle")
	proto.RegisterType((*ExportControlKeyHandle)(nil), "halproto.ExportControlKeyHandle")
	proto.RegisterType((*FlowMonitorRuleKeyHandle)(nil), "halproto.FlowMonitorRuleKeyHandle")
	proto.RegisterType((*DropMonitorRuleKeyHandle)(nil), "halproto.DropMonitorRuleKeyHandle")
	proto.RegisterType((*MirrorSessionKeyHandle)(nil), "halproto.MirrorSessionKeyHandle")
	proto.RegisterType((*VrfKeyHandle)(nil), "halproto.VrfKeyHandle")
	proto.RegisterType((*NetworkKey)(nil), "halproto.NetworkKey")
	proto.RegisterType((*NetworkKeyHandle)(nil), "halproto.NetworkKeyHandle")
	proto.RegisterType((*NexthopKeyHandle)(nil), "halproto.NexthopKeyHandle")
	proto.RegisterType((*RouteKey)(nil), "halproto.RouteKey")
	proto.RegisterType((*RouteKeyHandle)(nil), "halproto.RouteKeyHandle")
	proto.RegisterType((*L2SegmentKeyHandle)(nil), "halproto.L2SegmentKeyHandle")
	proto.RegisterType((*SecurityPolicyKey)(nil), "halproto.SecurityPolicyKey")
	proto.RegisterType((*SecurityPolicyKeyHandle)(nil), "halproto.SecurityPolicyKeyHandle")
	proto.RegisterType((*SecurityGroupPolicyId)(nil), "halproto.SecurityGroupPolicyId")
	proto.RegisterType((*SecurityGroupPolicyKeyHandle)(nil), "halproto.SecurityGroupPolicyKeyHandle")
	proto.RegisterType((*SecurityGroupKeyHandle)(nil), "halproto.SecurityGroupKeyHandle")
	proto.RegisterType((*PortKeyHandle)(nil), "halproto.PortKeyHandle")
	proto.RegisterType((*LifKeyHandle)(nil), "halproto.LifKeyHandle")
	proto.RegisterType((*InterfaceKeyHandle)(nil), "halproto.InterfaceKeyHandle")
	proto.RegisterType((*EndpointL2Key)(nil), "halproto.EndpointL2Key")
	proto.RegisterType((*EndpointL3Key)(nil), "halproto.EndpointL3Key")
	proto.RegisterType((*EndpointKey)(nil), "halproto.EndpointKey")
	proto.RegisterType((*EndpointKeyHandle)(nil), "halproto.EndpointKeyHandle")
	proto.RegisterType((*FilterKey)(nil), "halproto.FilterKey")
	proto.RegisterType((*FilterKeyHandle)(nil), "halproto.FilterKeyHandle")
	proto.RegisterType((*MulticastEntryKeyIP)(nil), "halproto.MulticastEntryKeyIP")
	proto.RegisterType((*MulticastEntryKeyMac)(nil), "halproto.MulticastEntryKeyMac")
	proto.RegisterType((*MulticastEntryKey)(nil), "halproto.MulticastEntryKey")
	proto.RegisterType((*MulticastEntryKeyHandle)(nil), "halproto.MulticastEntryKeyHandle")
	proto.RegisterType((*AclKeyHandle)(nil), "halproto.AclKeyHandle")
	proto.RegisterType((*GftExactMatchProfileKeyHandle)(nil), "halproto.GftExactMatchProfileKeyHandle")
	proto.RegisterType((*GftHeaderTranspositionProfileKeyHandle)(nil), "halproto.GftHeaderTranspositionProfileKeyHandle")
	proto.RegisterType((*GftExactMatchFlowEntryKeyHandle)(nil), "halproto.GftExactMatchFlowEntryKeyHandle")
	proto.RegisterType((*NatPoolKey)(nil), "halproto.NatPoolKey")
	proto.RegisterType((*NatPoolKeyHandle)(nil), "halproto.NatPoolKeyHandle")
	proto.RegisterType((*NATPolicyKey)(nil), "halproto.NATPolicyKey")
	proto.RegisterType((*NatPolicyKeyHandle)(nil), "halproto.NatPolicyKeyHandle")
	proto.RegisterType((*Svc)(nil), "halproto.Svc")
	proto.RegisterType((*NatMappingKeyHandle)(nil), "halproto.NatMappingKeyHandle")
	proto.RegisterType((*IPSecRuleKey)(nil), "halproto.IPSecRuleKey")
	proto.RegisterType((*IpsecRuleKeyHandle)(nil), "halproto.IpsecRuleKeyHandle")
	proto.RegisterType((*IpsecSAEncryptKeyHandle)(nil), "halproto.IpsecSAEncryptKeyHandle")
	proto.RegisterType((*IpsecSADecryptKeyHandle)(nil), "halproto.IpsecSADecryptKeyHandle")
	proto.RegisterType((*TcpProxyRuleKey)(nil), "halproto.TcpProxyRuleKey")
	proto.RegisterType((*TcpProxyRuleKeyHandle)(nil), "halproto.TcpProxyRuleKeyHandle")
	proto.RegisterType((*QosClassKeyHandle)(nil), "halproto.QosClassKeyHandle")
	proto.RegisterType((*CoppKeyHandle)(nil), "halproto.CoppKeyHandle")
	proto.RegisterType((*AppKeyHandle)(nil), "halproto.AppKeyHandle")
	proto.RegisterEnum("halproto.FilterType", FilterType_name, FilterType_value)
	proto.RegisterEnum("halproto.QosGroup", QosGroup_name, QosGroup_value)
	proto.RegisterEnum("halproto.CoppType", CoppType_name, CoppType_value)
}

func init() { proto.RegisterFile("kh.proto", fileDescriptor15) }

var fileDescriptor15 = []byte{
	// 2149 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0x5b, 0x73, 0xdb, 0xc6,
	0x15, 0x26, 0x28, 0x8a, 0x22, 0x0f, 0x6f, 0xe0, 0xea, 0xea, 0x34, 0x1e, 0x27, 0x4c, 0x93, 0x58,
	0x8a, 0xa3, 0xd8, 0x94, 0x1b, 0xcf, 0xa4, 0x4f, 0x14, 0x45, 0x99, 0xa8, 0x29, 0x92, 0x01, 0xe9,
	0xd4, 0xee, 0x43, 0x31, 0x10, 0x08, 0x4a, 0x18, 0x81, 0x00, 0x0c, 0x40, 0x94, 0xd8, 0x8e, 0x27,
	0x9d, 0x76, 0xda, 0xe9, 0xf5, 0xb1, 0x3f, 0xa0, 0x2f, 0x7d, 0x6b, 0x1f, 0xda, 0x1f, 0xd2, 0x87,
	0xbe, 0xfb, 0x47, 0xf8, 0x17, 0x74, 0x76, 0x17, 0xd7, 0x05, 0xa1, 0xba, 0x89, 0xa7, 0x9d, 0x3e,
	0x09, 0x3c, 0xd7, 0x6f, 0xcf, 0x9e, 0x3d, 0xe7, 0xec, 0x0a, 0x0a, 0x17, 0xe7, 0xfb, 0x96, 0x6d,
	0xba, 0x26, 0xca, 0x5e, 0x9c, 0xbf, 0x53, 0x72, 0x17, 0x96, 0xea, 0x50, 0x42, 0xe3, 0x12, 0x76,
	0x46, 0xaa, 0x72, 0x69, 0x6b, 0xee, 0x62, 0x68, 0x9b, 0x53, 0x4d, 0x57, 0x9f, 0xa8, 0x8b, 0xae,
	0x6c, 0x4c, 0x74, 0x15, 0xdd, 0x01, 0xb0, 0x28, 0x4d, 0xd2, 0x26, 0x3b, 0xdc, 0x7b, 0xdc, 0xdd,
	0x4a, 0x37, 0x23, 0x16, 0x3d, 0x9a, 0x30, 0x41, 0x1f, 0x43, 0xd5, 0x17, 0x38, 0x27, 0x2a, 0x3b,
	0xd9, 0xf7, 0xb8, 0xbb, 0xf9, 0x6e, 0x46, 0xac, 0x78, 0x74, 0x6a, 0xe9, 0xb0, 0x06, 0x95, 0x0b,
	0x75, 0x21, 0x99, 0xb6, 0x27, 0xd7, 0xb8, 0x02, 0xd4, 0x36, 0x75, 0x5d, 0x55, 0x5c, 0xd3, 0x0e,
	0x1d, 0x7e, 0x00, 0x65, 0xc5, 0xa7, 0xfa, 0x2e, 0x73, 0xdd, 0x8c, 0x58, 0x0a, 0xa8, 0xc2, 0x04,
	0x7d, 0x02, 0x7c, 0x28, 0xc4, 0xb8, 0xad, 0x05, 0x9c, 0x34, 0xc7, 0xbf, 0xe3, 0x60, 0xab, 0x73,
	0x6d, 0x99, 0xb6, 0xdb, 0x36, 0x0d, 0xd7, 0x36, 0xf5, 0xd0, 0xfb, 0x27, 0xc0, 0xab, 0x84, 0xa3,
	0x50, 0x4e, 0x14, 0x41, 0x2d, 0xc6, 0x11, 0x26, 0xe8, 0x00, 0x36, 0xe2, 0xc2, 0x0c, 0x92, 0xf5,
	0x18, 0x37, 0x0d, 0xcd, 0x5f, 0x39, 0xd8, 0x39, 0xd6, 0xcd, 0xab, 0x13, 0xd3, 0xd0, 0x5c, 0xd3,
	0x16, 0x2f, 0xa3, 0xe1, 0xef, 0x02, 0x9a, 0xea, 0xe6, 0xd5, 0x8c, 0xf2, 0xec, 0xcb, 0x70, 0x1b,
	0x72, 0x87, 0xdb, 0xaf, 0x5f, 0xdd, 0x59, 0x9f, 0xab, 0x86, 0xa6, 0xa8, 0x5f, 0xd8, 0xb2, 0x71,
	0xa6, 0x7e, 0x71, 0xff, 0xd3, 0x07, 0xf7, 0x9b, 0x0f, 0xbb, 0x19, 0xb1, 0xce, 0x28, 0x09, 0x13,
	0xf4, 0x08, 0xb6, 0x58, 0x4b, 0x0c, 0xdc, 0x4d, 0x86, 0x9f, 0x06, 0xf8, 0x8f, 0x1c, 0xec, 0x1c,
	0xd9, 0xa6, 0xb5, 0x14, 0xf0, 0x67, 0x80, 0x26, 0xb6, 0x69, 0x2d, 0x03, 0x8c, 0x71, 0x31, 0x3c,
	0x8a, 0x8b, 0x55, 0x60, 0x71, 0x31, 0xfc, 0x34, 0x5c, 0x7f, 0xe2, 0x60, 0xeb, 0x44, 0xb3, 0x6d,
	0xd3, 0x1e, 0xa9, 0x8e, 0xa3, 0x99, 0x46, 0x88, 0xaa, 0x05, 0xfc, 0x8c, 0x70, 0x1c, 0xca, 0x09,
	0x83, 0xb8, 0xf1, 0xfa, 0xd5, 0x1d, 0x9e, 0x09, 0xe2, 0x23, 0xbc, 0xd9, 0x31, 0x79, 0xba, 0xd9,
	0x71, 0x13, 0xec, 0x66, 0xc7, 0xb8, 0x69, 0x18, 0x9f, 0x43, 0xf9, 0x2b, 0x7b, 0x1a, 0x02, 0xdb,
	0x86, 0xfc, 0xdc, 0x9e, 0x46, 0x43, 0xb4, 0x3a, 0xb7, 0xa7, 0xc2, 0x04, 0x9f, 0x3b, 0xcc, 0x60,
	0x9c, 0x14, 0xe7, 0xf6, 0x34, 0xcd, 0xf4, 0xcf, 0x39, 0x80, 0xbe, 0xea, 0x5e, 0x99, 0xf6, 0xc5,
	0x13, 0x75, 0x81, 0x8e, 0xa1, 0x8a, 0x0d, 0x60, 0x19, 0xcf, 0x08, 0xf6, 0x50, 0x6a, 0xf2, 0xfb,
	0x17, 0xe7, 0xfb, 0x51, 0x0c, 0x87, 0xd5, 0xd7, 0xaf, 0xee, 0x80, 0x1f, 0x02, 0x75, 0x2a, 0x96,
	0xe7, 0x51, 0x84, 0xf7, 0xa0, 0xa8, 0x59, 0x92, 0x65, 0xab, 0x53, 0xed, 0x9a, 0xe0, 0x28, 0x35,
	0x6b, 0xfb, 0xb4, 0x7a, 0x08, 0xc3, 0x21, 0x21, 0x8b, 0x05, 0xcd, 0xa2, 0x5f, 0x8d, 0x0b, 0xe0,
	0x43, 0x0c, 0x9e, 0x85, 0x8f, 0x21, 0x6f, 0x5c, 0x61, 0x20, 0x1e, 0x82, 0x2a, 0x46, 0x10, 0x91,
	0xca, 0x88, 0xab, 0xc6, 0x15, 0x86, 0x7c, 0x1b, 0x8a, 0xc6, 0x15, 0xbb, 0xe4, 0x82, 0x71, 0x95,
	0xb6, 0xe2, 0x19, 0x76, 0x76, 0xed, 0x9e, 0x9b, 0x56, 0xac, 0x5e, 0x19, 0x94, 0x16, 0x0d, 0x6a,
	0xd1, 0xa3, 0xd1, 0x7a, 0xe5, 0x0b, 0xb0, 0xf5, 0xca, 0xa3, 0xa7, 0xb9, 0xfb, 0x19, 0x07, 0x05,
	0xd1, 0xbc, 0x74, 0xd5, 0xff, 0x5d, 0x78, 0x1d, 0xa8, 0xfa, 0x08, 0x82, 0x82, 0x55, 0xb4, 0x31,
	0x25, 0x12, 0xdf, 0x32, 0x86, 0x10, 0x88, 0x65, 0xc4, 0x82, 0xed, 0x83, 0xfe, 0x00, 0xca, 0x54,
	0x98, 0x59, 0x79, 0x89, 0x50, 0xd3, 0xd6, 0xed, 0x00, 0xea, 0x35, 0x47, 0xea, 0xd9, 0x4c, 0x35,
	0xdc, 0x58, 0xa0, 0x1d, 0x4a, 0x8b, 0x05, 0xda, 0xa3, 0xd1, 0x1a, 0xad, 0x37, 0x7d, 0x11, 0xb6,
	0x46, 0x07, 0x9c, 0x34, 0xa7, 0xbf, 0xe7, 0xa0, 0x1e, 0x34, 0x25, 0x53, 0xd7, 0x94, 0x05, 0x5e,
	0xc0, 0x3d, 0x40, 0x8e, 0x47, 0x94, 0x2c, 0x42, 0x0d, 0x9c, 0x8b, 0xbc, 0x13, 0x13, 0x17, 0x26,
	0x48, 0x00, 0x9e, 0x1e, 0x2e, 0x29, 0xde, 0x25, 0xde, 0x64, 0x97, 0x2a, 0xe4, 0x18, 0x0e, 0xbc,
	0x1e, 0xd2, 0xf8, 0x1b, 0x07, 0xdb, 0x09, 0x38, 0x5e, 0x24, 0x1e, 0xc3, 0x3a, 0x0b, 0x2a, 0xdc,
	0x8c, 0x4d, 0xec, 0x29, 0xa9, 0x99, 0x11, 0xeb, 0x4e, 0x62, 0x75, 0x9f, 0xc3, 0x16, 0x6b, 0x88,
	0x89, 0xdb, 0x46, 0x5c, 0xc9, 0xc3, 0xbe, 0x05, 0x1b, 0xa1, 0xdf, 0x48, 0x0c, 0xaf, 0x61, 0xd3,
	0xf7, 0xfc, 0xd8, 0x36, 0x2f, 0xad, 0x20, 0x30, 0x7b, 0x10, 0x78, 0x97, 0xce, 0x30, 0x27, 0x8c,
	0x62, 0xcd, 0x89, 0x6a, 0x90, 0xba, 0xb7, 0x65, 0xa9, 0xaa, 0x2d, 0x25, 0x15, 0xb2, 0x44, 0x61,
	0x1d, 0x73, 0x47, 0x71, 0xa5, 0xc6, 0x3f, 0x38, 0x78, 0x77, 0x89, 0xeb, 0x30, 0x66, 0x63, 0xd8,
	0x61, 0x0c, 0xc6, 0xb7, 0xb3, 0xd4, 0xbc, 0x15, 0x0d, 0x5c, 0x0c, 0x3e, 0x6e, 0x09, 0xce, 0xd2,
	0x75, 0xb5, 0xe0, 0xdd, 0xe5, 0x56, 0x99, 0x30, 0xde, 0x5a, 0xa2, 0xfe, 0x6f, 0x62, 0xf9, 0x07,
	0x0e, 0xb6, 0x62, 0x68, 0xa2, 0x47, 0x38, 0x2d, 0x9a, 0x38, 0xd3, 0xd9, 0x78, 0x3e, 0x84, 0x4d,
	0x46, 0x9a, 0x6d, 0x24, 0x31, 0x8d, 0xb4, 0xf3, 0xf1, 0x63, 0xa8, 0x0c, 0x4d, 0x3b, 0x72, 0x1e,
	0x6f, 0xc1, 0x1a, 0x1e, 0x36, 0x7c, 0xdf, 0x6b, 0xdd, 0x8c, 0x98, 0xc7, 0x04, 0x61, 0x82, 0xde,
	0x87, 0x12, 0x61, 0x31, 0x8e, 0x00, 0x13, 0x6f, 0x68, 0x54, 0x3d, 0x2d, 0xde, 0xa8, 0x74, 0x2d,
	0x68, 0x54, 0x58, 0x7d, 0x55, 0xd7, 0xbc, 0x46, 0x85, 0x19, 0x6c, 0xa3, 0xd2, 0xb5, 0xd4, 0x46,
	0xa5, 0x01, 0x12, 0x0c, 0x57, 0xb5, 0xa7, 0xb2, 0xa2, 0xc6, 0xe6, 0x3e, 0xcd, 0xa7, 0x46, 0xdd,
	0x94, 0x02, 0xaa, 0x30, 0xc1, 0x1d, 0x22, 0xe9, 0xab, 0x90, 0xee, 0xea, 0xb7, 0x1c, 0x54, 0x3a,
	0xc6, 0xc4, 0x32, 0x35, 0xc3, 0xed, 0x35, 0xf1, 0x19, 0x7b, 0x06, 0x1b, 0x61, 0x55, 0x4a, 0x54,
	0xef, 0x2d, 0x9c, 0x74, 0xc9, 0x62, 0x97, 0xa8, 0x0e, 0x28, 0xb0, 0x11, 0x2d, 0x88, 0xa5, 0x99,
	0xac, 0x48, 0xf2, 0x64, 0x62, 0xab, 0x8e, 0xe3, 0x9d, 0x0e, 0x98, 0xc9, 0x4a, 0x8b, 0x52, 0x1a,
	0xbf, 0x8e, 0x82, 0x39, 0x78, 0x9b, 0x4d, 0xe4, 0x33, 0x00, 0xcd, 0x8a, 0x79, 0xc6, 0x36, 0xfc,
	0x2e, 0xe2, 0xf9, 0x17, 0x8b, 0x9a, 0xe5, 0x43, 0xf9, 0x29, 0x94, 0x7c, 0x24, 0x18, 0xc7, 0x1e,
	0xe4, 0xf5, 0x66, 0xa4, 0x68, 0xd5, 0xb1, 0xff, 0x58, 0xdc, 0xc8, 0x7e, 0x37, 0x7d, 0xd9, 0x03,
	0x22, 0x9b, 0x5d, 0x22, 0x7b, 0xe0, 0xcb, 0xe2, 0x8f, 0xc3, 0x0d, 0x40, 0xaa, 0xc7, 0x91, 0xf4,
	0xa6, 0x44, 0xf5, 0x1a, 0xbf, 0xe4, 0xa0, 0x1e, 0xf1, 0xee, 0xad, 0xe1, 0x21, 0x94, 0x03, 0xd9,
	0x10, 0x49, 0x2d, 0x6a, 0x9d, 0xda, 0x2e, 0xa9, 0x11, 0xe4, 0xbb, 0x50, 0x0b, 0xb4, 0x98, 0xb4,
	0xa8, 0xfa, 0x8c, 0xb4, 0xe4, 0xf8, 0x33, 0x07, 0xc5, 0x63, 0x4d, 0x77, 0x55, 0x7c, 0xfb, 0x40,
	0xdf, 0x87, 0x3a, 0xce, 0xe3, 0x98, 0x48, 0x74, 0x3b, 0xa2, 0xa7, 0x41, 0xac, 0xea, 0xe4, 0x97,
	0xdf, 0x1e, 0x50, 0x03, 0x72, 0x38, 0xda, 0xc4, 0x77, 0x95, 0x0e, 0x38, 0xd4, 0xf2, 0x78, 0x61,
	0xa9, 0x22, 0xe1, 0xb1, 0xf9, 0xb1, 0xc2, 0xe6, 0x07, 0xda, 0x86, 0xb5, 0xb9, 0x2e, 0x93, 0xd9,
	0x34, 0x87, 0xef, 0x59, 0x62, 0x1e, 0xff, 0x14, 0x26, 0x8d, 0x05, 0xd4, 0x02, 0x9c, 0x9e, 0xc3,
	0x7d, 0x80, 0x29, 0x21, 0x45, 0x62, 0x55, 0x09, 0xdd, 0xd2, 0x48, 0x15, 0xa7, 0xc1, 0xea, 0x3e,
	0x84, 0x8a, 0x27, 0xcf, 0x44, 0xa9, 0x4c, 0xc9, 0x69, 0x31, 0x3a, 0x83, 0xf5, 0x93, 0x4b, 0xdd,
	0xd5, 0x14, 0xd9, 0x71, 0x3b, 0x86, 0x6b, 0xe3, 0x12, 0x2e, 0x0c, 0xd1, 0x5d, 0xc8, 0x3b, 0xe6,
	0xa5, 0xad, 0x84, 0x11, 0x62, 0x93, 0xcd, 0xe3, 0xa3, 0x8f, 0x60, 0x95, 0x54, 0xb9, 0xd4, 0xac,
	0xa4, 0xec, 0xc6, 0x3d, 0xd8, 0x48, 0x38, 0x3a, 0x91, 0x15, 0xb4, 0xe1, 0xeb, 0x93, 0x7a, 0xe0,
	0x4b, 0xff, 0x93, 0x83, 0x7a, 0x42, 0x1c, 0xed, 0x42, 0x56, 0xb3, 0x3c, 0x44, 0xdb, 0x38, 0x18,
	0x4b, 0xa0, 0x77, 0x33, 0x62, 0x56, 0xb3, 0xd0, 0x3d, 0x58, 0x99, 0xc9, 0x8a, 0x07, 0x6a, 0x67,
	0xa9, 0xec, 0x89, 0xac, 0x74, 0x33, 0x22, 0x16, 0x4b, 0x2d, 0x1a, 0x2b, 0xdf, 0xb6, 0x68, 0x1c,
	0x96, 0xc8, 0xf8, 0x67, 0xda, 0xd2, 0x4c, 0x56, 0xf0, 0x04, 0xbf, 0x9d, 0x80, 0xe1, 0x6d, 0xf8,
	0x2e, 0xac, 0x30, 0x43, 0x45, 0x52, 0x32, 0x23, 0x62, 0x19, 0x3c, 0x78, 0xcd, 0x7c, 0x5e, 0x62,
	0xf0, 0x0a, 0x38, 0x37, 0x14, 0xfe, 0x96, 0xa2, 0xc7, 0x0a, 0xbf, 0xac, 0xe8, 0xd1, 0xb6, 0xb2,
	0x2a, 0x2b, 0x3a, 0x2d, 0xfc, 0x98, 0xc1, 0x16, 0x7e, 0x59, 0x49, 0xbd, 0xe9, 0xfe, 0x04, 0x6e,
	0x3f, 0x9e, 0xba, 0x9d, 0x6b, 0x59, 0x71, 0x4f, 0x64, 0x57, 0x39, 0x7f, 0x83, 0xc7, 0x86, 0xdc,
	0xdb, 0x7a, 0x6c, 0xf8, 0x05, 0x07, 0x1f, 0x3d, 0x9e, 0xba, 0x5d, 0x55, 0x9e, 0xa8, 0xf6, 0xd8,
	0x96, 0x0d, 0xc7, 0x32, 0x1d, 0xcd, 0xd5, 0x4c, 0xe3, 0xbf, 0x89, 0xe2, 0x57, 0x1c, 0xdc, 0x89,
	0x85, 0x00, 0x5f, 0xfc, 0x99, 0x9d, 0xfe, 0x2e, 0x54, 0xf0, 0x45, 0x5c, 0x52, 0x31, 0x39, 0xf6,
	0x02, 0x32, 0xf5, 0x85, 0x85, 0x09, 0x1e, 0x3a, 0x22, 0x52, 0xec, 0x2e, 0x07, 0x92, 0xe9, 0xe3,
	0x03, 0xf4, 0x65, 0x77, 0x68, 0x92, 0xb7, 0x0f, 0xf4, 0x88, 0xde, 0x42, 0x2f, 0xce, 0xdf, 0xb8,
	0xff, 0xe0, 0x5b, 0xea, 0x93, 0x73, 0x5c, 0xb2, 0x2c, 0x93, 0xbe, 0x92, 0xd0, 0x7e, 0x97, 0xc7,
	0x3f, 0x85, 0x49, 0xc3, 0x01, 0x3e, 0xb4, 0x1f, 0x5c, 0x55, 0x0a, 0x44, 0x98, 0xbd, 0x09, 0x86,
	0x72, 0x19, 0x91, 0x98, 0xc3, 0x90, 0xc8, 0xcc, 0x92, 0x7c, 0x52, 0x01, 0x4c, 0x4c, 0x5b, 0xd4,
	0xd7, 0x50, 0xee, 0xb7, 0xc6, 0xe1, 0x3c, 0xdd, 0x80, 0x8a, 0x21, 0xbb, 0x89, 0x8b, 0x42, 0xc9,
	0xc0, 0x1e, 0xbd, 0x91, 0xf1, 0x09, 0xd4, 0xfd, 0x16, 0xfc, 0x9f, 0x5f, 0x12, 0xaa, 0xb4, 0x0b,
	0x07, 0xb7, 0x84, 0xaf, 0x01, 0xf5, 0x7d, 0xdb, 0xe1, 0xba, 0x1f, 0x00, 0x24, 0xae, 0x05, 0xc4,
	0x76, 0x14, 0x2c, 0xc9, 0xb0, 0x00, 0xf9, 0x87, 0x50, 0x59, 0x3e, 0xb9, 0x96, 0xad, 0xe8, 0xb0,
	0x9a, 0x88, 0xc0, 0x4b, 0x58, 0x19, 0xcd, 0x95, 0x6f, 0xbe, 0x9f, 0xbb, 0xb0, 0xe6, 0x0d, 0x12,
	0xa9, 0xf5, 0x3a, 0x4f, 0xa7, 0x08, 0x84, 0x20, 0x87, 0xe7, 0x47, 0x52, 0x03, 0x2b, 0x22, 0xf9,
	0x6e, 0xe8, 0xb0, 0xde, 0x97, 0xdd, 0x13, 0xd9, 0xb2, 0x34, 0xe3, 0x2c, 0x0c, 0xc0, 0x77, 0x60,
	0xc5, 0x99, 0x2b, 0x1e, 0x96, 0x35, 0x32, 0xd7, 0xcf, 0x49, 0x6d, 0x75, 0xe6, 0x0a, 0x3e, 0x4c,
	0x33, 0xaa, 0x90, 0x38, 0x4c, 0x1e, 0xfd, 0x86, 0xed, 0x16, 0x86, 0x23, 0x55, 0xf1, 0x1e, 0xa0,
	0xf0, 0x76, 0x6b, 0x96, 0xa3, 0x2a, 0x52, 0xec, 0xd5, 0x49, 0x2c, 0x11, 0xa2, 0x48, 0x5f, 0x9b,
	0xde, 0xea, 0x76, 0x5f, 0x01, 0x12, 0x7c, 0xdb, 0xe1, 0x6a, 0x3f, 0x85, 0x02, 0x01, 0xc0, 0x6c,
	0x76, 0x14, 0x2a, 0x4e, 0x74, 0xdb, 0x43, 0xfd, 0x3e, 0x94, 0x96, 0x3d, 0x7a, 0xc1, 0x4d, 0x2f,
	0x5d, 0x7f, 0xe1, 0x60, 0x9b, 0x78, 0x1e, 0xb5, 0x3a, 0x86, 0x62, 0x2f, 0xac, 0xc8, 0x1c, 0xb5,
	0x09, 0xab, 0xca, 0x69, 0xb4, 0x6c, 0xe4, 0x94, 0x53, 0x3a, 0x39, 0x2b, 0xa7, 0x89, 0xc9, 0x59,
	0x39, 0xf5, 0xb4, 0x96, 0xc6, 0x65, 0xe5, 0x9b, 0xc5, 0xe5, 0x46, 0xbc, 0x47, 0xea, 0xff, 0x01,
	0xde, 0xdf, 0x70, 0x50, 0x1b, 0x2b, 0xd6, 0xd0, 0x36, 0xaf, 0x17, 0x7e, 0x76, 0xed, 0x42, 0xdd,
	0x55, 0x2c, 0xc9, 0xc2, 0x34, 0x26, 0xc3, 0xaa, 0x6e, 0x44, 0xf6, 0x6d, 0x27, 0xd9, 0x4b, 0xd8,
	0x64, 0xa0, 0x78, 0x21, 0xb8, 0x9f, 0xc8, 0xb3, 0x75, 0x6c, 0x9c, 0x15, 0xfe, 0x96, 0xa9, 0xf6,
	0x12, 0xea, 0x5f, 0x9a, 0x4e, 0x5b, 0x97, 0x1d, 0x27, 0xf6, 0xe8, 0xf4, 0xc2, 0x74, 0xa4, 0x70,
	0x30, 0xab, 0xd2, 0x47, 0xa7, 0x2f, 0x4d, 0x87, 0x5e, 0x5a, 0x33, 0x62, 0xe1, 0x85, 0xf7, 0x8d,
	0xf6, 0x80, 0xc7, 0xc2, 0x0a, 0x36, 0x91, 0x98, 0xd1, 0x5f, 0x78, 0xb6, 0xd3, 0xdc, 0x5b, 0x50,
	0x69, 0x9b, 0x96, 0x15, 0x73, 0xad, 0x98, 0x96, 0x25, 0x91, 0x71, 0x3b, 0xe2, 0x1a, 0x4b, 0xe1,
	0x61, 0x9b, 0x64, 0x89, 0xf7, 0x8d, 0x17, 0x4c, 0x84, 0xd9, 0x05, 0x63, 0xe2, 0x4d, 0xf3, 0x4f,
	0xd4, 0x21, 0x9e, 0x7f, 0x2c, 0x2b, 0x76, 0xf1, 0x95, 0x2d, 0xcb, 0x9b, 0x7f, 0x92, 0xb6, 0x8b,
	0x72, 0xaa, 0xe9, 0x3d, 0x13, 0x20, 0xbc, 0x15, 0xa0, 0x1a, 0x94, 0x8e, 0x85, 0xde, 0xb8, 0x23,
	0x4a, 0xfd, 0x41, 0xbf, 0xc3, 0x67, 0x50, 0x15, 0xc0, 0x23, 0xf4, 0x84, 0x63, 0x9e, 0x43, 0x08,
	0xaa, 0xe1, 0x6f, 0xe9, 0xa4, 0xd5, 0xe6, 0xb3, 0x68, 0x1d, 0x6a, 0x11, 0xda, 0x57, 0xbd, 0x56,
	0x9f, 0x5f, 0x41, 0xdb, 0xb0, 0x1e, 0x17, 0xa4, 0x8c, 0xdc, 0xde, 0xdf, 0xb3, 0x50, 0xf0, 0xf7,
	0x04, 0x95, 0x60, 0xed, 0xa8, 0x73, 0xdc, 0x7a, 0xda, 0x1b, 0xf3, 0x19, 0x6c, 0xfb, 0xe9, 0xa8,
	0x23, 0x4a, 0x47, 0x9d, 0x63, 0xa1, 0xdf, 0x39, 0x92, 0x1e, 0x50, 0x7f, 0x31, 0x5a, 0x93, 0xcf,
	0x26, 0x68, 0x07, 0xfc, 0x4a, 0x82, 0xf6, 0x90, 0xcf, 0x25, 0x68, 0xdf, 0xe3, 0x57, 0x13, 0xb4,
	0xcf, 0xf9, 0x3c, 0x06, 0xd1, 0x1e, 0xf4, 0xc7, 0xe2, 0xa0, 0xc7, 0xaf, 0xa1, 0x02, 0xe4, 0x46,
	0xc3, 0x56, 0x9f, 0x2f, 0xa0, 0xdb, 0x70, 0x4b, 0xe8, 0x8f, 0x3b, 0x62, 0xbf, 0xd5, 0x93, 0xc4,
	0x67, 0xd2, 0x50, 0x1c, 0x3c, 0x7b, 0x2e, 0xf5, 0x07, 0xd2, 0x91, 0x38, 0x18, 0xf2, 0x45, 0xf4,
	0x0e, 0x6c, 0x25, 0xd9, 0x84, 0x07, 0x31, 0xd5, 0x31, 0xab, 0x5a, 0x8a, 0xa9, 0x8e, 0x63, 0xaa,
	0x65, 0xb4, 0x09, 0xf5, 0x80, 0xd7, 0x1e, 0x3e, 0x95, 0xda, 0x83, 0xe1, 0x73, 0xbe, 0xb2, 0xf7,
	0x03, 0x28, 0xf8, 0xd9, 0x84, 0x43, 0xdb, 0x1e, 0x0c, 0x87, 0xd2, 0xf8, 0xf9, 0xb0, 0x23, 0x1d,
	0xf7, 0x06, 0x3f, 0x94, 0x4e, 0x84, 0xd1, 0x88, 0xcf, 0xa0, 0x3a, 0x54, 0x42, 0x46, 0x4b, 0x1c,
	0xd2, 0xf8, 0x85, 0xa4, 0xa3, 0x6e, 0x7b, 0xc8, 0x67, 0x0f, 0xe1, 0x47, 0x85, 0x73, 0x59, 0x27,
	0xff, 0x66, 0x3b, 0xcd, 0x93, 0x3f, 0x07, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xec, 0x43, 0x53,
	0xac, 0x8a, 0x1b, 0x00, 0x00,
}
