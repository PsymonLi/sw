// Code generated by protoc-gen-go. DO NOT EDIT.
// source: session.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Types of NAT
type NatType int32

const (
	NatType_NAT_TYPE_NONE      NatType = 0
	NatType_NAT_TYPE_SNAT      NatType = 1
	NatType_NAT_TYPE_DNAT      NatType = 2
	NatType_NAT_TYPE_TWICE_NAT NatType = 3
)

var NatType_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_SNAT",
	2: "NAT_TYPE_DNAT",
	3: "NAT_TYPE_TWICE_NAT",
}
var NatType_value = map[string]int32{
	"NAT_TYPE_NONE":      0,
	"NAT_TYPE_SNAT":      1,
	"NAT_TYPE_DNAT":      2,
	"NAT_TYPE_TWICE_NAT": 3,
}

func (x NatType) String() string {
	return proto.EnumName(NatType_name, int32(x))
}
func (NatType) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{0} }

// Flow actions
type FlowAction int32

const (
	FlowAction_FLOW_ACTION_NONE  FlowAction = 0
	FlowAction_FLOW_ACTION_ALLOW FlowAction = 1
	FlowAction_FLOW_ACTION_DROP  FlowAction = 2
)

var FlowAction_name = map[int32]string{
	0: "FLOW_ACTION_NONE",
	1: "FLOW_ACTION_ALLOW",
	2: "FLOW_ACTION_DROP",
}
var FlowAction_value = map[string]int32{
	"FLOW_ACTION_NONE":  0,
	"FLOW_ACTION_ALLOW": 1,
	"FLOW_ACTION_DROP":  2,
}

func (x FlowAction) String() string {
	return proto.EnumName(FlowAction_name, int32(x))
}
func (FlowAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{1} }

// Flow TCP states
// TODO: Srini, please define all other states
type FlowTCPState int32

const (
	FlowTCPState_FLOW_TCP_STATE_INIT           FlowTCPState = 0
	FlowTCPState_FLOW_TCP_STATE_SYN_RCVD       FlowTCPState = 1
	FlowTCPState_FLOW_TCP_STATE_ACK_RCVD       FlowTCPState = 2
	FlowTCPState_FLOW_TCP_STATE_SYN_ACK_RCVD   FlowTCPState = 3
	FlowTCPState_FLOW_TCP_STATE_ESTABLISHED    FlowTCPState = 4
	FlowTCPState_FLOW_TCP_STATE_FIN_RCVD       FlowTCPState = 5
	FlowTCPState_FLOW_TCP_STATE_BIDIR_FIN_RCVD FlowTCPState = 6
	FlowTCPState_FLOW_TCP_STATE_RESET          FlowTCPState = 7
)

var FlowTCPState_name = map[int32]string{
	0: "FLOW_TCP_STATE_INIT",
	1: "FLOW_TCP_STATE_SYN_RCVD",
	2: "FLOW_TCP_STATE_ACK_RCVD",
	3: "FLOW_TCP_STATE_SYN_ACK_RCVD",
	4: "FLOW_TCP_STATE_ESTABLISHED",
	5: "FLOW_TCP_STATE_FIN_RCVD",
	6: "FLOW_TCP_STATE_BIDIR_FIN_RCVD",
	7: "FLOW_TCP_STATE_RESET",
}
var FlowTCPState_value = map[string]int32{
	"FLOW_TCP_STATE_INIT":           0,
	"FLOW_TCP_STATE_SYN_RCVD":       1,
	"FLOW_TCP_STATE_ACK_RCVD":       2,
	"FLOW_TCP_STATE_SYN_ACK_RCVD":   3,
	"FLOW_TCP_STATE_ESTABLISHED":    4,
	"FLOW_TCP_STATE_FIN_RCVD":       5,
	"FLOW_TCP_STATE_BIDIR_FIN_RCVD": 6,
	"FLOW_TCP_STATE_RESET":          7,
}

func (x FlowTCPState) String() string {
	return proto.EnumName(FlowTCPState_name, int32(x))
}
func (FlowTCPState) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{2} }

// App Types ... In sync with p4/nw/include/defines.h
// TODO: Revisit once we decide if flow drives app_id or service_lif
type FlowType int32

const (
	FlowType_FLOW_TYPE_NONE        FlowType = 0
	FlowType_FLOW_TYPE_CLASSIC_NIC FlowType = 1
	FlowType_FLOW_TYPE_RDMA        FlowType = 2
	FlowType_FLOW_TYPE_TCPTLS      FlowType = 3
	FlowType_FLOW_TYPE_IPSEC       FlowType = 4
	FlowType_FLOW_TYPE_NDE         FlowType = 5
	FlowType_FLOW_TYPE_STORAGE     FlowType = 6
	FlowType_FLOW_TYPE_TELEMETRY   FlowType = 7
)

var FlowType_name = map[int32]string{
	0: "FLOW_TYPE_NONE",
	1: "FLOW_TYPE_CLASSIC_NIC",
	2: "FLOW_TYPE_RDMA",
	3: "FLOW_TYPE_TCPTLS",
	4: "FLOW_TYPE_IPSEC",
	5: "FLOW_TYPE_NDE",
	6: "FLOW_TYPE_STORAGE",
	7: "FLOW_TYPE_TELEMETRY",
}
var FlowType_value = map[string]int32{
	"FLOW_TYPE_NONE":        0,
	"FLOW_TYPE_CLASSIC_NIC": 1,
	"FLOW_TYPE_RDMA":        2,
	"FLOW_TYPE_TCPTLS":      3,
	"FLOW_TYPE_IPSEC":       4,
	"FLOW_TYPE_NDE":         5,
	"FLOW_TYPE_STORAGE":     6,
	"FLOW_TYPE_TELEMETRY":   7,
}

func (x FlowType) String() string {
	return proto.EnumName(FlowType_name, int32(x))
}
func (FlowType) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{3} }

// flow instance primary vs secondary
type FlowInstance int32

const (
	FlowInstance_FLOW_INSTANCE_NONE      FlowInstance = 0
	FlowInstance_FLOW_INSTANCE_PRIMARY   FlowInstance = 1
	FlowInstance_FLOW_INSTANCE_SECONDARY FlowInstance = 2
)

var FlowInstance_name = map[int32]string{
	0: "FLOW_INSTANCE_NONE",
	1: "FLOW_INSTANCE_PRIMARY",
	2: "FLOW_INSTANCE_SECONDARY",
}
var FlowInstance_value = map[string]int32{
	"FLOW_INSTANCE_NONE":      0,
	"FLOW_INSTANCE_PRIMARY":   1,
	"FLOW_INSTANCE_SECONDARY": 2,
}

func (x FlowInstance) String() string {
	return proto.EnumName(FlowInstance_name, int32(x))
}
func (FlowInstance) EnumDescriptor() ([]byte, []int) { return fileDescriptor27, []int{4} }

// Key for L2 flows (i.e, non-IP flows)
type FlowKeyL2 struct {
	Smac        uint64 `protobuf:"fixed64,1,opt,name=smac" json:"smac,omitempty"`
	Dmac        uint64 `protobuf:"fixed64,2,opt,name=dmac" json:"dmac,omitempty"`
	EtherType   uint32 `protobuf:"varint,4,opt,name=ether_type,json=etherType" json:"ether_type,omitempty"`
	L2SegmentId uint32 `protobuf:"varint,3,opt,name=l2_segment_id,json=l2SegmentId" json:"l2_segment_id,omitempty"`
}

func (m *FlowKeyL2) Reset()                    { *m = FlowKeyL2{} }
func (m *FlowKeyL2) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyL2) ProtoMessage()               {}
func (*FlowKeyL2) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{0} }

func (m *FlowKeyL2) GetSmac() uint64 {
	if m != nil {
		return m.Smac
	}
	return 0
}

func (m *FlowKeyL2) GetDmac() uint64 {
	if m != nil {
		return m.Dmac
	}
	return 0
}

func (m *FlowKeyL2) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

func (m *FlowKeyL2) GetL2SegmentId() uint32 {
	if m != nil {
		return m.L2SegmentId
	}
	return 0
}

type FlowKeyTcpUdpInfo struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport" json:"dport,omitempty"`
}

func (m *FlowKeyTcpUdpInfo) Reset()                    { *m = FlowKeyTcpUdpInfo{} }
func (m *FlowKeyTcpUdpInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyTcpUdpInfo) ProtoMessage()               {}
func (*FlowKeyTcpUdpInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{1} }

func (m *FlowKeyTcpUdpInfo) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FlowKeyTcpUdpInfo) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type FlowKeyICMPInfo struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Id   uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *FlowKeyICMPInfo) Reset()                    { *m = FlowKeyICMPInfo{} }
func (m *FlowKeyICMPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyICMPInfo) ProtoMessage()               {}
func (*FlowKeyICMPInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{2} }

func (m *FlowKeyICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type FlowKeyESPInfo struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi" json:"spi,omitempty"`
}

func (m *FlowKeyESPInfo) Reset()                    { *m = FlowKeyESPInfo{} }
func (m *FlowKeyESPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyESPInfo) ProtoMessage()               {}
func (*FlowKeyESPInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{3} }

func (m *FlowKeyESPInfo) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

// Key for IPv4 flows
type FlowKeyV4 struct {
	Sip     uint32     `protobuf:"fixed32,1,opt,name=sip" json:"sip,omitempty"`
	Dip     uint32     `protobuf:"fixed32,2,opt,name=dip" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV4_TcpUdp
	//	*FlowKeyV4_Icmp
	//	*FlowKeyV4_Esp
	L4Fields isFlowKeyV4_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV4) Reset()                    { *m = FlowKeyV4{} }
func (m *FlowKeyV4) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV4) ProtoMessage()               {}
func (*FlowKeyV4) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{4} }

type isFlowKeyV4_L4Fields interface{ isFlowKeyV4_L4Fields() }

type FlowKeyV4_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV4_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV4_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV4_TcpUdp) isFlowKeyV4_L4Fields() {}
func (*FlowKeyV4_Icmp) isFlowKeyV4_L4Fields()   {}
func (*FlowKeyV4_Esp) isFlowKeyV4_L4Fields()    {}

func (m *FlowKeyV4) GetL4Fields() isFlowKeyV4_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV4) GetSip() uint32 {
	if m != nil {
		return m.Sip
	}
	return 0
}

func (m *FlowKeyV4) GetDip() uint32 {
	if m != nil {
		return m.Dip
	}
	return 0
}

func (m *FlowKeyV4) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV4) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV4) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV4) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV4) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV4_OneofMarshaler, _FlowKeyV4_OneofUnmarshaler, _FlowKeyV4_OneofSizer, []interface{}{
		(*FlowKeyV4_TcpUdp)(nil),
		(*FlowKeyV4_Icmp)(nil),
		(*FlowKeyV4_Esp)(nil),
	}
}

func _FlowKeyV4_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV4_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV4_Esp:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV4.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV4_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV4)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV4_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for IPv6 flows
type FlowKeyV6 struct {
	Sip     *IPAddress `protobuf:"bytes,1,opt,name=sip" json:"sip,omitempty"`
	Dip     *IPAddress `protobuf:"bytes,2,opt,name=dip" json:"dip,omitempty"`
	IpProto IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add AH etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV6_TcpUdp
	//	*FlowKeyV6_Icmp
	//	*FlowKeyV6_Esp
	L4Fields isFlowKeyV6_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV6) Reset()                    { *m = FlowKeyV6{} }
func (m *FlowKeyV6) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV6) ProtoMessage()               {}
func (*FlowKeyV6) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{5} }

type isFlowKeyV6_L4Fields interface{ isFlowKeyV6_L4Fields() }

type FlowKeyV6_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV6_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}
type FlowKeyV6_Esp struct {
	Esp *FlowKeyESPInfo `protobuf:"bytes,6,opt,name=esp,oneof"`
}

func (*FlowKeyV6_TcpUdp) isFlowKeyV6_L4Fields() {}
func (*FlowKeyV6_Icmp) isFlowKeyV6_L4Fields()   {}
func (*FlowKeyV6_Esp) isFlowKeyV6_L4Fields()    {}

func (m *FlowKeyV6) GetL4Fields() isFlowKeyV6_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV6) GetSip() *IPAddress {
	if m != nil {
		return m.Sip
	}
	return nil
}

func (m *FlowKeyV6) GetDip() *IPAddress {
	if m != nil {
		return m.Dip
	}
	return nil
}

func (m *FlowKeyV6) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowKeyV6) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV6) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Icmp); ok {
		return x.Icmp
	}
	return nil
}

func (m *FlowKeyV6) GetEsp() *FlowKeyESPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Esp); ok {
		return x.Esp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV6) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV6_OneofMarshaler, _FlowKeyV6_OneofUnmarshaler, _FlowKeyV6_OneofSizer, []interface{}{
		(*FlowKeyV6_TcpUdp)(nil),
		(*FlowKeyV6_Icmp)(nil),
		(*FlowKeyV6_Esp)(nil),
	}
}

func _FlowKeyV6_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV6_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case *FlowKeyV6_Esp:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Esp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV6.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV6_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV6)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Icmp{msg}
		return true, err
	case 6: // l4_fields.esp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyESPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Esp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV6_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Esp:
		s := proto.Size(x.Esp)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowKey is the key for uni-directional flow
type FlowKey struct {
	SrcVrfId uint64 `protobuf:"fixed64,1,opt,name=src_vrf_id,json=srcVrfId" json:"src_vrf_id,omitempty"`
	DstVrfId uint64 `protobuf:"fixed64,2,opt,name=dst_vrf_id,json=dstVrfId" json:"dst_vrf_id,omitempty"`
	// Types that are valid to be assigned to FlowKey:
	//	*FlowKey_L2Key
	//	*FlowKey_V4Key
	//	*FlowKey_V6Key
	FlowKey isFlowKey_FlowKey `protobuf_oneof:"flow_key"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{6} }

type isFlowKey_FlowKey interface{ isFlowKey_FlowKey() }

type FlowKey_L2Key struct {
	L2Key *FlowKeyL2 `protobuf:"bytes,3,opt,name=l2_key,json=l2Key,oneof"`
}
type FlowKey_V4Key struct {
	V4Key *FlowKeyV4 `protobuf:"bytes,4,opt,name=v4_key,json=v4Key,oneof"`
}
type FlowKey_V6Key struct {
	V6Key *FlowKeyV6 `protobuf:"bytes,5,opt,name=v6_key,json=v6Key,oneof"`
}

func (*FlowKey_L2Key) isFlowKey_FlowKey() {}
func (*FlowKey_V4Key) isFlowKey_FlowKey() {}
func (*FlowKey_V6Key) isFlowKey_FlowKey() {}

func (m *FlowKey) GetFlowKey() isFlowKey_FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowKey) GetSrcVrfId() uint64 {
	if m != nil {
		return m.SrcVrfId
	}
	return 0
}

func (m *FlowKey) GetDstVrfId() uint64 {
	if m != nil {
		return m.DstVrfId
	}
	return 0
}

func (m *FlowKey) GetL2Key() *FlowKeyL2 {
	if x, ok := m.GetFlowKey().(*FlowKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *FlowKey) GetV4Key() *FlowKeyV4 {
	if x, ok := m.GetFlowKey().(*FlowKey_V4Key); ok {
		return x.V4Key
	}
	return nil
}

func (m *FlowKey) GetV6Key() *FlowKeyV6 {
	if x, ok := m.GetFlowKey().(*FlowKey_V6Key); ok {
		return x.V6Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKey_OneofMarshaler, _FlowKey_OneofUnmarshaler, _FlowKey_OneofSizer, []interface{}{
		(*FlowKey_L2Key)(nil),
		(*FlowKey_V4Key)(nil),
		(*FlowKey_V6Key)(nil),
	}
}

func _FlowKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *FlowKey_V4Key:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V4Key); err != nil {
			return err
		}
	case *FlowKey_V6Key:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V6Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKey.FlowKey has unexpected type %T", x)
	}
	return nil
}

func _FlowKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKey)
	switch tag {
	case 3: // flow_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyL2)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_L2Key{msg}
		return true, err
	case 4: // flow_key.v4_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV4)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V4Key{msg}
		return true, err
	case 5: // flow_key.v6_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV6)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V6Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V4Key:
		s := proto.Size(x.V4Key)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V6Key:
		s := proto.Size(x.V6Key)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
type FlowInfo struct {
	FlowAction        FlowAction                `protobuf:"varint,1,opt,name=flow_action,json=flowAction,enum=session.FlowAction" json:"flow_action,omitempty"`
	FlowAge           uint32                    `protobuf:"varint,2,opt,name=flow_age,json=flowAge" json:"flow_age,omitempty"`
	TimeToAge         uint32                    `protobuf:"varint,3,opt,name=time_to_age,json=timeToAge" json:"time_to_age,omitempty"`
	NatType           NatType                   `protobuf:"varint,4,opt,name=nat_type,json=natType,enum=session.NatType" json:"nat_type,omitempty"`
	NatSip            *IPAddress                `protobuf:"bytes,5,opt,name=nat_sip,json=natSip" json:"nat_sip,omitempty"`
	NatSport          uint32                    `protobuf:"varint,6,opt,name=nat_sport,json=natSport" json:"nat_sport,omitempty"`
	NatDip            *IPAddress                `protobuf:"bytes,7,opt,name=nat_dip,json=natDip" json:"nat_dip,omitempty"`
	NatDport          uint32                    `protobuf:"varint,8,opt,name=nat_dport,json=natDport" json:"nat_dport,omitempty"`
	NatDmac           uint64                    `protobuf:"fixed64,9,opt,name=nat_dmac,json=natDmac" json:"nat_dmac,omitempty"`
	TcpState          FlowTCPState              `protobuf:"varint,10,opt,name=tcp_state,json=tcpState,enum=session.FlowTCPState" json:"tcp_state,omitempty"`
	IngMirrorSessions []*MirrorSessionKeyHandle `protobuf:"bytes,11,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty"`
	EgrMirrorSessions []*MirrorSessionKeyHandle `protobuf:"bytes,12,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty"`
}

func (m *FlowInfo) Reset()                    { *m = FlowInfo{} }
func (m *FlowInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowInfo) ProtoMessage()               {}
func (*FlowInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{7} }

func (m *FlowInfo) GetFlowAction() FlowAction {
	if m != nil {
		return m.FlowAction
	}
	return FlowAction_FLOW_ACTION_NONE
}

func (m *FlowInfo) GetFlowAge() uint32 {
	if m != nil {
		return m.FlowAge
	}
	return 0
}

func (m *FlowInfo) GetTimeToAge() uint32 {
	if m != nil {
		return m.TimeToAge
	}
	return 0
}

func (m *FlowInfo) GetNatType() NatType {
	if m != nil {
		return m.NatType
	}
	return NatType_NAT_TYPE_NONE
}

func (m *FlowInfo) GetNatSip() *IPAddress {
	if m != nil {
		return m.NatSip
	}
	return nil
}

func (m *FlowInfo) GetNatSport() uint32 {
	if m != nil {
		return m.NatSport
	}
	return 0
}

func (m *FlowInfo) GetNatDip() *IPAddress {
	if m != nil {
		return m.NatDip
	}
	return nil
}

func (m *FlowInfo) GetNatDport() uint32 {
	if m != nil {
		return m.NatDport
	}
	return 0
}

func (m *FlowInfo) GetNatDmac() uint64 {
	if m != nil {
		return m.NatDmac
	}
	return 0
}

func (m *FlowInfo) GetTcpState() FlowTCPState {
	if m != nil {
		return m.TcpState
	}
	return FlowTCPState_FLOW_TCP_STATE_INIT
}

func (m *FlowInfo) GetIngMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *FlowInfo) GetEgrMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

type ConnTrackExceptions struct {
	TcpSynRetransmit                bool `protobuf:"varint,1,opt,name=tcp_syn_retransmit,json=tcpSynRetransmit" json:"tcp_syn_retransmit,omitempty"`
	TcpWinZeroDrop                  bool `protobuf:"varint,2,opt,name=tcp_win_zero_drop,json=tcpWinZeroDrop" json:"tcp_win_zero_drop,omitempty"`
	TcpFullRetransmit               bool `protobuf:"varint,3,opt,name=tcp_full_retransmit,json=tcpFullRetransmit" json:"tcp_full_retransmit,omitempty"`
	TcpPartialOverlap               bool `protobuf:"varint,4,opt,name=tcp_partial_overlap,json=tcpPartialOverlap" json:"tcp_partial_overlap,omitempty"`
	TcpPacketReorder                bool `protobuf:"varint,5,opt,name=tcp_packet_reorder,json=tcpPacketReorder" json:"tcp_packet_reorder,omitempty"`
	TcpOutOfWindow                  bool `protobuf:"varint,6,opt,name=tcp_out_of_window,json=tcpOutOfWindow" json:"tcp_out_of_window,omitempty"`
	TcpInvalidAckNum                bool `protobuf:"varint,7,opt,name=tcp_invalid_ack_num,json=tcpInvalidAckNum" json:"tcp_invalid_ack_num,omitempty"`
	TcpNormalizationDrop            bool `protobuf:"varint,8,opt,name=tcp_normalization_drop,json=tcpNormalizationDrop" json:"tcp_normalization_drop,omitempty"`
	TcpSplitHandshakeDetected       bool `protobuf:"varint,9,opt,name=tcp_split_handshake_detected,json=tcpSplitHandshakeDetected" json:"tcp_split_handshake_detected,omitempty"`
	TcpDataAfterFin                 bool `protobuf:"varint,10,opt,name=tcp_data_after_fin,json=tcpDataAfterFin" json:"tcp_data_after_fin,omitempty"`
	TcpNonRstPktAfterRst            bool `protobuf:"varint,11,opt,name=tcp_non_rst_pkt_after_rst,json=tcpNonRstPktAfterRst" json:"tcp_non_rst_pkt_after_rst,omitempty"`
	TcpInvalidFirstPktFromResponder bool `protobuf:"varint,12,opt,name=tcp_invalid_first_pkt_from_responder,json=tcpInvalidFirstPktFromResponder" json:"tcp_invalid_first_pkt_from_responder,omitempty"`
	TcpUnexpectedPkt                bool `protobuf:"varint,13,opt,name=tcp_unexpected_pkt,json=tcpUnexpectedPkt" json:"tcp_unexpected_pkt,omitempty"`
	TcpRstWithInvalidAckNum         bool `protobuf:"varint,14,opt,name=tcp_rst_with_invalid_ack_num,json=tcpRstWithInvalidAckNum" json:"tcp_rst_with_invalid_ack_num,omitempty"`
}

func (m *ConnTrackExceptions) Reset()                    { *m = ConnTrackExceptions{} }
func (m *ConnTrackExceptions) String() string            { return proto.CompactTextString(m) }
func (*ConnTrackExceptions) ProtoMessage()               {}
func (*ConnTrackExceptions) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{8} }

func (m *ConnTrackExceptions) GetTcpSynRetransmit() bool {
	if m != nil {
		return m.TcpSynRetransmit
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpWinZeroDrop() bool {
	if m != nil {
		return m.TcpWinZeroDrop
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpFullRetransmit() bool {
	if m != nil {
		return m.TcpFullRetransmit
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpPartialOverlap() bool {
	if m != nil {
		return m.TcpPartialOverlap
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpPacketReorder() bool {
	if m != nil {
		return m.TcpPacketReorder
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpOutOfWindow() bool {
	if m != nil {
		return m.TcpOutOfWindow
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpInvalidAckNum() bool {
	if m != nil {
		return m.TcpInvalidAckNum
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpNormalizationDrop() bool {
	if m != nil {
		return m.TcpNormalizationDrop
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpSplitHandshakeDetected() bool {
	if m != nil {
		return m.TcpSplitHandshakeDetected
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpDataAfterFin() bool {
	if m != nil {
		return m.TcpDataAfterFin
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpNonRstPktAfterRst() bool {
	if m != nil {
		return m.TcpNonRstPktAfterRst
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpInvalidFirstPktFromResponder() bool {
	if m != nil {
		return m.TcpInvalidFirstPktFromResponder
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpUnexpectedPkt() bool {
	if m != nil {
		return m.TcpUnexpectedPkt
	}
	return false
}

func (m *ConnTrackExceptions) GetTcpRstWithInvalidAckNum() bool {
	if m != nil {
		return m.TcpRstWithInvalidAckNum
	}
	return false
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
type ConnTrackInfo struct {
	FlowCreateTs          uint64               `protobuf:"fixed64,1,opt,name=flow_create_ts,json=flowCreateTs" json:"flow_create_ts,omitempty"`
	FlowBytes             uint64               `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes" json:"flow_bytes,omitempty"`
	FlowPackets           uint32               `protobuf:"fixed32,3,opt,name=flow_packets,json=flowPackets" json:"flow_packets,omitempty"`
	Exceptions            *ConnTrackExceptions `protobuf:"bytes,4,opt,name=exceptions" json:"exceptions,omitempty"`
	TcpSeqNum             uint32               `protobuf:"fixed32,5,opt,name=tcp_seq_num,json=tcpSeqNum" json:"tcp_seq_num,omitempty"`
	TcpAckNum             uint32               `protobuf:"fixed32,6,opt,name=tcp_ack_num,json=tcpAckNum" json:"tcp_ack_num,omitempty"`
	TcpWinSz              uint32               `protobuf:"varint,7,opt,name=tcp_win_sz,json=tcpWinSz" json:"tcp_win_sz,omitempty"`
	TcpWinScale           uint32               `protobuf:"varint,8,opt,name=tcp_win_scale,json=tcpWinScale" json:"tcp_win_scale,omitempty"`
	TcpMss                uint32               `protobuf:"varint,9,opt,name=tcp_mss,json=tcpMss" json:"tcp_mss,omitempty"`
	TcpSackPermOptionSent bool                 `protobuf:"varint,10,opt,name=tcp_sack_perm_option_sent,json=tcpSackPermOptionSent" json:"tcp_sack_perm_option_sent,omitempty"`
	IflowSynAckDelta      int32                `protobuf:"zigzag32,11,opt,name=iflow_syn_ack_delta,json=iflowSynAckDelta" json:"iflow_syn_ack_delta,omitempty"`
	TcpWsOptionSent       bool                 `protobuf:"varint,12,opt,name=tcp_ws_option_sent,json=tcpWsOptionSent" json:"tcp_ws_option_sent,omitempty"`
	TcpTsOptionSent       bool                 `protobuf:"varint,13,opt,name=tcp_ts_option_sent,json=tcpTsOptionSent" json:"tcp_ts_option_sent,omitempty"`
}

func (m *ConnTrackInfo) Reset()                    { *m = ConnTrackInfo{} }
func (m *ConnTrackInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnTrackInfo) ProtoMessage()               {}
func (*ConnTrackInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{9} }

func (m *ConnTrackInfo) GetFlowCreateTs() uint64 {
	if m != nil {
		return m.FlowCreateTs
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *ConnTrackInfo) GetExceptions() *ConnTrackExceptions {
	if m != nil {
		return m.Exceptions
	}
	return nil
}

func (m *ConnTrackInfo) GetTcpSeqNum() uint32 {
	if m != nil {
		return m.TcpSeqNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpAckNum() uint32 {
	if m != nil {
		return m.TcpAckNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinSz() uint32 {
	if m != nil {
		return m.TcpWinSz
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinScale() uint32 {
	if m != nil {
		return m.TcpWinScale
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpMss() uint32 {
	if m != nil {
		return m.TcpMss
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpSackPermOptionSent() bool {
	if m != nil {
		return m.TcpSackPermOptionSent
	}
	return false
}

func (m *ConnTrackInfo) GetIflowSynAckDelta() int32 {
	if m != nil {
		return m.IflowSynAckDelta
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWsOptionSent() bool {
	if m != nil {
		return m.TcpWsOptionSent
	}
	return false
}

func (m *ConnTrackInfo) GetTcpTsOptionSent() bool {
	if m != nil {
		return m.TcpTsOptionSent
	}
	return false
}

// FlowData captures all the flow information
type FlowData struct {
	FlowInfo      *FlowInfo      `protobuf:"bytes,1,opt,name=flow_info,json=flowInfo" json:"flow_info,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
}

func (m *FlowData) Reset()                    { *m = FlowData{} }
func (m *FlowData) String() string            { return proto.CompactTextString(m) }
func (*FlowData) ProtoMessage()               {}
func (*FlowData) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{10} }

func (m *FlowData) GetFlowInfo() *FlowInfo {
	if m != nil {
		return m.FlowInfo
	}
	return nil
}

func (m *FlowData) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
type FlowSpec struct {
	FlowKey  *FlowKey  `protobuf:"bytes,1,opt,name=flow_key,json=flowKey" json:"flow_key,omitempty"`
	FlowData *FlowData `protobuf:"bytes,2,opt,name=flow_data,json=flowData" json:"flow_data,omitempty"`
}

func (m *FlowSpec) Reset()                    { *m = FlowSpec{} }
func (m *FlowSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowSpec) ProtoMessage()               {}
func (*FlowSpec) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{11} }

func (m *FlowSpec) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowSpec) GetFlowData() *FlowData {
	if m != nil {
		return m.FlowData
	}
	return nil
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
type SessionSpec struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
	// session_id is unique session identifier
	SessionId         uint32    `protobuf:"fixed32,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	ConnTrackEn       bool      `protobuf:"varint,3,opt,name=conn_track_en,json=connTrackEn" json:"conn_track_en,omitempty"`
	TcpTsOption       bool      `protobuf:"varint,4,opt,name=tcp_ts_option,json=tcpTsOption" json:"tcp_ts_option,omitempty"`
	TcpSackPermOption bool      `protobuf:"varint,5,opt,name=tcp_sack_perm_option,json=tcpSackPermOption" json:"tcp_sack_perm_option,omitempty"`
	InitiatorFlow     *FlowSpec `protobuf:"bytes,6,opt,name=initiator_flow,json=initiatorFlow" json:"initiator_flow,omitempty"`
	ResponderFlow     *FlowSpec `protobuf:"bytes,7,opt,name=responder_flow,json=responderFlow" json:"responder_flow,omitempty"`
	PeerInitiatorFlow *FlowSpec `protobuf:"bytes,8,opt,name=peer_initiator_flow,json=peerInitiatorFlow" json:"peer_initiator_flow,omitempty"`
	PeerResponderFlow *FlowSpec `protobuf:"bytes,9,opt,name=peer_responder_flow,json=peerResponderFlow" json:"peer_responder_flow,omitempty"`
}

func (m *SessionSpec) Reset()                    { *m = SessionSpec{} }
func (m *SessionSpec) String() string            { return proto.CompactTextString(m) }
func (*SessionSpec) ProtoMessage()               {}
func (*SessionSpec) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{12} }

func (m *SessionSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *SessionSpec) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SessionSpec) GetTcpTsOption() bool {
	if m != nil {
		return m.TcpTsOption
	}
	return false
}

func (m *SessionSpec) GetTcpSackPermOption() bool {
	if m != nil {
		return m.TcpSackPermOption
	}
	return false
}

func (m *SessionSpec) GetInitiatorFlow() *FlowSpec {
	if m != nil {
		return m.InitiatorFlow
	}
	return nil
}

func (m *SessionSpec) GetResponderFlow() *FlowSpec {
	if m != nil {
		return m.ResponderFlow
	}
	return nil
}

func (m *SessionSpec) GetPeerInitiatorFlow() *FlowSpec {
	if m != nil {
		return m.PeerInitiatorFlow
	}
	return nil
}

func (m *SessionSpec) GetPeerResponderFlow() *FlowSpec {
	if m != nil {
		return m.PeerResponderFlow
	}
	return nil
}

// SessionRequestMsg is batched session request message
type SessionRequestMsg struct {
	Request []*SessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionRequestMsg) Reset()                    { *m = SessionRequestMsg{} }
func (m *SessionRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionRequestMsg) ProtoMessage()               {}
func (*SessionRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{13} }

func (m *SessionRequestMsg) GetRequest() []*SessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
type FlowStatus struct {
	FlowHandle    uint64         `protobuf:"fixed64,1,opt,name=flow_handle,json=flowHandle" json:"flow_handle,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
	FlowColl      bool           `protobuf:"varint,3,opt,name=flow_coll,json=flowColl" json:"flow_coll,omitempty"`
	FlowHash      uint32         `protobuf:"varint,4,opt,name=flow_hash,json=flowHash" json:"flow_hash,omitempty"`
	FlowDirection FlowDirection  `protobuf:"varint,5,opt,name=flow_direction,json=flowDirection,enum=types.FlowDirection" json:"flow_direction,omitempty"`
	FlowInstance  FlowInstance   `protobuf:"varint,6,opt,name=flow_instance,json=flowInstance,enum=session.FlowInstance" json:"flow_instance,omitempty"`
}

func (m *FlowStatus) Reset()                    { *m = FlowStatus{} }
func (m *FlowStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowStatus) ProtoMessage()               {}
func (*FlowStatus) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{14} }

func (m *FlowStatus) GetFlowHandle() uint64 {
	if m != nil {
		return m.FlowHandle
	}
	return 0
}

func (m *FlowStatus) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

func (m *FlowStatus) GetFlowColl() bool {
	if m != nil {
		return m.FlowColl
	}
	return false
}

func (m *FlowStatus) GetFlowHash() uint32 {
	if m != nil {
		return m.FlowHash
	}
	return 0
}

func (m *FlowStatus) GetFlowDirection() FlowDirection {
	if m != nil {
		return m.FlowDirection
	}
	return FlowDirection_FLOW_DIRECTION_NONE
}

func (m *FlowStatus) GetFlowInstance() FlowInstance {
	if m != nil {
		return m.FlowInstance
	}
	return FlowInstance_FLOW_INSTANCE_NONE
}

// TFTPInfo captures the operational status of TFTP ALG session
type TFTPALGInfo struct {
	Iscontrol     bool   `protobuf:"varint,1,opt,name=iscontrol" json:"iscontrol,omitempty"`
	ParseError    uint32 `protobuf:"varint,2,opt,name=parse_error,json=parseError" json:"parse_error,omitempty"`
	UnknownOpcode uint32 `protobuf:"varint,3,opt,name=unknown_opcode,json=unknownOpcode" json:"unknown_opcode,omitempty"`
}

func (m *TFTPALGInfo) Reset()                    { *m = TFTPALGInfo{} }
func (m *TFTPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*TFTPALGInfo) ProtoMessage()               {}
func (*TFTPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{15} }

func (m *TFTPALGInfo) GetIscontrol() bool {
	if m != nil {
		return m.Iscontrol
	}
	return false
}

func (m *TFTPALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

func (m *TFTPALGInfo) GetUnknownOpcode() uint32 {
	if m != nil {
		return m.UnknownOpcode
	}
	return 0
}

// RPCInfo captures the operational status of SUNRPC/MSFT RPC ALG session
type RPCALGInfo struct {
	Iscontrol          bool   `protobuf:"varint,1,opt,name=iscontrol" json:"iscontrol,omitempty"`
	ParseError         uint32 `protobuf:"varint,2,opt,name=parse_error,json=parseError" json:"parse_error,omitempty"`
	NumDataSess        uint32 `protobuf:"varint,3,opt,name=num_data_sess,json=numDataSess" json:"num_data_sess,omitempty"`
	NumExpFlows        uint32 `protobuf:"varint,4,opt,name=num_exp_flows,json=numExpFlows" json:"num_exp_flows,omitempty"`
	MaxpktSizeExceeded uint32 `protobuf:"varint,5,opt,name=maxpkt_size_exceeded,json=maxpktSizeExceeded" json:"maxpkt_size_exceeded,omitempty"`
}

func (m *RPCALGInfo) Reset()                    { *m = RPCALGInfo{} }
func (m *RPCALGInfo) String() string            { return proto.CompactTextString(m) }
func (*RPCALGInfo) ProtoMessage()               {}
func (*RPCALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{16} }

func (m *RPCALGInfo) GetIscontrol() bool {
	if m != nil {
		return m.Iscontrol
	}
	return false
}

func (m *RPCALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

func (m *RPCALGInfo) GetNumDataSess() uint32 {
	if m != nil {
		return m.NumDataSess
	}
	return 0
}

func (m *RPCALGInfo) GetNumExpFlows() uint32 {
	if m != nil {
		return m.NumExpFlows
	}
	return 0
}

func (m *RPCALGInfo) GetMaxpktSizeExceeded() uint32 {
	if m != nil {
		return m.MaxpktSizeExceeded
	}
	return 0
}

// SIPInfo captures the operational status of SIP ALG session
type SIPALGInfo struct {
	ParseError uint32 `protobuf:"varint,1,opt,name=parse_error,json=parseError" json:"parse_error,omitempty"`
}

func (m *SIPALGInfo) Reset()                    { *m = SIPALGInfo{} }
func (m *SIPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*SIPALGInfo) ProtoMessage()               {}
func (*SIPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{17} }

func (m *SIPALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

// FTPInfo captures the operational status of FTP ALG session
type FTPALGInfo struct {
	Iscontrol   bool   `protobuf:"varint,1,opt,name=iscontrol" json:"iscontrol,omitempty"`
	ParseError  uint32 `protobuf:"varint,2,opt,name=parse_error,json=parseError" json:"parse_error,omitempty"`
	NumDataSess uint32 `protobuf:"varint,3,opt,name=num_data_sess,json=numDataSess" json:"num_data_sess,omitempty"`
	NumExpFlows uint32 `protobuf:"varint,4,opt,name=num_exp_flows,json=numExpFlows" json:"num_exp_flows,omitempty"`
}

func (m *FTPALGInfo) Reset()                    { *m = FTPALGInfo{} }
func (m *FTPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*FTPALGInfo) ProtoMessage()               {}
func (*FTPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{18} }

func (m *FTPALGInfo) GetIscontrol() bool {
	if m != nil {
		return m.Iscontrol
	}
	return false
}

func (m *FTPALGInfo) GetParseError() uint32 {
	if m != nil {
		return m.ParseError
	}
	return 0
}

func (m *FTPALGInfo) GetNumDataSess() uint32 {
	if m != nil {
		return m.NumDataSess
	}
	return 0
}

func (m *FTPALGInfo) GetNumExpFlows() uint32 {
	if m != nil {
		return m.NumExpFlows
	}
	return 0
}

// RTSPALGInfo captures the operational status of RTSP ALG session
type RTSPALGInfo struct {
	Iscontrol       bool   `protobuf:"varint,1,opt,name=iscontrol" json:"iscontrol,omitempty"`
	Sessionid       string `protobuf:"bytes,2,opt,name=sessionid" json:"sessionid,omitempty"`
	ParseErrors     uint32 `protobuf:"varint,3,opt,name=parse_errors,json=parseErrors" json:"parse_errors,omitempty"`
	NumDataSess     uint32 `protobuf:"varint,4,opt,name=num_data_sess,json=numDataSess" json:"num_data_sess,omitempty"`
	NumExpFlows     uint32 `protobuf:"varint,5,opt,name=num_exp_flows,json=numExpFlows" json:"num_exp_flows,omitempty"`
	NumRtspSessions uint32 `protobuf:"varint,6,opt,name=num_rtsp_sessions,json=numRtspSessions" json:"num_rtsp_sessions,omitempty"`
}

func (m *RTSPALGInfo) Reset()                    { *m = RTSPALGInfo{} }
func (m *RTSPALGInfo) String() string            { return proto.CompactTextString(m) }
func (*RTSPALGInfo) ProtoMessage()               {}
func (*RTSPALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{19} }

func (m *RTSPALGInfo) GetIscontrol() bool {
	if m != nil {
		return m.Iscontrol
	}
	return false
}

func (m *RTSPALGInfo) GetSessionid() string {
	if m != nil {
		return m.Sessionid
	}
	return ""
}

func (m *RTSPALGInfo) GetParseErrors() uint32 {
	if m != nil {
		return m.ParseErrors
	}
	return 0
}

func (m *RTSPALGInfo) GetNumDataSess() uint32 {
	if m != nil {
		return m.NumDataSess
	}
	return 0
}

func (m *RTSPALGInfo) GetNumExpFlows() uint32 {
	if m != nil {
		return m.NumExpFlows
	}
	return 0
}

func (m *RTSPALGInfo) GetNumRtspSessions() uint32 {
	if m != nil {
		return m.NumRtspSessions
	}
	return 0
}

// DNSALGInfo captures the operational status of DNS ALG session
type DNSALGInfo struct {
	ParseErrors   uint32 `protobuf:"varint,1,opt,name=parse_errors,json=parseErrors" json:"parse_errors,omitempty"`
	DnsId         uint32 `protobuf:"varint,2,opt,name=dns_id,json=dnsId" json:"dns_id,omitempty"`
	TimeRemaining uint32 `protobuf:"varint,3,opt,name=time_remaining,json=timeRemaining" json:"time_remaining,omitempty"`
}

func (m *DNSALGInfo) Reset()                    { *m = DNSALGInfo{} }
func (m *DNSALGInfo) String() string            { return proto.CompactTextString(m) }
func (*DNSALGInfo) ProtoMessage()               {}
func (*DNSALGInfo) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{20} }

func (m *DNSALGInfo) GetParseErrors() uint32 {
	if m != nil {
		return m.ParseErrors
	}
	return 0
}

func (m *DNSALGInfo) GetDnsId() uint32 {
	if m != nil {
		return m.DnsId
	}
	return 0
}

func (m *DNSALGInfo) GetTimeRemaining() uint32 {
	if m != nil {
		return m.TimeRemaining
	}
	return 0
}

// SessionStatus captures the operational status of the session
type SessionStatus struct {
	SessionHandle   uint64      `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
	IflowStatus     *FlowStatus `protobuf:"bytes,2,opt,name=iflow_status,json=iflowStatus" json:"iflow_status,omitempty"`
	RflowStatus     *FlowStatus `protobuf:"bytes,3,opt,name=rflow_status,json=rflowStatus" json:"rflow_status,omitempty"`
	PeerIflowStatus *FlowStatus `protobuf:"bytes,4,opt,name=peer_iflow_status,json=peerIflowStatus" json:"peer_iflow_status,omitempty"`
	PeerRflowStatus *FlowStatus `protobuf:"bytes,5,opt,name=peer_rflow_status,json=peerRflowStatus" json:"peer_rflow_status,omitempty"`
	AppId           uint32      `protobuf:"varint,6,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	AppIdState      uint32      `protobuf:"varint,7,opt,name=app_id_state,json=appIdState" json:"app_id_state,omitempty"`
	Alg             ALGName     `protobuf:"varint,8,opt,name=alg,enum=nwsec.ALGName" json:"alg,omitempty"`
	// Types that are valid to be assigned to AlgInfo:
	//	*SessionStatus_TftpInfo
	//	*SessionStatus_RpcInfo
	//	*SessionStatus_SipInfo
	//	*SessionStatus_RtspInfo
	//	*SessionStatus_DnsInfo
	//	*SessionStatus_FtpInfo
	AlgInfo isSessionStatus_AlgInfo `protobuf_oneof:"alg_info"`
}

func (m *SessionStatus) Reset()                    { *m = SessionStatus{} }
func (m *SessionStatus) String() string            { return proto.CompactTextString(m) }
func (*SessionStatus) ProtoMessage()               {}
func (*SessionStatus) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{21} }

type isSessionStatus_AlgInfo interface{ isSessionStatus_AlgInfo() }

type SessionStatus_TftpInfo struct {
	TftpInfo *TFTPALGInfo `protobuf:"bytes,9,opt,name=tftp_info,json=tftpInfo,oneof"`
}
type SessionStatus_RpcInfo struct {
	RpcInfo *RPCALGInfo `protobuf:"bytes,10,opt,name=rpc_info,json=rpcInfo,oneof"`
}
type SessionStatus_SipInfo struct {
	SipInfo *SIPALGInfo `protobuf:"bytes,11,opt,name=sip_info,json=sipInfo,oneof"`
}
type SessionStatus_RtspInfo struct {
	RtspInfo *RTSPALGInfo `protobuf:"bytes,12,opt,name=rtsp_info,json=rtspInfo,oneof"`
}
type SessionStatus_DnsInfo struct {
	DnsInfo *DNSALGInfo `protobuf:"bytes,13,opt,name=dns_info,json=dnsInfo,oneof"`
}
type SessionStatus_FtpInfo struct {
	FtpInfo *FTPALGInfo `protobuf:"bytes,14,opt,name=ftp_info,json=ftpInfo,oneof"`
}

func (*SessionStatus_TftpInfo) isSessionStatus_AlgInfo() {}
func (*SessionStatus_RpcInfo) isSessionStatus_AlgInfo()  {}
func (*SessionStatus_SipInfo) isSessionStatus_AlgInfo()  {}
func (*SessionStatus_RtspInfo) isSessionStatus_AlgInfo() {}
func (*SessionStatus_DnsInfo) isSessionStatus_AlgInfo()  {}
func (*SessionStatus_FtpInfo) isSessionStatus_AlgInfo()  {}

func (m *SessionStatus) GetAlgInfo() isSessionStatus_AlgInfo {
	if m != nil {
		return m.AlgInfo
	}
	return nil
}

func (m *SessionStatus) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

func (m *SessionStatus) GetIflowStatus() *FlowStatus {
	if m != nil {
		return m.IflowStatus
	}
	return nil
}

func (m *SessionStatus) GetRflowStatus() *FlowStatus {
	if m != nil {
		return m.RflowStatus
	}
	return nil
}

func (m *SessionStatus) GetPeerIflowStatus() *FlowStatus {
	if m != nil {
		return m.PeerIflowStatus
	}
	return nil
}

func (m *SessionStatus) GetPeerRflowStatus() *FlowStatus {
	if m != nil {
		return m.PeerRflowStatus
	}
	return nil
}

func (m *SessionStatus) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *SessionStatus) GetAppIdState() uint32 {
	if m != nil {
		return m.AppIdState
	}
	return 0
}

func (m *SessionStatus) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

func (m *SessionStatus) GetTftpInfo() *TFTPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_TftpInfo); ok {
		return x.TftpInfo
	}
	return nil
}

func (m *SessionStatus) GetRpcInfo() *RPCALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_RpcInfo); ok {
		return x.RpcInfo
	}
	return nil
}

func (m *SessionStatus) GetSipInfo() *SIPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_SipInfo); ok {
		return x.SipInfo
	}
	return nil
}

func (m *SessionStatus) GetRtspInfo() *RTSPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_RtspInfo); ok {
		return x.RtspInfo
	}
	return nil
}

func (m *SessionStatus) GetDnsInfo() *DNSALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_DnsInfo); ok {
		return x.DnsInfo
	}
	return nil
}

func (m *SessionStatus) GetFtpInfo() *FTPALGInfo {
	if x, ok := m.GetAlgInfo().(*SessionStatus_FtpInfo); ok {
		return x.FtpInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SessionStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SessionStatus_OneofMarshaler, _SessionStatus_OneofUnmarshaler, _SessionStatus_OneofSizer, []interface{}{
		(*SessionStatus_TftpInfo)(nil),
		(*SessionStatus_RpcInfo)(nil),
		(*SessionStatus_SipInfo)(nil),
		(*SessionStatus_RtspInfo)(nil),
		(*SessionStatus_DnsInfo)(nil),
		(*SessionStatus_FtpInfo)(nil),
	}
}

func _SessionStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SessionStatus)
	// alg_info
	switch x := m.AlgInfo.(type) {
	case *SessionStatus_TftpInfo:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TftpInfo); err != nil {
			return err
		}
	case *SessionStatus_RpcInfo:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RpcInfo); err != nil {
			return err
		}
	case *SessionStatus_SipInfo:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SipInfo); err != nil {
			return err
		}
	case *SessionStatus_RtspInfo:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RtspInfo); err != nil {
			return err
		}
	case *SessionStatus_DnsInfo:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsInfo); err != nil {
			return err
		}
	case *SessionStatus_FtpInfo:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FtpInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SessionStatus.AlgInfo has unexpected type %T", x)
	}
	return nil
}

func _SessionStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SessionStatus)
	switch tag {
	case 9: // alg_info.tftp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TFTPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_TftpInfo{msg}
		return true, err
	case 10: // alg_info.rpc_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RPCALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_RpcInfo{msg}
		return true, err
	case 11: // alg_info.sip_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SIPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_SipInfo{msg}
		return true, err
	case 12: // alg_info.rtsp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RTSPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_RtspInfo{msg}
		return true, err
	case 13: // alg_info.dns_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DNSALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_DnsInfo{msg}
		return true, err
	case 14: // alg_info.ftp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FTPALGInfo)
		err := b.DecodeMessage(msg)
		m.AlgInfo = &SessionStatus_FtpInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SessionStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SessionStatus)
	// alg_info
	switch x := m.AlgInfo.(type) {
	case *SessionStatus_TftpInfo:
		s := proto.Size(x.TftpInfo)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_RpcInfo:
		s := proto.Size(x.RpcInfo)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_SipInfo:
		s := proto.Size(x.SipInfo)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_RtspInfo:
		s := proto.Size(x.RtspInfo)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_DnsInfo:
		s := proto.Size(x.DnsInfo)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionStatus_FtpInfo:
		s := proto.Size(x.FtpInfo)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SessionResponse is the response to one SessionSpec
type SessionResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *SessionStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SessionResponse) Reset()                    { *m = SessionResponse{} }
func (m *SessionResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionResponse) ProtoMessage()               {}
func (*SessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{22} }

func (m *SessionResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SessionResponseMsg is the response to SessionRequestMsg
type SessionResponseMsg struct {
	Response []*SessionResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionResponseMsg) Reset()                    { *m = SessionResponseMsg{} }
func (m *SessionResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionResponseMsg) ProtoMessage()               {}
func (*SessionResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{23} }

func (m *SessionResponseMsg) GetResponse() []*SessionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SessionDeleteRequest is used to delete a session
type SessionDeleteRequest struct {
	// session_handle is the handle of the session
	//
	// Types that are valid to be assigned to GetBy:
	//	*SessionDeleteRequest_SessionHandle
	//	*SessionDeleteRequest_SessionFilter
	GetBy isSessionDeleteRequest_GetBy `protobuf_oneof:"get_by"`
}

func (m *SessionDeleteRequest) Reset()                    { *m = SessionDeleteRequest{} }
func (m *SessionDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequest) ProtoMessage()               {}
func (*SessionDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{24} }

type isSessionDeleteRequest_GetBy interface{ isSessionDeleteRequest_GetBy() }

type SessionDeleteRequest_SessionHandle struct {
	SessionHandle uint64 `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle,oneof"`
}
type SessionDeleteRequest_SessionFilter struct {
	SessionFilter *SessionFilter `protobuf:"bytes,2,opt,name=session_filter,json=sessionFilter,oneof"`
}

func (*SessionDeleteRequest_SessionHandle) isSessionDeleteRequest_GetBy() {}
func (*SessionDeleteRequest_SessionFilter) isSessionDeleteRequest_GetBy() {}

func (m *SessionDeleteRequest) GetGetBy() isSessionDeleteRequest_GetBy {
	if m != nil {
		return m.GetBy
	}
	return nil
}

func (m *SessionDeleteRequest) GetSessionHandle() uint64 {
	if x, ok := m.GetGetBy().(*SessionDeleteRequest_SessionHandle); ok {
		return x.SessionHandle
	}
	return 0
}

func (m *SessionDeleteRequest) GetSessionFilter() *SessionFilter {
	if x, ok := m.GetGetBy().(*SessionDeleteRequest_SessionFilter); ok {
		return x.SessionFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SessionDeleteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SessionDeleteRequest_OneofMarshaler, _SessionDeleteRequest_OneofUnmarshaler, _SessionDeleteRequest_OneofSizer, []interface{}{
		(*SessionDeleteRequest_SessionHandle)(nil),
		(*SessionDeleteRequest_SessionFilter)(nil),
	}
}

func _SessionDeleteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SessionDeleteRequest)
	// get_by
	switch x := m.GetBy.(type) {
	case *SessionDeleteRequest_SessionHandle:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.SessionHandle))
	case *SessionDeleteRequest_SessionFilter:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SessionFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SessionDeleteRequest.GetBy has unexpected type %T", x)
	}
	return nil
}

func _SessionDeleteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SessionDeleteRequest)
	switch tag {
	case 1: // get_by.session_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.GetBy = &SessionDeleteRequest_SessionHandle{x}
		return true, err
	case 2: // get_by.session_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SessionFilter)
		err := b.DecodeMessage(msg)
		m.GetBy = &SessionDeleteRequest_SessionFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SessionDeleteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SessionDeleteRequest)
	// get_by
	switch x := m.GetBy.(type) {
	case *SessionDeleteRequest_SessionHandle:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *SessionDeleteRequest_SessionFilter:
		s := proto.Size(x.SessionFilter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SessionDeleteRequestMsg is batched session delete request
type SessionDeleteRequestMsg struct {
	Request []*SessionDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionDeleteRequestMsg) Reset()                    { *m = SessionDeleteRequestMsg{} }
func (m *SessionDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequestMsg) ProtoMessage()               {}
func (*SessionDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{25} }

func (m *SessionDeleteRequestMsg) GetRequest() []*SessionDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SessionDeleteResponse is response to session delete request
type SessionDeleteResponse struct {
	ApiStatus     ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	SessionHandle uint64    `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
}

func (m *SessionDeleteResponse) Reset()                    { *m = SessionDeleteResponse{} }
func (m *SessionDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteResponse) ProtoMessage()               {}
func (*SessionDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{26} }

func (m *SessionDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionDeleteResponse) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
type SessionDeleteResponseMsg struct {
	Response []*SessionDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionDeleteResponseMsg) Reset()                    { *m = SessionDeleteResponseMsg{} }
func (m *SessionDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteResponseMsg) ProtoMessage()               {}
func (*SessionDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{27} }

func (m *SessionDeleteResponseMsg) GetResponse() []*SessionDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type SessionFilter struct {
	SrcIp       *IPAddress `protobuf:"bytes,1,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp       *IPAddress `protobuf:"bytes,2,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	SrcPort     uint32     `protobuf:"varint,3,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort     uint32     `protobuf:"varint,4,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	IpProto     IPProtocol `protobuf:"varint,5,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	VrfId       uint64     `protobuf:"fixed64,6,opt,name=vrf_id,json=vrfId" json:"vrf_id,omitempty"`
	L2SegmentId uint32     `protobuf:"varint,7,opt,name=l2_segment_id,json=l2SegmentId" json:"l2_segment_id,omitempty"`
	Alg         ALGName    `protobuf:"varint,8,opt,name=alg,enum=nwsec.ALGName" json:"alg,omitempty"`
}

func (m *SessionFilter) Reset()                    { *m = SessionFilter{} }
func (m *SessionFilter) String() string            { return proto.CompactTextString(m) }
func (*SessionFilter) ProtoMessage()               {}
func (*SessionFilter) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{28} }

func (m *SessionFilter) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *SessionFilter) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *SessionFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SessionFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SessionFilter) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *SessionFilter) GetVrfId() uint64 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

func (m *SessionFilter) GetL2SegmentId() uint32 {
	if m != nil {
		return m.L2SegmentId
	}
	return 0
}

func (m *SessionFilter) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

// SessionGetRequest  is used to get information about a session
type SessionGetRequest struct {
	// session_handle is the handle of the session
	//
	// Types that are valid to be assigned to GetBy:
	//	*SessionGetRequest_SessionHandle
	//	*SessionGetRequest_SessionFilter
	GetBy isSessionGetRequest_GetBy `protobuf_oneof:"get_by"`
}

func (m *SessionGetRequest) Reset()                    { *m = SessionGetRequest{} }
func (m *SessionGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequest) ProtoMessage()               {}
func (*SessionGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{29} }

type isSessionGetRequest_GetBy interface{ isSessionGetRequest_GetBy() }

type SessionGetRequest_SessionHandle struct {
	SessionHandle uint64 `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle,oneof"`
}
type SessionGetRequest_SessionFilter struct {
	SessionFilter *SessionFilter `protobuf:"bytes,2,opt,name=session_filter,json=sessionFilter,oneof"`
}

func (*SessionGetRequest_SessionHandle) isSessionGetRequest_GetBy() {}
func (*SessionGetRequest_SessionFilter) isSessionGetRequest_GetBy() {}

func (m *SessionGetRequest) GetGetBy() isSessionGetRequest_GetBy {
	if m != nil {
		return m.GetBy
	}
	return nil
}

func (m *SessionGetRequest) GetSessionHandle() uint64 {
	if x, ok := m.GetGetBy().(*SessionGetRequest_SessionHandle); ok {
		return x.SessionHandle
	}
	return 0
}

func (m *SessionGetRequest) GetSessionFilter() *SessionFilter {
	if x, ok := m.GetGetBy().(*SessionGetRequest_SessionFilter); ok {
		return x.SessionFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SessionGetRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SessionGetRequest_OneofMarshaler, _SessionGetRequest_OneofUnmarshaler, _SessionGetRequest_OneofSizer, []interface{}{
		(*SessionGetRequest_SessionHandle)(nil),
		(*SessionGetRequest_SessionFilter)(nil),
	}
}

func _SessionGetRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SessionGetRequest)
	// get_by
	switch x := m.GetBy.(type) {
	case *SessionGetRequest_SessionHandle:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.SessionHandle))
	case *SessionGetRequest_SessionFilter:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SessionFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SessionGetRequest.GetBy has unexpected type %T", x)
	}
	return nil
}

func _SessionGetRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SessionGetRequest)
	switch tag {
	case 1: // get_by.session_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.GetBy = &SessionGetRequest_SessionHandle{x}
		return true, err
	case 2: // get_by.session_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SessionFilter)
		err := b.DecodeMessage(msg)
		m.GetBy = &SessionGetRequest_SessionFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SessionGetRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SessionGetRequest)
	// get_by
	switch x := m.GetBy.(type) {
	case *SessionGetRequest_SessionHandle:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *SessionGetRequest_SessionFilter:
		s := proto.Size(x.SessionFilter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SessionGetRequestMsg  is batched get request
type SessionGetRequestMsg struct {
	Request []*SessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionGetRequestMsg) Reset()                    { *m = SessionGetRequestMsg{} }
func (m *SessionGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequestMsg) ProtoMessage()               {}
func (*SessionGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{30} }

func (m *SessionGetRequestMsg) GetRequest() []*SessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStats contains all the stats collected per flow
type FlowStats struct {
	FlowPermittedPackets uint64 `protobuf:"fixed64,1,opt,name=flow_permitted_packets,json=flowPermittedPackets" json:"flow_permitted_packets,omitempty"`
	FlowPermittedBytes   uint64 `protobuf:"fixed64,2,opt,name=flow_permitted_bytes,json=flowPermittedBytes" json:"flow_permitted_bytes,omitempty"`
	FlowDroppedPackets   uint64 `protobuf:"fixed64,3,opt,name=flow_dropped_packets,json=flowDroppedPackets" json:"flow_dropped_packets,omitempty"`
	FlowDroppedBytes     uint64 `protobuf:"fixed64,4,opt,name=flow_dropped_bytes,json=flowDroppedBytes" json:"flow_dropped_bytes,omitempty"`
	NumTcpTicklesSent    uint64 `protobuf:"fixed64,5,opt,name=num_tcp_tickles_sent,json=numTcpTicklesSent" json:"num_tcp_tickles_sent,omitempty"`
	NumTcpRstSent        uint64 `protobuf:"fixed64,6,opt,name=num_tcp_rst_sent,json=numTcpRstSent" json:"num_tcp_rst_sent,omitempty"`
}

func (m *FlowStats) Reset()                    { *m = FlowStats{} }
func (m *FlowStats) String() string            { return proto.CompactTextString(m) }
func (*FlowStats) ProtoMessage()               {}
func (*FlowStats) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{31} }

func (m *FlowStats) GetFlowPermittedPackets() uint64 {
	if m != nil {
		return m.FlowPermittedPackets
	}
	return 0
}

func (m *FlowStats) GetFlowPermittedBytes() uint64 {
	if m != nil {
		return m.FlowPermittedBytes
	}
	return 0
}

func (m *FlowStats) GetFlowDroppedPackets() uint64 {
	if m != nil {
		return m.FlowDroppedPackets
	}
	return 0
}

func (m *FlowStats) GetFlowDroppedBytes() uint64 {
	if m != nil {
		return m.FlowDroppedBytes
	}
	return 0
}

func (m *FlowStats) GetNumTcpTicklesSent() uint64 {
	if m != nil {
		return m.NumTcpTicklesSent
	}
	return 0
}

func (m *FlowStats) GetNumTcpRstSent() uint64 {
	if m != nil {
		return m.NumTcpRstSent
	}
	return 0
}

// SessionStats captures statistics of all its constituent flows
type SessionStats struct {
	InitiatorFlowStats     *FlowStats `protobuf:"bytes,1,opt,name=initiator_flow_stats,json=initiatorFlowStats" json:"initiator_flow_stats,omitempty"`
	ResponderFlowStats     *FlowStats `protobuf:"bytes,2,opt,name=responder_flow_stats,json=responderFlowStats" json:"responder_flow_stats,omitempty"`
	PeerInitiatorFlowStats *FlowStats `protobuf:"bytes,3,opt,name=peer_initiator_flow_stats,json=peerInitiatorFlowStats" json:"peer_initiator_flow_stats,omitempty"`
	PeerResponderFlowStats *FlowStats `protobuf:"bytes,4,opt,name=peer_responder_flow_stats,json=peerResponderFlowStats" json:"peer_responder_flow_stats,omitempty"`
}

func (m *SessionStats) Reset()                    { *m = SessionStats{} }
func (m *SessionStats) String() string            { return proto.CompactTextString(m) }
func (*SessionStats) ProtoMessage()               {}
func (*SessionStats) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{32} }

func (m *SessionStats) GetInitiatorFlowStats() *FlowStats {
	if m != nil {
		return m.InitiatorFlowStats
	}
	return nil
}

func (m *SessionStats) GetResponderFlowStats() *FlowStats {
	if m != nil {
		return m.ResponderFlowStats
	}
	return nil
}

func (m *SessionStats) GetPeerInitiatorFlowStats() *FlowStats {
	if m != nil {
		return m.PeerInitiatorFlowStats
	}
	return nil
}

func (m *SessionStats) GetPeerResponderFlowStats() *FlowStats {
	if m != nil {
		return m.PeerResponderFlowStats
	}
	return nil
}

// SessionGetResponse is response to one SessionGetRequest
type SessionGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *SessionSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SessionStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SessionStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SessionGetResponse) Reset()                    { *m = SessionGetResponse{} }
func (m *SessionGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponse) ProtoMessage()               {}
func (*SessionGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{33} }

func (m *SessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionGetResponse) GetSpec() *SessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SessionGetResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SessionGetResponse) GetStats() *SessionStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
type SessionGetResponseMsg struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Response  []*SessionGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *SessionGetResponseMsg) Reset()                    { *m = SessionGetResponseMsg{} }
func (m *SessionGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponseMsg) ProtoMessage()               {}
func (*SessionGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor27, []int{34} }

func (m *SessionGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionGetResponseMsg) GetResponse() []*SessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowKeyL2)(nil), "halproto.FlowKeyL2")
	proto.RegisterType((*FlowKeyTcpUdpInfo)(nil), "halproto.FlowKeyTcpUdpInfo")
	proto.RegisterType((*FlowKeyICMPInfo)(nil), "halproto.FlowKeyICMPInfo")
	proto.RegisterType((*FlowKeyESPInfo)(nil), "halproto.FlowKeyESPInfo")
	proto.RegisterType((*FlowKeyV4)(nil), "halproto.FlowKeyV4")
	proto.RegisterType((*FlowKeyV6)(nil), "halproto.FlowKeyV6")
	proto.RegisterType((*FlowKey)(nil), "halproto.FlowKey")
	proto.RegisterType((*FlowInfo)(nil), "halproto.FlowInfo")
	proto.RegisterType((*ConnTrackExceptions)(nil), "halproto.ConnTrackExceptions")
	proto.RegisterType((*ConnTrackInfo)(nil), "halproto.ConnTrackInfo")
	proto.RegisterType((*FlowData)(nil), "halproto.FlowData")
	proto.RegisterType((*FlowSpec)(nil), "halproto.FlowSpec")
	proto.RegisterType((*SessionSpec)(nil), "halproto.SessionSpec")
	proto.RegisterType((*SessionRequestMsg)(nil), "halproto.SessionRequestMsg")
	proto.RegisterType((*FlowStatus)(nil), "halproto.FlowStatus")
	proto.RegisterType((*TFTPALGInfo)(nil), "halproto.TFTPALGInfo")
	proto.RegisterType((*RPCALGInfo)(nil), "halproto.RPCALGInfo")
	proto.RegisterType((*SIPALGInfo)(nil), "halproto.SIPALGInfo")
	proto.RegisterType((*FTPALGInfo)(nil), "halproto.FTPALGInfo")
	proto.RegisterType((*RTSPALGInfo)(nil), "halproto.RTSPALGInfo")
	proto.RegisterType((*DNSALGInfo)(nil), "halproto.DNSALGInfo")
	proto.RegisterType((*SessionStatus)(nil), "halproto.SessionStatus")
	proto.RegisterType((*SessionResponse)(nil), "halproto.SessionResponse")
	proto.RegisterType((*SessionResponseMsg)(nil), "halproto.SessionResponseMsg")
	proto.RegisterType((*SessionDeleteRequest)(nil), "halproto.SessionDeleteRequest")
	proto.RegisterType((*SessionDeleteRequestMsg)(nil), "halproto.SessionDeleteRequestMsg")
	proto.RegisterType((*SessionDeleteResponse)(nil), "halproto.SessionDeleteResponse")
	proto.RegisterType((*SessionDeleteResponseMsg)(nil), "halproto.SessionDeleteResponseMsg")
	proto.RegisterType((*SessionFilter)(nil), "halproto.SessionFilter")
	proto.RegisterType((*SessionGetRequest)(nil), "halproto.SessionGetRequest")
	proto.RegisterType((*SessionGetRequestMsg)(nil), "halproto.SessionGetRequestMsg")
	proto.RegisterType((*FlowStats)(nil), "halproto.FlowStats")
	proto.RegisterType((*SessionStats)(nil), "halproto.SessionStats")
	proto.RegisterType((*SessionGetResponse)(nil), "halproto.SessionGetResponse")
	proto.RegisterType((*SessionGetResponseMsg)(nil), "halproto.SessionGetResponseMsg")
	proto.RegisterEnum("halproto.NatType", NatType_name, NatType_value)
	proto.RegisterEnum("halproto.FlowAction", FlowAction_name, FlowAction_value)
	proto.RegisterEnum("halproto.FlowTCPState", FlowTCPState_name, FlowTCPState_value)
	proto.RegisterEnum("halproto.FlowType", FlowType_name, FlowType_value)
	proto.RegisterEnum("halproto.FlowInstance", FlowInstance_name, FlowInstance_value)
}

func init() { proto.RegisterFile("session.proto", fileDescriptor27) }

var fileDescriptor27 = []byte{
	// 3216 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0x17, 0x29, 0xf1, 0x87, 0x1e, 0x45, 0x9a, 0x1a, 0x4b, 0xb6, 0xfc, 0xdb, 0x59, 0x24, 0x48,
	0x62, 0xc7, 0x8a, 0xc1, 0xe8, 0x6b, 0x07, 0xfe, 0x7e, 0xf3, 0x35, 0x28, 0x92, 0xb2, 0x18, 0x4b,
	0x14, 0xb1, 0x64, 0x2c, 0x38, 0x87, 0x2e, 0x36, 0xbb, 0x43, 0x6a, 0xc1, 0xe5, 0xee, 0x66, 0x67,
	0x24, 0x59, 0x2e, 0x7a, 0xe8, 0xa5, 0xff, 0x40, 0x0e, 0x05, 0x7a, 0x2a, 0x72, 0xef, 0xbd, 0x40,
	0x4f, 0x3d, 0xf4, 0xd6, 0x3f, 0xa0, 0xa7, 0xa0, 0xb7, 0x1c, 0x0b, 0xe4, 0x1c, 0x14, 0xc5, 0xbc,
	0x99, 0x5d, 0x2e, 0x97, 0x94, 0xe2, 0xb6, 0x3e, 0x14, 0x3d, 0x69, 0xf9, 0xde, 0xe7, 0xfd, 0x98,
	0x37, 0x6f, 0xde, 0x7b, 0x33, 0x82, 0x32, 0xa3, 0x8c, 0x39, 0xbe, 0xb7, 0x19, 0x84, 0x3e, 0xf7,
	0x49, 0x41, 0xfd, 0xbc, 0x5e, 0xe2, 0x67, 0x01, 0x65, 0x92, 0x7a, 0xbd, 0xe4, 0x9d, 0x32, 0x6a,
	0xa9, 0x1f, 0xc5, 0xd1, 0x91, 0xfc, 0xd2, 0x4e, 0x60, 0x79, 0xc7, 0xf5, 0x4f, 0x9f, 0xd3, 0xb3,
	0xbd, 0x1a, 0x21, 0xb0, 0xc4, 0xc6, 0xa6, 0xb5, 0x91, 0xb9, 0x9b, 0xf9, 0x20, 0xaf, 0xe3, 0xb7,
	0xa0, 0xd9, 0x82, 0x96, 0x95, 0x34, 0xf1, 0x4d, 0x6e, 0x01, 0x50, 0x7e, 0x44, 0x43, 0x43, 0x18,
	0xd8, 0x58, 0xba, 0x9b, 0xf9, 0xa0, 0xac, 0x2f, 0x23, 0xa5, 0x7f, 0x16, 0x50, 0xa2, 0x41, 0xd9,
	0xad, 0x19, 0x8c, 0x0e, 0xc7, 0xd4, 0xe3, 0x86, 0x63, 0x6f, 0x2c, 0x22, 0xa2, 0xe4, 0xd6, 0x7a,
	0x92, 0xd6, 0xb6, 0xb5, 0xa7, 0xb0, 0xaa, 0xec, 0xf6, 0xad, 0xe0, 0x0b, 0x3b, 0x68, 0x7b, 0x03,
	0x9f, 0xac, 0x41, 0x8e, 0x05, 0x7e, 0xc8, 0xd1, 0x81, 0xb2, 0x2e, 0x7f, 0x08, 0xaa, 0x8d, 0xd4,
	0xac, 0xa4, 0xe2, 0x0f, 0xad, 0x0d, 0x97, 0x94, 0x82, 0x76, 0x63, 0xbf, 0x8b, 0xe2, 0x04, 0x96,
	0xd0, 0x21, 0x29, 0x8d, 0xdf, 0x82, 0x66, 0xf9, 0x36, 0x55, 0xb2, 0xf8, 0x4d, 0x2a, 0x90, 0x8d,
	0x9d, 0xca, 0x3a, 0xb6, 0xa6, 0x41, 0x45, 0xa9, 0x6a, 0xf5, 0xa4, 0xa6, 0x2a, 0x2c, 0xb2, 0xc0,
	0x51, 0x8a, 0xc4, 0xa7, 0xf6, 0xf7, 0x4c, 0x1c, 0xa8, 0x17, 0x5b, 0xc8, 0x77, 0x02, 0xe4, 0x17,
	0x74, 0xf1, 0x29, 0x28, 0xb6, 0x13, 0xa0, 0x99, 0x82, 0x2e, 0x3e, 0xc9, 0x47, 0x50, 0x74, 0x02,
	0x03, 0xa3, 0x8c, 0xb6, 0x2a, 0xb5, 0xd5, 0x4d, 0xb9, 0x21, 0xed, 0x6e, 0x57, 0x50, 0x2d, 0xdf,
	0xd5, 0x0b, 0x4e, 0x80, 0xdf, 0xe4, 0x7f, 0xa0, 0xc0, 0xad, 0xc0, 0x38, 0xb6, 0x03, 0x8c, 0x67,
	0xa9, 0x76, 0x7d, 0x33, 0xda, 0xd5, 0x99, 0x38, 0xed, 0x2e, 0xe8, 0x79, 0x8e, 0xbf, 0xc8, 0x26,
	0x2c, 0x39, 0xd6, 0x38, 0xd8, 0xc8, 0xa1, 0xcc, 0x46, 0x5a, 0x26, 0x0a, 0xcd, 0xee, 0x82, 0x8e,
	0x38, 0x72, 0x1f, 0x16, 0x29, 0x0b, 0x36, 0xf2, 0x08, 0xbf, 0x9a, 0x86, 0xab, 0xe5, 0xef, 0x2e,
	0xe8, 0x02, 0xb5, 0x5d, 0x82, 0x65, 0x77, 0xcb, 0x18, 0x38, 0xd4, 0xb5, 0x99, 0xf6, 0x6d, 0x76,
	0x12, 0x80, 0x47, 0x44, 0x9b, 0x04, 0xa0, 0x54, 0xab, 0xc6, 0xeb, 0xaa, 0xdb, 0x76, 0x48, 0x19,
	0x93, 0x21, 0xd1, 0x26, 0x21, 0x99, 0x8b, 0xf9, 0x2f, 0x0c, 0xd2, 0x5f, 0x32, 0x50, 0x50, 0x30,
	0x72, 0x13, 0x80, 0x85, 0x96, 0x71, 0x12, 0x0e, 0xc4, 0x11, 0x90, 0x47, 0xaa, 0xc8, 0x42, 0xeb,
	0x45, 0x38, 0x68, 0xdb, 0x82, 0x6b, 0x33, 0x1e, 0x71, 0xe5, 0xe1, 0x2a, 0xda, 0x8c, 0x4b, 0xee,
	0x7d, 0xc8, 0xbb, 0x35, 0x63, 0x44, 0xcf, 0x30, 0x28, 0xa5, 0x1a, 0x49, 0x3b, 0xb1, 0x57, 0xdb,
	0x5d, 0xd0, 0x73, 0x6e, 0x4d, 0x18, 0xba, 0x0f, 0xf9, 0x93, 0x2d, 0x04, 0x2f, 0xcd, 0x07, 0xbf,
	0xd8, 0x12, 0xe0, 0x93, 0xad, 0x08, 0xfc, 0x08, 0xc1, 0xb9, 0x73, 0xc0, 0x8f, 0x10, 0xfc, 0xe8,
	0x39, 0x3d, 0xdb, 0x06, 0x28, 0x0e, 0x5c, 0xff, 0x54, 0xc0, 0xb5, 0xef, 0x97, 0xa0, 0x28, 0x20,
	0x78, 0x3e, 0xb6, 0xa0, 0x84, 0x0c, 0xd3, 0xe2, 0x8e, 0xef, 0xe1, 0xe2, 0x2a, 0xb5, 0xcb, 0x53,
	0xaa, 0xea, 0xc8, 0xd2, 0x61, 0x10, 0x7f, 0x93, 0x6b, 0x4a, 0x9d, 0x39, 0x8c, 0xce, 0x63, 0x01,
	0xb9, 0x43, 0x4a, 0x6e, 0x43, 0x89, 0x3b, 0x63, 0x6a, 0x70, 0x1f, 0xb9, 0xf2, 0x6c, 0x2e, 0x0b,
	0x52, 0xdf, 0x17, 0xfc, 0xfb, 0x50, 0xf4, 0x4c, 0x3e, 0xa9, 0x37, 0x95, 0x5a, 0x35, 0xb6, 0xd6,
	0x31, 0xb9, 0x28, 0x3b, 0x7a, 0xc1, 0x93, 0x1f, 0xe4, 0x43, 0x10, 0x9f, 0x86, 0x48, 0xd0, 0xdc,
	0x39, 0xc9, 0x97, 0xf7, 0x4c, 0xde, 0x73, 0x02, 0x72, 0x03, 0x96, 0x11, 0x8a, 0xf5, 0x25, 0x8f,
	0x56, 0x85, 0xa1, 0x1e, 0x16, 0x1e, 0xa5, 0x47, 0x24, 0x71, 0xe1, 0x02, 0x3d, 0xcd, 0x89, 0x1e,
	0x59, 0xa7, 0x8a, 0xb1, 0x9e, 0x26, 0xea, 0xb9, 0x26, 0x9d, 0xc7, 0x32, 0xba, 0x8c, 0x3b, 0x2d,
	0xf4, 0x36, 0x45, 0x25, 0xad, 0xc1, 0xb2, 0xc8, 0x68, 0xc6, 0x4d, 0x4e, 0x37, 0x00, 0x17, 0xb6,
	0x3e, 0x15, 0xc6, 0x7e, 0xa3, 0xdb, 0x13, 0x4c, 0xbd, 0xc8, 0xad, 0x00, 0xbf, 0x88, 0x07, 0x97,
	0x1d, 0x6f, 0x68, 0x8c, 0x9d, 0x30, 0xf4, 0x43, 0x43, 0x81, 0xd9, 0x46, 0xe9, 0xee, 0x22, 0x9e,
	0x88, 0xd1, 0xd1, 0xe6, 0x3e, 0xb2, 0x7a, 0x92, 0xf3, 0x9c, 0x9e, 0xed, 0x9a, 0x9e, 0xed, 0xd2,
	0x6d, 0xed, 0x87, 0xef, 0xee, 0xdc, 0x3e, 0xa1, 0x9e, 0x63, 0xd1, 0x27, 0x96, 0xef, 0x31, 0x1e,
	0x9a, 0x8e, 0xc7, 0xd9, 0x67, 0x3f, 0x0f, 0x4d, 0x6f, 0x48, 0x9f, 0x3c, 0x7c, 0xf0, 0xf8, 0x17,
	0xfa, 0xaa, 0xe3, 0x0d, 0xa7, 0xc4, 0x99, 0xb0, 0x47, 0x87, 0xe1, 0x8c, 0xbd, 0x95, 0xb7, 0x63,
	0x8f, 0x0e, 0xc3, 0x69, 0x7b, 0xda, 0xdf, 0x72, 0x70, 0xb9, 0xe1, 0x7b, 0x5e, 0x3f, 0x34, 0xad,
	0x51, 0xeb, 0x95, 0x45, 0x03, 0x8e, 0x7e, 0x7c, 0x04, 0x04, 0x63, 0x75, 0xe6, 0x19, 0x21, 0xe5,
	0xa1, 0xe9, 0xb1, 0xb1, 0x23, 0x5b, 0x45, 0x51, 0xaf, 0x8a, 0xe8, 0x9c, 0x79, 0x7a, 0x4c, 0x27,
	0x1f, 0xc2, 0xaa, 0x40, 0x9f, 0x3a, 0x9e, 0xf1, 0x9a, 0x86, 0xbe, 0x61, 0x87, 0xbe, 0xac, 0x45,
	0x45, 0xbd, 0xc2, 0xad, 0xe0, 0xd0, 0xf1, 0xbe, 0xa4, 0xa1, 0xdf, 0x0c, 0x7d, 0x51, 0x1f, 0x2e,
	0x0b, 0xe8, 0xe0, 0xd8, 0x75, 0x93, 0x9a, 0x17, 0x11, 0x2c, 0xb4, 0xec, 0x1c, 0xbb, 0x6e, 0x42,
	0xb5, 0xc2, 0x07, 0x66, 0xc8, 0x1d, 0xd3, 0x35, 0xfc, 0x13, 0x1a, 0xba, 0xa6, 0x2c, 0x49, 0x12,
	0xdf, 0x95, 0x9c, 0x03, 0xc9, 0x88, 0x1c, 0x0f, 0x4c, 0x6b, 0x44, 0xb9, 0x11, 0x52, 0x3f, 0xb4,
	0x69, 0x88, 0xa9, 0x29, 0x1d, 0xef, 0x22, 0x43, 0x97, 0xf4, 0xc8, 0x71, 0xff, 0x98, 0x1b, 0xfe,
	0x40, 0xf8, 0x6f, 0xfb, 0xa7, 0x98, 0x9a, 0xd2, 0xf1, 0x83, 0x63, 0x7e, 0x30, 0x38, 0x44, 0x2a,
	0x79, 0x20, 0x1d, 0x71, 0xbc, 0x13, 0xd3, 0x75, 0x6c, 0xc3, 0xb4, 0x46, 0x86, 0x77, 0x3c, 0xc6,
	0x64, 0x95, 0x9a, 0xdb, 0x92, 0x53, 0xb7, 0x46, 0x9d, 0xe3, 0x31, 0xd9, 0x82, 0x2b, 0x02, 0xee,
	0xf9, 0xe1, 0xd8, 0x74, 0x9d, 0xd7, 0xa6, 0x08, 0xab, 0x8c, 0x4b, 0x11, 0x25, 0xd6, 0xb8, 0x15,
	0x74, 0x92, 0x4c, 0x8c, 0xce, 0x53, 0xb8, 0x89, 0x61, 0x0f, 0x5c, 0x87, 0x1b, 0x47, 0xa6, 0x67,
	0xb3, 0x23, 0x73, 0x44, 0x0d, 0x9b, 0x72, 0x6a, 0x71, 0x6a, 0x63, 0x46, 0x17, 0xf5, 0x6b, 0x62,
	0x03, 0x04, 0x64, 0x37, 0x42, 0x34, 0x15, 0x80, 0xdc, 0x97, 0xcb, 0xb7, 0x4d, 0x6e, 0x1a, 0xe6,
	0x80, 0xd3, 0xd0, 0x18, 0x38, 0x1e, 0x26, 0x7b, 0x51, 0xbf, 0xc4, 0xad, 0xa0, 0x69, 0x72, 0xb3,
	0x2e, 0xe8, 0x3b, 0x8e, 0x47, 0x1e, 0xc3, 0x35, 0xe9, 0xa3, 0x67, 0x84, 0x8c, 0x1b, 0xc1, 0x88,
	0x2b, 0x99, 0x90, 0xf1, 0x8d, 0x52, 0xc2, 0x4d, 0x4f, 0x67, 0xbc, 0x3b, 0xe2, 0x28, 0xa8, 0x33,
	0x4e, 0xf6, 0xe1, 0xdd, 0x64, 0x2c, 0x06, 0x4e, 0x24, 0x3e, 0x08, 0xfd, 0xb1, 0x11, 0x52, 0x16,
	0xf8, 0x9e, 0x08, 0xfb, 0x0a, 0xea, 0xb8, 0x33, 0x09, 0xce, 0x8e, 0x40, 0x76, 0x47, 0x7c, 0x27,
	0xf4, 0xc7, 0x7a, 0x04, 0x8b, 0xf6, 0xec, 0xd8, 0xa3, 0xaf, 0x02, 0x5c, 0x86, 0xd0, 0xb5, 0x51,
	0x8e, 0x23, 0xfb, 0x45, 0xcc, 0xe8, 0x8e, 0x38, 0xf9, 0x4c, 0xc6, 0x48, 0x98, 0x3c, 0x75, 0xf8,
	0xd1, 0xcc, 0x8e, 0x54, 0x50, 0xee, 0x2a, 0xb7, 0x02, 0x9d, 0xf1, 0x43, 0x87, 0x1f, 0x4d, 0x6d,
	0x8c, 0xf6, 0xcd, 0x12, 0x94, 0xe3, 0x8c, 0xc7, 0x02, 0xfb, 0x2e, 0x54, 0xb0, 0x54, 0x5a, 0x21,
	0x35, 0x39, 0x35, 0x38, 0x53, 0x0d, 0x64, 0x45, 0x50, 0x1b, 0x48, 0xec, 0x33, 0x31, 0x87, 0x21,
	0xea, 0xab, 0x33, 0x4e, 0x99, 0x6a, 0x22, 0xcb, 0x82, 0xb2, 0x2d, 0x08, 0xe4, 0x1d, 0x40, 0xb8,
	0x4a, 0x3c, 0x86, 0x09, 0x5d, 0xd0, 0xb1, 0x72, 0xcb, 0x94, 0x63, 0xe4, 0xff, 0x00, 0x68, 0x7c,
	0xc2, 0x54, 0xff, 0xb8, 0x19, 0x17, 0xa0, 0x39, 0xa7, 0x50, 0x4f, 0xe0, 0xb1, 0x6a, 0x8b, 0xd4,
	0xa0, 0x5f, 0xe3, 0x2a, 0x73, 0xa8, 0x5f, 0x14, 0xb4, 0x1e, 0xfd, 0x5a, 0x24, 0x9c, 0xe2, 0x47,
	0x51, 0xc8, 0xc7, 0x7c, 0x95, 0x90, 0x37, 0x01, 0xa2, 0x33, 0xca, 0x5e, 0x63, 0xda, 0x96, 0xb1,
	0xce, 0x1d, 0x3a, 0x5e, 0xef, 0xb5, 0x18, 0x23, 0x63, 0xae, 0x65, 0xba, 0x54, 0xd5, 0xd5, 0x92,
	0x02, 0x08, 0x12, 0xb9, 0x2a, 0x27, 0x82, 0x31, 0x63, 0x98, 0x87, 0x65, 0xec, 0xf9, 0xfb, 0x8c,
	0x91, 0x4f, 0x65, 0x1e, 0x31, 0x61, 0x3b, 0xa0, 0xe1, 0xd8, 0xf0, 0xd1, 0x67, 0x83, 0x51, 0x8f,
	0xab, 0xdc, 0x5b, 0x17, 0x8e, 0x9a, 0xd6, 0xa8, 0x4b, 0xc3, 0xf1, 0x01, 0x72, 0x7b, 0xd4, 0xe3,
	0xe2, 0x50, 0x39, 0x18, 0x36, 0x51, 0x68, 0x84, 0xb8, 0x4d, 0x5d, 0x6e, 0x62, 0xee, 0xad, 0xea,
	0x55, 0x64, 0xf5, 0xce, 0xbc, 0xba, 0x35, 0x6a, 0x0a, 0x7a, 0x94, 0xdd, 0xa7, 0x6c, 0xca, 0xc2,
	0x4a, 0x9c, 0xdd, 0x87, 0x2c, 0xa1, 0x5b, 0x81, 0xf9, 0x34, 0xb8, 0x1c, 0x83, 0xfb, 0x09, 0xb0,
	0xf6, 0x5a, 0x36, 0x5c, 0x71, 0x3c, 0xc8, 0x26, 0xe0, 0xbe, 0x1a, 0x8e, 0x37, 0xf0, 0xd5, 0xd4,
	0xb5, 0x3a, 0xd5, 0x27, 0x44, 0xd6, 0xe8, 0xd8, 0x5e, 0x31, 0x7f, 0xfe, 0x1f, 0x2e, 0x59, 0xbe,
	0xe7, 0x19, 0x5c, 0xec, 0x9e, 0x94, 0x92, 0x73, 0xd8, 0x95, 0xd9, 0xcd, 0x45, 0xd1, 0xb2, 0x95,
	0xfc, 0xa9, 0x0d, 0xa5, 0xed, 0x5e, 0x40, 0x2d, 0xd1, 0x7b, 0xa3, 0x29, 0x20, 0x1e, 0xf8, 0x52,
	0x43, 0x83, 0x6c, 0xe4, 0x62, 0xbe, 0x88, 0x1c, 0x15, 0xa7, 0x5d, 0x99, 0x9c, 0x76, 0x54, 0x2c,
	0x47, 0x3a, 0x2a, 0xbe, 0xb4, 0xef, 0x17, 0xa1, 0xa4, 0x2a, 0x3f, 0x1a, 0x7b, 0x04, 0x15, 0x31,
	0x13, 0x8d, 0xe8, 0x19, 0xd6, 0x1a, 0x97, 0xc6, 0x26, 0x47, 0x47, 0x9b, 0x2f, 0xc2, 0x41, 0xdc,
	0x5d, 0xf4, 0x95, 0x93, 0xc4, 0x2f, 0xf2, 0x00, 0x40, 0x59, 0x89, 0xe6, 0xa9, 0xc2, 0x76, 0xe5,
	0x87, 0xef, 0xee, 0x80, 0xea, 0x3f, 0x23, 0x7a, 0xa6, 0x2f, 0x2b, 0x44, 0xdb, 0x16, 0xb9, 0x95,
	0x88, 0x0f, 0xf5, 0x54, 0xb1, 0x2f, 0xc5, 0x51, 0x68, 0x79, 0x51, 0xfe, 0xc5, 0x9b, 0xa5, 0x0a,
	0x7c, 0x29, 0xb1, 0x4f, 0xe4, 0x63, 0x58, 0x9b, 0x97, 0x66, 0xaa, 0xb8, 0xaf, 0xce, 0x64, 0x18,
	0xf9, 0x14, 0x2a, 0x8e, 0xe7, 0x70, 0xc7, 0xe4, 0x7e, 0x68, 0x88, 0x28, 0xa8, 0x31, 0x73, 0x3a,
	0x48, 0x22, 0x14, 0x7a, 0x39, 0x06, 0x0a, 0x92, 0x90, 0x8c, 0xab, 0x98, 0x94, 0x2c, 0x9c, 0x2b,
	0x19, 0x03, 0x51, 0xb2, 0x0e, 0x97, 0x03, 0x4a, 0x43, 0x23, 0x65, 0xb8, 0x78, 0x9e, 0xf8, 0xaa,
	0x40, 0xb7, 0xa7, 0x8c, 0x47, 0x2a, 0x52, 0x1e, 0x2c, 0x5f, 0xa8, 0x42, 0x4f, 0x7a, 0xa1, 0x35,
	0x60, 0x55, 0x6d, 0xb4, 0x4e, 0xbf, 0x3e, 0xa6, 0x8c, 0xef, 0xb3, 0x21, 0xd9, 0x84, 0x42, 0x28,
	0x7f, 0x6d, 0x64, 0x70, 0x9e, 0x58, 0x8b, 0x75, 0x25, 0xb2, 0x42, 0x8f, 0x40, 0xda, 0x6f, 0xb3,
	0x00, 0x68, 0x84, 0x9b, 0xfc, 0x98, 0x91, 0x3b, 0x6a, 0x0e, 0x4d, 0xa4, 0x4a, 0x5e, 0x8e, 0x9c,
	0x2a, 0x2d, 0xfe, 0xcd, 0x73, 0x20, 0xe6, 0x3a, 0x59, 0x87, 0x7d, 0xd7, 0x55, 0x39, 0x82, 0xb9,
	0xdb, 0xf0, 0x5d, 0x37, 0x66, 0x1e, 0x99, 0xec, 0x48, 0xdd, 0x82, 0x8b, 0xd2, 0x36, 0x3b, 0x22,
	0xff, 0xab, 0x2a, 0xb8, 0xed, 0x84, 0xd4, 0x8a, 0x73, 0xa2, 0x52, 0x5b, 0x53, 0x33, 0x24, 0x9e,
	0x85, 0x88, 0xa7, 0x97, 0x07, 0xc9, 0x9f, 0xe4, 0x09, 0x94, 0xd5, 0x71, 0x67, 0xdc, 0xf4, 0x2c,
	0x8a, 0x49, 0x92, 0x1e, 0x0d, 0xdb, 0x8a, 0x29, 0x9b, 0x42, 0xf4, 0x4b, 0x63, 0x50, 0xea, 0xef,
	0xf4, 0xbb, 0xf5, 0xbd, 0x67, 0xb8, 0x82, 0x9b, 0xb0, 0xec, 0x30, 0xcb, 0xf7, 0x78, 0xe8, 0xbb,
	0x6a, 0x58, 0x9a, 0x10, 0x44, 0x00, 0x03, 0x33, 0x64, 0xd4, 0xa0, 0x62, 0x04, 0x53, 0x53, 0x39,
	0x20, 0xa9, 0x25, 0x28, 0xe4, 0x3d, 0xa8, 0x1c, 0x7b, 0x23, 0xcf, 0x3f, 0xf5, 0x0c, 0x3f, 0xc0,
	0x9b, 0xb4, 0x9c, 0xcd, 0xcb, 0x8a, 0x7a, 0x80, 0x44, 0xed, 0x4f, 0x19, 0x00, 0xbd, 0xdb, 0x78,
	0x4b, 0x46, 0x35, 0x28, 0x7b, 0xc7, 0x63, 0x39, 0x31, 0x88, 0x15, 0x47, 0x0f, 0x08, 0xde, 0xf1,
	0x58, 0x14, 0x0d, 0x91, 0x19, 0x11, 0x86, 0xbe, 0x0a, 0x30, 0x15, 0x99, 0xda, 0x00, 0x81, 0x69,
	0xbd, 0x0a, 0x44, 0x7c, 0x18, 0x79, 0x08, 0x6b, 0x63, 0xf3, 0x95, 0x18, 0x02, 0x98, 0xf3, 0x9a,
	0x1a, 0xa2, 0x73, 0x51, 0x9b, 0xda, 0xb8, 0x13, 0x65, 0x9d, 0x48, 0x5e, 0xcf, 0x79, 0x4d, 0x5b,
	0x8a, 0xa3, 0x3d, 0x00, 0xe8, 0xb5, 0xe3, 0xd8, 0xa5, 0x1c, 0xcd, 0xa4, 0x1d, 0xd5, 0xbe, 0xc9,
	0x00, 0xbc, 0xbd, 0x58, 0xbf, 0xa5, 0x65, 0x6b, 0x7f, 0xcd, 0x40, 0x49, 0xef, 0xf7, 0xde, 0xd0,
	0xad, 0x9b, 0x10, 0xd5, 0x45, 0x55, 0x38, 0x97, 0xf5, 0x09, 0x41, 0xcc, 0x10, 0x09, 0xa7, 0x63,
	0x97, 0x26, 0x5e, 0xb3, 0x59, 0xb7, 0x97, 0xde, 0xc0, 0xed, 0xdc, 0xec, 0x6e, 0xdd, 0x83, 0x55,
	0x81, 0x09, 0x39, 0x0b, 0x26, 0xb7, 0x0c, 0x79, 0x27, 0xbb, 0xe4, 0x1d, 0x8f, 0x75, 0xce, 0x82,
	0xf8, 0x8e, 0x30, 0x06, 0x68, 0x76, 0x7a, 0xd1, 0x02, 0xd3, 0x4e, 0x66, 0x66, 0x9d, 0x5c, 0x87,
	0xbc, 0xed, 0xb1, 0xa8, 0x37, 0x94, 0xf5, 0x9c, 0xed, 0xb1, 0xb6, 0x2d, 0xd2, 0x1b, 0xef, 0x9d,
	0x21, 0x1d, 0x9b, 0x8e, 0xe7, 0x78, 0xc3, 0x28, 0xbd, 0x05, 0x55, 0x8f, 0x88, 0xda, 0x1f, 0x73,
	0x50, 0x8e, 0xea, 0x91, 0xac, 0x3c, 0xef, 0x41, 0x25, 0xea, 0x37, 0x53, 0xc5, 0x27, 0x7a, 0x8b,
	0x53, 0xf5, 0xe7, 0x11, 0xac, 0xa8, 0x61, 0x02, 0xc5, 0x54, 0xf1, 0x99, 0xbe, 0x29, 0x4b, 0x8d,
	0x7a, 0x49, 0x8e, 0x16, 0x52, 0xfd, 0x23, 0x58, 0x09, 0x93, 0x72, 0x8b, 0x17, 0xc8, 0x85, 0x09,
	0xb9, 0xa7, 0xb0, 0x2a, 0x4b, 0x7d, 0x52, 0x78, 0xe9, 0x7c, 0xe1, 0x4b, 0x58, 0xea, 0xe7, 0x28,
	0x98, 0xb2, 0x9e, 0xfb, 0x09, 0x05, 0x7a, 0x42, 0xc1, 0x3a, 0xe4, 0xcd, 0x20, 0x10, 0x81, 0x96,
	0x5b, 0x97, 0x33, 0x83, 0xa0, 0x6d, 0x93, 0xbb, 0xb0, 0x22, 0xc9, 0xea, 0xae, 0x2b, 0x87, 0x3d,
	0x40, 0xa6, 0xbc, 0xd6, 0xde, 0x85, 0x45, 0xd3, 0x1d, 0x62, 0x57, 0xaa, 0xd4, 0x2a, 0x9b, 0xf2,
	0xb9, 0xb2, 0xbe, 0xf7, 0xac, 0x63, 0x8e, 0xa9, 0x2e, 0x58, 0xe4, 0x13, 0x58, 0xe6, 0x03, 0x1e,
	0xc8, 0x32, 0x2e, 0x5b, 0xcf, 0xa4, 0x5d, 0x24, 0x6a, 0xde, 0xee, 0x82, 0x5e, 0x14, 0x40, 0xcc,
	0x8d, 0x87, 0x50, 0x0c, 0x03, 0x4b, 0xca, 0x40, 0x6a, 0x1d, 0x93, 0x8a, 0xb5, 0xbb, 0xa0, 0x17,
	0xc2, 0xc0, 0x8a, 0x24, 0x98, 0xa3, 0xac, 0x94, 0x52, 0x12, 0x93, 0xe2, 0x20, 0x24, 0x98, 0x23,
	0x6d, 0x7c, 0x02, 0xcb, 0x98, 0xb5, 0x28, 0xb2, 0x92, 0x72, 0x2c, 0x71, 0x12, 0x85, 0x63, 0x02,
	0x18, 0x99, 0xc1, 0x8c, 0x14, 0x32, 0xe5, 0x94, 0x99, 0x49, 0x6e, 0x0b, 0x33, 0x22, 0x55, 0x95,
	0x44, 0xbc, 0xfc, 0x4a, 0x7a, 0x4b, 0x92, 0xab, 0x2f, 0xa8, 0xc5, 0x6f, 0x03, 0x14, 0x4d, 0x77,
	0x88, 0x12, 0x5a, 0x08, 0x97, 0xe2, 0xfe, 0x2b, 0xfa, 0x32, 0xa3, 0xe4, 0x63, 0x00, 0x33, 0x70,
	0xa2, 0x5d, 0xce, 0xa8, 0x77, 0x15, 0xd9, 0x9f, 0xea, 0x81, 0xa3, 0xb6, 0x78, 0xd9, 0x8c, 0x3e,
	0xc9, 0x26, 0xe4, 0xa7, 0x12, 0xf9, 0xca, 0x4c, 0xb7, 0x96, 0x22, 0x0a, 0xa5, 0x7d, 0x0e, 0x24,
	0x65, 0x53, 0x34, 0xfd, 0x2d, 0x28, 0x86, 0xea, 0xa7, 0xea, 0xfa, 0x1b, 0x69, 0x3d, 0x11, 0x5c,
	0x8f, 0x91, 0xda, 0x6f, 0x32, 0xb0, 0xa6, 0xb8, 0x4d, 0xea, 0x52, 0x4e, 0xd5, 0x18, 0x41, 0x1e,
	0xcf, 0x3f, 0x8a, 0xe9, 0xf1, 0x6f, 0x77, 0x21, 0x7d, 0x38, 0x9f, 0x4e, 0x04, 0x07, 0x8e, 0xcb,
	0x69, 0x78, 0xde, 0xaa, 0x76, 0x90, 0x9b, 0x50, 0x20, 0x09, 0xdb, 0x45, 0xc8, 0x0f, 0x29, 0x37,
	0xbe, 0x3a, 0xd3, 0x74, 0xb8, 0x3a, 0xcf, 0x37, 0xb1, 0xda, 0xc7, 0xe9, 0x11, 0xe7, 0x56, 0x5a,
	0xfd, 0x94, 0xc8, 0x64, 0xd6, 0xf9, 0x55, 0x06, 0xd6, 0x53, 0x08, 0xb5, 0x6f, 0x3b, 0x6f, 0xb2,
	0x6f, 0xdb, 0xeb, 0x3f, 0x7c, 0x77, 0x67, 0x55, 0xad, 0x7f, 0x02, 0x4f, 0x6e, 0xe7, 0x6c, 0x11,
	0xcb, 0xce, 0x29, 0x62, 0xda, 0x0b, 0xd8, 0x98, 0xeb, 0x87, 0x58, 0xdd, 0x93, 0x99, 0xbd, 0xbc,
	0x7d, 0xde, 0xf2, 0x66, 0x76, 0xf4, 0xdb, 0x6c, 0x5c, 0x55, 0x65, 0x40, 0xc9, 0xfb, 0x90, 0x67,
	0xa1, 0x65, 0x5c, 0xf0, 0xb2, 0x9c, 0x63, 0xa1, 0xd5, 0x0e, 0x04, 0xd0, 0x66, 0xdc, 0xb8, 0xe0,
	0x79, 0x39, 0x67, 0x33, 0xde, 0x0e, 0xc8, 0x35, 0x28, 0x0a, 0x8d, 0xf8, 0x2e, 0x27, 0x4b, 0x7b,
	0x81, 0x85, 0x56, 0x57, 0x3d, 0xcb, 0x09, 0x1d, 0xc8, 0x92, 0x2d, 0xab, 0x60, 0x33, 0x8e, 0xac,
	0xe4, 0xb3, 0x74, 0xee, 0x27, 0x9f, 0xa5, 0xd7, 0x21, 0xaf, 0xde, 0x71, 0xf3, 0x18, 0xbe, 0xdc,
	0x09, 0x3e, 0xe2, 0xce, 0xfc, 0x1b, 0xa4, 0x30, 0xf3, 0x6f, 0x90, 0x9f, 0x2e, 0x7a, 0xda, 0xaf,
	0x33, 0xf1, 0xdc, 0xfc, 0x8c, 0xf2, 0xff, 0xa4, 0x9c, 0xdf, 0x8b, 0xcf, 0xe3, 0xc4, 0x31, 0x79,
	0xbc, 0x53, 0x09, 0x7f, 0x3d, 0xad, 0x7b, 0x82, 0x9f, 0x64, 0xfb, 0xef, 0xd4, 0xff, 0x17, 0x44,
	0x6a, 0x32, 0xb2, 0x05, 0x57, 0xe4, 0xd3, 0x05, 0x0d, 0xc7, 0x0e, 0xc7, 0xe7, 0x17, 0xf5, 0x88,
	0x21, 0xdb, 0xec, 0x1a, 0x3e, 0x62, 0x44, 0xcc, 0xe8, 0x35, 0xe3, 0x21, 0xac, 0xa5, 0xa4, 0x92,
	0x2f, 0x23, 0x64, 0x4a, 0x46, 0x3e, 0x91, 0x44, 0x12, 0x76, 0xe8, 0x07, 0x41, 0xc2, 0xca, 0xe2,
	0x44, 0xa2, 0x29, 0x59, 0x91, 0x8d, 0x8f, 0x80, 0x4c, 0x49, 0x48, 0x0b, 0x4b, 0x88, 0xaf, 0x26,
	0xf0, 0x52, 0xff, 0xc7, 0xb0, 0x26, 0x66, 0x1a, 0xbc, 0x47, 0x3a, 0xd6, 0xc8, 0xa5, 0x4c, 0x5e,
	0xf9, 0x73, 0x88, 0x17, 0xf3, 0x4e, 0xdf, 0x0a, 0xfa, 0x92, 0x83, 0x2f, 0x04, 0xef, 0x43, 0x35,
	0x12, 0x08, 0x19, 0x97, 0x60, 0x99, 0x55, 0x65, 0x09, 0xd6, 0x19, 0xc7, 0xd7, 0x81, 0xdf, 0x67,
	0x61, 0x25, 0x51, 0x74, 0x19, 0x69, 0xc2, 0xda, 0xf4, 0x05, 0x0f, 0x0f, 0x3c, 0x53, 0x27, 0x89,
	0xcc, 0x34, 0x6f, 0xa6, 0x93, 0xa9, 0x0b, 0x66, 0xac, 0x65, 0xfa, 0x8e, 0xa7, 0xb4, 0x64, 0xcf,
	0xd7, 0x32, 0x75, 0xd9, 0x94, 0x5a, 0xf6, 0xe1, 0xda, 0x9c, 0x1b, 0xa7, 0x52, 0xb5, 0x78, 0xae,
	0xaa, 0x2b, 0x33, 0x17, 0xcf, 0x69, 0x75, 0x73, 0x3d, 0x5b, 0xba, 0x58, 0x9d, 0x3e, 0xe3, 0x9d,
	0xf6, 0xe7, 0x4c, 0xdc, 0x96, 0x30, 0x13, 0xff, 0xd5, 0x6e, 0xf8, 0x01, 0x2c, 0xb1, 0x80, 0x5a,
	0x2a, 0x36, 0xf3, 0x6f, 0xae, 0x88, 0x48, 0xf4, 0xcd, 0xc5, 0x37, 0xe9, 0x9b, 0xe4, 0x3e, 0xe4,
	0x92, 0x8b, 0x5b, 0x9f, 0x07, 0x17, 0xb5, 0x10, 0x97, 0xf3, 0xcb, 0x49, 0x9f, 0x48, 0x2c, 0x47,
	0x9c, 0xc4, 0x7f, 0x7a, 0x45, 0x8f, 0x13, 0xd5, 0x3c, 0x8b, 0x67, 0xf7, 0xc6, 0xdc, 0xb3, 0x9b,
	0x2e, 0xe5, 0xf7, 0xbe, 0x84, 0x82, 0xfa, 0x37, 0x0c, 0x59, 0x85, 0x72, 0xa7, 0xde, 0x37, 0xfa,
	0x2f, 0xbb, 0x2d, 0xa3, 0x73, 0xd0, 0x69, 0x55, 0x17, 0xa6, 0x48, 0xbd, 0x4e, 0xbd, 0x5f, 0xcd,
	0x4c, 0x91, 0x9a, 0x82, 0x94, 0x25, 0x57, 0x80, 0xc4, 0xa4, 0xfe, 0x61, 0xbb, 0xd1, 0x32, 0x04,
	0x7d, 0xf1, 0xde, 0x81, 0xbc, 0xf2, 0xab, 0x7f, 0x22, 0xad, 0x41, 0x75, 0x67, 0xef, 0xe0, 0xd0,
	0xa8, 0x37, 0xfa, 0xed, 0x83, 0x4e, 0x64, 0x61, 0x1d, 0x56, 0x93, 0xd4, 0xfa, 0xde, 0xde, 0xc1,
	0x61, 0x35, 0x93, 0x06, 0x37, 0xf5, 0x83, 0x6e, 0x35, 0x7b, 0xef, 0xc7, 0x0c, 0xac, 0x24, 0xff,
	0xb7, 0x42, 0xae, 0xc2, 0x65, 0x84, 0xf5, 0x1b, 0x5d, 0xa3, 0xd7, 0xaf, 0xf7, 0x5b, 0x46, 0xbb,
	0xd3, 0xee, 0x57, 0x17, 0xc8, 0x0d, 0xb8, 0x9a, 0x62, 0xf4, 0x5e, 0x76, 0x0c, 0xbd, 0xf1, 0xa2,
	0x59, 0xcd, 0xcc, 0x61, 0xd6, 0x1b, 0xcf, 0x25, 0x33, 0x4b, 0xee, 0xc0, 0x8d, 0x39, 0x92, 0x31,
	0x60, 0x91, 0xdc, 0x86, 0xeb, 0x29, 0x40, 0xab, 0xd7, 0xaf, 0x6f, 0xef, 0xb5, 0x7b, 0xbb, 0xad,
	0x66, 0x75, 0x69, 0x8e, 0xf6, 0x9d, 0xb6, 0x32, 0x9d, 0x23, 0xef, 0xc0, 0xad, 0x14, 0x73, 0xbb,
	0xdd, 0x6c, 0xeb, 0x13, 0x48, 0x9e, 0x6c, 0xc0, 0x5a, 0x0a, 0xa2, 0xb7, 0x7a, 0xad, 0x7e, 0xb5,
	0x70, 0xef, 0x0f, 0x19, 0xf9, 0xb8, 0xd7, 0x97, 0xff, 0x1f, 0xaf, 0x48, 0x58, 0x62, 0xbb, 0xae,
	0xc1, 0xfa, 0x84, 0xd6, 0xd8, 0xab, 0xf7, 0x7a, 0xed, 0x86, 0xd1, 0x69, 0x37, 0xaa, 0x99, 0x69,
	0xb8, 0xde, 0xdc, 0xaf, 0x57, 0xb3, 0x71, 0x90, 0xe5, 0xc6, 0x35, 0xba, 0xfd, 0xbd, 0x5e, 0x75,
	0x91, 0x5c, 0x86, 0x4b, 0x13, 0x6a, 0xbb, 0xdb, 0x6b, 0x35, 0xaa, 0x4b, 0x62, 0xd7, 0x13, 0xd6,
	0x9a, 0xad, 0x6a, 0x2e, 0xde, 0x39, 0x99, 0x1c, 0xfd, 0x03, 0xbd, 0xfe, 0xac, 0x55, 0xcd, 0x4f,
	0xb6, 0x04, 0x95, 0xb6, 0xf6, 0x5a, 0xfb, 0xad, 0xbe, 0xfe, 0xb2, 0x5a, 0xb8, 0xf7, 0x33, 0xb9,
	0x77, 0xd1, 0x73, 0x87, 0xc8, 0x1a, 0x04, 0xb6, 0x3b, 0xbd, 0x7e, 0xbd, 0xd3, 0x98, 0x59, 0x44,
	0x4c, 0xef, 0xea, 0xed, 0xfd, 0xba, 0xfe, 0x32, 0xb1, 0x71, 0x31, 0xab, 0xd7, 0x6a, 0x1c, 0x74,
	0x9a, 0x82, 0x99, 0xad, 0xfd, 0x98, 0x81, 0x82, 0x4a, 0x75, 0xf2, 0x79, 0x3c, 0x9f, 0xc8, 0x27,
	0x77, 0x72, 0x7d, 0x76, 0x4e, 0x8d, 0xda, 0xde, 0xf5, 0x1b, 0xe7, 0xcd, 0xb0, 0xfb, 0x6c, 0xa8,
	0x2d, 0x90, 0x17, 0xb1, 0x2e, 0x39, 0x0f, 0x91, 0xbb, 0x17, 0x8e, 0x81, 0x42, 0xe3, 0x3b, 0x17,
	0x4f, 0x52, 0x52, 0xef, 0x3e, 0xc0, 0xe4, 0x64, 0x92, 0x5b, 0xe7, 0xb7, 0x5a, 0xa1, 0xf1, 0xf6,
	0x05, 0xa7, 0x19, 0xd5, 0x6d, 0xc3, 0x97, 0xc5, 0x23, 0xd3, 0xc5, 0xc9, 0xe7, 0xab, 0x3c, 0xfe,
	0xf9, 0xe4, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x15, 0x97, 0x81, 0xfb, 0x60, 0x22, 0x00, 0x00,
}
