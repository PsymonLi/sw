// Code generated by protoc-gen-go. DO NOT EDIT.
// source: acl.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AclAction specifies all possible actions for ACL entries
type AclAction int32

const (
	AclAction_ACL_ACTION_NONE     AclAction = 0
	AclAction_ACL_ACTION_PERMIT   AclAction = 1
	AclAction_ACL_ACTION_LOG      AclAction = 2
	AclAction_ACL_ACTION_DENY     AclAction = 3
	AclAction_ACL_ACTION_REDIRECT AclAction = 4
)

var AclAction_name = map[int32]string{
	0: "ACL_ACTION_NONE",
	1: "ACL_ACTION_PERMIT",
	2: "ACL_ACTION_LOG",
	3: "ACL_ACTION_DENY",
	4: "ACL_ACTION_REDIRECT",
}
var AclAction_value = map[string]int32{
	"ACL_ACTION_NONE":     0,
	"ACL_ACTION_PERMIT":   1,
	"ACL_ACTION_LOG":      2,
	"ACL_ACTION_DENY":     3,
	"ACL_ACTION_REDIRECT": 4,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}
func (AclAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// EthSelector has match criteria for non-IP packets
type EthSelector struct {
	EthType     uint32 `protobuf:"varint,1,opt,name=eth_type,json=ethType" json:"eth_type,omitempty"`
	EthTypeMask uint32 `protobuf:"varint,2,opt,name=eth_type_mask,json=ethTypeMask" json:"eth_type_mask,omitempty"`
	SrcMac      uint64 `protobuf:"varint,3,opt,name=src_mac,json=srcMac" json:"src_mac,omitempty"`
	SrcMacMask  uint64 `protobuf:"varint,4,opt,name=src_mac_mask,json=srcMacMask" json:"src_mac_mask,omitempty"`
	DstMac      uint64 `protobuf:"varint,5,opt,name=dst_mac,json=dstMac" json:"dst_mac,omitempty"`
	DstMacMask  uint64 `protobuf:"varint,6,opt,name=dst_mac_mask,json=dstMacMask" json:"dst_mac_mask,omitempty"`
}

func (m *EthSelector) Reset()                    { *m = EthSelector{} }
func (m *EthSelector) String() string            { return proto.CompactTextString(m) }
func (*EthSelector) ProtoMessage()               {}
func (*EthSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *EthSelector) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *EthSelector) GetEthTypeMask() uint32 {
	if m != nil {
		return m.EthTypeMask
	}
	return 0
}

func (m *EthSelector) GetSrcMac() uint64 {
	if m != nil {
		return m.SrcMac
	}
	return 0
}

func (m *EthSelector) GetSrcMacMask() uint64 {
	if m != nil {
		return m.SrcMacMask
	}
	return 0
}

func (m *EthSelector) GetDstMac() uint64 {
	if m != nil {
		return m.DstMac
	}
	return 0
}

func (m *EthSelector) GetDstMacMask() uint64 {
	if m != nil {
		return m.DstMacMask
	}
	return 0
}

// UDPSelector is used to specify match criteria for UDP traffic
type UDPSelector struct {
	SrcPortRange *L4PortRange `protobuf:"bytes,1,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange `protobuf:"bytes,2,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *UDPSelector) Reset()                    { *m = UDPSelector{} }
func (m *UDPSelector) String() string            { return proto.CompactTextString(m) }
func (*UDPSelector) ProtoMessage()               {}
func (*UDPSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *UDPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *UDPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// TCPSelector is used to specify match criteria for TCP traffic
type TCPSelector struct {
	// Types that are valid to be assigned to TcpSyn:
	//	*TCPSelector_TcpSynSet
	//	*TCPSelector_TcpSynClear
	TcpSyn isTCPSelector_TcpSyn `protobuf_oneof:"tcp_syn"`
	// Types that are valid to be assigned to TcpAck:
	//	*TCPSelector_TcpAckSet
	//	*TCPSelector_TcpAckClear
	TcpAck isTCPSelector_TcpAck `protobuf_oneof:"tcp_ack"`
	// Types that are valid to be assigned to TcpFin:
	//	*TCPSelector_TcpFinSet
	//	*TCPSelector_TcpFinClear
	TcpFin isTCPSelector_TcpFin `protobuf_oneof:"tcp_fin"`
	// Types that are valid to be assigned to TcpRst:
	//	*TCPSelector_TcpRstSet
	//	*TCPSelector_TcpRstClear
	TcpRst isTCPSelector_TcpRst `protobuf_oneof:"tcp_rst"`
	// Types that are valid to be assigned to TcpUrg:
	//	*TCPSelector_TcpUrgSet
	//	*TCPSelector_TcpUrgClear
	TcpUrg       isTCPSelector_TcpUrg `protobuf_oneof:"tcp_urg"`
	SrcPortRange *L4PortRange         `protobuf:"bytes,11,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange         `protobuf:"bytes,12,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *TCPSelector) Reset()                    { *m = TCPSelector{} }
func (m *TCPSelector) String() string            { return proto.CompactTextString(m) }
func (*TCPSelector) ProtoMessage()               {}
func (*TCPSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type isTCPSelector_TcpSyn interface{ isTCPSelector_TcpSyn() }
type isTCPSelector_TcpAck interface{ isTCPSelector_TcpAck() }
type isTCPSelector_TcpFin interface{ isTCPSelector_TcpFin() }
type isTCPSelector_TcpRst interface{ isTCPSelector_TcpRst() }
type isTCPSelector_TcpUrg interface{ isTCPSelector_TcpUrg() }

type TCPSelector_TcpSynSet struct {
	TcpSynSet bool `protobuf:"varint,1,opt,name=tcp_syn_set,json=tcpSynSet,oneof"`
}
type TCPSelector_TcpSynClear struct {
	TcpSynClear bool `protobuf:"varint,2,opt,name=tcp_syn_clear,json=tcpSynClear,oneof"`
}
type TCPSelector_TcpAckSet struct {
	TcpAckSet bool `protobuf:"varint,3,opt,name=tcp_ack_set,json=tcpAckSet,oneof"`
}
type TCPSelector_TcpAckClear struct {
	TcpAckClear bool `protobuf:"varint,4,opt,name=tcp_ack_clear,json=tcpAckClear,oneof"`
}
type TCPSelector_TcpFinSet struct {
	TcpFinSet bool `protobuf:"varint,5,opt,name=tcp_fin_set,json=tcpFinSet,oneof"`
}
type TCPSelector_TcpFinClear struct {
	TcpFinClear bool `protobuf:"varint,6,opt,name=tcp_fin_clear,json=tcpFinClear,oneof"`
}
type TCPSelector_TcpRstSet struct {
	TcpRstSet bool `protobuf:"varint,7,opt,name=tcp_rst_set,json=tcpRstSet,oneof"`
}
type TCPSelector_TcpRstClear struct {
	TcpRstClear bool `protobuf:"varint,8,opt,name=tcp_rst_clear,json=tcpRstClear,oneof"`
}
type TCPSelector_TcpUrgSet struct {
	TcpUrgSet bool `protobuf:"varint,9,opt,name=tcp_urg_set,json=tcpUrgSet,oneof"`
}
type TCPSelector_TcpUrgClear struct {
	TcpUrgClear bool `protobuf:"varint,10,opt,name=tcp_urg_clear,json=tcpUrgClear,oneof"`
}

func (*TCPSelector_TcpSynSet) isTCPSelector_TcpSyn()   {}
func (*TCPSelector_TcpSynClear) isTCPSelector_TcpSyn() {}
func (*TCPSelector_TcpAckSet) isTCPSelector_TcpAck()   {}
func (*TCPSelector_TcpAckClear) isTCPSelector_TcpAck() {}
func (*TCPSelector_TcpFinSet) isTCPSelector_TcpFin()   {}
func (*TCPSelector_TcpFinClear) isTCPSelector_TcpFin() {}
func (*TCPSelector_TcpRstSet) isTCPSelector_TcpRst()   {}
func (*TCPSelector_TcpRstClear) isTCPSelector_TcpRst() {}
func (*TCPSelector_TcpUrgSet) isTCPSelector_TcpUrg()   {}
func (*TCPSelector_TcpUrgClear) isTCPSelector_TcpUrg() {}

func (m *TCPSelector) GetTcpSyn() isTCPSelector_TcpSyn {
	if m != nil {
		return m.TcpSyn
	}
	return nil
}
func (m *TCPSelector) GetTcpAck() isTCPSelector_TcpAck {
	if m != nil {
		return m.TcpAck
	}
	return nil
}
func (m *TCPSelector) GetTcpFin() isTCPSelector_TcpFin {
	if m != nil {
		return m.TcpFin
	}
	return nil
}
func (m *TCPSelector) GetTcpRst() isTCPSelector_TcpRst {
	if m != nil {
		return m.TcpRst
	}
	return nil
}
func (m *TCPSelector) GetTcpUrg() isTCPSelector_TcpUrg {
	if m != nil {
		return m.TcpUrg
	}
	return nil
}

func (m *TCPSelector) GetTcpSynSet() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynSet); ok {
		return x.TcpSynSet
	}
	return false
}

func (m *TCPSelector) GetTcpSynClear() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynClear); ok {
		return x.TcpSynClear
	}
	return false
}

func (m *TCPSelector) GetTcpAckSet() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckSet); ok {
		return x.TcpAckSet
	}
	return false
}

func (m *TCPSelector) GetTcpAckClear() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckClear); ok {
		return x.TcpAckClear
	}
	return false
}

func (m *TCPSelector) GetTcpFinSet() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinSet); ok {
		return x.TcpFinSet
	}
	return false
}

func (m *TCPSelector) GetTcpFinClear() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinClear); ok {
		return x.TcpFinClear
	}
	return false
}

func (m *TCPSelector) GetTcpRstSet() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstSet); ok {
		return x.TcpRstSet
	}
	return false
}

func (m *TCPSelector) GetTcpRstClear() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstClear); ok {
		return x.TcpRstClear
	}
	return false
}

func (m *TCPSelector) GetTcpUrgSet() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgSet); ok {
		return x.TcpUrgSet
	}
	return false
}

func (m *TCPSelector) GetTcpUrgClear() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgClear); ok {
		return x.TcpUrgClear
	}
	return false
}

func (m *TCPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *TCPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TCPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TCPSelector_OneofMarshaler, _TCPSelector_OneofUnmarshaler, _TCPSelector_OneofSizer, []interface{}{
		(*TCPSelector_TcpSynSet)(nil),
		(*TCPSelector_TcpSynClear)(nil),
		(*TCPSelector_TcpAckSet)(nil),
		(*TCPSelector_TcpAckClear)(nil),
		(*TCPSelector_TcpFinSet)(nil),
		(*TCPSelector_TcpFinClear)(nil),
		(*TCPSelector_TcpRstSet)(nil),
		(*TCPSelector_TcpRstClear)(nil),
		(*TCPSelector_TcpUrgSet)(nil),
		(*TCPSelector_TcpUrgClear)(nil),
	}
}

func _TCPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		t := uint64(0)
		if x.TcpSynSet {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpSynClear:
		t := uint64(0)
		if x.TcpSynClear {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpSyn has unexpected type %T", x)
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		t := uint64(0)
		if x.TcpAckSet {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpAckClear:
		t := uint64(0)
		if x.TcpAckClear {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpAck has unexpected type %T", x)
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		t := uint64(0)
		if x.TcpFinSet {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpFinClear:
		t := uint64(0)
		if x.TcpFinClear {
			t = 1
		}
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpFin has unexpected type %T", x)
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		t := uint64(0)
		if x.TcpRstSet {
			t = 1
		}
		b.EncodeVarint(7<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpRstClear:
		t := uint64(0)
		if x.TcpRstClear {
			t = 1
		}
		b.EncodeVarint(8<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpRst has unexpected type %T", x)
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		t := uint64(0)
		if x.TcpUrgSet {
			t = 1
		}
		b.EncodeVarint(9<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpUrgClear:
		t := uint64(0)
		if x.TcpUrgClear {
			t = 1
		}
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpUrg has unexpected type %T", x)
	}
	return nil
}

func _TCPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TCPSelector)
	switch tag {
	case 1: // tcp_syn.tcp_syn_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynSet{x != 0}
		return true, err
	case 2: // tcp_syn.tcp_syn_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynClear{x != 0}
		return true, err
	case 3: // tcp_ack.tcp_ack_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckSet{x != 0}
		return true, err
	case 4: // tcp_ack.tcp_ack_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckClear{x != 0}
		return true, err
	case 5: // tcp_fin.tcp_fin_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinSet{x != 0}
		return true, err
	case 6: // tcp_fin.tcp_fin_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinClear{x != 0}
		return true, err
	case 7: // tcp_rst.tcp_rst_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstSet{x != 0}
		return true, err
	case 8: // tcp_rst.tcp_rst_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstClear{x != 0}
		return true, err
	case 9: // tcp_urg.tcp_urg_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgSet{x != 0}
		return true, err
	case 10: // tcp_urg.tcp_urg_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgClear{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TCPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpSynClear:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpAckClear:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpFinClear:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpRstClear:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpUrgClear:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ICMPSelector has match criteria for ICMP packets
type ICMPSelector struct {
	IcmpCode     uint32 `protobuf:"varint,1,opt,name=icmp_code,json=icmpCode" json:"icmp_code,omitempty"`
	IcmpCodeMask uint32 `protobuf:"varint,2,opt,name=icmp_code_mask,json=icmpCodeMask" json:"icmp_code_mask,omitempty"`
	IcmpType     uint32 `protobuf:"varint,3,opt,name=icmp_type,json=icmpType" json:"icmp_type,omitempty"`
	IcmpTypeMask uint32 `protobuf:"varint,4,opt,name=icmp_type_mask,json=icmpTypeMask" json:"icmp_type_mask,omitempty"`
}

func (m *ICMPSelector) Reset()                    { *m = ICMPSelector{} }
func (m *ICMPSelector) String() string            { return proto.CompactTextString(m) }
func (*ICMPSelector) ProtoMessage()               {}
func (*ICMPSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *ICMPSelector) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *ICMPSelector) GetIcmpCodeMask() uint32 {
	if m != nil {
		return m.IcmpCodeMask
	}
	return 0
}

func (m *ICMPSelector) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *ICMPSelector) GetIcmpTypeMask() uint32 {
	if m != nil {
		return m.IcmpTypeMask
	}
	return 0
}

// IPSelector has match criteria for selecting IP packets
type IPSelector struct {
	IpAf      IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,enum=types.IPAddressFamily" json:"ip_af,omitempty"`
	SrcPrefix *IPPrefix       `protobuf:"bytes,2,opt,name=src_prefix,json=srcPrefix" json:"src_prefix,omitempty"`
	DstPrefix *IPPrefix       `protobuf:"bytes,3,opt,name=dst_prefix,json=dstPrefix" json:"dst_prefix,omitempty"`
	// Types that are valid to be assigned to L4Selectors:
	//	*IPSelector_IpProtocol
	//	*IPSelector_IcmpSelector
	//	*IPSelector_UdpSelector
	//	*IPSelector_TcpSelector
	L4Selectors isIPSelector_L4Selectors `protobuf_oneof:"l4_selectors"`
}

func (m *IPSelector) Reset()                    { *m = IPSelector{} }
func (m *IPSelector) String() string            { return proto.CompactTextString(m) }
func (*IPSelector) ProtoMessage()               {}
func (*IPSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

type isIPSelector_L4Selectors interface{ isIPSelector_L4Selectors() }

type IPSelector_IpProtocol struct {
	IpProtocol IPProtocol `protobuf:"varint,4,opt,name=ip_protocol,json=ipProtocol,enum=types.IPProtocol,oneof"`
}
type IPSelector_IcmpSelector struct {
	IcmpSelector *ICMPSelector `protobuf:"bytes,5,opt,name=icmp_selector,json=icmpSelector,oneof"`
}
type IPSelector_UdpSelector struct {
	UdpSelector *UDPSelector `protobuf:"bytes,6,opt,name=udp_selector,json=udpSelector,oneof"`
}
type IPSelector_TcpSelector struct {
	TcpSelector *TCPSelector `protobuf:"bytes,7,opt,name=tcp_selector,json=tcpSelector,oneof"`
}

func (*IPSelector_IpProtocol) isIPSelector_L4Selectors()   {}
func (*IPSelector_IcmpSelector) isIPSelector_L4Selectors() {}
func (*IPSelector_UdpSelector) isIPSelector_L4Selectors()  {}
func (*IPSelector_TcpSelector) isIPSelector_L4Selectors()  {}

func (m *IPSelector) GetL4Selectors() isIPSelector_L4Selectors {
	if m != nil {
		return m.L4Selectors
	}
	return nil
}

func (m *IPSelector) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPSelector) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *IPSelector) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *IPSelector) GetIpProtocol() IPProtocol {
	if x, ok := m.GetL4Selectors().(*IPSelector_IpProtocol); ok {
		return x.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *IPSelector) GetIcmpSelector() *ICMPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_IcmpSelector); ok {
		return x.IcmpSelector
	}
	return nil
}

func (m *IPSelector) GetUdpSelector() *UDPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_UdpSelector); ok {
		return x.UdpSelector
	}
	return nil
}

func (m *IPSelector) GetTcpSelector() *TCPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_TcpSelector); ok {
		return x.TcpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSelector_OneofMarshaler, _IPSelector_OneofUnmarshaler, _IPSelector_OneofSizer, []interface{}{
		(*IPSelector_IpProtocol)(nil),
		(*IPSelector_IcmpSelector)(nil),
		(*IPSelector_UdpSelector)(nil),
		(*IPSelector_TcpSelector)(nil),
	}
}

func _IPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpSelector); err != nil {
			return err
		}
	case *IPSelector_UdpSelector:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpSelector); err != nil {
			return err
		}
	case *IPSelector_TcpSelector:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSelector.L4Selectors has unexpected type %T", x)
	}
	return nil
}

func _IPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSelector)
	switch tag {
	case 4: // l4_selectors.ip_protocol
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Selectors = &IPSelector_IpProtocol{IPProtocol(x)}
		return true, err
	case 5: // l4_selectors.icmp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_IcmpSelector{msg}
		return true, err
	case 6: // l4_selectors.udp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UDPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_UdpSelector{msg}
		return true, err
	case 7: // l4_selectors.tcp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TCPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_TcpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		s := proto.Size(x.IcmpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_UdpSelector:
		s := proto.Size(x.UdpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_TcpSelector:
		s := proto.Size(x.TcpSelector)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclInternalSelector has match criteria which are for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalSelector struct {
	FlowMiss        bool         `protobuf:"varint,1,opt,name=flow_miss,json=flowMiss" json:"flow_miss,omitempty"`
	OuterDstMac     uint64       `protobuf:"varint,2,opt,name=outer_dst_mac,json=outerDstMac" json:"outer_dst_mac,omitempty"`
	IpOptions       bool         `protobuf:"varint,3,opt,name=ip_options,json=ipOptions" json:"ip_options,omitempty"`
	IpFrag          bool         `protobuf:"varint,4,opt,name=ip_frag,json=ipFrag" json:"ip_frag,omitempty"`
	DropReasons     *DropReasons `protobuf:"bytes,5,opt,name=drop_reasons,json=dropReasons" json:"drop_reasons,omitempty"`
	TunnelTerminate bool         `protobuf:"varint,6,opt,name=tunnel_terminate,json=tunnelTerminate" json:"tunnel_terminate,omitempty"`
	Direction       bool         `protobuf:"varint,7,opt,name=direction" json:"direction,omitempty"`
	FromCpu         bool         `protobuf:"varint,8,opt,name=from_cpu,json=fromCpu" json:"from_cpu,omitempty"`
	NoDrop          bool         `protobuf:"varint,9,opt,name=no_drop,json=noDrop" json:"no_drop,omitempty"`
	EpLearnEn       bool         `protobuf:"varint,10,opt,name=ep_learn_en,json=epLearnEn" json:"ep_learn_en,omitempty"`
}

func (m *AclInternalSelector) Reset()                    { *m = AclInternalSelector{} }
func (m *AclInternalSelector) String() string            { return proto.CompactTextString(m) }
func (*AclInternalSelector) ProtoMessage()               {}
func (*AclInternalSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *AclInternalSelector) GetFlowMiss() bool {
	if m != nil {
		return m.FlowMiss
	}
	return false
}

func (m *AclInternalSelector) GetOuterDstMac() uint64 {
	if m != nil {
		return m.OuterDstMac
	}
	return 0
}

func (m *AclInternalSelector) GetIpOptions() bool {
	if m != nil {
		return m.IpOptions
	}
	return false
}

func (m *AclInternalSelector) GetIpFrag() bool {
	if m != nil {
		return m.IpFrag
	}
	return false
}

func (m *AclInternalSelector) GetDropReasons() *DropReasons {
	if m != nil {
		return m.DropReasons
	}
	return nil
}

func (m *AclInternalSelector) GetTunnelTerminate() bool {
	if m != nil {
		return m.TunnelTerminate
	}
	return false
}

func (m *AclInternalSelector) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

func (m *AclInternalSelector) GetFromCpu() bool {
	if m != nil {
		return m.FromCpu
	}
	return false
}

func (m *AclInternalSelector) GetNoDrop() bool {
	if m != nil {
		return m.NoDrop
	}
	return false
}

func (m *AclInternalSelector) GetEpLearnEn() bool {
	if m != nil {
		return m.EpLearnEn
	}
	return false
}

// AclInternalActionInfo has action parameters for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalActionInfo struct {
	MacSaRewriteEn bool         `protobuf:"varint,1,opt,name=mac_sa_rewrite_en,json=macSaRewriteEn" json:"mac_sa_rewrite_en,omitempty"`
	MacSa          uint64       `protobuf:"varint,2,opt,name=mac_sa,json=macSa" json:"mac_sa,omitempty"`
	MacDaRewriteEn bool         `protobuf:"varint,3,opt,name=mac_da_rewrite_en,json=macDaRewriteEn" json:"mac_da_rewrite_en,omitempty"`
	MacDa          uint64       `protobuf:"varint,4,opt,name=mac_da,json=macDa" json:"mac_da,omitempty"`
	TtlDecEn       bool         `protobuf:"varint,5,opt,name=ttl_dec_en,json=ttlDecEn" json:"ttl_dec_en,omitempty"`
	EncapInfo      *EncapInfo   `protobuf:"bytes,6,opt,name=encap_info,json=encapInfo" json:"encap_info,omitempty"`
	Qid            CpucbId      `protobuf:"varint,7,opt,name=qid,enum=types.CpucbId" json:"qid,omitempty"`
	QidValid       bool         `protobuf:"varint,8,opt,name=qid_valid,json=qidValid" json:"qid_valid,omitempty"`
	DropReason     *DropReasons `protobuf:"bytes,9,opt,name=drop_reason,json=dropReason" json:"drop_reason,omitempty"`
}

func (m *AclInternalActionInfo) Reset()                    { *m = AclInternalActionInfo{} }
func (m *AclInternalActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclInternalActionInfo) ProtoMessage()               {}
func (*AclInternalActionInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *AclInternalActionInfo) GetMacSaRewriteEn() bool {
	if m != nil {
		return m.MacSaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacSa() uint64 {
	if m != nil {
		return m.MacSa
	}
	return 0
}

func (m *AclInternalActionInfo) GetMacDaRewriteEn() bool {
	if m != nil {
		return m.MacDaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacDa() uint64 {
	if m != nil {
		return m.MacDa
	}
	return 0
}

func (m *AclInternalActionInfo) GetTtlDecEn() bool {
	if m != nil {
		return m.TtlDecEn
	}
	return false
}

func (m *AclInternalActionInfo) GetEncapInfo() *EncapInfo {
	if m != nil {
		return m.EncapInfo
	}
	return nil
}

func (m *AclInternalActionInfo) GetQid() CpucbId {
	if m != nil {
		return m.Qid
	}
	return CpucbId_CPUCB_ID_FLOWMISS
}

func (m *AclInternalActionInfo) GetQidValid() bool {
	if m != nil {
		return m.QidValid
	}
	return false
}

func (m *AclInternalActionInfo) GetDropReason() *DropReasons {
	if m != nil {
		return m.DropReason
	}
	return nil
}

// AclSelector has all the match criteria for an ACL entry
type AclSelector struct {
	SrcIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=src_if_key_handle,json=srcIfKeyHandle" json:"src_if_key_handle,omitempty"`
	DstIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=dst_if_key_handle,json=dstIfKeyHandle" json:"dst_if_key_handle,omitempty"`
	// Types that are valid to be assigned to SegSelector:
	//	*AclSelector_VrfKeyHandle
	//	*AclSelector_L2SegmentKeyHandle
	SegSelector isAclSelector_SegSelector `protobuf_oneof:"seg_selector"`
	// Types that are valid to be assigned to PktSelector:
	//	*AclSelector_EthSelector
	//	*AclSelector_IpSelector
	PktSelector isAclSelector_PktSelector `protobuf_oneof:"pkt_selector"`
	// TODO: REMOVE
	InternalKey  *AclInternalSelector `protobuf:"bytes,7,opt,name=internal_key,json=internalKey" json:"internal_key,omitempty"`
	InternalMask *AclInternalSelector `protobuf:"bytes,8,opt,name=internal_mask,json=internalMask" json:"internal_mask,omitempty"`
}

func (m *AclSelector) Reset()                    { *m = AclSelector{} }
func (m *AclSelector) String() string            { return proto.CompactTextString(m) }
func (*AclSelector) ProtoMessage()               {}
func (*AclSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

type isAclSelector_SegSelector interface{ isAclSelector_SegSelector() }
type isAclSelector_PktSelector interface{ isAclSelector_PktSelector() }

type AclSelector_VrfKeyHandle struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle,oneof"`
}
type AclSelector_L2SegmentKeyHandle struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,4,opt,name=l2segment_key_handle,json=l2segmentKeyHandle,oneof"`
}
type AclSelector_EthSelector struct {
	EthSelector *EthSelector `protobuf:"bytes,5,opt,name=eth_selector,json=ethSelector,oneof"`
}
type AclSelector_IpSelector struct {
	IpSelector *IPSelector `protobuf:"bytes,6,opt,name=ip_selector,json=ipSelector,oneof"`
}

func (*AclSelector_VrfKeyHandle) isAclSelector_SegSelector()       {}
func (*AclSelector_L2SegmentKeyHandle) isAclSelector_SegSelector() {}
func (*AclSelector_EthSelector) isAclSelector_PktSelector()        {}
func (*AclSelector_IpSelector) isAclSelector_PktSelector()         {}

func (m *AclSelector) GetSegSelector() isAclSelector_SegSelector {
	if m != nil {
		return m.SegSelector
	}
	return nil
}
func (m *AclSelector) GetPktSelector() isAclSelector_PktSelector {
	if m != nil {
		return m.PktSelector
	}
	return nil
}

func (m *AclSelector) GetSrcIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.SrcIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetDstIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.DstIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetVrfKeyHandle() *VrfKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_VrfKeyHandle); ok {
		return x.VrfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_L2SegmentKeyHandle); ok {
		return x.L2SegmentKeyHandle
	}
	return nil
}

func (m *AclSelector) GetEthSelector() *EthSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_EthSelector); ok {
		return x.EthSelector
	}
	return nil
}

func (m *AclSelector) GetIpSelector() *IPSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_IpSelector); ok {
		return x.IpSelector
	}
	return nil
}

func (m *AclSelector) GetInternalKey() *AclInternalSelector {
	if m != nil {
		return m.InternalKey
	}
	return nil
}

func (m *AclSelector) GetInternalMask() *AclInternalSelector {
	if m != nil {
		return m.InternalMask
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclSelector_OneofMarshaler, _AclSelector_OneofUnmarshaler, _AclSelector_OneofSizer, []interface{}{
		(*AclSelector_VrfKeyHandle)(nil),
		(*AclSelector_L2SegmentKeyHandle)(nil),
		(*AclSelector_EthSelector)(nil),
		(*AclSelector_IpSelector)(nil),
	}
}

func _AclSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_VrfKeyHandle:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VrfKeyHandle); err != nil {
			return err
		}
	case *AclSelector_L2SegmentKeyHandle:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2SegmentKeyHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.SegSelector has unexpected type %T", x)
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthSelector); err != nil {
			return err
		}
	case *AclSelector_IpSelector:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.PktSelector has unexpected type %T", x)
	}
	return nil
}

func _AclSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclSelector)
	switch tag {
	case 3: // seg_selector.vrf_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VrfKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_VrfKeyHandle{msg}
		return true, err
	case 4: // seg_selector.l2segment_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_L2SegmentKeyHandle{msg}
		return true, err
	case 5: // pkt_selector.eth_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_EthSelector{msg}
		return true, err
	case 6: // pkt_selector.ip_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_IpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_VrfKeyHandle:
		s := proto.Size(x.VrfKeyHandle)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_L2SegmentKeyHandle:
		s := proto.Size(x.L2SegmentKeyHandle)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		s := proto.Size(x.EthSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_IpSelector:
		s := proto.Size(x.IpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AclActionInfo struct {
	Action              AclAction                 `protobuf:"varint,1,opt,name=action,enum=acl.AclAction" json:"action,omitempty"`
	IngMirrorSessions   []*MirrorSessionKeyHandle `protobuf:"bytes,2,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty"`
	EgrMirrorSessions   []*MirrorSessionKeyHandle `protobuf:"bytes,3,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty"`
	CoppKeyHandle       *CoppKeyHandle            `protobuf:"bytes,4,opt,name=copp_key_handle,json=coppKeyHandle" json:"copp_key_handle,omitempty"`
	RedirectIfKeyHandle *InterfaceKeyHandle       `protobuf:"bytes,5,opt,name=redirect_if_key_handle,json=redirectIfKeyHandle" json:"redirect_if_key_handle,omitempty"`
	EgressDrop          bool                      `protobuf:"varint,6,opt,name=egress_drop,json=egressDrop" json:"egress_drop,omitempty"`
	// TODO: REMOVE
	InternalActions *AclInternalActionInfo `protobuf:"bytes,7,opt,name=internal_actions,json=internalActions" json:"internal_actions,omitempty"`
}

func (m *AclActionInfo) Reset()                    { *m = AclActionInfo{} }
func (m *AclActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclActionInfo) ProtoMessage()               {}
func (*AclActionInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *AclActionInfo) GetAction() AclAction {
	if m != nil {
		return m.Action
	}
	return AclAction_ACL_ACTION_NONE
}

func (m *AclActionInfo) GetIngMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetEgrMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetCoppKeyHandle() *CoppKeyHandle {
	if m != nil {
		return m.CoppKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetRedirectIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.RedirectIfKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetEgressDrop() bool {
	if m != nil {
		return m.EgressDrop
	}
	return false
}

func (m *AclActionInfo) GetInternalActions() *AclInternalActionInfo {
	if m != nil {
		return m.InternalActions
	}
	return nil
}

// ACL entry configuration
type AclSpec struct {
	// key_or_handle is ACL's key or handle
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	Priority    uint32        `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	// TBD: is this per-vrf priority ? or global ?
	Match  *AclSelector   `protobuf:"bytes,3,opt,name=match" json:"match,omitempty"`
	Action *AclActionInfo `protobuf:"bytes,4,opt,name=action" json:"action,omitempty"`
}

func (m *AclSpec) Reset()                    { *m = AclSpec{} }
func (m *AclSpec) String() string            { return proto.CompactTextString(m) }
func (*AclSpec) ProtoMessage()               {}
func (*AclSpec) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *AclSpec) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AclSpec) GetMatch() *AclSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AclSpec) GetAction() *AclActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Batched requests to create/update acls
type AclRequestMsg struct {
	Request []*AclSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclRequestMsg) Reset()                    { *m = AclRequestMsg{} }
func (m *AclRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclRequestMsg) ProtoMessage()               {}
func (*AclRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *AclRequestMsg) GetRequest() []*AclSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Acl oper state for enterprise pipeline
type AclStatusEpd struct {
	HwTcamIdx uint32 `protobuf:"varint,1,opt,name=hw_tcam_idx,json=hwTcamIdx" json:"hw_tcam_idx,omitempty"`
}

func (m *AclStatusEpd) Reset()                    { *m = AclStatusEpd{} }
func (m *AclStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*AclStatusEpd) ProtoMessage()               {}
func (*AclStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *AclStatusEpd) GetHwTcamIdx() uint32 {
	if m != nil {
		return m.HwTcamIdx
	}
	return 0
}

// Acl oper state for cloud pipeline
type AclStatusCpd struct {
}

func (m *AclStatusCpd) Reset()                    { *m = AclStatusCpd{} }
func (m *AclStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*AclStatusCpd) ProtoMessage()               {}
func (*AclStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

// AclStatus represents the operational status of an ACL entry
type AclStatus struct {
	AclHandle uint64 `protobuf:"fixed64,1,opt,name=acl_handle,json=aclHandle" json:"acl_handle,omitempty"`
	// Types that are valid to be assigned to QosClassPdStatus:
	//	*AclStatus_EpdStatus
	//	*AclStatus_CpdStatus
	QosClassPdStatus isAclStatus_QosClassPdStatus `protobuf_oneof:"qos_class_pd_status"`
}

func (m *AclStatus) Reset()                    { *m = AclStatus{} }
func (m *AclStatus) String() string            { return proto.CompactTextString(m) }
func (*AclStatus) ProtoMessage()               {}
func (*AclStatus) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

type isAclStatus_QosClassPdStatus interface{ isAclStatus_QosClassPdStatus() }

type AclStatus_EpdStatus struct {
	EpdStatus *AclStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type AclStatus_CpdStatus struct {
	CpdStatus *AclStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*AclStatus_EpdStatus) isAclStatus_QosClassPdStatus() {}
func (*AclStatus_CpdStatus) isAclStatus_QosClassPdStatus() {}

func (m *AclStatus) GetQosClassPdStatus() isAclStatus_QosClassPdStatus {
	if m != nil {
		return m.QosClassPdStatus
	}
	return nil
}

func (m *AclStatus) GetAclHandle() uint64 {
	if m != nil {
		return m.AclHandle
	}
	return 0
}

func (m *AclStatus) GetEpdStatus() *AclStatusEpd {
	if x, ok := m.GetQosClassPdStatus().(*AclStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *AclStatus) GetCpdStatus() *AclStatusCpd {
	if x, ok := m.GetQosClassPdStatus().(*AclStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclStatus_OneofMarshaler, _AclStatus_OneofUnmarshaler, _AclStatus_OneofSizer, []interface{}{
		(*AclStatus_EpdStatus)(nil),
		(*AclStatus_CpdStatus)(nil),
	}
}

func _AclStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *AclStatus_EpdStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *AclStatus_CpdStatus:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclStatus.QosClassPdStatus has unexpected type %T", x)
	}
	return nil
}

func _AclStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclStatus)
	switch tag {
	case 2: // qos_class_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclStatusEpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &AclStatus_EpdStatus{msg}
		return true, err
	case 3: // qos_class_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclStatusCpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &AclStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *AclStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclResponse is response to one Acl
type AclResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *AclResponse) Reset()                    { *m = AclResponse{} }
func (m *AclResponse) String() string            { return proto.CompactTextString(m) }
func (*AclResponse) ProtoMessage()               {}
func (*AclResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *AclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update acls
type AclResponseMsg struct {
	Response []*AclResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclResponseMsg) Reset()                    { *m = AclResponseMsg{} }
func (m *AclResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclResponseMsg) ProtoMessage()               {}
func (*AclResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *AclResponseMsg) GetResponse() []*AclResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AclDeleteRequest struct {
	// key_or_handle is unique identifier of ACL being deleted
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclDeleteRequest) Reset()                    { *m = AclDeleteRequest{} }
func (m *AclDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequest) ProtoMessage()               {}
func (*AclDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *AclDeleteRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete acls
type AclDeleteRequestMsg struct {
	Request []*AclDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclDeleteRequestMsg) Reset()                    { *m = AclDeleteRequestMsg{} }
func (m *AclDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequestMsg) ProtoMessage()               {}
func (*AclDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

func (m *AclDeleteRequestMsg) GetRequest() []*AclDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclDeleteResponse is response to Acl delete request
type AclDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AclDeleteResponse) Reset()                    { *m = AclDeleteResponse{} }
func (m *AclDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponse) ProtoMessage()               {}
func (*AclDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

func (m *AclDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// AclDeleteResponseMsg is batched response to AclDeleteRequestMsg
type AclDeleteResponseMsg struct {
	Response []*AclDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclDeleteResponseMsg) Reset()                    { *m = AclDeleteResponseMsg{} }
func (m *AclDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponseMsg) ProtoMessage()               {}
func (*AclDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19} }

func (m *AclDeleteResponseMsg) GetResponse() []*AclDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// AclGetRequest is used to get information about a acl
type AclGetRequest struct {
	// key_or_handle is ACL's identifier for retrieval
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclGetRequest) Reset()                    { *m = AclGetRequest{} }
func (m *AclGetRequest) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequest) ProtoMessage()               {}
func (*AclGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{20} }

func (m *AclGetRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type AclGetRequestMsg struct {
	Request []*AclGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclGetRequestMsg) Reset()                    { *m = AclGetRequestMsg{} }
func (m *AclGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequestMsg) ProtoMessage()               {}
func (*AclGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{21} }

func (m *AclGetRequestMsg) GetRequest() []*AclGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStats captures all the statistics of a acl
type AclStats struct {
}

func (m *AclStats) Reset()                    { *m = AclStats{} }
func (m *AclStats) String() string            { return proto.CompactTextString(m) }
func (*AclStats) ProtoMessage()               {}
func (*AclStats) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{22} }

// AclGetResponse captures all the information about a acl
type AclGetResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *AclSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *AclStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *AclStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *AclGetResponse) Reset()                    { *m = AclGetResponse{} }
func (m *AclGetResponse) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponse) ProtoMessage()               {}
func (*AclGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{23} }

func (m *AclGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclGetResponse) GetSpec() *AclSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AclGetResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AclGetResponse) GetStats() *AclStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AclGetResponseMsg is response to AclGetRequestMsg
type AclGetResponseMsg struct {
	Response []*AclGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclGetResponseMsg) Reset()                    { *m = AclGetResponseMsg{} }
func (m *AclGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponseMsg) ProtoMessage()               {}
func (*AclGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{24} }

func (m *AclGetResponseMsg) GetResponse() []*AclGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EthSelector)(nil), "halproto.EthSelector")
	proto.RegisterType((*UDPSelector)(nil), "halproto.UDPSelector")
	proto.RegisterType((*TCPSelector)(nil), "halproto.TCPSelector")
	proto.RegisterType((*ICMPSelector)(nil), "halproto.ICMPSelector")
	proto.RegisterType((*IPSelector)(nil), "halproto.IPSelector")
	proto.RegisterType((*AclInternalSelector)(nil), "halproto.AclInternalSelector")
	proto.RegisterType((*AclInternalActionInfo)(nil), "halproto.AclInternalActionInfo")
	proto.RegisterType((*AclSelector)(nil), "halproto.AclSelector")
	proto.RegisterType((*AclActionInfo)(nil), "halproto.AclActionInfo")
	proto.RegisterType((*AclSpec)(nil), "halproto.AclSpec")
	proto.RegisterType((*AclRequestMsg)(nil), "halproto.AclRequestMsg")
	proto.RegisterType((*AclStatusEpd)(nil), "halproto.AclStatusEpd")
	proto.RegisterType((*AclStatusCpd)(nil), "halproto.AclStatusCpd")
	proto.RegisterType((*AclStatus)(nil), "halproto.AclStatus")
	proto.RegisterType((*AclResponse)(nil), "halproto.AclResponse")
	proto.RegisterType((*AclResponseMsg)(nil), "halproto.AclResponseMsg")
	proto.RegisterType((*AclDeleteRequest)(nil), "halproto.AclDeleteRequest")
	proto.RegisterType((*AclDeleteRequestMsg)(nil), "halproto.AclDeleteRequestMsg")
	proto.RegisterType((*AclDeleteResponse)(nil), "halproto.AclDeleteResponse")
	proto.RegisterType((*AclDeleteResponseMsg)(nil), "halproto.AclDeleteResponseMsg")
	proto.RegisterType((*AclGetRequest)(nil), "halproto.AclGetRequest")
	proto.RegisterType((*AclGetRequestMsg)(nil), "halproto.AclGetRequestMsg")
	proto.RegisterType((*AclStats)(nil), "halproto.AclStats")
	proto.RegisterType((*AclGetResponse)(nil), "halproto.AclGetResponse")
	proto.RegisterType((*AclGetResponseMsg)(nil), "halproto.AclGetResponseMsg")
	proto.RegisterEnum("halproto.AclAction", AclAction_name, AclAction_value)
}

func init() { proto.RegisterFile("acl.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 2136 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0x1b, 0xb7,
	0xf9, 0x36, 0xc5, 0x3f, 0x22, 0xdf, 0x95, 0x28, 0x09, 0x8a, 0x1d, 0xc5, 0xbf, 0xfc, 0x42, 0x65,
	0xdb, 0x7a, 0x9c, 0xc6, 0x91, 0x5d, 0xda, 0xb2, 0xe3, 0xa4, 0xee, 0x84, 0xa4, 0xa8, 0x88, 0xb6,
	0x65, 0x2b, 0x90, 0x9c, 0x36, 0xe9, 0x61, 0x67, 0x8d, 0x05, 0xc9, 0x1d, 0x2e, 0x77, 0x21, 0x00,
	0xb4, 0xcd, 0xe9, 0xe8, 0xd0, 0x53, 0xcf, 0x6d, 0xbf, 0x40, 0x4f, 0x9d, 0xe9, 0xad, 0x1f, 0xa1,
	0xb7, 0x7e, 0x83, 0x1c, 0x35, 0xfd, 0x0c, 0x9a, 0x7e, 0x80, 0x0e, 0x80, 0xdd, 0xe5, 0x92, 0x92,
	0x95, 0x48, 0x63, 0x5f, 0xbc, 0x00, 0x9e, 0xf7, 0xc1, 0x8b, 0xf7, 0xcf, 0x03, 0x50, 0x50, 0x71,
	0x49, 0xb0, 0xc1, 0x78, 0x24, 0x23, 0x94, 0x77, 0x49, 0x70, 0xdd, 0x92, 0x63, 0x46, 0x85, 0x99,
	0xb9, 0x5e, 0x1e, 0xf4, 0xcd, 0x97, 0xfd, 0x43, 0x1e, 0xac, 0xb6, 0xec, 0xef, 0xd3, 0x80, 0x12,
	0x19, 0x71, 0xd4, 0x80, 0x32, 0x95, 0x7d, 0x47, 0x81, 0xd7, 0x72, 0xeb, 0xb9, 0x9b, 0x8b, 0xcd,
	0x1b, 0x27, 0xc7, 0x35, 0xfb, 0x15, 0x0d, 0x7d, 0x42, 0xbf, 0x20, 0x51, 0x28, 0x24, 0x77, 0xfd,
	0x50, 0x8a, 0x47, 0x7f, 0xe0, 0x6e, 0xd8, 0xa3, 0x5f, 0xdc, 0xf9, 0xec, 0xfe, 0xe6, 0xe6, 0xdd,
	0xcd, 0x23, 0x3c, 0x4f, 0x65, 0xff, 0x60, 0xcc, 0x28, 0x7a, 0x0c, 0x8b, 0x09, 0x85, 0x33, 0x74,
	0xc5, 0x60, 0x6d, 0xee, 0x42, 0x3c, 0x56, 0xcc, 0xb3, 0xeb, 0x8a, 0x01, 0xda, 0x81, 0x79, 0xc1,
	0x89, 0x33, 0x74, 0xc9, 0x5a, 0x7e, 0x3d, 0x77, 0xb3, 0xd0, 0xbc, 0x7d, 0x72, 0x5c, 0xfb, 0xf4,
	0x3c, 0x96, 0x3b, 0x6f, 0xba, 0x99, 0x7f, 0x47, 0xb8, 0x24, 0x38, 0xd9, 0x75, 0x09, 0xfa, 0x06,
	0x16, 0x62, 0x26, 0xe3, 0x54, 0xe1, 0x72, 0x74, 0x60, 0xe8, 0x12, 0xe7, 0x3c, 0x21, 0xb5, 0x73,
	0xc5, 0x4b, 0x3a, 0xe7, 0x09, 0x19, 0x3b, 0x17, 0x33, 0x19, 0xe7, 0x4a, 0x97, 0x74, 0xce, 0xd0,
	0x29, 0xe7, 0xec, 0x3f, 0xe6, 0xc0, 0x7a, 0xb1, 0xb5, 0x97, 0x26, 0xf6, 0x73, 0xa8, 0xaa, 0xf3,
	0xb3, 0x88, 0x4b, 0x47, 0xdb, 0xeb, 0xf4, 0x5a, 0x75, 0xb4, 0x61, 0x0a, 0xe3, 0xe9, 0xbd, 0xbd,
	0x88, 0x4b, 0xac, 0x56, 0xb0, 0x8a, 0x54, 0x3a, 0x52, 0x96, 0xca, 0xb9, 0x8c, 0xe5, 0xdc, 0xdb,
	0x2d, 0x3d, 0x21, 0xd3, 0x91, 0xfd, 0xb7, 0x02, 0x58, 0x07, 0xad, 0x89, 0x0f, 0xeb, 0x60, 0x49,
	0xc2, 0x1c, 0x31, 0x0e, 0x1d, 0x41, 0xa5, 0x76, 0xa0, 0xbc, 0x73, 0x05, 0x57, 0x24, 0x61, 0xfb,
	0xe3, 0x70, 0x9f, 0x4a, 0xf4, 0x73, 0x58, 0x4c, 0x10, 0x24, 0xa0, 0x2e, 0xd7, 0x5b, 0x29, 0x8c,
	0x65, 0x30, 0x2d, 0x35, 0x99, 0xf0, 0xb8, 0x64, 0xa0, 0x79, 0xf2, 0x1a, 0x93, 0xd3, 0x3c, 0x0d,
	0x32, 0xc8, 0xf0, 0x28, 0x84, 0xe1, 0x29, 0xc4, 0x18, 0xcb, 0x60, 0xa6, 0x78, 0xba, 0xbe, 0xf1,
	0xa7, 0xa8, 0x31, 0x73, 0x9a, 0x67, 0xdb, 0xcf, 0xfa, 0xa3, 0x10, 0x86, 0xa7, 0x14, 0x63, 0x2c,
	0x83, 0x99, 0xe2, 0xe1, 0x42, 0x6a, 0x9e, 0x79, 0x8d, 0xc9, 0x6b, 0x1e, 0x2c, 0x64, 0x86, 0x47,
	0x21, 0x0c, 0x4f, 0x39, 0xc6, 0x58, 0x06, 0x33, 0xc5, 0x33, 0xe2, 0x3d, 0xcd, 0x53, 0xd1, 0x98,
	0x82, 0xe6, 0x79, 0xc1, 0x7b, 0x19, 0x1e, 0x85, 0x30, 0x3c, 0x10, 0x63, 0x2c, 0x83, 0x31, 0x3c,
	0xa7, 0x73, 0x6d, 0x5d, 0x3a, 0xd7, 0x0b, 0x3f, 0x2d, 0xd7, 0xcd, 0x0a, 0xcc, 0xc7, 0x99, 0x4b,
	0x3e, 0x5d, 0x32, 0x48, 0x3e, 0xbb, 0x7e, 0x3a, 0xcb, 0x85, 0x4c, 0x3e, 0x47, 0xbc, 0x67, 0xff,
	0x73, 0x0e, 0x16, 0x3a, 0xad, 0xdd, 0x49, 0x8d, 0x34, 0xa1, 0xe2, 0x93, 0x21, 0x73, 0x48, 0xe4,
	0x25, 0x0a, 0xf4, 0x8b, 0x93, 0xe3, 0xda, 0xc7, 0x3f, 0xd6, 0x07, 0x47, 0xb8, 0xac, 0xec, 0x5a,
	0x91, 0x47, 0xd1, 0x13, 0xa8, 0xa6, 0x1c, 0x59, 0x09, 0xfa, 0x89, 0x44, 0x0b, 0x09, 0x91, 0xee,
	0xf2, 0xc4, 0x21, 0x2d, 0x89, 0xf9, 0x0b, 0x3b, 0xa4, 0x25, 0x31, 0x71, 0x68, 0xa2, 0x89, 0x85,
	0x0b, 0x3b, 0x94, 0x68, 0xa2, 0xfd, 0xa7, 0x3c, 0x40, 0x67, 0x12, 0xb0, 0x4f, 0xa1, 0xe8, 0x33,
	0xc7, 0xed, 0xea, 0x60, 0x55, 0xeb, 0xd7, 0xe2, 0x4c, 0x75, 0xf6, 0x1a, 0x9e, 0xc7, 0xa9, 0x10,
	0xdb, 0xee, 0xd0, 0x0f, 0xc6, 0xb8, 0xe0, 0xb3, 0x46, 0x17, 0x6d, 0x00, 0xe8, 0xca, 0xe0, 0xb4,
	0xeb, 0xbf, 0x89, 0xfb, 0x78, 0x29, 0xb5, 0xd8, 0xd3, 0xd3, 0xb8, 0xa2, 0x4a, 0x42, 0x7f, 0x2a,
	0xbc, 0xae, 0x07, 0x83, 0xcf, 0xbf, 0x05, 0xaf, 0x0a, 0xc1, 0xe0, 0xef, 0x81, 0xe5, 0x33, 0x47,
	0x5f, 0x2d, 0x24, 0x0a, 0xf4, 0x29, 0xab, 0xf5, 0x95, 0x8c, 0x81, 0x59, 0xd8, 0xb9, 0x82, 0xc1,
	0x67, 0xc9, 0x08, 0x7d, 0x0e, 0x8b, 0x3a, 0x3c, 0x22, 0x3e, 0x93, 0xee, 0x44, 0xab, 0xbe, 0xb2,
	0xa1, 0xee, 0xb0, 0x6c, 0x75, 0xec, 0x5c, 0x31, 0xb1, 0x48, 0x0f, 0xbf, 0x09, 0x0b, 0x23, 0x2f,
	0x63, 0x58, 0xd2, 0x86, 0xcb, 0xda, 0x30, 0xa3, 0x7e, 0x4a, 0x40, 0x46, 0xde, 0x94, 0x99, 0x2e,
	0xd6, 0xc4, 0x6c, 0x3e, 0x63, 0x96, 0x11, 0xac, 0x44, 0x77, 0xe2, 0x61, 0xb3, 0x0a, 0x0b, 0xc1,
	0xbd, 0xd4, 0x4a, 0xd8, 0x7f, 0xcd, 0xc3, 0x6a, 0x83, 0x04, 0x9d, 0x50, 0x52, 0x1e, 0xba, 0x41,
	0x4a, 0xff, 0x7f, 0x50, 0xe9, 0x06, 0xd1, 0x6b, 0x67, 0xe8, 0x0b, 0x61, 0x54, 0x0e, 0x97, 0xd5,
	0xc4, 0xae, 0x2f, 0x04, 0xda, 0x87, 0xc5, 0x68, 0x24, 0x29, 0x77, 0x92, 0xbb, 0x63, 0xee, 0x72,
	0x62, 0x6f, 0x69, 0x96, 0x2d, 0x73, 0x81, 0xfc, 0x3f, 0x80, 0xcf, 0x9c, 0x88, 0x49, 0x3f, 0x0a,
	0x85, 0x11, 0x44, 0x5c, 0xf1, 0xd9, 0x73, 0x33, 0x81, 0xde, 0x87, 0x79, 0x9f, 0x39, 0x5d, 0xee,
	0xf6, 0x8c, 0x10, 0xe2, 0x92, 0xcf, 0xb6, 0xb9, 0xdb, 0x53, 0x81, 0xf0, 0x78, 0xc4, 0x1c, 0x4e,
	0x5d, 0xa1, 0x2c, 0x8b, 0x53, 0xdd, 0xbe, 0xc5, 0x23, 0x86, 0xcd, 0x0a, 0xb6, 0xbc, 0xc9, 0x00,
	0x7d, 0x02, 0xcb, 0x72, 0x14, 0x86, 0x34, 0x70, 0x24, 0xe5, 0x43, 0x3f, 0x74, 0x25, 0x35, 0xca,
	0x88, 0x97, 0xcc, 0xfc, 0x41, 0x32, 0x8d, 0x3e, 0x84, 0x8a, 0xe7, 0x73, 0x4a, 0x94, 0x23, 0x46,
	0x19, 0xf1, 0x64, 0x02, 0x7d, 0x00, 0xe5, 0x2e, 0x8f, 0x86, 0x0e, 0x61, 0x23, 0x23, 0x89, 0x78,
	0x5e, 0x8d, 0x5b, 0x6c, 0xa4, 0x7c, 0x0e, 0x23, 0x47, 0xed, 0x6a, 0x84, 0x10, 0x97, 0xc2, 0x48,
	0x39, 0x84, 0x3e, 0x02, 0x8b, 0x32, 0x47, 0x09, 0x5d, 0xe8, 0xd0, 0xd0, 0x28, 0x20, 0xae, 0x50,
	0xf6, 0x54, 0xcd, 0xb4, 0x43, 0xfb, 0x5f, 0x79, 0xb8, 0x9a, 0xc9, 0x4a, 0x43, 0xef, 0xd4, 0x09,
	0xbb, 0x11, 0xfa, 0x04, 0x56, 0xd4, 0x15, 0x2b, 0x5c, 0x87, 0xd3, 0xd7, 0xdc, 0x97, 0x54, 0xd9,
	0x9b, 0xfc, 0x54, 0x87, 0x2e, 0xd9, 0x77, 0xb1, 0x99, 0x6e, 0x87, 0x68, 0x1b, 0x4a, 0x06, 0x7a,
	0xd9, 0xf4, 0x14, 0x35, 0x61, 0xb2, 0xa5, 0x37, 0xb5, 0x65, 0x3e, 0xdd, 0x72, 0xeb, 0xf4, 0x96,
	0x9e, 0x7b, 0xd9, 0xb7, 0x49, 0x51, 0x13, 0xa2, 0x0f, 0x01, 0xa4, 0x0c, 0x1c, 0x8f, 0x12, 0xb5,
	0x57, 0xd1, 0x94, 0x9f, 0x94, 0xc1, 0x16, 0x25, 0xed, 0x10, 0xdd, 0x06, 0xa0, 0x21, 0x71, 0x99,
	0xe3, 0x87, 0xdd, 0x28, 0xed, 0x17, 0x93, 0xef, 0xb6, 0x5a, 0x50, 0x91, 0xc2, 0x15, 0x9a, 0x7c,
	0xa2, 0x75, 0xc8, 0x1f, 0xfa, 0x9e, 0x4e, 0x5d, 0xb5, 0x5e, 0x8d, 0x91, 0x2d, 0x36, 0x22, 0x2f,
	0x3b, 0x1e, 0x56, 0x4b, 0xaa, 0xdc, 0x0f, 0x7d, 0xcf, 0x79, 0xe5, 0x06, 0xbe, 0x17, 0x67, 0xb1,
	0x7c, 0xe8, 0x7b, 0xdf, 0xaa, 0x31, 0xba, 0x0b, 0x56, 0xa6, 0xc2, 0x74, 0x2a, 0xcf, 0x2e, 0x30,
	0x98, 0x14, 0x98, 0xfd, 0x9f, 0x02, 0x58, 0x0d, 0x32, 0x69, 0xa8, 0x6f, 0x60, 0x45, 0xc9, 0x96,
	0xdf, 0x75, 0x06, 0x74, 0xec, 0xf4, 0xdd, 0xd0, 0x0b, 0x92, 0xf7, 0xcb, 0xb5, 0x8d, 0x41, 0x7f,
	0x43, 0xe7, 0xba, 0xeb, 0x12, 0xfa, 0x84, 0x8e, 0x77, 0xf4, 0x6a, 0xb3, 0x7a, 0x72, 0x5c, 0x83,
	0x38, 0x7a, 0x9c, 0x76, 0xb1, 0xba, 0x11, 0x3b, 0xdd, 0x74, 0x5d, 0x51, 0xaa, 0x06, 0x9c, 0xa6,
	0x9c, 0xbb, 0x18, 0xa5, 0x27, 0x64, 0x96, 0x72, 0x07, 0xaa, 0xaf, 0xf8, 0x14, 0x5f, 0x3e, 0x0e,
	0xef, 0xa0, 0xbf, 0xf1, 0x2d, 0xef, 0xbe, 0x95, 0x49, 0xc9, 0xda, 0xab, 0xcc, 0x3a, 0xfa, 0x1e,
	0xde, 0x0b, 0xea, 0x82, 0xf6, 0x86, 0x34, 0x94, 0x59, 0xbe, 0xc2, 0xc4, 0xbf, 0xa7, 0xf5, 0x7d,
	0xb3, 0x7e, 0x1e, 0x2b, 0x4a, 0x59, 0x26, 0xdc, 0x9b, 0xb0, 0xa0, 0x9e, 0xe7, 0x33, 0x5a, 0x6b,
	0xb4, 0x2f, 0xf3, 0x4b, 0x40, 0xbd, 0x95, 0x68, 0xe6, 0x87, 0x41, 0x5d, 0x2b, 0xfb, 0x8c, 0xd0,
	0x2e, 0x19, 0x85, 0xde, 0xcb, 0x18, 0x81, 0x3f, 0x91, 0xd9, 0x2f, 0x61, 0xc1, 0x8f, 0xbb, 0x50,
	0x9d, 0x22, 0x96, 0xd9, 0x35, 0x6d, 0x74, 0x86, 0x6e, 0x62, 0x2b, 0x41, 0x3f, 0xa1, 0x63, 0xf4,
	0x08, 0x16, 0x53, 0x63, 0x7d, 0x65, 0x96, 0x7f, 0xc4, 0x3a, 0xdd, 0x4b, 0xdd, 0x92, 0x4a, 0xab,
	0x05, 0xed, 0xa5, 0x0e, 0xab, 0x31, 0x1b, 0xc8, 0x74, 0x6c, 0xff, 0x50, 0x84, 0xc5, 0x06, 0xc9,
	0xaa, 0xc3, 0xaf, 0xa1, 0xe4, 0x1a, 0x99, 0xca, 0xc5, 0xb5, 0x1e, 0xef, 0x64, 0x30, 0xcd, 0xf7,
	0x4e, 0x8e, 0x6b, 0xcb, 0x71, 0x78, 0x87, 0x6e, 0xe8, 0xb9, 0x32, 0xe2, 0x63, 0x1c, 0xdb, 0xa0,
	0x10, 0x56, 0xfd, 0xb0, 0xe7, 0x0c, 0x7d, 0xce, 0x23, 0xee, 0x08, 0x2a, 0x84, 0x96, 0xe2, 0xb9,
	0xf5, 0xfc, 0x4d, 0xab, 0x7e, 0x5d, 0x65, 0x6c, 0x57, 0x2f, 0xed, 0x9b, 0x95, 0x49, 0xd6, 0xec,
	0x93, 0xe3, 0xda, 0x47, 0xe7, 0xb5, 0xf9, 0x83, 0x23, 0xbc, 0xe2, 0x87, 0xbd, 0x29, 0x73, 0xa1,
	0xf6, 0xa3, 0x3d, 0x7e, 0x6a, 0xbf, 0xfc, 0xbb, 0xd9, 0x8f, 0xf6, 0xf8, 0xcc, 0x7e, 0x1d, 0x58,
	0x22, 0x11, 0x63, 0xa7, 0xab, 0x71, 0x45, 0xed, 0xd5, 0x8a, 0x18, 0x7b, 0x7b, 0xa3, 0x2c, 0x92,
	0xec, 0x32, 0xfa, 0x7b, 0x0e, 0xae, 0x71, 0x6a, 0x2e, 0x81, 0x99, 0x06, 0x2c, 0x9e, 0xdb, 0x80,
	0xdf, 0x9d, 0x1c, 0xd7, 0x5e, 0x4c, 0x78, 0x6f, 0x9d, 0x75, 0x8a, 0xa9, 0x9c, 0xa9, 0xbc, 0x6e,
	0x98, 0x04, 0x3d, 0x7a, 0xe4, 0x92, 0xc0, 0x61, 0x2f, 0xeb, 0x1b, 0x8d, 0xd6, 0x53, 0xa7, 0xd1,
	0x3a, 0xe8, 0x3c, 0x7f, 0xe6, 0xe0, 0xf6, 0x56, 0x07, 0xb7, 0x5b, 0x07, 0x47, 0x78, 0x35, 0x71,
	0x28, 0xdb, 0xd0, 0x35, 0xb0, 0x68, 0x4f, 0xbd, 0xa1, 0xcc, 0x35, 0x64, 0x6e, 0x38, 0x30, 0x53,
	0xfa, 0x2a, 0xfa, 0x73, 0x0e, 0x96, 0xd3, 0x22, 0x35, 0xfb, 0x88, 0xb8, 0xca, 0xaf, 0xcf, 0xd6,
	0xe9, 0xc4, 0xa3, 0xe6, 0xe3, 0x93, 0xe3, 0xda, 0xf6, 0x45, 0x9c, 0xff, 0xf8, 0x2c, 0xe7, 0xb7,
	0xda, 0xcf, 0xbe, 0x3b, 0xc2, 0x4b, 0xfe, 0x14, 0xbf, 0xb0, 0xff, 0x32, 0x07, 0xf3, 0x4a, 0x3b,
	0x19, 0x25, 0x68, 0x0b, 0x16, 0x55, 0x70, 0x23, 0x3e, 0xad, 0x99, 0x5a, 0x90, 0x1a, 0x24, 0x38,
	0x3b, 0x63, 0x03, 0x3a, 0xc6, 0xd6, 0x80, 0x8e, 0x9f, 0xf3, 0x38, 0x0c, 0xbf, 0x85, 0x32, 0xe3,
	0x7e, 0xc4, 0x7d, 0x39, 0x8e, 0x1f, 0xd2, 0x5f, 0x9e, 0x1c, 0xd7, 0x1e, 0xc4, 0xf0, 0x51, 0xe8,
	0x1f, 0x8e, 0xe8, 0xad, 0xb7, 0x57, 0xd4, 0xaf, 0xee, 0xdc, 0xf9, 0xec, 0x5e, 0xfd, 0xe1, 0xbd,
	0x87, 0xf7, 0x1f, 0xd4, 0x1f, 0x6e, 0x1e, 0xe1, 0x94, 0x0c, 0xdd, 0x80, 0xe2, 0xd0, 0x95, 0xa4,
	0x9f, 0xea, 0x64, 0x7c, 0xfe, 0xb4, 0xa5, 0xcd, 0x32, 0xfa, 0x2a, 0xed, 0xcc, 0x42, 0x7c, 0x7d,
	0x9c, 0x0a, 0xd4, 0xf9, 0xdd, 0x69, 0x3f, 0xd0, 0xcd, 0x8e, 0xe9, 0xe1, 0x88, 0x0a, 0xb9, 0x2b,
	0x7a, 0xe8, 0x06, 0xcc, 0x73, 0x33, 0x5a, 0xcb, 0xe9, 0x96, 0x59, 0x48, 0x37, 0x67, 0x94, 0xe0,
	0x64, 0xd1, 0xde, 0x80, 0x05, 0x35, 0x27, 0x5d, 0x39, 0x12, 0x6d, 0xe6, 0xa9, 0xc7, 0x47, 0xff,
	0xb5, 0x23, 0x89, 0x3b, 0x74, 0x7c, 0xef, 0x8d, 0xf9, 0x81, 0x82, 0x2b, 0xfd, 0xd7, 0x07, 0xc4,
	0x1d, 0x76, 0xbc, 0x37, 0x76, 0x35, 0x83, 0x6f, 0x31, 0xcf, 0xfe, 0x47, 0x0e, 0x2a, 0xe9, 0x84,
	0x7a, 0xa6, 0xa9, 0x44, 0x66, 0x92, 0x51, 0xc2, 0x15, 0x97, 0x04, 0x71, 0xa0, 0xeb, 0x00, 0x94,
	0x79, 0x8e, 0xd0, 0xe0, 0xf8, 0x32, 0x5a, 0x49, 0xfd, 0x4a, 0x7c, 0x50, 0xbf, 0x98, 0x29, 0xf3,
	0x62, 0xca, 0x3a, 0x00, 0x99, 0xd8, 0xe4, 0xcf, 0xb2, 0x69, 0x19, 0x1b, 0x92, 0xd8, 0x34, 0xaf,
	0xc2, 0xea, 0x61, 0x24, 0x1c, 0x12, 0xb8, 0x42, 0x38, 0xa9, 0xb1, 0x7d, 0xa4, 0x2f, 0x5d, 0x4c,
	0x05, 0x8b, 0x42, 0x41, 0xd1, 0x36, 0x80, 0xcb, 0xfc, 0x84, 0xd9, 0x68, 0x62, 0xf2, 0x52, 0x68,
	0x30, 0x3f, 0xe1, 0x3a, 0x39, 0xae, 0xad, 0xc4, 0x71, 0x9f, 0xc0, 0x71, 0xc5, 0x4d, 0x10, 0xe8,
	0x06, 0x94, 0xa6, 0x4e, 0x54, 0x9d, 0xf6, 0x0e, 0xc7, 0xab, 0xf6, 0x6f, 0xa0, 0x9a, 0xd9, 0x5e,
	0x25, 0xe9, 0x16, 0x94, 0x79, 0x3c, 0x8c, 0xb3, 0x94, 0x96, 0x48, 0x02, 0xc3, 0x29, 0xc2, 0xfe,
	0x1d, 0x2c, 0x37, 0x48, 0xb0, 0x45, 0x03, 0x2a, 0x69, 0x9c, 0xe9, 0x77, 0xd3, 0x00, 0xf6, 0xb6,
	0x7e, 0xe6, 0x4f, 0x31, 0x2b, 0xf7, 0x6e, 0xcf, 0xd6, 0xd0, 0xd5, 0xc4, 0xbb, 0x29, 0xe8, 0xa4,
	0x98, 0x7e, 0x0f, 0x2b, 0x99, 0xc5, 0x77, 0x1b, 0x66, 0xfb, 0x31, 0xbc, 0x77, 0x8a, 0x5c, 0x79,
	0x59, 0x3f, 0x15, 0xc4, 0x6b, 0xb3, 0x6e, 0x9e, 0x0a, 0xe5, 0x0b, 0xdd, 0x2e, 0x5f, 0x53, 0xf9,
	0x6e, 0xe3, 0xf8, 0x95, 0xce, 0xd0, 0x84, 0xd6, 0xe4, 0x78, 0x26, 0x88, 0x69, 0x73, 0x4f, 0x70,
	0x93, 0x08, 0x02, 0x94, 0xe3, 0xc2, 0x11, 0xf6, 0xbf, 0x73, 0xba, 0x60, 0x34, 0xec, 0x1d, 0x97,
	0xec, 0x3a, 0x14, 0x04, 0xa3, 0x24, 0x2e, 0xd8, 0x69, 0x69, 0xd0, 0x2b, 0x99, 0xa2, 0xce, 0x9f,
	0x57, 0xd4, 0xe8, 0x67, 0x50, 0x54, 0x5f, 0x22, 0x56, 0xae, 0xc5, 0x2c, 0x4c, 0x60, 0xb3, 0x66,
	0x6f, 0xe9, 0xba, 0xc8, 0x1c, 0xc4, 0x54, 0xd7, 0x6c, 0xde, 0x56, 0xa7, 0x22, 0x33, 0x9b, 0xb4,
	0x5f, 0x8e, 0xb5, 0xd2, 0x18, 0x49, 0x44, 0xab, 0xb0, 0x94, 0xb9, 0x2a, 0x9e, 0x3d, 0x7f, 0xd6,
	0x5e, 0xbe, 0x82, 0xae, 0xc2, 0x4a, 0x66, 0x72, 0xaf, 0x8d, 0x77, 0x3b, 0x07, 0xcb, 0x39, 0x84,
	0xa0, 0x9a, 0x99, 0x7e, 0xfa, 0xfc, 0xeb, 0xe5, 0xb9, 0x19, 0x7b, 0x75, 0xd5, 0x2c, 0xe7, 0xd1,
	0xfb, 0xb0, 0x7a, 0xc6, 0xe5, 0xb9, 0x5c, 0xa8, 0xff, 0x37, 0x07, 0xf9, 0x06, 0x09, 0xd0, 0x7d,
	0xed, 0x42, 0x8b, 0x53, 0xf5, 0xcb, 0x0f, 0x4d, 0x7a, 0x35, 0xc9, 0xf6, 0xf5, 0xd5, 0xd9, 0xfe,
	0xdd, 0x15, 0x3d, 0xfb, 0x4a, 0x6c, 0xf7, 0x82, 0x79, 0x17, 0xb4, 0x6b, 0x6a, 0x3b, 0x53, 0xc6,
	0x68, 0xed, 0xcc, 0xee, 0x53, 0xd6, 0x1f, 0x9c, 0x5d, 0xf0, 0x86, 0xe3, 0x21, 0x94, 0x4c, 0x48,
	0xd1, 0xd5, 0xd3, 0x95, 0xa7, 0xac, 0xaf, 0x9d, 0x11, 0x76, 0x6d, 0xda, 0x84, 0xef, 0xcb, 0x7d,
	0x37, 0xd0, 0x7f, 0xed, 0x78, 0x59, 0xd2, 0xff, 0xdd, 0xfd, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xf1, 0xe0, 0x43, 0xcc, 0x78, 0x17, 0x00, 0x00,
}
