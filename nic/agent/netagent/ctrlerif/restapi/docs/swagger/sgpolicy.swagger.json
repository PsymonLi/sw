{
  "swagger": "2.0",
  "info": {
    "title": "Netproto API reference",
    "description": "\n",
    "version": ""
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/security/policies/": {
      "get": {
        "summary": "List all SGPolicy Objects",
        "operationId": "",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/netprotoSGPolicy"
              }
            }
          }
        },
        "tags": [
          "SGPolicy"
        ]
      },
      "post": {
        "summary": "Creates a SGPolicy Object",
        "operationId": "",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/netprotoApiResponse"
            }
          },
          "500": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/netprotoApiResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/netprotoSGPolicy"
            }
          }
        ],
        "tags": [
          "SGPolicy"
        ]
      }
    },
    "/api/security/policies/{ObjectMeta.Tenant}/{ObjectMeta.Namespace}/{ObjectMeta.Name}": {
      "delete": {
        "summary": "Deletes a SGPolicy Object",
        "operationId": "",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/netprotoApiResponse"
            }
          },
          "500": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/netprotoApiResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "kind": {
                  "type": "string"
                },
                "meta": {
                  "$ref": "#/definitions/apiObjectMeta"
                }
              }
            }
          }
        ],
        "tags": [
          "SGPolicy"
        ]
      }
    }
  },
  "definitions": {
    "apiEventType": {
      "type": "string",
      "enum": [
        "CreateEvent",
        "UpdateEvent",
        "DeleteEvent"
      ],
      "default": "CreateEvent",
      "title": "Watch event types"
    },
    "apiListWatchOptions": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "tenant": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "resource-version": {
          "type": "string"
        },
        "uuid": {
          "type": "string"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "creation-time": {
          "type": "string",
          "format": "date-time"
        },
        "mod-time": {
          "type": "string",
          "format": "date-time"
        },
        "self-link": {
          "type": "string"
        },
        "label-selector": {
          "type": "string",
          "description": "LabelSelector to select on labels in list or watch results."
        },
        "field-selector": {
          "type": "string",
          "title": "FieldSelector to select on field values in list or watch results"
        },
        "field-change-selector": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "FieldChangeSelector specifies to generate a watch notification on change in field(s) specified."
        },
        "from": {
          "type": "integer",
          "format": "int32",
          "title": "from represents the start offset (zero based), used for pagination.\nresults returned would be in the range [from ... from+max-results-1]"
        },
        "max-results": {
          "type": "integer",
          "format": "int32",
          "description": "max. number of events to be fetched for the request."
        }
      }
    },
    "apiObjectMeta": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the object, unique within a Namespace for scoped objects."
        },
        "tenant": {
          "type": "string",
          "description": "Tenant is global namespace isolation for various objects. This can be automatically\nfilled in many cases based on the tenant a user, who created the object, belongs go."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the object, for scoped objects."
        },
        "resource-version": {
          "type": "string",
          "description": "Resource version in the object store. This can only be set by the server."
        },
        "uuid": {
          "type": "string",
          "description": "UUID is the unique identifier for the object. This can only be set by the server."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are arbitrary (key,value) pairs associated with any object."
        },
        "creation-time": {
          "type": "string",
          "format": "date-time",
          "title": "CreationTime is the creation time of Object"
        },
        "mod-time": {
          "type": "string",
          "format": "date-time",
          "title": "ModTime is the Last Modification time of Object"
        },
        "self-link": {
          "type": "string",
          "description": "SelfLink is a link to accessing this object. When stored in the KV store this is\n the key in the kvstore and when the object is served from the API-GW it is the\n URI path. Examples\n   - \"/venice/tenants/tenants/tenant2\" in the kvstore\n   - \"/v1/tenants/tenants/tenant2\" when served by API Gateway."
        }
      },
      "description": "ObjectMeta contains metadata that all objects stored in kvstore must have."
    },
    "apiObjectRef": {
      "type": "object",
      "properties": {
        "tenant": {
          "type": "string",
          "description": "Tenant of the object."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the object, for scoped objects."
        },
        "kind": {
          "type": "string",
          "description": "Kind represents the type of the API object."
        },
        "name": {
          "type": "string",
          "description": "Name of the object, unique within a Namespace for scoped objects."
        },
        "uri": {
          "type": "string",
          "description": "URI is a link to accessing the referenced object."
        }
      },
      "description": "ObjectRef contains identifying information about an object."
    },
    "apiStatus": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string"
        },
        "api-version": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/apiStatusResult",
          "description": "Result contains the status of the operation, success or failure."
        },
        "message": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Message contains human readable form of the error."
        },
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "Code is the HTTP status code."
        },
        "object-ref": {
          "$ref": "#/definitions/apiObjectRef",
          "description": "Reference to the object (optional) for which this status is being sent."
        }
      },
      "description": "Status is returned for calls that dont return objects."
    },
    "apiStatusResult": {
      "type": "object",
      "properties": {
        "Str": {
          "type": "string"
        }
      },
      "description": "StatusResult contains possible statuses for a NIC."
    },
    "apiTimestamp": {
      "type": "object",
      "properties": {
        "seconds": {
          "type": "string",
          "format": "int64"
        },
        "nanos": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "apiTypeMeta": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "description": "Kind represents the type of the API object."
        },
        "api-version": {
          "type": "string",
          "title": "APIVersion defines the version of the API object. This can only be set by the server"
        }
      },
      "description": "TypeMeta contains the metadata about kind and version for all API objects."
    },
    "apiWatchEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "object": {
          "$ref": "#/definitions/protobufAny"
        }
      }
    },
    "apiWatchEventList": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/apiWatchEvent"
          }
        }
      }
    },
    "netprotoApiResponse": {
      "type": "object",
      "properties": {
        "status-code": {
          "type": "integer"
        },
        "error": {
          "type": "string"
        },
        "references": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "netprotoMatchSelector": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "Automatically interpret the string as an octet, a CIDR or an hyphen separated range"
        },
        "security-group": {
          "type": "string",
          "title": "Match on the security group"
        },
        "app": {
          "type": "string",
          "enum": [
            "NONE",
            "L4PORT"
          ],
          "default": "NONE",
          "title": "Match on the App info"
        },
        "app-config": {
          "type": "string"
        }
      },
      "title": "Common MatchSelector. ToDo Add ICMP Match criteria"
    },
    "netprotoPolicyRule": {
      "type": "object",
      "properties": {
        "action": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "enum": [
            "PERMIT",
            "DENY",
            "REJECT",
            "LOG"
          ],
          "default": "PERMIT",
          "title": "list of actions for the rule. Some combinations are invalid, eg: [\"PERMIT\", \"DENY\"]"
        },
        "source": {
          "$ref": "#/definitions/netprotoMatchSelector",
          "title": "inbound rule match. IP Address, CIDR based IP mask, or hyphen separeted IP Range or App info based selector.\nEmtpy src is interpreted as match all"
        },
        "destination": {
          "$ref": "#/definitions/netprotoMatchSelector",
          "title": "outbound rule match. IP Address, CIDR based IP mask, or hyphen separeted IP Range or App info based selector.\nEmtpy dst is interpreted as match all"
        },
        "rule-id": {
          "type": "string",
          "format": "uint64",
          "title": "Allocated ID"
        }
      }
    },
    "netprotoSGPolicy": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string"
        },
        "api-version": {
          "type": "string"
        },
        "meta": {
          "$ref": "#/definitions/apiObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/netprotoSGPolicySpec"
        },
        "status": {
          "$ref": "#/definitions/netprotoSGPolicyStatus"
        }
      },
      "title": "SGPolicy object"
    },
    "netprotoSGPolicyEvent": {
      "type": "object",
      "properties": {
        "event-type": {
          "$ref": "#/definitions/apiEventType"
        },
        "sg-policy": {
          "$ref": "#/definitions/netprotoSGPolicy"
        }
      },
      "title": "sg policy watch event"
    },
    "netprotoSGPolicyList": {
      "type": "object",
      "properties": {
        "sgpolicies": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/netprotoSGPolicy"
          }
        }
      }
    },
    "netprotoSGPolicySpec": {
      "type": "object",
      "properties": {
        "attach-group": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "list of security groups on which the policy is applied."
        },
        "attach-tenant": {
          "type": "boolean",
          "format": "boolean",
          "title": "specifies if the set of rules need to be attached globally to a tenant"
        },
        "policy-rules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/netprotoPolicyRule"
          },
          "title": "list of rules"
        }
      },
      "title": "SGPolicySpec captures all the security policy configuration"
    },
    "netprotoSGPolicyStatus": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "SGPolicyStatus captures the sg policy status"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name whose content describes the type of the\nserialized protocol buffer message.\n\nFor URLs which use the scheme `http`, `https`, or no scheme, the\nfollowing restrictions and interpretations apply:\n\n* If no scheme is provided, `https` is assumed.\n* The last segment of the URL's path must represent the fully\n  qualified name of the type (as in `path/google.protobuf.Duration`).\n  The name should be in a canonical form (e.g., leading \".\" is\n  not accepted).\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    }
  }
}
