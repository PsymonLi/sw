// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nwsec.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// normalization feature actions upon detecting malformed packets
type NormalizationAction int32

const (
	NormalizationAction_NORM_ACTION_NONE  NormalizationAction = 0
	NormalizationAction_NORM_ACTION_ALLOW NormalizationAction = 1
	NormalizationAction_NORM_ACTION_DROP  NormalizationAction = 2
	NormalizationAction_NORM_ACTION_EDIT  NormalizationAction = 3
)

var NormalizationAction_name = map[int32]string{
	0: "NORM_ACTION_NONE",
	1: "NORM_ACTION_ALLOW",
	2: "NORM_ACTION_DROP",
	3: "NORM_ACTION_EDIT",
}
var NormalizationAction_value = map[string]int32{
	"NORM_ACTION_NONE":  0,
	"NORM_ACTION_ALLOW": 1,
	"NORM_ACTION_DROP":  2,
	"NORM_ACTION_EDIT":  3,
}

func (x NormalizationAction) String() string {
	return proto.EnumName(NormalizationAction_name, int32(x))
}
func (NormalizationAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{0} }

// Applicaion Layer Gateway (ALG) names for invoking appropriate ALG
type ALGName int32

const (
	ALGName_APP_SVC_NONE       ALGName = 0
	ALGName_APP_SVC_TFTP       ALGName = 1
	ALGName_APP_SVC_FTP        ALGName = 2
	ALGName_APP_SVC_DNS        ALGName = 3
	ALGName_APP_SVC_SIP        ALGName = 4
	ALGName_APP_SVC_SUN_RPC    ALGName = 5
	ALGName_APP_SVC_MSFT_RPC   ALGName = 6
	ALGName_APP_SVC_RTSP       ALGName = 7
	ALGName_APP_SVC_TRACEROUTE ALGName = 8
	ALGName_APP_SVC_IP         ALGName = 9
	ALGName_APP_SVC_ANY        ALGName = 10
)

var ALGName_name = map[int32]string{
	0:  "APP_SVC_NONE",
	1:  "APP_SVC_TFTP",
	2:  "APP_SVC_FTP",
	3:  "APP_SVC_DNS",
	4:  "APP_SVC_SIP",
	5:  "APP_SVC_SUN_RPC",
	6:  "APP_SVC_MSFT_RPC",
	7:  "APP_SVC_RTSP",
	8:  "APP_SVC_TRACEROUTE",
	9:  "APP_SVC_IP",
	10: "APP_SVC_ANY",
}
var ALGName_value = map[string]int32{
	"APP_SVC_NONE":       0,
	"APP_SVC_TFTP":       1,
	"APP_SVC_FTP":        2,
	"APP_SVC_DNS":        3,
	"APP_SVC_SIP":        4,
	"APP_SVC_SUN_RPC":    5,
	"APP_SVC_MSFT_RPC":   6,
	"APP_SVC_RTSP":       7,
	"APP_SVC_TRACEROUTE": 8,
	"APP_SVC_IP":         9,
	"APP_SVC_ANY":        10,
}

func (x ALGName) String() string {
	return proto.EnumName(ALGName_name, int32(x))
}
func (ALGName) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{1} }

// Firewall policy actions
type FirewallAction int32

const (
	FirewallAction_FIREWALL_ACTION_NONE   FirewallAction = 0
	FirewallAction_FIREWALL_ACTION_ALLOW  FirewallAction = 1
	FirewallAction_FIREWALL_ACTION_DENY   FirewallAction = 2
	FirewallAction_FIREWALL_ACTION_REJECT FirewallAction = 3
)

var FirewallAction_name = map[int32]string{
	0: "FIREWALL_ACTION_NONE",
	1: "FIREWALL_ACTION_ALLOW",
	2: "FIREWALL_ACTION_DENY",
	3: "FIREWALL_ACTION_REJECT",
}
var FirewallAction_value = map[string]int32{
	"FIREWALL_ACTION_NONE":   0,
	"FIREWALL_ACTION_ALLOW":  1,
	"FIREWALL_ACTION_DENY":   2,
	"FIREWALL_ACTION_REJECT": 3,
}

func (x FirewallAction) String() string {
	return proto.EnumName(FirewallAction_name, int32(x))
}
func (FirewallAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{2} }

// Action to be takn on hitting a rule
type SecurityAction int32

const (
	SecurityAction_SECURITY_RULE_ACTION_NONE          SecurityAction = 0
	SecurityAction_SECURITY_RULE_ACTION_ALLOW         SecurityAction = 1
	SecurityAction_SECURITY_RULE_ACTION_DENY          SecurityAction = 2
	SecurityAction_SECURITY_RULE_ACTION_REJECT        SecurityAction = 3
	SecurityAction_SECURITY_RULE_ACTION_IMPLICIT_DENY SecurityAction = 4
)

var SecurityAction_name = map[int32]string{
	0: "SECURITY_RULE_ACTION_NONE",
	1: "SECURITY_RULE_ACTION_ALLOW",
	2: "SECURITY_RULE_ACTION_DENY",
	3: "SECURITY_RULE_ACTION_REJECT",
	4: "SECURITY_RULE_ACTION_IMPLICIT_DENY",
}
var SecurityAction_value = map[string]int32{
	"SECURITY_RULE_ACTION_NONE":          0,
	"SECURITY_RULE_ACTION_ALLOW":         1,
	"SECURITY_RULE_ACTION_DENY":          2,
	"SECURITY_RULE_ACTION_REJECT":        3,
	"SECURITY_RULE_ACTION_IMPLICIT_DENY": 4,
}

func (x SecurityAction) String() string {
	return proto.EnumName(SecurityAction_name, int32(x))
}
func (SecurityAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{3} }

type LogAction int32

const (
	LogAction_LOG_NONE                     LogAction = 0
	LogAction_LOG_ON_SESSION_START         LogAction = 1
	LogAction_LOG_ON_SESSION_END           LogAction = 2
	LogAction_LOG_ON_SESSION_START_AND_END LogAction = 3
)

var LogAction_name = map[int32]string{
	0: "LOG_NONE",
	1: "LOG_ON_SESSION_START",
	2: "LOG_ON_SESSION_END",
	3: "LOG_ON_SESSION_START_AND_END",
}
var LogAction_value = map[string]int32{
	"LOG_NONE":                     0,
	"LOG_ON_SESSION_START":         1,
	"LOG_ON_SESSION_END":           2,
	"LOG_ON_SESSION_START_AND_END": 3,
}

func (x LogAction) String() string {
	return proto.EnumName(LogAction_name, int32(x))
}
func (LogAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{4} }

type AppData_TraceLevel int32

const (
	AppData_TRACE_LEVEL_NONE      AppData_TraceLevel = 0
	AppData_TRACE_LEVEL_BRIEF     AppData_TraceLevel = 1
	AppData_TRACE_LEVEL_DETAIL    AppData_TraceLevel = 2
	AppData_TRACE_LEVEL_EXTENSIVE AppData_TraceLevel = 3
	AppData_TRACE_LEVEL_VERBOSE   AppData_TraceLevel = 4
)

var AppData_TraceLevel_name = map[int32]string{
	0: "TRACE_LEVEL_NONE",
	1: "TRACE_LEVEL_BRIEF",
	2: "TRACE_LEVEL_DETAIL",
	3: "TRACE_LEVEL_EXTENSIVE",
	4: "TRACE_LEVEL_VERBOSE",
}
var AppData_TraceLevel_value = map[string]int32{
	"TRACE_LEVEL_NONE":      0,
	"TRACE_LEVEL_BRIEF":     1,
	"TRACE_LEVEL_DETAIL":    2,
	"TRACE_LEVEL_EXTENSIVE": 3,
	"TRACE_LEVEL_VERBOSE":   4,
}

func (x AppData_TraceLevel) String() string {
	return proto.EnumName(AppData_TraceLevel_name, int32(x))
}
func (AppData_TraceLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 0} }

// ------------------------------------------------------------------------------
// SecurityProfileSpec object captures feature knobs that are most likely
// shareable across L2 segments, vrfs, or even interfaces and most of the
// time operates on defaults. It is possible that there is only object of this
// kind in the system.
// NOTE: user is not expected to fill in all the fields explicitly, that job is
//       done by the agent. Agent will be exposing user visible knobs and fill
//       in the defaults when interacting with HAL.
//
// Expected defaults:
//
// 1. Any abnormal behavior w.r.t flags (IP or TCP), default action is drop
// 2. Anything to do with options, default behavior is to reset/trim
// 3. Any length related errors, default is truncate the pkt
//
// Semantics:
// tcp_cnxn_setup_timeout = Maximum time elapsed from first SYN to 3-way handshake completion.
//                          Session gets cleaned up if 3-way handshake is not done by
//                          this time.
// tcp_half_closed_timeout= Maximum time elapsed from first FIN to 3/4way close.
//                           Session gets cleaned up if this elapses. To support half-open
//                           connections, this needs to be configured with a high value.
// tcp_close_timeout      = Time wait after FIN/RST is seen from both sides to session cleanup.
//
// tcp/udp/icmp_timeout   = Maximum idle timeout allowed for tcp/upd/icmp sessions before they
//                           are aged out. For TCP sessions, 3 TCP tickles are sent with 3 seconds
//                           interval. If we dont see a response back, we age out the session after
//                           sending out TCP RST.
// session_idle_timeout   = Maximum idle timeout allowed for all other sessions.
//
//
// {
//     cnxn_tracking_en                    = true
//     tcp_non_syn_first_pkt_drop          = true
//
//     ip_normalization_en                 = true
//     {
//         ip_ttl_change_detect_en         = false
//         ip_rsvd_flags_action            = drop
//         ip_df_action                    = allow
//         ip_options_action               = allow
//         ip_invalid_len_action           = trim
//         ip_normalize_ttl                = 0 (applicable only for workload
//                                              generated traffic)
//     }
//
//     icmp_normalization_en               = true
//     {
//         icmp_invalid_code_action        = drop
//         icmp_deprecated_msgs_drop       = true
//         icmp_redirect_msg_drop          = true
//     }
//
//     tcp_normalization_en                = true
//     {
//         tcp_split_handshake_drop        = false
//         tcp_rsvd_flags_action           = drop
//         tcp_unexpected_mss_action       = strip
//         tcp_unexpected_win_scale_action = strip
//         tcp_urg_ptr_not_set_action      = reset
//         tcp_urg_flag_not_set_action     = reset
//         tcp_urg_payload_missing_action  = reset
//         tcp_rst_with_data_action        = drop
//         tcp_data_len_gt_mss_action      = trim  (if conntrack is enabled)
//         tcp_data_len_gt_win_size_action = trim  (if conntrack is enabled)
//         tcp_unexpected_ts_option_action = reset (if conntrack is enabled)
//         tcp_unexpected_echo_ts_action   = drop
//         tcp_ts_not_present_drop         = true  (if conntrack is enabled)
//         tcp_invalid_flags_drop          = true
//         tcp_nonsyn_noack_drop           = true
//         tcp_normalize_mss               = 0 (no tcp_mss normalization)
//     }
//
//
// Flood protection knobs.
// Default is 0 and max is 128K sessions cumulative across all types.
//
//     tcp_half_open_session_limit         = 0 (no limits applied)
//     udp_active_session_limit            = 0 (no limits applied)
//     icmp_active_session_limit           = 0 (no limits applied)
//     other_active_session_limit          = 0 (no limits applied)
//
// }
// ------------------------------------------------------------------------------
type SecurityProfileSpec struct {
	KeyOrHandle          *SecurityProfileKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	SessionIdleTimeout   uint32                    `protobuf:"varint,2,opt,name=session_idle_timeout,json=sessionIdleTimeout,proto3" json:"session_idle_timeout,omitempty" range:30-172800, venice:default=90`
	TcpCnxnSetupTimeout  uint32                    `protobuf:"varint,3,opt,name=tcp_cnxn_setup_timeout,json=tcpCnxnSetupTimeout,proto3" json:"tcp_cnxn_setup_timeout,omitempty" range:1-60, venice:default=30`
	TcpCloseTimeout      uint32                    `protobuf:"varint,4,opt,name=tcp_close_timeout,json=tcpCloseTimeout,proto3" json:"tcp_close_timeout,omitempty" range:1-300, venice:default=15`
	TcpHalfClosedTimeout uint32                    `protobuf:"varint,5,opt,name=tcp_half_closed_timeout,json=tcpHalfClosedTimeout,proto3" json:"tcp_half_closed_timeout,omitempty" range:1-172800, venice:default=120`
	IpNormalizeTtl       uint32                    `protobuf:"varint,6,opt,name=ip_normalize_ttl,json=ipNormalizeTtl,proto3" json:"ip_normalize_ttl,omitempty" range:0-255, venice:default=0`
	TcpDropTimeout       uint32                    `protobuf:"varint,7,opt,name=tcp_drop_timeout,json=tcpDropTimeout,proto3" json:"tcp_drop_timeout,omitempty" range:1-300, venice:default=90`
	UdpDropTimeout       uint32                    `protobuf:"varint,8,opt,name=udp_drop_timeout,json=udpDropTimeout,proto3" json:"udp_drop_timeout,omitempty" range:1-172800, venice:default=60`
	IcmpDropTimeout      uint32                    `protobuf:"varint,9,opt,name=icmp_drop_timeout,json=icmpDropTimeout,proto3" json:"icmp_drop_timeout,omitempty" range:1-300, venice:default=60`
	DropTimeout          uint32                    `protobuf:"varint,10,opt,name=drop_timeout,json=dropTimeout,proto3" json:"drop_timeout,omitempty" range:1-300, venice:default=60`
	TcpTimeout           uint32                    `protobuf:"varint,11,opt,name=tcp_timeout,json=tcpTimeout,proto3" json:"tcp_timeout,omitempty" range:1-172800, venice:default=120`
	UdpTimeout           uint32                    `protobuf:"varint,12,opt,name=udp_timeout,json=udpTimeout,proto3" json:"udp_timeout,omitempty" range:1-172800, venice:default=30`
	IcmpTimeout          uint32                    `protobuf:"varint,13,opt,name=icmp_timeout,json=icmpTimeout,proto3" json:"icmp_timeout,omitempty" range:1-172800, venice:default=6`
	CnxnTrackingEn       bool                      `protobuf:"varint,14,opt,name=cnxn_tracking_en,json=cnxnTrackingEn,proto3" json:"cnxn_tracking_en,omitempty" venice:default=true`
	IpsgEn               bool                      `protobuf:"varint,15,opt,name=ipsg_en,json=ipsgEn,proto3" json:"ipsg_en,omitempty" venice:default=false`
	TcpRttEstimateEn     bool                      `protobuf:"varint,16,opt,name=tcp_rtt_estimate_en,json=tcpRttEstimateEn,proto3" json:"tcp_rtt_estimate_en,omitempty" venice:default=false`
	IpNormalizationEn    bool                      `protobuf:"varint,17,opt,name=ip_normalization_en,json=ipNormalizationEn,proto3" json:"ip_normalization_en,omitempty" venice:default=true`
	TcpNormalizationEn   bool                      `protobuf:"varint,18,opt,name=tcp_normalization_en,json=tcpNormalizationEn,proto3" json:"tcp_normalization_en,omitempty" venice:default=true`
	IcmpNormalizationEn  bool                      `protobuf:"varint,19,opt,name=icmp_normalization_en,json=icmpNormalizationEn,proto3" json:"icmp_normalization_en,omitempty" venice:default=true`
	IpReassemblyEn       bool                      `protobuf:"varint,20,opt,name=ip_reassembly_en,json=ipReassemblyEn,proto3" json:"ip_reassembly_en,omitempty" venice:default=false`
	// IP normalization knobs
	IpTtlChangeDetectEn        bool                `protobuf:"varint,21,opt,name=ip_ttl_change_detect_en,json=ipTtlChangeDetectEn,proto3" json:"ip_ttl_change_detect_en,omitempty" venice:default=false`
	IpSrcGuardEn               bool                `protobuf:"varint,22,opt,name=ip_src_guard_en,json=ipSrcGuardEn,proto3" json:"ip_src_guard_en,omitempty" venice:default=false`
	IpRsvdFlagsAction          NormalizationAction `protobuf:"varint,23,opt,name=ip_rsvd_flags_action,json=ipRsvdFlagsAction,proto3,enum=nwsec.NormalizationAction" json:"ip_rsvd_flags_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	IpDfAction                 NormalizationAction `protobuf:"varint,24,opt,name=ip_df_action,json=ipDfAction,proto3,enum=nwsec.NormalizationAction" json:"ip_df_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_ALLOW`
	IpOptionsAction            NormalizationAction `protobuf:"varint,25,opt,name=ip_options_action,json=ipOptionsAction,proto3,enum=nwsec.NormalizationAction" json:"ip_options_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_ALLOW`
	IpInvalidLenAction         NormalizationAction `protobuf:"varint,26,opt,name=ip_invalid_len_action,json=ipInvalidLenAction,proto3,enum=nwsec.NormalizationAction" json:"ip_invalid_len_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_TRIM`
	IpSpoofPktDrop             bool                `protobuf:"varint,27,opt,name=ip_spoof_pkt_drop,json=ipSpoofPktDrop,proto3" json:"ip_spoof_pkt_drop,omitempty" venice:default=false`
	IpLooseSrcRoutingPktDrop   bool                `protobuf:"varint,28,opt,name=ip_loose_src_routing_pkt_drop,json=ipLooseSrcRoutingPktDrop,proto3" json:"ip_loose_src_routing_pkt_drop,omitempty" venice:default=false`
	IpMalformedOptionPktDrop   bool                `protobuf:"varint,29,opt,name=ip_malformed_option_pkt_drop,json=ipMalformedOptionPktDrop,proto3" json:"ip_malformed_option_pkt_drop,omitempty" venice:default=false`
	IpRecordRouteOptionPktDrop bool                `protobuf:"varint,30,opt,name=ip_record_route_option_pkt_drop,json=ipRecordRouteOptionPktDrop,proto3" json:"ip_record_route_option_pkt_drop,omitempty" venice:default=false`
	IpStrictSrcRoutingPktDrop  bool                `protobuf:"varint,31,opt,name=ip_strict_src_routing_pkt_drop,json=ipStrictSrcRoutingPktDrop,proto3" json:"ip_strict_src_routing_pkt_drop,omitempty" venice:default=false`
	IpTsOptionPktDrop          bool                `protobuf:"varint,32,opt,name=ip_ts_option_pkt_drop,json=ipTsOptionPktDrop,proto3" json:"ip_ts_option_pkt_drop,omitempty" venice:default=false`
	IpUnknownOptionPktDrop     bool                `protobuf:"varint,33,opt,name=ip_unknown_option_pkt_drop,json=ipUnknownOptionPktDrop,proto3" json:"ip_unknown_option_pkt_drop,omitempty" venice:default=false`
	IpStreamIdOptionPktDrop    bool                `protobuf:"varint,34,opt,name=ip_stream_id_option_pkt_drop,json=ipStreamIdOptionPktDrop,proto3" json:"ip_stream_id_option_pkt_drop,omitempty" venice:default=false`
	IpRsvdFldSetPktDrop        bool                `protobuf:"varint,35,opt,name=ip_rsvd_fld_set_pkt_drop,json=ipRsvdFldSetPktDrop,proto3" json:"ip_rsvd_fld_set_pkt_drop,omitempty" venice:default=false`
	IpClearDfBit               bool                `protobuf:"varint,36,opt,name=ip_clear_df_bit,json=ipClearDfBit,proto3" json:"ip_clear_df_bit,omitempty" venice:default=false`
	// IPv6 knobs
	Ipv6AnycastSrcDrop         bool `protobuf:"varint,40,opt,name=ipv6_anycast_src_drop,json=ipv6AnycastSrcDrop,proto3" json:"ipv6_anycast_src_drop,omitempty" venice:default=false`
	Ipv6V4CompatibleAddrDrop   bool `protobuf:"varint,41,opt,name=ipv6_v4_compatible_addr_drop,json=ipv6V4CompatibleAddrDrop,proto3" json:"ipv6_v4_compatible_addr_drop,omitempty" venice:default=false`
	Ipv6NeedlessIpFragHdrDrop  bool `protobuf:"varint,42,opt,name=ipv6_needless_ip_frag_hdr_drop,json=ipv6NeedlessIpFragHdrDrop,proto3" json:"ipv6_needless_ip_frag_hdr_drop,omitempty" venice:default=false`
	Ipv6InvalidOptionsPktDrop  bool `protobuf:"varint,43,opt,name=ipv6_invalid_options_pkt_drop,json=ipv6InvalidOptionsPktDrop,proto3" json:"ipv6_invalid_options_pkt_drop,omitempty" venice:default=false`
	Ipv6RsvdFldSetPktDrop      bool `protobuf:"varint,44,opt,name=ipv6_rsvd_fld_set_pkt_drop,json=ipv6RsvdFldSetPktDrop,proto3" json:"ipv6_rsvd_fld_set_pkt_drop,omitempty" venice:default=false`
	Ipv6RtgHdrPktDrop          bool `protobuf:"varint,45,opt,name=ipv6_rtg_hdr_pkt_drop,json=ipv6RtgHdrPktDrop,proto3" json:"ipv6_rtg_hdr_pkt_drop,omitempty" venice:default=false`
	Ipv6DstOptionsHdrPktDrop   bool `protobuf:"varint,46,opt,name=ipv6_dst_options_hdr_pkt_drop,json=ipv6DstOptionsHdrPktDrop,proto3" json:"ipv6_dst_options_hdr_pkt_drop,omitempty" venice:default=false`
	Ipv6HopByHopOptionsPktDrop bool `protobuf:"varint,47,opt,name=ipv6_hop_by_hop_options_pkt_drop,json=ipv6HopByHopOptionsPktDrop,proto3" json:"ipv6_hop_by_hop_options_pkt_drop,omitempty" venice:default=false`
	// ICMP/ICMPv6 normalization knobs
	IcmpInvalidCodeAction       NormalizationAction `protobuf:"varint,50,opt,name=icmp_invalid_code_action,json=icmpInvalidCodeAction,proto3,enum=nwsec.NormalizationAction" json:"icmp_invalid_code_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	IcmpDeprecatedMsgsDrop      bool                `protobuf:"varint,51,opt,name=icmp_deprecated_msgs_drop,json=icmpDeprecatedMsgsDrop,proto3" json:"icmp_deprecated_msgs_drop,omitempty" venice:default=true`
	IcmpRedirectMsgDrop         bool                `protobuf:"varint,52,opt,name=icmp_redirect_msg_drop,json=icmpRedirectMsgDrop,proto3" json:"icmp_redirect_msg_drop,omitempty" venice:default=true`
	IcmpDstUnreachIgnorePayload bool                `protobuf:"varint,53,opt,name=icmp_dst_unreach_ignore_payload,json=icmpDstUnreachIgnorePayload,proto3" json:"icmp_dst_unreach_ignore_payload,omitempty" venice:default=false`
	IcmpParamPrblmIgnorePayload bool                `protobuf:"varint,54,opt,name=icmp_param_prblm_ignore_payload,json=icmpParamPrblmIgnorePayload,proto3" json:"icmp_param_prblm_ignore_payload,omitempty" venice:default=false`
	IcmpPktTooBigIgnorePayload  bool                `protobuf:"varint,55,opt,name=icmp_pkt_too_big_ignore_payload,json=icmpPktTooBigIgnorePayload,proto3" json:"icmp_pkt_too_big_ignore_payload,omitempty" venice:default=false`
	IcmpRedirectIgnorePayload   bool                `protobuf:"varint,56,opt,name=icmp_redirect_ignore_payload,json=icmpRedirectIgnorePayload,proto3" json:"icmp_redirect_ignore_payload,omitempty" venice:default=false`
	IcmpTimeExceedIgnorePayload bool                `protobuf:"varint,57,opt,name=icmp_time_exceed_ignore_payload,json=icmpTimeExceedIgnorePayload,proto3" json:"icmp_time_exceed_ignore_payload,omitempty" venice:default=false`
	IcmpErrorDrop               bool                `protobuf:"varint,58,opt,name=icmp_error_drop,json=icmpErrorDrop,proto3" json:"icmp_error_drop,omitempty" venice:default=false`
	IcmpFragmentsDrop           bool                `protobuf:"varint,59,opt,name=icmp_fragments_drop,json=icmpFragmentsDrop,proto3" json:"icmp_fragments_drop,omitempty" venice:default=false`
	IcmpLargePktDrop            bool                `protobuf:"varint,60,opt,name=icmp_large_pkt_drop,json=icmpLargePktDrop,proto3" json:"icmp_large_pkt_drop,omitempty" venice:default=false`
	IcmpPingZeroIdDrop          bool                `protobuf:"varint,61,opt,name=icmp_ping_zero_id_drop,json=icmpPingZeroIdDrop,proto3" json:"icmp_ping_zero_id_drop,omitempty" venice:default=false`
	IcmpNeedFragSuppress        bool                `protobuf:"varint,62,opt,name=icmp_need_frag_suppress,json=icmpNeedFragSuppress,proto3" json:"icmp_need_frag_suppress,omitempty" venice:default=false`
	IcmpTimeExceedSuppress      bool                `protobuf:"varint,63,opt,name=icmp_time_exceed_suppress,json=icmpTimeExceedSuppress,proto3" json:"icmp_time_exceed_suppress,omitempty" venice:default=false`
	Icmpv6LargeMsgMtuSmallDrop  bool                `protobuf:"varint,64,opt,name=icmpv6_large_msg_mtu_small_drop,json=icmpv6LargeMsgMtuSmallDrop,proto3" json:"icmpv6_large_msg_mtu_small_drop,omitempty" venice:default=false`
	// TCP normalization knobs
	TcpSplitHandshakeDrop         bool                `protobuf:"varint,71,opt,name=tcp_split_handshake_drop,json=tcpSplitHandshakeDrop,proto3" json:"tcp_split_handshake_drop,omitempty" venice:default=false`
	TcpRsvdFlagsAction            NormalizationAction `protobuf:"varint,72,opt,name=tcp_rsvd_flags_action,json=tcpRsvdFlagsAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_rsvd_flags_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	TcpUnexpectedMssAction        NormalizationAction `protobuf:"varint,73,opt,name=tcp_unexpected_mss_action,json=tcpUnexpectedMssAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_mss_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_STRIP`
	TcpUnexpectedWinScaleAction   NormalizationAction `protobuf:"varint,74,opt,name=tcp_unexpected_win_scale_action,json=tcpUnexpectedWinScaleAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_win_scale_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_STRIP`
	TcpUnexpectedSackPermAction   NormalizationAction `protobuf:"varint,75,opt,name=tcp_unexpected_sack_perm_action,json=tcpUnexpectedSackPermAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_sack_perm_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_STRIP`
	TcpUrgPtrNotSetAction         NormalizationAction `protobuf:"varint,76,opt,name=tcp_urg_ptr_not_set_action,json=tcpUrgPtrNotSetAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_ptr_not_set_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_RESET`
	TcpUrgFlagNotSetAction        NormalizationAction `protobuf:"varint,77,opt,name=tcp_urg_flag_not_set_action,json=tcpUrgFlagNotSetAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_flag_not_set_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_RESET`
	TcpUrgPayloadMissingAction    NormalizationAction `protobuf:"varint,78,opt,name=tcp_urg_payload_missing_action,json=tcpUrgPayloadMissingAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_urg_payload_missing_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_RESET`
	TcpRstWithDataAction          NormalizationAction `protobuf:"varint,79,opt,name=tcp_rst_with_data_action,json=tcpRstWithDataAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_rst_with_data_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	TcpDataLenGtMssAction         NormalizationAction `protobuf:"varint,80,opt,name=tcp_data_len_gt_mss_action,json=tcpDataLenGtMssAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_data_len_gt_mss_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_TRIM`
	TcpDataLenGtWinSizeAction     NormalizationAction `protobuf:"varint,81,opt,name=tcp_data_len_gt_win_size_action,json=tcpDataLenGtWinSizeAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_data_len_gt_win_size_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_TRIM`
	TcpUnexpectedTsOptionAction   NormalizationAction `protobuf:"varint,82,opt,name=tcp_unexpected_ts_option_action,json=tcpUnexpectedTsOptionAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_ts_option_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_RESET`
	TcpUnexpectedEchoTsAction     NormalizationAction `protobuf:"varint,83,opt,name=tcp_unexpected_echo_ts_action,json=tcpUnexpectedEchoTsAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_echo_ts_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	TcpUnexpectedSackOptionAction NormalizationAction `protobuf:"varint,84,opt,name=tcp_unexpected_sack_option_action,json=tcpUnexpectedSackOptionAction,proto3,enum=nwsec.NormalizationAction" json:"tcp_unexpected_sack_option_action,omitempty" venice:default=nwsec.NormalizationAction.NORM_ACTION_DROP`
	TcpTsNotPresentDrop           bool                `protobuf:"varint,85,opt,name=tcp_ts_not_present_drop,json=tcpTsNotPresentDrop,proto3" json:"tcp_ts_not_present_drop,omitempty" venice:default=true`
	TcpNonSynFirstPktDrop         bool                `protobuf:"varint,86,opt,name=tcp_non_syn_first_pkt_drop,json=tcpNonSynFirstPktDrop,proto3" json:"tcp_non_syn_first_pkt_drop,omitempty" venice:default=true`
	// We will check for the following cases for invalid TCP flags
	// 1. SYN + FIN
	// 2. SYN + RST
	// 3. All TCP flags set (tcp_flags = 0xFF)
	// 4. No TCP flags set (tcp_flags = 0x0)
	TcpInvalidFlagsDrop         bool `protobuf:"varint,87,opt,name=tcp_invalid_flags_drop,json=tcpInvalidFlagsDrop,proto3" json:"tcp_invalid_flags_drop,omitempty" venice:default=true`
	TcpNonsynNoackDrop          bool `protobuf:"varint,88,opt,name=tcp_nonsyn_noack_drop,json=tcpNonsynNoackDrop,proto3" json:"tcp_nonsyn_noack_drop,omitempty" venice:default=true`
	TcpSynWithDataDrop          bool `protobuf:"varint,89,opt,name=tcp_syn_with_data_drop,json=tcpSynWithDataDrop,proto3" json:"tcp_syn_with_data_drop,omitempty" venice:default=false`
	TcpSynAckWithDataDrop       bool `protobuf:"varint,90,opt,name=tcp_syn_ack_with_data_drop,json=tcpSynAckWithDataDrop,proto3" json:"tcp_syn_ack_with_data_drop,omitempty" venice:default=false`
	TcpOverlappingSegmentsDrop  bool `protobuf:"varint,91,opt,name=tcp_overlapping_segments_drop,json=tcpOverlappingSegmentsDrop,proto3" json:"tcp_overlapping_segments_drop,omitempty" venice:default=false`
	TcpStripTimestampOption     bool `protobuf:"varint,92,opt,name=tcp_strip_timestamp_option,json=tcpStripTimestampOption,proto3" json:"tcp_strip_timestamp_option,omitempty" venice:default=false`
	TcpConnTrackBypassWindowErr bool `protobuf:"varint,93,opt,name=tcp_conn_track_bypass_window_err,json=tcpConnTrackBypassWindowErr,proto3" json:"tcp_conn_track_bypass_window_err,omitempty" venice:default=false`
	TcpConnTrackFinRstDisable   bool `protobuf:"varint,94,opt,name=tcp_conn_track_fin_rst_disable,json=tcpConnTrackFinRstDisable,proto3" json:"tcp_conn_track_fin_rst_disable,omitempty" venice:default=false`
	TcpUrgFlagPtrClear          bool `protobuf:"varint,95,opt,name=tcp_urg_flag_ptr_clear,json=tcpUrgFlagPtrClear,proto3" json:"tcp_urg_flag_ptr_clear,omitempty" venice:default=false`
	// Can we have zero as default but when configured the range is between 576 - 9216 ?
	TcpNormalizeMss  uint32 `protobuf:"varint,96,opt,name=tcp_normalize_mss,json=tcpNormalizeMss,proto3" json:"tcp_normalize_mss,omitempty" range:0-9216, venice:default=0`
	MulticastSrcDrop bool   `protobuf:"varint,97,opt,name=multicast_src_drop,json=multicastSrcDrop,proto3" json:"multicast_src_drop,omitempty" venice:default=true`
	// Flood protection knobs
	TcpHalfOpenSessionLimit uint32 `protobuf:"varint,98,opt,name=tcp_half_open_session_limit,json=tcpHalfOpenSessionLimit,proto3" json:"tcp_half_open_session_limit,omitempty" venice:default=0`
	UdpActiveSessionLimit   uint32 `protobuf:"varint,99,opt,name=udp_active_session_limit,json=udpActiveSessionLimit,proto3" json:"udp_active_session_limit,omitempty" venice:default=0`
	IcmpActiveSessionLimit  uint32 `protobuf:"varint,100,opt,name=icmp_active_session_limit,json=icmpActiveSessionLimit,proto3" json:"icmp_active_session_limit,omitempty" venice:default=0`
	OtherActiveSessionLimit uint32 `protobuf:"varint,101,opt,name=other_active_session_limit,json=otherActiveSessionLimit,proto3" json:"other_active_session_limit,omitempty" venice:default=0`
	// Firewall knobs
	PolicyEnforceEn bool `protobuf:"varint,102,opt,name=policy_enforce_en,json=policyEnforceEn,proto3" json:"policy_enforce_en,omitempty" venice:default=true`
	FlowLearnEn     bool `protobuf:"varint,103,opt,name=flow_learn_en,json=flowLearnEn,proto3" json:"flow_learn_en,omitempty" venice:default=false`
	AppDetectionEn  bool `protobuf:"varint,104,opt,name=app_detection_en,json=appDetectionEn,proto3" json:"app_detection_en,omitempty" venice:default=false`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{0} }

func (m *SecurityProfileSpec) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityProfileSpec) GetSessionIdleTimeout() uint32 {
	if m != nil {
		return m.SessionIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpCnxnSetupTimeout() uint32 {
	if m != nil {
		return m.TcpCnxnSetupTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpCloseTimeout() uint32 {
	if m != nil {
		return m.TcpCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpHalfClosedTimeout() uint32 {
	if m != nil {
		return m.TcpHalfClosedTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetIpNormalizeTtl() uint32 {
	if m != nil {
		return m.IpNormalizeTtl
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpDropTimeout() uint32 {
	if m != nil {
		return m.TcpDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUdpDropTimeout() uint32 {
	if m != nil {
		return m.UdpDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetIcmpDropTimeout() uint32 {
	if m != nil {
		return m.IcmpDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetDropTimeout() uint32 {
	if m != nil {
		return m.DropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTcpTimeout() uint32 {
	if m != nil {
		return m.TcpTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUdpTimeout() uint32 {
	if m != nil {
		return m.UdpTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetIcmpTimeout() uint32 {
	if m != nil {
		return m.IcmpTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetCnxnTrackingEn() bool {
	if m != nil {
		return m.CnxnTrackingEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpsgEn() bool {
	if m != nil {
		return m.IpsgEn
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpRttEstimateEn() bool {
	if m != nil {
		return m.TcpRttEstimateEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpNormalizationEn() bool {
	if m != nil {
		return m.IpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNormalizationEn() bool {
	if m != nil {
		return m.TcpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpNormalizationEn() bool {
	if m != nil {
		return m.IcmpNormalizationEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpReassemblyEn() bool {
	if m != nil {
		return m.IpReassemblyEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpTtlChangeDetectEn() bool {
	if m != nil {
		return m.IpTtlChangeDetectEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpSrcGuardEn() bool {
	if m != nil {
		return m.IpSrcGuardEn
	}
	return false
}

func (m *SecurityProfileSpec) GetIpRsvdFlagsAction() NormalizationAction {
	if m != nil {
		return m.IpRsvdFlagsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpDfAction() NormalizationAction {
	if m != nil {
		return m.IpDfAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpOptionsAction() NormalizationAction {
	if m != nil {
		return m.IpOptionsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpInvalidLenAction() NormalizationAction {
	if m != nil {
		return m.IpInvalidLenAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIpSpoofPktDrop() bool {
	if m != nil {
		return m.IpSpoofPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpLooseSrcRoutingPktDrop() bool {
	if m != nil {
		return m.IpLooseSrcRoutingPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpMalformedOptionPktDrop() bool {
	if m != nil {
		return m.IpMalformedOptionPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpRecordRouteOptionPktDrop() bool {
	if m != nil {
		return m.IpRecordRouteOptionPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpStrictSrcRoutingPktDrop() bool {
	if m != nil {
		return m.IpStrictSrcRoutingPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpTsOptionPktDrop() bool {
	if m != nil {
		return m.IpTsOptionPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpUnknownOptionPktDrop() bool {
	if m != nil {
		return m.IpUnknownOptionPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpStreamIdOptionPktDrop() bool {
	if m != nil {
		return m.IpStreamIdOptionPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpRsvdFldSetPktDrop() bool {
	if m != nil {
		return m.IpRsvdFldSetPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpClearDfBit() bool {
	if m != nil {
		return m.IpClearDfBit
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6AnycastSrcDrop() bool {
	if m != nil {
		return m.Ipv6AnycastSrcDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6V4CompatibleAddrDrop() bool {
	if m != nil {
		return m.Ipv6V4CompatibleAddrDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6NeedlessIpFragHdrDrop() bool {
	if m != nil {
		return m.Ipv6NeedlessIpFragHdrDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6InvalidOptionsPktDrop() bool {
	if m != nil {
		return m.Ipv6InvalidOptionsPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6RsvdFldSetPktDrop() bool {
	if m != nil {
		return m.Ipv6RsvdFldSetPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6RtgHdrPktDrop() bool {
	if m != nil {
		return m.Ipv6RtgHdrPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6DstOptionsHdrPktDrop() bool {
	if m != nil {
		return m.Ipv6DstOptionsHdrPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIpv6HopByHopOptionsPktDrop() bool {
	if m != nil {
		return m.Ipv6HopByHopOptionsPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpInvalidCodeAction() NormalizationAction {
	if m != nil {
		return m.IcmpInvalidCodeAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetIcmpDeprecatedMsgsDrop() bool {
	if m != nil {
		return m.IcmpDeprecatedMsgsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpRedirectMsgDrop() bool {
	if m != nil {
		return m.IcmpRedirectMsgDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpDstUnreachIgnorePayload() bool {
	if m != nil {
		return m.IcmpDstUnreachIgnorePayload
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpParamPrblmIgnorePayload() bool {
	if m != nil {
		return m.IcmpParamPrblmIgnorePayload
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpPktTooBigIgnorePayload() bool {
	if m != nil {
		return m.IcmpPktTooBigIgnorePayload
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpRedirectIgnorePayload() bool {
	if m != nil {
		return m.IcmpRedirectIgnorePayload
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpTimeExceedIgnorePayload() bool {
	if m != nil {
		return m.IcmpTimeExceedIgnorePayload
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpErrorDrop() bool {
	if m != nil {
		return m.IcmpErrorDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpFragmentsDrop() bool {
	if m != nil {
		return m.IcmpFragmentsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpLargePktDrop() bool {
	if m != nil {
		return m.IcmpLargePktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpPingZeroIdDrop() bool {
	if m != nil {
		return m.IcmpPingZeroIdDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpNeedFragSuppress() bool {
	if m != nil {
		return m.IcmpNeedFragSuppress
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpTimeExceedSuppress() bool {
	if m != nil {
		return m.IcmpTimeExceedSuppress
	}
	return false
}

func (m *SecurityProfileSpec) GetIcmpv6LargeMsgMtuSmallDrop() bool {
	if m != nil {
		return m.Icmpv6LargeMsgMtuSmallDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpSplitHandshakeDrop() bool {
	if m != nil {
		return m.TcpSplitHandshakeDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpRsvdFlagsAction() NormalizationAction {
	if m != nil {
		return m.TcpRsvdFlagsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedMssAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedMssAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedWinScaleAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedWinScaleAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedSackPermAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedSackPermAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgPtrNotSetAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgPtrNotSetAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgFlagNotSetAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgFlagNotSetAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUrgPayloadMissingAction() NormalizationAction {
	if m != nil {
		return m.TcpUrgPayloadMissingAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpRstWithDataAction() NormalizationAction {
	if m != nil {
		return m.TcpRstWithDataAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpDataLenGtMssAction() NormalizationAction {
	if m != nil {
		return m.TcpDataLenGtMssAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpDataLenGtWinSizeAction() NormalizationAction {
	if m != nil {
		return m.TcpDataLenGtWinSizeAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedTsOptionAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedTsOptionAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedEchoTsAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedEchoTsAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpUnexpectedSackOptionAction() NormalizationAction {
	if m != nil {
		return m.TcpUnexpectedSackOptionAction
	}
	return NormalizationAction_NORM_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTcpTsNotPresentDrop() bool {
	if m != nil {
		return m.TcpTsNotPresentDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNonSynFirstPktDrop() bool {
	if m != nil {
		return m.TcpNonSynFirstPktDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpInvalidFlagsDrop() bool {
	if m != nil {
		return m.TcpInvalidFlagsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNonsynNoackDrop() bool {
	if m != nil {
		return m.TcpNonsynNoackDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpSynWithDataDrop() bool {
	if m != nil {
		return m.TcpSynWithDataDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpSynAckWithDataDrop() bool {
	if m != nil {
		return m.TcpSynAckWithDataDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpOverlappingSegmentsDrop() bool {
	if m != nil {
		return m.TcpOverlappingSegmentsDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpStripTimestampOption() bool {
	if m != nil {
		return m.TcpStripTimestampOption
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpConnTrackBypassWindowErr() bool {
	if m != nil {
		return m.TcpConnTrackBypassWindowErr
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpConnTrackFinRstDisable() bool {
	if m != nil {
		return m.TcpConnTrackFinRstDisable
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpUrgFlagPtrClear() bool {
	if m != nil {
		return m.TcpUrgFlagPtrClear
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpNormalizeMss() uint32 {
	if m != nil {
		return m.TcpNormalizeMss
	}
	return 0
}

func (m *SecurityProfileSpec) GetMulticastSrcDrop() bool {
	if m != nil {
		return m.MulticastSrcDrop
	}
	return false
}

func (m *SecurityProfileSpec) GetTcpHalfOpenSessionLimit() uint32 {
	if m != nil {
		return m.TcpHalfOpenSessionLimit
	}
	return 0
}

func (m *SecurityProfileSpec) GetUdpActiveSessionLimit() uint32 {
	if m != nil {
		return m.UdpActiveSessionLimit
	}
	return 0
}

func (m *SecurityProfileSpec) GetIcmpActiveSessionLimit() uint32 {
	if m != nil {
		return m.IcmpActiveSessionLimit
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherActiveSessionLimit() uint32 {
	if m != nil {
		return m.OtherActiveSessionLimit
	}
	return 0
}

func (m *SecurityProfileSpec) GetPolicyEnforceEn() bool {
	if m != nil {
		return m.PolicyEnforceEn
	}
	return false
}

func (m *SecurityProfileSpec) GetFlowLearnEn() bool {
	if m != nil {
		return m.FlowLearnEn
	}
	return false
}

func (m *SecurityProfileSpec) GetAppDetectionEn() bool {
	if m != nil {
		return m.AppDetectionEn
	}
	return false
}

// SecurityProfileRequestMsg is batched add or modify profile request
type SecurityProfileRequestMsg struct {
	Request []*SecurityProfileSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileRequestMsg) Reset()                    { *m = SecurityProfileRequestMsg{} }
func (m *SecurityProfileRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileRequestMsg) ProtoMessage()               {}
func (*SecurityProfileRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{1} }

func (m *SecurityProfileRequestMsg) GetRequest() []*SecurityProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Security profile oper state for enterprise pipeline
type SecurityProfileStatusEpd struct {
	HwSecProfileId uint32 `protobuf:"varint,1,opt,name=hw_sec_profile_id,json=hwSecProfileId,proto3" json:"hw_sec_profile_id,omitempty"`
}

func (m *SecurityProfileStatusEpd) Reset()                    { *m = SecurityProfileStatusEpd{} }
func (m *SecurityProfileStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatusEpd) ProtoMessage()               {}
func (*SecurityProfileStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{2} }

func (m *SecurityProfileStatusEpd) GetHwSecProfileId() uint32 {
	if m != nil {
		return m.HwSecProfileId
	}
	return 0
}

// Security profile oper state for cloud pipeline
type SecurityProfileStatusCpd struct {
}

func (m *SecurityProfileStatusCpd) Reset()                    { *m = SecurityProfileStatusCpd{} }
func (m *SecurityProfileStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatusCpd) ProtoMessage()               {}
func (*SecurityProfileStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{3} }

// SecurityProfile operational status
type SecurityProfileStatus struct {
	ProfileHandle uint64 `protobuf:"fixed64,1,opt,name=profile_handle,json=profileHandle,proto3" json:"profile_handle,omitempty"`
	// Types that are valid to be assigned to ProfilePdStatus:
	//	*SecurityProfileStatus_EpdStatus
	//	*SecurityProfileStatus_CpdStatus
	ProfilePdStatus isSecurityProfileStatus_ProfilePdStatus `protobuf_oneof:"profile_pd_status"`
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{4} }

type isSecurityProfileStatus_ProfilePdStatus interface {
	isSecurityProfileStatus_ProfilePdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecurityProfileStatus_EpdStatus struct {
	EpdStatus *SecurityProfileStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type SecurityProfileStatus_CpdStatus struct {
	CpdStatus *SecurityProfileStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*SecurityProfileStatus_EpdStatus) isSecurityProfileStatus_ProfilePdStatus() {}
func (*SecurityProfileStatus_CpdStatus) isSecurityProfileStatus_ProfilePdStatus() {}

func (m *SecurityProfileStatus) GetProfilePdStatus() isSecurityProfileStatus_ProfilePdStatus {
	if m != nil {
		return m.ProfilePdStatus
	}
	return nil
}

func (m *SecurityProfileStatus) GetProfileHandle() uint64 {
	if m != nil {
		return m.ProfileHandle
	}
	return 0
}

func (m *SecurityProfileStatus) GetEpdStatus() *SecurityProfileStatusEpd {
	if x, ok := m.GetProfilePdStatus().(*SecurityProfileStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *SecurityProfileStatus) GetCpdStatus() *SecurityProfileStatusCpd {
	if x, ok := m.GetProfilePdStatus().(*SecurityProfileStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SecurityProfileStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SecurityProfileStatus_OneofMarshaler, _SecurityProfileStatus_OneofUnmarshaler, _SecurityProfileStatus_OneofSizer, []interface{}{
		(*SecurityProfileStatus_EpdStatus)(nil),
		(*SecurityProfileStatus_CpdStatus)(nil),
	}
}

func _SecurityProfileStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SecurityProfileStatus)
	// profile_pd_status
	switch x := m.ProfilePdStatus.(type) {
	case *SecurityProfileStatus_EpdStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *SecurityProfileStatus_CpdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SecurityProfileStatus.ProfilePdStatus has unexpected type %T", x)
	}
	return nil
}

func _SecurityProfileStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SecurityProfileStatus)
	switch tag {
	case 2: // profile_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityProfileStatusEpd)
		err := b.DecodeMessage(msg)
		m.ProfilePdStatus = &SecurityProfileStatus_EpdStatus{msg}
		return true, err
	case 3: // profile_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityProfileStatusCpd)
		err := b.DecodeMessage(msg)
		m.ProfilePdStatus = &SecurityProfileStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SecurityProfileStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SecurityProfileStatus)
	// profile_pd_status
	switch x := m.ProfilePdStatus.(type) {
	case *SecurityProfileStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SecurityProfileStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SecurityProfileResponse is response to SecurityProfileSpec
type SecurityProfileResponse struct {
	ApiStatus     ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	ProfileStatus *SecurityProfileStatus `protobuf:"bytes,2,opt,name=profile_status,json=profileStatus" json:"profile_status,omitempty"`
}

func (m *SecurityProfileResponse) Reset()                    { *m = SecurityProfileResponse{} }
func (m *SecurityProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponse) ProtoMessage()               {}
func (*SecurityProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{5} }

func (m *SecurityProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileResponse) GetProfileStatus() *SecurityProfileStatus {
	if m != nil {
		return m.ProfileStatus
	}
	return nil
}

// SecurityProfileResponseMsg is batched response to SecurityProfileRequestMsg
type SecurityProfileResponseMsg struct {
	Response []*SecurityProfileResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileResponseMsg) Reset()                    { *m = SecurityProfileResponseMsg{} }
func (m *SecurityProfileResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponseMsg) ProtoMessage()               {}
func (*SecurityProfileResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{6} }

func (m *SecurityProfileResponseMsg) GetResponse() []*SecurityProfileResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityProfileDeleteRequest is used to delete a SecurityProfile profile
type SecurityProfileDeleteRequest struct {
	// key_or_handle is to identify SecurityProfile being deleted
	KeyOrHandle *SecurityProfileKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityProfileDeleteRequest) Reset()         { *m = SecurityProfileDeleteRequest{} }
func (m *SecurityProfileDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequest) ProtoMessage()    {}
func (*SecurityProfileDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{7}
}

func (m *SecurityProfileDeleteRequest) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityProfileDeleteRequestMsg is used to delete a batch of SecurityProfile profiles
type SecurityProfileDeleteRequestMsg struct {
	Request []*SecurityProfileDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileDeleteRequestMsg) Reset()         { *m = SecurityProfileDeleteRequestMsg{} }
func (m *SecurityProfileDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityProfileDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{8}
}

func (m *SecurityProfileDeleteRequestMsg) GetRequest() []*SecurityProfileDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityProfileResponse is response to SecurityProfileSpec
type SecurityProfileDeleteResponse struct {
	ApiStatus     ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	ProfileStatus *SecurityProfileStatus `protobuf:"bytes,2,opt,name=profile_status,json=profileStatus" json:"profile_status,omitempty"`
}

func (m *SecurityProfileDeleteResponse) Reset()         { *m = SecurityProfileDeleteResponse{} }
func (m *SecurityProfileDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponse) ProtoMessage()    {}
func (*SecurityProfileDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{9}
}

func (m *SecurityProfileDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileDeleteResponse) GetProfileStatus() *SecurityProfileStatus {
	if m != nil {
		return m.ProfileStatus
	}
	return nil
}

// SecurityProfileDeleteResponseMsg is batched response to SecurityProfileDeleteRequestMsg
type SecurityProfileDeleteResponseMsg struct {
	Response []*SecurityProfileDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileDeleteResponseMsg) Reset()         { *m = SecurityProfileDeleteResponseMsg{} }
func (m *SecurityProfileDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityProfileDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{10}
}

func (m *SecurityProfileDeleteResponseMsg) GetResponse() []*SecurityProfileDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityProfileGetRequest is used to get information about a L2 Segment
type SecurityProfileGetRequest struct {
	// key_or_handle is the security profile's identifier for retrieval
	KeyOrHandle *SecurityProfileKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityProfileGetRequest) Reset()                    { *m = SecurityProfileGetRequest{} }
func (m *SecurityProfileGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequest) ProtoMessage()               {}
func (*SecurityProfileGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{11} }

func (m *SecurityProfileGetRequest) GetKeyOrHandle() *SecurityProfileKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityProfileGetRequestMsg is batched GET request for SecurityProfile profiles
type SecurityProfileGetRequestMsg struct {
	Request []*SecurityProfileGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityProfileGetRequestMsg) Reset()         { *m = SecurityProfileGetRequestMsg{} }
func (m *SecurityProfileGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequestMsg) ProtoMessage()    {}
func (*SecurityProfileGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{12}
}

func (m *SecurityProfileGetRequestMsg) GetRequest() []*SecurityProfileGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityProfileStats is the statistics object for each SecurityProfile profile
type SecurityProfileStats struct {
}

func (m *SecurityProfileStats) Reset()                    { *m = SecurityProfileStats{} }
func (m *SecurityProfileStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStats) ProtoMessage()               {}
func (*SecurityProfileStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{13} }

// SecurityProfileGetResponse captures all the information about a SecurityProfile profile
type SecurityProfileGetResponse struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *SecurityProfileSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityProfileStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityProfileStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityProfileGetResponse) Reset()                    { *m = SecurityProfileGetResponse{} }
func (m *SecurityProfileGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponse) ProtoMessage()               {}
func (*SecurityProfileGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{14} }

func (m *SecurityProfileGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileGetResponse) GetSpec() *SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityProfileGetResponse) GetStatus() *SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityProfileGetResponse) GetStats() *SecurityProfileStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityProfileGetResponseMsg is the batched response to SecurityProfileGetRequestMsg
type SecurityProfileGetResponseMsg struct {
	Response []*SecurityProfileGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityProfileGetResponseMsg) Reset()         { *m = SecurityProfileGetResponseMsg{} }
func (m *SecurityProfileGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponseMsg) ProtoMessage()    {}
func (*SecurityProfileGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{15}
}

func (m *SecurityProfileGetResponseMsg) GetResponse() []*SecurityProfileGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Service object identifies an app defined by IP protocol and TCP/UDP port
// in most cases. This object also can specify blanket apps like all TCP or
// UDP traffic, all IP traffic, ICMP type/code combinations etc.
type Service struct {
	IpProtocol IPProtocol `protobuf:"varint,1,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol" json:"ip_protocol,omitempty"`
	// Types that are valid to be assigned to L4Info:
	//	*Service_DstPort
	//	*Service_IcmpMsgType
	L4Info isService_L4Info `protobuf_oneof:"l4_info"`
	Alg    ALGName          `protobuf:"varint,4,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{16} }

type isService_L4Info interface {
	isService_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Service_DstPort struct {
	DstPort uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort,proto3,oneof"`
}
type Service_IcmpMsgType struct {
	IcmpMsgType ICMPMsgType `protobuf:"varint,3,opt,name=icmp_msg_type,json=icmpMsgType,proto3,enum=types.ICMPMsgType,oneof"`
}

func (*Service_DstPort) isService_L4Info()     {}
func (*Service_IcmpMsgType) isService_L4Info() {}

func (m *Service) GetL4Info() isService_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *Service) GetIpProtocol() IPProtocol {
	if m != nil {
		return m.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *Service) GetDstPort() uint32 {
	if x, ok := m.GetL4Info().(*Service_DstPort); ok {
		return x.DstPort
	}
	return 0
}

func (m *Service) GetIcmpMsgType() ICMPMsgType {
	if x, ok := m.GetL4Info().(*Service_IcmpMsgType); ok {
		return x.IcmpMsgType
	}
	return ICMPMsgType_ICMP_MSG_TYPE_NONE
}

func (m *Service) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Service) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Service_OneofMarshaler, _Service_OneofUnmarshaler, _Service_OneofSizer, []interface{}{
		(*Service_DstPort)(nil),
		(*Service_IcmpMsgType)(nil),
	}
}

func _Service_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Service)
	// l4_info
	switch x := m.L4Info.(type) {
	case *Service_DstPort:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DstPort))
	case *Service_IcmpMsgType:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IcmpMsgType))
	case nil:
	default:
		return fmt.Errorf("Service.L4Info has unexpected type %T", x)
	}
	return nil
}

func _Service_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Service)
	switch tag {
	case 2: // l4_info.dst_port
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &Service_DstPort{uint32(x)}
		return true, err
	case 3: // l4_info.icmp_msg_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &Service_IcmpMsgType{ICMPMsgType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Service_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Service)
	// l4_info
	switch x := m.L4Info.(type) {
	case *Service_DstPort:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DstPort))
	case *Service_IcmpMsgType:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IcmpMsgType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FirewallRuleSpec defines a stateful firewall rule that is part of a
// SecurityGroupSpec
type FirewallRuleSpec struct {
	Svc    []*Service     `protobuf:"bytes,2,rep,name=svc" json:"svc,omitempty"`
	Apps   []string       `protobuf:"bytes,3,rep,name=apps" json:"apps,omitempty"`
	Action FirewallAction `protobuf:"varint,4,opt,name=action,proto3,enum=nwsec.FirewallAction" json:"action,omitempty"`
	Log    bool           `protobuf:"varint,5,opt,name=log,proto3" json:"log,omitempty"`
}

func (m *FirewallRuleSpec) Reset()                    { *m = FirewallRuleSpec{} }
func (m *FirewallRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FirewallRuleSpec) ProtoMessage()               {}
func (*FirewallRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{17} }

func (m *FirewallRuleSpec) GetSvc() []*Service {
	if m != nil {
		return m.Svc
	}
	return nil
}

func (m *FirewallRuleSpec) GetApps() []string {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *FirewallRuleSpec) GetAction() FirewallAction {
	if m != nil {
		return m.Action
	}
	return FirewallAction_FIREWALL_ACTION_NONE
}

func (m *FirewallRuleSpec) GetLog() bool {
	if m != nil {
		return m.Log
	}
	return false
}

// ingress policy for the security group
type NetworkSecurityPolicy struct {
	InFwRules []*FirewallRuleSpec `protobuf:"bytes,1,rep,name=in_fw_rules,json=inFwRules" json:"in_fw_rules,omitempty"`
	EgFwRules []*FirewallRuleSpec `protobuf:"bytes,2,rep,name=eg_fw_rules,json=egFwRules" json:"eg_fw_rules,omitempty"`
}

func (m *NetworkSecurityPolicy) Reset()                    { *m = NetworkSecurityPolicy{} }
func (m *NetworkSecurityPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkSecurityPolicy) ProtoMessage()               {}
func (*NetworkSecurityPolicy) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{18} }

func (m *NetworkSecurityPolicy) GetInFwRules() []*FirewallRuleSpec {
	if m != nil {
		return m.InFwRules
	}
	return nil
}

func (m *NetworkSecurityPolicy) GetEgFwRules() []*FirewallRuleSpec {
	if m != nil {
		return m.EgFwRules
	}
	return nil
}

// SecurityGroupPolicySpec captures the policy for a security group pair (aka. group of
// endpoints or enic interfaces) in both directions from workload's perspective.
// This policy will be attached to enic interface or an endpoint so it applies
// to the traffic from/to that workload. If no match is found for the new
// session in the slow path, either a drop flow will be installed or packet will
// be dropped without creating drop flow
type SecurityGroupPolicySpec struct {
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	PolicyRules *NetworkSecurityPolicy        `protobuf:"bytes,2,opt,name=policy_rules,json=policyRules" json:"policy_rules,omitempty"`
}

func (m *SecurityGroupPolicySpec) Reset()                    { *m = SecurityGroupPolicySpec{} }
func (m *SecurityGroupPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicySpec) ProtoMessage()               {}
func (*SecurityGroupPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{19} }

func (m *SecurityGroupPolicySpec) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityGroupPolicySpec) GetPolicyRules() *NetworkSecurityPolicy {
	if m != nil {
		return m.PolicyRules
	}
	return nil
}

// SecurityGroupPolicyRequestMsg is batched add or modify security group policy request
type SecurityGroupPolicyRequestMsg struct {
	Request []*SecurityGroupPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyRequestMsg) Reset()         { *m = SecurityGroupPolicyRequestMsg{} }
func (m *SecurityGroupPolicyRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{20}
}

func (m *SecurityGroupPolicyRequestMsg) GetRequest() []*SecurityGroupPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security group operational status
type SecurityGroupPolicyStatus struct {
	PolicyHandle uint64 `protobuf:"fixed64,1,opt,name=policy_handle,json=policyHandle,proto3" json:"policy_handle,omitempty"`
}

func (m *SecurityGroupPolicyStatus) Reset()                    { *m = SecurityGroupPolicyStatus{} }
func (m *SecurityGroupPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyStatus) ProtoMessage()               {}
func (*SecurityGroupPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{21} }

func (m *SecurityGroupPolicyStatus) GetPolicyHandle() uint64 {
	if m != nil {
		return m.PolicyHandle
	}
	return 0
}

// SecurityGroupResponse is the response to SecurityGroupPolicySpec
type SecurityGroupPolicyResponse struct {
	ApiStatus ApiStatus                  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *SecurityGroupPolicyStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityGroupPolicyResponse) Reset()         { *m = SecurityGroupPolicyResponse{} }
func (m *SecurityGroupPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{22}
}

func (m *SecurityGroupPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupPolicyResponse) GetStatus() *SecurityGroupPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SecurityGroupResponseMsg is batched response to SecurityGroupPolicyRequestMsg
type SecurityGroupPolicyResponseMsg struct {
	Response []*SecurityGroupPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupPolicyResponseMsg) Reset()         { *m = SecurityGroupPolicyResponseMsg{} }
func (m *SecurityGroupPolicyResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{23}
}

func (m *SecurityGroupPolicyResponseMsg) GetResponse() []*SecurityGroupPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupPolicyDeleteRequest is used to delete a security group policy
type SecurityGroupPolicyDeleteRequest struct {
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupPolicyDeleteRequest) Reset()         { *m = SecurityGroupPolicyDeleteRequest{} }
func (m *SecurityGroupPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{24}
}

func (m *SecurityGroupPolicyDeleteRequest) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupDeleteRequestMsg is used to delete a batch of security group policies.
type SecurityGroupPolicyDeleteRequestMsg struct {
	Request []*SecurityGroupPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Reset()         { *m = SecurityGroupPolicyDeleteRequestMsg{} }
func (m *SecurityGroupPolicyDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{25}
}

func (m *SecurityGroupPolicyDeleteRequestMsg) GetRequest() []*SecurityGroupPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityGroupPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *SecurityGroupPolicyDeleteResponse) Reset()         { *m = SecurityGroupPolicyDeleteResponse{} }
func (m *SecurityGroupPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{26}
}

func (m *SecurityGroupPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// SecurityGroupPolicyDeleteResponseMsg is batched response to
// SecurityGroupPolicyDeleteRequestMsg
type SecurityGroupPolicyDeleteResponseMsg struct {
	Response []*SecurityGroupPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Reset()         { *m = SecurityGroupPolicyDeleteResponseMsg{} }
func (m *SecurityGroupPolicyDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{27}
}

func (m *SecurityGroupPolicyDeleteResponseMsg) GetResponse() []*SecurityGroupPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupPolicyGetRequest is used to get information about a security group policy
type SecurityGroupPolicyGetRequest struct {
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupPolicyGetRequest) Reset()         { *m = SecurityGroupPolicyGetRequest{} }
func (m *SecurityGroupPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetRequest) ProtoMessage()    {}
func (*SecurityGroupPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{28}
}

func (m *SecurityGroupPolicyGetRequest) GetKeyOrHandle() *SecurityGroupPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupGetRequestMsg is batched GET request for security group policies
type SecurityGroupPolicyGetRequestMsg struct {
	Request []*SecurityGroupPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupPolicyGetRequestMsg) Reset()         { *m = SecurityGroupPolicyGetRequestMsg{} }
func (m *SecurityGroupPolicyGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetRequestMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{29}
}

func (m *SecurityGroupPolicyGetRequestMsg) GetRequest() []*SecurityGroupPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupStats is the statistics object for a security group
type SecurityGroupPolicyStats struct {
}

func (m *SecurityGroupPolicyStats) Reset()                    { *m = SecurityGroupPolicyStats{} }
func (m *SecurityGroupPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyStats) ProtoMessage()               {}
func (*SecurityGroupPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{30} }

// SecurityGroupGetResponse captures all the information about a security group
type SecurityGroupPolicyGetResponse struct {
	ApiStatus ApiStatus                  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *SecurityGroupPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityGroupPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityGroupPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityGroupPolicyGetResponse) Reset()         { *m = SecurityGroupPolicyGetResponse{} }
func (m *SecurityGroupPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetResponse) ProtoMessage()    {}
func (*SecurityGroupPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{31}
}

func (m *SecurityGroupPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupPolicyGetResponse) GetSpec() *SecurityGroupPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponse) GetStatus() *SecurityGroupPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponse) GetStats() *SecurityGroupPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityGroupPolicyGetResponseMsg is batched response to SecurityGroupGetRequestMsg
type SecurityGroupPolicyGetResponseMsg struct {
	Response  []*SecurityGroupPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	ApiStatus ApiStatus                         `protobuf:"varint,2,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SecurityGroupPolicyGetResponseMsg) Reset()         { *m = SecurityGroupPolicyGetResponseMsg{} }
func (m *SecurityGroupPolicyGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupPolicyGetResponseMsg) ProtoMessage()    {}
func (*SecurityGroupPolicyGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{32}
}

func (m *SecurityGroupPolicyGetResponseMsg) GetResponse() []*SecurityGroupPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SecurityGroupPolicyGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type SecurityGroupSpec struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupSpec) Reset()                    { *m = SecurityGroupSpec{} }
func (m *SecurityGroupSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupSpec) ProtoMessage()               {}
func (*SecurityGroupSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{33} }

func (m *SecurityGroupSpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupSpec) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupRequestMsg is batched add or modify security group policy request
type SecurityGroupRequestMsg struct {
	Request []*SecurityGroupSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupRequestMsg) Reset()                    { *m = SecurityGroupRequestMsg{} }
func (m *SecurityGroupRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupRequestMsg) ProtoMessage()               {}
func (*SecurityGroupRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{34} }

func (m *SecurityGroupRequestMsg) GetRequest() []*SecurityGroupSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security group operational status
type SecurityGroupStatus struct {
	Meta        *delphi.ObjectMeta      `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupStatus) Reset()                    { *m = SecurityGroupStatus{} }
func (m *SecurityGroupStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupStatus) ProtoMessage()               {}
func (*SecurityGroupStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{35} }

func (m *SecurityGroupStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityGroupStatus) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupResponse is the response to SecurityGroupSpec
type SecurityGroupResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *SecurityGroupStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityGroupResponse) Reset()                    { *m = SecurityGroupResponse{} }
func (m *SecurityGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupResponse) ProtoMessage()               {}
func (*SecurityGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{36} }

func (m *SecurityGroupResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupResponse) GetStatus() *SecurityGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SecurityGroupResponseMsg is batched response to SecurityGroupRequestMsg
type SecurityGroupResponseMsg struct {
	Response []*SecurityGroupResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityGroupResponseMsg) Reset()                    { *m = SecurityGroupResponseMsg{} }
func (m *SecurityGroupResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupResponseMsg) ProtoMessage()               {}
func (*SecurityGroupResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{37} }

func (m *SecurityGroupResponseMsg) GetResponse() []*SecurityGroupResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityGroupDeleteRequest is used to delete a security group
type SecurityGroupDeleteRequest struct {
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupDeleteRequest) Reset()                    { *m = SecurityGroupDeleteRequest{} }
func (m *SecurityGroupDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteRequest) ProtoMessage()               {}
func (*SecurityGroupDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{38} }

func (m *SecurityGroupDeleteRequest) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupDeleteRequestMsg is used to delete a batch of security groups
type SecurityGroupDeleteRequestMsg struct {
	Request []*SecurityGroupDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupDeleteRequestMsg) Reset()         { *m = SecurityGroupDeleteRequestMsg{} }
func (m *SecurityGroupDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityGroupDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{39}
}

func (m *SecurityGroupDeleteRequestMsg) GetRequest() []*SecurityGroupDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupDeleteResponseMsg is batched response to
// SecurityGroupDeleteRequestMsg
type SecurityGroupDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *SecurityGroupDeleteResponseMsg) Reset()         { *m = SecurityGroupDeleteResponseMsg{} }
func (m *SecurityGroupDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityGroupDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{40}
}

func (m *SecurityGroupDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// SecurityGroupGetRequest is used to get information about a security group
type SecurityGroupGetRequest struct {
	// key_or_handle is the security group's unique identifier
	KeyOrHandle *SecurityGroupKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityGroupGetRequest) Reset()                    { *m = SecurityGroupGetRequest{} }
func (m *SecurityGroupGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetRequest) ProtoMessage()               {}
func (*SecurityGroupGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{41} }

func (m *SecurityGroupGetRequest) GetKeyOrHandle() *SecurityGroupKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityGroupGetRequestMsg is batched GET request for security groups
type SecurityGroupGetRequestMsg struct {
	Request []*SecurityGroupGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityGroupGetRequestMsg) Reset()                    { *m = SecurityGroupGetRequestMsg{} }
func (m *SecurityGroupGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetRequestMsg) ProtoMessage()               {}
func (*SecurityGroupGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{42} }

func (m *SecurityGroupGetRequestMsg) GetRequest() []*SecurityGroupGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityGroupStats is the statistics object for a security group
type SecurityGroupStats struct {
}

func (m *SecurityGroupStats) Reset()                    { *m = SecurityGroupStats{} }
func (m *SecurityGroupStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupStats) ProtoMessage()               {}
func (*SecurityGroupStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{43} }

// SecurityGroupGetResponse captures all the information about a security group
type SecurityGroupGetResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *SecurityGroupSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityGroupStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *SecurityGroupStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *SecurityGroupGetResponse) Reset()                    { *m = SecurityGroupGetResponse{} }
func (m *SecurityGroupGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupGetResponse) ProtoMessage()               {}
func (*SecurityGroupGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{44} }

func (m *SecurityGroupGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityGroupGetResponse) GetSpec() *SecurityGroupSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityGroupGetResponse) GetStatus() *SecurityGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityGroupGetResponse) GetStats() *SecurityGroupStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// SecurityGroupGetResponseMsg is batched response to SecurityGroupGetRequestMsg
type SecurityGroupGetResponseMsg struct {
	Response  []*SecurityGroupGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	ApiStatus ApiStatus                   `protobuf:"varint,2,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SecurityGroupGetResponseMsg) Reset()         { *m = SecurityGroupGetResponseMsg{} }
func (m *SecurityGroupGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityGroupGetResponseMsg) ProtoMessage()    {}
func (*SecurityGroupGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{45}
}

func (m *SecurityGroupGetResponseMsg) GetResponse() []*SecurityGroupGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SecurityGroupGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// AppData- identifies app data specific to security plugin
type AppData struct {
	Alg ALGName `protobuf:"varint,1,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
	// Types that are valid to be assigned to AppOptions:
	//	*AppData_FtpOptionInfo
	//	*AppData_DnsOptionInfo
	//	*AppData_MsrpcOptionInfo
	//	*AppData_SunRpcOptionInfo
	//	*AppData_SipOptions
	AppOptions  isAppData_AppOptions  `protobuf_oneof:"AppOptions"`
	IdleTimeout uint32                `protobuf:"varint,7,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	TraceOpts   *AppData_TraceOptions `protobuf:"bytes,8,opt,name=trace_opts,json=traceOpts" json:"trace_opts,omitempty"`
}

func (m *AppData) Reset()                    { *m = AppData{} }
func (m *AppData) String() string            { return proto.CompactTextString(m) }
func (*AppData) ProtoMessage()               {}
func (*AppData) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46} }

type isAppData_AppOptions interface {
	isAppData_AppOptions()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppData_FtpOptionInfo struct {
	FtpOptionInfo *AppData_FTPOptions `protobuf:"bytes,2,opt,name=ftp_option_info,json=ftpOptionInfo,oneof"`
}
type AppData_DnsOptionInfo struct {
	DnsOptionInfo *AppData_DNSOptions `protobuf:"bytes,3,opt,name=dns_option_info,json=dnsOptionInfo,oneof"`
}
type AppData_MsrpcOptionInfo struct {
	MsrpcOptionInfo *AppData_MSRPCOptions `protobuf:"bytes,4,opt,name=msrpc_option_info,json=msrpcOptionInfo,oneof"`
}
type AppData_SunRpcOptionInfo struct {
	SunRpcOptionInfo *AppData_SunRPCOptions `protobuf:"bytes,5,opt,name=sun_rpc_option_info,json=sunRpcOptionInfo,oneof"`
}
type AppData_SipOptions struct {
	SipOptions *AppData_SIPOptions `protobuf:"bytes,6,opt,name=sip_options,json=sipOptions,oneof"`
}

func (*AppData_FtpOptionInfo) isAppData_AppOptions()    {}
func (*AppData_DnsOptionInfo) isAppData_AppOptions()    {}
func (*AppData_MsrpcOptionInfo) isAppData_AppOptions()  {}
func (*AppData_SunRpcOptionInfo) isAppData_AppOptions() {}
func (*AppData_SipOptions) isAppData_AppOptions()       {}

func (m *AppData) GetAppOptions() isAppData_AppOptions {
	if m != nil {
		return m.AppOptions
	}
	return nil
}

func (m *AppData) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

func (m *AppData) GetFtpOptionInfo() *AppData_FTPOptions {
	if x, ok := m.GetAppOptions().(*AppData_FtpOptionInfo); ok {
		return x.FtpOptionInfo
	}
	return nil
}

func (m *AppData) GetDnsOptionInfo() *AppData_DNSOptions {
	if x, ok := m.GetAppOptions().(*AppData_DnsOptionInfo); ok {
		return x.DnsOptionInfo
	}
	return nil
}

func (m *AppData) GetMsrpcOptionInfo() *AppData_MSRPCOptions {
	if x, ok := m.GetAppOptions().(*AppData_MsrpcOptionInfo); ok {
		return x.MsrpcOptionInfo
	}
	return nil
}

func (m *AppData) GetSunRpcOptionInfo() *AppData_SunRPCOptions {
	if x, ok := m.GetAppOptions().(*AppData_SunRpcOptionInfo); ok {
		return x.SunRpcOptionInfo
	}
	return nil
}

func (m *AppData) GetSipOptions() *AppData_SIPOptions {
	if x, ok := m.GetAppOptions().(*AppData_SipOptions); ok {
		return x.SipOptions
	}
	return nil
}

func (m *AppData) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *AppData) GetTraceOpts() *AppData_TraceOptions {
	if m != nil {
		return m.TraceOpts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AppData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AppData_OneofMarshaler, _AppData_OneofUnmarshaler, _AppData_OneofSizer, []interface{}{
		(*AppData_FtpOptionInfo)(nil),
		(*AppData_DnsOptionInfo)(nil),
		(*AppData_MsrpcOptionInfo)(nil),
		(*AppData_SunRpcOptionInfo)(nil),
		(*AppData_SipOptions)(nil),
	}
}

func _AppData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AppData)
	// AppOptions
	switch x := m.AppOptions.(type) {
	case *AppData_FtpOptionInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FtpOptionInfo); err != nil {
			return err
		}
	case *AppData_DnsOptionInfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsOptionInfo); err != nil {
			return err
		}
	case *AppData_MsrpcOptionInfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MsrpcOptionInfo); err != nil {
			return err
		}
	case *AppData_SunRpcOptionInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SunRpcOptionInfo); err != nil {
			return err
		}
	case *AppData_SipOptions:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SipOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AppData.AppOptions has unexpected type %T", x)
	}
	return nil
}

func _AppData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AppData)
	switch tag {
	case 2: // AppOptions.ftp_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppData_FTPOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &AppData_FtpOptionInfo{msg}
		return true, err
	case 3: // AppOptions.dns_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppData_DNSOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &AppData_DnsOptionInfo{msg}
		return true, err
	case 4: // AppOptions.msrpc_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppData_MSRPCOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &AppData_MsrpcOptionInfo{msg}
		return true, err
	case 5: // AppOptions.sun_rpc_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppData_SunRPCOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &AppData_SunRpcOptionInfo{msg}
		return true, err
	case 6: // AppOptions.sip_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppData_SIPOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &AppData_SipOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AppData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AppData)
	// AppOptions
	switch x := m.AppOptions.(type) {
	case *AppData_FtpOptionInfo:
		s := proto.Size(x.FtpOptionInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AppData_DnsOptionInfo:
		s := proto.Size(x.DnsOptionInfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AppData_MsrpcOptionInfo:
		s := proto.Size(x.MsrpcOptionInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AppData_SunRpcOptionInfo:
		s := proto.Size(x.SunRpcOptionInfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AppData_SipOptions:
		s := proto.Size(x.SipOptions)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AppData_TraceOptions struct {
	Level AppData_TraceLevel `protobuf:"varint,1,opt,name=level,proto3,enum=nwsec.AppData_TraceLevel" json:"level,omitempty"`
}

func (m *AppData_TraceOptions) Reset()                    { *m = AppData_TraceOptions{} }
func (m *AppData_TraceOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_TraceOptions) ProtoMessage()               {}
func (*AppData_TraceOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 0} }

func (m *AppData_TraceOptions) GetLevel() AppData_TraceLevel {
	if m != nil {
		return m.Level
	}
	return AppData_TRACE_LEVEL_NONE
}

type AppData_FTPOptions struct {
	AllowMismatchIpAddress bool `protobuf:"varint,1,opt,name=allow_mismatch_ip_address,json=allowMismatchIpAddress,proto3" json:"allow_mismatch_ip_address,omitempty"`
}

func (m *AppData_FTPOptions) Reset()                    { *m = AppData_FTPOptions{} }
func (m *AppData_FTPOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_FTPOptions) ProtoMessage()               {}
func (*AppData_FTPOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 1} }

func (m *AppData_FTPOptions) GetAllowMismatchIpAddress() bool {
	if m != nil {
		return m.AllowMismatchIpAddress
	}
	return false
}

type AppData_DNSOptions struct {
	DropMultiQuestionPackets   bool   `protobuf:"varint,1,opt,name=drop_multi_question_packets,json=dropMultiQuestionPackets,proto3" json:"drop_multi_question_packets,omitempty"`
	DropLargeDomainNamePackets bool   `protobuf:"varint,2,opt,name=drop_large_domain_name_packets,json=dropLargeDomainNamePackets,proto3" json:"drop_large_domain_name_packets,omitempty"`
	DropLongLabelPackets       bool   `protobuf:"varint,3,opt,name=drop_long_label_packets,json=dropLongLabelPackets,proto3" json:"drop_long_label_packets,omitempty"`
	DropMultizonePackets       bool   `protobuf:"varint,4,opt,name=drop_multizone_packets,json=dropMultizonePackets,proto3" json:"drop_multizone_packets,omitempty"`
	MaxMsgLength               uint32 `protobuf:"varint,5,opt,name=max_msg_length,json=maxMsgLength,proto3" json:"max_msg_length,omitempty"`
	QueryResponseTimeout       uint32 `protobuf:"varint,6,opt,name=query_response_timeout,json=queryResponseTimeout,proto3" json:"query_response_timeout,omitempty"`
}

func (m *AppData_DNSOptions) Reset()                    { *m = AppData_DNSOptions{} }
func (m *AppData_DNSOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_DNSOptions) ProtoMessage()               {}
func (*AppData_DNSOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 2} }

func (m *AppData_DNSOptions) GetDropMultiQuestionPackets() bool {
	if m != nil {
		return m.DropMultiQuestionPackets
	}
	return false
}

func (m *AppData_DNSOptions) GetDropLargeDomainNamePackets() bool {
	if m != nil {
		return m.DropLargeDomainNamePackets
	}
	return false
}

func (m *AppData_DNSOptions) GetDropLongLabelPackets() bool {
	if m != nil {
		return m.DropLongLabelPackets
	}
	return false
}

func (m *AppData_DNSOptions) GetDropMultizonePackets() bool {
	if m != nil {
		return m.DropMultizonePackets
	}
	return false
}

func (m *AppData_DNSOptions) GetMaxMsgLength() uint32 {
	if m != nil {
		return m.MaxMsgLength
	}
	return 0
}

func (m *AppData_DNSOptions) GetQueryResponseTimeout() uint32 {
	if m != nil {
		return m.QueryResponseTimeout
	}
	return 0
}

type AppData_RPCData struct {
	ProgramId   string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
	IdleTimeout uint32 `protobuf:"varint,2,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
}

func (m *AppData_RPCData) Reset()                    { *m = AppData_RPCData{} }
func (m *AppData_RPCData) String() string            { return proto.CompactTextString(m) }
func (*AppData_RPCData) ProtoMessage()               {}
func (*AppData_RPCData) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 3} }

func (m *AppData_RPCData) GetProgramId() string {
	if m != nil {
		return m.ProgramId
	}
	return ""
}

func (m *AppData_RPCData) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

type AppData_MSRPCOptions struct {
	Data []*AppData_RPCData `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *AppData_MSRPCOptions) Reset()                    { *m = AppData_MSRPCOptions{} }
func (m *AppData_MSRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_MSRPCOptions) ProtoMessage()               {}
func (*AppData_MSRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 4} }

func (m *AppData_MSRPCOptions) GetData() []*AppData_RPCData {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppData_SunRPCOptions struct {
	Data []*AppData_RPCData `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *AppData_SunRPCOptions) Reset()                    { *m = AppData_SunRPCOptions{} }
func (m *AppData_SunRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_SunRPCOptions) ProtoMessage()               {}
func (*AppData_SunRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 5} }

func (m *AppData_SunRPCOptions) GetData() []*AppData_RPCData {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppData_SIPOptions struct {
	Ctimeout               uint32 `protobuf:"varint,1,opt,name=ctimeout,proto3" json:"ctimeout,omitempty"`
	DscpCodePoint          uint32 `protobuf:"varint,2,opt,name=dscp_code_point,json=dscpCodePoint,proto3" json:"dscp_code_point,omitempty"`
	MediaInactivityTimeout uint32 `protobuf:"varint,3,opt,name=media_inactivity_timeout,json=mediaInactivityTimeout,proto3" json:"media_inactivity_timeout,omitempty"`
	MaxCallDuration        uint32 `protobuf:"varint,4,opt,name=max_call_duration,json=maxCallDuration,proto3" json:"max_call_duration,omitempty"`
	T1TimerValue           uint32 `protobuf:"varint,5,opt,name=t1_timer_value,json=t1TimerValue,proto3" json:"t1_timer_value,omitempty"`
	T4TimerValue           uint32 `protobuf:"varint,6,opt,name=t4_timer_value,json=t4TimerValue,proto3" json:"t4_timer_value,omitempty"`
}

func (m *AppData_SIPOptions) Reset()                    { *m = AppData_SIPOptions{} }
func (m *AppData_SIPOptions) String() string            { return proto.CompactTextString(m) }
func (*AppData_SIPOptions) ProtoMessage()               {}
func (*AppData_SIPOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{46, 6} }

func (m *AppData_SIPOptions) GetCtimeout() uint32 {
	if m != nil {
		return m.Ctimeout
	}
	return 0
}

func (m *AppData_SIPOptions) GetDscpCodePoint() uint32 {
	if m != nil {
		return m.DscpCodePoint
	}
	return 0
}

func (m *AppData_SIPOptions) GetMediaInactivityTimeout() uint32 {
	if m != nil {
		return m.MediaInactivityTimeout
	}
	return 0
}

func (m *AppData_SIPOptions) GetMaxCallDuration() uint32 {
	if m != nil {
		return m.MaxCallDuration
	}
	return 0
}

func (m *AppData_SIPOptions) GetT1TimerValue() uint32 {
	if m != nil {
		return m.T1TimerValue
	}
	return 0
}

func (m *AppData_SIPOptions) GetT4TimerValue() uint32 {
	if m != nil {
		return m.T4TimerValue
	}
	return 0
}

type SecurityRuleAction struct {
	SecAction SecurityAction `protobuf:"varint,1,opt,name=sec_action,json=secAction,proto3,enum=nwsec.SecurityAction" json:"sec_action,omitempty"`
	LogAction LogAction      `protobuf:"varint,2,opt,name=log_action,json=logAction,proto3,enum=nwsec.LogAction" json:"log_action,omitempty"`
	AppData   *AppData       `protobuf:"bytes,3,opt,name=app_data,json=appData" json:"app_data,omitempty"`
}

func (m *SecurityRuleAction) Reset()                    { *m = SecurityRuleAction{} }
func (m *SecurityRuleAction) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleAction) ProtoMessage()               {}
func (*SecurityRuleAction) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{47} }

func (m *SecurityRuleAction) GetSecAction() SecurityAction {
	if m != nil {
		return m.SecAction
	}
	return SecurityAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityRuleAction) GetLogAction() LogAction {
	if m != nil {
		return m.LogAction
	}
	return LogAction_LOG_NONE
}

func (m *SecurityRuleAction) GetAppData() *AppData {
	if m != nil {
		return m.AppData
	}
	return nil
}

type SecurityRule struct {
	RuleId uint64              `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty" venice:mandatory`
	Match  *RuleMatch          `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
	Action *SecurityRuleAction `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	Appid  []string            `protobuf:"bytes,4,rep,name=appid" json:"appid,omitempty"`
}

func (m *SecurityRule) Reset()                    { *m = SecurityRule{} }
func (m *SecurityRule) String() string            { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()               {}
func (*SecurityRule) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{48} }

func (m *SecurityRule) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *SecurityRule) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *SecurityRule) GetAction() *SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *SecurityRule) GetAppid() []string {
	if m != nil {
		return m.Appid
	}
	return nil
}

// SecurityPolicySpec that contains set of SecurityRules
type SecurityPolicySpec struct {
	Meta        *delphi.ObjectMeta       `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle *SecurityPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Rule        []*SecurityRule          `protobuf:"bytes,3,rep,name=rule" json:"rule,omitempty"`
}

func (m *SecurityPolicySpec) Reset()                    { *m = SecurityPolicySpec{} }
func (m *SecurityPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicySpec) ProtoMessage()               {}
func (*SecurityPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{49} }

func (m *SecurityPolicySpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityPolicySpec) GetKeyOrHandle() *SecurityPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityPolicySpec) GetRule() []*SecurityRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

// SecurityPolicyRequestMsg is batched add or modify security policy request
type SecurityPolicyRequestMsg struct {
	Request []*SecurityPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityPolicyRequestMsg) Reset()                    { *m = SecurityPolicyRequestMsg{} }
func (m *SecurityPolicyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyRequestMsg) ProtoMessage()               {}
func (*SecurityPolicyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{50} }

func (m *SecurityPolicyRequestMsg) GetRequest() []*SecurityPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityRuleStatus struct {
	RuleId   uint64 `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Priority uint64 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *SecurityRuleStatus) Reset()                    { *m = SecurityRuleStatus{} }
func (m *SecurityRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStatus) ProtoMessage()               {}
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{51} }

func (m *SecurityRuleStatus) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *SecurityRuleStatus) GetPriority() uint64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

type SecurityPolicyStatus struct {
	Meta        *delphi.ObjectMeta       `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle *SecurityPolicyKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	RuleStatus  []*SecurityRuleStatus    `protobuf:"bytes,3,rep,name=rule_status,json=ruleStatus" json:"rule_status,omitempty"`
}

func (m *SecurityPolicyStatus) Reset()                    { *m = SecurityPolicyStatus{} }
func (m *SecurityPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStatus) ProtoMessage()               {}
func (*SecurityPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{52} }

func (m *SecurityPolicyStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityPolicyStatus) GetKeyOrHandle() *SecurityPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *SecurityPolicyStatus) GetRuleStatus() []*SecurityRuleStatus {
	if m != nil {
		return m.RuleStatus
	}
	return nil
}

// SecurityPolicyResponse is the response to SecurityPolicyRequest
type SecurityPolicyResponse struct {
	ApiStatus    ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	PolicyStatus *SecurityPolicyStatus `protobuf:"bytes,2,opt,name=policy_status,json=policyStatus" json:"policy_status,omitempty"`
}

func (m *SecurityPolicyResponse) Reset()                    { *m = SecurityPolicyResponse{} }
func (m *SecurityPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyResponse) ProtoMessage()               {}
func (*SecurityPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{53} }

func (m *SecurityPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyResponse) GetPolicyStatus() *SecurityPolicyStatus {
	if m != nil {
		return m.PolicyStatus
	}
	return nil
}

type SecurityPolicyResponseMsg struct {
	Response []*SecurityPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityPolicyResponseMsg) Reset()                    { *m = SecurityPolicyResponseMsg{} }
func (m *SecurityPolicyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyResponseMsg) ProtoMessage()               {}
func (*SecurityPolicyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{54} }

func (m *SecurityPolicyResponseMsg) GetResponse() []*SecurityPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityPolicyDeleteRequest is used to delete a security rule
type SecurityPolicyDeleteRequest struct {
	KeyOrHandle *SecurityPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityPolicyDeleteRequest) Reset()         { *m = SecurityPolicyDeleteRequest{} }
func (m *SecurityPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{55}
}

func (m *SecurityPolicyDeleteRequest) GetKeyOrHandle() *SecurityPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityPolicyDeleteRequestMsg is used to delete a batch of security policy
type SecurityPolicyDeleteRequestMsg struct {
	Request []*SecurityPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityPolicyDeleteRequestMsg) Reset()         { *m = SecurityPolicyDeleteRequestMsg{} }
func (m *SecurityPolicyDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{56}
}

func (m *SecurityPolicyDeleteRequestMsg) GetRequest() []*SecurityPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *SecurityPolicyDeleteResponse) Reset()         { *m = SecurityPolicyDeleteResponse{} }
func (m *SecurityPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{57}
}

func (m *SecurityPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// SecurityPolicyDeleteResponseMsg is batched response to SecurityPolicyDeleteRequestMsg
type SecurityPolicyDeleteResponseMsg struct {
	Response []*SecurityPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityPolicyDeleteResponseMsg) Reset()         { *m = SecurityPolicyDeleteResponseMsg{} }
func (m *SecurityPolicyDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{58}
}

func (m *SecurityPolicyDeleteResponseMsg) GetResponse() []*SecurityPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityPolicyGet is used to get information about a security policy
type SecurityPolicyGetRequest struct {
	// key_or_handle is the security policy's unique identifier
	KeyOrHandle *SecurityPolicyKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *SecurityPolicyGetRequest) Reset()                    { *m = SecurityPolicyGetRequest{} }
func (m *SecurityPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetRequest) ProtoMessage()               {}
func (*SecurityPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{59} }

func (m *SecurityPolicyGetRequest) GetKeyOrHandle() *SecurityPolicyKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityPolicyGetRequestMsg is batched GET request for security policy
type SecurityPolicyGetRequestMsg struct {
	Request []*SecurityPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityPolicyGetRequestMsg) Reset()         { *m = SecurityPolicyGetRequestMsg{} }
func (m *SecurityPolicyGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyGetRequestMsg) ProtoMessage()    {}
func (*SecurityPolicyGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{60}
}

func (m *SecurityPolicyGetRequestMsg) GetRequest() []*SecurityPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityRuleStats
type SecurityRuleStats struct {
	RuleId      uint64 `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	NumHits     uint64 `protobuf:"fixed64,2,opt,name=num_hits,json=numHits,proto3" json:"num_hits,omitempty"`
	NumTcpHits  uint64 `protobuf:"fixed64,3,opt,name=num_tcp_hits,json=numTcpHits,proto3" json:"num_tcp_hits,omitempty"`
	NumUdpHits  uint64 `protobuf:"fixed64,4,opt,name=num_udp_hits,json=numUdpHits,proto3" json:"num_udp_hits,omitempty"`
	NumIcmpHits uint64 `protobuf:"fixed64,5,opt,name=num_icmp_hits,json=numIcmpHits,proto3" json:"num_icmp_hits,omitempty"`
}

func (m *SecurityRuleStats) Reset()                    { *m = SecurityRuleStats{} }
func (m *SecurityRuleStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStats) ProtoMessage()               {}
func (*SecurityRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{61} }

func (m *SecurityRuleStats) GetRuleId() uint64 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *SecurityRuleStats) GetNumHits() uint64 {
	if m != nil {
		return m.NumHits
	}
	return 0
}

func (m *SecurityRuleStats) GetNumTcpHits() uint64 {
	if m != nil {
		return m.NumTcpHits
	}
	return 0
}

func (m *SecurityRuleStats) GetNumUdpHits() uint64 {
	if m != nil {
		return m.NumUdpHits
	}
	return 0
}

func (m *SecurityRuleStats) GetNumIcmpHits() uint64 {
	if m != nil {
		return m.NumIcmpHits
	}
	return 0
}

// SecurityPolicyStats
type SecurityPolicyStats struct {
	RuleStats []*SecurityRuleStats `protobuf:"bytes,1,rep,name=rule_stats,json=ruleStats" json:"rule_stats,omitempty"`
}

func (m *SecurityPolicyStats) Reset()                    { *m = SecurityPolicyStats{} }
func (m *SecurityPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStats) ProtoMessage()               {}
func (*SecurityPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{62} }

func (m *SecurityPolicyStats) GetRuleStats() []*SecurityRuleStats {
	if m != nil {
		return m.RuleStats
	}
	return nil
}

// only if api_status indicates success, other fields are valid
type SecurityPolicyGetResponse struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *SecurityPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	PolStats  *SecurityPolicyStats  `protobuf:"bytes,4,opt,name=pol_stats,json=polStats" json:"pol_stats,omitempty"`
}

func (m *SecurityPolicyGetResponse) Reset()                    { *m = SecurityPolicyGetResponse{} }
func (m *SecurityPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetResponse) ProtoMessage()               {}
func (*SecurityPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{63} }

func (m *SecurityPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyGetResponse) GetSpec() *SecurityPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityPolicyGetResponse) GetStatus() *SecurityPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityPolicyGetResponse) GetPolStats() *SecurityPolicyStats {
	if m != nil {
		return m.PolStats
	}
	return nil
}

// SecurityPolicyGetResponse Msg is batched response to SecurityPolicyGetRequestMsg
type SecurityPolicyGetResponseMsg struct {
	Response []*SecurityPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityPolicyGetResponseMsg) Reset()         { *m = SecurityPolicyGetResponseMsg{} }
func (m *SecurityPolicyGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyGetResponseMsg) ProtoMessage()    {}
func (*SecurityPolicyGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{64}
}

func (m *SecurityPolicyGetResponseMsg) GetResponse() []*SecurityPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type SecurityFlowGateFilter struct {
	SrcIp   *IPAddress `protobuf:"bytes,1,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp   *IPAddress `protobuf:"bytes,2,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	SrcPort uint32     `protobuf:"varint,3,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort uint32     `protobuf:"varint,4,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	IpProto IPProtocol `protobuf:"varint,5,opt,name=ip_proto,json=ipProto,proto3,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	VrfId   uint64     `protobuf:"fixed64,6,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
	Alg     ALGName    `protobuf:"varint,7,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
}

func (m *SecurityFlowGateFilter) Reset()                    { *m = SecurityFlowGateFilter{} }
func (m *SecurityFlowGateFilter) String() string            { return proto.CompactTextString(m) }
func (*SecurityFlowGateFilter) ProtoMessage()               {}
func (*SecurityFlowGateFilter) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{65} }

func (m *SecurityFlowGateFilter) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *SecurityFlowGateFilter) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *SecurityFlowGateFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SecurityFlowGateFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SecurityFlowGateFilter) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *SecurityFlowGateFilter) GetVrfId() uint64 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

func (m *SecurityFlowGateFilter) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

type SecurityFlowGateGetRequest struct {
	Filter *SecurityFlowGateFilter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
}

func (m *SecurityFlowGateGetRequest) Reset()                    { *m = SecurityFlowGateGetRequest{} }
func (m *SecurityFlowGateGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityFlowGateGetRequest) ProtoMessage()               {}
func (*SecurityFlowGateGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{66} }

func (m *SecurityFlowGateGetRequest) GetFilter() *SecurityFlowGateFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type SecurityFlowGateGetRequestMsg struct {
	Request []*SecurityFlowGateGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityFlowGateGetRequestMsg) Reset()         { *m = SecurityFlowGateGetRequestMsg{} }
func (m *SecurityFlowGateGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateGetRequestMsg) ProtoMessage()    {}
func (*SecurityFlowGateGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{67}
}

func (m *SecurityFlowGateGetRequestMsg) GetRequest() []*SecurityFlowGateGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type FlowGateKey struct {
	Direction FlowDirection `protobuf:"varint,1,opt,name=direction,proto3,enum=types.FlowDirection" json:"direction,omitempty"`
	SrcVrfId  uint64        `protobuf:"fixed64,2,opt,name=src_vrf_id,json=srcVrfId,proto3" json:"src_vrf_id,omitempty"`
	DstVrfId  uint64        `protobuf:"fixed64,3,opt,name=dst_vrf_id,json=dstVrfId,proto3" json:"dst_vrf_id,omitempty"`
	SrcIp     *IPAddress    `protobuf:"bytes,4,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp     *IPAddress    `protobuf:"bytes,5,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	IpProto   IPProtocol    `protobuf:"varint,6,opt,name=ip_proto,json=ipProto,proto3,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	SrcPort   uint32        `protobuf:"varint,7,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort   uint32        `protobuf:"varint,8,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
}

func (m *FlowGateKey) Reset()                    { *m = FlowGateKey{} }
func (m *FlowGateKey) String() string            { return proto.CompactTextString(m) }
func (*FlowGateKey) ProtoMessage()               {}
func (*FlowGateKey) Descriptor() ([]byte, []int) { return fileDescriptorNwsec, []int{68} }

func (m *FlowGateKey) GetDirection() FlowDirection {
	if m != nil {
		return m.Direction
	}
	return FlowDirection_FLOW_DIRECTION_NONE
}

func (m *FlowGateKey) GetSrcVrfId() uint64 {
	if m != nil {
		return m.SrcVrfId
	}
	return 0
}

func (m *FlowGateKey) GetDstVrfId() uint64 {
	if m != nil {
		return m.DstVrfId
	}
	return 0
}

func (m *FlowGateKey) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *FlowGateKey) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *FlowGateKey) GetIpProto() IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowGateKey) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *FlowGateKey) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type SecurityFlowGateGetResponse struct {
	ApiStatus    ApiStatus    `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	FlowGateKey  *FlowGateKey `protobuf:"bytes,2,opt,name=flow_gate_key,json=flowGateKey" json:"flow_gate_key,omitempty"`
	Alg          ALGName      `protobuf:"varint,3,opt,name=alg,proto3,enum=nwsec.ALGName" json:"alg,omitempty"`
	DeleteMarked bool         `protobuf:"varint,4,opt,name=delete_marked,json=deleteMarked,proto3" json:"delete_marked,omitempty"`
	RefCount     uint32       `protobuf:"varint,5,opt,name=ref_count,json=refCount,proto3" json:"ref_count,omitempty"`
	TimeToAge    uint32       `protobuf:"varint,6,opt,name=time_to_age,json=timeToAge,proto3" json:"time_to_age,omitempty"`
}

func (m *SecurityFlowGateGetResponse) Reset()         { *m = SecurityFlowGateGetResponse{} }
func (m *SecurityFlowGateGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateGetResponse) ProtoMessage()    {}
func (*SecurityFlowGateGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{69}
}

func (m *SecurityFlowGateGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityFlowGateGetResponse) GetFlowGateKey() *FlowGateKey {
	if m != nil {
		return m.FlowGateKey
	}
	return nil
}

func (m *SecurityFlowGateGetResponse) GetAlg() ALGName {
	if m != nil {
		return m.Alg
	}
	return ALGName_APP_SVC_NONE
}

func (m *SecurityFlowGateGetResponse) GetDeleteMarked() bool {
	if m != nil {
		return m.DeleteMarked
	}
	return false
}

func (m *SecurityFlowGateGetResponse) GetRefCount() uint32 {
	if m != nil {
		return m.RefCount
	}
	return 0
}

func (m *SecurityFlowGateGetResponse) GetTimeToAge() uint32 {
	if m != nil {
		return m.TimeToAge
	}
	return 0
}

type SecurityFlowGateGetResponseMsg struct {
	ApiStatus ApiStatus                      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Response  []*SecurityFlowGateGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityFlowGateGetResponseMsg) Reset()         { *m = SecurityFlowGateGetResponseMsg{} }
func (m *SecurityFlowGateGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateGetResponseMsg) ProtoMessage()    {}
func (*SecurityFlowGateGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{70}
}

func (m *SecurityFlowGateGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityFlowGateGetResponseMsg) GetResponse() []*SecurityFlowGateGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type SecurityFlowGateDeleteRequest struct {
	Filter *SecurityFlowGateFilter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
}

func (m *SecurityFlowGateDeleteRequest) Reset()         { *m = SecurityFlowGateDeleteRequest{} }
func (m *SecurityFlowGateDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateDeleteRequest) ProtoMessage()    {}
func (*SecurityFlowGateDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{71}
}

func (m *SecurityFlowGateDeleteRequest) GetFilter() *SecurityFlowGateFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type SecurityFlowGateDeleteRequestMsg struct {
	Request []*SecurityFlowGateDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityFlowGateDeleteRequestMsg) Reset()         { *m = SecurityFlowGateDeleteRequestMsg{} }
func (m *SecurityFlowGateDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityFlowGateDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{72}
}

func (m *SecurityFlowGateDeleteRequestMsg) GetRequest() []*SecurityFlowGateDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityFlowGateDeleteResponseMsg struct {
}

func (m *SecurityFlowGateDeleteResponseMsg) Reset()         { *m = SecurityFlowGateDeleteResponseMsg{} }
func (m *SecurityFlowGateDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityFlowGateDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityFlowGateDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec, []int{73}
}

func init() {
	proto.RegisterType((*SecurityProfileSpec)(nil), "nwsec.SecurityProfileSpec")
	proto.RegisterType((*SecurityProfileRequestMsg)(nil), "nwsec.SecurityProfileRequestMsg")
	proto.RegisterType((*SecurityProfileStatusEpd)(nil), "nwsec.SecurityProfileStatusEpd")
	proto.RegisterType((*SecurityProfileStatusCpd)(nil), "nwsec.SecurityProfileStatusCpd")
	proto.RegisterType((*SecurityProfileStatus)(nil), "nwsec.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileResponse)(nil), "nwsec.SecurityProfileResponse")
	proto.RegisterType((*SecurityProfileResponseMsg)(nil), "nwsec.SecurityProfileResponseMsg")
	proto.RegisterType((*SecurityProfileDeleteRequest)(nil), "nwsec.SecurityProfileDeleteRequest")
	proto.RegisterType((*SecurityProfileDeleteRequestMsg)(nil), "nwsec.SecurityProfileDeleteRequestMsg")
	proto.RegisterType((*SecurityProfileDeleteResponse)(nil), "nwsec.SecurityProfileDeleteResponse")
	proto.RegisterType((*SecurityProfileDeleteResponseMsg)(nil), "nwsec.SecurityProfileDeleteResponseMsg")
	proto.RegisterType((*SecurityProfileGetRequest)(nil), "nwsec.SecurityProfileGetRequest")
	proto.RegisterType((*SecurityProfileGetRequestMsg)(nil), "nwsec.SecurityProfileGetRequestMsg")
	proto.RegisterType((*SecurityProfileStats)(nil), "nwsec.SecurityProfileStats")
	proto.RegisterType((*SecurityProfileGetResponse)(nil), "nwsec.SecurityProfileGetResponse")
	proto.RegisterType((*SecurityProfileGetResponseMsg)(nil), "nwsec.SecurityProfileGetResponseMsg")
	proto.RegisterType((*Service)(nil), "nwsec.Service")
	proto.RegisterType((*FirewallRuleSpec)(nil), "nwsec.FirewallRuleSpec")
	proto.RegisterType((*NetworkSecurityPolicy)(nil), "nwsec.NetworkSecurityPolicy")
	proto.RegisterType((*SecurityGroupPolicySpec)(nil), "nwsec.SecurityGroupPolicySpec")
	proto.RegisterType((*SecurityGroupPolicyRequestMsg)(nil), "nwsec.SecurityGroupPolicyRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyStatus)(nil), "nwsec.SecurityGroupPolicyStatus")
	proto.RegisterType((*SecurityGroupPolicyResponse)(nil), "nwsec.SecurityGroupPolicyResponse")
	proto.RegisterType((*SecurityGroupPolicyResponseMsg)(nil), "nwsec.SecurityGroupPolicyResponseMsg")
	proto.RegisterType((*SecurityGroupPolicyDeleteRequest)(nil), "nwsec.SecurityGroupPolicyDeleteRequest")
	proto.RegisterType((*SecurityGroupPolicyDeleteRequestMsg)(nil), "nwsec.SecurityGroupPolicyDeleteRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyDeleteResponse)(nil), "nwsec.SecurityGroupPolicyDeleteResponse")
	proto.RegisterType((*SecurityGroupPolicyDeleteResponseMsg)(nil), "nwsec.SecurityGroupPolicyDeleteResponseMsg")
	proto.RegisterType((*SecurityGroupPolicyGetRequest)(nil), "nwsec.SecurityGroupPolicyGetRequest")
	proto.RegisterType((*SecurityGroupPolicyGetRequestMsg)(nil), "nwsec.SecurityGroupPolicyGetRequestMsg")
	proto.RegisterType((*SecurityGroupPolicyStats)(nil), "nwsec.SecurityGroupPolicyStats")
	proto.RegisterType((*SecurityGroupPolicyGetResponse)(nil), "nwsec.SecurityGroupPolicyGetResponse")
	proto.RegisterType((*SecurityGroupPolicyGetResponseMsg)(nil), "nwsec.SecurityGroupPolicyGetResponseMsg")
	proto.RegisterType((*SecurityGroupSpec)(nil), "nwsec.SecurityGroupSpec")
	proto.RegisterType((*SecurityGroupRequestMsg)(nil), "nwsec.SecurityGroupRequestMsg")
	proto.RegisterType((*SecurityGroupStatus)(nil), "nwsec.SecurityGroupStatus")
	proto.RegisterType((*SecurityGroupResponse)(nil), "nwsec.SecurityGroupResponse")
	proto.RegisterType((*SecurityGroupResponseMsg)(nil), "nwsec.SecurityGroupResponseMsg")
	proto.RegisterType((*SecurityGroupDeleteRequest)(nil), "nwsec.SecurityGroupDeleteRequest")
	proto.RegisterType((*SecurityGroupDeleteRequestMsg)(nil), "nwsec.SecurityGroupDeleteRequestMsg")
	proto.RegisterType((*SecurityGroupDeleteResponseMsg)(nil), "nwsec.SecurityGroupDeleteResponseMsg")
	proto.RegisterType((*SecurityGroupGetRequest)(nil), "nwsec.SecurityGroupGetRequest")
	proto.RegisterType((*SecurityGroupGetRequestMsg)(nil), "nwsec.SecurityGroupGetRequestMsg")
	proto.RegisterType((*SecurityGroupStats)(nil), "nwsec.SecurityGroupStats")
	proto.RegisterType((*SecurityGroupGetResponse)(nil), "nwsec.SecurityGroupGetResponse")
	proto.RegisterType((*SecurityGroupGetResponseMsg)(nil), "nwsec.SecurityGroupGetResponseMsg")
	proto.RegisterType((*AppData)(nil), "nwsec.AppData")
	proto.RegisterType((*AppData_TraceOptions)(nil), "nwsec.AppData.TraceOptions")
	proto.RegisterType((*AppData_FTPOptions)(nil), "nwsec.AppData.FTPOptions")
	proto.RegisterType((*AppData_DNSOptions)(nil), "nwsec.AppData.DNSOptions")
	proto.RegisterType((*AppData_RPCData)(nil), "nwsec.AppData.RPCData")
	proto.RegisterType((*AppData_MSRPCOptions)(nil), "nwsec.AppData.MSRPCOptions")
	proto.RegisterType((*AppData_SunRPCOptions)(nil), "nwsec.AppData.SunRPCOptions")
	proto.RegisterType((*AppData_SIPOptions)(nil), "nwsec.AppData.SIPOptions")
	proto.RegisterType((*SecurityRuleAction)(nil), "nwsec.SecurityRuleAction")
	proto.RegisterType((*SecurityRule)(nil), "nwsec.SecurityRule")
	proto.RegisterType((*SecurityPolicySpec)(nil), "nwsec.SecurityPolicySpec")
	proto.RegisterType((*SecurityPolicyRequestMsg)(nil), "nwsec.SecurityPolicyRequestMsg")
	proto.RegisterType((*SecurityRuleStatus)(nil), "nwsec.SecurityRuleStatus")
	proto.RegisterType((*SecurityPolicyStatus)(nil), "nwsec.SecurityPolicyStatus")
	proto.RegisterType((*SecurityPolicyResponse)(nil), "nwsec.SecurityPolicyResponse")
	proto.RegisterType((*SecurityPolicyResponseMsg)(nil), "nwsec.SecurityPolicyResponseMsg")
	proto.RegisterType((*SecurityPolicyDeleteRequest)(nil), "nwsec.SecurityPolicyDeleteRequest")
	proto.RegisterType((*SecurityPolicyDeleteRequestMsg)(nil), "nwsec.SecurityPolicyDeleteRequestMsg")
	proto.RegisterType((*SecurityPolicyDeleteResponse)(nil), "nwsec.SecurityPolicyDeleteResponse")
	proto.RegisterType((*SecurityPolicyDeleteResponseMsg)(nil), "nwsec.SecurityPolicyDeleteResponseMsg")
	proto.RegisterType((*SecurityPolicyGetRequest)(nil), "nwsec.SecurityPolicyGetRequest")
	proto.RegisterType((*SecurityPolicyGetRequestMsg)(nil), "nwsec.SecurityPolicyGetRequestMsg")
	proto.RegisterType((*SecurityRuleStats)(nil), "nwsec.SecurityRuleStats")
	proto.RegisterType((*SecurityPolicyStats)(nil), "nwsec.SecurityPolicyStats")
	proto.RegisterType((*SecurityPolicyGetResponse)(nil), "nwsec.SecurityPolicyGetResponse")
	proto.RegisterType((*SecurityPolicyGetResponseMsg)(nil), "nwsec.SecurityPolicyGetResponseMsg")
	proto.RegisterType((*SecurityFlowGateFilter)(nil), "nwsec.SecurityFlowGateFilter")
	proto.RegisterType((*SecurityFlowGateGetRequest)(nil), "nwsec.SecurityFlowGateGetRequest")
	proto.RegisterType((*SecurityFlowGateGetRequestMsg)(nil), "nwsec.SecurityFlowGateGetRequestMsg")
	proto.RegisterType((*FlowGateKey)(nil), "nwsec.FlowGateKey")
	proto.RegisterType((*SecurityFlowGateGetResponse)(nil), "nwsec.SecurityFlowGateGetResponse")
	proto.RegisterType((*SecurityFlowGateGetResponseMsg)(nil), "nwsec.SecurityFlowGateGetResponseMsg")
	proto.RegisterType((*SecurityFlowGateDeleteRequest)(nil), "nwsec.SecurityFlowGateDeleteRequest")
	proto.RegisterType((*SecurityFlowGateDeleteRequestMsg)(nil), "nwsec.SecurityFlowGateDeleteRequestMsg")
	proto.RegisterType((*SecurityFlowGateDeleteResponseMsg)(nil), "nwsec.SecurityFlowGateDeleteResponseMsg")
	proto.RegisterEnum("nwsec.NormalizationAction", NormalizationAction_name, NormalizationAction_value)
	proto.RegisterEnum("nwsec.ALGName", ALGName_name, ALGName_value)
	proto.RegisterEnum("nwsec.FirewallAction", FirewallAction_name, FirewallAction_value)
	proto.RegisterEnum("nwsec.SecurityAction", SecurityAction_name, SecurityAction_value)
	proto.RegisterEnum("nwsec.LogAction", LogAction_name, LogAction_value)
	proto.RegisterEnum("nwsec.AppData_TraceLevel", AppData_TraceLevel_name, AppData_TraceLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NwSecurity service

type NwSecurityClient interface {
	SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error)
	SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error)
	SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityProfileDeleteResponseMsg, error)
	SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequestMsg, opts ...grpc.CallOption) (*SecurityProfileGetResponseMsg, error)
	SecurityGroupPolicyCreate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyUpdate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyDelete(ctx context.Context, in *SecurityGroupPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyDeleteResponseMsg, error)
	SecurityGroupPolicyGet(ctx context.Context, in *SecurityGroupPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyGetResponseMsg, error)
	SecurityGroupCreate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error)
	SecurityGroupUpdate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error)
	SecurityGroupDelete(ctx context.Context, in *SecurityGroupDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupDeleteResponseMsg, error)
	SecurityGroupGet(ctx context.Context, in *SecurityGroupGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupGetResponseMsg, error)
	SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyResponseMsg, error)
	SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyResponseMsg, error)
	SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponseMsg, error)
	SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyGetResponseMsg, error)
	SecurityFlowGateGet(ctx context.Context, in *SecurityFlowGateGetRequestMsg, opts ...grpc.CallOption) (*SecurityFlowGateGetResponseMsg, error)
	SecurityFlowGateDelete(ctx context.Context, in *SecurityFlowGateDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityFlowGateDeleteResponseMsg, error)
}

type nwSecurityClient struct {
	cc *grpc.ClientConn
}

func NewNwSecurityClient(cc *grpc.ClientConn) NwSecurityClient {
	return &nwSecurityClient{cc}
}

func (c *nwSecurityClient) SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error) {
	out := new(SecurityProfileResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequestMsg, opts ...grpc.CallOption) (*SecurityProfileResponseMsg, error) {
	out := new(SecurityProfileResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityProfileDeleteResponseMsg, error) {
	out := new(SecurityProfileDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequestMsg, opts ...grpc.CallOption) (*SecurityProfileGetResponseMsg, error) {
	out := new(SecurityProfileGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityProfileGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyCreate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error) {
	out := new(SecurityGroupPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyUpdate(ctx context.Context, in *SecurityGroupPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyResponseMsg, error) {
	out := new(SecurityGroupPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyDelete(ctx context.Context, in *SecurityGroupPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyDeleteResponseMsg, error) {
	out := new(SecurityGroupPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupPolicyGet(ctx context.Context, in *SecurityGroupPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupPolicyGetResponseMsg, error) {
	out := new(SecurityGroupPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupCreate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error) {
	out := new(SecurityGroupResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupUpdate(ctx context.Context, in *SecurityGroupRequestMsg, opts ...grpc.CallOption) (*SecurityGroupResponseMsg, error) {
	out := new(SecurityGroupResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupDelete(ctx context.Context, in *SecurityGroupDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityGroupDeleteResponseMsg, error) {
	out := new(SecurityGroupDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityGroupGet(ctx context.Context, in *SecurityGroupGetRequestMsg, opts ...grpc.CallOption) (*SecurityGroupGetResponseMsg, error) {
	out := new(SecurityGroupGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityGroupGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyResponseMsg, error) {
	out := new(SecurityPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyResponseMsg, error) {
	out := new(SecurityPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponseMsg, error) {
	out := new(SecurityPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequestMsg, opts ...grpc.CallOption) (*SecurityPolicyGetResponseMsg, error) {
	out := new(SecurityPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityFlowGateGet(ctx context.Context, in *SecurityFlowGateGetRequestMsg, opts ...grpc.CallOption) (*SecurityFlowGateGetResponseMsg, error) {
	out := new(SecurityFlowGateGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityFlowGateGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityClient) SecurityFlowGateDelete(ctx context.Context, in *SecurityFlowGateDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityFlowGateDeleteResponseMsg, error) {
	out := new(SecurityFlowGateDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurity/SecurityFlowGateDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NwSecurity service

type NwSecurityServer interface {
	SecurityProfileCreate(context.Context, *SecurityProfileRequestMsg) (*SecurityProfileResponseMsg, error)
	SecurityProfileUpdate(context.Context, *SecurityProfileRequestMsg) (*SecurityProfileResponseMsg, error)
	SecurityProfileDelete(context.Context, *SecurityProfileDeleteRequestMsg) (*SecurityProfileDeleteResponseMsg, error)
	SecurityProfileGet(context.Context, *SecurityProfileGetRequestMsg) (*SecurityProfileGetResponseMsg, error)
	SecurityGroupPolicyCreate(context.Context, *SecurityGroupPolicyRequestMsg) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyUpdate(context.Context, *SecurityGroupPolicyRequestMsg) (*SecurityGroupPolicyResponseMsg, error)
	SecurityGroupPolicyDelete(context.Context, *SecurityGroupPolicyDeleteRequestMsg) (*SecurityGroupPolicyDeleteResponseMsg, error)
	SecurityGroupPolicyGet(context.Context, *SecurityGroupPolicyGetRequestMsg) (*SecurityGroupPolicyGetResponseMsg, error)
	SecurityGroupCreate(context.Context, *SecurityGroupRequestMsg) (*SecurityGroupResponseMsg, error)
	SecurityGroupUpdate(context.Context, *SecurityGroupRequestMsg) (*SecurityGroupResponseMsg, error)
	SecurityGroupDelete(context.Context, *SecurityGroupDeleteRequestMsg) (*SecurityGroupDeleteResponseMsg, error)
	SecurityGroupGet(context.Context, *SecurityGroupGetRequestMsg) (*SecurityGroupGetResponseMsg, error)
	SecurityPolicyCreate(context.Context, *SecurityPolicyRequestMsg) (*SecurityPolicyResponseMsg, error)
	SecurityPolicyUpdate(context.Context, *SecurityPolicyRequestMsg) (*SecurityPolicyResponseMsg, error)
	SecurityPolicyDelete(context.Context, *SecurityPolicyDeleteRequestMsg) (*SecurityPolicyDeleteResponseMsg, error)
	SecurityPolicyGet(context.Context, *SecurityPolicyGetRequestMsg) (*SecurityPolicyGetResponseMsg, error)
	SecurityFlowGateGet(context.Context, *SecurityFlowGateGetRequestMsg) (*SecurityFlowGateGetResponseMsg, error)
	SecurityFlowGateDelete(context.Context, *SecurityFlowGateDeleteRequestMsg) (*SecurityFlowGateDeleteResponseMsg, error)
}

func RegisterNwSecurityServer(s *grpc.Server, srv NwSecurityServer) {
	s.RegisterService(&_NwSecurity_serviceDesc, srv)
}

func _NwSecurity_SecurityProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileCreate(ctx, req.(*SecurityProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileUpdate(ctx, req.(*SecurityProfileRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileDelete(ctx, req.(*SecurityProfileDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityProfileGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityProfileGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityProfileGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityProfileGet(ctx, req.(*SecurityProfileGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyCreate(ctx, req.(*SecurityGroupPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyUpdate(ctx, req.(*SecurityGroupPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyDelete(ctx, req.(*SecurityGroupPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupPolicyGet(ctx, req.(*SecurityGroupPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupCreate(ctx, req.(*SecurityGroupRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupUpdate(ctx, req.(*SecurityGroupRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupDelete(ctx, req.(*SecurityGroupDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityGroupGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroupGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityGroupGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityGroupGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityGroupGet(ctx, req.(*SecurityGroupGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityPolicyCreate(ctx, req.(*SecurityPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityPolicyUpdate(ctx, req.(*SecurityPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityPolicyDelete(ctx, req.(*SecurityPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityPolicyGet(ctx, req.(*SecurityPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityFlowGateGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityFlowGateGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityFlowGateGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityFlowGateGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityFlowGateGet(ctx, req.(*SecurityFlowGateGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurity_SecurityFlowGateDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityFlowGateDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityServer).SecurityFlowGateDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurity/SecurityFlowGateDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityServer).SecurityFlowGateDelete(ctx, req.(*SecurityFlowGateDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _NwSecurity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nwsec.NwSecurity",
	HandlerType: (*NwSecurityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityProfileCreate",
			Handler:    _NwSecurity_SecurityProfileCreate_Handler,
		},
		{
			MethodName: "SecurityProfileUpdate",
			Handler:    _NwSecurity_SecurityProfileUpdate_Handler,
		},
		{
			MethodName: "SecurityProfileDelete",
			Handler:    _NwSecurity_SecurityProfileDelete_Handler,
		},
		{
			MethodName: "SecurityProfileGet",
			Handler:    _NwSecurity_SecurityProfileGet_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyCreate",
			Handler:    _NwSecurity_SecurityGroupPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyUpdate",
			Handler:    _NwSecurity_SecurityGroupPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyDelete",
			Handler:    _NwSecurity_SecurityGroupPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityGroupPolicyGet",
			Handler:    _NwSecurity_SecurityGroupPolicyGet_Handler,
		},
		{
			MethodName: "SecurityGroupCreate",
			Handler:    _NwSecurity_SecurityGroupCreate_Handler,
		},
		{
			MethodName: "SecurityGroupUpdate",
			Handler:    _NwSecurity_SecurityGroupUpdate_Handler,
		},
		{
			MethodName: "SecurityGroupDelete",
			Handler:    _NwSecurity_SecurityGroupDelete_Handler,
		},
		{
			MethodName: "SecurityGroupGet",
			Handler:    _NwSecurity_SecurityGroupGet_Handler,
		},
		{
			MethodName: "SecurityPolicyCreate",
			Handler:    _NwSecurity_SecurityPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityPolicyUpdate",
			Handler:    _NwSecurity_SecurityPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityPolicyDelete",
			Handler:    _NwSecurity_SecurityPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityPolicyGet",
			Handler:    _NwSecurity_SecurityPolicyGet_Handler,
		},
		{
			MethodName: "SecurityFlowGateGet",
			Handler:    _NwSecurity_SecurityFlowGateGet_Handler,
		},
		{
			MethodName: "SecurityFlowGateDelete",
			Handler:    _NwSecurity_SecurityFlowGateDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nwsec.proto",
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SessionIdleTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SessionIdleTimeout))
	}
	if m.TcpCnxnSetupTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpCnxnSetupTimeout))
	}
	if m.TcpCloseTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpCloseTimeout))
	}
	if m.TcpHalfClosedTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpHalfClosedTimeout))
	}
	if m.IpNormalizeTtl != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpNormalizeTtl))
	}
	if m.TcpDropTimeout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpDropTimeout))
	}
	if m.UdpDropTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.UdpDropTimeout))
	}
	if m.IcmpDropTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpDropTimeout))
	}
	if m.DropTimeout != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DropTimeout))
	}
	if m.TcpTimeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpTimeout))
	}
	if m.UdpTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.UdpTimeout))
	}
	if m.IcmpTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpTimeout))
	}
	if m.CnxnTrackingEn {
		dAtA[i] = 0x70
		i++
		if m.CnxnTrackingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpsgEn {
		dAtA[i] = 0x78
		i++
		if m.IpsgEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpRttEstimateEn {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.TcpRttEstimateEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpNormalizationEn {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNormalizationEn {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.TcpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpNormalizationEn {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.IcmpNormalizationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpReassemblyEn {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IpReassemblyEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpTtlChangeDetectEn {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.IpTtlChangeDetectEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpSrcGuardEn {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.IpSrcGuardEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpRsvdFlagsAction != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpRsvdFlagsAction))
	}
	if m.IpDfAction != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpDfAction))
	}
	if m.IpOptionsAction != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpOptionsAction))
	}
	if m.IpInvalidLenAction != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpInvalidLenAction))
	}
	if m.IpSpoofPktDrop {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.IpSpoofPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpLooseSrcRoutingPktDrop {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.IpLooseSrcRoutingPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpMalformedOptionPktDrop {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		if m.IpMalformedOptionPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpRecordRouteOptionPktDrop {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		if m.IpRecordRouteOptionPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpStrictSrcRoutingPktDrop {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.IpStrictSrcRoutingPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpTsOptionPktDrop {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.IpTsOptionPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpUnknownOptionPktDrop {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.IpUnknownOptionPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpStreamIdOptionPktDrop {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.IpStreamIdOptionPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpRsvdFldSetPktDrop {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		if m.IpRsvdFldSetPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpClearDfBit {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.IpClearDfBit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6AnycastSrcDrop {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6AnycastSrcDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6V4CompatibleAddrDrop {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6V4CompatibleAddrDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6NeedlessIpFragHdrDrop {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6NeedlessIpFragHdrDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6InvalidOptionsPktDrop {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6InvalidOptionsPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6RsvdFldSetPktDrop {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6RsvdFldSetPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6RtgHdrPktDrop {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6RtgHdrPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6DstOptionsHdrPktDrop {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6DstOptionsHdrPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipv6HopByHopOptionsPktDrop {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		if m.Ipv6HopByHopOptionsPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpInvalidCodeAction != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpInvalidCodeAction))
	}
	if m.IcmpDeprecatedMsgsDrop {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpDeprecatedMsgsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpRedirectMsgDrop {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpRedirectMsgDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpDstUnreachIgnorePayload {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpDstUnreachIgnorePayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpParamPrblmIgnorePayload {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpParamPrblmIgnorePayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpPktTooBigIgnorePayload {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpPktTooBigIgnorePayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpRedirectIgnorePayload {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpRedirectIgnorePayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpTimeExceedIgnorePayload {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpTimeExceedIgnorePayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpErrorDrop {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpErrorDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpFragmentsDrop {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpFragmentsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpLargePktDrop {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpLargePktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpPingZeroIdDrop {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpPingZeroIdDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpNeedFragSuppress {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpNeedFragSuppress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IcmpTimeExceedSuppress {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		if m.IcmpTimeExceedSuppress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Icmpv6LargeMsgMtuSmallDrop {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		if m.Icmpv6LargeMsgMtuSmallDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpSplitHandshakeDrop {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x4
		i++
		if m.TcpSplitHandshakeDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpRsvdFlagsAction != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpRsvdFlagsAction))
	}
	if m.TcpUnexpectedMssAction != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedMssAction))
	}
	if m.TcpUnexpectedWinScaleAction != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedWinScaleAction))
	}
	if m.TcpUnexpectedSackPermAction != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedSackPermAction))
	}
	if m.TcpUrgPtrNotSetAction != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgPtrNotSetAction))
	}
	if m.TcpUrgFlagNotSetAction != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgFlagNotSetAction))
	}
	if m.TcpUrgPayloadMissingAction != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUrgPayloadMissingAction))
	}
	if m.TcpRstWithDataAction != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpRstWithDataAction))
	}
	if m.TcpDataLenGtMssAction != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpDataLenGtMssAction))
	}
	if m.TcpDataLenGtWinSizeAction != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpDataLenGtWinSizeAction))
	}
	if m.TcpUnexpectedTsOptionAction != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedTsOptionAction))
	}
	if m.TcpUnexpectedEchoTsAction != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedEchoTsAction))
	}
	if m.TcpUnexpectedSackOptionAction != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpUnexpectedSackOptionAction))
	}
	if m.TcpTsNotPresentDrop {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpTsNotPresentDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNonSynFirstPktDrop {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpNonSynFirstPktDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpInvalidFlagsDrop {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpInvalidFlagsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNonsynNoackDrop {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpNonsynNoackDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpSynWithDataDrop {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpSynWithDataDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpSynAckWithDataDrop {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpSynAckWithDataDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpOverlappingSegmentsDrop {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpOverlappingSegmentsDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpStripTimestampOption {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpStripTimestampOption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpConnTrackBypassWindowErr {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpConnTrackBypassWindowErr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpConnTrackFinRstDisable {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpConnTrackFinRstDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpUrgFlagPtrClear {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x5
		i++
		if m.TcpUrgFlagPtrClear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpNormalizeMss != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpNormalizeMss))
	}
	if m.MulticastSrcDrop {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x6
		i++
		if m.MulticastSrcDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TcpHalfOpenSessionLimit != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TcpHalfOpenSessionLimit))
	}
	if m.UdpActiveSessionLimit != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.UdpActiveSessionLimit))
	}
	if m.IcmpActiveSessionLimit != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpActiveSessionLimit))
	}
	if m.OtherActiveSessionLimit != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.OtherActiveSessionLimit))
	}
	if m.PolicyEnforceEn {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		if m.PolicyEnforceEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FlowLearnEn {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x6
		i++
		if m.FlowLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AppDetectionEn {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x6
		i++
		if m.AppDetectionEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SecurityProfileRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwSecProfileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.HwSecProfileId))
	}
	return i, nil
}

func (m *SecurityProfileStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ProfileHandle))
		i += 8
	}
	if m.ProfilePdStatus != nil {
		nn2, err := m.ProfilePdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *SecurityProfileStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.EpdStatus.Size()))
		n3, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *SecurityProfileStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.CpdStatus.Size()))
		n4, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *SecurityProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ProfileStatus.Size()))
		n5, err := m.ProfileStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SecurityProfileResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n6, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ProfileStatus.Size()))
		n7, err := m.ProfileStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n8, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SecurityProfileGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfileGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n9, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n11, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SecurityProfileGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpProtocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		nn12, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	if m.Alg != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Alg))
	}
	return i, nil
}

func (m *Service_DstPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintNwsec(dAtA, i, uint64(m.DstPort))
	return i, nil
}
func (m *Service_IcmpMsgType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintNwsec(dAtA, i, uint64(m.IcmpMsgType))
	return i, nil
}
func (m *FirewallRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svc) > 0 {
		for _, msg := range m.Svc {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Action != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Action))
	}
	if m.Log {
		dAtA[i] = 0x28
		i++
		if m.Log {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NetworkSecurityPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSecurityPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InFwRules) > 0 {
		for _, msg := range m.InFwRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgFwRules) > 0 {
		for _, msg := range m.EgFwRules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n13, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.PolicyRules != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PolicyRules.Size()))
		n14, err := m.PolicyRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *SecurityGroupPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PolicyHandle))
		i += 8
	}
	return i, nil
}

func (m *SecurityGroupPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n15, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *SecurityGroupPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n16, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityGroupPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n18, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n20, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *SecurityGroupPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n22, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *SecurityGroupRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n23, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n24, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *SecurityGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n25, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SecurityGroupResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n26, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *SecurityGroupDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA28 := make([]byte, len(m.ApiStatus)*10)
		var j27 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	return i, nil
}

func (m *SecurityGroupGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n29, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *SecurityGroupGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityGroupGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n30, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n31, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Stats.Size()))
		n32, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *SecurityGroupGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AppData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Alg != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Alg))
	}
	if m.AppOptions != nil {
		nn33, err := m.AppOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn33
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.TraceOpts != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TraceOpts.Size()))
		n34, err := m.TraceOpts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *AppData_FtpOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FtpOptionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.FtpOptionInfo.Size()))
		n35, err := m.FtpOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *AppData_DnsOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsOptionInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DnsOptionInfo.Size()))
		n36, err := m.DnsOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *AppData_MsrpcOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MsrpcOptionInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.MsrpcOptionInfo.Size()))
		n37, err := m.MsrpcOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *AppData_SunRpcOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SunRpcOptionInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SunRpcOptionInfo.Size()))
		n38, err := m.SunRpcOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *AppData_SipOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SipOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SipOptions.Size()))
		n39, err := m.SipOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *AppData_TraceOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_TraceOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *AppData_FTPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMismatchIpAddress {
		dAtA[i] = 0x8
		i++
		if m.AllowMismatchIpAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AppData_DNSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		dAtA[i] = 0x8
		i++
		if m.DropMultiQuestionPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLargeDomainNamePackets {
		dAtA[i] = 0x10
		i++
		if m.DropLargeDomainNamePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLongLabelPackets {
		dAtA[i] = 0x18
		i++
		if m.DropLongLabelPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMultizonePackets {
		dAtA[i] = 0x20
		i++
		if m.DropMultizonePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxMsgLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.MaxMsgLength))
	}
	if m.QueryResponseTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.QueryResponseTimeout))
	}
	return i, nil
}

func (m *AppData_RPCData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_RPCData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(len(m.ProgramId)))
		i += copy(dAtA[i:], m.ProgramId)
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IdleTimeout))
	}
	return i, nil
}

func (m *AppData_MSRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppData_SunRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppData_SIPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppData_SIPOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ctimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Ctimeout))
	}
	if m.DscpCodePoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DscpCodePoint))
	}
	if m.MediaInactivityTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.MediaInactivityTimeout))
	}
	if m.MaxCallDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.MaxCallDuration))
	}
	if m.T1TimerValue != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.T1TimerValue))
	}
	if m.T4TimerValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.T4TimerValue))
	}
	return i, nil
}

func (m *SecurityRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SecAction))
	}
	if m.LogAction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.LogAction))
	}
	if m.AppData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.AppData.Size()))
		n40, err := m.AppData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.RuleId))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Match.Size()))
		n41, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Action != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Action.Size()))
		n42, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Appid) > 0 {
		for _, s := range m.Appid {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SecurityPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n43, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n44, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Rule) > 0 {
		for _, msg := range m.Rule {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.RuleId))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Priority))
	}
	return i, nil
}

func (m *SecurityPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Meta.Size()))
		n45, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n46, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.RuleStatus) > 0 {
		for _, msg := range m.RuleStatus {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PolicyStatus.Size()))
		n47, err := m.PolicyStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *SecurityPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n48, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *SecurityPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n49, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}

func (m *SecurityPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.RuleId))
	}
	if m.NumHits != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NumHits))
		i += 8
	}
	if m.NumTcpHits != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NumTcpHits))
		i += 8
	}
	if m.NumUdpHits != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NumUdpHits))
		i += 8
	}
	if m.NumIcmpHits != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NumIcmpHits))
		i += 8
	}
	return i, nil
}

func (m *SecurityPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuleStats) > 0 {
		for _, msg := range m.RuleStats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Spec.Size()))
		n50, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Status.Size()))
		n51, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.PolStats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.PolStats.Size()))
		n52, err := m.PolStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *SecurityPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityFlowGateFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcIp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SrcIp.Size()))
		n53, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.DstIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DstIp.Size()))
		n54, err := m.DstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DstPort))
	}
	if m.IpProto != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpProto))
	}
	if m.VrfId != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.VrfId))
		i += 8
	}
	if m.Alg != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Alg))
	}
	return i, nil
}

func (m *SecurityFlowGateGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Filter.Size()))
		n55, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *SecurityFlowGateGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowGateKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowGateKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Direction))
	}
	if m.SrcVrfId != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SrcVrfId))
		i += 8
	}
	if m.DstVrfId != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DstVrfId))
		i += 8
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SrcIp.Size()))
		n56, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.DstIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DstIp.Size()))
		n57, err := m.DstIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.IpProto != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.IpProto))
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.DstPort))
	}
	return i, nil
}

func (m *SecurityFlowGateGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if m.FlowGateKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.FlowGateKey.Size()))
		n58, err := m.FlowGateKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.Alg != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Alg))
	}
	if m.DeleteMarked {
		dAtA[i] = 0x20
		i++
		if m.DeleteMarked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RefCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.RefCount))
	}
	if m.TimeToAge != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.TimeToAge))
	}
	return i, nil
}

func (m *SecurityFlowGateGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityFlowGateDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec(dAtA, i, uint64(m.Filter.Size()))
		n59, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *SecurityFlowGateDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityFlowGateDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFlowGateDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintNwsec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.SessionIdleTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.SessionIdleTimeout))
	}
	if m.TcpCnxnSetupTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpCnxnSetupTimeout))
	}
	if m.TcpCloseTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpCloseTimeout))
	}
	if m.TcpHalfClosedTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpHalfClosedTimeout))
	}
	if m.IpNormalizeTtl != 0 {
		n += 1 + sovNwsec(uint64(m.IpNormalizeTtl))
	}
	if m.TcpDropTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpDropTimeout))
	}
	if m.UdpDropTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.UdpDropTimeout))
	}
	if m.IcmpDropTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.IcmpDropTimeout))
	}
	if m.DropTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.DropTimeout))
	}
	if m.TcpTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.TcpTimeout))
	}
	if m.UdpTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.UdpTimeout))
	}
	if m.IcmpTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.IcmpTimeout))
	}
	if m.CnxnTrackingEn {
		n += 2
	}
	if m.IpsgEn {
		n += 2
	}
	if m.TcpRttEstimateEn {
		n += 3
	}
	if m.IpNormalizationEn {
		n += 3
	}
	if m.TcpNormalizationEn {
		n += 3
	}
	if m.IcmpNormalizationEn {
		n += 3
	}
	if m.IpReassemblyEn {
		n += 3
	}
	if m.IpTtlChangeDetectEn {
		n += 3
	}
	if m.IpSrcGuardEn {
		n += 3
	}
	if m.IpRsvdFlagsAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpRsvdFlagsAction))
	}
	if m.IpDfAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpDfAction))
	}
	if m.IpOptionsAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpOptionsAction))
	}
	if m.IpInvalidLenAction != 0 {
		n += 2 + sovNwsec(uint64(m.IpInvalidLenAction))
	}
	if m.IpSpoofPktDrop {
		n += 3
	}
	if m.IpLooseSrcRoutingPktDrop {
		n += 3
	}
	if m.IpMalformedOptionPktDrop {
		n += 3
	}
	if m.IpRecordRouteOptionPktDrop {
		n += 3
	}
	if m.IpStrictSrcRoutingPktDrop {
		n += 3
	}
	if m.IpTsOptionPktDrop {
		n += 3
	}
	if m.IpUnknownOptionPktDrop {
		n += 3
	}
	if m.IpStreamIdOptionPktDrop {
		n += 3
	}
	if m.IpRsvdFldSetPktDrop {
		n += 3
	}
	if m.IpClearDfBit {
		n += 3
	}
	if m.Ipv6AnycastSrcDrop {
		n += 3
	}
	if m.Ipv6V4CompatibleAddrDrop {
		n += 3
	}
	if m.Ipv6NeedlessIpFragHdrDrop {
		n += 3
	}
	if m.Ipv6InvalidOptionsPktDrop {
		n += 3
	}
	if m.Ipv6RsvdFldSetPktDrop {
		n += 3
	}
	if m.Ipv6RtgHdrPktDrop {
		n += 3
	}
	if m.Ipv6DstOptionsHdrPktDrop {
		n += 3
	}
	if m.Ipv6HopByHopOptionsPktDrop {
		n += 3
	}
	if m.IcmpInvalidCodeAction != 0 {
		n += 2 + sovNwsec(uint64(m.IcmpInvalidCodeAction))
	}
	if m.IcmpDeprecatedMsgsDrop {
		n += 3
	}
	if m.IcmpRedirectMsgDrop {
		n += 3
	}
	if m.IcmpDstUnreachIgnorePayload {
		n += 3
	}
	if m.IcmpParamPrblmIgnorePayload {
		n += 3
	}
	if m.IcmpPktTooBigIgnorePayload {
		n += 3
	}
	if m.IcmpRedirectIgnorePayload {
		n += 3
	}
	if m.IcmpTimeExceedIgnorePayload {
		n += 3
	}
	if m.IcmpErrorDrop {
		n += 3
	}
	if m.IcmpFragmentsDrop {
		n += 3
	}
	if m.IcmpLargePktDrop {
		n += 3
	}
	if m.IcmpPingZeroIdDrop {
		n += 3
	}
	if m.IcmpNeedFragSuppress {
		n += 3
	}
	if m.IcmpTimeExceedSuppress {
		n += 3
	}
	if m.Icmpv6LargeMsgMtuSmallDrop {
		n += 3
	}
	if m.TcpSplitHandshakeDrop {
		n += 3
	}
	if m.TcpRsvdFlagsAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpRsvdFlagsAction))
	}
	if m.TcpUnexpectedMssAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedMssAction))
	}
	if m.TcpUnexpectedWinScaleAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedWinScaleAction))
	}
	if m.TcpUnexpectedSackPermAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedSackPermAction))
	}
	if m.TcpUrgPtrNotSetAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgPtrNotSetAction))
	}
	if m.TcpUrgFlagNotSetAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgFlagNotSetAction))
	}
	if m.TcpUrgPayloadMissingAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUrgPayloadMissingAction))
	}
	if m.TcpRstWithDataAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpRstWithDataAction))
	}
	if m.TcpDataLenGtMssAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpDataLenGtMssAction))
	}
	if m.TcpDataLenGtWinSizeAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpDataLenGtWinSizeAction))
	}
	if m.TcpUnexpectedTsOptionAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedTsOptionAction))
	}
	if m.TcpUnexpectedEchoTsAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedEchoTsAction))
	}
	if m.TcpUnexpectedSackOptionAction != 0 {
		n += 2 + sovNwsec(uint64(m.TcpUnexpectedSackOptionAction))
	}
	if m.TcpTsNotPresentDrop {
		n += 3
	}
	if m.TcpNonSynFirstPktDrop {
		n += 3
	}
	if m.TcpInvalidFlagsDrop {
		n += 3
	}
	if m.TcpNonsynNoackDrop {
		n += 3
	}
	if m.TcpSynWithDataDrop {
		n += 3
	}
	if m.TcpSynAckWithDataDrop {
		n += 3
	}
	if m.TcpOverlappingSegmentsDrop {
		n += 3
	}
	if m.TcpStripTimestampOption {
		n += 3
	}
	if m.TcpConnTrackBypassWindowErr {
		n += 3
	}
	if m.TcpConnTrackFinRstDisable {
		n += 3
	}
	if m.TcpUrgFlagPtrClear {
		n += 3
	}
	if m.TcpNormalizeMss != 0 {
		n += 2 + sovNwsec(uint64(m.TcpNormalizeMss))
	}
	if m.MulticastSrcDrop {
		n += 3
	}
	if m.TcpHalfOpenSessionLimit != 0 {
		n += 2 + sovNwsec(uint64(m.TcpHalfOpenSessionLimit))
	}
	if m.UdpActiveSessionLimit != 0 {
		n += 2 + sovNwsec(uint64(m.UdpActiveSessionLimit))
	}
	if m.IcmpActiveSessionLimit != 0 {
		n += 2 + sovNwsec(uint64(m.IcmpActiveSessionLimit))
	}
	if m.OtherActiveSessionLimit != 0 {
		n += 2 + sovNwsec(uint64(m.OtherActiveSessionLimit))
	}
	if m.PolicyEnforceEn {
		n += 3
	}
	if m.FlowLearnEn {
		n += 3
	}
	if m.AppDetectionEn {
		n += 3
	}
	return n
}

func (m *SecurityProfileRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.HwSecProfileId != 0 {
		n += 1 + sovNwsec(uint64(m.HwSecProfileId))
	}
	return n
}

func (m *SecurityProfileStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.ProfileHandle != 0 {
		n += 9
	}
	if m.ProfilePdStatus != nil {
		n += m.ProfilePdStatus.Size()
	}
	return n
}

func (m *SecurityProfileStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *SecurityProfileStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *SecurityProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		l = m.ProfileStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.ProfileStatus != nil {
		l = m.ProfileStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfileGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityProfileGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.IpProtocol != 0 {
		n += 1 + sovNwsec(uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	if m.Alg != 0 {
		n += 1 + sovNwsec(uint64(m.Alg))
	}
	return n
}

func (m *Service_DstPort) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec(uint64(m.DstPort))
	return n
}
func (m *Service_IcmpMsgType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec(uint64(m.IcmpMsgType))
	return n
}
func (m *FirewallRuleSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Svc) > 0 {
		for _, e := range m.Svc {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			l = len(s)
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.Action != 0 {
		n += 1 + sovNwsec(uint64(m.Action))
	}
	if m.Log {
		n += 2
	}
	return n
}

func (m *NetworkSecurityPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.InFwRules) > 0 {
		for _, e := range m.InFwRules {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if len(m.EgFwRules) > 0 {
		for _, e := range m.EgFwRules {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.PolicyRules != nil {
		l = m.PolicyRules.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.PolicyHandle != 0 {
		n += 9
	}
	return n
}

func (m *SecurityGroupPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityGroupPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupPolicyStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityGroupPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityGroupSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupStatus) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNwsec(uint64(e))
		}
		n += 1 + sovNwsec(uint64(l)) + l
	}
	return n
}

func (m *SecurityGroupGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityGroupGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityGroupGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *AppData) Size() (n int) {
	var l int
	_ = l
	if m.Alg != 0 {
		n += 1 + sovNwsec(uint64(m.Alg))
	}
	if m.AppOptions != nil {
		n += m.AppOptions.Size()
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.IdleTimeout))
	}
	if m.TraceOpts != nil {
		l = m.TraceOpts.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *AppData_FtpOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.FtpOptionInfo != nil {
		l = m.FtpOptionInfo.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *AppData_DnsOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.DnsOptionInfo != nil {
		l = m.DnsOptionInfo.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *AppData_MsrpcOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.MsrpcOptionInfo != nil {
		l = m.MsrpcOptionInfo.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *AppData_SunRpcOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.SunRpcOptionInfo != nil {
		l = m.SunRpcOptionInfo.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *AppData_SipOptions) Size() (n int) {
	var l int
	_ = l
	if m.SipOptions != nil {
		l = m.SipOptions.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}
func (m *AppData_TraceOptions) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovNwsec(uint64(m.Level))
	}
	return n
}

func (m *AppData_FTPOptions) Size() (n int) {
	var l int
	_ = l
	if m.AllowMismatchIpAddress {
		n += 2
	}
	return n
}

func (m *AppData_DNSOptions) Size() (n int) {
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		n += 2
	}
	if m.DropLargeDomainNamePackets {
		n += 2
	}
	if m.DropLongLabelPackets {
		n += 2
	}
	if m.DropMultizonePackets {
		n += 2
	}
	if m.MaxMsgLength != 0 {
		n += 1 + sovNwsec(uint64(m.MaxMsgLength))
	}
	if m.QueryResponseTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.QueryResponseTimeout))
	}
	return n
}

func (m *AppData_RPCData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.IdleTimeout))
	}
	return n
}

func (m *AppData_MSRPCOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *AppData_SunRPCOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *AppData_SIPOptions) Size() (n int) {
	var l int
	_ = l
	if m.Ctimeout != 0 {
		n += 1 + sovNwsec(uint64(m.Ctimeout))
	}
	if m.DscpCodePoint != 0 {
		n += 1 + sovNwsec(uint64(m.DscpCodePoint))
	}
	if m.MediaInactivityTimeout != 0 {
		n += 1 + sovNwsec(uint64(m.MediaInactivityTimeout))
	}
	if m.MaxCallDuration != 0 {
		n += 1 + sovNwsec(uint64(m.MaxCallDuration))
	}
	if m.T1TimerValue != 0 {
		n += 1 + sovNwsec(uint64(m.T1TimerValue))
	}
	if m.T4TimerValue != 0 {
		n += 1 + sovNwsec(uint64(m.T4TimerValue))
	}
	return n
}

func (m *SecurityRuleAction) Size() (n int) {
	var l int
	_ = l
	if m.SecAction != 0 {
		n += 1 + sovNwsec(uint64(m.SecAction))
	}
	if m.LogAction != 0 {
		n += 1 + sovNwsec(uint64(m.LogAction))
	}
	if m.AppData != nil {
		l = m.AppData.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityRule) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNwsec(uint64(m.RuleId))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if len(m.Appid) > 0 {
		for _, s := range m.Appid {
			l = len(s)
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if len(m.Rule) > 0 {
		for _, e := range m.Rule {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNwsec(uint64(m.RuleId))
	}
	if m.Priority != 0 {
		n += 1 + sovNwsec(uint64(m.Priority))
	}
	return n
}

func (m *SecurityPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if len(m.RuleStatus) > 0 {
		for _, e := range m.RuleStatus {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.PolicyStatus != nil {
		l = m.PolicyStatus.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNwsec(uint64(m.RuleId))
	}
	if m.NumHits != 0 {
		n += 9
	}
	if m.NumTcpHits != 0 {
		n += 9
	}
	if m.NumUdpHits != 0 {
		n += 9
	}
	if m.NumIcmpHits != 0 {
		n += 9
	}
	return n
}

func (m *SecurityPolicyStats) Size() (n int) {
	var l int
	_ = l
	if len(m.RuleStats) > 0 {
		for _, e := range m.RuleStats {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.PolStats != nil {
		l = m.PolStats.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityFlowGateFilter) Size() (n int) {
	var l int
	_ = l
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNwsec(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNwsec(uint64(m.DstPort))
	}
	if m.IpProto != 0 {
		n += 1 + sovNwsec(uint64(m.IpProto))
	}
	if m.VrfId != 0 {
		n += 9
	}
	if m.Alg != 0 {
		n += 1 + sovNwsec(uint64(m.Alg))
	}
	return n
}

func (m *SecurityFlowGateGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityFlowGateGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *FlowGateKey) Size() (n int) {
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovNwsec(uint64(m.Direction))
	}
	if m.SrcVrfId != 0 {
		n += 9
	}
	if m.DstVrfId != 0 {
		n += 9
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.IpProto != 0 {
		n += 1 + sovNwsec(uint64(m.IpProto))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNwsec(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNwsec(uint64(m.DstPort))
	}
	return n
}

func (m *SecurityFlowGateGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if m.FlowGateKey != nil {
		l = m.FlowGateKey.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	if m.Alg != 0 {
		n += 1 + sovNwsec(uint64(m.Alg))
	}
	if m.DeleteMarked {
		n += 2
	}
	if m.RefCount != 0 {
		n += 1 + sovNwsec(uint64(m.RefCount))
	}
	if m.TimeToAge != 0 {
		n += 1 + sovNwsec(uint64(m.TimeToAge))
	}
	return n
}

func (m *SecurityFlowGateGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityFlowGateDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovNwsec(uint64(l))
	}
	return n
}

func (m *SecurityFlowGateDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec(uint64(l))
		}
	}
	return n
}

func (m *SecurityFlowGateDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovNwsec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNwsec(x uint64) (n int) {
	return sovNwsec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdleTimeout", wireType)
			}
			m.SessionIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCnxnSetupTimeout", wireType)
			}
			m.TcpCnxnSetupTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCnxnSetupTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCloseTimeout", wireType)
			}
			m.TcpCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHalfClosedTimeout", wireType)
			}
			m.TcpHalfClosedTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHalfClosedTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpNormalizeTtl", wireType)
			}
			m.IpNormalizeTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpNormalizeTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDropTimeout", wireType)
			}
			m.TcpDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpDropTimeout", wireType)
			}
			m.UdpDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpDropTimeout", wireType)
			}
			m.IcmpDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTimeout", wireType)
			}
			m.DropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTimeout", wireType)
			}
			m.TcpTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpTimeout", wireType)
			}
			m.UdpTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpTimeout", wireType)
			}
			m.IcmpTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnxnTrackingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CnxnTrackingEn = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsgEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpsgEn = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRttEstimateEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpRttEstimateEn = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpNormalizationEn = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNormalizationEn = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpNormalizationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpNormalizationEn = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReassemblyEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpReassemblyEn = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtlChangeDetectEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpTtlChangeDetectEn = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSrcGuardEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpSrcGuardEn = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRsvdFlagsAction", wireType)
			}
			m.IpRsvdFlagsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpRsvdFlagsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDfAction", wireType)
			}
			m.IpDfAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDfAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOptionsAction", wireType)
			}
			m.IpOptionsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOptionsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInvalidLenAction", wireType)
			}
			m.IpInvalidLenAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInvalidLenAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSpoofPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpSpoofPktDrop = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLooseSrcRoutingPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpLooseSrcRoutingPktDrop = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMalformedOptionPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpMalformedOptionPktDrop = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRecordRouteOptionPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpRecordRouteOptionPktDrop = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpStrictSrcRoutingPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpStrictSrcRoutingPktDrop = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTsOptionPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpTsOptionPktDrop = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpUnknownOptionPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpUnknownOptionPktDrop = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpStreamIdOptionPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpStreamIdOptionPktDrop = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRsvdFldSetPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpRsvdFldSetPktDrop = bool(v != 0)
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpClearDfBit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpClearDfBit = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AnycastSrcDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6AnycastSrcDrop = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6V4CompatibleAddrDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6V4CompatibleAddrDrop = bool(v != 0)
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6NeedlessIpFragHdrDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6NeedlessIpFragHdrDrop = bool(v != 0)
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6InvalidOptionsPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6InvalidOptionsPktDrop = bool(v != 0)
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6RsvdFldSetPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6RsvdFldSetPktDrop = bool(v != 0)
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6RtgHdrPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6RtgHdrPktDrop = bool(v != 0)
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6DstOptionsHdrPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6DstOptionsHdrPktDrop = bool(v != 0)
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6HopByHopOptionsPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipv6HopByHopOptionsPktDrop = bool(v != 0)
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInvalidCodeAction", wireType)
			}
			m.IcmpInvalidCodeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInvalidCodeAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpDeprecatedMsgsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpDeprecatedMsgsDrop = bool(v != 0)
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpRedirectMsgDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpRedirectMsgDrop = bool(v != 0)
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpDstUnreachIgnorePayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpDstUnreachIgnorePayload = bool(v != 0)
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpParamPrblmIgnorePayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpParamPrblmIgnorePayload = bool(v != 0)
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpPktTooBigIgnorePayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpPktTooBigIgnorePayload = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpRedirectIgnorePayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpRedirectIgnorePayload = bool(v != 0)
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpTimeExceedIgnorePayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpTimeExceedIgnorePayload = bool(v != 0)
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpErrorDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpErrorDrop = bool(v != 0)
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpFragmentsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpFragmentsDrop = bool(v != 0)
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpLargePktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpLargePktDrop = bool(v != 0)
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpPingZeroIdDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpPingZeroIdDrop = bool(v != 0)
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpNeedFragSuppress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpNeedFragSuppress = bool(v != 0)
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpTimeExceedSuppress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IcmpTimeExceedSuppress = bool(v != 0)
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6LargeMsgMtuSmallDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Icmpv6LargeMsgMtuSmallDrop = bool(v != 0)
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSplitHandshakeDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpSplitHandshakeDrop = bool(v != 0)
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRsvdFlagsAction", wireType)
			}
			m.TcpRsvdFlagsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRsvdFlagsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedMssAction", wireType)
			}
			m.TcpUnexpectedMssAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedMssAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedWinScaleAction", wireType)
			}
			m.TcpUnexpectedWinScaleAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedWinScaleAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedSackPermAction", wireType)
			}
			m.TcpUnexpectedSackPermAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedSackPermAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgPtrNotSetAction", wireType)
			}
			m.TcpUrgPtrNotSetAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgPtrNotSetAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgFlagNotSetAction", wireType)
			}
			m.TcpUrgFlagNotSetAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgFlagNotSetAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgPayloadMissingAction", wireType)
			}
			m.TcpUrgPayloadMissingAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUrgPayloadMissingAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 79:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstWithDataAction", wireType)
			}
			m.TcpRstWithDataAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRstWithDataAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDataLenGtMssAction", wireType)
			}
			m.TcpDataLenGtMssAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDataLenGtMssAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 81:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDataLenGtWinSizeAction", wireType)
			}
			m.TcpDataLenGtWinSizeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDataLenGtWinSizeAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 82:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedTsOptionAction", wireType)
			}
			m.TcpUnexpectedTsOptionAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedTsOptionAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedEchoTsAction", wireType)
			}
			m.TcpUnexpectedEchoTsAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedEchoTsAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUnexpectedSackOptionAction", wireType)
			}
			m.TcpUnexpectedSackOptionAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpUnexpectedSackOptionAction |= (NormalizationAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTsNotPresentDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpTsNotPresentDrop = bool(v != 0)
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNonSynFirstPktDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNonSynFirstPktDrop = bool(v != 0)
		case 87:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpInvalidFlagsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpInvalidFlagsDrop = bool(v != 0)
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNonsynNoackDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNonsynNoackDrop = bool(v != 0)
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynWithDataDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpSynWithDataDrop = bool(v != 0)
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynAckWithDataDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpSynAckWithDataDrop = bool(v != 0)
		case 91:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOverlappingSegmentsDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpOverlappingSegmentsDrop = bool(v != 0)
		case 92:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpStripTimestampOption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpStripTimestampOption = bool(v != 0)
		case 93:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnTrackBypassWindowErr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpConnTrackBypassWindowErr = bool(v != 0)
		case 94:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnTrackFinRstDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpConnTrackFinRstDisable = bool(v != 0)
		case 95:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgFlagPtrClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpUrgFlagPtrClear = bool(v != 0)
		case 96:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNormalizeMss", wireType)
			}
			m.TcpNormalizeMss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpNormalizeMss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 97:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MulticastSrcDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MulticastSrcDrop = bool(v != 0)
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHalfOpenSessionLimit", wireType)
			}
			m.TcpHalfOpenSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHalfOpenSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpActiveSessionLimit", wireType)
			}
			m.UdpActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpActiveSessionLimit", wireType)
			}
			m.IcmpActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherActiveSessionLimit", wireType)
			}
			m.OtherActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyEnforceEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolicyEnforceEn = bool(v != 0)
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowLearnEn = bool(v != 0)
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDetectionEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppDetectionEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwSecProfileId", wireType)
			}
			m.HwSecProfileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwSecProfileId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileHandle", wireType)
			}
			m.ProfileHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecurityProfileStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProfilePdStatus = &SecurityProfileStatus_EpdStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecurityProfileStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProfilePdStatus = &SecurityProfileStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfileStatus == nil {
				m.ProfileStatus = &SecurityProfileStatus{}
			}
			if err := m.ProfileStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfileStatus == nil {
				m.ProfileStatus = &SecurityProfileStatus{}
			}
			if err := m.ProfileStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityProfileKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityProfileSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityProfileStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &Service_DstPort{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpMsgType", wireType)
			}
			var v ICMPMsgType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ICMPMsgType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &Service_IcmpMsgType{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svc = append(m.Svc, &Service{})
			if err := m.Svc[len(m.Svc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (FirewallAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Log = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSecurityPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSecurityPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSecurityPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFwRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFwRules = append(m.InFwRules, &FirewallRuleSpec{})
			if err := m.InFwRules[len(m.InFwRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgFwRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgFwRules = append(m.EgFwRules, &FirewallRuleSpec{})
			if err := m.EgFwRules[len(m.EgFwRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyRules == nil {
				m.PolicyRules = &NetworkSecurityPolicy{}
			}
			if err := m.PolicyRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyHandle", wireType)
			}
			m.PolicyHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityGroupPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityGroupPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNwsec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNwsec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityGroupKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityGroupGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityGroupSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityGroupStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityGroupGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppData_FTPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &AppData_FtpOptionInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppData_DNSOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &AppData_DnsOptionInfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsrpcOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppData_MSRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &AppData_MsrpcOptionInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SunRpcOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppData_SunRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &AppData_SunRpcOptionInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SipOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppData_SIPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &AppData_SipOptions{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceOpts == nil {
				m.TraceOpts = &AppData_TraceOptions{}
			}
			if err := m.TraceOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_TraceOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (AppData_TraceLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_FTPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMismatchIpAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMismatchIpAddress = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_DNSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQuestionPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQuestionPackets = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainNamePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainNamePackets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLongLabelPackets = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultizonePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultizonePackets = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgLength", wireType)
			}
			m.MaxMsgLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryResponseTimeout", wireType)
			}
			m.QueryResponseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryResponseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_RPCData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_MSRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &AppData_RPCData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_SunRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SunRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SunRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &AppData_RPCData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppData_SIPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctimeout", wireType)
			}
			m.Ctimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpCodePoint", wireType)
			}
			m.DscpCodePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DscpCodePoint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaInactivityTimeout", wireType)
			}
			m.MediaInactivityTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaInactivityTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCallDuration", wireType)
			}
			m.MaxCallDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCallDuration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1TimerValue", wireType)
			}
			m.T1TimerValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T1TimerValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T4TimerValue", wireType)
			}
			m.T4TimerValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T4TimerValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecAction", wireType)
			}
			m.SecAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecAction |= (SecurityAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogAction", wireType)
			}
			m.LogAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogAction |= (LogAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppData == nil {
				m.AppData = &AppData{}
			}
			if err := m.AppData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &SecurityRuleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appid = append(m.Appid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = append(m.Rule, &SecurityRule{})
			if err := m.Rule[len(m.Rule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleStatus = append(m.RuleStatus, &SecurityRuleStatus{})
			if err := m.RuleStatus[len(m.RuleStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyStatus == nil {
				m.PolicyStatus = &SecurityPolicyStatus{}
			}
			if err := m.PolicyStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityPolicyKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHits", wireType)
			}
			m.NumHits = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumHits = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpHits", wireType)
			}
			m.NumTcpHits = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumTcpHits = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpHits", wireType)
			}
			m.NumUdpHits = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumUdpHits = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIcmpHits", wireType)
			}
			m.NumIcmpHits = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumIcmpHits = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleStats = append(m.RuleStats, &SecurityRuleStats{})
			if err := m.RuleStats[len(m.RuleStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolStats == nil {
				m.PolStats = &SecurityPolicyStats{}
			}
			if err := m.PolStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProto", wireType)
			}
			m.IpProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProto |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			m.VrfId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &SecurityFlowGateFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityFlowGateGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowGateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowGateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowGateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (FlowDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcVrfId", wireType)
			}
			m.SrcVrfId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcVrfId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstVrfId", wireType)
			}
			m.DstVrfId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DstVrfId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProto", wireType)
			}
			m.IpProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProto |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowGateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowGateKey == nil {
				m.FlowGateKey = &FlowGateKey{}
			}
			if err := m.FlowGateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (ALGName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteMarked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteMarked = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCount", wireType)
			}
			m.RefCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToAge", wireType)
			}
			m.TimeToAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeToAge |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityFlowGateGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &SecurityFlowGateFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityFlowGateDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFlowGateDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFlowGateDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNwsec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNwsec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNwsec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNwsec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNwsec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNwsec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNwsec   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nwsec.proto", fileDescriptorNwsec) }

var fileDescriptorNwsec = []byte{
	// 5907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5c, 0xcb, 0x6f, 0x1b, 0x49,
	0x7a, 0x37, 0x25, 0x59, 0x8f, 0x4f, 0x2f, 0xaa, 0x2d, 0xc9, 0x14, 0x6d, 0x4b, 0x32, 0xed, 0xf1,
	0x78, 0xbd, 0x63, 0x8f, 0x2c, 0xdb, 0x1a, 0xdb, 0xf3, 0xb2, 0x44, 0x51, 0x36, 0x67, 0x44, 0x8a,
	0xd3, 0xa4, 0x5f, 0x33, 0x3b, 0xd3, 0xdb, 0xea, 0x2e, 0x52, 0xbd, 0x6a, 0x76, 0xf7, 0x76, 0x17,
	0x29, 0x6b, 0x92, 0xc3, 0x22, 0x40, 0x12, 0xe4, 0x75, 0xd8, 0x6c, 0x82, 0x3d, 0x04, 0x79, 0x03,
	0x0b, 0x04, 0x08, 0x92, 0x20, 0x39, 0xe4, 0x92, 0x4b, 0x6e, 0x39, 0x26, 0x97, 0x24, 0x27, 0x23,
	0xd8, 0x3f, 0xc1, 0x40, 0x8e, 0x41, 0x82, 0xaa, 0xae, 0xea, 0x37, 0xd9, 0x9c, 0x89, 0x94, 0xcd,
	0xc9, 0x62, 0xf7, 0xf7, 0xfd, 0xea, 0xab, 0xef, 0x55, 0xdf, 0x57, 0x55, 0x6d, 0x98, 0x34, 0x8e,
	0x1c, 0xa4, 0xdc, 0xb2, 0x6c, 0x13, 0x9b, 0xc2, 0x59, 0xfa, 0x23, 0x3f, 0x89, 0x8f, 0x2d, 0xe4,
	0xb8, 0xcf, 0xf2, 0xe3, 0x87, 0x07, 0xec, 0xaf, 0x29, 0x15, 0xe9, 0xd6, 0x81, 0xe6, 0xfe, 0x2a,
	0xfc, 0xf7, 0x36, 0x9c, 0xab, 0x23, 0xa5, 0x63, 0x6b, 0xf8, 0xb8, 0x66, 0x9b, 0x4d, 0x4d, 0x47,
	0x75, 0x0b, 0x29, 0x42, 0x0d, 0xa6, 0x0f, 0xd1, 0xb1, 0x64, 0xda, 0xd2, 0x81, 0x6c, 0xa8, 0x3a,
	0xca, 0x65, 0x56, 0x33, 0xd7, 0x27, 0xd7, 0x2f, 0xde, 0x3a, 0x3c, 0xb8, 0x15, 0xa1, 0xff, 0x14,
	0x1d, 0x3f, 0xa1, 0x34, 0x5b, 0x33, 0x6f, 0x5e, 0xaf, 0x40, 0x17, 0x19, 0x9a, 0x82, 0x1e, 0x1e,
	0xa2, 0x63, 0x71, 0xf2, 0x10, 0x1d, 0xef, 0xd9, 0xee, 0x4b, 0xe1, 0x05, 0xcc, 0x3b, 0xc8, 0x71,
	0x34, 0xd3, 0x90, 0x34, 0x55, 0x47, 0x12, 0xd6, 0xda, 0xc8, 0xec, 0xe0, 0xdc, 0xd0, 0x6a, 0xe6,
	0xfa, 0xf4, 0xd6, 0xb5, 0x37, 0xaf, 0x57, 0x0a, 0xb6, 0x6c, 0xb4, 0xd0, 0xc3, 0x3b, 0x6b, 0x37,
	0x6f, 0xbf, 0xb7, 0x7e, 0x7f, 0x6d, 0xed, 0x9d, 0x55, 0x86, 0xa5, 0xa2, 0xa6, 0xdc, 0xd1, 0xf1,
	0x87, 0x0f, 0xd6, 0x44, 0x81, 0x61, 0x94, 0x55, 0x1d, 0x35, 0x5c, 0x04, 0xe1, 0x19, 0x2c, 0x62,
	0xc5, 0x92, 0x14, 0xe3, 0x95, 0x21, 0x39, 0x08, 0x77, 0x2c, 0x0f, 0x7b, 0x98, 0x62, 0x5f, 0x7e,
	0xf3, 0x7a, 0xe5, 0x92, 0x8b, 0x7d, 0xfb, 0xe6, 0x46, 0x1c, 0xf6, 0xce, 0x9a, 0x78, 0x0e, 0x2b,
	0x56, 0xd1, 0x78, 0x65, 0xd4, 0x09, 0x3b, 0xc7, 0xad, 0xc2, 0x1c, 0xc5, 0xd5, 0x4d, 0xc7, 0x17,
	0x77, 0x84, 0x42, 0x16, 0xde, 0xbc, 0x5e, 0x59, 0xe6, 0x90, 0x77, 0x12, 0x44, 0xbd, 0x7d, 0x4f,
	0x9c, 0x25, 0x98, 0x84, 0x97, 0xe3, 0x7d, 0x09, 0xe7, 0x09, 0xde, 0x81, 0xac, 0x37, 0x5d, 0x50,
	0xd5, 0x43, 0x3d, 0x1b, 0x55, 0xc2, 0xed, 0x5e, 0x3a, 0xb8, 0xbd, 0xbe, 0x26, 0xce, 0x63, 0xc5,
	0x7a, 0x22, 0xeb, 0x4d, 0x8a, 0xae, 0x72, 0xf8, 0x4f, 0x21, 0xab, 0x59, 0x92, 0x61, 0xda, 0x6d,
	0x59, 0xd7, 0xbe, 0x46, 0x12, 0xc6, 0x7a, 0x6e, 0x34, 0xaa, 0x80, 0xb5, 0x9b, 0xeb, 0xf7, 0xee,
	0xc5, 0x40, 0xd7, 0xc4, 0x19, 0xcd, 0xaa, 0x72, 0xce, 0x06, 0xd6, 0x85, 0x5d, 0xc8, 0x12, 0x59,
	0x55, 0xdb, 0xf4, 0xb5, 0x39, 0x36, 0xd8, 0xd4, 0x1f, 0xac, 0x89, 0x33, 0x58, 0xb1, 0xb6, 0x6d,
	0xd3, 0xd3, 0xe4, 0x1e, 0x64, 0x3b, 0x6a, 0x04, 0x6d, 0x9c, 0xa2, 0xbd, 0xf5, 0xe6, 0xf5, 0xca,
	0xe5, 0x94, 0x29, 0x6f, 0xac, 0x89, 0x33, 0x1d, 0x35, 0x04, 0x58, 0x85, 0x39, 0x4d, 0x69, 0x47,
	0x10, 0x27, 0x06, 0x93, 0x6f, 0x63, 0x4d, 0x9c, 0x25, 0xcc, 0x41, 0xbc, 0x12, 0x4c, 0x85, 0xa0,
	0x60, 0x60, 0xa8, 0x49, 0x35, 0x00, 0xf3, 0x18, 0x26, 0x89, 0xd6, 0x38, 0xca, 0xe4, 0x37, 0xb2,
	0x2a, 0x60, 0xc5, 0x03, 0xda, 0x81, 0x49, 0xa2, 0x30, 0x0e, 0x34, 0x35, 0xb0, 0xae, 0xee, 0xac,
	0x89, 0xd0, 0x51, 0x03, 0x02, 0x4d, 0x51, 0x3d, 0x71, 0xa0, 0x69, 0x0a, 0x74, 0xf5, 0xcd, 0xeb,
	0x95, 0xd5, 0x34, 0xa5, 0x8b, 0x93, 0x84, 0x93, 0x03, 0x6d, 0x42, 0x96, 0xc6, 0x17, 0xb6, 0x65,
	0xe5, 0x50, 0x33, 0x5a, 0x12, 0x32, 0x72, 0x33, 0xab, 0x99, 0xeb, 0xe3, 0x5b, 0xe7, 0xdf, 0xbc,
	0x5e, 0x39, 0x17, 0x61, 0xc6, 0x76, 0x07, 0x89, 0x33, 0x84, 0xa1, 0xc1, 0xe8, 0x4b, 0x86, 0x70,
	0x1b, 0xc6, 0x34, 0xcb, 0xa1, 0x9c, 0xb3, 0x94, 0x33, 0xf7, 0xe6, 0xf5, 0xca, 0x7c, 0x84, 0xb3,
	0x29, 0xeb, 0x0e, 0x12, 0x47, 0x09, 0x61, 0xc9, 0x10, 0x1e, 0x03, 0x09, 0x4c, 0xc9, 0xc6, 0x58,
	0x42, 0x0e, 0xd6, 0xda, 0x32, 0x46, 0x84, 0x3d, 0x9b, 0xc2, 0x4e, 0x5c, 0x57, 0xc4, 0xb8, 0xc4,
	0x58, 0x5c, 0xa0, 0x40, 0x6c, 0xc8, 0x98, 0x64, 0x21, 0x64, 0xe4, 0xe6, 0xfa, 0xcf, 0x60, 0xce,
	0x0f, 0x0a, 0xca, 0x52, 0x32, 0x84, 0x32, 0x90, 0xe0, 0x8b, 0x23, 0x09, 0xfd, 0x91, 0x04, 0xac,
	0xc4, 0xa0, 0x3e, 0x85, 0x05, 0x6a, 0x9b, 0x18, 0xd6, 0xb9, 0xfe, 0x58, 0xe7, 0x08, 0x57, 0x14,
	0x6c, 0x8b, 0x06, 0xbf, 0x8d, 0x64, 0xc7, 0x41, 0xed, 0x7d, 0xfd, 0x98, 0xe0, 0xcc, 0xa7, 0xa8,
	0x69, 0x46, 0xb3, 0x44, 0x8f, 0xa1, 0x64, 0x08, 0x55, 0x38, 0xaf, 0x59, 0x24, 0x6d, 0x48, 0xca,
	0x01, 0x71, 0x0e, 0x49, 0x45, 0x18, 0x29, 0x98, 0x40, 0x2d, 0xa4, 0x40, 0x9d, 0xd3, 0xac, 0x06,
	0xd6, 0x8b, 0x94, 0x6d, 0x9b, 0x72, 0x95, 0x0c, 0xe1, 0x63, 0x98, 0xd5, 0x2c, 0xc9, 0xb1, 0x15,
	0xa9, 0xd5, 0x91, 0x6d, 0x95, 0xe0, 0x2c, 0xa6, 0xe0, 0x4c, 0x69, 0x56, 0xdd, 0x56, 0x1e, 0x13,
	0xf2, 0x92, 0x21, 0xfc, 0x66, 0x06, 0xe6, 0xc9, 0xac, 0x9c, 0xae, 0x2a, 0x35, 0x75, 0xb9, 0xe5,
	0x48, 0xb2, 0x42, 0xe6, 0x9b, 0x3b, 0xbf, 0x9a, 0xb9, 0x3e, 0xb3, 0x9e, 0xbf, 0xe5, 0xae, 0x7a,
	0x21, 0x5d, 0x6c, 0x52, 0x8a, 0xad, 0x0f, 0xdf, 0xbc, 0x5e, 0x79, 0x10, 0x19, 0xa2, 0x27, 0xf5,
	0xad, 0xea, 0x9e, 0x58, 0x91, 0x36, 0x8b, 0x8d, 0xf2, 0x5e, 0x55, 0xda, 0x16, 0xf7, 0x6a, 0xc4,
	0xf2, 0xa2, 0xd3, 0x55, 0x77, 0xc8, 0xa0, 0x2e, 0x8d, 0xf0, 0xcb, 0x30, 0xa5, 0x59, 0x92, 0xda,
	0xe4, 0x32, 0xe4, 0x52, 0x65, 0xf8, 0xe8, 0xcd, 0xeb, 0x95, 0x87, 0xdf, 0x4a, 0x86, 0xcd, 0xdd,
	0xdd, 0xbd, 0xe7, 0x22, 0x68, 0xd6, 0x76, 0x93, 0x8d, 0xfe, 0x6b, 0x19, 0x98, 0xd3, 0x2c, 0xc9,
	0xb4, 0xc8, 0x2f, 0x4f, 0x0f, 0x4b, 0xa7, 0x2e, 0xc3, 0xac, 0x66, 0xed, 0xb9, 0x63, 0x32, 0x41,
	0x7e, 0x3b, 0x03, 0x0b, 0x9a, 0x25, 0x69, 0x46, 0x57, 0xd6, 0x35, 0x55, 0xd2, 0x91, 0xc1, 0x85,
	0xc9, 0x9f, 0xa2, 0x51, 0x1a, 0x62, 0xb9, 0x22, 0x0a, 0x9a, 0x55, 0x76, 0x87, 0xdd, 0x45, 0x8c,
	0x48, 0x28, 0x52, 0xb5, 0x38, 0x96, 0x69, 0x36, 0x25, 0xeb, 0x10, 0xd3, 0x05, 0x21, 0x77, 0x21,
	0xdd, 0xf1, 0xeb, 0x84, 0xa3, 0x76, 0x88, 0xc9, 0x22, 0x20, 0xbc, 0x84, 0x4b, 0x9a, 0x25, 0xe9,
	0x26, 0x59, 0xe7, 0x89, 0xbb, 0xda, 0x66, 0x07, 0x93, 0x1c, 0xe7, 0x01, 0x5e, 0x4c, 0x01, 0xcc,
	0x69, 0xd6, 0x2e, 0xe1, 0xae, 0xdb, 0x8a, 0xe8, 0xf2, 0x72, 0xe8, 0x17, 0x70, 0x51, 0xb3, 0xa4,
	0xb6, 0xac, 0x37, 0x4d, 0xbb, 0x8d, 0x54, 0x66, 0x40, 0x1f, 0xf9, 0x52, 0x3a, 0x72, 0x85, 0x33,
	0xbb, 0x86, 0xe0, 0xc8, 0x5f, 0xc2, 0x0a, 0x8d, 0x78, 0xc5, 0xb4, 0x55, 0x2a, 0x31, 0x8a, 0x81,
	0x2f, 0xa7, 0x80, 0xe7, 0x49, 0x02, 0x20, 0xfc, 0x44, 0x68, 0x14, 0x86, 0xff, 0x02, 0x96, 0x89,
	0x62, 0xb1, 0xad, 0x29, 0x38, 0x59, 0x29, 0x2b, 0x29, 0xe8, 0x4b, 0x9a, 0x55, 0xa7, 0xec, 0x71,
	0xad, 0x7c, 0x42, 0x7d, 0x08, 0x3b, 0x31, 0x89, 0x57, 0x53, 0x30, 0xe7, 0x34, 0xab, 0xe1, 0x84,
	0x05, 0x6d, 0x40, 0x5e, 0xb3, 0xa4, 0x8e, 0x71, 0x68, 0x98, 0x47, 0x46, 0x0c, 0xf0, 0x72, 0x0a,
	0xe0, 0xa2, 0x66, 0x3d, 0x75, 0x59, 0xc3, 0xa8, 0xcf, 0xa9, 0xdd, 0x1c, 0x6c, 0x23, 0xb9, 0x2d,
	0x69, 0x71, 0xbb, 0x15, 0x52, 0x70, 0xcf, 0xd3, 0xc9, 0x23, 0xb9, 0x5d, 0x8e, 0x98, 0x6d, 0x0f,
	0x72, 0x7e, 0x4a, 0x53, 0x49, 0xbd, 0xea, 0x83, 0x5e, 0x49, 0xcf, 0xb2, 0x6e, 0x56, 0x52, 0xeb,
	0x08, 0x73, 0x40, 0x37, 0xcb, 0x2a, 0x3a, 0x92, 0x6d, 0x92, 0x9d, 0xf6, 0x35, 0x9c, 0xbb, 0x9a,
	0x9e, 0x65, 0x8b, 0x84, 0x7e, 0xbb, 0xb9, 0xa5, 0x61, 0xba, 0x0e, 0x59, 0xdd, 0x0d, 0x49, 0x36,
	0x8e, 0x15, 0xd9, 0x71, 0x8d, 0x4d, 0xc5, 0xb9, 0x9e, 0x02, 0x23, 0x10, 0xb6, 0x4d, 0x97, 0xab,
	0x6e, 0x2b, 0xbe, 0xbf, 0x77, 0x37, 0xa4, 0xee, 0x5d, 0x49, 0x31, 0xdb, 0x96, 0x8c, 0xb5, 0x7d,
	0x1d, 0x49, 0xb2, 0xaa, 0xda, 0x2e, 0xe6, 0x77, 0xd2, 0xfd, 0xbd, 0xbb, 0xf1, 0xec, 0x6e, 0xd1,
	0xe3, 0xdd, 0x54, 0x55, 0xdb, 0x77, 0xc8, 0xee, 0x86, 0x64, 0x20, 0xa4, 0xea, 0xc8, 0x71, 0x24,
	0xcd, 0x92, 0x9a, 0xb6, 0xdc, 0x92, 0x0e, 0x38, 0xf6, 0x8d, 0x74, 0x87, 0xec, 0x6e, 0x54, 0x19,
	0x7b, 0xd9, 0xda, 0xb1, 0xe5, 0xd6, 0x13, 0x06, 0xfe, 0x39, 0xc9, 0x00, 0xdd, 0x0d, 0x2f, 0xad,
	0xf1, 0x3c, 0xeb, 0x99, 0xe6, 0xbb, 0x83, 0x60, 0xb3, 0xec, 0xc4, 0x12, 0x26, 0x37, 0x50, 0x9d,
	0x38, 0x68, 0x77, 0xa3, 0x87, 0xcd, 0xdf, 0x49, 0x01, 0xa6, 0xb6, 0x89, 0x5b, 0xfd, 0x13, 0x66,
	0x34, 0x1b, 0xbb, 0x0a, 0xf0, 0xf0, 0x6e, 0xa6, 0x47, 0x50, 0x77, 0x43, 0xc4, 0x64, 0xe6, 0xa1,
	0xf4, 0xd7, 0xdd, 0x90, 0x54, 0x07, 0x7b, 0x13, 0x0f, 0x61, 0xde, 0x1a, 0xc4, 0x68, 0xdb, 0x0e,
	0x66, 0x13, 0x0f, 0x40, 0x7f, 0x05, 0xab, 0x14, 0xfa, 0xc0, 0xb4, 0xa4, 0xfd, 0x63, 0xfa, 0x4f,
	0x4c, 0xb5, 0xef, 0xa6, 0x67, 0xa9, 0xee, 0xc6, 0x13, 0xd3, 0xda, 0x3a, 0x7e, 0x62, 0x5a, 0x11,
	0xdd, 0xfe, 0x6e, 0x06, 0x72, 0xb4, 0x88, 0xe2, 0x86, 0x53, 0x4c, 0x15, 0xf1, 0x05, 0x69, 0xfd,
	0xb4, 0xab, 0x04, 0x5a, 0xbf, 0x31, 0xa3, 0x17, 0x4d, 0x15, 0xb1, 0x35, 0x49, 0x84, 0x25, 0xb7,
	0x39, 0x41, 0x96, 0x8d, 0x14, 0x19, 0x23, 0x55, 0x6a, 0x3b, 0x2d, 0xc7, 0x9d, 0xed, 0x9d, 0xfe,
	0xc5, 0xdd, 0x22, 0xed, 0x4c, 0x3c, 0xc6, 0x8a, 0xd3, 0x72, 0xe8, 0x44, 0x77, 0x81, 0xbe, 0x91,
	0x6c, 0xa4, 0x6a, 0x36, 0x29, 0xca, 0xda, 0x4e, 0xcb, 0x05, 0xbc, 0x3b, 0x40, 0xb5, 0x28, 0x32,
	0xae, 0x8a, 0xd3, 0x62, 0x66, 0x59, 0x71, 0x25, 0x74, 0xb0, 0xd4, 0x31, 0x6c, 0x24, 0x2b, 0x07,
	0x92, 0xd6, 0x32, 0x4c, 0x1b, 0x49, 0x96, 0x7c, 0xac, 0x9b, 0xb2, 0x9a, 0xbb, 0x97, 0x62, 0x95,
	0x0b, 0x54, 0x50, 0x07, 0x3f, 0x75, 0xd9, 0xcb, 0x94, 0xbb, 0xe6, 0x32, 0x7b, 0xf8, 0x96, 0x6c,
	0xcb, 0x6d, 0xc9, 0xb2, 0xf7, 0xf5, 0x76, 0x14, 0x7f, 0x63, 0x10, 0xfc, 0x1a, 0xe1, 0xaf, 0x11,
	0xf6, 0x30, 0xfe, 0x97, 0x1c, 0xff, 0x10, 0x4b, 0xd8, 0x34, 0xa5, 0x7d, 0xad, 0x15, 0xc5, 0x7f,
	0x2f, 0xd5, 0xab, 0x08, 0xfe, 0x21, 0x6e, 0x98, 0xe6, 0x96, 0xd6, 0x0a, 0xc3, 0xbf, 0x84, 0x8b,
	0x61, 0x65, 0x47, 0xb0, 0xef, 0xa7, 0x26, 0x83, 0x80, 0xce, 0x93, 0x35, 0x43, 0x1a, 0x32, 0x09,
	0xbd, 0x52, 0x10, 0x52, 0xa3, 0xe8, 0x0f, 0x06, 0xd1, 0x0c, 0xe9, 0xcb, 0x4a, 0x94, 0x3d, 0x8c,
	0xff, 0x08, 0x68, 0x6f, 0x2b, 0x21, 0xdb, 0x36, 0x59, 0x5a, 0x7c, 0x98, 0x82, 0x37, 0x4d, 0x18,
	0x4a, 0x84, 0x9e, 0xfa, 0xc6, 0x13, 0xa0, 0x2e, 0x43, 0x73, 0x6b, 0x1b, 0x19, 0x98, 0xf9, 0xed,
	0xfb, 0xa9, 0x79, 0x45, 0x69, 0xd3, 0x94, 0x4a, 0x79, 0x28, 0xd2, 0x63, 0x86, 0xa4, 0xcb, 0x76,
	0x0b, 0xf9, 0xf1, 0xfe, 0x41, 0x5a, 0xf7, 0x46, 0x98, 0x76, 0x09, 0x0f, 0x8f, 0x72, 0xee, 0xfc,
	0x16, 0xa9, 0x3f, 0xbe, 0x46, 0xb6, 0x49, 0x56, 0x64, 0x8a, 0xf5, 0x61, 0xea, 0x12, 0x45, 0xac,
	0xac, 0x19, 0xad, 0xcf, 0x91, 0x6d, 0x96, 0x55, 0xb6, 0x02, 0x9f, 0x77, 0xfb, 0x2e, 0xa2, 0x7b,
	0xba, 0x82, 0x38, 0x1d, 0xcb, 0xb2, 0x91, 0xe3, 0xe4, 0x3e, 0x4a, 0x81, 0x9b, 0xa7, 0xad, 0x17,
	0x42, 0x2a, 0x99, 0x68, 0x9d, 0x71, 0x09, 0x75, 0x16, 0xef, 0x41, 0x9b, 0x7a, 0x90, 0x1f, 0xa7,
	0x16, 0x20, 0x21, 0x6b, 0x7a, 0xa0, 0xcc, 0xc5, 0xbb, 0x1b, 0x4c, 0x7d, 0x24, 0xde, 0xdb, 0xb8,
	0x23, 0x39, 0x6d, 0x59, 0xd7, 0xdd, 0xc9, 0x3f, 0x1a, 0xc4, 0xc5, 0xbb, 0x1b, 0x54, 0x95, 0x15,
	0xa7, 0x55, 0xc1, 0x9d, 0x3a, 0x61, 0xa6, 0x4a, 0xf8, 0x0c, 0x72, 0xa4, 0x8f, 0x75, 0x2c, 0x5d,
	0xc3, 0x74, 0x8b, 0xcf, 0x39, 0x90, 0x0f, 0x91, 0x8b, 0xfb, 0x38, 0x6d, 0x49, 0xc2, 0x8a, 0x55,
	0x27, 0x8c, 0x4f, 0x38, 0x1f, 0x85, 0x24, 0x9d, 0x01, 0xed, 0xd6, 0x63, 0xed, 0xda, 0x93, 0xd3,
	0x4e, 0xc4, 0xa4, 0xbd, 0x8e, 0xf6, 0x6b, 0xbf, 0x9f, 0x81, 0x25, 0x22, 0x4e, 0xc7, 0x40, 0xaf,
	0x2c, 0xa4, 0xb8, 0x59, 0xd8, 0x13, 0xa9, 0x7c, 0x8a, 0x9d, 0x53, 0xbd, 0x21, 0x96, 0x6b, 0xe2,
	0x22, 0x56, 0xac, 0xa7, 0xde, 0xd8, 0x15, 0x87, 0xcb, 0xf5, 0x27, 0x19, 0x58, 0x89, 0xc8, 0x75,
	0xa4, 0x19, 0x92, 0xa3, 0xc8, 0xba, 0xb7, 0x72, 0x7d, 0x72, 0xea, 0xd2, 0x5d, 0x08, 0x49, 0xf7,
	0x5c, 0x33, 0xea, 0x64, 0xfc, 0xde, 0x22, 0x3a, 0xb2, 0x72, 0x28, 0x59, 0xc8, 0x6e, 0x73, 0x11,
	0x3f, 0xfd, 0x3f, 0x16, 0xb1, 0x2e, 0x2b, 0x87, 0x35, 0x64, 0xb7, 0x7d, 0xeb, 0xe6, 0xa9, 0x88,
	0x76, 0x4b, 0xb2, 0xb0, 0x2d, 0x19, 0x26, 0xa6, 0x75, 0x15, 0x93, 0x6e, 0xf7, 0x14, 0xa5, 0x13,
	0x4b, 0xf5, 0x52, 0x83, 0x06, 0xc1, 0x53, 0xbb, 0x55, 0xc3, 0x76, 0xd5, 0xc4, 0x75, 0x84, 0x99,
	0x5c, 0x3f, 0xcd, 0xc0, 0x05, 0x2e, 0x17, 0x89, 0x81, 0xa8, 0x60, 0x95, 0x53, 0x17, 0x6c, 0xd1,
	0x15, 0x8c, 0x84, 0x42, 0x48, 0xb2, 0x3f, 0xca, 0xc0, 0xb2, 0xa7, 0x31, 0x77, 0xb5, 0x90, 0xda,
	0x9a, 0xe3, 0x90, 0x9c, 0xca, 0x84, 0xab, 0x9e, 0xba, 0x70, 0x79, 0xa6, 0x35, 0x77, 0xfc, 0x8a,
	0x3b, 0x3c, 0x13, 0xf0, 0xc7, 0x19, 0x37, 0x27, 0xd9, 0x0e, 0x96, 0x8e, 0x34, 0x7c, 0x20, 0xa9,
	0x32, 0x96, 0xb9, 0x68, 0x7b, 0xa7, 0x9d, 0x42, 0xe6, 0x69, 0x0a, 0xc1, 0xcf, 0x35, 0x7c, 0xb0,
	0x2d, 0x63, 0x99, 0xc9, 0xf4, 0x7b, 0xcc, 0xcd, 0xa8, 0x28, 0x3a, 0x32, 0xa4, 0x16, 0x0e, 0x66,
	0x91, 0xda, 0x69, 0x6f, 0x79, 0x10, 0x2f, 0x23, 0xe2, 0xec, 0x22, 0xe3, 0x31, 0xf6, 0x73, 0xc8,
	0x1f, 0xb2, 0x00, 0x0d, 0x8a, 0x45, 0x93, 0x88, 0xf6, 0xb5, 0x97, 0x43, 0x3e, 0x3b, 0x6d, 0xd9,
	0x96, 0x82, 0xb2, 0x91, 0x0c, 0xa2, 0x7d, 0xdd, 0x27, 0x81, 0xf8, 0xcd, 0x3e, 0x93, 0x4f, 0x3c,
	0x75, 0x67, 0x0b, 0x27, 0x10, 0xbe, 0x6f, 0xc0, 0x44, 0xfc, 0x83, 0x0c, 0x5c, 0x8a, 0x88, 0x88,
	0x94, 0x03, 0x93, 0xc8, 0xc9, 0x04, 0xac, 0x9f, 0xb6, 0xcb, 0x2d, 0x85, 0xe4, 0x2b, 0x29, 0x07,
	0x66, 0x83, 0x1b, 0xf8, 0xcf, 0x33, 0x70, 0x39, 0x29, 0x03, 0x87, 0x55, 0xd8, 0x38, 0x6d, 0x09,
	0x2f, 0xc5, 0x52, 0x70, 0x48, 0x87, 0x15, 0xf7, 0x40, 0x0b, 0x3b, 0x34, 0xcb, 0x91, 0xba, 0x05,
	0x19, 0xac, 0xc8, 0x7b, 0x9a, 0xd2, 0x95, 0x60, 0xc5, 0x6a, 0x38, 0x55, 0x13, 0xd7, 0x5c, 0x26,
	0x5a, 0x40, 0x88, 0x6e, 0xac, 0x19, 0xa6, 0x21, 0x39, 0xc7, 0x86, 0xd4, 0xd4, 0x48, 0x26, 0xf0,
	0xca, 0xc6, 0x67, 0xfd, 0x11, 0x17, 0xe8, 0x0e, 0xbb, 0x51, 0x3f, 0x36, 0x76, 0x08, 0x5f, 0xa0,
	0x74, 0x24, 0x98, 0xbc, 0x3d, 0x74, 0xcb, 0x12, 0x8a, 0xf7, 0x3c, 0x5d, 0x42, 0xd6, 0xda, 0xd1,
	0xaa, 0x82, 0x77, 0xdd, 0x4c, 0x42, 0x22, 0xa0, 0x61, 0x12, 0x93, 0x50, 0xb0, 0x17, 0x83, 0x6c,
	0xff, 0x13, 0xa6, 0x2a, 0xe1, 0x09, 0x4a, 0x46, 0x80, 0xfc, 0x6c, 0x47, 0xc1, 0x5e, 0xa6, 0x15,
	0xb5, 0xa4, 0xfe, 0x3a, 0x36, 0x78, 0xaa, 0xe2, 0x9b, 0x0c, 0x1c, 0x8d, 0x08, 0x15, 0x41, 0xfc,
	0x7c, 0x90, 0x8a, 0xee, 0xd8, 0xd8, 0x54, 0x0e, 0x43, 0xa0, 0x5f, 0xb8, 0x21, 0x62, 0x76, 0x91,
	0xad, 0xcb, 0x16, 0xad, 0xbe, 0x1d, 0x14, 0x6c, 0x0a, 0xbe, 0x48, 0xab, 0x40, 0xb1, 0x62, 0xed,
	0xf9, 0xdc, 0x75, 0x14, 0xe8, 0x0e, 0x9e, 0x32, 0x89, 0xb1, 0xad, 0xb9, 0xa5, 0xb3, 0x83, 0xe5,
	0x36, 0xdf, 0x1e, 0xc8, 0x7d, 0x2f, 0x6d, 0x7f, 0x8d, 0x48, 0x4c, 0x58, 0x1b, 0x9c, 0xd3, 0xf5,
	0x4c, 0x41, 0x82, 0x55, 0x7a, 0x68, 0x6b, 0x1a, 0xec, 0xb0, 0x4a, 0xda, 0x3f, 0xb6, 0x64, 0xc7,
	0x21, 0xf9, 0x51, 0x35, 0x8f, 0x48, 0x63, 0x94, 0xfb, 0x32, 0xad, 0xc3, 0xc2, 0x8a, 0x55, 0x34,
	0x0d, 0xf7, 0xf0, 0x6a, 0x8b, 0xb2, 0x3f, 0xa7, 0xdc, 0x25, 0xdb, 0x16, 0xbe, 0x70, 0x97, 0xd1,
	0xc0, 0x00, 0x4d, 0xcd, 0xa0, 0x8b, 0x96, 0xaa, 0x39, 0xf2, 0xbe, 0x8e, 0x72, 0x5f, 0xa5, 0xb5,
	0x87, 0x41, 0xf8, 0x1d, 0xcd, 0x10, 0x1d, 0xbc, 0xed, 0xb2, 0x72, 0xa7, 0xf0, 0xaa, 0x07, 0x52,
	0xda, 0xd0, 0xad, 0xbd, 0x9c, 0x34, 0x80, 0x53, 0xb0, 0x65, 0xbf, 0x86, 0x6d, 0xba, 0xbd, 0xc7,
	0x0f, 0xb0, 0xfd, 0x23, 0xe1, 0xb6, 0xe3, 0xe4, 0xbe, 0x1f, 0x3d, 0xda, 0x5c, 0xbb, 0xf9, 0x60,
	0xfd, 0xf6, 0x46, 0xc2, 0x99, 0xf0, 0x6c, 0xe0, 0xd0, 0x0a, 0x55, 0x1c, 0x47, 0x28, 0x81, 0xd0,
	0xee, 0xe8, 0x58, 0x0b, 0x6f, 0x13, 0xca, 0xfd, 0x7d, 0x3f, 0xeb, 0xb1, 0xf0, 0x3d, 0x42, 0xd1,
	0x2d, 0x91, 0xe8, 0x39, 0xb8, 0x69, 0x21, 0x43, 0xe2, 0xf7, 0x02, 0x74, 0xad, 0xad, 0xe1, 0xdc,
	0x3e, 0x15, 0x70, 0xfe, 0xcd, 0xeb, 0x95, 0x6c, 0x4c, 0xa4, 0xf3, 0xec, 0xe4, 0x7b, 0xcf, 0x42,
	0x46, 0xdd, 0xe5, 0xda, 0x25, 0x4c, 0x42, 0x05, 0x72, 0x1d, 0xd5, 0xa2, 0x89, 0xb1, 0x8b, 0x22,
	0x80, 0x4a, 0x1f, 0xc0, 0x85, 0x8e, 0x6a, 0x6d, 0x52, 0xa6, 0x10, 0xdc, 0x1e, 0x6b, 0xe9, 0x12,
	0xf1, 0xd4, 0x3e, 0x78, 0xb4, 0x9d, 0x4b, 0x00, 0xfc, 0x0c, 0xf2, 0x26, 0x3e, 0x40, 0x76, 0x32,
	0x22, 0xea, 0x37, 0x65, 0xca, 0x97, 0x00, 0x59, 0x84, 0x39, 0xcb, 0xd4, 0x35, 0xe5, 0x58, 0x42,
	0x46, 0xd3, 0xb4, 0x15, 0x7a, 0x34, 0xda, 0xec, 0x6f, 0x8c, 0x59, 0x97, 0xa3, 0xe4, 0x32, 0x94,
	0x0c, 0xe1, 0x03, 0x98, 0x6e, 0xea, 0xe6, 0x91, 0x44, 0xfc, 0x85, 0x1e, 0x3e, 0xb6, 0x52, 0xfc,
	0x6c, 0x92, 0x90, 0xef, 0x12, 0x6a, 0xf7, 0xd4, 0x51, 0xb6, 0x2c, 0x76, 0x4e, 0xc8, 0x4e, 0x2f,
	0x0f, 0xd2, 0x0e, 0x5f, 0x64, 0xcb, 0xda, 0xe6, 0x0c, 0x25, 0xa3, 0xf0, 0x19, 0x2c, 0x45, 0x2e,
	0x94, 0x88, 0xe8, 0x87, 0x1d, 0xe4, 0xe0, 0x8a, 0xd3, 0x12, 0xee, 0xc2, 0x98, 0xed, 0xfe, 0xca,
	0x65, 0x56, 0x87, 0xaf, 0x4f, 0x7a, 0x8b, 0x5d, 0xc2, 0x9d, 0x15, 0x91, 0x93, 0x16, 0x4a, 0x90,
	0x8b, 0xbe, 0xc7, 0x32, 0xee, 0x38, 0x25, 0x4b, 0x15, 0xbe, 0x03, 0x73, 0x07, 0x47, 0x92, 0x83,
	0x14, 0xc9, 0x72, 0x5f, 0x49, 0x9a, 0x4a, 0x2f, 0xb7, 0x4c, 0x8b, 0x33, 0x07, 0x47, 0x75, 0xa4,
	0x30, 0x8e, 0xb2, 0x5a, 0xc8, 0xf7, 0x80, 0x29, 0x5a, 0x6a, 0xe1, 0xdf, 0x32, 0xb0, 0x90, 0xf8,
	0x52, 0x78, 0x0b, 0x66, 0x38, 0x72, 0xe0, 0xea, 0xcc, 0xa8, 0x38, 0xcd, 0x9e, 0xb2, 0xeb, 0x30,
	0x8f, 0x00, 0x90, 0xa5, 0x4a, 0x0e, 0x65, 0xa2, 0x97, 0x60, 0x26, 0xd7, 0x57, 0x7a, 0x4c, 0x8e,
	0x0b, 0xff, 0xe4, 0x8c, 0x38, 0x81, 0x2c, 0x95, 0x0d, 0xf4, 0x08, 0x40, 0xf1, 0x11, 0x86, 0xd3,
	0x11, 0x8a, 0x2e, 0x82, 0xc2, 0x11, 0xb6, 0xce, 0xc1, 0x1c, 0x17, 0xd5, 0x03, 0x2a, 0xfc, 0x2c,
	0x03, 0xe7, 0x63, 0x06, 0x71, 0x2c, 0xd3, 0x70, 0x90, 0xb0, 0x03, 0x20, 0x5b, 0x1a, 0x1f, 0x32,
	0x43, 0xcb, 0x8f, 0xec, 0x2d, 0xf7, 0x9e, 0xd1, 0xa6, 0xa5, 0x31, 0xd8, 0x85, 0x37, 0xaf, 0x57,
	0xe6, 0x98, 0xed, 0x7d, 0x72, 0x71, 0x42, 0xe6, 0x14, 0x42, 0xd1, 0xd7, 0x51, 0x48, 0x01, 0x17,
	0xfb, 0x89, 0xef, 0x69, 0xd0, 0xfd, 0x59, 0x78, 0x01, 0xf9, 0x1e, 0x72, 0x12, 0xcf, 0x79, 0x08,
	0xe3, 0x36, 0xfb, 0xc9, 0x5c, 0x67, 0x39, 0x19, 0x9c, 0x33, 0x89, 0x1e, 0x7d, 0xc1, 0x82, 0x8b,
	0x11, 0xa2, 0x6d, 0xa4, 0x23, 0xcc, 0x1d, 0xf3, 0xe4, 0x2f, 0x47, 0x15, 0xbe, 0x0f, 0x2b, 0xfd,
	0x46, 0x24, 0x13, 0xfa, 0x30, 0x1a, 0x0a, 0x57, 0x92, 0xe7, 0x13, 0x62, 0xf4, 0x63, 0xe2, 0x2f,
	0x33, 0x70, 0xa9, 0x07, 0xe5, 0xff, 0x47, 0xe3, 0xaa, 0xb0, 0xda, 0x57, 0x5a, 0xa2, 0x91, 0x47,
	0x31, 0x13, 0x5f, 0xed, 0xaf, 0x92, 0x98, 0xa1, 0xdb, 0xb1, 0xdc, 0xf3, 0x18, 0xe1, 0xd3, 0xb3,
	0xf2, 0xe7, 0x31, 0xbf, 0xf2, 0x87, 0x73, 0x7d, 0x36, 0x62, 0xe2, 0xd5, 0xe4, 0xf9, 0xf8, 0x5c,
	0xbe, 0x7d, 0x17, 0x61, 0x3e, 0x41, 0xb1, 0x4e, 0xe1, 0xbf, 0x32, 0xb1, 0x30, 0xa1, 0xec, 0x27,
	0x6c, 0xf4, 0x5b, 0x30, 0xe2, 0x58, 0x48, 0x61, 0xa6, 0xee, 0x97, 0xa5, 0x29, 0x9d, 0x70, 0x17,
	0x46, 0x43, 0x89, 0xab, 0xbf, 0x73, 0x30, 0x5a, 0xe1, 0x36, 0x9c, 0x25, 0x7f, 0x39, 0xf4, 0x16,
	0xde, 0xe4, 0xfa, 0x85, 0xde, 0x4c, 0x8e, 0xe8, 0x52, 0x16, 0xbe, 0x8a, 0xb9, 0x7d, 0x60, 0xfa,
	0x6e, 0x5c, 0x45, 0xbd, 0xe8, 0x72, 0x1f, 0xad, 0xc7, 0x5c, 0xe8, 0x1f, 0x33, 0x30, 0x56, 0x47,
	0x76, 0x57, 0x53, 0x90, 0xb0, 0x0e, 0x93, 0x9a, 0x25, 0xd1, 0x8b, 0x95, 0x8a, 0xa9, 0x33, 0x6d,
	0xce, 0x31, 0x6d, 0x96, 0x6b, 0x35, 0xf6, 0x42, 0x04, 0xcd, 0xe2, 0x7f, 0x0b, 0x17, 0x60, 0x5c,
	0x25, 0x6d, 0x8e, 0x69, 0xb3, 0xab, 0x90, 0x4f, 0xce, 0x88, 0x63, 0xaa, 0x83, 0x6b, 0xa6, 0x8d,
	0x85, 0xfb, 0x40, 0x37, 0xe7, 0xe9, 0xe6, 0x2f, 0x41, 0xa1, 0xca, 0x9a, 0x59, 0x17, 0x38, 0x64,
	0xb1, 0x52, 0xab, 0x38, 0xad, 0xc6, 0xb1, 0x85, 0x9e, 0x9c, 0x71, 0xef, 0x6b, 0xb1, 0x9f, 0xc2,
	0x2a, 0x0c, 0xcb, 0x7a, 0x8b, 0xea, 0x69, 0x66, 0x7d, 0x86, 0x4d, 0x68, 0x73, 0xf7, 0x71, 0x55,
	0x6e, 0x23, 0x91, 0xbc, 0xda, 0x9a, 0x80, 0x31, 0xfd, 0xae, 0xa4, 0x19, 0x4d, 0xb3, 0xf0, 0x1b,
	0x19, 0xc8, 0xee, 0x68, 0x36, 0x3a, 0x92, 0x75, 0x5d, 0xec, 0xb0, 0x1b, 0xa0, 0xab, 0x30, 0xec,
	0x74, 0x89, 0x41, 0x89, 0x4a, 0x66, 0x3c, 0x95, 0xd0, 0x99, 0x8a, 0xe4, 0x95, 0x20, 0xc0, 0x88,
	0x6c, 0x59, 0xc4, 0x82, 0xc3, 0xd7, 0x27, 0x44, 0xfa, 0xb7, 0x70, 0x13, 0x46, 0x59, 0x73, 0xea,
	0x0e, 0xbd, 0xc0, 0x18, 0x39, 0xbc, 0xdb, 0x39, 0x8a, 0x8c, 0x48, 0xc8, 0xc2, 0xb0, 0x6e, 0xb6,
	0xe8, 0xf5, 0xc7, 0x71, 0x91, 0xfc, 0x49, 0x64, 0x59, 0xa8, 0x22, 0x7c, 0x64, 0xda, 0x87, 0x9e,
	0xfe, 0x69, 0xcd, 0x22, 0xbc, 0x07, 0x93, 0x9a, 0x21, 0x35, 0x8f, 0x24, 0xbb, 0xa3, 0x23, 0x87,
	0xd9, 0xea, 0x7c, 0x04, 0x9f, 0x8b, 0x2f, 0x4e, 0x68, 0xc6, 0xce, 0x11, 0xf9, 0xe5, 0x10, 0x46,
	0xd4, 0xf2, 0x19, 0x87, 0x52, 0x18, 0x51, 0x8b, 0x31, 0x16, 0xfe, 0x26, 0xb0, 0x14, 0x3e, 0xb6,
	0xcd, 0x8e, 0xe5, 0x4a, 0x42, 0xd5, 0xd3, 0x48, 0xce, 0x0e, 0xab, 0xc1, 0xec, 0x10, 0xe0, 0x19,
	0xf0, 0x92, 0xec, 0xc7, 0x30, 0xc5, 0x6a, 0x3a, 0x2e, 0x6b, 0x30, 0x38, 0x12, 0xf5, 0x22, 0x4e,
	0xba, 0x1c, 0xae, 0xc8, 0x2f, 0x7d, 0x77, 0x0f, 0x8c, 0x1e, 0xc8, 0x31, 0xf7, 0xa3, 0x39, 0x26,
	0xba, 0x2c, 0x46, 0x26, 0xea, 0x67, 0x98, 0x47, 0x7e, 0xb2, 0x0c, 0xd2, 0xb8, 0x91, 0x79, 0x05,
	0xa6, 0x99, 0xe0, 0xa1, 0xa2, 0x87, 0xcd, 0x86, 0xe5, 0xbf, 0x3f, 0xce, 0xc0, 0x85, 0x44, 0xe9,
	0x4e, 0x38, 0x19, 0xdd, 0xf7, 0x92, 0xcb, 0x10, 0x33, 0x4a, 0xef, 0x29, 0x86, 0x12, 0x4c, 0xe1,
	0xfb, 0xb0, 0xdc, 0x47, 0x40, 0xa2, 0xbf, 0x8f, 0x62, 0xe9, 0xa2, 0xd0, 0x1b, 0x3d, 0x21, 0x5f,
	0xbc, 0xf2, 0x17, 0xb6, 0x00, 0x61, 0xb8, 0xbe, 0x38, 0x15, 0xdf, 0x2a, 0x1c, 0xc0, 0x95, 0xb4,
	0x91, 0xc9, 0x04, 0x37, 0xa3, 0x0e, 0xf2, 0x76, 0xef, 0xf9, 0xf5, 0xa8, 0x35, 0x0e, 0xe1, 0x72,
	0x1f, 0xe2, 0x93, 0x35, 0x76, 0x41, 0x87, 0xab, 0xa9, 0x83, 0x91, 0x79, 0x6d, 0xc7, 0x0c, 0x77,
	0x3d, 0x7d, 0x62, 0x31, 0xf3, 0x75, 0x12, 0xe3, 0x2b, 0x50, 0x35, 0x9c, 0x8e, 0xed, 0xf6, 0x13,
	0xbd, 0x26, 0x5c, 0x3d, 0x7c, 0x14, 0x35, 0xdc, 0xd5, 0xde, 0xf3, 0x4b, 0xaa, 0x20, 0x02, 0xed,
	0x4e, 0x24, 0x40, 0x9c, 0xc2, 0xef, 0x0c, 0x25, 0x06, 0xc6, 0x69, 0x54, 0x12, 0xeb, 0xa1, 0x4a,
	0x22, 0x2d, 0x3b, 0xb9, 0xd5, 0xc4, 0xfd, 0x48, 0x35, 0x31, 0x70, 0xc0, 0x0b, 0xf7, 0xc2, 0x15,
	0xc5, 0x4a, 0x7f, 0x46, 0xaf, 0xaa, 0xf8, 0x69, 0x26, 0xd1, 0xc5, 0x23, 0xa5, 0xc5, 0x66, 0xcc,
	0xe5, 0xde, 0x4a, 0x31, 0x49, 0xd4, 0xdf, 0x84, 0x77, 0x43, 0x5a, 0x1d, 0x4a, 0xd6, 0x6a, 0x30,
	0x1c, 0x7e, 0x9c, 0x81, 0xb9, 0x10, 0x3a, 0x5d, 0xad, 0xae, 0xc1, 0x48, 0x05, 0x61, 0x99, 0x39,
	0xa3, 0x70, 0x8b, 0x7d, 0x03, 0xb2, 0xb7, 0xff, 0x03, 0xa4, 0x60, 0xf2, 0x46, 0xa4, 0xef, 0x85,
	0x6a, 0xd4, 0x7b, 0x79, 0x3d, 0x17, 0xf5, 0xde, 0xc1, 0xfc, 0xf6, 0xe1, 0xc8, 0x8f, 0x7e, 0x5a,
	0xc8, 0x14, 0x2a, 0x91, 0x65, 0x34, 0xe0, 0xb4, 0xeb, 0x51, 0xa7, 0xcd, 0x25, 0x69, 0x28, 0xbc,
	0x10, 0xfd, 0x24, 0xe3, 0x7f, 0xb3, 0xe2, 0xbe, 0x76, 0x6d, 0xf9, 0x8b, 0x9d, 0xe4, 0x4f, 0x02,
	0x3b, 0x02, 0x6c, 0x96, 0x27, 0x1e, 0x19, 0xe1, 0x65, 0x2d, 0x9f, 0xa8, 0xaa, 0xf0, 0x82, 0xd6,
	0x88, 0x04, 0x75, 0xd0, 0x3d, 0xef, 0xc7, 0xdc, 0xf3, 0x62, 0x12, 0x62, 0x42, 0x16, 0xd4, 0xfd,
	0x9e, 0x82, 0x92, 0x84, 0x97, 0xaf, 0x6a, 0x72, 0x0a, 0xfc, 0xb6, 0xfa, 0x2d, 0x7c, 0x2f, 0x92,
	0x73, 0x63, 0x4b, 0xd6, 0xfb, 0x51, 0x27, 0xba, 0x9c, 0x34, 0x8f, 0x1e, 0x8b, 0xd5, 0x41, 0x24,
	0xb3, 0xc5, 0x57, 0x8e, 0xa8, 0xfd, 0x86, 0xbf, 0xe5, 0x4a, 0xa5, 0x45, 0xc2, 0x20, 0xb0, 0x6a,
	0x9c, 0xb4, 0xca, 0x9e, 0x45, 0x0c, 0x14, 0x5e, 0x29, 0x06, 0xab, 0x01, 0x93, 0xd6, 0x88, 0x79,
	0x10, 0x62, 0xde, 0xe6, 0x14, 0xfe, 0x33, 0x13, 0xf1, 0xb2, 0xd3, 0x58, 0x17, 0xde, 0x09, 0xad,
	0x0b, 0xbd, 0xd3, 0x84, 0xbb, 0x22, 0xac, 0x47, 0x56, 0x84, 0x01, 0x62, 0x45, 0x78, 0x37, 0xbc,
	0x16, 0x2c, 0xf5, 0x62, 0xf1, 0x56, 0x81, 0xdf, 0x8a, 0xd6, 0xb3, 0x91, 0xfc, 0xff, 0x7e, 0x2c,
	0xc0, 0x56, 0x7a, 0x2a, 0xfa, 0x7f, 0x9f, 0xf9, 0xff, 0x76, 0x0a, 0xc6, 0x36, 0x2d, 0x7a, 0x24,
	0xcb, 0xdb, 0xbf, 0x4c, 0xcf, 0xf6, 0x4f, 0x28, 0xc2, 0x6c, 0x13, 0xf3, 0xe3, 0x16, 0xda, 0x06,
	0x32, 0xcd, 0xf2, 0x69, 0x33, 0xa8, 0x5b, 0x3b, 0x8d, 0x1a, 0xbf, 0xd7, 0x79, 0x46, 0x9c, 0x6e,
	0x62, 0x76, 0xd0, 0x52, 0x36, 0x9a, 0x26, 0x01, 0x51, 0x0d, 0x27, 0x04, 0x32, 0x9c, 0x08, 0xb2,
	0x5d, 0xad, 0x07, 0x40, 0x54, 0xc3, 0x09, 0x80, 0x94, 0x61, 0xae, 0xed, 0xd8, 0x96, 0x12, 0x82,
	0x09, 0x37, 0xf8, 0x1c, 0xa6, 0x52, 0x17, 0x6b, 0x45, 0x1f, 0x68, 0x96, 0xf2, 0x05, 0xa0, 0x2a,
	0x70, 0xce, 0xe9, 0x18, 0x52, 0x14, 0xec, 0x6c, 0xa8, 0x8b, 0xe2, 0x60, 0xf5, 0x8e, 0x11, 0x42,
	0xcb, 0x3a, 0x1d, 0x43, 0x0c, 0xc1, 0x7d, 0x00, 0x93, 0x8e, 0xff, 0xd1, 0x05, 0xfd, 0x98, 0x2e,
	0x3e, 0xb5, 0x7a, 0x39, 0xa0, 0x1f, 0x70, 0xbc, 0xef, 0x25, 0x84, 0xcb, 0x30, 0x15, 0xfa, 0xd0,
	0x91, 0x7e, 0x3e, 0x27, 0x4e, 0x6a, 0x81, 0x2f, 0x17, 0x1f, 0x02, 0x60, 0x5b, 0x56, 0xe8, 0xcd,
	0x7d, 0x87, 0x7e, 0x11, 0x17, 0x9f, 0x73, 0x83, 0x10, 0x30, 0x4c, 0x71, 0x02, 0xb3, 0x5f, 0x4e,
	0xfe, 0x63, 0x98, 0x0a, 0xbe, 0x22, 0xde, 0xab, 0xa3, 0x2e, 0xe2, 0xdb, 0x0e, 0x4b, 0x49, 0x30,
	0xbb, 0x84, 0x40, 0x74, 0xe9, 0xf2, 0x8f, 0x01, 0x7c, 0xdb, 0x0a, 0x0f, 0x60, 0x49, 0xd6, 0x75,
	0xf3, 0x48, 0x6a, 0x6b, 0x4e, 0x5b, 0xc6, 0xca, 0x81, 0xa4, 0x59, 0xf4, 0xde, 0x36, 0x72, 0xdc,
	0xa8, 0x1d, 0x17, 0x17, 0x29, 0x41, 0x85, 0xbd, 0x2f, 0x5b, 0x9b, 0xee, 0xdb, 0xfc, 0xbf, 0x0f,
	0x01, 0xf8, 0x06, 0x16, 0x3e, 0x84, 0x0b, 0xf4, 0x5b, 0x3a, 0x7a, 0xee, 0x23, 0xd1, 0xbc, 0x41,
	0xaf, 0xce, 0xcb, 0xca, 0x21, 0xc2, 0x1c, 0x2b, 0x47, 0x48, 0x2a, 0x84, 0xe2, 0x33, 0x46, 0x50,
	0x73, 0xdf, 0x0b, 0x5b, 0xb0, 0x4c, 0xd9, 0xdd, 0x6b, 0x6f, 0xaa, 0xd9, 0x96, 0x35, 0x43, 0x32,
	0xe4, 0x36, 0xf2, 0x10, 0x86, 0x28, 0x42, 0x9e, 0x50, 0xd1, 0xbb, 0x6d, 0xdb, 0x94, 0x86, 0xb8,
	0x36, 0xc7, 0xb8, 0x07, 0xe7, 0x5d, 0x0c, 0xd3, 0x68, 0x49, 0xba, 0xbc, 0x8f, 0x74, 0x8f, 0x79,
	0x98, 0x32, 0xcf, 0x53, 0x66, 0xd3, 0x68, 0xed, 0x92, 0x97, 0x9c, 0xed, 0x2e, 0x2c, 0xfa, 0x92,
	0x7f, 0x6d, 0x1a, 0xfe, 0x90, 0x23, 0x3e, 0x57, 0x85, 0xbf, 0xe4, 0x5c, 0x57, 0x61, 0xa6, 0x2d,
	0xbf, 0xa2, 0x7b, 0x34, 0x3a, 0x32, 0x5a, 0xf8, 0xc0, 0xfd, 0x9a, 0x53, 0x9c, 0x6a, 0xcb, 0xaf,
	0x2a, 0x4e, 0x6b, 0x97, 0x3e, 0x23, 0xd8, 0x3f, 0xec, 0x20, 0xfb, 0x58, 0xe2, 0x01, 0xee, 0xf9,
	0x05, 0xfd, 0x46, 0x53, 0x9c, 0xa7, 0x6f, 0x79, 0x1e, 0x60, 0x0e, 0x92, 0xff, 0x14, 0xc6, 0xc4,
	0x5a, 0x91, 0x86, 0xf4, 0x25, 0x00, 0xcb, 0x36, 0x5b, 0x36, 0xfd, 0x1e, 0x81, 0x6a, 0x71, 0x42,
	0x9c, 0x60, 0x4f, 0xca, 0x6a, 0xcc, 0xdb, 0x86, 0x62, 0xde, 0x96, 0x7f, 0x08, 0x53, 0xc1, 0x00,
	0x12, 0x6e, 0xc0, 0x88, 0x2a, 0xd3, 0x7a, 0x89, 0xa4, 0xa6, 0xc5, 0x88, 0xc3, 0xb0, 0x71, 0x45,
	0x4a, 0x93, 0x7f, 0x1f, 0xa6, 0x43, 0xf1, 0xf2, 0x8d, 0x98, 0x7f, 0x65, 0x08, 0xc0, 0x0f, 0x13,
	0x21, 0x0f, 0xe3, 0x0a, 0x17, 0xd3, 0x3d, 0x79, 0xf1, 0x7e, 0x0b, 0xd7, 0x60, 0x56, 0x75, 0xe8,
	0xf1, 0xaa, 0x8a, 0x24, 0xcb, 0xd4, 0x0c, 0x3e, 0x93, 0x69, 0xf2, 0xb8, 0x68, 0xaa, 0xa8, 0x46,
	0x1e, 0x0a, 0xf7, 0x21, 0xd7, 0x46, 0xaa, 0x26, 0x4b, 0x9a, 0x41, 0x4f, 0xd4, 0x34, 0x7c, 0x1c,
	0xfe, 0xea, 0x57, 0x5c, 0xa4, 0xef, 0xcb, 0xde, 0x6b, 0x1e, 0x73, 0x37, 0x60, 0x8e, 0x98, 0x4b,
	0xa1, 0xd7, 0x28, 0x3b, 0xb6, 0xec, 0x6d, 0x56, 0x4d, 0x8b, 0xb3, 0x6d, 0xf9, 0x55, 0x51, 0xd6,
	0xf5, 0x6d, 0xf6, 0x98, 0x98, 0x16, 0xdf, 0xa6, 0xb8, 0xb6, 0xd4, 0x95, 0xf5, 0x0e, 0xe2, 0xa6,
	0xc5, 0xb7, 0x09, 0x9c, 0xfd, 0x8c, 0x3c, 0xa3, 0x54, 0x77, 0x43, 0x54, 0xa3, 0x8c, 0xea, 0xae,
	0x4f, 0x55, 0xf8, 0xd5, 0x0c, 0x80, 0x1f, 0x84, 0xc2, 0x3c, 0x64, 0x1b, 0xe2, 0x66, 0xb1, 0x24,
	0xed, 0x96, 0x9e, 0x95, 0x76, 0xa5, 0xea, 0x5e, 0xb5, 0x94, 0x3d, 0x23, 0x2c, 0xc0, 0x5c, 0xf0,
	0xe9, 0x96, 0x58, 0x2e, 0xed, 0x64, 0x33, 0xc2, 0x22, 0x08, 0xc1, 0xc7, 0xdb, 0xa5, 0xc6, 0x66,
	0x79, 0x37, 0x3b, 0x24, 0x2c, 0xc1, 0x42, 0xf0, 0x79, 0xe9, 0x45, 0xa3, 0x54, 0xad, 0x97, 0x9f,
	0x95, 0xb2, 0xc3, 0xc2, 0x79, 0x38, 0x17, 0x7c, 0xf5, 0xac, 0x24, 0x6e, 0xed, 0xd5, 0x4b, 0xd9,
	0x91, 0xad, 0x29, 0x80, 0x4d, 0x8b, 0x27, 0xa9, 0xc2, 0xcf, 0x32, 0xfe, 0x8a, 0x2e, 0x76, 0xbc,
	0x1b, 0x80, 0x77, 0x01, 0x1c, 0xa4, 0xf0, 0x7b, 0x26, 0x99, 0xd0, 0x56, 0x1e, 0x27, 0x67, 0x5b,
	0x79, 0x13, 0x0e, 0x52, 0x18, 0xd7, 0xbb, 0x00, 0xba, 0xe9, 0xdd, 0x26, 0xe3, 0x4b, 0x96, 0xcb,
	0xb5, 0x6b, 0xb6, 0x38, 0x83, 0xce, 0xff, 0x14, 0xbe, 0x03, 0xe3, 0xf4, 0xfc, 0x90, 0x38, 0x92,
	0xbb, 0x70, 0xcc, 0x84, 0x1d, 0x49, 0x1c, 0x93, 0xdd, 0x3f, 0x0a, 0x7f, 0x95, 0x81, 0xa9, 0xa0,
	0xa0, 0xc2, 0x4d, 0x18, 0xb3, 0x3b, 0xfe, 0xf1, 0xdd, 0x48, 0xe8, 0xf8, 0xb4, 0x2d, 0x1b, 0xaa,
	0x8c, 0x4d, 0xfb, 0x58, 0x1c, 0x25, 0x44, 0x65, 0x55, 0xb8, 0x06, 0x67, 0x69, 0xda, 0x62, 0xab,
	0x1c, 0x5f, 0x49, 0x09, 0x54, 0x85, 0x3c, 0x17, 0xdd, 0xd7, 0xc2, 0x6d, 0x6f, 0x03, 0x73, 0x38,
	0xb1, 0x0a, 0xf0, 0x95, 0xe4, 0x6d, 0x62, 0xce, 0xc3, 0x59, 0xd9, 0xb2, 0x34, 0x35, 0x37, 0x42,
	0x37, 0x42, 0xdd, 0x1f, 0x85, 0x7f, 0x08, 0x68, 0x36, 0xb0, 0x6f, 0x38, 0x68, 0x93, 0xb2, 0x97,
	0xdc, 0xa4, 0x5c, 0x08, 0x9d, 0x3e, 0x7c, 0x93, 0xad, 0xc5, 0xb7, 0x61, 0x84, 0xa8, 0x82, 0xee,
	0xd6, 0x4e, 0xae, 0x9f, 0x4b, 0x98, 0x96, 0x48, 0x09, 0x58, 0x3b, 0xb3, 0x17, 0x38, 0xfc, 0x8c,
	0xee, 0x21, 0xde, 0x89, 0xd6, 0x8f, 0x51, 0x25, 0x25, 0x6d, 0x1f, 0x96, 0xc3, 0x8e, 0xc6, 0xaa,
	0xba, 0xf3, 0x11, 0x2b, 0x7a, 0xf6, 0xca, 0xc3, 0xb8, 0x65, 0x6b, 0x26, 0x21, 0xa7, 0x53, 0x1f,
	0x11, 0xbd, 0xdf, 0x85, 0x7f, 0xc9, 0x04, 0x0e, 0x3b, 0x82, 0xbb, 0x90, 0xbf, 0x30, 0xe5, 0x3e,
	0x84, 0x49, 0x3a, 0x0d, 0xaf, 0xe6, 0x1c, 0xee, 0xe1, 0x3a, 0xac, 0x6c, 0x03, 0xdb, 0xfb, 0x9b,
	0xe9, 0xfb, 0xcf, 0x32, 0xb0, 0x18, 0x55, 0xf8, 0x09, 0x57, 0xd0, 0x8f, 0xbc, 0x3d, 0xda, 0x50,
	0x1b, 0x79, 0x21, 0xd9, 0x78, 0x2e, 0x3b, 0xdb, 0xc0, 0x65, 0x25, 0xe6, 0xb3, 0xc0, 0x79, 0x59,
	0x6c, 0x67, 0xf4, 0x41, 0xac, 0xda, 0xbd, 0x94, 0x88, 0x9c, 0xd0, 0x4f, 0x1a, 0x7e, 0x1d, 0x9d,
	0xb4, 0x1f, 0xba, 0x97, 0xdc, 0x1d, 0x7d, 0x6b, 0x73, 0x15, 0xbe, 0xf2, 0x7b, 0xbe, 0x1e, 0xbb,
	0xa0, 0x1f, 0x44, 0x5d, 0xbc, 0x90, 0x38, 0x97, 0x1e, 0x3d, 0x65, 0x33, 0x70, 0xd0, 0x77, 0x9a,
	0x7b, 0x9f, 0xfb, 0x81, 0x63, 0xe3, 0x1e, 0xdb, 0x9e, 0x1f, 0xc7, 0xac, 0x72, 0xa5, 0xef, 0x4c,
	0x62, 0xb6, 0x39, 0x8c, 0x26, 0x82, 0x40, 0xdb, 0x7a, 0xe2, 0x86, 0x79, 0x11, 0x75, 0x84, 0x70,
	0xe3, 0xfa, 0x20, 0x6a, 0x95, 0x95, 0xc4, 0xb9, 0x24, 0x75, 0xae, 0x7f, 0x1d, 0xd8, 0x17, 0xe3,
	0x81, 0xd8, 0x27, 0xfd, 0x2c, 0xc1, 0xb8, 0xd1, 0x69, 0x4b, 0x07, 0x1a, 0xab, 0x37, 0x47, 0xc5,
	0x31, 0xa3, 0xd3, 0x7e, 0xa2, 0x61, 0x47, 0x58, 0x85, 0x29, 0xf2, 0x8a, 0x5e, 0x61, 0xd2, 0x58,
	0x45, 0x39, 0x2a, 0x82, 0xd1, 0x69, 0x37, 0x14, 0x2b, 0x48, 0xd1, 0x51, 0x19, 0xc5, 0x88, 0x47,
	0xf1, 0x54, 0x75, 0x29, 0x0a, 0x30, 0x4d, 0x28, 0xe8, 0xe1, 0x1e, 0x25, 0x39, 0x4b, 0x49, 0x26,
	0x8d, 0x4e, 0xbb, 0xac, 0xb4, 0x29, 0x4d, 0xa1, 0x1a, 0xf8, 0x9f, 0x59, 0xfc, 0x1d, 0x48, 0xe1,
	0x3d, 0x00, 0x2f, 0xd5, 0x38, 0x3d, 0x36, 0xcd, 0xbc, 0x09, 0x8a, 0x13, 0x3c, 0xd1, 0x38, 0x85,
	0x1f, 0x0d, 0x45, 0xa3, 0xf7, 0x34, 0xda, 0xf4, 0x9b, 0xa1, 0x36, 0xbd, 0xcf, 0xc2, 0xe0, 0xf6,
	0xe9, 0x77, 0x22, 0x7d, 0x7a, 0xdf, 0x64, 0xc4, 0x1b, 0xf5, 0xf7, 0x60, 0xc2, 0x32, 0x75, 0x29,
	0xd8, 0xac, 0xe7, 0x7b, 0xf2, 0x39, 0xe2, 0xb8, 0x65, 0xea, 0xae, 0x0a, 0xbe, 0x17, 0x8d, 0xcb,
	0x48, 0xc3, 0xfe, 0x41, 0x2c, 0x58, 0x56, 0x7b, 0x3b, 0x58, 0x2c, 0x52, 0x7e, 0x7d, 0xc8, 0x4f,
	0xe1, 0x3b, 0xba, 0x79, 0xf4, 0x58, 0xc6, 0x68, 0x47, 0xd3, 0x31, 0xb2, 0x85, 0xb7, 0x61, 0xd4,
	0xb1, 0x15, 0x49, 0xb3, 0x58, 0x84, 0x64, 0xbd, 0x43, 0x61, 0xd6, 0x44, 0x89, 0x67, 0x1d, 0x5b,
	0x29, 0x5b, 0x84, 0x50, 0x75, 0x30, 0x21, 0x1c, 0xea, 0x45, 0xa8, 0x3a, 0xb8, 0x6c, 0x11, 0x07,
	0x25, 0x88, 0xf4, 0xdc, 0xd8, 0x2d, 0x78, 0xc7, 0x1c, 0x5b, 0xa1, 0xa7, 0xc6, 0x4b, 0x81, 0x23,
	0x65, 0xb7, 0xb0, 0xf5, 0x0e, 0x94, 0xdf, 0x81, 0x71, 0x7e, 0x42, 0x4d, 0x5d, 0x2e, 0xf1, 0x78,
	0x7a, 0x8c, 0x1d, 0x4f, 0x0b, 0x0b, 0x30, 0xda, 0xb5, 0x9b, 0x24, 0x38, 0x46, 0xa9, 0x7b, 0x9e,
	0xed, 0xda, 0xcd, 0xb2, 0xca, 0x37, 0x17, 0xc6, 0x7a, 0x6e, 0x2e, 0x14, 0xea, 0xfe, 0xf6, 0x13,
	0x57, 0x44, 0x20, 0x6b, 0xdc, 0x83, 0xd1, 0x26, 0x55, 0x0b, 0x53, 0x46, 0x74, 0x99, 0x08, 0xeb,
	0x4e, 0x64, 0xc4, 0xc1, 0x6d, 0xc0, 0x38, 0xe8, 0x40, 0xdb, 0x80, 0x71, 0x36, 0x3f, 0x3f, 0xfc,
	0xdd, 0x10, 0x4c, 0xf2, 0xf7, 0x9f, 0xa2, 0x63, 0x61, 0x1d, 0x26, 0xdc, 0xef, 0xf7, 0xfc, 0x02,
	0x78, 0x9e, 0xa9, 0x8a, 0x90, 0x6d, 0xf3, 0x77, 0xa2, 0x4f, 0x26, 0x5c, 0x04, 0x20, 0x36, 0x61,
	0x3a, 0x73, 0xd3, 0x06, 0xb1, 0xd2, 0x33, 0xaa, 0xb6, 0x8b, 0x00, 0xc4, 0x2c, 0xec, 0xad, 0x9b,
	0x35, 0x88, 0xa1, 0xdc, 0xb7, 0xbe, 0x87, 0x8c, 0x0c, 0xea, 0x21, 0x67, 0xfb, 0x7b, 0x48, 0xd0,
	0xd6, 0xa3, 0xa9, 0xb6, 0x0e, 0xfa, 0xd3, 0x58, 0x6f, 0x7f, 0x1a, 0x0f, 0xf9, 0x53, 0xe1, 0x4f,
	0x87, 0xfc, 0x84, 0x1d, 0xd2, 0xee, 0x09, 0x67, 0x95, 0x0d, 0x76, 0x4d, 0xb1, 0x25, 0x63, 0x24,
	0x1d, 0xa2, 0x63, 0x16, 0x1d, 0x02, 0x3f, 0xc4, 0xf7, 0x0d, 0xe7, 0x5e, 0x50, 0xe4, 0x56, 0x64,
	0xae, 0x3a, 0xdc, 0x7b, 0x1f, 0xec, 0x0a, 0x4c, 0xab, 0x74, 0xe9, 0x93, 0xda, 0xb2, 0x7d, 0x88,
	0x54, 0xd6, 0xea, 0x4f, 0xb9, 0x0f, 0x2b, 0xf4, 0x99, 0x70, 0x01, 0x26, 0x6c, 0xd4, 0x94, 0x14,
	0xb3, 0x63, 0xb0, 0xff, 0xab, 0x89, 0x84, 0x7d, 0xb3, 0x48, 0x7e, 0x0b, 0xcb, 0x30, 0x49, 0xbf,
	0xfc, 0xc3, 0xa6, 0x24, 0xb7, 0x78, 0xef, 0x37, 0x41, 0x1e, 0x35, 0xcc, 0xcd, 0x16, 0x2a, 0xfc,
	0x38, 0xe3, 0x57, 0x1b, 0x09, 0x3a, 0x22, 0x9e, 0xfb, 0xee, 0x20, 0x6a, 0x0a, 0xea, 0x23, 0x78,
	0x0a, 0x3d, 0x94, 0x58, 0x9f, 0x24, 0x8c, 0x14, 0x48, 0x55, 0xcf, 0xe2, 0xb1, 0x14, 0x2e, 0xb9,
	0xbe, 0x65, 0x8c, 0x06, 0xce, 0x29, 0x13, 0x71, 0x07, 0x3a, 0xa7, 0x4c, 0xe4, 0xf4, 0x23, 0xf5,
	0x8a, 0x7f, 0xf4, 0x16, 0xa5, 0xf4, 0x34, 0x7a, 0xc3, 0x80, 0x73, 0x09, 0x5f, 0x38, 0x90, 0xae,
	0x3b, 0xf8, 0x91, 0x83, 0xdf, 0x75, 0xc7, 0xfe, 0xe7, 0x93, 0x6c, 0x26, 0x4a, 0xbc, 0x2d, 0xee,
	0xd5, 0xb2, 0x43, 0xd1, 0xa7, 0xa5, 0xed, 0x72, 0x23, 0x3b, 0x7c, 0xe3, 0x5f, 0x33, 0x30, 0xc6,
	0xfc, 0x4a, 0xc8, 0xc2, 0xd4, 0x66, 0xad, 0x26, 0xd5, 0x9f, 0x15, 0xf9, 0x00, 0x81, 0x27, 0x8d,
	0x9d, 0x46, 0x2d, 0x9b, 0x11, 0x66, 0x61, 0x92, 0x3f, 0x21, 0x0f, 0x86, 0x82, 0x0f, 0xb6, 0xab,
	0xf5, 0xec, 0x70, 0xf0, 0x41, 0xbd, 0x5c, 0xcb, 0x8e, 0x08, 0xe7, 0x60, 0xd6, 0x7b, 0xf0, 0xb4,
	0x2a, 0x89, 0xb5, 0x62, 0xf6, 0x2c, 0x91, 0x86, 0x3f, 0xac, 0xd4, 0x77, 0x1a, 0xf4, 0xe9, 0x68,
	0x70, 0x3c, 0xb1, 0x51, 0xaf, 0x65, 0xc7, 0x84, 0x45, 0x10, 0x3c, 0x09, 0xc4, 0xcd, 0x62, 0x49,
	0xdc, 0x7b, 0xda, 0x28, 0x65, 0xc7, 0x85, 0x19, 0x00, 0xfe, 0xbc, 0x5c, 0xcb, 0x4e, 0x04, 0x47,
	0xdd, 0xac, 0xbe, 0xcc, 0xc2, 0x8d, 0x5f, 0x82, 0x99, 0xf0, 0xdd, 0x1d, 0x21, 0x07, 0xf3, 0x3b,
	0x65, 0xb1, 0xf4, 0x7c, 0x73, 0x77, 0x37, 0xa2, 0xc7, 0x25, 0x58, 0x88, 0xbe, 0xe1, 0xba, 0x4c,
	0x60, 0xda, 0x2e, 0x55, 0x5f, 0x66, 0x87, 0x84, 0x3c, 0x2c, 0x46, 0xdf, 0x88, 0xa5, 0x4f, 0x4a,
	0x45, 0xa2, 0xd5, 0xbf, 0xcf, 0xc0, 0x4c, 0x78, 0xbb, 0x41, 0xb8, 0x04, 0x4b, 0xf5, 0x52, 0xf1,
	0xa9, 0x58, 0x6e, 0xbc, 0x94, 0xc4, 0xa7, 0xbb, 0xa5, 0x88, 0x08, 0xcb, 0x90, 0x4f, 0x7c, 0xcd,
	0xe5, 0xe8, 0xc5, 0xce, 0x84, 0x59, 0x81, 0x0b, 0x89, 0xaf, 0xb9, 0x44, 0xc2, 0x35, 0x28, 0x24,
	0x12, 0x94, 0x2b, 0xb5, 0xdd, 0x72, 0xb1, 0xdc, 0x70, 0x81, 0x46, 0x6e, 0xb4, 0x61, 0xc2, 0xdb,
	0xf1, 0x10, 0xa6, 0x60, 0x7c, 0x77, 0xef, 0x31, 0x17, 0x31, 0x07, 0xf3, 0xe4, 0xd7, 0x5e, 0x55,
	0xaa, 0x97, 0xea, 0x75, 0xf7, 0x7b, 0xc7, 0x4d, 0xb1, 0xe1, 0x6e, 0xf3, 0x44, 0xde, 0x94, 0xaa,
	0xdb, 0xd9, 0x21, 0x61, 0x15, 0x2e, 0x26, 0x71, 0x48, 0x9b, 0xd5, 0x6d, 0x4a, 0x31, 0xbc, 0xfe,
	0x17, 0x33, 0x00, 0xd5, 0x23, 0xae, 0x2a, 0xe1, 0xab, 0xd8, 0xe5, 0xe4, 0xa2, 0x8d, 0x64, 0x8c,
	0x84, 0xd5, 0x5e, 0x77, 0x60, 0x79, 0x74, 0xe6, 0x2f, 0xf7, 0xbf, 0x25, 0x5b, 0x71, 0x5a, 0x85,
	0x33, 0x09, 0xf8, 0x4f, 0x2d, 0xf5, 0x04, 0xf1, 0x7f, 0x10, 0xc3, 0x77, 0x23, 0x5c, 0xb8, 0x36,
	0xc0, 0x9d, 0x57, 0x32, 0xca, 0xdb, 0x83, 0x5c, 0x04, 0x75, 0xc7, 0x92, 0x03, 0xdb, 0x34, 0xde,
	0x45, 0x3f, 0xe1, 0x4a, 0xda, 0xcd, 0x4b, 0x32, 0xca, 0xd5, 0xd4, 0x8b, 0x82, 0x7c, 0x3a, 0x49,
	0x37, 0xa7, 0x98, 0x49, 0xae, 0xf6, 0xbb, 0x3e, 0xe4, 0x0d, 0xf5, 0x56, 0xfa, 0x25, 0xa3, 0x7e,
	0x63, 0x31, 0xf3, 0x9c, 0xf0, 0x58, 0xdd, 0xc4, 0xb1, 0x98, 0xa9, 0x6e, 0x0c, 0x78, 0x6d, 0x88,
	0x8c, 0xf8, 0xdd, 0x41, 0x6f, 0xe2, 0xb8, 0xe3, 0xb6, 0xfd, 0x3a, 0x3b, 0x7c, 0x81, 0x42, 0x78,
	0x7b, 0x90, 0x2b, 0x2f, 0x64, 0xc4, 0xeb, 0x03, 0x5d, 0xc4, 0x70, 0x87, 0x7b, 0x11, 0xb9, 0x6e,
	0xc0, 0x0c, 0xb7, 0x9c, 0x7c, 0x58, 0xee, 0x0d, 0xb1, 0xd2, 0xef, 0x30, 0x3d, 0x19, 0x99, 0x99,
	0xe9, 0x04, 0x90, 0xd5, 0x08, 0x32, 0x33, 0xca, 0xd5, 0xd4, 0x83, 0xf1, 0x9e, 0x0e, 0x90, 0x64,
	0x88, 0x2f, 0x20, 0x1b, 0x3d, 0xc9, 0x14, 0x2e, 0xf7, 0x3f, 0x4b, 0x26, 0xf8, 0x85, 0x94, 0x53,
	0x50, 0x0e, 0x1e, 0xd9, 0xe4, 0x63, 0x7a, 0x5f, 0xe9, 0xb1, 0xab, 0xe4, 0xc1, 0xaf, 0xf6, 0xdd,
	0x76, 0xea, 0x01, 0xce, 0x54, 0x7f, 0x22, 0xe0, 0xad, 0x28, 0x38, 0xd3, 0xfe, 0x5b, 0xe9, 0x7b,
	0x48, 0x64, 0x88, 0x6b, 0x03, 0x6c, 0xd0, 0xf0, 0x3c, 0x3c, 0x17, 0x6b, 0x4c, 0x85, 0x42, 0xca,
	0x9e, 0x08, 0x19, 0xe2, 0x4a, 0x5a, 0x5b, 0x1b, 0xf3, 0xa2, 0x40, 0x3d, 0x29, 0x5c, 0x4d, 0xed,
	0xab, 0x92, 0xbc, 0x28, 0xb9, 0xf6, 0x0d, 0x87, 0x73, 0xb8, 0xa0, 0x8b, 0x85, 0x73, 0xaf, 0x9a,
	0x32, 0x16, 0xce, 0x3d, 0x0b, 0xc3, 0xc2, 0x99, 0xad, 0xc5, 0x7f, 0xfa, 0xf9, 0x72, 0xe6, 0x9f,
	0x7f, 0xbe, 0x9c, 0xf9, 0x8f, 0x9f, 0x2f, 0x67, 0x3e, 0x1f, 0x3f, 0x90, 0x75, 0xda, 0x23, 0xed,
	0x8f, 0xd2, 0x7f, 0xee, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x14, 0xaf, 0x38, 0xb9, 0x4c,
	0x57, 0x00, 0x00,
}
