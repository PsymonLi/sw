// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

/*
	Package halproto is a generated protocol buffer package.

	It is generated from these files:
		types.proto
		kh.proto
		endpoint.proto
		eplearn.proto
		event.proto
		events.proto
		fwlog.proto
		interface.proto
		l2segment.proto
		multicast.proto
		nwsec.proto
		port.proto
		qos.proto
		system.proto
		telemetry.proto
		vrf.proto

	It has these top-level messages:
		ObjectMeta
		MplsTag
		EncapInfo
		IPAddress
		IPRange
		IPPrefix
		IPSubnet
		AddressRange
		Address
		IPAddressObj
		L4PortRange
		Empty
		DropReasons
		EgressDropReasons
		RuleMatch
		SecurityProfileKeyHandle
		CollectorKeyHandle
		ExportControlKeyHandle
		FlowMonitorRuleKeyHandle
		DropMonitorRuleKeyHandle
		MirrorSessionKeyHandle
		VrfKeyHandle
		NetworkKey
		NetworkKeyHandle
		NexthopKeyHandle
		RouteKey
		RouteKeyHandle
		L2SegmentKeyHandle
		SecurityPolicyKey
		SecurityPolicyKeyHandle
		SecurityGroupPolicyId
		SecurityGroupPolicyKeyHandle
		SecurityGroupKeyHandle
		PortKeyHandle
		LifKeyHandle
		InterfaceKeyHandle
		EndpointL2Key
		EndpointL3Key
		EndpointKey
		EndpointKeyHandle
		FilterKey
		FilterKeyHandle
		MulticastEntryKeyIP
		MulticastEntryKeyMac
		MulticastEntryKey
		MulticastEntryKeyHandle
		AclKeyHandle
		GftExactMatchProfileKeyHandle
		GftHeaderTranspositionProfileKeyHandle
		GftExactMatchFlowEntryKeyHandle
		NatPoolKey
		NatPoolKeyHandle
		NATPolicyKey
		NatPolicyKeyHandle
		Svc
		NatMappingKeyHandle
		IPSecRuleKey
		IpsecRuleKeyHandle
		IpsecSAEncryptKeyHandle
		IpsecSADecryptKeyHandle
		TcpProxyRuleKey
		TcpProxyRuleKeyHandle
		QosClassKeyHandle
		CoppKeyHandle
		AppKeyHandle
		EndpointAttributes
		EndpointSpec
		EndpointRequestMsg
		EndpointIpAddress
		EndpointStatusEpd
		EndpointStatusCpd
		EndpointStatus
		EndpointResponse
		EndpointResponseMsg
		EndpointUpdateRequest
		EndpointUpdateRequestMsg
		EndpointUpdateResponseMsg
		EndpointFilter
		EndpointDeleteRequest
		EndpointDeleteRequestMsg
		EndpointDeleteResponse
		EndpointDeleteResponseMsg
		EndpointGetRequest
		EndpointGetRequestMsg
		EndpointGetByInterfaceRequest
		EndpointGetByInterfaceRequestMsg
		EndpointGetAllRequestMsg
		EndpointStats
		EndpointGetResponse
		EndpointGetResponseMsg
		MigrationResponse
		FilterSpec
		FilterRequestMsg
		FilterStatus
		FilterResponse
		FilterResponseMsg
		FilterDeleteRequest
		FilterDeleteRequestMsg
		FilterDeleteResponse
		FilterDeleteResponseMsg
		FilterGetRequest
		FilterGetRequestMsg
		FilterGetResponse
		FilterGetResponseMsg
		EplearnDhcpCfg
		EplearnArpCfg
		EplearnDataPacketCfg
		EplearnCfg
		ArpStats
		DhcpStats
		L2EplearnStats
		DhcpStatus
		ArpStatus
		EplearnStats
		EplearnStatus
		EventRequest
		EventResponse
		Event
		FWEvent
		LifQStateMapEntry
		PktFilter
		BcastPktFilter
		McastPktFilter
		LifSpec
		LifRequestMsg
		LifStatus
		LifQState
		LifRdmaData
		LifTxSchedulerData
		LifResponse
		LifResponseMsg
		QStateGetReq
		GetQStateRequestMsg
		QStateGetResp
		GetQStateResponseMsg
		P4ProgLabel
		QStateSetReq
		SetQStateRequestMsg
		QStateSetResp
		SetQStateResponseMsg
		LifDeleteRequest
		LifDeleteRequestMsg
		LifDeleteResponse
		LifDeleteResponseMsg
		LifTxStats
		LifRxStats
		DataLifStats
		CpuQueueStats
		CpuLifStats
		LifStats
		LifGetRequest
		LifGetRequestMsg
		LifGetResponse
		LifGetResponseMsg
		LifRssSpec
		EnicInfo
		EnicClassicInfo
		IfEnicInfo
		IfUplinkInfo
		IfUplinkPCInfo
		IfTunnelVxlanInfo
		IfTunnelGREInfo
		IfTunnelProprietaryMpls
		IfTunnelInfo
		IfCPUInfo
		IfAppRedirInfo
		InterfaceSpec
		InterfaceRequestMsg
		UplinkResponseInfo
		EnicL2SegInfo
		SmartEnicInfo
		ClassicEnicInfo
		EnicResponseInfo
		CpuIfResponseInfo
		TunnelIfResponseInfo
		AppRedirIfInfo
		InterfaceStatus
		InterfaceResponse
		InterfaceResponseMsg
		InterfaceDeleteRequest
		InterfaceDeleteRequestMsg
		InterfaceDeleteResponse
		InterfaceDeleteResponseMsg
		InterfaceStats
		InterfaceGetRequest
		InterfaceGetRequestMsg
		InterfaceGetResponse
		InterfaceGetResponseMsg
		InterfaceL2SegmentSpec
		InterfaceL2SegmentRequestMsg
		InterfaceL2SegmentResponse
		InterfaceL2SegmentResponseMsg
		L2SegmentSpec
		L2SegmentRequestMsg
		L2SegmentStatusEpd
		L2SegmentStatusCpd
		L2SegmentStatus
		L2SegmentResponse
		L2SegmentResponseMsg
		L2SegmentDeleteRequest
		L2SegmentDeleteRequestMsg
		L2SegmentDeleteResponse
		L2SegmentDeleteResponseMsg
		L2SegmentGetRequest
		L2SegmentGetRequestMsg
		L2SegmentStats
		L2SegmentGetResponse
		L2SegmentGetResponseMsg
		Oif
		OifListEpd
		OifListCpd
		OifList
		MulticastEntryStatusEpd
		MulticastEntryStatusCpd
		MulticastEntryStatus
		MulticastEntrySpec
		MulticastEntryRequestMsg
		MulticastEntryResponse
		MulticastEntryResponseMsg
		MulticastEntryDeleteRequest
		MulticastEntryDeleteRequestMsg
		MulticastEntryDeleteResponse
		MulticastEntryDeleteResponseMsg
		MulticastEntryGetRequest
		MulticastEntryGetRequestMsg
		MulticastEntryStats
		MulticastEntryGetResponse
		MulticastEntryGetResponseMsg
		SecurityProfileSpec
		SecurityProfileRequestMsg
		SecurityProfileStatusEpd
		SecurityProfileStatusCpd
		SecurityProfileStatus
		SecurityProfileResponse
		SecurityProfileResponseMsg
		SecurityProfileDeleteRequest
		SecurityProfileDeleteRequestMsg
		SecurityProfileDeleteResponse
		SecurityProfileDeleteResponseMsg
		SecurityProfileGetRequest
		SecurityProfileGetRequestMsg
		SecurityProfileStats
		SecurityProfileGetResponse
		SecurityProfileGetResponseMsg
		Service
		FirewallRuleSpec
		NetworkSecurityPolicy
		SecurityGroupPolicySpec
		SecurityGroupPolicyRequestMsg
		SecurityGroupPolicyStatus
		SecurityGroupPolicyResponse
		SecurityGroupPolicyResponseMsg
		SecurityGroupPolicyDeleteRequest
		SecurityGroupPolicyDeleteRequestMsg
		SecurityGroupPolicyDeleteResponse
		SecurityGroupPolicyDeleteResponseMsg
		SecurityGroupPolicyGetRequest
		SecurityGroupPolicyGetRequestMsg
		SecurityGroupPolicyStats
		SecurityGroupPolicyGetResponse
		SecurityGroupPolicyGetResponseMsg
		SecurityGroupSpec
		SecurityGroupRequestMsg
		SecurityGroupStatus
		SecurityGroupResponse
		SecurityGroupResponseMsg
		SecurityGroupDeleteRequest
		SecurityGroupDeleteRequestMsg
		SecurityGroupDeleteResponseMsg
		SecurityGroupGetRequest
		SecurityGroupGetRequestMsg
		SecurityGroupStats
		SecurityGroupGetResponse
		SecurityGroupGetResponseMsg
		AppData
		SecurityRuleAction
		SecurityRule
		SecurityPolicySpec
		SecurityPolicyRequestMsg
		SecurityRuleStatus
		SecurityPolicyStatus
		SecurityPolicyResponse
		SecurityPolicyResponseMsg
		SecurityPolicyDeleteRequest
		SecurityPolicyDeleteRequestMsg
		SecurityPolicyDeleteResponse
		SecurityPolicyDeleteResponseMsg
		SecurityPolicyGetRequest
		SecurityPolicyGetRequestMsg
		SecurityRuleStats
		SecurityPolicyStats
		SecurityPolicyGetResponse
		SecurityPolicyGetResponseMsg
		SecurityFlowGateFilter
		SecurityFlowGateGetRequest
		SecurityFlowGateGetRequestMsg
		FlowGateKey
		SecurityFlowGateGetResponse
		SecurityFlowGateGetResponseMsg
		SecurityFlowGateDeleteRequest
		SecurityFlowGateDeleteRequestMsg
		SecurityFlowGateDeleteResponseMsg
		PortXcvrStatus
		PortSpec
		PortLinkStatus
		PortStatus
		PortRequestMsg
		PortResponse
		PortResponseMsg
		PortDeleteRequest
		PortDeleteRequestMsg
		PortDeleteResponse
		PortDeleteResponseMsg
		MgmtMacStats
		MacStats
		TimeDuration
		LinkTimingInfo
		PortStats
		PortGetRequest
		PortGetRequestMsg
		PortGetResponse
		PortGetResponseMsg
		PortInfoGetRequest
		PortInfoGetRequestMsg
		PortInfoSpec
		PortInfoGetResponse
		PortInfoGetResponseMsg
		PortEvent
		AacsRequestMsg
		PolicerPPSSpec
		PolicerBPSSpec
		PolicerSpec
		PolicerStats
		QosPause
		QosSched
		QosClassMap
		QosMarking
		QosClassSpec
		QosClassRequestMsg
		PacketBufferPort
		QosClassPortStatus
		QosClassStatusEpd
		QosClassStatusCpd
		QosClassStatus
		QosClassResponse
		QosClassResponseMsg
		QosClassDeleteRequest
		QosClassDeleteRequestMsg
		QosClassDeleteResponse
		QosClassDeleteResponseMsg
		QosClearStatsRequest
		QosClearStatsRequestMsg
		QosClearStatsResponse
		QosClearStatsResponseMsg
		QosClassInputOflowQueueStats
		QosClassInputQueueStats
		QosClassOutputQueueStats
		QosClassQueueStats
		QosClassPortStats
		QosClassStats
		QosClassGetRequest
		QosClassGetRequestMsg
		QosClassGetResponse
		OccupancyPerQueue
		PortOccupancy
		Thresholds
		QosClassThresholdsGetResponse
		QosClassThresholdsGetResponseMsg
		QosClassThresholdsGetRequest
		QosClassThresholdsGetRequestMsg
		QosClassGetResponseMsg
		QosClassSetGlobalPauseTypeRequest
		QosClassSetGlobalPauseTypeRequestMsg
		QosClassSetGlobalPauseTypeResponseMsg
		CoppSpec
		CoppRequestMsg
		CoppStatusEpd
		CoppStatusCpd
		CoppStatus
		CoppResponse
		CoppResponseMsg
		CoppDeleteRequest
		CoppDeleteRequestMsg
		CoppDeleteResponse
		CoppDeleteResponseMsg
		CoppStats
		CoppGetRequest
		CoppGetRequestMsg
		CoppGetResponse
		CoppGetResponseMsg
		ApiStatsEntry
		ApiStatsResponse
		DropStatsEntry
		EgressDropStatsEntry
		BufferDropStatsEntry
		BufferDropStats
		TableStatsEntry
		TableStats
		BufferStats
		OflowFifoDropStatsEntry
		OflowFifoDropStats
		OflowFifoStats
		PacketBufferPortStats
		PacketBufferStats
		Status
		SystemGetRequest
		SystemResponse
		Stats
		DropStats
		EgressDropStats
		FTEError
		FTEFeatureStats
		FTEStatsInfo
		FTEStats
		SessionSummaryStats
		QCtr
		QGlobalInfo
		QInfo
		FTEInfo
		PMDStats
		FeatureProfileResponse
		MicroSegEvent
		MicroSegSpec
		MicroSegRequestMsg
		MicroSegResponse
		MicroSegResponseMsg
		MicroSegUpdateRequest
		MicroSegUpdateRequestMsg
		MicroSegUpdateResponse
		MicroSegUpdateResponseMsg
		SysSpec
		SysSpecCreateUpdateRequest
		SysSpecStatus
		SysSpecResponse
		SysSpecGetResponse
		SysSpecGetRequest
		CollectorSpec
		CollectorStatus
		CollectorResponse
		CollectorRequestMsg
		CollectorResponseMsg
		CollectorDeleteRequest
		CollectorDeleteResponse
		CollectorDeleteRequestMsg
		CollectorDeleteResponseMsg
		CollectorGetRequest
		CollectorGetRequestMsg
		CollectorGetResponse
		CollectorGetResponseMsg
		CollectorStats
		MonitorAction
		FlowMonitorRuleSpec
		FlowMonitorRuleStatus
		FlowMonitorRuleResponse
		FlowMonitorRuleRequestMsg
		FlowMonitorRuleResponseMsg
		FlowMonitorRuleDeleteRequest
		FlowMonitorRuleDeleteResponse
		FlowMonitorRuleDeleteRequestMsg
		FlowMonitorRuleDeleteResponseMsg
		FlowMonitorRuleGetRequest
		FlowMonitorRuleGetRequestMsg
		FlowMonitorRuleStats
		FlowMonitorRuleGetResponse
		FlowMonitorRuleGetResponseMsg
		DropMonitorRuleSpec
		DropMonitorRuleStatus
		DropMonitorRuleResponse
		DropMonitorRuleRequestMsg
		DropMonitorRuleResponseMsg
		DropMonitorRuleDeleteRequest
		DropMonitorRuleDeleteResponse
		DropMonitorRuleDeleteRequestMsg
		DropMonitorRuleDeleteResponseMsg
		DropMonitorRuleGetRequest
		DropMonitorRuleGetRequestMsg
		DropMonitorRuleStats
		DropMonitorRuleGetResponse
		DropMonitorRuleGetResponseMsg
		RSpanSpec
		ERSpanSpec
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorSessionResponse
		MirrorSessionRequestMsg
		MirrorSessionResponseMsg
		MirrorSessionDeleteRequest
		MirrorSessionDeleteResponse
		MirrorSessionDeleteRequestMsg
		MirrorSessionDeleteResponseMsg
		MirrorSessionGetRequest
		MirrorSessionGetRequestMsg
		MirrorSessionStats
		MirrorSessionGetResponse
		MirrorSessionGetResponseMsg
		VrfSpec
		VrfRequestMsg
		VrfStatusEpd
		VrfStatusCpd
		VrfStatus
		VrfResponse
		VrfResponseMsg
		VrfDeleteRequest
		VrfDeleteResponse
		VrfDeleteRequestMsg
		VrfDeleteResponseMsg
		VrfGetRequest
		VrfGetRequestMsg
		VrfStats
		VrfGetResponse
		VrfGetResponseMsg
*/
package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import gogoproto "github.com/gogo/protobuf/gogoproto"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// goproto_enum_prefix from public import gogo.proto
var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

// goproto_enum_stringer from public import gogo.proto
var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

// enum_stringer from public import gogo.proto
var E_EnumStringer = gogoproto.E_EnumStringer

// enum_customname from public import gogo.proto
var E_EnumCustomname = gogoproto.E_EnumCustomname

// enumdecl from public import gogo.proto
var E_Enumdecl = gogoproto.E_Enumdecl

// enumvalue_customname from public import gogo.proto
var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

// goproto_getters_all from public import gogo.proto
var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

// goproto_enum_prefix_all from public import gogo.proto
var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

// goproto_stringer_all from public import gogo.proto
var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

// verbose_equal_all from public import gogo.proto
var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

// face_all from public import gogo.proto
var E_FaceAll = gogoproto.E_FaceAll

// gostring_all from public import gogo.proto
var E_GostringAll = gogoproto.E_GostringAll

// populate_all from public import gogo.proto
var E_PopulateAll = gogoproto.E_PopulateAll

// stringer_all from public import gogo.proto
var E_StringerAll = gogoproto.E_StringerAll

// onlyone_all from public import gogo.proto
var E_OnlyoneAll = gogoproto.E_OnlyoneAll

// equal_all from public import gogo.proto
var E_EqualAll = gogoproto.E_EqualAll

// description_all from public import gogo.proto
var E_DescriptionAll = gogoproto.E_DescriptionAll

// testgen_all from public import gogo.proto
var E_TestgenAll = gogoproto.E_TestgenAll

// benchgen_all from public import gogo.proto
var E_BenchgenAll = gogoproto.E_BenchgenAll

// marshaler_all from public import gogo.proto
var E_MarshalerAll = gogoproto.E_MarshalerAll

// unmarshaler_all from public import gogo.proto
var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

// stable_marshaler_all from public import gogo.proto
var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

// sizer_all from public import gogo.proto
var E_SizerAll = gogoproto.E_SizerAll

// goproto_enum_stringer_all from public import gogo.proto
var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

// enum_stringer_all from public import gogo.proto
var E_EnumStringerAll = gogoproto.E_EnumStringerAll

// unsafe_marshaler_all from public import gogo.proto
var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

// unsafe_unmarshaler_all from public import gogo.proto
var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

// goproto_extensions_map_all from public import gogo.proto
var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

// goproto_unrecognized_all from public import gogo.proto
var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

// gogoproto_import from public import gogo.proto
var E_GogoprotoImport = gogoproto.E_GogoprotoImport

// protosizer_all from public import gogo.proto
var E_ProtosizerAll = gogoproto.E_ProtosizerAll

// compare_all from public import gogo.proto
var E_CompareAll = gogoproto.E_CompareAll

// typedecl_all from public import gogo.proto
var E_TypedeclAll = gogoproto.E_TypedeclAll

// enumdecl_all from public import gogo.proto
var E_EnumdeclAll = gogoproto.E_EnumdeclAll

// goproto_registration from public import gogo.proto
var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

// goproto_getters from public import gogo.proto
var E_GoprotoGetters = gogoproto.E_GoprotoGetters

// goproto_stringer from public import gogo.proto
var E_GoprotoStringer = gogoproto.E_GoprotoStringer

// verbose_equal from public import gogo.proto
var E_VerboseEqual = gogoproto.E_VerboseEqual

// face from public import gogo.proto
var E_Face = gogoproto.E_Face

// gostring from public import gogo.proto
var E_Gostring = gogoproto.E_Gostring

// populate from public import gogo.proto
var E_Populate = gogoproto.E_Populate

// stringer from public import gogo.proto
var E_Stringer = gogoproto.E_Stringer

// onlyone from public import gogo.proto
var E_Onlyone = gogoproto.E_Onlyone

// equal from public import gogo.proto
var E_Equal = gogoproto.E_Equal

// description from public import gogo.proto
var E_Description = gogoproto.E_Description

// testgen from public import gogo.proto
var E_Testgen = gogoproto.E_Testgen

// benchgen from public import gogo.proto
var E_Benchgen = gogoproto.E_Benchgen

// marshaler from public import gogo.proto
var E_Marshaler = gogoproto.E_Marshaler

// unmarshaler from public import gogo.proto
var E_Unmarshaler = gogoproto.E_Unmarshaler

// stable_marshaler from public import gogo.proto
var E_StableMarshaler = gogoproto.E_StableMarshaler

// sizer from public import gogo.proto
var E_Sizer = gogoproto.E_Sizer

// unsafe_marshaler from public import gogo.proto
var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

// unsafe_unmarshaler from public import gogo.proto
var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

// goproto_extensions_map from public import gogo.proto
var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

// goproto_unrecognized from public import gogo.proto
var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

// protosizer from public import gogo.proto
var E_Protosizer = gogoproto.E_Protosizer

// compare from public import gogo.proto
var E_Compare = gogoproto.E_Compare

// typedecl from public import gogo.proto
var E_Typedecl = gogoproto.E_Typedecl

// nullable from public import gogo.proto
var E_Nullable = gogoproto.E_Nullable

// embed from public import gogo.proto
var E_Embed = gogoproto.E_Embed

// customtype from public import gogo.proto
var E_Customtype = gogoproto.E_Customtype

// customname from public import gogo.proto
var E_Customname = gogoproto.E_Customname

// jsontag from public import gogo.proto
var E_Jsontag = gogoproto.E_Jsontag

// moretags from public import gogo.proto
var E_Moretags = gogoproto.E_Moretags

// casttype from public import gogo.proto
var E_Casttype = gogoproto.E_Casttype

// castkey from public import gogo.proto
var E_Castkey = gogoproto.E_Castkey

// castvalue from public import gogo.proto
var E_Castvalue = gogoproto.E_Castvalue

// stdtime from public import gogo.proto
var E_Stdtime = gogoproto.E_Stdtime

// stdduration from public import gogo.proto
var E_Stdduration = gogoproto.E_Stdduration

// IP protocol numbers
type IPProtocol int32

const (
	IPProtocol_IPPROTO_NONE   IPProtocol = 0
	IPProtocol_IPPROTO_ICMP   IPProtocol = 1
	IPProtocol_IPPROTO_IPV4   IPProtocol = 4
	IPProtocol_IPPROTO_TCP    IPProtocol = 6
	IPProtocol_IPPROTO_UDP    IPProtocol = 17
	IPProtocol_IPPROTO_GRE    IPProtocol = 47
	IPProtocol_IPPROTO_ESP    IPProtocol = 50
	IPProtocol_IPPROTO_AH     IPProtocol = 51
	IPProtocol_IPPROTO_ICMPV6 IPProtocol = 58
)

var IPProtocol_name = map[int32]string{
	0:  "IPPROTO_NONE",
	1:  "IPPROTO_ICMP",
	4:  "IPPROTO_IPV4",
	6:  "IPPROTO_TCP",
	17: "IPPROTO_UDP",
	47: "IPPROTO_GRE",
	50: "IPPROTO_ESP",
	51: "IPPROTO_AH",
	58: "IPPROTO_ICMPV6",
}
var IPProtocol_value = map[string]int32{
	"IPPROTO_NONE":   0,
	"IPPROTO_ICMP":   1,
	"IPPROTO_IPV4":   4,
	"IPPROTO_TCP":    6,
	"IPPROTO_UDP":    17,
	"IPPROTO_GRE":    47,
	"IPPROTO_ESP":    50,
	"IPPROTO_AH":     51,
	"IPPROTO_ICMPV6": 58,
}

func (x IPProtocol) String() string {
	return proto.EnumName(IPProtocol_name, int32(x))
}
func (IPProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ICMP message types
// TBD - add more here !!
type ICMPMsgType int32

const (
	ICMPMsgType_ICMP_MSG_TYPE_NONE ICMPMsgType = 0
	ICMPMsgType_ICMP_MSG_TYPE_ECHO ICMPMsgType = 1
)

var ICMPMsgType_name = map[int32]string{
	0: "ICMP_MSG_TYPE_NONE",
	1: "ICMP_MSG_TYPE_ECHO",
}
var ICMPMsgType_value = map[string]int32{
	"ICMP_MSG_TYPE_NONE": 0,
	"ICMP_MSG_TYPE_ECHO": 1,
}

func (x ICMPMsgType) String() string {
	return proto.EnumName(ICMPMsgType_name, int32(x))
}
func (ICMPMsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// API return codes (more descriptive than protobuf enums)
type ApiStatus int32

const (
	ApiStatus_API_STATUS_OK                                        ApiStatus = 0
	ApiStatus_API_STATUS_ERR                                       ApiStatus = 1
	ApiStatus_API_STATUS_INVALID_ARG                               ApiStatus = 2
	ApiStatus_API_STATUS_EXISTS_ALREADY                            ApiStatus = 3
	ApiStatus_API_STATUS_OUT_OF_MEM                                ApiStatus = 4
	ApiStatus_API_STATUS_NOT_FOUND                                 ApiStatus = 5
	ApiStatus_API_STATUS_OUT_OF_RESOURCE                           ApiStatus = 6
	ApiStatus_API_STATUS_ENCAP_INVALID                             ApiStatus = 7
	ApiStatus_API_STATUS_VRF_ID_INVALID                            ApiStatus = 8
	ApiStatus_API_STATUS_L2_SEGMENT_ID_INVALID                     ApiStatus = 9
	ApiStatus_API_STATUS_INTERFACE_ID_INVALID                      ApiStatus = 10
	ApiStatus_API_STATUS_IF_TYPE_INVALID                           ApiStatus = 11
	ApiStatus_API_STATUS_IF_INFO_INVALID                           ApiStatus = 12
	ApiStatus_API_STATUS_IF_L2SEGMENT_INVALID                      ApiStatus = 13
	ApiStatus_API_STATUS_IF_ENIC_INFO_INVALID                      ApiStatus = 14
	ApiStatus_API_STATUS_IF_ENIC_TYPE_INVALID                      ApiStatus = 15
	ApiStatus_API_STATUS_IF_LIF_INFO_NOT_INVALID                   ApiStatus = 16
	ApiStatus_API_STATUS_IF_LIFQ_INFO_NOT_INVALID                  ApiStatus = 17
	ApiStatus_API_STATUS_FLOW_KEY_INVALID                          ApiStatus = 18
	ApiStatus_API_STATUS_FLOW_INFO_INVALID                         ApiStatus = 19
	ApiStatus_API_STATUS_HANDLE_INVALID                            ApiStatus = 20
	ApiStatus_API_STATUS_HW_PROG_ERR                               ApiStatus = 21
	ApiStatus_API_STATUS_LIF_ID_INVALID                            ApiStatus = 22
	ApiStatus_API_STATUS_NWSEC_PROFILE_ID_INVALID                  ApiStatus = 23
	ApiStatus_API_STATUS_TLS_CB_ID_INVALID                         ApiStatus = 24
	ApiStatus_API_STATUS_TCP_CB_ID_INVALID                         ApiStatus = 25
	ApiStatus_API_STATUS_ACL_ID_INVALID                            ApiStatus = 26
	ApiStatus_API_STATUS_WRING_ID_INVALID                          ApiStatus = 27
	ApiStatus_API_STATUS_WRING_TYPE_INVALID                        ApiStatus = 28
	ApiStatus_API_STATUS_PROXY_TYPE_INVALID                        ApiStatus = 29
	ApiStatus_API_STATUS_IPSEC_CB_ID_INVALID                       ApiStatus = 30
	ApiStatus_API_STATUS_L4LB_KEY_INVALID                          ApiStatus = 31
	ApiStatus_API_STATUS_CPU_CB_ID_INVALID                         ApiStatus = 32
	ApiStatus_API_STATUS_PROXY_NOT_ENABLED                         ApiStatus = 33
	ApiStatus_API_STATUS_CFG_DB_ERR                                ApiStatus = 34
	ApiStatus_API_STATUS_SECURITY_GROUP_ID_INVALID                 ApiStatus = 35
	ApiStatus_API_STATUS_SECURITY_POLICY_ID_INVALID                ApiStatus = 36
	ApiStatus_API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID              ApiStatus = 37
	ApiStatus_API_STATUS_DOS_POLICY_ID_INVALID                     ApiStatus = 38
	ApiStatus_API_STATUS_RAWR_CB_ID_INVALID                        ApiStatus = 39
	ApiStatus_API_STATUS_OBJECT_IN_USE                             ApiStatus = 40
	ApiStatus_API_STATUS_RAWC_CB_ID_INVALID                        ApiStatus = 41
	ApiStatus_API_STATUS_PORT_ID_INVALID                           ApiStatus = 42
	ApiStatus_API_STATUS_PORT_TYPE_INVALID                         ApiStatus = 43
	ApiStatus_API_STATUS_PORT_SPEED_INVALID                        ApiStatus = 44
	ApiStatus_API_STATUS_PORT_NUM_LANES_INVALID                    ApiStatus = 45
	ApiStatus_API_STATUS_MC_ENTRY_ID_INVALID                       ApiStatus = 46
	ApiStatus_API_STATUS_PROXYR_CB_ID_INVALID                      ApiStatus = 47
	ApiStatus_API_STATUS_PROXYC_CB_ID_INVALID                      ApiStatus = 48
	ApiStatus_API_STATUS_HW_READ_ERROR                             ApiStatus = 49
	ApiStatus_API_STATUS_HW_WRITE_ERROR                            ApiStatus = 50
	ApiStatus_API_STATUS_L2_SEGMENT_TYPE_INVALID                   ApiStatus = 51
	ApiStatus_API_STATUS_NAT_POOL_KEY_INVALID                      ApiStatus = 52
	ApiStatus_API_STATUS_NAT_MAPPING_KEY_INVALID                   ApiStatus = 53
	ApiStatus_API_STATUS_QOS_CLASS_MTU_INVALID                     ApiStatus = 54
	ApiStatus_API_STATUS_QOS_CLASS_XON_THRESHOLD_INVALID           ApiStatus = 55
	ApiStatus_API_STATUS_QOS_CLASS_XOFF_THRESHOLD_INVALID          ApiStatus = 56
	ApiStatus_API_STATUS_QOS_CLASS_SCHEDULER_NOT_SET               ApiStatus = 57
	ApiStatus_API_STATUS_QOS_CLASS_DWRR_INVALID                    ApiStatus = 58
	ApiStatus_API_STATUS_QOS_CLASS_QOS_GROUP_INVALID               ApiStatus = 59
	ApiStatus_API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_NOT_SET        ApiStatus = 60
	ApiStatus_API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_SET            ApiStatus = 61
	ApiStatus_API_STATUS_QOS_CLASS_DOT1Q_PCP_INVALID               ApiStatus = 62
	ApiStatus_API_STATUS_QOS_CLASS_IP_DSCP_INVALID                 ApiStatus = 63
	ApiStatus_API_STATUS_QOS_CLASS_DOT1Q_PCP_MARKING_INVALID       ApiStatus = 64
	ApiStatus_API_STATUS_QOS_CLASS_IP_DSCP_MARKING_INVALID         ApiStatus = 65
	ApiStatus_API_STATUS_QOS_CLASS_DOT1Q_PCP_ALREADY_IN_USE        ApiStatus = 66
	ApiStatus_API_STATUS_QOS_CLASS_IP_DSCP_ALREADY_IN_USE          ApiStatus = 67
	ApiStatus_API_STATUS_QOS_CLASS_DROP_NO_DROP_CHANGE_NOT_ALLOWED ApiStatus = 68
)

var ApiStatus_name = map[int32]string{
	0:  "API_STATUS_OK",
	1:  "API_STATUS_ERR",
	2:  "API_STATUS_INVALID_ARG",
	3:  "API_STATUS_EXISTS_ALREADY",
	4:  "API_STATUS_OUT_OF_MEM",
	5:  "API_STATUS_NOT_FOUND",
	6:  "API_STATUS_OUT_OF_RESOURCE",
	7:  "API_STATUS_ENCAP_INVALID",
	8:  "API_STATUS_VRF_ID_INVALID",
	9:  "API_STATUS_L2_SEGMENT_ID_INVALID",
	10: "API_STATUS_INTERFACE_ID_INVALID",
	11: "API_STATUS_IF_TYPE_INVALID",
	12: "API_STATUS_IF_INFO_INVALID",
	13: "API_STATUS_IF_L2SEGMENT_INVALID",
	14: "API_STATUS_IF_ENIC_INFO_INVALID",
	15: "API_STATUS_IF_ENIC_TYPE_INVALID",
	16: "API_STATUS_IF_LIF_INFO_NOT_INVALID",
	17: "API_STATUS_IF_LIFQ_INFO_NOT_INVALID",
	18: "API_STATUS_FLOW_KEY_INVALID",
	19: "API_STATUS_FLOW_INFO_INVALID",
	20: "API_STATUS_HANDLE_INVALID",
	21: "API_STATUS_HW_PROG_ERR",
	22: "API_STATUS_LIF_ID_INVALID",
	23: "API_STATUS_NWSEC_PROFILE_ID_INVALID",
	24: "API_STATUS_TLS_CB_ID_INVALID",
	25: "API_STATUS_TCP_CB_ID_INVALID",
	26: "API_STATUS_ACL_ID_INVALID",
	27: "API_STATUS_WRING_ID_INVALID",
	28: "API_STATUS_WRING_TYPE_INVALID",
	29: "API_STATUS_PROXY_TYPE_INVALID",
	30: "API_STATUS_IPSEC_CB_ID_INVALID",
	31: "API_STATUS_L4LB_KEY_INVALID",
	32: "API_STATUS_CPU_CB_ID_INVALID",
	33: "API_STATUS_PROXY_NOT_ENABLED",
	34: "API_STATUS_CFG_DB_ERR",
	35: "API_STATUS_SECURITY_GROUP_ID_INVALID",
	36: "API_STATUS_SECURITY_POLICY_ID_INVALID",
	37: "API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID",
	38: "API_STATUS_DOS_POLICY_ID_INVALID",
	39: "API_STATUS_RAWR_CB_ID_INVALID",
	40: "API_STATUS_OBJECT_IN_USE",
	41: "API_STATUS_RAWC_CB_ID_INVALID",
	42: "API_STATUS_PORT_ID_INVALID",
	43: "API_STATUS_PORT_TYPE_INVALID",
	44: "API_STATUS_PORT_SPEED_INVALID",
	45: "API_STATUS_PORT_NUM_LANES_INVALID",
	46: "API_STATUS_MC_ENTRY_ID_INVALID",
	47: "API_STATUS_PROXYR_CB_ID_INVALID",
	48: "API_STATUS_PROXYC_CB_ID_INVALID",
	49: "API_STATUS_HW_READ_ERROR",
	50: "API_STATUS_HW_WRITE_ERROR",
	51: "API_STATUS_L2_SEGMENT_TYPE_INVALID",
	52: "API_STATUS_NAT_POOL_KEY_INVALID",
	53: "API_STATUS_NAT_MAPPING_KEY_INVALID",
	54: "API_STATUS_QOS_CLASS_MTU_INVALID",
	55: "API_STATUS_QOS_CLASS_XON_THRESHOLD_INVALID",
	56: "API_STATUS_QOS_CLASS_XOFF_THRESHOLD_INVALID",
	57: "API_STATUS_QOS_CLASS_SCHEDULER_NOT_SET",
	58: "API_STATUS_QOS_CLASS_DWRR_INVALID",
	59: "API_STATUS_QOS_CLASS_QOS_GROUP_INVALID",
	60: "API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_NOT_SET",
	61: "API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_SET",
	62: "API_STATUS_QOS_CLASS_DOT1Q_PCP_INVALID",
	63: "API_STATUS_QOS_CLASS_IP_DSCP_INVALID",
	64: "API_STATUS_QOS_CLASS_DOT1Q_PCP_MARKING_INVALID",
	65: "API_STATUS_QOS_CLASS_IP_DSCP_MARKING_INVALID",
	66: "API_STATUS_QOS_CLASS_DOT1Q_PCP_ALREADY_IN_USE",
	67: "API_STATUS_QOS_CLASS_IP_DSCP_ALREADY_IN_USE",
	68: "API_STATUS_QOS_CLASS_DROP_NO_DROP_CHANGE_NOT_ALLOWED",
}
var ApiStatus_value = map[string]int32{
	"API_STATUS_OK":                                        0,
	"API_STATUS_ERR":                                       1,
	"API_STATUS_INVALID_ARG":                               2,
	"API_STATUS_EXISTS_ALREADY":                            3,
	"API_STATUS_OUT_OF_MEM":                                4,
	"API_STATUS_NOT_FOUND":                                 5,
	"API_STATUS_OUT_OF_RESOURCE":                           6,
	"API_STATUS_ENCAP_INVALID":                             7,
	"API_STATUS_VRF_ID_INVALID":                            8,
	"API_STATUS_L2_SEGMENT_ID_INVALID":                     9,
	"API_STATUS_INTERFACE_ID_INVALID":                      10,
	"API_STATUS_IF_TYPE_INVALID":                           11,
	"API_STATUS_IF_INFO_INVALID":                           12,
	"API_STATUS_IF_L2SEGMENT_INVALID":                      13,
	"API_STATUS_IF_ENIC_INFO_INVALID":                      14,
	"API_STATUS_IF_ENIC_TYPE_INVALID":                      15,
	"API_STATUS_IF_LIF_INFO_NOT_INVALID":                   16,
	"API_STATUS_IF_LIFQ_INFO_NOT_INVALID":                  17,
	"API_STATUS_FLOW_KEY_INVALID":                          18,
	"API_STATUS_FLOW_INFO_INVALID":                         19,
	"API_STATUS_HANDLE_INVALID":                            20,
	"API_STATUS_HW_PROG_ERR":                               21,
	"API_STATUS_LIF_ID_INVALID":                            22,
	"API_STATUS_NWSEC_PROFILE_ID_INVALID":                  23,
	"API_STATUS_TLS_CB_ID_INVALID":                         24,
	"API_STATUS_TCP_CB_ID_INVALID":                         25,
	"API_STATUS_ACL_ID_INVALID":                            26,
	"API_STATUS_WRING_ID_INVALID":                          27,
	"API_STATUS_WRING_TYPE_INVALID":                        28,
	"API_STATUS_PROXY_TYPE_INVALID":                        29,
	"API_STATUS_IPSEC_CB_ID_INVALID":                       30,
	"API_STATUS_L4LB_KEY_INVALID":                          31,
	"API_STATUS_CPU_CB_ID_INVALID":                         32,
	"API_STATUS_PROXY_NOT_ENABLED":                         33,
	"API_STATUS_CFG_DB_ERR":                                34,
	"API_STATUS_SECURITY_GROUP_ID_INVALID":                 35,
	"API_STATUS_SECURITY_POLICY_ID_INVALID":                36,
	"API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID":              37,
	"API_STATUS_DOS_POLICY_ID_INVALID":                     38,
	"API_STATUS_RAWR_CB_ID_INVALID":                        39,
	"API_STATUS_OBJECT_IN_USE":                             40,
	"API_STATUS_RAWC_CB_ID_INVALID":                        41,
	"API_STATUS_PORT_ID_INVALID":                           42,
	"API_STATUS_PORT_TYPE_INVALID":                         43,
	"API_STATUS_PORT_SPEED_INVALID":                        44,
	"API_STATUS_PORT_NUM_LANES_INVALID":                    45,
	"API_STATUS_MC_ENTRY_ID_INVALID":                       46,
	"API_STATUS_PROXYR_CB_ID_INVALID":                      47,
	"API_STATUS_PROXYC_CB_ID_INVALID":                      48,
	"API_STATUS_HW_READ_ERROR":                             49,
	"API_STATUS_HW_WRITE_ERROR":                            50,
	"API_STATUS_L2_SEGMENT_TYPE_INVALID":                   51,
	"API_STATUS_NAT_POOL_KEY_INVALID":                      52,
	"API_STATUS_NAT_MAPPING_KEY_INVALID":                   53,
	"API_STATUS_QOS_CLASS_MTU_INVALID":                     54,
	"API_STATUS_QOS_CLASS_XON_THRESHOLD_INVALID":           55,
	"API_STATUS_QOS_CLASS_XOFF_THRESHOLD_INVALID":          56,
	"API_STATUS_QOS_CLASS_SCHEDULER_NOT_SET":               57,
	"API_STATUS_QOS_CLASS_DWRR_INVALID":                    58,
	"API_STATUS_QOS_CLASS_QOS_GROUP_INVALID":               59,
	"API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_NOT_SET":        60,
	"API_STATUS_QOS_CLASS_UPLINK_CLASS_MAP_SET":            61,
	"API_STATUS_QOS_CLASS_DOT1Q_PCP_INVALID":               62,
	"API_STATUS_QOS_CLASS_IP_DSCP_INVALID":                 63,
	"API_STATUS_QOS_CLASS_DOT1Q_PCP_MARKING_INVALID":       64,
	"API_STATUS_QOS_CLASS_IP_DSCP_MARKING_INVALID":         65,
	"API_STATUS_QOS_CLASS_DOT1Q_PCP_ALREADY_IN_USE":        66,
	"API_STATUS_QOS_CLASS_IP_DSCP_ALREADY_IN_USE":          67,
	"API_STATUS_QOS_CLASS_DROP_NO_DROP_CHANGE_NOT_ALLOWED": 68,
}

func (x ApiStatus) String() string {
	return proto.EnumName(ApiStatus_name, int32(x))
}
func (ApiStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Types of Vrfs
type VrfType int32

const (
	VrfType_VRF_TYPE_NONE                VrfType = 0
	VrfType_VRF_TYPE_INFRA               VrfType = 1
	VrfType_VRF_TYPE_CUSTOMER            VrfType = 2
	VrfType_VRF_TYPE_OOB_MANAGEMENT      VrfType = 3
	VrfType_VRF_TYPE_INTERNAL_MANAGEMENT VrfType = 4
	VrfType_VRF_TYPE_INBAND_MANAGEMENT   VrfType = 5
)

var VrfType_name = map[int32]string{
	0: "VRF_TYPE_NONE",
	1: "VRF_TYPE_INFRA",
	2: "VRF_TYPE_CUSTOMER",
	3: "VRF_TYPE_OOB_MANAGEMENT",
	4: "VRF_TYPE_INTERNAL_MANAGEMENT",
	5: "VRF_TYPE_INBAND_MANAGEMENT",
}
var VrfType_value = map[string]int32{
	"VRF_TYPE_NONE":                0,
	"VRF_TYPE_INFRA":               1,
	"VRF_TYPE_CUSTOMER":            2,
	"VRF_TYPE_OOB_MANAGEMENT":      3,
	"VRF_TYPE_INTERNAL_MANAGEMENT": 4,
	"VRF_TYPE_INBAND_MANAGEMENT":   5,
}

func (x VrfType) String() string {
	return proto.EnumName(VrfType_name, int32(x))
}
func (VrfType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Types of L2 segments
type L2SegmentType int32

const (
	L2SegmentType_L2_SEGMENT_TYPE_NONE L2SegmentType = 0
	L2SegmentType_L2_SEGMENT_PRIMARY   L2SegmentType = 1
	L2SegmentType_L2_SEGMENT_ISOLATED  L2SegmentType = 2
)

var L2SegmentType_name = map[int32]string{
	0: "L2_SEGMENT_TYPE_NONE",
	1: "L2_SEGMENT_PRIMARY",
	2: "L2_SEGMENT_ISOLATED",
}
var L2SegmentType_value = map[string]int32{
	"L2_SEGMENT_TYPE_NONE": 0,
	"L2_SEGMENT_PRIMARY":   1,
	"L2_SEGMENT_ISOLATED":  2,
}

func (x L2SegmentType) String() string {
	return proto.EnumName(L2SegmentType_name, int32(x))
}
func (L2SegmentType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

// Supported wire encaps for the L2 segments
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE     EncapType = 0
	EncapType_ENCAP_TYPE_DOT1Q    EncapType = 1
	EncapType_ENCAP_TYPE_VXLAN    EncapType = 2
	EncapType_ENCAP_TYPE_IP_IN_IP EncapType = 3
	EncapType_ENCAP_TYPE_GRE      EncapType = 4
	EncapType_ENCAP_TYPE_IPSEC    EncapType = 5
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_DOT1Q",
	2: "ENCAP_TYPE_VXLAN",
	3: "ENCAP_TYPE_IP_IN_IP",
	4: "ENCAP_TYPE_GRE",
	5: "ENCAP_TYPE_IPSEC",
}
var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":     0,
	"ENCAP_TYPE_DOT1Q":    1,
	"ENCAP_TYPE_VXLAN":    2,
	"ENCAP_TYPE_IP_IN_IP": 3,
	"ENCAP_TYPE_GRE":      4,
	"ENCAP_TYPE_IPSEC":    5,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}
func (EncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type SnakeTestType int32

const (
	SnakeTestType_SNAKE_TEST_TYPE_NONE       SnakeTestType = 0
	SnakeTestType_SNAKE_TEST_TYPE_ARM_TO_ARM SnakeTestType = 1
	SnakeTestType_SNAKE_TEST_TYPE_LOOP       SnakeTestType = 2
	SnakeTestType_SNAKE_TEST_TYPE_UP2UP      SnakeTestType = 3
)

var SnakeTestType_name = map[int32]string{
	0: "SNAKE_TEST_TYPE_NONE",
	1: "SNAKE_TEST_TYPE_ARM_TO_ARM",
	2: "SNAKE_TEST_TYPE_LOOP",
	3: "SNAKE_TEST_TYPE_UP2UP",
}
var SnakeTestType_value = map[string]int32{
	"SNAKE_TEST_TYPE_NONE":       0,
	"SNAKE_TEST_TYPE_ARM_TO_ARM": 1,
	"SNAKE_TEST_TYPE_LOOP":       2,
	"SNAKE_TEST_TYPE_UP2UP":      3,
}

func (x SnakeTestType) String() string {
	return proto.EnumName(SnakeTestType_name, int32(x))
}
func (SnakeTestType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// IP address families
type IPAddressFamily int32

const (
	IPAddressFamily_IP_AF_NONE  IPAddressFamily = 0
	IPAddressFamily_IP_AF_INET  IPAddressFamily = 1
	IPAddressFamily_IP_AF_INET6 IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}
var IPAddressFamily_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type IPAddressType int32

const (
	IPAddressType_IP_ADDRESS_NONE           IPAddressType = 0
	IPAddressType_IP_ADDRESS_IPV4_ANY       IPAddressType = 1
	IPAddressType_IP_ADDRESS_IPV6_ANY       IPAddressType = 2
	IPAddressType_IP_ADDRESS_ANY            IPAddressType = 3
	IPAddressType_IP_ADDRESS_IPV4_MULTICAST IPAddressType = 4
	IPAddressType_IP_ADDRESS_IPV6_MULTICAST IPAddressType = 5
	IPAddressType_IP_ADDRESS_MULTICAST      IPAddressType = 6
	IPAddressType_IP_ADDRESS_V6_LINK_LOCAL  IPAddressType = 7
)

var IPAddressType_name = map[int32]string{
	0: "IP_ADDRESS_NONE",
	1: "IP_ADDRESS_IPV4_ANY",
	2: "IP_ADDRESS_IPV6_ANY",
	3: "IP_ADDRESS_ANY",
	4: "IP_ADDRESS_IPV4_MULTICAST",
	5: "IP_ADDRESS_IPV6_MULTICAST",
	6: "IP_ADDRESS_MULTICAST",
	7: "IP_ADDRESS_V6_LINK_LOCAL",
}
var IPAddressType_value = map[string]int32{
	"IP_ADDRESS_NONE":           0,
	"IP_ADDRESS_IPV4_ANY":       1,
	"IP_ADDRESS_IPV6_ANY":       2,
	"IP_ADDRESS_ANY":            3,
	"IP_ADDRESS_IPV4_MULTICAST": 4,
	"IP_ADDRESS_IPV6_MULTICAST": 5,
	"IP_ADDRESS_MULTICAST":      6,
	"IP_ADDRESS_V6_LINK_LOCAL":  7,
}

func (x IPAddressType) String() string {
	return proto.EnumName(IPAddressType_name, int32(x))
}
func (IPAddressType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// Types of lif
type LifType int32

const (
	LifType_LIF_TYPE_NONE                     LifType = 0
	LifType_LIF_TYPE_HOST                     LifType = 1
	LifType_LIF_TYPE_HOST_MANAGEMENT          LifType = 2
	LifType_LIF_TYPE_MNIC_OOB_MANAGEMENT      LifType = 3
	LifType_LIF_TYPE_MNIC_INTERNAL_MANAGEMENT LifType = 4
	LifType_LIF_TYPE_MNIC_INBAND_MANAGEMENT   LifType = 5
	LifType_LIF_TYPE_MNIC_CPU                 LifType = 6
	LifType_LIF_TYPE_SWM                      LifType = 7
)

var LifType_name = map[int32]string{
	0: "LIF_TYPE_NONE",
	1: "LIF_TYPE_HOST",
	2: "LIF_TYPE_HOST_MANAGEMENT",
	3: "LIF_TYPE_MNIC_OOB_MANAGEMENT",
	4: "LIF_TYPE_MNIC_INTERNAL_MANAGEMENT",
	5: "LIF_TYPE_MNIC_INBAND_MANAGEMENT",
	6: "LIF_TYPE_MNIC_CPU",
	7: "LIF_TYPE_SWM",
}
var LifType_value = map[string]int32{
	"LIF_TYPE_NONE":                     0,
	"LIF_TYPE_HOST":                     1,
	"LIF_TYPE_HOST_MANAGEMENT":          2,
	"LIF_TYPE_MNIC_OOB_MANAGEMENT":      3,
	"LIF_TYPE_MNIC_INTERNAL_MANAGEMENT": 4,
	"LIF_TYPE_MNIC_INBAND_MANAGEMENT":   5,
	"LIF_TYPE_MNIC_CPU":                 6,
	"LIF_TYPE_SWM":                      7,
}

func (x LifType) String() string {
	return proto.EnumName(LifType_name, int32(x))
}
func (LifType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

// Types of Work Ring
type WRingType int32

const (
	WRingType_WRING_TYPE_NONE              WRingType = 0
	WRingType_WRING_TYPE_SERQ              WRingType = 1
	WRingType_WRING_TYPE_BSQ               WRingType = 2
	WRingType_WRING_TYPE_BRQ               WRingType = 3
	WRingType_WRING_TYPE_SESQ              WRingType = 4
	WRingType_WRING_TYPE_IPSECCBQ          WRingType = 5
	WRingType_WRING_TYPE_ARQRX             WRingType = 6
	WRingType_WRING_TYPE_ASQ               WRingType = 7
	WRingType_WRING_TYPE_ASESQ             WRingType = 8
	WRingType_WRING_TYPE_RAWRCB            WRingType = 9
	WRingType_WRING_TYPE_IPSECCBQ_BARCO    WRingType = 10
	WRingType_WRING_TYPE_APP_REDIR_RAWC    WRingType = 11
	WRingType_WRING_TYPE_APP_REDIR_PROXYR  WRingType = 12
	WRingType_WRING_TYPE_APP_REDIR_PROXYC  WRingType = 13
	WRingType_WRING_TYPE_NMDR_RX_GC        WRingType = 14
	WRingType_WRING_TYPE_NMDR_TX_GC        WRingType = 15
	WRingType_WRING_TYPE_ARQTX             WRingType = 16
	WRingType_WRING_TYPE_ASCQ              WRingType = 17
	WRingType_WRING_TYPE_CPU_TX_DR         WRingType = 18
	WRingType_WRING_TYPE_CPU_TX_PR         WRingType = 19
	WRingType_WRING_TYPE_IPSEC_NMDR_TX     WRingType = 20
	WRingType_WRING_TYPE_IPSEC_NMDR_RX     WRingType = 21
	WRingType_WRING_TYPE_IPSEC_NMPR_TX     WRingType = 22
	WRingType_WRING_TYPE_IPSEC_NMPR_RX     WRingType = 23
	WRingType_WRING_TYPE_IPSEC_BIG_NMDR_TX WRingType = 24
	WRingType_WRING_TYPE_IPSEC_BIG_NMDR_RX WRingType = 25
	WRingType_WRING_TYPE_IPSEC_BIG_NMPR_TX WRingType = 26
	WRingType_WRING_TYPE_IPSEC_BIG_NMPR_RX WRingType = 27
	WRingType_WRING_TYPE_NMDPR_SMALL_TX    WRingType = 28
	WRingType_WRING_TYPE_NMDPR_SMALL_RX    WRingType = 29
	WRingType_WRING_TYPE_NMDPR_BIG_TX      WRingType = 30
	WRingType_WRING_TYPE_NMDPR_BIG_RX      WRingType = 31
	WRingType_WRING_TYPE_TCP_OOO_RX        WRingType = 32
	WRingType_WRING_TYPE_TCP_OOO_RX2TX     WRingType = 33
	WRingType_WRING_TYPE_CPU_RX_DPR        WRingType = 34
	WRingType_WRING_TYPE_TCP_ACTL_Q        WRingType = 35
)

var WRingType_name = map[int32]string{
	0:  "WRING_TYPE_NONE",
	1:  "WRING_TYPE_SERQ",
	2:  "WRING_TYPE_BSQ",
	3:  "WRING_TYPE_BRQ",
	4:  "WRING_TYPE_SESQ",
	5:  "WRING_TYPE_IPSECCBQ",
	6:  "WRING_TYPE_ARQRX",
	7:  "WRING_TYPE_ASQ",
	8:  "WRING_TYPE_ASESQ",
	9:  "WRING_TYPE_RAWRCB",
	10: "WRING_TYPE_IPSECCBQ_BARCO",
	11: "WRING_TYPE_APP_REDIR_RAWC",
	12: "WRING_TYPE_APP_REDIR_PROXYR",
	13: "WRING_TYPE_APP_REDIR_PROXYC",
	14: "WRING_TYPE_NMDR_RX_GC",
	15: "WRING_TYPE_NMDR_TX_GC",
	16: "WRING_TYPE_ARQTX",
	17: "WRING_TYPE_ASCQ",
	18: "WRING_TYPE_CPU_TX_DR",
	19: "WRING_TYPE_CPU_TX_PR",
	20: "WRING_TYPE_IPSEC_NMDR_TX",
	21: "WRING_TYPE_IPSEC_NMDR_RX",
	22: "WRING_TYPE_IPSEC_NMPR_TX",
	23: "WRING_TYPE_IPSEC_NMPR_RX",
	24: "WRING_TYPE_IPSEC_BIG_NMDR_TX",
	25: "WRING_TYPE_IPSEC_BIG_NMDR_RX",
	26: "WRING_TYPE_IPSEC_BIG_NMPR_TX",
	27: "WRING_TYPE_IPSEC_BIG_NMPR_RX",
	28: "WRING_TYPE_NMDPR_SMALL_TX",
	29: "WRING_TYPE_NMDPR_SMALL_RX",
	30: "WRING_TYPE_NMDPR_BIG_TX",
	31: "WRING_TYPE_NMDPR_BIG_RX",
	32: "WRING_TYPE_TCP_OOO_RX",
	33: "WRING_TYPE_TCP_OOO_RX2TX",
	34: "WRING_TYPE_CPU_RX_DPR",
	35: "WRING_TYPE_TCP_ACTL_Q",
}
var WRingType_value = map[string]int32{
	"WRING_TYPE_NONE":              0,
	"WRING_TYPE_SERQ":              1,
	"WRING_TYPE_BSQ":               2,
	"WRING_TYPE_BRQ":               3,
	"WRING_TYPE_SESQ":              4,
	"WRING_TYPE_IPSECCBQ":          5,
	"WRING_TYPE_ARQRX":             6,
	"WRING_TYPE_ASQ":               7,
	"WRING_TYPE_ASESQ":             8,
	"WRING_TYPE_RAWRCB":            9,
	"WRING_TYPE_IPSECCBQ_BARCO":    10,
	"WRING_TYPE_APP_REDIR_RAWC":    11,
	"WRING_TYPE_APP_REDIR_PROXYR":  12,
	"WRING_TYPE_APP_REDIR_PROXYC":  13,
	"WRING_TYPE_NMDR_RX_GC":        14,
	"WRING_TYPE_NMDR_TX_GC":        15,
	"WRING_TYPE_ARQTX":             16,
	"WRING_TYPE_ASCQ":              17,
	"WRING_TYPE_CPU_TX_DR":         18,
	"WRING_TYPE_CPU_TX_PR":         19,
	"WRING_TYPE_IPSEC_NMDR_TX":     20,
	"WRING_TYPE_IPSEC_NMDR_RX":     21,
	"WRING_TYPE_IPSEC_NMPR_TX":     22,
	"WRING_TYPE_IPSEC_NMPR_RX":     23,
	"WRING_TYPE_IPSEC_BIG_NMDR_TX": 24,
	"WRING_TYPE_IPSEC_BIG_NMDR_RX": 25,
	"WRING_TYPE_IPSEC_BIG_NMPR_TX": 26,
	"WRING_TYPE_IPSEC_BIG_NMPR_RX": 27,
	"WRING_TYPE_NMDPR_SMALL_TX":    28,
	"WRING_TYPE_NMDPR_SMALL_RX":    29,
	"WRING_TYPE_NMDPR_BIG_TX":      30,
	"WRING_TYPE_NMDPR_BIG_RX":      31,
	"WRING_TYPE_TCP_OOO_RX":        32,
	"WRING_TYPE_TCP_OOO_RX2TX":     33,
	"WRING_TYPE_CPU_RX_DPR":        34,
	"WRING_TYPE_TCP_ACTL_Q":        35,
}

func (x WRingType) String() string {
	return proto.EnumName(WRingType_name, int32(x))
}
func (WRingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

// Types of Proxy Service
type ProxyType int32

const (
	ProxyType_PROXY_TYPE_NONE                     ProxyType = 0
	ProxyType_PROXY_TYPE_TCP                      ProxyType = 1
	ProxyType_PROXY_TYPE_TLS                      ProxyType = 2
	ProxyType_PROXY_TYPE_IPSEC                    ProxyType = 3
	ProxyType_PROXY_TYPE_GC                       ProxyType = 4
	ProxyType_PROXY_TYPE_IPFIX                    ProxyType = 6
	ProxyType_PROXY_TYPE_APP_REDIR                ProxyType = 7
	ProxyType_PROXY_TYPE_P4PT                     ProxyType = 8
	ProxyType_PROXY_TYPE_APP_REDIR_PROXY_TCP      ProxyType = 9
	ProxyType_PROXY_TYPE_APP_REDIR_SPAN           ProxyType = 10
	ProxyType_PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN ProxyType = 11
	ProxyType_PROXY_TYPE_NVME                     ProxyType = 12
)

var ProxyType_name = map[int32]string{
	0:  "PROXY_TYPE_NONE",
	1:  "PROXY_TYPE_TCP",
	2:  "PROXY_TYPE_TLS",
	3:  "PROXY_TYPE_IPSEC",
	4:  "PROXY_TYPE_GC",
	6:  "PROXY_TYPE_IPFIX",
	7:  "PROXY_TYPE_APP_REDIR",
	8:  "PROXY_TYPE_P4PT",
	9:  "PROXY_TYPE_APP_REDIR_PROXY_TCP",
	10: "PROXY_TYPE_APP_REDIR_SPAN",
	11: "PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN",
	12: "PROXY_TYPE_NVME",
}
var ProxyType_value = map[string]int32{
	"PROXY_TYPE_NONE":                     0,
	"PROXY_TYPE_TCP":                      1,
	"PROXY_TYPE_TLS":                      2,
	"PROXY_TYPE_IPSEC":                    3,
	"PROXY_TYPE_GC":                       4,
	"PROXY_TYPE_IPFIX":                    6,
	"PROXY_TYPE_APP_REDIR":                7,
	"PROXY_TYPE_P4PT":                     8,
	"PROXY_TYPE_APP_REDIR_PROXY_TCP":      9,
	"PROXY_TYPE_APP_REDIR_SPAN":           10,
	"PROXY_TYPE_APP_REDIR_PROXY_TCP_SPAN": 11,
	"PROXY_TYPE_NVME":                     12,
}

func (x ProxyType) String() string {
	return proto.EnumName(ProxyType_name, int32(x))
}
func (ProxyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

// Types of Cryptographic Asymmetric keys
type CryptoAsymKeyType int32

const (
	CryptoAsymKeyType_CRYPTO_ASYM_KEY_TYPE_ECDSA CryptoAsymKeyType = 0
	CryptoAsymKeyType_CRYPTO_ASYM_KEY_TYPE_RSA   CryptoAsymKeyType = 1
)

var CryptoAsymKeyType_name = map[int32]string{
	0: "CRYPTO_ASYM_KEY_TYPE_ECDSA",
	1: "CRYPTO_ASYM_KEY_TYPE_RSA",
}
var CryptoAsymKeyType_value = map[string]int32{
	"CRYPTO_ASYM_KEY_TYPE_ECDSA": 0,
	"CRYPTO_ASYM_KEY_TYPE_RSA":   1,
}

func (x CryptoAsymKeyType) String() string {
	return proto.EnumName(CryptoAsymKeyType_name, int32(x))
}
func (CryptoAsymKeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

// Types of Cryptographic keys
type CryptoKeyType int32

const (
	CryptoKeyType_CRYPTO_KEY_TYPE_AES128   CryptoKeyType = 0
	CryptoKeyType_CRYPTO_KEY_TYPE_AES192   CryptoKeyType = 1
	CryptoKeyType_CRYPTO_KEY_TYPE_AES256   CryptoKeyType = 2
	CryptoKeyType_CRYPTO_KEY_TYPE_DES      CryptoKeyType = 3
	CryptoKeyType_CRYPTO_KEY_TYPE_CHACHA20 CryptoKeyType = 4
	CryptoKeyType_CRYPTO_KEY_TYPE_POLY1305 CryptoKeyType = 5
	CryptoKeyType_CRYPTO_KEY_TYPE_HMAC     CryptoKeyType = 6
)

var CryptoKeyType_name = map[int32]string{
	0: "CRYPTO_KEY_TYPE_AES128",
	1: "CRYPTO_KEY_TYPE_AES192",
	2: "CRYPTO_KEY_TYPE_AES256",
	3: "CRYPTO_KEY_TYPE_DES",
	4: "CRYPTO_KEY_TYPE_CHACHA20",
	5: "CRYPTO_KEY_TYPE_POLY1305",
	6: "CRYPTO_KEY_TYPE_HMAC",
}
var CryptoKeyType_value = map[string]int32{
	"CRYPTO_KEY_TYPE_AES128":   0,
	"CRYPTO_KEY_TYPE_AES192":   1,
	"CRYPTO_KEY_TYPE_AES256":   2,
	"CRYPTO_KEY_TYPE_DES":      3,
	"CRYPTO_KEY_TYPE_CHACHA20": 4,
	"CRYPTO_KEY_TYPE_POLY1305": 5,
	"CRYPTO_KEY_TYPE_HMAC":     6,
}

func (x CryptoKeyType) String() string {
	return proto.EnumName(CryptoKeyType_name, int32(x))
}
func (CryptoKeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

// Types of Barco Rings
type BarcoRings int32

const (
	BarcoRings_BARCO_RING_ASYM   BarcoRings = 0
	BarcoRings_BARCO_RING_GCM0   BarcoRings = 1
	BarcoRings_BARCO_RING_GCM1   BarcoRings = 2
	BarcoRings_BARCO_RING_XTS0   BarcoRings = 3
	BarcoRings_BARCO_RING_XTS1   BarcoRings = 4
	BarcoRings_BARCO_RING_MPP0   BarcoRings = 5
	BarcoRings_BARCO_RING_MPP1   BarcoRings = 6
	BarcoRings_BARCO_RING_MPP2   BarcoRings = 7
	BarcoRings_BARCO_RING_MPP3   BarcoRings = 8
	BarcoRings_BARCO_RING_MPP4   BarcoRings = 9
	BarcoRings_BARCO_RING_MPP5   BarcoRings = 10
	BarcoRings_BARCO_RING_MPP6   BarcoRings = 11
	BarcoRings_BARCO_RING_MPP7   BarcoRings = 12
	BarcoRings_BARCO_RING_CP     BarcoRings = 13
	BarcoRings_BARCO_RING_CP_HOT BarcoRings = 14
	BarcoRings_BARCO_RING_DC     BarcoRings = 15
	BarcoRings_BARCO_RING_DC_HOT BarcoRings = 16
)

var BarcoRings_name = map[int32]string{
	0:  "BARCO_RING_ASYM",
	1:  "BARCO_RING_GCM0",
	2:  "BARCO_RING_GCM1",
	3:  "BARCO_RING_XTS0",
	4:  "BARCO_RING_XTS1",
	5:  "BARCO_RING_MPP0",
	6:  "BARCO_RING_MPP1",
	7:  "BARCO_RING_MPP2",
	8:  "BARCO_RING_MPP3",
	9:  "BARCO_RING_MPP4",
	10: "BARCO_RING_MPP5",
	11: "BARCO_RING_MPP6",
	12: "BARCO_RING_MPP7",
	13: "BARCO_RING_CP",
	14: "BARCO_RING_CP_HOT",
	15: "BARCO_RING_DC",
	16: "BARCO_RING_DC_HOT",
}
var BarcoRings_value = map[string]int32{
	"BARCO_RING_ASYM":   0,
	"BARCO_RING_GCM0":   1,
	"BARCO_RING_GCM1":   2,
	"BARCO_RING_XTS0":   3,
	"BARCO_RING_XTS1":   4,
	"BARCO_RING_MPP0":   5,
	"BARCO_RING_MPP1":   6,
	"BARCO_RING_MPP2":   7,
	"BARCO_RING_MPP3":   8,
	"BARCO_RING_MPP4":   9,
	"BARCO_RING_MPP5":   10,
	"BARCO_RING_MPP6":   11,
	"BARCO_RING_MPP7":   12,
	"BARCO_RING_CP":     13,
	"BARCO_RING_CP_HOT": 14,
	"BARCO_RING_DC":     15,
	"BARCO_RING_DC_HOT": 16,
}

func (x BarcoRings) String() string {
	return proto.EnumName(BarcoRings_name, int32(x))
}
func (BarcoRings) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

type AppRedirType int32

const (
	AppRedirType_APP_REDIR_TYPE_NONE     AppRedirType = 0
	AppRedirType_APP_REDIR_TYPE_REDIRECT AppRedirType = 1
	AppRedirType_APP_REDIR_TYPE_SPAN     AppRedirType = 2
)

var AppRedirType_name = map[int32]string{
	0: "APP_REDIR_TYPE_NONE",
	1: "APP_REDIR_TYPE_REDIRECT",
	2: "APP_REDIR_TYPE_SPAN",
}
var AppRedirType_value = map[string]int32{
	"APP_REDIR_TYPE_NONE":     0,
	"APP_REDIR_TYPE_REDIRECT": 1,
	"APP_REDIR_TYPE_SPAN":     2,
}

func (x AppRedirType) String() string {
	return proto.EnumName(AppRedirType_name, int32(x))
}
func (AppRedirType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

// Types of CPU CB/QIDs
type CpucbId int32

const (
	CpucbId_CPUCB_ID_FLOWMISS      CpucbId = 0
	CpucbId_CPUCB_ID_TCP_CLOSE     CpucbId = 1
	CpucbId_CPUCB_ID_RELIABLE_COPY CpucbId = 2
	CpucbId_CPUCB_ID_NACL_REDIRECT CpucbId = 3
	CpucbId_CPUCB_ID_QUIESCE       CpucbId = 4
	CpucbId_CPUCB_ID_NACL_LOG      CpucbId = 5
	CpucbId_CPUCB_ID_FTE_SPAN      CpucbId = 6
)

var CpucbId_name = map[int32]string{
	0: "CPUCB_ID_FLOWMISS",
	1: "CPUCB_ID_TCP_CLOSE",
	2: "CPUCB_ID_RELIABLE_COPY",
	3: "CPUCB_ID_NACL_REDIRECT",
	4: "CPUCB_ID_QUIESCE",
	5: "CPUCB_ID_NACL_LOG",
	6: "CPUCB_ID_FTE_SPAN",
}
var CpucbId_value = map[string]int32{
	"CPUCB_ID_FLOWMISS":      0,
	"CPUCB_ID_TCP_CLOSE":     1,
	"CPUCB_ID_RELIABLE_COPY": 2,
	"CPUCB_ID_NACL_REDIRECT": 3,
	"CPUCB_ID_QUIESCE":       4,
	"CPUCB_ID_NACL_LOG":      5,
	"CPUCB_ID_FTE_SPAN":      6,
}

func (x CpucbId) String() string {
	return proto.EnumName(CpucbId_name, int32(x))
}
func (CpucbId) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

// FTE Span Match Selectors
type FTESpanMatchSelector int32

const (
	FTESpanMatchSelector_SRC_LIF         FTESpanMatchSelector = 0
	FTESpanMatchSelector_SRC_LPORT       FTESpanMatchSelector = 1
	FTESpanMatchSelector_DST_LPORT       FTESpanMatchSelector = 2
	FTESpanMatchSelector_DROP_REASON     FTESpanMatchSelector = 3
	FTESpanMatchSelector_FLOW_LKUP_DIR   FTESpanMatchSelector = 4
	FTESpanMatchSelector_FLOW_LKUP_TYPE  FTESpanMatchSelector = 5
	FTESpanMatchSelector_FLOW_LKUP_VRF   FTESpanMatchSelector = 6
	FTESpanMatchSelector_FLOW_LKUP_SRC   FTESpanMatchSelector = 7
	FTESpanMatchSelector_FLOW_LKUP_DST   FTESpanMatchSelector = 8
	FTESpanMatchSelector_FLOW_LKUP_PROTO FTESpanMatchSelector = 9
	FTESpanMatchSelector_FLOW_LKUP_SPORT FTESpanMatchSelector = 10
	FTESpanMatchSelector_FLOW_LKUP_DPORT FTESpanMatchSelector = 11
	FTESpanMatchSelector_ETH_DMAC        FTESpanMatchSelector = 12
	FTESpanMatchSelector_FROM_CPU        FTESpanMatchSelector = 13
	FTESpanMatchSelector_MATCH_ANY       FTESpanMatchSelector = 14
)

var FTESpanMatchSelector_name = map[int32]string{
	0:  "SRC_LIF",
	1:  "SRC_LPORT",
	2:  "DST_LPORT",
	3:  "DROP_REASON",
	4:  "FLOW_LKUP_DIR",
	5:  "FLOW_LKUP_TYPE",
	6:  "FLOW_LKUP_VRF",
	7:  "FLOW_LKUP_SRC",
	8:  "FLOW_LKUP_DST",
	9:  "FLOW_LKUP_PROTO",
	10: "FLOW_LKUP_SPORT",
	11: "FLOW_LKUP_DPORT",
	12: "ETH_DMAC",
	13: "FROM_CPU",
	14: "MATCH_ANY",
}
var FTESpanMatchSelector_value = map[string]int32{
	"SRC_LIF":         0,
	"SRC_LPORT":       1,
	"DST_LPORT":       2,
	"DROP_REASON":     3,
	"FLOW_LKUP_DIR":   4,
	"FLOW_LKUP_TYPE":  5,
	"FLOW_LKUP_VRF":   6,
	"FLOW_LKUP_SRC":   7,
	"FLOW_LKUP_DST":   8,
	"FLOW_LKUP_PROTO": 9,
	"FLOW_LKUP_SPORT": 10,
	"FLOW_LKUP_DPORT": 11,
	"ETH_DMAC":        12,
	"FROM_CPU":        13,
	"MATCH_ANY":       14,
}

func (x FTESpanMatchSelector) String() string {
	return proto.EnumName(FTESpanMatchSelector_name, int32(x))
}
func (FTESpanMatchSelector) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

// flow direction
type FlowDirection int32

const (
	FlowDirection_FLOW_DIRECTION_NONE        FlowDirection = 0
	FlowDirection_FLOW_DIRECTION_FROM_HOST   FlowDirection = 1
	FlowDirection_FLOW_DIRECTION_FROM_UPLINK FlowDirection = 2
)

var FlowDirection_name = map[int32]string{
	0: "FLOW_DIRECTION_NONE",
	1: "FLOW_DIRECTION_FROM_HOST",
	2: "FLOW_DIRECTION_FROM_UPLINK",
}
var FlowDirection_value = map[string]int32{
	"FLOW_DIRECTION_NONE":        0,
	"FLOW_DIRECTION_FROM_HOST":   1,
	"FLOW_DIRECTION_FROM_UPLINK": 2,
}

func (x FlowDirection) String() string {
	return proto.EnumName(FlowDirection_name, int32(x))
}
func (FlowDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

type HashType int32

const (
	HashType_SHA1   HashType = 0
	HashType_SHA224 HashType = 1
	HashType_SHA256 HashType = 2
	HashType_SHA384 HashType = 3
	HashType_SHA512 HashType = 4
)

var HashType_name = map[int32]string{
	0: "SHA1",
	1: "SHA224",
	2: "SHA256",
	3: "SHA384",
	4: "SHA512",
}
var HashType_value = map[string]int32{
	"SHA1":   0,
	"SHA224": 1,
	"SHA256": 2,
	"SHA384": 3,
	"SHA512": 4,
}

func (x HashType) String() string {
	return proto.EnumName(HashType_name, int32(x))
}
func (HashType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

type RSASignatureScheme int32

const (
	RSASignatureScheme_RSASSA_PSS        RSASignatureScheme = 0
	RSASignatureScheme_RSASSA_PKCS1_v1_5 RSASignatureScheme = 1
)

var RSASignatureScheme_name = map[int32]string{
	0: "RSASSA_PSS",
	1: "RSASSA_PKCS1_v1_5",
}
var RSASignatureScheme_value = map[string]int32{
	"RSASSA_PSS":        0,
	"RSASSA_PKCS1_v1_5": 1,
}

func (x RSASignatureScheme) String() string {
	return proto.EnumName(RSASignatureScheme_name, int32(x))
}
func (RSASignatureScheme) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_TYPE_NONE                 NatAction = 0
	NatAction_NAT_TYPE_STATIC_ADDRESS       NatAction = 1
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS      NatAction = 2
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS_PORT NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_STATIC_ADDRESS",
	2: "NAT_TYPE_DYNAMIC_ADDRESS",
	3: "NAT_TYPE_DYNAMIC_ADDRESS_PORT",
}
var NatAction_value = map[string]int32{
	"NAT_TYPE_NONE":                 0,
	"NAT_TYPE_STATIC_ADDRESS":       1,
	"NAT_TYPE_DYNAMIC_ADDRESS":      2,
	"NAT_TYPE_DYNAMIC_ADDRESS_PORT": 3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}
func (NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

// common meta object that is part of all other top level objects
// TODO: should we add last updated timestamp, revision etc. here ?
type ObjectMeta struct {
	VrfId uint64 `protobuf:"fixed64,1,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
}

func (m *ObjectMeta) Reset()                    { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()               {}
func (*ObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *ObjectMeta) GetVrfId() uint64 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

// Captures the MPLS tag information
type MplsTag struct {
	Label uint32 `protobuf:"varint,1,opt,name=label,proto3" json:"label,omitempty" venice:mandatory`
	Exp   uint32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty" venice:default=0`
	Ttl   uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty" venice:default=64`
}

func (m *MplsTag) Reset()                    { *m = MplsTag{} }
func (m *MplsTag) String() string            { return proto.CompactTextString(m) }
func (*MplsTag) ProtoMessage()               {}
func (*MplsTag) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *MplsTag) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *MplsTag) GetExp() uint32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *MplsTag) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// EncapInfo captures wire encap information
type EncapInfo struct {
	EncapType  EncapType `protobuf:"varint,1,opt,name=encap_type,json=encapType,proto3,enum=types.EncapType" json:"encap_type,omitempty"`
	EncapValue uint32    `protobuf:"varint,2,opt,name=encap_value,json=encapValue,proto3" json:"encap_value,omitempty"`
}

func (m *EncapInfo) Reset()                    { *m = EncapInfo{} }
func (m *EncapInfo) String() string            { return proto.CompactTextString(m) }
func (*EncapInfo) ProtoMessage()               {}
func (*EncapInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *EncapInfo) GetEncapType() EncapType {
	if m != nil {
		return m.EncapType
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *EncapInfo) GetEncapValue() uint32 {
	if m != nil {
		return m.EncapValue
	}
	return 0
}

// IP address object
type IPAddress struct {
	IpAf IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,proto3,enum=types.IPAddressFamily" json:"ip_af,omitempty" venice:mandatory`
	// Types that are valid to be assigned to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6 isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddress_V4Addr struct {
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=v4_addr,json=v4Addr,proto3,oneof"`
}
type IPAddress_V6Addr struct {
	V6Addr []byte `protobuf:"bytes,3,opt,name=v6_addr,json=v6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}
func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (m *IPAddress) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPAddress) GetV4Addr() uint32 {
	if x, ok := m.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (m *IPAddress) GetV6Addr() []byte {
	if x, ok := m.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddress_OneofMarshaler, _IPAddress_OneofUnmarshaler, _IPAddress_OneofSizer, []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
}

func _IPAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.V4Addr))
	case *IPAddress_V6Addr:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.V6Addr)
	case nil:
	default:
		return fmt.Errorf("IPAddress.V4OrV6 has unexpected type %T", x)
	}
	return nil
}

func _IPAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddress)
	switch tag {
	case 2: // v4_or_v6.v4_addr
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.V4OrV6 = &IPAddress_V4Addr{uint32(x)}
		return true, err
	case 3: // v4_or_v6.v6_addr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.V4OrV6 = &IPAddress_V6Addr{x}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case *IPAddress_V6Addr:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.V6Addr)))
		n += len(x.V6Addr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IP Range
type IPRange struct {
	LowIpaddr  *IPAddress `protobuf:"bytes,1,opt,name=low_ipaddr,json=lowIpaddr" json:"low_ipaddr,omitempty"`
	HighIpaddr *IPAddress `protobuf:"bytes,2,opt,name=high_ipaddr,json=highIpaddr" json:"high_ipaddr,omitempty"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (m *IPRange) String() string            { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *IPRange) GetLowIpaddr() *IPAddress {
	if m != nil {
		return m.LowIpaddr
	}
	return nil
}

func (m *IPRange) GetHighIpaddr() *IPAddress {
	if m != nil {
		return m.HighIpaddr
	}
	return nil
}

// IP Prefix object
type IPPrefix struct {
	Address   *IPAddress `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	PrefixLen uint32     `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty" venice:range:0-128`
}

func (m *IPPrefix) Reset()                    { *m = IPPrefix{} }
func (m *IPPrefix) String() string            { return proto.CompactTextString(m) }
func (*IPPrefix) ProtoMessage()               {}
func (*IPPrefix) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *IPPrefix) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// IPSubnet represents an IPv4 or IPv6 subnet
type IPSubnet struct {
	// Types that are valid to be assigned to Subnet:
	//	*IPSubnet_Ipv4Subnet
	//	*IPSubnet_Ipv6Subnet
	Subnet isIPSubnet_Subnet `protobuf_oneof:"subnet"`
}

func (m *IPSubnet) Reset()                    { *m = IPSubnet{} }
func (m *IPSubnet) String() string            { return proto.CompactTextString(m) }
func (*IPSubnet) ProtoMessage()               {}
func (*IPSubnet) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isIPSubnet_Subnet interface {
	isIPSubnet_Subnet()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPSubnet_Ipv4Subnet struct {
	Ipv4Subnet *IPPrefix `protobuf:"bytes,1,opt,name=ipv4_subnet,json=ipv4Subnet,oneof"`
}
type IPSubnet_Ipv6Subnet struct {
	Ipv6Subnet *IPPrefix `protobuf:"bytes,2,opt,name=ipv6_subnet,json=ipv6Subnet,oneof"`
}

func (*IPSubnet_Ipv4Subnet) isIPSubnet_Subnet() {}
func (*IPSubnet_Ipv6Subnet) isIPSubnet_Subnet() {}

func (m *IPSubnet) GetSubnet() isIPSubnet_Subnet {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *IPSubnet) GetIpv4Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_Ipv4Subnet); ok {
		return x.Ipv4Subnet
	}
	return nil
}

func (m *IPSubnet) GetIpv6Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_Ipv6Subnet); ok {
		return x.Ipv6Subnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSubnet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSubnet_OneofMarshaler, _IPSubnet_OneofUnmarshaler, _IPSubnet_OneofSizer, []interface{}{
		(*IPSubnet_Ipv4Subnet)(nil),
		(*IPSubnet_Ipv6Subnet)(nil),
	}
}

func _IPSubnet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSubnet)
	// subnet
	switch x := m.Subnet.(type) {
	case *IPSubnet_Ipv4Subnet:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4Subnet); err != nil {
			return err
		}
	case *IPSubnet_Ipv6Subnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6Subnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSubnet.Subnet has unexpected type %T", x)
	}
	return nil
}

func _IPSubnet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSubnet)
	switch tag {
	case 1: // subnet.ipv4_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Subnet = &IPSubnet_Ipv4Subnet{msg}
		return true, err
	case 2: // subnet.ipv6_subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Subnet = &IPSubnet_Ipv6Subnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSubnet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSubnet)
	// subnet
	switch x := m.Subnet.(type) {
	case *IPSubnet_Ipv4Subnet:
		s := proto.Size(x.Ipv4Subnet)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSubnet_Ipv6Subnet:
		s := proto.Size(x.Ipv6Subnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AddressRange represents an IPv4 or IPv6 address range
type AddressRange struct {
	// Types that are valid to be assigned to Range:
	//	*AddressRange_Ipv4Range
	//	*AddressRange_Ipv6Range
	Range isAddressRange_Range `protobuf_oneof:"range"`
}

func (m *AddressRange) Reset()                    { *m = AddressRange{} }
func (m *AddressRange) String() string            { return proto.CompactTextString(m) }
func (*AddressRange) ProtoMessage()               {}
func (*AddressRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isAddressRange_Range interface {
	isAddressRange_Range()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AddressRange_Ipv4Range struct {
	Ipv4Range *IPRange `protobuf:"bytes,1,opt,name=ipv4_range,json=ipv4Range,oneof"`
}
type AddressRange_Ipv6Range struct {
	Ipv6Range *IPRange `protobuf:"bytes,2,opt,name=ipv6_range,json=ipv6Range,oneof"`
}

func (*AddressRange_Ipv4Range) isAddressRange_Range() {}
func (*AddressRange_Ipv6Range) isAddressRange_Range() {}

func (m *AddressRange) GetRange() isAddressRange_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *AddressRange) GetIpv4Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_Ipv4Range); ok {
		return x.Ipv4Range
	}
	return nil
}

func (m *AddressRange) GetIpv6Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_Ipv6Range); ok {
		return x.Ipv6Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AddressRange) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AddressRange_OneofMarshaler, _AddressRange_OneofUnmarshaler, _AddressRange_OneofSizer, []interface{}{
		(*AddressRange_Ipv4Range)(nil),
		(*AddressRange_Ipv6Range)(nil),
	}
}

func _AddressRange_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AddressRange)
	// range
	switch x := m.Range.(type) {
	case *AddressRange_Ipv4Range:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4Range); err != nil {
			return err
		}
	case *AddressRange_Ipv6Range:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AddressRange.Range has unexpected type %T", x)
	}
	return nil
}

func _AddressRange_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AddressRange)
	switch tag {
	case 1: // range.ipv4_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.Range = &AddressRange_Ipv4Range{msg}
		return true, err
	case 2: // range.ipv6_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.Range = &AddressRange_Ipv6Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AddressRange_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AddressRange)
	// range
	switch x := m.Range.(type) {
	case *AddressRange_Ipv4Range:
		s := proto.Size(x.Ipv4Range)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AddressRange_Ipv6Range:
		s := proto.Size(x.Ipv6Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Address object is the prefix or range
type Address struct {
	// Types that are valid to be assigned to Address:
	//	*Address_Prefix
	//	*Address_Range
	Address isAddress_Address `protobuf_oneof:"Address"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isAddress_Address interface {
	isAddress_Address()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Address_Prefix struct {
	Prefix *IPSubnet `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type Address_Range struct {
	Range *AddressRange `protobuf:"bytes,2,opt,name=range,oneof"`
}

func (*Address_Prefix) isAddress_Address() {}
func (*Address_Range) isAddress_Address()  {}

func (m *Address) GetAddress() isAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Address) GetPrefix() *IPSubnet {
	if x, ok := m.GetAddress().(*Address_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *Address) GetRange() *AddressRange {
	if x, ok := m.GetAddress().(*Address_Range); ok {
		return x.Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Address) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Address_OneofMarshaler, _Address_OneofUnmarshaler, _Address_OneofSizer, []interface{}{
		(*Address_Prefix)(nil),
		(*Address_Range)(nil),
	}
}

func _Address_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Address)
	// Address
	switch x := m.Address.(type) {
	case *Address_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *Address_Range:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Address.Address has unexpected type %T", x)
	}
	return nil
}

func _Address_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Address)
	switch tag {
	case 1: // Address.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSubnet)
		err := b.DecodeMessage(msg)
		m.Address = &Address_Prefix{msg}
		return true, err
	case 2: // Address.range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Address = &Address_Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Address_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Address)
	// Address
	switch x := m.Address.(type) {
	case *Address_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Address_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type IPAddressObj struct {
	// Types that are valid to be assigned to Formats:
	//	*IPAddressObj_Type
	//	*IPAddressObj_Address
	Formats isIPAddressObj_Formats `protobuf_oneof:"Formats"`
	Negate  bool                   `protobuf:"varint,3,opt,name=negate,proto3" json:"negate,omitempty"`
}

func (m *IPAddressObj) Reset()                    { *m = IPAddressObj{} }
func (m *IPAddressObj) String() string            { return proto.CompactTextString(m) }
func (*IPAddressObj) ProtoMessage()               {}
func (*IPAddressObj) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isIPAddressObj_Formats interface {
	isIPAddressObj_Formats()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddressObj_Type struct {
	Type IPAddressType `protobuf:"varint,1,opt,name=type,proto3,enum=types.IPAddressType,oneof"`
}
type IPAddressObj_Address struct {
	Address *Address `protobuf:"bytes,2,opt,name=address,oneof"`
}

func (*IPAddressObj_Type) isIPAddressObj_Formats()    {}
func (*IPAddressObj_Address) isIPAddressObj_Formats() {}

func (m *IPAddressObj) GetFormats() isIPAddressObj_Formats {
	if m != nil {
		return m.Formats
	}
	return nil
}

func (m *IPAddressObj) GetType() IPAddressType {
	if x, ok := m.GetFormats().(*IPAddressObj_Type); ok {
		return x.Type
	}
	return IPAddressType_IP_ADDRESS_NONE
}

func (m *IPAddressObj) GetAddress() *Address {
	if x, ok := m.GetFormats().(*IPAddressObj_Address); ok {
		return x.Address
	}
	return nil
}

func (m *IPAddressObj) GetNegate() bool {
	if m != nil {
		return m.Negate
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddressObj) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddressObj_OneofMarshaler, _IPAddressObj_OneofUnmarshaler, _IPAddressObj_OneofSizer, []interface{}{
		(*IPAddressObj_Type)(nil),
		(*IPAddressObj_Address)(nil),
	}
}

func _IPAddressObj_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddressObj)
	// Formats
	switch x := m.Formats.(type) {
	case *IPAddressObj_Type:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Type))
	case *IPAddressObj_Address:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPAddressObj.Formats has unexpected type %T", x)
	}
	return nil
}

func _IPAddressObj_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddressObj)
	switch tag {
	case 1: // Formats.type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Formats = &IPAddressObj_Type{IPAddressType(x)}
		return true, err
	case 2: // Formats.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Address)
		err := b.DecodeMessage(msg)
		m.Formats = &IPAddressObj_Address{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddressObj_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddressObj)
	// Formats
	switch x := m.Formats.(type) {
	case *IPAddressObj_Type:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Type))
	case *IPAddressObj_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PortRange object has low and high end of the port ranges
type L4PortRange struct {
	PortLow  uint32 `protobuf:"varint,1,opt,name=port_low,json=portLow,proto3" json:"port_low,omitempty" venice:range:0-65535`
	PortHigh uint32 `protobuf:"varint,2,opt,name=port_high,json=portHigh,proto3" json:"port_high,omitempty" venice:range:0-65535`
}

func (m *L4PortRange) Reset()                    { *m = L4PortRange{} }
func (m *L4PortRange) String() string            { return proto.CompactTextString(m) }
func (*L4PortRange) ProtoMessage()               {}
func (*L4PortRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *L4PortRange) GetPortLow() uint32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *L4PortRange) GetPortHigh() uint32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type DropReasons struct {
	DropMalformedPkt                bool `protobuf:"varint,1,opt,name=drop_malformed_pkt,json=dropMalformedPkt,proto3" json:"drop_malformed_pkt,omitempty"`
	DropParserIcrcError             bool `protobuf:"varint,2,opt,name=drop_parser_icrc_error,json=dropParserIcrcError,proto3" json:"drop_parser_icrc_error,omitempty"`
	DropParseLenError               bool `protobuf:"varint,3,opt,name=drop_parse_len_error,json=dropParseLenError,proto3" json:"drop_parse_len_error,omitempty"`
	DropHardwareError               bool `protobuf:"varint,4,opt,name=drop_hardware_error,json=dropHardwareError,proto3" json:"drop_hardware_error,omitempty"`
	DropInputMapping                bool `protobuf:"varint,5,opt,name=drop_input_mapping,json=dropInputMapping,proto3" json:"drop_input_mapping,omitempty"`
	DropInputMappingDejavu          bool `protobuf:"varint,6,opt,name=drop_input_mapping_dejavu,json=dropInputMappingDejavu,proto3" json:"drop_input_mapping_dejavu,omitempty"`
	DropMultiDestNotPinnedUplink    bool `protobuf:"varint,7,opt,name=drop_multi_dest_not_pinned_uplink,json=dropMultiDestNotPinnedUplink,proto3" json:"drop_multi_dest_not_pinned_uplink,omitempty"`
	DropFlowHit                     bool `protobuf:"varint,8,opt,name=drop_flow_hit,json=dropFlowHit,proto3" json:"drop_flow_hit,omitempty"`
	DropFlowMiss                    bool `protobuf:"varint,9,opt,name=drop_flow_miss,json=dropFlowMiss,proto3" json:"drop_flow_miss,omitempty"`
	DropNacl                        bool `protobuf:"varint,10,opt,name=drop_nacl,json=dropNacl,proto3" json:"drop_nacl,omitempty"`
	DropIpsg                        bool `protobuf:"varint,11,opt,name=drop_ipsg,json=dropIpsg,proto3" json:"drop_ipsg,omitempty"`
	DropIpNormalization             bool `protobuf:"varint,12,opt,name=drop_ip_normalization,json=dropIpNormalization,proto3" json:"drop_ip_normalization,omitempty"`
	DropTcpNormalization            bool `protobuf:"varint,13,opt,name=drop_tcp_normalization,json=dropTcpNormalization,proto3" json:"drop_tcp_normalization,omitempty"`
	DropTcpRstWithInvalidAckNum     bool `protobuf:"varint,14,opt,name=drop_tcp_rst_with_invalid_ack_num,json=dropTcpRstWithInvalidAckNum,proto3" json:"drop_tcp_rst_with_invalid_ack_num,omitempty"`
	DropTcpNonSynFirstPkt           bool `protobuf:"varint,15,opt,name=drop_tcp_non_syn_first_pkt,json=dropTcpNonSynFirstPkt,proto3" json:"drop_tcp_non_syn_first_pkt,omitempty"`
	DropIcmpNormalization           bool `protobuf:"varint,16,opt,name=drop_icmp_normalization,json=dropIcmpNormalization,proto3" json:"drop_icmp_normalization,omitempty"`
	DropInputPropertiesMiss         bool `protobuf:"varint,17,opt,name=drop_input_properties_miss,json=dropInputPropertiesMiss,proto3" json:"drop_input_properties_miss,omitempty"`
	DropTcpOutOfWindow              bool `protobuf:"varint,18,opt,name=drop_tcp_out_of_window,json=dropTcpOutOfWindow,proto3" json:"drop_tcp_out_of_window,omitempty"`
	DropTcpSplitHandshake           bool `protobuf:"varint,19,opt,name=drop_tcp_split_handshake,json=dropTcpSplitHandshake,proto3" json:"drop_tcp_split_handshake,omitempty"`
	DropTcpWinZeroDrop              bool `protobuf:"varint,20,opt,name=drop_tcp_win_zero_drop,json=dropTcpWinZeroDrop,proto3" json:"drop_tcp_win_zero_drop,omitempty"`
	DropTcpDataAfterFin             bool `protobuf:"varint,21,opt,name=drop_tcp_data_after_fin,json=dropTcpDataAfterFin,proto3" json:"drop_tcp_data_after_fin,omitempty"`
	DropTcpNonRstPktAfterRst        bool `protobuf:"varint,22,opt,name=drop_tcp_non_rst_pkt_after_rst,json=dropTcpNonRstPktAfterRst,proto3" json:"drop_tcp_non_rst_pkt_after_rst,omitempty"`
	DropTcpInvalidResponderFirstPkt bool `protobuf:"varint,23,opt,name=drop_tcp_invalid_responder_first_pkt,json=dropTcpInvalidResponderFirstPkt,proto3" json:"drop_tcp_invalid_responder_first_pkt,omitempty"`
	DropTcpUnexpectedPkt            bool `protobuf:"varint,24,opt,name=drop_tcp_unexpected_pkt,json=dropTcpUnexpectedPkt,proto3" json:"drop_tcp_unexpected_pkt,omitempty"`
	DropSrcLifMismatch              bool `protobuf:"varint,25,opt,name=drop_src_lif_mismatch,json=dropSrcLifMismatch,proto3" json:"drop_src_lif_mismatch,omitempty"`
	DropVfIpLabelMismatch           bool `protobuf:"varint,26,opt,name=drop_vf_ip_label_mismatch,json=dropVfIpLabelMismatch,proto3" json:"drop_vf_ip_label_mismatch,omitempty"`
	DropVfBadRrDstIp                bool `protobuf:"varint,27,opt,name=drop_vf_bad_rr_dst_ip,json=dropVfBadRrDstIp,proto3" json:"drop_vf_bad_rr_dst_ip,omitempty"`
	DropIcmpFragPkt                 bool `protobuf:"varint,28,opt,name=drop_icmp_frag_pkt,json=dropIcmpFragPkt,proto3" json:"drop_icmp_frag_pkt,omitempty"`
}

func (m *DropReasons) Reset()                    { *m = DropReasons{} }
func (m *DropReasons) String() string            { return proto.CompactTextString(m) }
func (*DropReasons) ProtoMessage()               {}
func (*DropReasons) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *DropReasons) GetDropMalformedPkt() bool {
	if m != nil {
		return m.DropMalformedPkt
	}
	return false
}

func (m *DropReasons) GetDropParserIcrcError() bool {
	if m != nil {
		return m.DropParserIcrcError
	}
	return false
}

func (m *DropReasons) GetDropParseLenError() bool {
	if m != nil {
		return m.DropParseLenError
	}
	return false
}

func (m *DropReasons) GetDropHardwareError() bool {
	if m != nil {
		return m.DropHardwareError
	}
	return false
}

func (m *DropReasons) GetDropInputMapping() bool {
	if m != nil {
		return m.DropInputMapping
	}
	return false
}

func (m *DropReasons) GetDropInputMappingDejavu() bool {
	if m != nil {
		return m.DropInputMappingDejavu
	}
	return false
}

func (m *DropReasons) GetDropMultiDestNotPinnedUplink() bool {
	if m != nil {
		return m.DropMultiDestNotPinnedUplink
	}
	return false
}

func (m *DropReasons) GetDropFlowHit() bool {
	if m != nil {
		return m.DropFlowHit
	}
	return false
}

func (m *DropReasons) GetDropFlowMiss() bool {
	if m != nil {
		return m.DropFlowMiss
	}
	return false
}

func (m *DropReasons) GetDropNacl() bool {
	if m != nil {
		return m.DropNacl
	}
	return false
}

func (m *DropReasons) GetDropIpsg() bool {
	if m != nil {
		return m.DropIpsg
	}
	return false
}

func (m *DropReasons) GetDropIpNormalization() bool {
	if m != nil {
		return m.DropIpNormalization
	}
	return false
}

func (m *DropReasons) GetDropTcpNormalization() bool {
	if m != nil {
		return m.DropTcpNormalization
	}
	return false
}

func (m *DropReasons) GetDropTcpRstWithInvalidAckNum() bool {
	if m != nil {
		return m.DropTcpRstWithInvalidAckNum
	}
	return false
}

func (m *DropReasons) GetDropTcpNonSynFirstPkt() bool {
	if m != nil {
		return m.DropTcpNonSynFirstPkt
	}
	return false
}

func (m *DropReasons) GetDropIcmpNormalization() bool {
	if m != nil {
		return m.DropIcmpNormalization
	}
	return false
}

func (m *DropReasons) GetDropInputPropertiesMiss() bool {
	if m != nil {
		return m.DropInputPropertiesMiss
	}
	return false
}

func (m *DropReasons) GetDropTcpOutOfWindow() bool {
	if m != nil {
		return m.DropTcpOutOfWindow
	}
	return false
}

func (m *DropReasons) GetDropTcpSplitHandshake() bool {
	if m != nil {
		return m.DropTcpSplitHandshake
	}
	return false
}

func (m *DropReasons) GetDropTcpWinZeroDrop() bool {
	if m != nil {
		return m.DropTcpWinZeroDrop
	}
	return false
}

func (m *DropReasons) GetDropTcpDataAfterFin() bool {
	if m != nil {
		return m.DropTcpDataAfterFin
	}
	return false
}

func (m *DropReasons) GetDropTcpNonRstPktAfterRst() bool {
	if m != nil {
		return m.DropTcpNonRstPktAfterRst
	}
	return false
}

func (m *DropReasons) GetDropTcpInvalidResponderFirstPkt() bool {
	if m != nil {
		return m.DropTcpInvalidResponderFirstPkt
	}
	return false
}

func (m *DropReasons) GetDropTcpUnexpectedPkt() bool {
	if m != nil {
		return m.DropTcpUnexpectedPkt
	}
	return false
}

func (m *DropReasons) GetDropSrcLifMismatch() bool {
	if m != nil {
		return m.DropSrcLifMismatch
	}
	return false
}

func (m *DropReasons) GetDropVfIpLabelMismatch() bool {
	if m != nil {
		return m.DropVfIpLabelMismatch
	}
	return false
}

func (m *DropReasons) GetDropVfBadRrDstIp() bool {
	if m != nil {
		return m.DropVfBadRrDstIp
	}
	return false
}

func (m *DropReasons) GetDropIcmpFragPkt() bool {
	if m != nil {
		return m.DropIcmpFragPkt
	}
	return false
}

type EgressDropReasons struct {
	DropOutputMapping bool `protobuf:"varint,1,opt,name=drop_output_mapping,json=dropOutputMapping,proto3" json:"drop_output_mapping,omitempty"`
	DropPruneSrcPort  bool `protobuf:"varint,2,opt,name=drop_prune_src_port,json=dropPruneSrcPort,proto3" json:"drop_prune_src_port,omitempty"`
	DropMirror        bool `protobuf:"varint,3,opt,name=drop_mirror,json=dropMirror,proto3" json:"drop_mirror,omitempty"`
	DropPolicer       bool `protobuf:"varint,4,opt,name=drop_policer,json=dropPolicer,proto3" json:"drop_policer,omitempty"`
	DropCopp          bool `protobuf:"varint,5,opt,name=drop_copp,json=dropCopp,proto3" json:"drop_copp,omitempty"`
	DropChecksumErr   bool `protobuf:"varint,6,opt,name=drop_checksum_err,json=dropChecksumErr,proto3" json:"drop_checksum_err,omitempty"`
}

func (m *EgressDropReasons) Reset()                    { *m = EgressDropReasons{} }
func (m *EgressDropReasons) String() string            { return proto.CompactTextString(m) }
func (*EgressDropReasons) ProtoMessage()               {}
func (*EgressDropReasons) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *EgressDropReasons) GetDropOutputMapping() bool {
	if m != nil {
		return m.DropOutputMapping
	}
	return false
}

func (m *EgressDropReasons) GetDropPruneSrcPort() bool {
	if m != nil {
		return m.DropPruneSrcPort
	}
	return false
}

func (m *EgressDropReasons) GetDropMirror() bool {
	if m != nil {
		return m.DropMirror
	}
	return false
}

func (m *EgressDropReasons) GetDropPolicer() bool {
	if m != nil {
		return m.DropPolicer
	}
	return false
}

func (m *EgressDropReasons) GetDropCopp() bool {
	if m != nil {
		return m.DropCopp
	}
	return false
}

func (m *EgressDropReasons) GetDropChecksumErr() bool {
	if m != nil {
		return m.DropChecksumErr
	}
	return false
}

type RuleMatch struct {
	SrcAddress    []*IPAddressObj     `protobuf:"bytes,1,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	SrcMacAddress []uint64            `protobuf:"fixed64,2,rep,packed,name=src_mac_address,json=srcMacAddress" json:"src_mac_address,omitempty"`
	SrcSg         []uint32            `protobuf:"varint,3,rep,packed,name=src_sg,json=srcSg" json:"src_sg,omitempty"`
	DstAddress    []*IPAddressObj     `protobuf:"bytes,4,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstMacAddress []uint64            `protobuf:"fixed64,5,rep,packed,name=dst_mac_address,json=dstMacAddress" json:"dst_mac_address,omitempty"`
	DstSg         []uint32            `protobuf:"varint,6,rep,packed,name=dst_sg,json=dstSg" json:"dst_sg,omitempty"`
	Protocol      int32               `protobuf:"varint,7,opt,name=protocol,proto3" json:"protocol,omitempty"`
	EtherType     uint32              `protobuf:"varint,8,opt,name=ether_type,json=etherType,proto3" json:"ether_type,omitempty"`
	AppMatch      *RuleMatch_AppMatch `protobuf:"bytes,9,opt,name=app_match,json=appMatch" json:"app_match,omitempty"`
}

func (m *RuleMatch) Reset()                    { *m = RuleMatch{} }
func (m *RuleMatch) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch) ProtoMessage()               {}
func (*RuleMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *RuleMatch) GetSrcAddress() []*IPAddressObj {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *RuleMatch) GetSrcMacAddress() []uint64 {
	if m != nil {
		return m.SrcMacAddress
	}
	return nil
}

func (m *RuleMatch) GetSrcSg() []uint32 {
	if m != nil {
		return m.SrcSg
	}
	return nil
}

func (m *RuleMatch) GetDstAddress() []*IPAddressObj {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *RuleMatch) GetDstMacAddress() []uint64 {
	if m != nil {
		return m.DstMacAddress
	}
	return nil
}

func (m *RuleMatch) GetDstSg() []uint32 {
	if m != nil {
		return m.DstSg
	}
	return nil
}

func (m *RuleMatch) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *RuleMatch) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

func (m *RuleMatch) GetAppMatch() *RuleMatch_AppMatch {
	if m != nil {
		return m.AppMatch
	}
	return nil
}

type RuleMatch_L4PortAppInfo struct {
	DstPortRange []*L4PortRange `protobuf:"bytes,1,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange `protobuf:"bytes,2,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
}

func (m *RuleMatch_L4PortAppInfo) Reset()                    { *m = RuleMatch_L4PortAppInfo{} }
func (m *RuleMatch_L4PortAppInfo) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch_L4PortAppInfo) ProtoMessage()               {}
func (*RuleMatch_L4PortAppInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14, 0} }

func (m *RuleMatch_L4PortAppInfo) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *RuleMatch_L4PortAppInfo) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

type RuleMatch_ICMPAppInfo struct {
	IcmpType uint32 `protobuf:"varint,1,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	IcmpCode uint32 `protobuf:"varint,2,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
}

func (m *RuleMatch_ICMPAppInfo) Reset()                    { *m = RuleMatch_ICMPAppInfo{} }
func (m *RuleMatch_ICMPAppInfo) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch_ICMPAppInfo) ProtoMessage()               {}
func (*RuleMatch_ICMPAppInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14, 1} }

func (m *RuleMatch_ICMPAppInfo) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *RuleMatch_ICMPAppInfo) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

type RuleMatch_ICMPv6AppInfo struct {
	Icmpv6Type uint32 `protobuf:"varint,1,opt,name=icmpv6_type,json=icmpv6Type,proto3" json:"icmpv6_type,omitempty"`
	Icmpv6Code uint32 `protobuf:"varint,2,opt,name=icmpv6_code,json=icmpv6Code,proto3" json:"icmpv6_code,omitempty"`
}

func (m *RuleMatch_ICMPv6AppInfo) Reset()                    { *m = RuleMatch_ICMPv6AppInfo{} }
func (m *RuleMatch_ICMPv6AppInfo) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch_ICMPv6AppInfo) ProtoMessage()               {}
func (*RuleMatch_ICMPv6AppInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14, 2} }

func (m *RuleMatch_ICMPv6AppInfo) GetIcmpv6Type() uint32 {
	if m != nil {
		return m.Icmpv6Type
	}
	return 0
}

func (m *RuleMatch_ICMPv6AppInfo) GetIcmpv6Code() uint32 {
	if m != nil {
		return m.Icmpv6Code
	}
	return 0
}

type RuleMatch_ESPInfo struct {
	Spi uint32 `protobuf:"varint,1,opt,name=spi,proto3" json:"spi,omitempty"`
}

func (m *RuleMatch_ESPInfo) Reset()                    { *m = RuleMatch_ESPInfo{} }
func (m *RuleMatch_ESPInfo) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch_ESPInfo) ProtoMessage()               {}
func (*RuleMatch_ESPInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14, 3} }

func (m *RuleMatch_ESPInfo) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

// cannot have repeated of oneof hence this intermediate message
type RuleMatch_AppMatch struct {
	// Types that are valid to be assigned to App:
	//	*RuleMatch_AppMatch_PortInfo
	//	*RuleMatch_AppMatch_IcmpInfo
	//	*RuleMatch_AppMatch_Icmpv6Info
	//	*RuleMatch_AppMatch_EspInfo
	App isRuleMatch_AppMatch_App `protobuf_oneof:"App"`
}

func (m *RuleMatch_AppMatch) Reset()                    { *m = RuleMatch_AppMatch{} }
func (m *RuleMatch_AppMatch) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch_AppMatch) ProtoMessage()               {}
func (*RuleMatch_AppMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14, 4} }

type isRuleMatch_AppMatch_App interface {
	isRuleMatch_AppMatch_App()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleMatch_AppMatch_PortInfo struct {
	PortInfo *RuleMatch_L4PortAppInfo `protobuf:"bytes,1,opt,name=port_info,json=portInfo,oneof"`
}
type RuleMatch_AppMatch_IcmpInfo struct {
	IcmpInfo *RuleMatch_ICMPAppInfo `protobuf:"bytes,2,opt,name=icmp_info,json=icmpInfo,oneof"`
}
type RuleMatch_AppMatch_Icmpv6Info struct {
	Icmpv6Info *RuleMatch_ICMPv6AppInfo `protobuf:"bytes,3,opt,name=icmpv6_info,json=icmpv6Info,oneof"`
}
type RuleMatch_AppMatch_EspInfo struct {
	EspInfo *RuleMatch_ESPInfo `protobuf:"bytes,6,opt,name=esp_info,json=espInfo,oneof"`
}

func (*RuleMatch_AppMatch_PortInfo) isRuleMatch_AppMatch_App()   {}
func (*RuleMatch_AppMatch_IcmpInfo) isRuleMatch_AppMatch_App()   {}
func (*RuleMatch_AppMatch_Icmpv6Info) isRuleMatch_AppMatch_App() {}
func (*RuleMatch_AppMatch_EspInfo) isRuleMatch_AppMatch_App()    {}

func (m *RuleMatch_AppMatch) GetApp() isRuleMatch_AppMatch_App {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *RuleMatch_AppMatch) GetPortInfo() *RuleMatch_L4PortAppInfo {
	if x, ok := m.GetApp().(*RuleMatch_AppMatch_PortInfo); ok {
		return x.PortInfo
	}
	return nil
}

func (m *RuleMatch_AppMatch) GetIcmpInfo() *RuleMatch_ICMPAppInfo {
	if x, ok := m.GetApp().(*RuleMatch_AppMatch_IcmpInfo); ok {
		return x.IcmpInfo
	}
	return nil
}

func (m *RuleMatch_AppMatch) GetIcmpv6Info() *RuleMatch_ICMPv6AppInfo {
	if x, ok := m.GetApp().(*RuleMatch_AppMatch_Icmpv6Info); ok {
		return x.Icmpv6Info
	}
	return nil
}

func (m *RuleMatch_AppMatch) GetEspInfo() *RuleMatch_ESPInfo {
	if x, ok := m.GetApp().(*RuleMatch_AppMatch_EspInfo); ok {
		return x.EspInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RuleMatch_AppMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RuleMatch_AppMatch_OneofMarshaler, _RuleMatch_AppMatch_OneofUnmarshaler, _RuleMatch_AppMatch_OneofSizer, []interface{}{
		(*RuleMatch_AppMatch_PortInfo)(nil),
		(*RuleMatch_AppMatch_IcmpInfo)(nil),
		(*RuleMatch_AppMatch_Icmpv6Info)(nil),
		(*RuleMatch_AppMatch_EspInfo)(nil),
	}
}

func _RuleMatch_AppMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RuleMatch_AppMatch)
	// App
	switch x := m.App.(type) {
	case *RuleMatch_AppMatch_PortInfo:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortInfo); err != nil {
			return err
		}
	case *RuleMatch_AppMatch_IcmpInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpInfo); err != nil {
			return err
		}
	case *RuleMatch_AppMatch_Icmpv6Info:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmpv6Info); err != nil {
			return err
		}
	case *RuleMatch_AppMatch_EspInfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EspInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RuleMatch_AppMatch.App has unexpected type %T", x)
	}
	return nil
}

func _RuleMatch_AppMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RuleMatch_AppMatch)
	switch tag {
	case 1: // App.port_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuleMatch_L4PortAppInfo)
		err := b.DecodeMessage(msg)
		m.App = &RuleMatch_AppMatch_PortInfo{msg}
		return true, err
	case 2: // App.icmp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuleMatch_ICMPAppInfo)
		err := b.DecodeMessage(msg)
		m.App = &RuleMatch_AppMatch_IcmpInfo{msg}
		return true, err
	case 3: // App.icmpv6_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuleMatch_ICMPv6AppInfo)
		err := b.DecodeMessage(msg)
		m.App = &RuleMatch_AppMatch_Icmpv6Info{msg}
		return true, err
	case 6: // App.esp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuleMatch_ESPInfo)
		err := b.DecodeMessage(msg)
		m.App = &RuleMatch_AppMatch_EspInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RuleMatch_AppMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RuleMatch_AppMatch)
	// App
	switch x := m.App.(type) {
	case *RuleMatch_AppMatch_PortInfo:
		s := proto.Size(x.PortInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleMatch_AppMatch_IcmpInfo:
		s := proto.Size(x.IcmpInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleMatch_AppMatch_Icmpv6Info:
		s := proto.Size(x.Icmpv6Info)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleMatch_AppMatch_EspInfo:
		s := proto.Size(x.EspInfo)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ObjectMeta)(nil), "types.ObjectMeta")
	proto.RegisterType((*MplsTag)(nil), "types.MplsTag")
	proto.RegisterType((*EncapInfo)(nil), "types.EncapInfo")
	proto.RegisterType((*IPAddress)(nil), "types.IPAddress")
	proto.RegisterType((*IPRange)(nil), "types.IPRange")
	proto.RegisterType((*IPPrefix)(nil), "types.IPPrefix")
	proto.RegisterType((*IPSubnet)(nil), "types.IPSubnet")
	proto.RegisterType((*AddressRange)(nil), "types.AddressRange")
	proto.RegisterType((*Address)(nil), "types.Address")
	proto.RegisterType((*IPAddressObj)(nil), "types.IPAddressObj")
	proto.RegisterType((*L4PortRange)(nil), "types.L4PortRange")
	proto.RegisterType((*Empty)(nil), "types.Empty")
	proto.RegisterType((*DropReasons)(nil), "types.DropReasons")
	proto.RegisterType((*EgressDropReasons)(nil), "types.EgressDropReasons")
	proto.RegisterType((*RuleMatch)(nil), "types.RuleMatch")
	proto.RegisterType((*RuleMatch_L4PortAppInfo)(nil), "types.RuleMatch.L4PortAppInfo")
	proto.RegisterType((*RuleMatch_ICMPAppInfo)(nil), "types.RuleMatch.ICMPAppInfo")
	proto.RegisterType((*RuleMatch_ICMPv6AppInfo)(nil), "types.RuleMatch.ICMPv6AppInfo")
	proto.RegisterType((*RuleMatch_ESPInfo)(nil), "types.RuleMatch.ESPInfo")
	proto.RegisterType((*RuleMatch_AppMatch)(nil), "types.RuleMatch.AppMatch")
	proto.RegisterEnum("types.IPProtocol", IPProtocol_name, IPProtocol_value)
	proto.RegisterEnum("types.ICMPMsgType", ICMPMsgType_name, ICMPMsgType_value)
	proto.RegisterEnum("types.ApiStatus", ApiStatus_name, ApiStatus_value)
	proto.RegisterEnum("types.VrfType", VrfType_name, VrfType_value)
	proto.RegisterEnum("types.L2SegmentType", L2SegmentType_name, L2SegmentType_value)
	proto.RegisterEnum("types.EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("types.SnakeTestType", SnakeTestType_name, SnakeTestType_value)
	proto.RegisterEnum("types.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("types.IPAddressType", IPAddressType_name, IPAddressType_value)
	proto.RegisterEnum("types.LifType", LifType_name, LifType_value)
	proto.RegisterEnum("types.WRingType", WRingType_name, WRingType_value)
	proto.RegisterEnum("types.ProxyType", ProxyType_name, ProxyType_value)
	proto.RegisterEnum("types.CryptoAsymKeyType", CryptoAsymKeyType_name, CryptoAsymKeyType_value)
	proto.RegisterEnum("types.CryptoKeyType", CryptoKeyType_name, CryptoKeyType_value)
	proto.RegisterEnum("types.BarcoRings", BarcoRings_name, BarcoRings_value)
	proto.RegisterEnum("types.AppRedirType", AppRedirType_name, AppRedirType_value)
	proto.RegisterEnum("types.CpucbId", CpucbId_name, CpucbId_value)
	proto.RegisterEnum("types.FTESpanMatchSelector", FTESpanMatchSelector_name, FTESpanMatchSelector_value)
	proto.RegisterEnum("types.FlowDirection", FlowDirection_name, FlowDirection_value)
	proto.RegisterEnum("types.HashType", HashType_name, HashType_value)
	proto.RegisterEnum("types.RSASignatureScheme", RSASignatureScheme_name, RSASignatureScheme_value)
	proto.RegisterEnum("types.NatAction", NatAction_name, NatAction_value)
}
func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrfId != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.VrfId))
		i += 8
	}
	return i, nil
}

func (m *MplsTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MplsTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Label != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Label))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Exp))
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *EncapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EncapType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EncapType))
	}
	if m.EncapValue != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EncapValue))
	}
	return i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAf != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpAf))
	}
	if m.V4OrV6 != nil {
		nn1, err := m.V4OrV6.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *IPAddress_V4Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.V4Addr))
	i += 4
	return i, nil
}
func (m *IPAddress_V6Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V6Addr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.V6Addr)))
		i += copy(dAtA[i:], m.V6Addr)
	}
	return i, nil
}
func (m *IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LowIpaddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LowIpaddr.Size()))
		n2, err := m.LowIpaddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.HighIpaddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HighIpaddr.Size()))
		n3, err := m.HighIpaddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *IPPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Address.Size()))
		n4, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixLen))
	}
	return i, nil
}

func (m *IPSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSubnet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subnet != nil {
		nn5, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *IPSubnet_Ipv4Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv4Subnet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ipv4Subnet.Size()))
		n6, err := m.Ipv4Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *IPSubnet_Ipv6Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv6Subnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ipv6Subnet.Size()))
		n7, err := m.Ipv6Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *AddressRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		nn8, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *AddressRange_Ipv4Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv4Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ipv4Range.Size()))
		n9, err := m.Ipv4Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *AddressRange_Ipv6Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ipv6Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ipv6Range.Size()))
		n10, err := m.Ipv6Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		nn11, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *Address_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n12, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Address_Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Range.Size()))
		n13, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *IPAddressObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddressObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Formats != nil {
		nn14, err := m.Formats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.Negate {
		dAtA[i] = 0x18
		i++
		if m.Negate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IPAddressObj_Type) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	return i, nil
}
func (m *IPAddressObj_Address) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Address != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Address.Size()))
		n15, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *L4PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4PortRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortLow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortHigh))
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DropReasons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropReasons) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMalformedPkt {
		dAtA[i] = 0x8
		i++
		if m.DropMalformedPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropParserIcrcError {
		dAtA[i] = 0x10
		i++
		if m.DropParserIcrcError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropParseLenError {
		dAtA[i] = 0x18
		i++
		if m.DropParseLenError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropHardwareError {
		dAtA[i] = 0x20
		i++
		if m.DropHardwareError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputMapping {
		dAtA[i] = 0x28
		i++
		if m.DropInputMapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputMappingDejavu {
		dAtA[i] = 0x30
		i++
		if m.DropInputMappingDejavu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMultiDestNotPinnedUplink {
		dAtA[i] = 0x38
		i++
		if m.DropMultiDestNotPinnedUplink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropFlowHit {
		dAtA[i] = 0x40
		i++
		if m.DropFlowHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropFlowMiss {
		dAtA[i] = 0x48
		i++
		if m.DropFlowMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropNacl {
		dAtA[i] = 0x50
		i++
		if m.DropNacl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIpsg {
		dAtA[i] = 0x58
		i++
		if m.DropIpsg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIpNormalization {
		dAtA[i] = 0x60
		i++
		if m.DropIpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNormalization {
		dAtA[i] = 0x68
		i++
		if m.DropTcpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpRstWithInvalidAckNum {
		dAtA[i] = 0x70
		i++
		if m.DropTcpRstWithInvalidAckNum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNonSynFirstPkt {
		dAtA[i] = 0x78
		i++
		if m.DropTcpNonSynFirstPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIcmpNormalization {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.DropIcmpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputPropertiesMiss {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.DropInputPropertiesMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpOutOfWindow {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpOutOfWindow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpSplitHandshake {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpSplitHandshake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpWinZeroDrop {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpWinZeroDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpDataAfterFin {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpDataAfterFin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNonRstPktAfterRst {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpNonRstPktAfterRst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpInvalidResponderFirstPkt {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpInvalidResponderFirstPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpUnexpectedPkt {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpUnexpectedPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropSrcLifMismatch {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropSrcLifMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropVfIpLabelMismatch {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropVfIpLabelMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropVfBadRrDstIp {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropVfBadRrDstIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIcmpFragPkt {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropIcmpFragPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EgressDropReasons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressDropReasons) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropOutputMapping {
		dAtA[i] = 0x8
		i++
		if m.DropOutputMapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropPruneSrcPort {
		dAtA[i] = 0x10
		i++
		if m.DropPruneSrcPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMirror {
		dAtA[i] = 0x18
		i++
		if m.DropMirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropPolicer {
		dAtA[i] = 0x20
		i++
		if m.DropPolicer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropCopp {
		dAtA[i] = 0x28
		i++
		if m.DropCopp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropChecksumErr {
		dAtA[i] = 0x30
		i++
		if m.DropChecksumErr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcMacAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SrcMacAddress)*8))
		for _, num := range m.SrcMacAddress {
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	if len(m.SrcSg) > 0 {
		dAtA17 := make([]byte, len(m.SrcSg)*10)
		var j16 int
		for _, num := range m.SrcSg {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstMacAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DstMacAddress)*8))
		for _, num := range m.DstMacAddress {
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	if len(m.DstSg) > 0 {
		dAtA19 := make([]byte, len(m.DstSg)*10)
		var j18 int
		for _, num := range m.DstSg {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Protocol))
	}
	if m.EtherType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EtherType))
	}
	if m.AppMatch != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AppMatch.Size()))
		n20, err := m.AppMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *RuleMatch_L4PortAppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch_L4PortAppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RuleMatch_ICMPAppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch_ICMPAppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IcmpType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IcmpType))
	}
	if m.IcmpCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IcmpCode))
	}
	return i, nil
}

func (m *RuleMatch_ICMPv6AppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch_ICMPv6AppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Icmpv6Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Icmpv6Type))
	}
	if m.Icmpv6Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Icmpv6Code))
	}
	return i, nil
}

func (m *RuleMatch_ESPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch_ESPInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Spi))
	}
	return i, nil
}

func (m *RuleMatch_AppMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch_AppMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		nn21, err := m.App.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	return i, nil
}

func (m *RuleMatch_AppMatch_PortInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortInfo.Size()))
		n22, err := m.PortInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *RuleMatch_AppMatch_IcmpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IcmpInfo.Size()))
		n23, err := m.IcmpInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *RuleMatch_AppMatch_Icmpv6Info) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmpv6Info != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Icmpv6Info.Size()))
		n24, err := m.Icmpv6Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *RuleMatch_AppMatch_EspInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EspInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EspInfo.Size()))
		n25, err := m.EspInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ObjectMeta) Size() (n int) {
	var l int
	_ = l
	if m.VrfId != 0 {
		n += 9
	}
	return n
}

func (m *MplsTag) Size() (n int) {
	var l int
	_ = l
	if m.Label != 0 {
		n += 1 + sovTypes(uint64(m.Label))
	}
	if m.Exp != 0 {
		n += 1 + sovTypes(uint64(m.Exp))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	return n
}

func (m *EncapInfo) Size() (n int) {
	var l int
	_ = l
	if m.EncapType != 0 {
		n += 1 + sovTypes(uint64(m.EncapType))
	}
	if m.EncapValue != 0 {
		n += 1 + sovTypes(uint64(m.EncapValue))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAf != 0 {
		n += 1 + sovTypes(uint64(m.IpAf))
	}
	if m.V4OrV6 != nil {
		n += m.V4OrV6.Size()
	}
	return n
}

func (m *IPAddress_V4Addr) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *IPAddress_V6Addr) Size() (n int) {
	var l int
	_ = l
	if m.V6Addr != nil {
		l = len(m.V6Addr)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPRange) Size() (n int) {
	var l int
	_ = l
	if m.LowIpaddr != nil {
		l = m.LowIpaddr.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HighIpaddr != nil {
		l = m.HighIpaddr.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IPPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovTypes(uint64(m.PrefixLen))
	}
	return n
}

func (m *IPSubnet) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		n += m.Subnet.Size()
	}
	return n
}

func (m *IPSubnet_Ipv4Subnet) Size() (n int) {
	var l int
	_ = l
	if m.Ipv4Subnet != nil {
		l = m.Ipv4Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPSubnet_Ipv6Subnet) Size() (n int) {
	var l int
	_ = l
	if m.Ipv6Subnet != nil {
		l = m.Ipv6Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		n += m.Range.Size()
	}
	return n
}

func (m *AddressRange_Ipv4Range) Size() (n int) {
	var l int
	_ = l
	if m.Ipv4Range != nil {
		l = m.Ipv4Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange_Ipv6Range) Size() (n int) {
	var l int
	_ = l
	if m.Ipv6Range != nil {
		l = m.Ipv6Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		n += m.Address.Size()
	}
	return n
}

func (m *Address_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address_Range) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPAddressObj) Size() (n int) {
	var l int
	_ = l
	if m.Formats != nil {
		n += m.Formats.Size()
	}
	if m.Negate {
		n += 2
	}
	return n
}

func (m *IPAddressObj_Type) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Type))
	return n
}
func (m *IPAddressObj_Address) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *L4PortRange) Size() (n int) {
	var l int
	_ = l
	if m.PortLow != 0 {
		n += 1 + sovTypes(uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		n += 1 + sovTypes(uint64(m.PortHigh))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DropReasons) Size() (n int) {
	var l int
	_ = l
	if m.DropMalformedPkt {
		n += 2
	}
	if m.DropParserIcrcError {
		n += 2
	}
	if m.DropParseLenError {
		n += 2
	}
	if m.DropHardwareError {
		n += 2
	}
	if m.DropInputMapping {
		n += 2
	}
	if m.DropInputMappingDejavu {
		n += 2
	}
	if m.DropMultiDestNotPinnedUplink {
		n += 2
	}
	if m.DropFlowHit {
		n += 2
	}
	if m.DropFlowMiss {
		n += 2
	}
	if m.DropNacl {
		n += 2
	}
	if m.DropIpsg {
		n += 2
	}
	if m.DropIpNormalization {
		n += 2
	}
	if m.DropTcpNormalization {
		n += 2
	}
	if m.DropTcpRstWithInvalidAckNum {
		n += 2
	}
	if m.DropTcpNonSynFirstPkt {
		n += 2
	}
	if m.DropIcmpNormalization {
		n += 3
	}
	if m.DropInputPropertiesMiss {
		n += 3
	}
	if m.DropTcpOutOfWindow {
		n += 3
	}
	if m.DropTcpSplitHandshake {
		n += 3
	}
	if m.DropTcpWinZeroDrop {
		n += 3
	}
	if m.DropTcpDataAfterFin {
		n += 3
	}
	if m.DropTcpNonRstPktAfterRst {
		n += 3
	}
	if m.DropTcpInvalidResponderFirstPkt {
		n += 3
	}
	if m.DropTcpUnexpectedPkt {
		n += 3
	}
	if m.DropSrcLifMismatch {
		n += 3
	}
	if m.DropVfIpLabelMismatch {
		n += 3
	}
	if m.DropVfBadRrDstIp {
		n += 3
	}
	if m.DropIcmpFragPkt {
		n += 3
	}
	return n
}

func (m *EgressDropReasons) Size() (n int) {
	var l int
	_ = l
	if m.DropOutputMapping {
		n += 2
	}
	if m.DropPruneSrcPort {
		n += 2
	}
	if m.DropMirror {
		n += 2
	}
	if m.DropPolicer {
		n += 2
	}
	if m.DropCopp {
		n += 2
	}
	if m.DropChecksumErr {
		n += 2
	}
	return n
}

func (m *RuleMatch) Size() (n int) {
	var l int
	_ = l
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SrcMacAddress) > 0 {
		n += 1 + sovTypes(uint64(len(m.SrcMacAddress)*8)) + len(m.SrcMacAddress)*8
	}
	if len(m.SrcSg) > 0 {
		l = 0
		for _, e := range m.SrcSg {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DstMacAddress) > 0 {
		n += 1 + sovTypes(uint64(len(m.DstMacAddress)*8)) + len(m.DstMacAddress)*8
	}
	if len(m.DstSg) > 0 {
		l = 0
		for _, e := range m.DstSg {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.Protocol != 0 {
		n += 1 + sovTypes(uint64(m.Protocol))
	}
	if m.EtherType != 0 {
		n += 1 + sovTypes(uint64(m.EtherType))
	}
	if m.AppMatch != nil {
		l = m.AppMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleMatch_L4PortAppInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RuleMatch_ICMPAppInfo) Size() (n int) {
	var l int
	_ = l
	if m.IcmpType != 0 {
		n += 1 + sovTypes(uint64(m.IcmpType))
	}
	if m.IcmpCode != 0 {
		n += 1 + sovTypes(uint64(m.IcmpCode))
	}
	return n
}

func (m *RuleMatch_ICMPv6AppInfo) Size() (n int) {
	var l int
	_ = l
	if m.Icmpv6Type != 0 {
		n += 1 + sovTypes(uint64(m.Icmpv6Type))
	}
	if m.Icmpv6Code != 0 {
		n += 1 + sovTypes(uint64(m.Icmpv6Code))
	}
	return n
}

func (m *RuleMatch_ESPInfo) Size() (n int) {
	var l int
	_ = l
	if m.Spi != 0 {
		n += 1 + sovTypes(uint64(m.Spi))
	}
	return n
}

func (m *RuleMatch_AppMatch) Size() (n int) {
	var l int
	_ = l
	if m.App != nil {
		n += m.App.Size()
	}
	return n
}

func (m *RuleMatch_AppMatch_PortInfo) Size() (n int) {
	var l int
	_ = l
	if m.PortInfo != nil {
		l = m.PortInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleMatch_AppMatch_IcmpInfo) Size() (n int) {
	var l int
	_ = l
	if m.IcmpInfo != nil {
		l = m.IcmpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleMatch_AppMatch_Icmpv6Info) Size() (n int) {
	var l int
	_ = l
	if m.Icmpv6Info != nil {
		l = m.Icmpv6Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleMatch_AppMatch_EspInfo) Size() (n int) {
	var l int
	_ = l
	if m.EspInfo != nil {
		l = m.EspInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			m.VrfId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MplsTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MplsTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MplsTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapType", wireType)
			}
			m.EncapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncapType |= (EncapType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapValue", wireType)
			}
			m.EncapValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncapValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAf", wireType)
			}
			m.IpAf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAf |= (IPAddressFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Addr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.V4OrV6 = &IPAddress_V4Addr{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.V4OrV6 = &IPAddress_V6Addr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIpaddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowIpaddr == nil {
				m.LowIpaddr = &IPAddress{}
			}
			if err := m.LowIpaddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighIpaddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighIpaddr == nil {
				m.HighIpaddr = &IPAddress{}
			}
			if err := m.HighIpaddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &IPAddress{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_Ipv4Subnet{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_Ipv6Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_Ipv4Range{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_Ipv6Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddressObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddressObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddressObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v IPAddressType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (IPAddressType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formats = &IPAddressObj_Type{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Address{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Formats = &IPAddressObj_Address{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Negate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortLow", wireType)
			}
			m.PortLow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortLow |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortHigh", wireType)
			}
			m.PortHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortHigh |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropReasons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropReasons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropReasons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMalformedPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMalformedPkt = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropParserIcrcError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropParserIcrcError = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropParseLenError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropParseLenError = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropHardwareError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropHardwareError = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputMapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputMapping = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputMappingDejavu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputMappingDejavu = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiDestNotPinnedUplink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiDestNotPinnedUplink = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFlowHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropFlowHit = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFlowMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropFlowMiss = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropNacl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropNacl = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIpsg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIpsg = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIpNormalization = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNormalization = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpRstWithInvalidAckNum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpRstWithInvalidAckNum = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNonSynFirstPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNonSynFirstPkt = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIcmpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIcmpNormalization = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputPropertiesMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputPropertiesMiss = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpOutOfWindow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpOutOfWindow = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpSplitHandshake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpSplitHandshake = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpWinZeroDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpWinZeroDrop = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpDataAfterFin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpDataAfterFin = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNonRstPktAfterRst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNonRstPktAfterRst = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpInvalidResponderFirstPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpInvalidResponderFirstPkt = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpUnexpectedPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpUnexpectedPkt = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropSrcLifMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropSrcLifMismatch = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropVfIpLabelMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropVfIpLabelMismatch = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropVfBadRrDstIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropVfBadRrDstIp = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIcmpFragPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIcmpFragPkt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressDropReasons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressDropReasons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressDropReasons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOutputMapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOutputMapping = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropPruneSrcPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropPruneSrcPort = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMirror = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropPolicer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropPolicer = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCopp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropCopp = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropChecksumErr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropChecksumErr = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressObj{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.SrcMacAddress = append(m.SrcMacAddress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.SrcMacAddress = append(m.SrcMacAddress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMacAddress", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcSg = append(m.SrcSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcSg = append(m.SrcSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSg", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressObj{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.DstMacAddress = append(m.DstMacAddress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.DstMacAddress = append(m.DstMacAddress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMacAddress", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstSg = append(m.DstSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstSg = append(m.DstSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSg", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			m.EtherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtherType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppMatch == nil {
				m.AppMatch = &RuleMatch_AppMatch{}
			}
			if err := m.AppMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch_L4PortAppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4PortAppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4PortAppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch_ICMPAppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPAppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPAppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpType", wireType)
			}
			m.IcmpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCode", wireType)
			}
			m.IcmpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch_ICMPv6AppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6AppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6AppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Type", wireType)
			}
			m.Icmpv6Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpv6Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Code", wireType)
			}
			m.Icmpv6Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpv6Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch_ESPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch_AppMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleMatch_L4PortAppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.App = &RuleMatch_AppMatch_PortInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleMatch_ICMPAppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.App = &RuleMatch_AppMatch_IcmpInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleMatch_ICMPv6AppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.App = &RuleMatch_AppMatch_Icmpv6Info{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleMatch_ESPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.App = &RuleMatch_AppMatch_EspInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 4271 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x5a, 0xcd, 0x73, 0xdb, 0xc8,
	0x72, 0x17, 0xa9, 0x0f, 0x92, 0x2d, 0x51, 0x1e, 0x8d, 0x65, 0x99, 0x96, 0x6d, 0xc9, 0x96, 0xf7,
	0x93, 0xfb, 0xd6, 0xb6, 0x64, 0x49, 0xcf, 0xbb, 0x9b, 0x4d, 0x1e, 0x08, 0x82, 0x22, 0x62, 0x90,
	0x80, 0x06, 0xa0, 0x3e, 0x5e, 0xd5, 0xab, 0x29, 0x98, 0x04, 0x25, 0xac, 0x29, 0x02, 0x05, 0x40,
	0xd2, 0xea, 0xd5, 0xab, 0x5c, 0x52, 0x95, 0x54, 0x4e, 0xc9, 0x1f, 0x90, 0x73, 0x0e, 0xb9, 0xa5,
	0x2a, 0x55, 0xf9, 0x17, 0x72, 0x4c, 0x25, 0xf7, 0xad, 0x57, 0x5b, 0xf9, 0x07, 0xb2, 0xa7, 0xdc,
	0x92, 0x9a, 0xc1, 0x07, 0x01, 0x50, 0x72, 0x72, 0x32, 0xd0, 0xbf, 0x5f, 0xf7, 0xf4, 0x74, 0xf7,
	0x34, 0x7a, 0x44, 0xc3, 0x62, 0x70, 0xe3, 0x5a, 0xfe, 0x4b, 0xd7, 0x73, 0x02, 0x07, 0xcf, 0xf3,
	0x97, 0x75, 0x38, 0x73, 0xce, 0x9c, 0x50, 0xb4, 0xf5, 0x02, 0x40, 0x7d, 0xff, 0x83, 0xd5, 0x0f,
	0x3a, 0x56, 0x60, 0xe2, 0x07, 0xb0, 0x70, 0xe5, 0x0d, 0xa9, 0x3d, 0xa8, 0x15, 0x9e, 0x15, 0xbe,
	0x58, 0x20, 0xf3, 0x57, 0xde, 0x50, 0x1e, 0x6c, 0xfd, 0x55, 0x01, 0x4a, 0x1d, 0x77, 0xe4, 0x1b,
	0xe6, 0x19, 0xae, 0xc3, 0xfc, 0xc8, 0x7c, 0x6f, 0x8d, 0x38, 0xa3, 0xda, 0x58, 0xfd, 0xe5, 0xa7,
	0x4d, 0x74, 0x65, 0x8d, 0xed, 0xbe, 0xf5, 0xed, 0x85, 0x39, 0x1e, 0x98, 0x81, 0xe3, 0xdd, 0x90,
	0x90, 0x82, 0x3f, 0x83, 0x59, 0xeb, 0x47, 0xb7, 0x56, 0x9c, 0x62, 0x0e, 0xac, 0xa1, 0x79, 0x39,
	0x0a, 0xbe, 0x7f, 0x4d, 0x18, 0x01, 0x7f, 0x0e, 0xb3, 0x41, 0x30, 0xaa, 0xcd, 0x72, 0xde, 0x83,
	0x5f, 0x7e, 0xda, 0x5c, 0xc9, 0xf1, 0xf6, 0x77, 0x09, 0x63, 0x6c, 0xfd, 0x0e, 0x2a, 0xd2, 0xb8,
	0x6f, 0xba, 0xf2, 0x78, 0xe8, 0xe0, 0x57, 0x00, 0x16, 0x7b, 0xa1, 0x6c, 0x57, 0xdc, 0x9d, 0xe5,
	0x1d, 0xf4, 0x32, 0xdc, 0x2f, 0x07, 0x8c, 0x1b, 0xd7, 0x22, 0x95, 0xe4, 0x11, 0x6f, 0xc2, 0x62,
	0xa8, 0x70, 0x65, 0x8e, 0x2e, 0xad, 0xd0, 0x2d, 0x12, 0xda, 0x38, 0x62, 0x92, 0xad, 0xbf, 0x2b,
	0x40, 0x45, 0xd6, 0x84, 0xc1, 0xc0, 0xb3, 0x7c, 0x1f, 0x0b, 0x30, 0x6f, 0xbb, 0xd4, 0x1c, 0x46,
	0xa6, 0xd7, 0x22, 0xd3, 0x09, 0xa1, 0x65, 0x5e, 0xd8, 0xa3, 0x9b, 0x3b, 0x22, 0x30, 0x67, 0xbb,
	0xc2, 0x10, 0x3f, 0x82, 0xd2, 0xd5, 0x2e, 0x35, 0x07, 0x03, 0x8f, 0xaf, 0x56, 0x6a, 0xcf, 0x90,
	0x85, 0xab, 0x5d, 0xa6, 0xcf, 0xa1, 0xfd, 0x10, 0x62, 0xfb, 0x5e, 0xe2, 0xd0, 0x3e, 0x83, 0x1a,
	0x00, 0xe5, 0xab, 0x5d, 0xea, 0x78, 0xf4, 0x6a, 0x7f, 0xeb, 0x02, 0x4a, 0xb2, 0x46, 0xcc, 0xf1,
	0x99, 0xc5, 0xf6, 0x3b, 0x72, 0xae, 0xa9, 0xed, 0x72, 0x25, 0xe6, 0xd4, 0x62, 0xb2, 0xdf, 0xc4,
	0x29, 0x52, 0x19, 0x39, 0xd7, 0x32, 0xa7, 0xe0, 0x6d, 0x58, 0x3c, 0xb7, 0xcf, 0xce, 0x63, 0x8d,
	0xe2, 0x1d, 0x1a, 0xc0, 0x48, 0xa1, 0xca, 0xd6, 0x05, 0x94, 0x65, 0x4d, 0xf3, 0xac, 0xa1, 0xfd,
	0x23, 0xae, 0x43, 0xc9, 0x0c, 0x29, 0x77, 0x2e, 0x16, 0x13, 0xf0, 0x1e, 0x80, 0xcb, 0xb5, 0xe8,
	0xc8, 0x1a, 0x47, 0x09, 0x5f, 0xfb, 0xe5, 0xa7, 0x4d, 0x1c, 0x05, 0xc6, 0x63, 0x3b, 0xf8, 0xf6,
	0xf5, 0xd7, 0xdb, 0x3b, 0x6f, 0x49, 0x25, 0x64, 0x2a, 0xd6, 0x78, 0xeb, 0x0f, 0x6c, 0x39, 0xfd,
	0xf2, 0xfd, 0xd8, 0x0a, 0xf0, 0x0e, 0x2c, 0xda, 0xee, 0xd5, 0x2e, 0xf5, 0xf9, 0x6b, 0xb4, 0xe4,
	0xbd, 0x64, 0xc9, 0xd0, 0xa9, 0xf6, 0x0c, 0x01, 0xc6, 0xca, 0xe8, 0xec, 0xc7, 0x3a, 0xc5, 0x8f,
	0xe9, 0xec, 0x87, 0x3a, 0x8d, 0x32, 0x2c, 0x84, 0xf4, 0xad, 0x1b, 0x58, 0x8a, 0x37, 0x12, 0x07,
	0x98, 0x7b, 0xc0, 0x9d, 0x8d, 0x1c, 0x58, 0x4e, 0x8c, 0x71, 0x4e, 0x7b, 0x86, 0x54, 0x18, 0x27,
	0xad, 0xb0, 0x1f, 0x29, 0x14, 0x3f, 0xa2, 0xb0, 0xcf, 0x5f, 0x1a, 0x25, 0x98, 0xe7, 0xdc, 0xad,
	0x11, 0x94, 0xe2, 0x32, 0xfb, 0x12, 0x16, 0xc2, 0x80, 0x4c, 0x6d, 0x39, 0x74, 0x98, 0x15, 0x46,
	0x48, 0xc0, 0x5f, 0x45, 0xea, 0xd1, 0x52, 0xf7, 0x23, 0x66, 0x7a, 0x13, 0xed, 0x19, 0x12, 0x72,
	0x1a, 0x95, 0x64, 0x89, 0xad, 0xbf, 0x29, 0xc0, 0x52, 0x92, 0x34, 0xf5, 0xfd, 0x0f, 0xb8, 0x0e,
	0x73, 0xa9, 0x43, 0xb3, 0x9a, 0xcf, 0x2b, 0x3b, 0x2d, 0xed, 0x19, 0xc2, 0x39, 0xe9, 0x32, 0xc8,
	0xee, 0x30, 0x22, 0xb7, 0x67, 0x26, 0x65, 0xb0, 0x06, 0x0b, 0x63, 0xeb, 0xcc, 0x0c, 0x2c, 0x5e,
	0xd3, 0x65, 0x12, 0xbd, 0x31, 0x5f, 0x5a, 0x8e, 0x77, 0x61, 0x06, 0xfe, 0xd6, 0x0d, 0x2c, 0x2a,
	0xbb, 0x9a, 0xe3, 0x05, 0x61, 0x08, 0xdf, 0x40, 0xd9, 0x75, 0xbc, 0x80, 0x8e, 0x9c, 0xeb, 0xa8,
	0xa3, 0xd4, 0x7e, 0xf9, 0x69, 0x73, 0x35, 0x57, 0x36, 0xfb, 0x7b, 0x7b, 0x6f, 0xf6, 0x48, 0x89,
	0x31, 0x15, 0xe7, 0x1a, 0xef, 0x41, 0x85, 0x2b, 0xb1, 0xc2, 0x8d, 0x8a, 0xed, 0x6e, 0x2d, 0x6e,
	0xbf, 0x6d, 0x9f, 0x9d, 0x6f, 0x95, 0x60, 0x5e, 0xba, 0x70, 0x83, 0x9b, 0xad, 0xff, 0x58, 0x84,
	0xc5, 0xa6, 0xe7, 0xb8, 0xc4, 0x32, 0x7d, 0x67, 0xec, 0xe3, 0x5f, 0x01, 0x1e, 0x78, 0x8e, 0x4b,
	0x2f, 0xcc, 0xd1, 0xd0, 0xf1, 0x2e, 0xac, 0x01, 0x75, 0x3f, 0x84, 0x15, 0x58, 0x26, 0x88, 0x21,
	0x9d, 0x18, 0xd0, 0x3e, 0x04, 0xf8, 0x0d, 0xac, 0x71, 0xb6, 0x6b, 0x7a, 0xbe, 0xe5, 0x51, 0xbb,
	0xef, 0xf5, 0xa9, 0xe5, 0x79, 0x4e, 0x78, 0xc2, 0xca, 0xe4, 0x3e, 0x43, 0x35, 0x0e, 0xca, 0x7d,
	0xaf, 0x2f, 0x31, 0x08, 0xbf, 0x82, 0xd5, 0x89, 0x12, 0x3b, 0x24, 0x91, 0x4a, 0x18, 0xa7, 0x95,
	0x44, 0x45, 0xb1, 0xc6, 0xa1, 0xc2, 0x4b, 0xe0, 0x76, 0xe8, 0xb9, 0xe9, 0x0d, 0xae, 0x4d, 0xcf,
	0x8a, 0xf8, 0x73, 0x13, 0x7e, 0x3b, 0x42, 0x42, 0x7e, 0xbc, 0x07, 0x7b, 0xec, 0x5e, 0x06, 0xf4,
	0xc2, 0x74, 0x5d, 0x7b, 0x7c, 0x56, 0x9b, 0x9f, 0xec, 0x41, 0x66, 0x40, 0x27, 0x94, 0xe3, 0x6f,
	0xe0, 0xd1, 0x34, 0x9b, 0x0e, 0xac, 0x1f, 0xcc, 0xab, 0xcb, 0xda, 0x02, 0x57, 0x5a, 0xcb, 0x2b,
	0x35, 0x39, 0x8a, 0x0f, 0xe0, 0x79, 0x18, 0xac, 0xcb, 0x51, 0x60, 0xd3, 0x81, 0xe5, 0x07, 0x74,
	0xec, 0x04, 0xd4, 0xb5, 0xc7, 0x63, 0x6b, 0x40, 0x2f, 0xdd, 0x91, 0x3d, 0xfe, 0x50, 0x2b, 0x71,
	0x13, 0x4f, 0x78, 0xec, 0x18, 0xaf, 0x69, 0xf9, 0x41, 0xd7, 0x09, 0x34, 0x4e, 0xea, 0x71, 0x0e,
	0xde, 0x82, 0x2a, 0x37, 0x34, 0x64, 0x5d, 0xed, 0xdc, 0x0e, 0x6a, 0x65, 0xae, 0xb4, 0xc8, 0x84,
	0xad, 0x91, 0x73, 0xdd, 0xb6, 0x03, 0xfc, 0x09, 0x2c, 0x4f, 0x38, 0x17, 0xb6, 0xef, 0xd7, 0x2a,
	0x9c, 0xb4, 0x14, 0x93, 0x3a, 0xb6, 0xef, 0xe3, 0xc7, 0x50, 0xe1, 0xac, 0xb1, 0xd9, 0x1f, 0xd5,
	0x80, 0x13, 0xca, 0x4c, 0xd0, 0x35, 0xfb, 0xa3, 0x04, 0xb4, 0x5d, 0xff, 0xac, 0xb6, 0x38, 0x01,
	0x65, 0xd7, 0x3f, 0xc3, 0x3b, 0xf0, 0x20, 0x02, 0xe9, 0x98, 0x15, 0xe8, 0xc8, 0xfe, 0xbd, 0x19,
	0xd8, 0xce, 0xb8, 0xb6, 0x34, 0x49, 0xa5, 0xec, 0x76, 0xd3, 0x10, 0xde, 0x8d, 0xf2, 0x1f, 0xf4,
	0xf3, 0x4a, 0x55, 0xae, 0xc4, 0x13, 0x6d, 0xf4, 0x73, 0x5a, 0xad, 0x28, 0x6c, 0x4c, 0xcb, 0xf3,
	0x03, 0x7a, 0x6d, 0x07, 0xe7, 0xd4, 0x1e, 0x5f, 0x99, 0x23, 0x7b, 0x40, 0xcd, 0xfe, 0x07, 0x3a,
	0xbe, 0xbc, 0xa8, 0x2d, 0x73, 0x03, 0x8f, 0x23, 0x03, 0xc4, 0x0f, 0x8e, 0xed, 0xe0, 0x5c, 0x0e,
	0x49, 0x42, 0xff, 0x43, 0xf7, 0xf2, 0x02, 0x7f, 0x03, 0xeb, 0xa9, 0xd5, 0xc7, 0xd4, 0xbf, 0x19,
	0xd3, 0xa1, 0xcd, 0x2c, 0xb2, 0x9a, 0xbd, 0xc7, 0x0d, 0x3c, 0x48, 0x3c, 0x18, 0xeb, 0x37, 0xe3,
	0x16, 0x43, 0x59, 0xe1, 0xee, 0xc3, 0xc3, 0x70, 0xb3, 0xfd, 0x8b, 0xbc, 0xe7, 0x68, 0xa2, 0x27,
	0xf7, 0x2f, 0x72, 0xae, 0x7f, 0x17, 0x2d, 0x19, 0x16, 0x8b, 0xeb, 0x39, 0xae, 0xe5, 0x05, 0xb6,
	0xe5, 0x87, 0x09, 0x59, 0xe1, 0xaa, 0x0f, 0x93, 0x6a, 0xd1, 0x12, 0x9c, 0xe7, 0x66, 0x27, 0x15,
	0x2d, 0xe7, 0x32, 0xa0, 0xce, 0x90, 0x5e, 0xdb, 0xe3, 0x81, 0x73, 0x5d, 0xc3, 0x5c, 0x11, 0x47,
	0xbe, 0xaa, 0x97, 0x81, 0x3a, 0x3c, 0xe6, 0x08, 0xfe, 0x35, 0xd4, 0x12, 0x1d, 0xdf, 0x1d, 0xd9,
	0x01, 0x3d, 0x37, 0xc7, 0x03, 0xff, 0xdc, 0xfc, 0x60, 0xd5, 0xee, 0x67, 0x76, 0xa8, 0x33, 0xb4,
	0x1d, 0x83, 0x99, 0xc5, 0xae, 0xed, 0x31, 0xfd, 0xbd, 0xe5, 0x39, 0x94, 0x49, 0x6a, 0xab, 0x99,
	0xc5, 0x8e, 0xed, 0xf1, 0x6f, 0x2d, 0xcf, 0x61, 0x3d, 0x00, 0xef, 0x46, 0x51, 0x61, 0x3a, 0x03,
	0x33, 0x30, 0xa9, 0x39, 0x0c, 0x2c, 0x8f, 0x0e, 0xed, 0x71, 0xed, 0xc1, 0xa4, 0x08, 0x8c, 0xbe,
	0xdb, 0x34, 0x03, 0x53, 0x60, 0x58, 0xcb, 0x1e, 0xe3, 0xdf, 0xc0, 0x46, 0x26, 0x0d, 0x51, 0x02,
	0x22, 0x65, 0xcf, 0x0f, 0x6a, 0x6b, 0x5c, 0xb9, 0x36, 0x49, 0x05, 0xe1, 0x59, 0xe0, 0x16, 0x88,
	0x1f, 0xe0, 0x0e, 0x7c, 0x92, 0x58, 0x88, 0xeb, 0xc0, 0xb3, 0x7c, 0xd7, 0x19, 0x0f, 0xf8, 0xf2,
	0x71, 0x4a, 0x1f, 0x72, 0x3b, 0x9b, 0x91, 0x9d, 0xa8, 0x18, 0x48, 0x4c, 0x4c, 0x92, 0xbb, 0x97,
	0xda, 0xc6, 0xe5, 0xd8, 0xfa, 0xd1, 0xb5, 0xfa, 0x41, 0xd4, 0xc8, 0x6a, 0x99, 0xb2, 0xec, 0x25,
	0x20, 0x53, 0xdb, 0x8e, 0x0e, 0x80, 0xef, 0xf5, 0xe9, 0xc8, 0x1e, 0xb2, 0x94, 0x5e, 0x98, 0x41,
	0xff, 0xbc, 0xf6, 0x68, 0x12, 0x30, 0xdd, 0xeb, 0x2b, 0xf6, 0xb0, 0x13, 0x21, 0xf8, 0x6d, 0xd4,
	0x3b, 0xae, 0x86, 0xec, 0xd8, 0xf0, 0x49, 0x6f, 0xa2, 0xb6, 0x3e, 0x49, 0xcf, 0xd1, 0x50, 0x76,
	0x15, 0x86, 0x26, 0x9a, 0xaf, 0xa2, 0xc5, 0xae, 0x86, 0xf4, 0xbd, 0x39, 0xa0, 0x9e, 0x47, 0x07,
	0x7e, 0x40, 0x6d, 0xb7, 0xf6, 0x78, 0xd2, 0xa6, 0x8e, 0x86, 0x0d, 0x73, 0x40, 0xbc, 0xa6, 0x1f,
	0xc8, 0x2e, 0xfe, 0x2a, 0x6e, 0x6a, 0xac, 0x62, 0x87, 0x9e, 0x79, 0xc6, 0xf7, 0xf3, 0x84, 0xb3,
	0xef, 0xc5, 0xc5, 0xda, 0xf2, 0xcc, 0x33, 0xed, 0x43, 0xb0, 0xf5, 0x3f, 0x05, 0x58, 0x91, 0xce,
	0xd8, 0x77, 0x28, 0xdd, 0xdb, 0xe3, 0x3e, 0xea, 0x5c, 0x06, 0xe9, 0xc6, 0x58, 0x98, 0xf4, 0x51,
	0x95, 0x23, 0x71, 0x67, 0xfc, 0x3a, 0xe2, 0xbb, 0xde, 0xe5, 0xd8, 0xe2, 0x61, 0x61, 0xdf, 0x8f,
	0xa8, 0xb5, 0x73, 0x0f, 0x35, 0x86, 0xe8, 0x5e, 0x9f, 0x7d, 0xc4, 0xd8, 0x4c, 0x19, 0x76, 0x43,
	0x3b, 0xd5, 0xce, 0x81, 0xf7, 0x3d, 0x2e, 0xc1, 0xcf, 0x61, 0x29, 0xb4, 0xe7, 0x8c, 0xec, 0xbe,
	0x15, 0x37, 0x70, 0xae, 0xa4, 0x85, 0xa2, 0xa4, 0x43, 0xf5, 0x1d, 0xd7, 0x8d, 0x3a, 0x36, 0xef,
	0x50, 0xa2, 0xe3, 0xba, 0xb8, 0x0e, 0x2b, 0x21, 0x78, 0x6e, 0xf5, 0x3f, 0xf8, 0x97, 0x17, 0xec,
	0x3b, 0x10, 0x75, 0x68, 0x1e, 0x01, 0x31, 0x92, 0x4b, 0x9e, 0xb7, 0xf5, 0x4f, 0x25, 0xa8, 0x90,
	0xcb, 0x91, 0xd5, 0xe1, 0xd1, 0xde, 0x85, 0x45, 0xe6, 0xfe, 0x64, 0x86, 0x9b, 0x4d, 0xcd, 0x0c,
	0xe9, 0x71, 0x80, 0x80, 0xef, 0xf5, 0xe3, 0x71, 0xe4, 0x33, 0xb8, 0xc7, 0xb4, 0x2e, 0xcc, 0x89,
	0x66, 0xf1, 0xd9, 0xec, 0x17, 0x0b, 0xa4, 0xea, 0x7b, 0xfd, 0x8e, 0x99, 0xf0, 0x1e, 0xc0, 0x02,
	0xe3, 0xf9, 0x67, 0xb5, 0xd9, 0x67, 0xb3, 0x5f, 0x54, 0xc9, 0xbc, 0xef, 0xf5, 0xf5, 0x33, 0xb6,
	0x28, 0xcb, 0x69, 0xac, 0x3a, 0xf7, 0x91, 0x45, 0x07, 0x7e, 0x90, 0x5a, 0x94, 0x69, 0xa5, 0x17,
	0x9d, 0x0f, 0x17, 0x1d, 0xf8, 0x41, 0x76, 0x51, 0xc6, 0xf3, 0xcf, 0x6a, 0x0b, 0xe1, 0xa2, 0x03,
	0x3f, 0xd0, 0xcf, 0xf0, 0x3a, 0x94, 0xf9, 0x6d, 0xa6, 0xef, 0x8c, 0xf8, 0x97, 0x67, 0x9e, 0x24,
	0xef, 0xf8, 0x29, 0x80, 0x15, 0x9c, 0x5b, 0x5e, 0x78, 0x4b, 0x28, 0xf3, 0x99, 0xbf, 0xc2, 0x25,
	0xfc, 0x4e, 0xb0, 0x0f, 0x15, 0xd3, 0x65, 0x5f, 0x7e, 0x56, 0xbc, 0x15, 0x3e, 0xdf, 0x3c, 0x8a,
	0xbc, 0x4d, 0x22, 0xf9, 0x52, 0x70, 0x5d, 0xfe, 0x40, 0xca, 0x66, 0xf4, 0xb4, 0xfe, 0x97, 0x05,
	0xa8, 0x86, 0x73, 0x8c, 0xe0, 0x86, 0xd7, 0x91, 0xb7, 0xb0, 0xcc, 0x7c, 0xe3, 0x83, 0x49, 0x3c,
	0x41, 0xb2, 0xcd, 0xe3, 0xc8, 0x5c, 0x6a, 0xea, 0x21, 0x4b, 0x03, 0x3f, 0x98, 0xcc, 0x40, 0x6f,
	0x61, 0x39, 0xae, 0xb3, 0x64, 0x94, 0xbc, 0x53, 0xd3, 0x0f, 0x0b, 0x8f, 0xbf, 0xad, 0x1f, 0xc0,
	0xa2, 0x2c, 0x76, 0xb4, 0xd8, 0x85, 0xc7, 0x50, 0xe1, 0x27, 0x25, 0x99, 0xed, 0xaa, 0xa4, 0xcc,
	0x04, 0x7c, 0xa7, 0x31, 0xd8, 0x77, 0x06, 0xf1, 0xdd, 0x87, 0x83, 0xa2, 0x33, 0xb0, 0xd6, 0x0f,
	0xa1, 0xca, 0x0c, 0x5d, 0xed, 0xc7, 0xa6, 0x36, 0x61, 0x91, 0x81, 0x57, 0xfb, 0x69, 0x63, 0x10,
	0x8a, 0xe2, 0xcb, 0x54, 0x44, 0x48, 0x19, 0x8c, 0x08, 0xdc, 0xe4, 0x63, 0x28, 0x49, 0xba, 0xc6,
	0x8d, 0x21, 0x98, 0xf5, 0x5d, 0x3b, 0x32, 0xc2, 0x1e, 0xd7, 0xff, 0xba, 0x08, 0xe5, 0x38, 0xaa,
	0xf8, 0xfb, 0x68, 0x9c, 0xb3, 0xc7, 0x43, 0x27, 0x1a, 0x82, 0x37, 0xa6, 0x72, 0x90, 0x09, 0x76,
	0x7b, 0x26, 0x1c, 0xeb, 0xb8, 0xf5, 0xef, 0xa2, 0x8d, 0x71, 0xf5, 0x70, 0x44, 0x7d, 0x32, 0xa5,
	0x9e, 0x0a, 0x13, 0x53, 0x66, 0x0a, 0x5c, 0x59, 0x48, 0xb6, 0xc1, 0xd5, 0x67, 0xef, 0x58, 0x3d,
	0x13, 0x1c, 0x7e, 0xa1, 0xe0, 0x4a, 0xdc, 0xc4, 0x1e, 0x94, 0x2d, 0x3f, 0x5a, 0x7e, 0x81, 0xeb,
	0xd7, 0xa6, 0xf4, 0xa3, 0x48, 0xb0, 0x59, 0xd9, 0xf2, 0xb9, 0x91, 0xc6, 0x3c, 0xcc, 0x0a, 0xae,
	0x5b, 0xff, 0xc7, 0x02, 0x00, 0xbb, 0xa9, 0x44, 0xe5, 0x8a, 0xd8, 0xa4, 0xae, 0x11, 0xd5, 0x50,
	0x69, 0x57, 0xed, 0x4a, 0x68, 0x26, 0x2d, 0x61, 0x5e, 0xa0, 0x42, 0x46, 0xa2, 0x1d, 0xed, 0xa2,
	0x39, 0x7c, 0x0f, 0x16, 0x63, 0x89, 0x21, 0x6a, 0x68, 0x21, 0x2d, 0xe8, 0x35, 0x35, 0xb4, 0x92,
	0x16, 0x1c, 0x10, 0x09, 0xbd, 0x4a, 0x0b, 0x24, 0x5d, 0x43, 0x3b, 0x78, 0x99, 0xfb, 0xc1, 0x05,
	0x42, 0x1b, 0xbd, 0xc1, 0x18, 0x96, 0xd3, 0xeb, 0x1e, 0xed, 0xa3, 0x6f, 0xeb, 0xdf, 0x87, 0xf5,
	0xd6, 0xf1, 0xcf, 0x78, 0x0d, 0xac, 0x01, 0x66, 0xaf, 0xb4, 0xa3, 0x1f, 0x50, 0xe3, 0x54, 0x93,
	0x62, 0x97, 0xa7, 0xe4, 0x92, 0xd8, 0x56, 0x51, 0xa1, 0xfe, 0xdf, 0xf7, 0xa1, 0x22, 0xb8, 0xb6,
	0x1e, 0x98, 0xc1, 0xa5, 0x8f, 0x57, 0xa0, 0x2a, 0x68, 0x32, 0xd5, 0x0d, 0xc1, 0xe8, 0xe9, 0x54,
	0x7d, 0x87, 0x66, 0xd8, 0x9a, 0x29, 0x91, 0x44, 0x08, 0x2a, 0xe0, 0x75, 0x58, 0x4b, 0xc9, 0xe4,
	0xee, 0x91, 0xa0, 0xc8, 0x4d, 0x2a, 0x90, 0x03, 0x54, 0xc4, 0x4f, 0xe1, 0x51, 0x9a, 0x7f, 0x22,
	0xeb, 0x86, 0x4e, 0x05, 0x85, 0x48, 0x42, 0xf3, 0x14, 0xcd, 0xe2, 0x47, 0xf0, 0x20, 0xbd, 0x42,
	0xcf, 0xa0, 0x6a, 0x8b, 0x76, 0xa4, 0x0e, 0x9a, 0xc3, 0x35, 0x58, 0x4d, 0x41, 0x5d, 0xd5, 0xa0,
	0x2d, 0xb5, 0xd7, 0x6d, 0xa2, 0x79, 0xbc, 0x01, 0xeb, 0xd3, 0x4a, 0x44, 0xd2, 0xd5, 0x1e, 0x11,
	0x25, 0xb4, 0x80, 0x9f, 0x40, 0x2d, 0xbd, 0x66, 0x57, 0x14, 0xb4, 0xd8, 0x2b, 0x54, 0xca, 0x79,
	0x74, 0x44, 0x5a, 0x54, 0x6e, 0x26, 0x70, 0x19, 0x7f, 0x02, 0xcf, 0x52, 0xb0, 0xb2, 0x43, 0x75,
	0xe9, 0xa0, 0x23, 0x75, 0x8d, 0x34, 0xab, 0x82, 0x5f, 0xc0, 0x66, 0x66, 0xcb, 0x86, 0x44, 0x5a,
	0x82, 0x28, 0xa5, 0x49, 0x90, 0xf3, 0x53, 0x6e, 0x85, 0x91, 0x8e, 0xf1, 0xc5, 0x69, 0x5c, 0xee,
	0xb6, 0xd4, 0x04, 0x5f, 0xca, 0x2f, 0xd2, 0xa2, 0xca, 0x4e, 0xe2, 0x4c, 0x44, 0xaa, 0x4e, 0x93,
	0xa4, 0xae, 0x2c, 0x66, 0x2d, 0x2d, 0xdf, 0x41, 0xca, 0xb8, 0x73, 0x0f, 0x7f, 0x06, 0x5b, 0xb9,
	0xe5, 0x62, 0x97, 0x58, 0xf0, 0x63, 0x1e, 0xc2, 0x9f, 0xc3, 0x8b, 0x29, 0xde, 0xe1, 0x34, 0x71,
	0x05, 0x6f, 0xc2, 0xe3, 0x14, 0xb1, 0xa5, 0xa8, 0xc7, 0xf4, 0x9d, 0x74, 0x9a, 0x10, 0x30, 0x7e,
	0x06, 0x4f, 0xf2, 0x84, 0x8c, 0xe3, 0xf7, 0x73, 0xc9, 0x6a, 0x0b, 0xdd, 0xa6, 0x32, 0x71, 0x79,
	0x35, 0x57, 0x79, 0xed, 0x63, 0xaa, 0x11, 0xf5, 0x80, 0x57, 0xe5, 0x83, 0x9c, 0x2a, 0xdf, 0xcb,
	0x24, 0x39, 0x6b, 0xb9, 0x5d, 0x74, 0x8f, 0x75, 0x49, 0x64, 0xda, 0x2d, 0x59, 0xc9, 0x64, 0xf1,
	0x61, 0xce, 0x49, 0x43, 0xd1, 0xa9, 0xd8, 0x48, 0x33, 0x6a, 0x79, 0x86, 0xa8, 0xe5, 0x18, 0x8f,
	0x72, 0xbe, 0x08, 0xa2, 0x92, 0x86, 0xd7, 0x73, 0x81, 0x3a, 0x26, 0x72, 0xf7, 0x20, 0x4d, 0x78,
	0x8c, 0x9f, 0xc3, 0xd3, 0x29, 0x42, 0x26, 0x7b, 0x4f, 0x72, 0x14, 0x8d, 0xa8, 0x27, 0xa7, 0x59,
	0xca, 0x53, 0xbc, 0x05, 0x1b, 0xe9, 0xc4, 0x69, 0x6c, 0xcb, 0x59, 0x4f, 0x37, 0x72, 0xae, 0x28,
	0xbb, 0x4a, 0x23, 0x93, 0xb3, 0xcd, 0xdc, 0x66, 0x45, 0xad, 0x97, 0x33, 0xf1, 0x2c, 0xc7, 0x08,
	0x3d, 0x61, 0x85, 0x21, 0x75, 0x85, 0x86, 0x22, 0x35, 0xd1, 0xf3, 0xdc, 0xa9, 0x17, 0x5b, 0x07,
	0xb4, 0xd9, 0xe0, 0x59, 0xdb, 0xc2, 0x5f, 0xc0, 0x27, 0x29, 0x48, 0x97, 0xc4, 0x1e, 0x91, 0x8d,
	0x53, 0x7a, 0x40, 0xd4, 0x9e, 0x96, 0x5e, 0xe6, 0x05, 0xfe, 0x12, 0x3e, 0xbd, 0x8d, 0xa9, 0xa9,
	0x8a, 0x2c, 0x9e, 0xa6, 0xa9, 0x9f, 0xe0, 0xaf, 0xe0, 0xf3, 0x4c, 0x43, 0x68, 0x6a, 0xaa, 0xdc,
	0x35, 0x68, 0x4f, 0x6b, 0xf2, 0xcd, 0xb5, 0x9b, 0x4a, 0x42, 0xfe, 0x34, 0xd7, 0x00, 0x9a, 0xaa,
	0x7e, 0x8b, 0xc9, 0xcf, 0x72, 0xe1, 0x26, 0xc2, 0x31, 0xc9, 0xc5, 0xe1, 0xf3, 0x5c, 0x1b, 0x52,
	0x1b, 0x7f, 0x2e, 0x89, 0xec, 0x74, 0xd0, 0x9e, 0x2e, 0xa1, 0x2f, 0xa6, 0x0d, 0xe4, 0x73, 0xf1,
	0x65, 0xae, 0x3f, 0x68, 0x2a, 0xc9, 0x34, 0xa1, 0x7a, 0x3e, 0xd0, 0x0c, 0xcf, 0x64, 0xfc, 0xab,
	0x7c, 0x51, 0x30, 0x86, 0xae, 0x49, 0xd2, 0xc4, 0xc8, 0xaf, 0xf0, 0xa7, 0xf0, 0x3c, 0x4f, 0xe9,
	0xf6, 0x3a, 0x54, 0x11, 0xba, 0x52, 0xd2, 0xcb, 0xd1, 0xd7, 0xb9, 0xda, 0xe9, 0x88, 0x54, 0xea,
	0x1a, 0x24, 0x13, 0x93, 0x97, 0xb9, 0x2e, 0xc3, 0x13, 0x9f, 0x8f, 0xca, 0xab, 0xdb, 0x48, 0xf9,
	0x9d, 0xbf, 0xce, 0x85, 0xae, 0x7d, 0x4c, 0xd9, 0xf7, 0x82, 0x55, 0x88, 0x4a, 0xd0, 0x76, 0xbe,
	0x29, 0x1c, 0xb3, 0x03, 0x61, 0x48, 0x11, 0xbc, 0x93, 0xeb, 0x63, 0xa9, 0x0e, 0x9e, 0x09, 0xce,
	0x9b, 0x9c, 0x27, 0x5d, 0xc1, 0xa0, 0x9a, 0xaa, 0x2a, 0x99, 0x72, 0xdf, 0xcd, 0x19, 0x63, 0xa4,
	0x8e, 0xa0, 0x69, 0xec, 0xfc, 0xa5, 0x79, 0x7b, 0xb9, 0xaa, 0x39, 0x54, 0x75, 0x2a, 0x2a, 0x82,
	0xae, 0xd3, 0x8e, 0xd1, 0x4b, 0x58, 0xfb, 0xf8, 0x25, 0xd4, 0x6f, 0x65, 0x9d, 0xa8, 0x5d, 0x6a,
	0xb4, 0x89, 0xa4, 0xb7, 0x55, 0x65, 0x12, 0x87, 0x5f, 0xe3, 0x57, 0xf0, 0xd5, 0x1d, 0xfc, 0x56,
	0xeb, 0x16, 0x85, 0xb7, 0xb8, 0x0e, 0x9f, 0xdd, 0xaa, 0xa0, 0x8b, 0x6d, 0xa9, 0xd9, 0x53, 0x24,
	0xc2, 0x4f, 0xa2, 0x2e, 0x19, 0xe8, 0x9b, 0x5c, 0xe6, 0x27, 0xdc, 0xe6, 0x31, 0x21, 0x89, 0xc9,
	0x6f, 0xef, 0x34, 0xc9, 0x9e, 0xa2, 0x63, 0x19, 0x71, 0xbf, 0xc3, 0xdb, 0xf0, 0xf5, 0xad, 0xdc,
	0x9e, 0xa6, 0xc8, 0xdd, 0x77, 0x71, 0x48, 0x04, 0x2d, 0xf1, 0xe2, 0x4f, 0xf0, 0xd7, 0xf0, 0xe5,
	0xff, 0x4f, 0x85, 0xd1, 0xbf, 0xbf, 0xd3, 0x9b, 0xa6, 0x6a, 0x6c, 0x1f, 0x52, 0x4d, 0x9c, 0x78,
	0xf3, 0xa7, 0xb9, 0x5e, 0x32, 0xe1, 0xca, 0x1a, 0x6d, 0xea, 0x29, 0xe6, 0x9f, 0xe1, 0x1d, 0x78,
	0xf9, 0x7f, 0x58, 0xed, 0x08, 0xe4, 0x1d, 0x6f, 0xcb, 0x91, 0xce, 0x6f, 0xf0, 0x6b, 0xf8, 0xd5,
	0x47, 0xad, 0xe7, 0x35, 0x84, 0x3b, 0xa3, 0x33, 0x59, 0x25, 0x1a, 0x8c, 0xe2, 0x2e, 0xd1, 0xb8,
	0xb3, 0x00, 0xe2, 0x45, 0x72, 0x0a, 0x22, 0x7e, 0x0b, 0xbb, 0xb7, 0xaf, 0x41, 0x54, 0x16, 0xf5,
	0xf0, 0x5f, 0xb1, 0x2d, 0x74, 0x0f, 0x24, 0x9e, 0x04, 0x41, 0x51, 0xd4, 0x63, 0xa9, 0x89, 0x9a,
	0xf5, 0x7f, 0x28, 0x40, 0xe9, 0xc8, 0x1b, 0xf2, 0xb1, 0x71, 0x05, 0xaa, 0x6c, 0x30, 0x4a, 0x4f,
	0x8c, 0x18, 0x96, 0x13, 0x91, 0xdc, 0x6d, 0x11, 0x01, 0x15, 0xf0, 0x03, 0x58, 0x49, 0x64, 0x62,
	0x4f, 0x37, 0xd4, 0x8e, 0x44, 0x50, 0x11, 0x3f, 0x86, 0x87, 0x89, 0x58, 0x55, 0x1b, 0xb4, 0x23,
	0x74, 0x85, 0x03, 0x89, 0x1d, 0x41, 0x34, 0xcb, 0x9a, 0x56, 0xca, 0x8e, 0x21, 0x91, 0xae, 0xa0,
	0xa4, 0x19, 0x73, 0xac, 0xed, 0xa5, 0x18, 0x0d, 0xa1, 0xdb, 0x4c, 0xe3, 0xf3, 0xf5, 0xdf, 0x42,
	0x55, 0xd9, 0xd1, 0xad, 0xb3, 0x0b, 0x6b, 0x1c, 0x70, 0x6f, 0x6b, 0xb0, 0x9a, 0x3f, 0xe5, 0x93,
	0x31, 0x37, 0x85, 0x68, 0x44, 0xee, 0x08, 0xe4, 0x14, 0x15, 0xf0, 0x43, 0xb8, 0x9f, 0x9e, 0xec,
	0x74, 0x55, 0x11, 0x0c, 0xa9, 0x89, 0x8a, 0xf5, 0xbf, 0x2d, 0x40, 0xea, 0xe7, 0xa8, 0xfb, 0x70,
	0x2f, 0x9c, 0x1e, 0xd3, 0x36, 0x57, 0x01, 0xa5, 0x84, 0x3c, 0x77, 0xa8, 0x90, 0x93, 0x1e, 0x9d,
	0x28, 0x42, 0x17, 0x15, 0xd9, 0x3a, 0x29, 0xa9, 0xcc, 0x4a, 0x8e, 0xca, 0x1a, 0x9a, 0x65, 0xd1,
	0x4c, 0x01, 0x6c, 0xde, 0x9f, 0xcb, 0x99, 0xe0, 0x9f, 0x67, 0x34, 0x5f, 0xff, 0x0b, 0xa8, 0xea,
	0x63, 0xf3, 0x83, 0x65, 0x58, 0x7e, 0xb2, 0x5b, 0xbd, 0x2b, 0xbc, 0x93, 0xa8, 0x21, 0xe9, 0xd9,
	0xdd, 0x6e, 0xc0, 0x7a, 0x1e, 0x11, 0x48, 0x87, 0xb2, 0xeb, 0x02, 0xe9, 0xa0, 0xc2, 0x6d, 0x9a,
	0x8a, 0xaa, 0x6a, 0xa8, 0xc8, 0x3e, 0xc8, 0x79, 0xa4, 0xa7, 0xed, 0xf4, 0x34, 0x34, 0x5b, 0x6f,
	0xc0, 0xbd, 0xdc, 0xef, 0x69, 0xe1, 0x3d, 0x84, 0x0a, 0xad, 0x78, 0xdd, 0xe4, 0x5d, 0xee, 0x4a,
	0x06, 0x2a, 0x84, 0x17, 0x97, 0xf8, 0x7d, 0x1f, 0x15, 0xeb, 0x7f, 0x2c, 0x40, 0x35, 0xf3, 0xd3,
	0x05, 0x8b, 0x2c, 0xa3, 0x34, 0x9b, 0x44, 0xd2, 0xf5, 0xd8, 0xce, 0x43, 0xb8, 0x9f, 0x12, 0xb2,
	0x8b, 0x13, 0x15, 0xba, 0x51, 0xba, 0xb2, 0xc0, 0x3e, 0x07, 0x8a, 0xe1, 0x0d, 0x28, 0x01, 0x98,
	0x6c, 0x96, 0x7d, 0x1d, 0xf2, 0x56, 0x3a, 0x3d, 0xc5, 0x90, 0x45, 0x41, 0x67, 0xd5, 0x35, 0x05,
	0xef, 0xa7, 0xe0, 0x79, 0x16, 0xa3, 0x14, 0x3c, 0x41, 0xf8, 0xad, 0x22, 0x85, 0x1c, 0xed, 0x53,
	0xde, 0x9f, 0x14, 0x55, 0x14, 0x14, 0x54, 0xaa, 0xff, 0x67, 0x01, 0x4a, 0x8a, 0x9d, 0x9c, 0x1e,
	0x45, 0xce, 0x9e, 0x9e, 0xb4, 0xa8, 0xad, 0xea, 0x2c, 0x4a, 0x4f, 0xa0, 0x96, 0x11, 0xa5, 0x8b,
	0xbc, 0xc8, 0x8e, 0x49, 0x82, 0x76, 0xd8, 0xb0, 0x3e, 0x75, 0x90, 0x3e, 0x85, 0xe7, 0x59, 0xc6,
	0xed, 0xa7, 0xe9, 0x05, 0x6c, 0xe6, 0x69, 0x53, 0x47, 0x8a, 0x1d, 0xe4, 0x2c, 0x49, 0xd4, 0x7a,
	0x68, 0x81, 0x5d, 0x63, 0x13, 0xb1, 0x7e, 0xdc, 0x41, 0xa5, 0xfa, 0x4f, 0x25, 0xa8, 0x1c, 0x13,
	0x7b, 0x7c, 0x16, 0x67, 0x31, 0x35, 0x8b, 0x46, 0x5b, 0xcd, 0x0a, 0x75, 0x89, 0xb0, 0xe3, 0x81,
	0x61, 0x39, 0x25, 0x6c, 0xe8, 0x87, 0x61, 0xf2, 0xd2, 0x32, 0x72, 0x88, 0x66, 0xa7, 0x94, 0xf5,
	0x43, 0x34, 0xc7, 0xd2, 0x9f, 0x1e, 0x79, 0xd9, 0xc1, 0x10, 0x1b, 0x87, 0x68, 0x9e, 0x9d, 0x98,
	0x14, 0x20, 0x90, 0x43, 0x72, 0x82, 0x16, 0x72, 0x76, 0x05, 0xfd, 0x10, 0x95, 0xf2, 0x4c, 0x6e,
	0xb8, 0xcc, 0xb6, 0x9d, 0x92, 0xb2, 0x21, 0x4e, 0x6c, 0xa0, 0x0a, 0x2b, 0x91, 0x5b, 0xd6, 0xa3,
	0x0d, 0x81, 0x88, 0x2a, 0x82, 0x1c, 0x2c, 0x68, 0x1a, 0x25, 0x52, 0x53, 0x26, 0x7c, 0x86, 0x43,
	0x8b, 0x6c, 0x82, 0xbe, 0x15, 0x0e, 0xe7, 0x21, 0xb4, 0xf4, 0x71, 0x82, 0x88, 0xaa, 0xec, 0x34,
	0xa6, 0xc3, 0xda, 0x69, 0x12, 0x4a, 0x4e, 0xe8, 0x81, 0x88, 0x96, 0x6f, 0x83, 0x0c, 0x0e, 0xdd,
	0x9b, 0x0e, 0x86, 0x71, 0x82, 0x50, 0x2e, 0xa0, 0x82, 0x2e, 0x1e, 0xa2, 0x15, 0x56, 0xe4, 0x29,
	0x21, 0x9b, 0xe1, 0x8d, 0x13, 0xda, 0x24, 0x08, 0xdf, 0x8e, 0x68, 0x04, 0xdd, 0x67, 0xe5, 0x9a,
	0x0f, 0x4a, 0xbc, 0x3e, 0x5a, 0xbd, 0x1b, 0x25, 0x27, 0xe8, 0xc1, 0x1d, 0xa8, 0xc6, 0x75, 0xd7,
	0xee, 0x46, 0xc9, 0x49, 0x78, 0xfd, 0x9a, 0x42, 0x1b, 0xf2, 0x41, 0xb2, 0x76, 0xed, 0xe3, 0x0c,
	0x72, 0x82, 0x1e, 0x7d, 0x84, 0x11, 0xfa, 0xb0, 0xfe, 0x71, 0x06, 0x39, 0x41, 0x8f, 0x73, 0x59,
	0xef, 0x76, 0x9a, 0x1a, 0xa1, 0x7a, 0x47, 0x50, 0x14, 0x66, 0xe0, 0xc9, 0x47, 0x60, 0x72, 0x82,
	0x9e, 0xb2, 0x4f, 0xe2, 0x14, 0xcc, 0xec, 0x1b, 0x27, 0x68, 0xe3, 0x4e, 0x90, 0x9c, 0xa0, 0xcd,
	0x5c, 0xc6, 0xd9, 0xe5, 0x52, 0x55, 0x55, 0x06, 0x3d, 0xcb, 0x05, 0x6e, 0x02, 0xed, 0x18, 0x27,
	0xe1, 0x25, 0x2b, 0x97, 0x4a, 0x72, 0x42, 0x9b, 0x1a, 0xbb, 0x64, 0x4d, 0xdb, 0x14, 0x44, 0x43,
	0xa1, 0x87, 0xe8, 0x45, 0xfd, 0x5f, 0x8a, 0x50, 0xd1, 0x3c, 0xe7, 0xc7, 0x9b, 0xf8, 0x80, 0xa7,
	0x6e, 0x92, 0x93, 0x49, 0x20, 0x25, 0x34, 0x44, 0x2d, 0x3c, 0xdf, 0x69, 0x99, 0xa2, 0xa3, 0x22,
	0x2b, 0xc8, 0xf4, 0x35, 0x94, 0x7f, 0xcf, 0x66, 0x59, 0x27, 0x4c, 0x49, 0x0f, 0xc4, 0xf0, 0xc3,
	0x97, 0x21, 0xb6, 0x64, 0x76, 0x8c, 0x6b, 0xb0, 0x9a, 0x92, 0x26, 0xc7, 0x04, 0x95, 0x72, 0x5e,
	0x69, 0xbb, 0x9a, 0x81, 0xca, 0xec, 0x82, 0x72, 0x1b, 0x3d, 0xbe, 0x09, 0x8b, 0x5a, 0x78, 0xb0,
	0x6f, 0xe5, 0xe8, 0x9a, 0xd0, 0x45, 0x80, 0x3f, 0x87, 0x17, 0x1f, 0x37, 0x11, 0x12, 0x17, 0xf3,
	0x61, 0x39, 0xea, 0x48, 0x68, 0xa9, 0x7e, 0x08, 0x2b, 0xa2, 0x77, 0xe3, 0x06, 0x8e, 0xe0, 0xdf,
	0x5c, 0xbc, 0xb3, 0xc2, 0x00, 0x6e, 0xc0, 0xba, 0x48, 0x4e, 0x35, 0xf6, 0x09, 0xd6, 0x4f, 0x3b,
	0xfc, 0xce, 0x10, 0xfd, 0xb9, 0xad, 0xa9, 0x0b, 0x68, 0x86, 0xa5, 0xf0, 0x56, 0x9c, 0xe8, 0x02,
	0x2a, 0xd4, 0xff, 0xbd, 0x00, 0xd5, 0xd0, 0x66, 0x6c, 0x6f, 0x1d, 0xd6, 0x22, 0x7e, 0x42, 0x15,
	0x24, 0x7d, 0x7b, 0xe7, 0x2d, 0x9a, 0xb9, 0x0b, 0xfb, 0x66, 0x27, 0xfc, 0x13, 0xdd, 0x2d, 0xd8,
	0xce, 0xde, 0x7e, 0x38, 0xa4, 0xe4, 0xb1, 0xa6, 0xa4, 0xa3, 0xd9, 0x94, 0x73, 0x09, 0x20, 0xb6,
	0x05, 0xb1, 0x2d, 0xec, 0xbc, 0x46, 0x73, 0xb7, 0xa1, 0x9a, 0xaa, 0x9c, 0x6e, 0xbf, 0x79, 0xbd,
	0x17, 0x7e, 0x47, 0xf3, 0x68, 0xbb, 0x23, 0x88, 0x68, 0xa1, 0xfe, 0x5f, 0x45, 0x80, 0x86, 0xe9,
	0xf5, 0x1d, 0xf6, 0x19, 0xf1, 0x59, 0x2c, 0x79, 0x63, 0xa5, 0xbc, 0x20, 0x59, 0x14, 0xc2, 0x6f,
	0x48, 0x4a, 0x78, 0x20, 0x76, 0x5e, 0xa3, 0xc2, 0xb4, 0x70, 0x1b, 0x15, 0x73, 0xc2, 0x13, 0x43,
	0x7f, 0x1d, 0x7e, 0x45, 0xb2, 0xc2, 0x6d, 0x34, 0x97, 0x13, 0x76, 0x34, 0xed, 0x35, 0x9a, 0x9f,
	0x16, 0x6e, 0xa3, 0x85, 0x69, 0xe1, 0x4e, 0x58, 0x74, 0x59, 0xe1, 0x1b, 0x54, 0x9e, 0x16, 0xee,
	0xa2, 0xca, 0xb4, 0x70, 0x0f, 0xc1, 0xb4, 0x70, 0x3f, 0xac, 0xa3, 0xac, 0xf0, 0xd7, 0x68, 0x89,
	0x1d, 0x90, 0x94, 0x50, 0xd4, 0x50, 0x95, 0x7d, 0xa7, 0x32, 0x22, 0xda, 0x56, 0x0d, 0xb4, 0x9c,
	0x63, 0x36, 0xd9, 0x47, 0x20, 0xcb, 0x6c, 0x8a, 0x9c, 0x89, 0xea, 0xbf, 0x83, 0x25, 0xc1, 0x75,
	0x89, 0x35, 0xb0, 0xc3, 0xdf, 0x54, 0x1e, 0xc2, 0xfd, 0x49, 0x79, 0xa7, 0xcf, 0xf6, 0x63, 0x78,
	0x98, 0x03, 0xf8, 0xa3, 0x24, 0x1a, 0xe1, 0x18, 0x96, 0x03, 0xf9, 0x79, 0x28, 0xd6, 0xff, 0xb9,
	0x00, 0x25, 0xd1, 0xbd, 0xec, 0xbf, 0x97, 0x07, 0xcc, 0x03, 0x51, 0xeb, 0x85, 0x17, 0xfa, 0x96,
	0xa2, 0x1e, 0x77, 0x64, 0x5d, 0x0f, 0x27, 0xf1, 0x44, 0xcc, 0xff, 0x42, 0xa6, 0xa8, 0xba, 0x14,
	0x15, 0x66, 0x2c, 0x27, 0x92, 0x22, 0x0b, 0x0d, 0x45, 0xa2, 0xa2, 0xaa, 0xb1, 0xe9, 0x2e, 0x8d,
	0x75, 0x05, 0x51, 0x99, 0xf8, 0x32, 0xcb, 0x7a, 0x46, 0x82, 0x1d, 0xf6, 0x64, 0x49, 0x17, 0xd9,
	0x08, 0x9d, 0x5e, 0x9c, 0x6b, 0x28, 0xea, 0x41, 0x38, 0xde, 0x4c, 0x7c, 0x32, 0x22, 0xb7, 0x17,
	0xea, 0x7f, 0x5f, 0x84, 0xd5, 0x96, 0x21, 0xe9, 0xae, 0x39, 0xe6, 0xbf, 0x01, 0xe8, 0xd6, 0xc8,
	0xea, 0x07, 0x8e, 0x87, 0x17, 0xa1, 0xa4, 0x13, 0x91, 0x2a, 0x72, 0x0b, 0xcd, 0xe0, 0x2a, 0x54,
	0xf8, 0x8b, 0xa6, 0x12, 0x16, 0x84, 0x2a, 0x54, 0x9a, 0xba, 0x11, 0xbd, 0x16, 0xd9, 0xac, 0xcb,
	0xaf, 0x54, 0x44, 0x12, 0x74, 0xb5, 0x1b, 0xf6, 0x37, 0xfe, 0x87, 0x4c, 0xe5, 0x5d, 0x4f, 0xa3,
	0xac, 0x5f, 0xcd, 0xb1, 0xe6, 0x38, 0x11, 0xb1, 0xb8, 0xa1, 0xf9, 0x2c, 0xed, 0x88, 0xb4, 0xd0,
	0x42, 0x56, 0xa4, 0x13, 0x11, 0x95, 0x72, 0xc6, 0x74, 0x23, 0x2c, 0xb9, 0x89, 0x88, 0xff, 0xf1,
	0x3f, 0x2c, 0xb9, 0x94, 0x2a, 0x77, 0x0d, 0xb2, 0xc2, 0x26, 0x17, 0x2e, 0xe2, 0x25, 0x28, 0x4b,
	0x46, 0x9b, 0x36, 0xd9, 0x59, 0x5c, 0x62, 0x6f, 0x2d, 0xa2, 0x76, 0xf8, 0xb8, 0x57, 0x65, 0x5b,
	0xeb, 0x08, 0x86, 0xd8, 0xe6, 0x83, 0xf4, 0x72, 0x7d, 0x08, 0xd5, 0xd6, 0xc8, 0xb9, 0x6e, 0xda,
	0x9e, 0xd5, 0xe7, 0xff, 0xcb, 0xe0, 0x21, 0xdc, 0xe7, 0x06, 0xc3, 0x24, 0xc8, 0x6a, 0x37, 0xae,
	0x9a, 0x27, 0x50, 0xcb, 0x01, 0xdc, 0x6a, 0x34, 0xe8, 0x6e, 0xc0, 0xfa, 0x6d, 0x68, 0x78, 0xc1,
	0x47, 0xc5, 0x7a, 0x13, 0xca, 0x6d, 0xd3, 0x3f, 0xe7, 0x85, 0x59, 0x86, 0x39, 0xbd, 0x2d, 0x6c,
	0xa3, 0x19, 0x0c, 0xb0, 0xa0, 0xb7, 0x85, 0x9d, 0x9d, 0x5d, 0x54, 0x88, 0x9f, 0x79, 0xb7, 0x0a,
	0x9f, 0xdf, 0xbc, 0xdd, 0x45, 0xb3, 0xd1, 0xf3, 0xde, 0xf6, 0x0e, 0x9a, 0xab, 0x7f, 0x07, 0x98,
	0xe8, 0x82, 0x6e, 0x9f, 0x8d, 0xcd, 0xe0, 0xd2, 0xb3, 0xf4, 0xfe, 0xb9, 0x75, 0x61, 0xb1, 0xab,
	0x09, 0x93, 0xea, 0x02, 0xd5, 0x78, 0x19, 0x3e, 0x80, 0x95, 0xf8, 0xfd, 0x9d, 0xa8, 0x6f, 0xd3,
	0xab, 0x6d, 0xba, 0x87, 0x0a, 0xf5, 0x3f, 0x40, 0xa5, 0x6b, 0x06, 0x42, 0xb8, 0xcd, 0x15, 0xa8,
	0x76, 0x05, 0x23, 0x7f, 0x2c, 0x12, 0x11, 0xbb, 0x5a, 0xcb, 0x62, 0x7c, 0x11, 0x08, 0x07, 0xf9,
	0x04, 0x6c, 0x9e, 0x76, 0x85, 0x4e, 0x0a, 0x2d, 0xe2, 0xe7, 0xf0, 0xf4, 0x2e, 0x94, 0xff, 0xb5,
	0x0d, 0xcd, 0x36, 0xd6, 0xfe, 0xf5, 0xe7, 0x8d, 0xc2, 0xbf, 0xfd, 0xbc, 0x51, 0xf8, 0xe3, 0xcf,
	0x1b, 0x85, 0xdf, 0x96, 0xcf, 0xcd, 0x11, 0xff, 0x6d, 0x54, 0x9b, 0x79, 0xbf, 0xc0, 0x1f, 0xde,
	0xfc, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x6d, 0x4e, 0xd6, 0x24, 0x2a, 0x00, 0x00,
}
