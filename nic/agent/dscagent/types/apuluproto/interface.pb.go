// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: interface.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of interfaces
type IfType int32

const (
	IfType_IF_TYPE_NONE IfType = 0
	// uplink interface
	IfType_IF_TYPE_UPLINK IfType = 1
	// uplink port-channel interface
	IfType_IF_TYPE_UPLINK_PC IfType = 2
	// L3 interface
	IfType_IF_TYPE_L3 IfType = 3
	// loopback interface
	IfType_IF_TYPE_LOOPBACK IfType = 4
	// inband management/control interface
	IfType_IF_TYPE_VENDOR_L3 IfType = 5
)

var IfType_name = map[int32]string{
	0: "IF_TYPE_NONE",
	1: "IF_TYPE_UPLINK",
	2: "IF_TYPE_UPLINK_PC",
	3: "IF_TYPE_L3",
	4: "IF_TYPE_LOOPBACK",
	5: "IF_TYPE_VENDOR_L3",
}
var IfType_value = map[string]int32{
	"IF_TYPE_NONE":      0,
	"IF_TYPE_UPLINK":    1,
	"IF_TYPE_UPLINK_PC": 2,
	"IF_TYPE_L3":        3,
	"IF_TYPE_LOOPBACK":  4,
	"IF_TYPE_VENDOR_L3": 5,
}

func (x IfType) String() string {
	return proto.EnumName(IfType_name, int32(x))
}
func (IfType) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

// IfStatus status reflects the operational status of Interface
type IfStatus int32

const (
	IfStatus_IF_STATUS_NONE IfStatus = 0
	IfStatus_IF_STATUS_UP   IfStatus = 1
	IfStatus_IF_STATUS_DOWN IfStatus = 2
)

var IfStatus_name = map[int32]string{
	0: "IF_STATUS_NONE",
	1: "IF_STATUS_UP",
	2: "IF_STATUS_DOWN",
}
var IfStatus_value = map[string]int32{
	"IF_STATUS_NONE": 0,
	"IF_STATUS_UP":   1,
	"IF_STATUS_DOWN": 2,
}

func (x IfStatus) String() string {
	return proto.EnumName(IfStatus_name, int32(x))
}
func (IfStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

// Uplink configuration (if interface type is IF_TYPE_UPLINK)
type UplinkSpec struct {
	// physical port id corresponding to this interface
	PortId []byte `protobuf:"bytes,1,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagge
	NativeVlanId uint32 `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
}

func (m *UplinkSpec) Reset()                    { *m = UplinkSpec{} }
func (m *UplinkSpec) String() string            { return proto.CompactTextString(m) }
func (*UplinkSpec) ProtoMessage()               {}
func (*UplinkSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

func (m *UplinkSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *UplinkSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

// Uplink port-channel configuration (i.e., if interface type is
// IF_TYPE_UPLINK_PC)
type UplinkPCSpec struct {
	// member interfaces of this port-channel in the form of bitmap
	// (e.g. if uplink interfaces 1 and 2 part of this port channel
	// this is set to 0x11
	MemberIfBitmap uint64 `protobuf:"varint,1,opt,name=MemberIfBitmap,proto3" json:"MemberIfBitmap,omitempty"`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagge
	NativeVlanId uint32 `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
}

func (m *UplinkPCSpec) Reset()                    { *m = UplinkPCSpec{} }
func (m *UplinkPCSpec) String() string            { return proto.CompactTextString(m) }
func (*UplinkPCSpec) ProtoMessage()               {}
func (*UplinkPCSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

func (m *UplinkPCSpec) GetMemberIfBitmap() uint64 {
	if m != nil {
		return m.MemberIfBitmap
	}
	return 0
}

func (m *UplinkPCSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

// L3 interface configuration
type L3IfSpec struct {
	// vpc/vrf this L3 interface belongs to
	VpcId []byte `protobuf:"bytes,1,opt,name=VpcId,proto3" json:"VpcId,omitempty" meta:mandatory`
	// IP address, prefix of this L3 interface
	Prefix *IPPrefix `protobuf:"bytes,2,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
	// Physical port of this L3 interface
	PortId []byte `protobuf:"bytes,3,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory`
	// (optional) encap used for packet rewrites if this is a L3 sub interface
	Encap *Encap `protobuf:"bytes,4,opt,name=Encap" json:"Encap,omitempty"`
	// MAC address of this L3 interface
	MACAddress uint64 `protobuf:"varint,5,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
}

func (m *L3IfSpec) Reset()                    { *m = L3IfSpec{} }
func (m *L3IfSpec) String() string            { return proto.CompactTextString(m) }
func (*L3IfSpec) ProtoMessage()               {}
func (*L3IfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{2} }

func (m *L3IfSpec) GetVpcId() []byte {
	if m != nil {
		return m.VpcId
	}
	return nil
}

func (m *L3IfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *L3IfSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *L3IfSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *L3IfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

// Loopback interface configuration
type LoopbackIfSpec struct {
	// IP address hosted on the loopback interface
	// NOTE: This IP address is in underlay VPC
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
}

func (m *LoopbackIfSpec) Reset()                    { *m = LoopbackIfSpec{} }
func (m *LoopbackIfSpec) String() string            { return proto.CompactTextString(m) }
func (*LoopbackIfSpec) ProtoMessage()               {}
func (*LoopbackIfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{3} }

func (m *LoopbackIfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

// Inband management/control interface configuration
type VendorL3IfSpec struct {
	// IP address hosted on the inband control interface
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
}

func (m *VendorL3IfSpec) Reset()                    { *m = VendorL3IfSpec{} }
func (m *VendorL3IfSpec) String() string            { return proto.CompactTextString(m) }
func (*VendorL3IfSpec) ProtoMessage()               {}
func (*VendorL3IfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{4} }

func (m *VendorL3IfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

// InterfaceSpec is used to add or update of an interface
type InterfaceSpec struct {
	// unique interface id
	// NOTE: interface ids start from 1, for IF_TYPE_UPLINK this id is in the
	//       range [1...max-ports#] and same for IF_TYPE_UPLINK_PC
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// type of the interface
	Type IfType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.IfType" json:"Type,omitempty" meta:mandatory,immutable`
	// port up|down adminstratively
	AdminStatus IfStatus `protobuf:"varint,3,opt,name=AdminStatus,proto3,enum=pds.IfStatus" json:"AdminStatus,omitempty"`
	// interface type specific configuration
	//
	// Types that are valid to be assigned to Ifinfo:
	//	*InterfaceSpec_UplinkSpec
	//	*InterfaceSpec_UplinkPCSpec
	//	*InterfaceSpec_L3IfSpec
	//	*InterfaceSpec_LoopbackIfSpec
	//	*InterfaceSpec_VendorL3IfSpec
	Ifinfo isInterfaceSpec_Ifinfo `protobuf_oneof:"ifinfo"`
	// Tx/egress mirror session id list, if any
	TxMirrorSessionId [][]byte `protobuf:"bytes,9,rep,name=TxMirrorSessionId" json:"TxMirrorSessionId,omitempty"`
	// Rx/ingress mirror session id list, if any
	RxMirrorSessionId [][]byte `protobuf:"bytes,10,rep,name=RxMirrorSessionId" json:"RxMirrorSessionId,omitempty"`
}

func (m *InterfaceSpec) Reset()                    { *m = InterfaceSpec{} }
func (m *InterfaceSpec) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec) ProtoMessage()               {}
func (*InterfaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{5} }

type isInterfaceSpec_Ifinfo interface {
	isInterfaceSpec_Ifinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceSpec_UplinkSpec struct {
	UplinkSpec *UplinkSpec `protobuf:"bytes,4,opt,name=UplinkSpec,oneof"`
}
type InterfaceSpec_UplinkPCSpec struct {
	UplinkPCSpec *UplinkPCSpec `protobuf:"bytes,5,opt,name=UplinkPCSpec,oneof"`
}
type InterfaceSpec_L3IfSpec struct {
	L3IfSpec *L3IfSpec `protobuf:"bytes,6,opt,name=L3IfSpec,oneof"`
}
type InterfaceSpec_LoopbackIfSpec struct {
	LoopbackIfSpec *LoopbackIfSpec `protobuf:"bytes,7,opt,name=LoopbackIfSpec,oneof"`
}
type InterfaceSpec_VendorL3IfSpec struct {
	VendorL3IfSpec *VendorL3IfSpec `protobuf:"bytes,8,opt,name=VendorL3IfSpec,oneof"`
}

func (*InterfaceSpec_UplinkSpec) isInterfaceSpec_Ifinfo()     {}
func (*InterfaceSpec_UplinkPCSpec) isInterfaceSpec_Ifinfo()   {}
func (*InterfaceSpec_L3IfSpec) isInterfaceSpec_Ifinfo()       {}
func (*InterfaceSpec_LoopbackIfSpec) isInterfaceSpec_Ifinfo() {}
func (*InterfaceSpec_VendorL3IfSpec) isInterfaceSpec_Ifinfo() {}

func (m *InterfaceSpec) GetIfinfo() isInterfaceSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (m *InterfaceSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *InterfaceSpec) GetType() IfType {
	if m != nil {
		return m.Type
	}
	return IfType_IF_TYPE_NONE
}

func (m *InterfaceSpec) GetAdminStatus() IfStatus {
	if m != nil {
		return m.AdminStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceSpec) GetUplinkSpec() *UplinkSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkSpec); ok {
		return x.UplinkSpec
	}
	return nil
}

func (m *InterfaceSpec) GetUplinkPCSpec() *UplinkPCSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkPCSpec); ok {
		return x.UplinkPCSpec
	}
	return nil
}

func (m *InterfaceSpec) GetL3IfSpec() *L3IfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_L3IfSpec); ok {
		return x.L3IfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetLoopbackIfSpec() *LoopbackIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_LoopbackIfSpec); ok {
		return x.LoopbackIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetVendorL3IfSpec() *VendorL3IfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_VendorL3IfSpec); ok {
		return x.VendorL3IfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetTxMirrorSessionId() [][]byte {
	if m != nil {
		return m.TxMirrorSessionId
	}
	return nil
}

func (m *InterfaceSpec) GetRxMirrorSessionId() [][]byte {
	if m != nil {
		return m.RxMirrorSessionId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceSpec_OneofMarshaler, _InterfaceSpec_OneofUnmarshaler, _InterfaceSpec_OneofSizer, []interface{}{
		(*InterfaceSpec_UplinkSpec)(nil),
		(*InterfaceSpec_UplinkPCSpec)(nil),
		(*InterfaceSpec_L3IfSpec)(nil),
		(*InterfaceSpec_LoopbackIfSpec)(nil),
		(*InterfaceSpec_VendorL3IfSpec)(nil),
	}
}

func _InterfaceSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceSpec)
	// ifinfo
	switch x := m.Ifinfo.(type) {
	case *InterfaceSpec_UplinkSpec:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkSpec); err != nil {
			return err
		}
	case *InterfaceSpec_UplinkPCSpec:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkPCSpec); err != nil {
			return err
		}
	case *InterfaceSpec_L3IfSpec:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3IfSpec); err != nil {
			return err
		}
	case *InterfaceSpec_LoopbackIfSpec:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoopbackIfSpec); err != nil {
			return err
		}
	case *InterfaceSpec_VendorL3IfSpec:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VendorL3IfSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InterfaceSpec.Ifinfo has unexpected type %T", x)
	}
	return nil
}

func _InterfaceSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceSpec)
	switch tag {
	case 4: // ifinfo.UplinkSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_UplinkSpec{msg}
		return true, err
	case 5: // ifinfo.UplinkPCSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkPCSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_UplinkPCSpec{msg}
		return true, err
	case 6: // ifinfo.L3IfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L3IfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_L3IfSpec{msg}
		return true, err
	case 7: // ifinfo.LoopbackIfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoopbackIfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_LoopbackIfSpec{msg}
		return true, err
	case 8: // ifinfo.VendorL3IfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VendorL3IfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_VendorL3IfSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceSpec)
	// ifinfo
	switch x := m.Ifinfo.(type) {
	case *InterfaceSpec_UplinkSpec:
		s := proto.Size(x.UplinkSpec)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_UplinkPCSpec:
		s := proto.Size(x.UplinkPCSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_L3IfSpec:
		s := proto.Size(x.L3IfSpec)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_LoopbackIfSpec:
		s := proto.Size(x.LoopbackIfSpec)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_VendorL3IfSpec:
		s := proto.Size(x.VendorL3IfSpec)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// operational status of uplink interface
type UplinkIfStatus struct {
	// lif id associated with this uplink
	LifId uint32 `protobuf:"varint,1,opt,name=LifId,proto3" json:"LifId,omitempty"`
}

func (m *UplinkIfStatus) Reset()                    { *m = UplinkIfStatus{} }
func (m *UplinkIfStatus) String() string            { return proto.CompactTextString(m) }
func (*UplinkIfStatus) ProtoMessage()               {}
func (*UplinkIfStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{6} }

func (m *UplinkIfStatus) GetLifId() uint32 {
	if m != nil {
		return m.LifId
	}
	return 0
}

// operational status of loopback interface
type LoopbackIfStatus struct {
	// loopback interface name in linux
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *LoopbackIfStatus) Reset()                    { *m = LoopbackIfStatus{} }
func (m *LoopbackIfStatus) String() string            { return proto.CompactTextString(m) }
func (*LoopbackIfStatus) ProtoMessage()               {}
func (*LoopbackIfStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{7} }

func (m *LoopbackIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// operational status of an interface, if any
type InterfaceStatus struct {
	// encoded interface index of this interface
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// operational status of the interface
	OperStatus IfStatus `protobuf:"varint,2,opt,name=OperStatus,proto3,enum=pds.IfStatus" json:"OperStatus,omitempty"`
	// Types that are valid to be assigned to Ifstatus:
	//	*InterfaceStatus_UplinkIfStatus
	//	*InterfaceStatus_LoopbackIfStatus
	Ifstatus isInterfaceStatus_Ifstatus `protobuf_oneof:"ifstatus"`
}

func (m *InterfaceStatus) Reset()                    { *m = InterfaceStatus{} }
func (m *InterfaceStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStatus) ProtoMessage()               {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{8} }

type isInterfaceStatus_Ifstatus interface {
	isInterfaceStatus_Ifstatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceStatus_UplinkIfStatus struct {
	UplinkIfStatus *UplinkIfStatus `protobuf:"bytes,3,opt,name=UplinkIfStatus,oneof"`
}
type InterfaceStatus_LoopbackIfStatus struct {
	LoopbackIfStatus *LoopbackIfStatus `protobuf:"bytes,4,opt,name=LoopbackIfStatus,oneof"`
}

func (*InterfaceStatus_UplinkIfStatus) isInterfaceStatus_Ifstatus()   {}
func (*InterfaceStatus_LoopbackIfStatus) isInterfaceStatus_Ifstatus() {}

func (m *InterfaceStatus) GetIfstatus() isInterfaceStatus_Ifstatus {
	if m != nil {
		return m.Ifstatus
	}
	return nil
}

func (m *InterfaceStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *InterfaceStatus) GetOperStatus() IfStatus {
	if m != nil {
		return m.OperStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceStatus) GetUplinkIfStatus() *UplinkIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_UplinkIfStatus); ok {
		return x.UplinkIfStatus
	}
	return nil
}

func (m *InterfaceStatus) GetLoopbackIfStatus() *LoopbackIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_LoopbackIfStatus); ok {
		return x.LoopbackIfStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceStatus_OneofMarshaler, _InterfaceStatus_OneofUnmarshaler, _InterfaceStatus_OneofSizer, []interface{}{
		(*InterfaceStatus_UplinkIfStatus)(nil),
		(*InterfaceStatus_LoopbackIfStatus)(nil),
	}
}

func _InterfaceStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceStatus)
	// ifstatus
	switch x := m.Ifstatus.(type) {
	case *InterfaceStatus_UplinkIfStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkIfStatus); err != nil {
			return err
		}
	case *InterfaceStatus_LoopbackIfStatus:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoopbackIfStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InterfaceStatus.Ifstatus has unexpected type %T", x)
	}
	return nil
}

func _InterfaceStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceStatus)
	switch tag {
	case 3: // ifstatus.UplinkIfStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkIfStatus)
		err := b.DecodeMessage(msg)
		m.Ifstatus = &InterfaceStatus_UplinkIfStatus{msg}
		return true, err
	case 4: // ifstatus.LoopbackIfStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoopbackIfStatus)
		err := b.DecodeMessage(msg)
		m.Ifstatus = &InterfaceStatus_LoopbackIfStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceStatus)
	// ifstatus
	switch x := m.Ifstatus.(type) {
	case *InterfaceStatus_UplinkIfStatus:
		s := proto.Size(x.UplinkIfStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStatus_LoopbackIfStatus:
		s := proto.Size(x.LoopbackIfStatus)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// stats for an interface, if any
type InterfaceStats struct {
}

func (m *InterfaceStats) Reset()                    { *m = InterfaceStats{} }
func (m *InterfaceStats) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStats) ProtoMessage()               {}
func (*InterfaceStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{9} }

// interface Object
type Interface struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *InterfaceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *InterfaceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *InterfaceStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{10} }

func (m *Interface) GetSpec() *InterfaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Interface) GetStatus() *InterfaceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Interface) GetStats() *InterfaceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// interface create and update request
type InterfaceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// batched requests
	Request []*InterfaceSpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *InterfaceRequest) Reset()                    { *m = InterfaceRequest{} }
func (m *InterfaceRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceRequest) ProtoMessage()               {}
func (*InterfaceRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{11} }

func (m *InterfaceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceRequest) GetRequest() []*InterfaceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// interface create and update response
type InterfaceResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*InterfaceStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *InterfaceResponse) Reset()                    { *m = InterfaceResponse{} }
func (m *InterfaceResponse) String() string            { return proto.CompactTextString(m) }
func (*InterfaceResponse) ProtoMessage()               {}
func (*InterfaceResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{12} }

func (m *InterfaceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceResponse) GetResponse() []*InterfaceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface get request
type InterfaceGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *InterfaceGetRequest) Reset()                    { *m = InterfaceGetRequest{} }
func (m *InterfaceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetRequest) ProtoMessage()               {}
func (*InterfaceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{13} }

func (m *InterfaceGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface get response
type InterfaceGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*Interface `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *InterfaceGetResponse) Reset()                    { *m = InterfaceGetResponse{} }
func (m *InterfaceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetResponse) ProtoMessage()               {}
func (*InterfaceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{14} }

func (m *InterfaceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceGetResponse) GetResponse() []*Interface {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface delete request
type InterfaceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *InterfaceDeleteRequest) Reset()                    { *m = InterfaceDeleteRequest{} }
func (m *InterfaceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteRequest) ProtoMessage()               {}
func (*InterfaceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{15} }

func (m *InterfaceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface delete response
type InterfaceDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *InterfaceDeleteResponse) Reset()         { *m = InterfaceDeleteResponse{} }
func (m *InterfaceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*InterfaceDeleteResponse) ProtoMessage()    {}
func (*InterfaceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{16}
}

func (m *InterfaceDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// / Lif (Logical interface) object represents a device (eth/storage etc.)
type LifSpec struct {
	// unique key of the lif
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// type of the lif device
	Type LifType `protobuf:"varint,2,opt,name=Type,proto3,enum=types.LifType" json:"Type,omitempty"`
	// MAC address of the lif, if any
	MacAddress uint64 `protobuf:"varint,3,opt,name=MacAddress,proto3" json:"MacAddress,omitempty"`
	// pinned uplink interface, if applicable for this device
	PinnedInterface []byte `protobuf:"bytes,4,opt,name=PinnedInterface,proto3" json:"PinnedInterface,omitempty"`
	// Tx/egress mirror session id list, if any
	TxMirrorSessionId [][]byte `protobuf:"bytes,5,rep,name=TxMirrorSessionId" json:"TxMirrorSessionId,omitempty"`
	// Rx/ingress mirror session id list, if any
	RxMirrorSessionId [][]byte `protobuf:"bytes,6,rep,name=RxMirrorSessionId" json:"RxMirrorSessionId,omitempty"`
}

func (m *LifSpec) Reset()                    { *m = LifSpec{} }
func (m *LifSpec) String() string            { return proto.CompactTextString(m) }
func (*LifSpec) ProtoMessage()               {}
func (*LifSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{17} }

func (m *LifSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LifSpec) GetType() LifType {
	if m != nil {
		return m.Type
	}
	return LifType_LIF_TYPE_NONE
}

func (m *LifSpec) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *LifSpec) GetPinnedInterface() []byte {
	if m != nil {
		return m.PinnedInterface
	}
	return nil
}

func (m *LifSpec) GetTxMirrorSessionId() [][]byte {
	if m != nil {
		return m.TxMirrorSessionId
	}
	return nil
}

func (m *LifSpec) GetRxMirrorSessionId() [][]byte {
	if m != nil {
		return m.RxMirrorSessionId
	}
	return nil
}

type LifStatus struct {
	// encoded ifindex of this lif
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// name of this lif (as seen on the host)
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// operational status of this lif
	Status IfStatus `protobuf:"varint,3,opt,name=Status,proto3,enum=pds.IfStatus" json:"Status,omitempty"`
}

func (m *LifStatus) Reset()                    { *m = LifStatus{} }
func (m *LifStatus) String() string            { return proto.CompactTextString(m) }
func (*LifStatus) ProtoMessage()               {}
func (*LifStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{18} }

func (m *LifStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LifStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LifStatus) GetStatus() IfStatus {
	if m != nil {
		return m.Status
	}
	return IfStatus_IF_STATUS_NONE
}

type LifStats struct {
}

func (m *LifStats) Reset()                    { *m = LifStats{} }
func (m *LifStats) String() string            { return proto.CompactTextString(m) }
func (*LifStats) ProtoMessage()               {}
func (*LifStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{19} }

type Lif struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *LifSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *LifStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *LifStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Lif) Reset()                    { *m = Lif{} }
func (m *Lif) String() string            { return proto.CompactTextString(m) }
func (*Lif) ProtoMessage()               {}
func (*Lif) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{20} }

func (m *Lif) GetSpec() *LifSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Lif) GetStatus() *LifStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Lif) GetStats() *LifStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type LifGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *LifGetRequest) Reset()                    { *m = LifGetRequest{} }
func (m *LifGetRequest) String() string            { return proto.CompactTextString(m) }
func (*LifGetRequest) ProtoMessage()               {}
func (*LifGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{21} }

func (m *LifGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type LifGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*Lif    `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *LifGetResponse) Reset()                    { *m = LifGetResponse{} }
func (m *LifGetResponse) String() string            { return proto.CompactTextString(m) }
func (*LifGetResponse) ProtoMessage()               {}
func (*LifGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{22} }

func (m *LifGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LifGetResponse) GetResponse() []*Lif {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*UplinkSpec)(nil), "pds.UplinkSpec")
	proto.RegisterType((*UplinkPCSpec)(nil), "pds.UplinkPCSpec")
	proto.RegisterType((*L3IfSpec)(nil), "pds.L3IfSpec")
	proto.RegisterType((*LoopbackIfSpec)(nil), "pds.LoopbackIfSpec")
	proto.RegisterType((*VendorL3IfSpec)(nil), "pds.VendorL3IfSpec")
	proto.RegisterType((*InterfaceSpec)(nil), "pds.InterfaceSpec")
	proto.RegisterType((*UplinkIfStatus)(nil), "pds.UplinkIfStatus")
	proto.RegisterType((*LoopbackIfStatus)(nil), "pds.LoopbackIfStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "pds.InterfaceStatus")
	proto.RegisterType((*InterfaceStats)(nil), "pds.InterfaceStats")
	proto.RegisterType((*Interface)(nil), "pds.Interface")
	proto.RegisterType((*InterfaceRequest)(nil), "pds.InterfaceRequest")
	proto.RegisterType((*InterfaceResponse)(nil), "pds.InterfaceResponse")
	proto.RegisterType((*InterfaceGetRequest)(nil), "pds.InterfaceGetRequest")
	proto.RegisterType((*InterfaceGetResponse)(nil), "pds.InterfaceGetResponse")
	proto.RegisterType((*InterfaceDeleteRequest)(nil), "pds.InterfaceDeleteRequest")
	proto.RegisterType((*InterfaceDeleteResponse)(nil), "pds.InterfaceDeleteResponse")
	proto.RegisterType((*LifSpec)(nil), "pds.LifSpec")
	proto.RegisterType((*LifStatus)(nil), "pds.LifStatus")
	proto.RegisterType((*LifStats)(nil), "pds.LifStats")
	proto.RegisterType((*Lif)(nil), "pds.Lif")
	proto.RegisterType((*LifGetRequest)(nil), "pds.LifGetRequest")
	proto.RegisterType((*LifGetResponse)(nil), "pds.LifGetResponse")
	proto.RegisterEnum("pds.IfType", IfType_name, IfType_value)
	proto.RegisterEnum("pds.IfStatus", IfStatus_name, IfStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IfSvc service

type IfSvcClient interface {
	InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error)
	InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error)
	LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error)
}

type ifSvcClient struct {
	cc *grpc.ClientConn
}

func NewIfSvcClient(cc *grpc.ClientConn) IfSvcClient {
	return &ifSvcClient{cc}
}

func (c *ifSvcClient) InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error) {
	out := new(InterfaceDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error) {
	out := new(InterfaceGetResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error) {
	out := new(LifGetResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/LifGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IfSvc service

type IfSvcServer interface {
	InterfaceCreate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceUpdate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceDelete(context.Context, *InterfaceDeleteRequest) (*InterfaceDeleteResponse, error)
	InterfaceGet(context.Context, *InterfaceGetRequest) (*InterfaceGetResponse, error)
	LifGet(context.Context, *LifGetRequest) (*LifGetResponse, error)
}

func RegisterIfSvcServer(s *grpc.Server, srv IfSvcServer) {
	s.RegisterService(&_IfSvc_serviceDesc, srv)
}

func _IfSvc_InterfaceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceCreate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceDelete(ctx, req.(*InterfaceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceGet(ctx, req.(*InterfaceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_LifGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).LifGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/LifGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).LifGet(ctx, req.(*LifGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IfSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.IfSvc",
	HandlerType: (*IfSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InterfaceCreate",
			Handler:    _IfSvc_InterfaceCreate_Handler,
		},
		{
			MethodName: "InterfaceUpdate",
			Handler:    _IfSvc_InterfaceUpdate_Handler,
		},
		{
			MethodName: "InterfaceDelete",
			Handler:    _IfSvc_InterfaceDelete_Handler,
		},
		{
			MethodName: "InterfaceGet",
			Handler:    _IfSvc_InterfaceGet_Handler,
		},
		{
			MethodName: "LifGet",
			Handler:    _IfSvc_LifGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "interface.proto",
}

func (m *UplinkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if m.NativeVlanId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
	}
	return i, nil
}

func (m *UplinkPCSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemberIfBitmap != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MemberIfBitmap))
	}
	if m.NativeVlanId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
	}
	return i, nil
}

func (m *L3IfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VpcId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.VpcId)))
		i += copy(dAtA[i:], m.VpcId)
	}
	if m.Prefix != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n1, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PortId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if m.Encap != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Encap.Size()))
		n2, err := m.Encap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.MACAddress != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
	}
	return i, nil
}

func (m *LoopbackIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n3, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *VendorL3IfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VendorL3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n4, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *InterfaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
	}
	if m.AdminStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.AdminStatus))
	}
	if m.Ifinfo != nil {
		nn5, err := m.Ifinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			dAtA[i] = 0x52
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceSpec_UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkSpec.Size()))
		n6, err := m.UplinkSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *InterfaceSpec_UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkPCSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkPCSpec.Size()))
		n7, err := m.UplinkPCSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *InterfaceSpec_L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L3IfSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.L3IfSpec.Size()))
		n8, err := m.L3IfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *InterfaceSpec_LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoopbackIfSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LoopbackIfSpec.Size()))
		n9, err := m.LoopbackIfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *InterfaceSpec_VendorL3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VendorL3IfSpec != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.VendorL3IfSpec.Size()))
		n10, err := m.VendorL3IfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *UplinkIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LifId))
	}
	return i, nil
}

func (m *LoopbackIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.OperStatus))
	}
	if m.Ifstatus != nil {
		nn11, err := m.Ifstatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *InterfaceStatus_UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkIfStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkIfStatus.Size()))
		n12, err := m.UplinkIfStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *InterfaceStatus_LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoopbackIfStatus != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LoopbackIfStatus.Size()))
		n13, err := m.LoopbackIfStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *InterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
		n14, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ObjMeta.Size()))
		n15, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
		n16, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
		n17, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Stats.Size()))
		n18, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *InterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.BatchCtxt.Size()))
		n19, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.BatchCtxt.Size()))
		n20, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA22 := make([]byte, len(m.ApiStatus)*10)
		var j21 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	return i, nil
}

func (m *LifSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
	}
	if m.MacAddress != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MacAddress))
	}
	if len(m.PinnedInterface) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PinnedInterface)))
		i += copy(dAtA[i:], m.PinnedInterface)
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			dAtA[i] = 0x32
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *LifStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *LifStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Lif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
		n23, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ObjMeta.Size()))
		n24, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
		n25, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
		n26, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Stats.Size()))
		n27, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *LifGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *LifGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UplinkSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	return n
}

func (m *UplinkPCSpec) Size() (n int) {
	var l int
	_ = l
	if m.MemberIfBitmap != 0 {
		n += 1 + sovInterface(uint64(m.MemberIfBitmap))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	return n
}

func (m *L3IfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	return n
}

func (m *LoopbackIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *VendorL3IfSpec) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	if m.AdminStatus != 0 {
		n += 1 + sovInterface(uint64(m.AdminStatus))
	}
	if m.Ifinfo != nil {
		n += m.Ifinfo.Size()
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceSpec_UplinkSpec) Size() (n int) {
	var l int
	_ = l
	if m.UplinkSpec != nil {
		l = m.UplinkSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_UplinkPCSpec) Size() (n int) {
	var l int
	_ = l
	if m.UplinkPCSpec != nil {
		l = m.UplinkPCSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_L3IfSpec) Size() (n int) {
	var l int
	_ = l
	if m.L3IfSpec != nil {
		l = m.L3IfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_LoopbackIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.LoopbackIfSpec != nil {
		l = m.LoopbackIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_VendorL3IfSpec) Size() (n int) {
	var l int
	_ = l
	if m.VendorL3IfSpec != nil {
		l = m.VendorL3IfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *UplinkIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.LifId != 0 {
		n += 1 + sovInterface(uint64(m.LifId))
	}
	return n
}

func (m *LoopbackIfStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovInterface(uint64(m.OperStatus))
	}
	if m.Ifstatus != nil {
		n += m.Ifstatus.Size()
	}
	return n
}

func (m *InterfaceStatus_UplinkIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.UplinkIfStatus != nil {
		l = m.UplinkIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStatus_LoopbackIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.LoopbackIfStatus != nil {
		l = m.LoopbackIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Interface) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovInterface(uint64(e))
		}
		n += 1 + sovInterface(uint64(l)) + l
	}
	return n
}

func (m *LifSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	if m.MacAddress != 0 {
		n += 1 + sovInterface(uint64(m.MacAddress))
	}
	l = len(m.PinnedInterface)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *LifStatus) Size() (n int) {
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovInterface(uint64(m.Status))
	}
	return n
}

func (m *LifStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Lif) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *LifGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *LifGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func sovInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInterface(x uint64) (n int) {
	return sovInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UplinkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkPCSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkPCSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkPCSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberIfBitmap", wireType)
			}
			m.MemberIfBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberIfBitmap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3IfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3IfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3IfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = append(m.VpcId[:0], dAtA[iNdEx:postIndex]...)
			if m.VpcId == nil {
				m.VpcId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VendorL3IfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VendorL3IfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VendorL3IfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (IfType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			m.AdminStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminStatus |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkSpec{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPCSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkPCSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkPCSpec{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3IfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3IfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_L3IfSpec{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_LoopbackIfSpec{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorL3IfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VendorL3IfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_VendorL3IfSpec{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMirrorSessionId = append(m.TxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.TxMirrorSessionId[len(m.TxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxMirrorSessionId = append(m.RxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.RxMirrorSessionId[len(m.RxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifId", wireType)
			}
			m.LifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_UplinkIfStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_LoopbackIfStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InterfaceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InterfaceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &InterfaceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &InterfaceSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &InterfaceStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Interface{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInterface
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInterface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (LifType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			m.MacAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedInterface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinnedInterface = append(m.PinnedInterface[:0], dAtA[iNdEx:postIndex]...)
			if m.PinnedInterface == nil {
				m.PinnedInterface = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMirrorSessionId = append(m.TxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.TxMirrorSessionId[len(m.TxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxMirrorSessionId = append(m.RxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.RxMirrorSessionId[len(m.RxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &LifSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LifStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &LifStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Lif{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInterface   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("interface.proto", fileDescriptorInterface) }

var fileDescriptorInterface = []byte{
	// 1347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x5b, 0x4f, 0xdc, 0xd6,
	0x13, 0xc7, 0xde, 0x0b, 0xcb, 0xb0, 0x78, 0xcd, 0x81, 0xe4, 0xbf, 0x7f, 0x1a, 0x61, 0x64, 0x35,
	0x11, 0x42, 0x74, 0xd3, 0x42, 0xd3, 0xa6, 0x49, 0x68, 0x85, 0x17, 0xda, 0x58, 0x59, 0x76, 0x57,
	0xe6, 0xd2, 0x8b, 0x2a, 0x51, 0xb3, 0x3e, 0x56, 0xdd, 0xec, 0xda, 0xae, 0x6d, 0x22, 0x68, 0xd5,
	0x97, 0x7e, 0xa3, 0x7e, 0x8b, 0xe6, 0x2d, 0xef, 0x95, 0x56, 0x6d, 0xfa, 0xc6, 0xe3, 0x7e, 0x82,
	0xca, 0xe7, 0x1c, 0x5f, 0x77, 0x43, 0x80, 0x3e, 0xf4, 0x05, 0xad, 0xe7, 0xcc, 0xcc, 0x6f, 0x66,
	0xce, 0xcc, 0xef, 0x0c, 0x50, 0xb3, 0xec, 0x00, 0x7b, 0xa6, 0xde, 0xc3, 0x0d, 0xd7, 0x73, 0x02,
	0x07, 0x15, 0x5c, 0xc3, 0x5f, 0xaa, 0x0d, 0x70, 0xa0, 0xdf, 0x0f, 0xff, 0x50, 0xe9, 0xd2, 0x6c,
	0x70, 0xee, 0x62, 0x9f, 0x7e, 0xc8, 0xdf, 0x02, 0x1c, 0xba, 0x7d, 0xcb, 0x7e, 0xbe, 0xef, 0xe2,
	0x1e, 0x5a, 0x83, 0x72, 0xd7, 0xf1, 0x02, 0xd5, 0xa8, 0x73, 0x2b, 0xdc, 0x6a, 0x55, 0x41, 0xa3,
	0xa1, 0x24, 0x84, 0xa6, 0x8f, 0x06, 0xba, 0x6d, 0xe8, 0x81, 0xe3, 0x9d, 0x6b, 0x4c, 0x03, 0xc9,
	0x50, 0x6d, 0xeb, 0x81, 0xf5, 0x02, 0x1f, 0xf5, 0x75, 0x5b, 0x35, 0xea, 0xfc, 0x0a, 0xb7, 0x3a,
	0xa7, 0x65, 0x64, 0xf2, 0x37, 0x50, 0xa5, 0xde, 0xbb, 0x4d, 0xe2, 0xff, 0x1e, 0x08, 0x7b, 0x78,
	0x70, 0x82, 0x3d, 0xd5, 0x54, 0xac, 0x60, 0xa0, 0xbb, 0x04, 0xa7, 0xa8, 0xe5, 0xa4, 0x57, 0xf2,
	0xfd, 0x17, 0x07, 0x95, 0xd6, 0xa6, 0x6a, 0x12, 0xc7, 0xab, 0x50, 0x3a, 0x72, 0x7b, 0x97, 0xc6,
	0x4d, 0x15, 0xd0, 0x63, 0x28, 0x77, 0x3d, 0x6c, 0x5a, 0x67, 0xc4, 0xe9, 0xec, 0x46, 0xad, 0x41,
	0xcb, 0xa1, 0x76, 0xa9, 0xf8, 0x0d, 0x39, 0x93, 0xb3, 0x54, 0x7d, 0x0a, 0x57, 0xa8, 0x4f, 0x69,
	0xd7, 0xee, 0xe9, 0x6e, 0xbd, 0x48, 0x70, 0xaa, 0x0c, 0x87, 0xc8, 0x34, 0x7a, 0x84, 0x96, 0x01,
	0xf6, 0xb6, 0x9b, 0xdb, 0x86, 0xe1, 0x61, 0xdf, 0xaf, 0x97, 0x48, 0x2d, 0x52, 0x12, 0x79, 0x0f,
	0x84, 0x96, 0xe3, 0xb8, 0x27, 0x7a, 0xef, 0x39, 0x4b, 0x34, 0x09, 0x9f, 0xbb, 0x76, 0xf8, 0xa1,
	0xbb, 0x23, 0x6c, 0x1b, 0x8e, 0x17, 0xd7, 0xed, 0x5f, 0xb9, 0x7b, 0x59, 0x86, 0x39, 0x35, 0x6a,
	0x39, 0xe2, 0x4e, 0x06, 0xfe, 0xd2, 0x3b, 0xe0, 0x55, 0x03, 0x6d, 0x41, 0xf1, 0xe0, 0xdc, 0xc5,
	0xa4, 0xfc, 0xc2, 0xc6, 0x6c, 0xc3, 0x35, 0xfc, 0x86, 0x6a, 0x86, 0x22, 0xe5, 0xce, 0x68, 0x28,
	0xd5, 0xb3, 0x26, 0xeb, 0xd6, 0x60, 0x70, 0x1a, 0xe8, 0x27, 0x7d, 0xac, 0x11, 0x33, 0x74, 0x1f,
	0x66, 0xb7, 0x8d, 0x81, 0x65, 0xef, 0x07, 0x7a, 0x70, 0xea, 0x93, 0x7b, 0x10, 0x36, 0xe6, 0x98,
	0x17, 0x2a, 0xd4, 0xd2, 0x1a, 0xa8, 0x9f, 0xee, 0x70, 0x76, 0x19, 0x35, 0xa2, 0x9f, 0x88, 0x95,
	0x4f, 0x46, 0x43, 0xe9, 0x01, 0x41, 0xee, 0x39, 0xb6, 0x1f, 0x78, 0xba, 0x65, 0x07, 0xfe, 0xd6,
	0xcf, 0x99, 0xec, 0x1a, 0x21, 0xfe, 0xd6, 0x96, 0xfa, 0xf9, 0xf1, 0xc1, 0xd7, 0xdd, 0xdd, 0xe3,
	0xc3, 0x6e, 0x4b, 0x6d, 0x3f, 0xfb, 0xe5, 0xe9, 0x94, 0x96, 0x9e, 0xa0, 0xd3, 0x6c, 0xc7, 0x93,
	0x3b, 0x9d, 0xdd, 0x98, 0x4f, 0xe1, 0xd1, 0x03, 0xe5, 0xc9, 0x68, 0x28, 0x3d, 0xbc, 0x09, 0xe2,
	0x71, 0xb7, 0x19, 0x82, 0x66, 0x07, 0xeb, 0x24, 0x99, 0x85, 0x7a, 0x99, 0x40, 0xd2, 0x92, 0x44,
	0x42, 0xe5, 0xc1, 0x68, 0x28, 0x7d, 0x70, 0x3d, 0xb8, 0xd6, 0x66, 0x88, 0x93, 0xcc, 0xd8, 0x79,
	0xbe, 0x19, 0xeb, 0xd3, 0x04, 0x69, 0x81, 0x22, 0x65, 0x8e, 0x94, 0x47, 0xa3, 0xa1, 0xf4, 0xd1,
	0x35, 0xf1, 0x3a, 0x9d, 0xae, 0xb2, 0xdd, 0x7c, 0xf6, 0x74, 0x4a, 0xcb, 0x77, 0xfd, 0x4f, 0xf9,
	0xc6, 0xad, 0x57, 0x52, 0xd0, 0xd9, 0x23, 0xe5, 0xf1, 0x68, 0x28, 0x7d, 0x7c, 0x3d, 0xe8, 0xa3,
	0xdd, 0xf6, 0x4e, 0x47, 0x3b, 0x6e, 0x6d, 0x86, 0xd8, 0xb9, 0x11, 0x59, 0x87, 0xf9, 0x83, 0xb3,
	0x3d, 0xcb, 0xf3, 0x1c, 0x6f, 0x1f, 0xfb, 0xbe, 0xe5, 0x84, 0x84, 0x34, 0xb3, 0x52, 0x58, 0xad,
	0x6a, 0xe3, 0x07, 0xa1, 0xb6, 0x36, 0xa6, 0x0d, 0x54, 0x7b, 0xec, 0x40, 0xa9, 0x40, 0xd9, 0x32,
	0x2d, 0xdb, 0x74, 0xe4, 0x7b, 0x20, 0xd0, 0x0b, 0x8d, 0x9a, 0x18, 0x2d, 0x42, 0xa9, 0x65, 0x99,
	0x6c, 0x9c, 0xe6, 0x34, 0xfa, 0x21, 0xdf, 0x03, 0x31, 0x55, 0x1b, 0xaa, 0x89, 0xa0, 0x68, 0xeb,
	0x03, 0x4c, 0x14, 0x67, 0x34, 0xf2, 0x5b, 0xbe, 0xe0, 0xa0, 0x96, 0x64, 0x4c, 0xf5, 0xea, 0x30,
	0xad, 0x9a, 0xaa, 0x6d, 0xe0, 0x33, 0xe6, 0x33, 0xfa, 0x44, 0xef, 0x01, 0x74, 0x5c, 0xec, 0xb1,
	0x99, 0xe2, 0x27, 0xcd, 0x54, 0x4a, 0x01, 0x6d, 0xe5, 0x83, 0x25, 0x63, 0x18, 0x5d, 0x47, 0xf6,
	0x28, 0xac, 0x68, 0x2e, 0xb3, 0xe6, 0x78, 0x0e, 0x6c, 0x2e, 0x6f, 0xe5, 0x5b, 0x29, 0x72, 0x31,
	0x66, 0xa0, 0x00, 0x54, 0x2c, 0xd3, 0x27, 0xbf, 0x65, 0x11, 0x84, 0x4c, 0xae, 0xbe, 0xfc, 0x92,
	0x87, 0x99, 0x58, 0x84, 0x1e, 0x43, 0x25, 0xbc, 0xef, 0x3d, 0x1c, 0xe8, 0x8c, 0xe7, 0x84, 0x06,
	0x79, 0x10, 0x23, 0xa9, 0x52, 0x7b, 0x35, 0x94, 0xb8, 0x8b, 0xa1, 0x34, 0xbd, 0x6e, 0xd9, 0x7d,
	0xcb, 0xc6, 0x5a, 0x6c, 0x80, 0x3e, 0x83, 0xe9, 0xce, 0xc9, 0x0f, 0xc4, 0x96, 0x67, 0x93, 0x45,
	0x6c, 0x99, 0x50, 0xb9, 0xcd, 0x4c, 0x09, 0xd7, 0xad, 0x3b, 0x03, 0x2b, 0xc0, 0x03, 0x37, 0x38,
	0xd7, 0x22, 0x2b, 0xf4, 0x08, 0x8a, 0xa4, 0x65, 0x69, 0x8d, 0x10, 0x2d, 0x6b, 0xba, 0x19, 0x15,
	0x14, 0x9a, 0xfb, 0x2e, 0xee, 0xa5, 0xcc, 0x89, 0x0d, 0x52, 0xa0, 0x9c, 0x29, 0xd0, 0x62, 0xce,
	0x9a, 0xd6, 0x62, 0xf1, 0x62, 0x28, 0x89, 0xb4, 0x16, 0x29, 0x0f, 0xcc, 0x12, 0x7d, 0x0a, 0x25,
	0x52, 0x14, 0xc6, 0x45, 0x0b, 0xe3, 0x2e, 0x7c, 0x65, 0xe1, 0x62, 0x28, 0xd5, 0x42, 0x0f, 0x69,
	0x07, 0xd4, 0x4c, 0x76, 0x41, 0x8c, 0xb5, 0x35, 0xfc, 0xe3, 0x29, 0xf6, 0x03, 0xd4, 0x80, 0x19,
	0x45, 0x0f, 0x7a, 0xdf, 0x37, 0x83, 0xb3, 0x80, 0x95, 0x54, 0x64, 0x4f, 0x47, 0x2c, 0xd7, 0x12,
	0x15, 0xb4, 0x0e, 0xd3, 0xcc, 0xb4, 0xce, 0xaf, 0x14, 0x26, 0x97, 0x41, 0x8b, 0x54, 0xe4, 0x53,
	0x98, 0x4f, 0x21, 0xfa, 0xae, 0x63, 0xfb, 0x38, 0x84, 0xdc, 0x76, 0x2d, 0x56, 0x0d, 0x8e, 0xb4,
	0x68, 0x04, 0x19, 0xcb, 0xb5, 0x44, 0x05, 0xbd, 0x0f, 0x95, 0xc8, 0x96, 0x61, 0x4e, 0x2c, 0x9e,
	0x16, 0x6b, 0xc9, 0x77, 0x61, 0x21, 0x3e, 0xfc, 0x02, 0x07, 0x51, 0xae, 0x02, 0x7b, 0xd4, 0xc2,
	0x19, 0xe6, 0x55, 0x43, 0xf6, 0x60, 0x31, 0xab, 0x76, 0xc3, 0x00, 0xd7, 0xc6, 0x02, 0x14, 0xb2,
	0x01, 0xa6, 0x42, 0xfb, 0x0a, 0x6e, 0xc7, 0xe2, 0x1d, 0xdc, 0xc7, 0xc1, 0x8d, 0x6f, 0x82, 0x66,
	0xc3, 0xc7, 0xd9, 0xa8, 0xf0, 0xbf, 0x31, 0xcf, 0x93, 0x13, 0x2a, 0xbc, 0x25, 0x21, 0xf9, 0x6f,
	0x0e, 0xa6, 0x5b, 0x16, 0x65, 0x4d, 0x21, 0xd9, 0x04, 0xc8, 0xab, 0x2f, 0x67, 0x5e, 0x7d, 0x81,
	0xb9, 0x69, 0x59, 0xe4, 0xe1, 0x67, 0x4f, 0x7b, 0xb8, 0x0d, 0xe9, 0xbd, 0x68, 0x1b, 0x2a, 0xb0,
	0x6d, 0x28, 0x96, 0xa0, 0x55, 0xa8, 0x75, 0x2d, 0xdb, 0xc6, 0x46, 0x1c, 0x30, 0x99, 0x8a, 0xaa,
	0x96, 0x17, 0x4f, 0xe6, 0xec, 0xd2, 0xb5, 0x38, 0xbb, 0xfc, 0x06, 0xce, 0x96, 0xbf, 0x83, 0x99,
	0x30, 0xc9, 0xb7, 0x51, 0x2a, 0x82, 0x62, 0x3b, 0x24, 0x65, 0x9e, 0x92, 0x72, 0xf8, 0x1b, 0xdd,
	0x8d, 0xa7, 0x79, 0xe2, 0xda, 0xc2, 0x0e, 0x65, 0x80, 0x0a, 0x43, 0xf0, 0xe5, 0xdf, 0x78, 0x28,
	0xb4, 0x2c, 0xf3, 0x3f, 0xa6, 0xb0, 0x0f, 0x33, 0x14, 0x56, 0xa5, 0x2c, 0x4d, 0x6f, 0xfa, 0x12,
	0xf2, 0x7a, 0x92, 0x23, 0x2f, 0x21, 0xb6, 0xbb, 0x0a, 0x6d, 0x3d, 0xcc, 0xd2, 0xd6, 0x5c, 0xda,
	0xf8, 0x72, 0xc2, 0x92, 0x60, 0xae, 0x65, 0x99, 0x97, 0x4c, 0xb0, 0x09, 0x42, 0xa4, 0x70, 0xc3,
	0xd9, 0x7d, 0x77, 0x6c, 0x76, 0x2b, 0x51, 0x7c, 0xc9, 0xd4, 0xae, 0xfd, 0xca, 0x41, 0x99, 0xae,
	0xb6, 0x48, 0x84, 0x6a, 0xb4, 0x6c, 0xb4, 0x3b, 0xed, 0x5d, 0x71, 0x0a, 0x21, 0x10, 0xb2, 0x8b,
	0x9d, 0xc8, 0xa1, 0x5b, 0x30, 0x3f, 0xb6, 0xec, 0x89, 0x3c, 0x12, 0x00, 0x92, 0xa5, 0x4c, 0x2c,
	0xa0, 0x45, 0x10, 0xf3, 0x4b, 0x93, 0x58, 0x4c, 0x1b, 0xc7, 0xfb, 0x8c, 0x58, 0x5a, 0xdb, 0x81,
	0x4a, 0x6a, 0x53, 0x08, 0x31, 0xf7, 0x0f, 0xb6, 0x0f, 0x0e, 0xf7, 0xa3, 0x38, 0x68, 0x64, 0x4c,
	0x76, 0xd8, 0x15, 0xb9, 0xac, 0xd6, 0x4e, 0xe7, 0xcb, 0xb6, 0xc8, 0x6f, 0xfc, 0xc1, 0x43, 0x49,
	0x35, 0xf7, 0x5f, 0x84, 0x4f, 0x52, 0xb2, 0x58, 0x34, 0x3d, 0xac, 0x07, 0x18, 0xdd, 0xca, 0xf1,
	0x16, 0x2d, 0xfb, 0xd2, 0xed, 0xbc, 0x98, 0x91, 0xd9, 0x54, 0xc6, 0xc7, 0xa1, 0x6b, 0xdc, 0xc8,
	0x47, 0x3b, 0xe5, 0x83, 0x12, 0x17, 0x7a, 0x27, 0xab, 0x9c, 0x21, 0xca, 0xa5, 0x3b, 0x93, 0x0f,
	0x63, 0x7f, 0xbb, 0x50, 0x4d, 0xd3, 0x3a, 0xaa, 0x67, 0xf5, 0x93, 0x76, 0x5a, 0xfa, 0xff, 0x84,
	0x93, 0xd8, 0xcd, 0x26, 0x94, 0x69, 0x6f, 0x21, 0x14, 0x75, 0x44, 0xca, 0x74, 0x21, 0x23, 0x8b,
	0x8c, 0x94, 0xea, 0xef, 0xaf, 0x97, 0xb9, 0x57, 0xaf, 0x97, 0xb9, 0x3f, 0x5f, 0x2f, 0x73, 0x27,
	0x65, 0xf2, 0xaf, 0xf9, 0xe6, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xed, 0x91, 0x36, 0xf5, 0xd0,
	0x0f, 0x00, 0x00,
}
