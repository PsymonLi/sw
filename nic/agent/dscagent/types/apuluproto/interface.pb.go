// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: interface.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of interfaces
type IfType int32

const (
	IfType_IF_TYPE_NONE IfType = 0
	// uplink interface
	IfType_IF_TYPE_UPLINK IfType = 1
	// uplink port-channel interface
	IfType_IF_TYPE_UPLINK_PC IfType = 2
	// L3 interface
	IfType_IF_TYPE_L3 IfType = 3
	// loopback interface
	IfType_IF_TYPE_LOOPBACK IfType = 4
	// inband management/control interface
	IfType_IF_TYPE_CONTROL IfType = 5
	// host visible interface/device (PF or VF)
	IfType_IF_TYPE_HOST IfType = 6
)

var IfType_name = map[int32]string{
	0: "IF_TYPE_NONE",
	1: "IF_TYPE_UPLINK",
	2: "IF_TYPE_UPLINK_PC",
	3: "IF_TYPE_L3",
	4: "IF_TYPE_LOOPBACK",
	5: "IF_TYPE_CONTROL",
	6: "IF_TYPE_HOST",
}
var IfType_value = map[string]int32{
	"IF_TYPE_NONE":      0,
	"IF_TYPE_UPLINK":    1,
	"IF_TYPE_UPLINK_PC": 2,
	"IF_TYPE_L3":        3,
	"IF_TYPE_LOOPBACK":  4,
	"IF_TYPE_CONTROL":   5,
	"IF_TYPE_HOST":      6,
}

func (x IfType) String() string {
	return proto.EnumName(IfType_name, int32(x))
}
func (IfType) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

// IfStatus status reflects the operational status of Interface
type IfStatus int32

const (
	IfStatus_IF_STATUS_NONE IfStatus = 0
	IfStatus_IF_STATUS_UP   IfStatus = 1
	IfStatus_IF_STATUS_DOWN IfStatus = 2
)

var IfStatus_name = map[int32]string{
	0: "IF_STATUS_NONE",
	1: "IF_STATUS_UP",
	2: "IF_STATUS_DOWN",
}
var IfStatus_value = map[string]int32{
	"IF_STATUS_NONE": 0,
	"IF_STATUS_UP":   1,
	"IF_STATUS_DOWN": 2,
}

func (x IfStatus) String() string {
	return proto.EnumName(IfStatus_name, int32(x))
}
func (IfStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

// LLDP chassis/port Identifier key type
type LldpIdType int32

const (
	LldpIdType_LLDPID_SUBTYPE_NONE    LldpIdType = 0
	LldpIdType_LLDPID_SUBTYPE_IFNAME  LldpIdType = 1
	LldpIdType_LLDPID_SUBTYPE_IFALIAS LldpIdType = 2
	LldpIdType_LLDPID_SUBTYPE_LOCAL   LldpIdType = 3
	LldpIdType_LLDPID_SUBTYPE_MAC     LldpIdType = 4
	LldpIdType_LLDPID_SUBTYPE_IP      LldpIdType = 5
	LldpIdType_LLDPID_SUBTYPE_PORT    LldpIdType = 6
	LldpIdType_LLDPID_SUBTYPE_CHASSIS LldpIdType = 7
)

var LldpIdType_name = map[int32]string{
	0: "LLDPID_SUBTYPE_NONE",
	1: "LLDPID_SUBTYPE_IFNAME",
	2: "LLDPID_SUBTYPE_IFALIAS",
	3: "LLDPID_SUBTYPE_LOCAL",
	4: "LLDPID_SUBTYPE_MAC",
	5: "LLDPID_SUBTYPE_IP",
	6: "LLDPID_SUBTYPE_PORT",
	7: "LLDPID_SUBTYPE_CHASSIS",
}
var LldpIdType_value = map[string]int32{
	"LLDPID_SUBTYPE_NONE":    0,
	"LLDPID_SUBTYPE_IFNAME":  1,
	"LLDPID_SUBTYPE_IFALIAS": 2,
	"LLDPID_SUBTYPE_LOCAL":   3,
	"LLDPID_SUBTYPE_MAC":     4,
	"LLDPID_SUBTYPE_IP":      5,
	"LLDPID_SUBTYPE_PORT":    6,
	"LLDPID_SUBTYPE_CHASSIS": 7,
}

func (x LldpIdType) String() string {
	return proto.EnumName(LldpIdType_name, int32(x))
}
func (LldpIdType) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{2} }

// Protocol used for LLDP
type LldpProtoMode int32

const (
	LldpProtoMode_LLDP_MODE_NONE  LldpProtoMode = 0
	LldpProtoMode_LLDP_MODE_LLDP  LldpProtoMode = 1
	LldpProtoMode_LLDP_MODE_CDPV1 LldpProtoMode = 2
	LldpProtoMode_LLDP_MODE_CDPV2 LldpProtoMode = 3
	LldpProtoMode_LLDP_MODE_EDP   LldpProtoMode = 4
	LldpProtoMode_LLDP_MODE_FDP   LldpProtoMode = 5
	LldpProtoMode_LLDP_MODE_SONMP LldpProtoMode = 6
)

var LldpProtoMode_name = map[int32]string{
	0: "LLDP_MODE_NONE",
	1: "LLDP_MODE_LLDP",
	2: "LLDP_MODE_CDPV1",
	3: "LLDP_MODE_CDPV2",
	4: "LLDP_MODE_EDP",
	5: "LLDP_MODE_FDP",
	6: "LLDP_MODE_SONMP",
}
var LldpProtoMode_value = map[string]int32{
	"LLDP_MODE_NONE":  0,
	"LLDP_MODE_LLDP":  1,
	"LLDP_MODE_CDPV1": 2,
	"LLDP_MODE_CDPV2": 3,
	"LLDP_MODE_EDP":   4,
	"LLDP_MODE_FDP":   5,
	"LLDP_MODE_SONMP": 6,
}

func (x LldpProtoMode) String() string {
	return proto.EnumName(LldpProtoMode_name, int32(x))
}
func (LldpProtoMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{3} }

// Capabilities on the interfce
type LldpCapType int32

const (
	LldpCapType_LLDP_CAPTYPE_OTHER     LldpCapType = 0
	LldpCapType_LLDP_CAPTYPE_REPEATER  LldpCapType = 1
	LldpCapType_LLDP_CAPTYPE_BRIDGE    LldpCapType = 2
	LldpCapType_LLDP_CAPTYPE_ROUTER    LldpCapType = 3
	LldpCapType_LLDP_CAPTYPE_WLAN      LldpCapType = 4
	LldpCapType_LLDP_CAPTYPE_TELEPHONE LldpCapType = 5
	LldpCapType_LLDP_CAPTYPE_DOCSIS    LldpCapType = 6
	LldpCapType_LLDP_CAPTYPE_STATION   LldpCapType = 7
)

var LldpCapType_name = map[int32]string{
	0: "LLDP_CAPTYPE_OTHER",
	1: "LLDP_CAPTYPE_REPEATER",
	2: "LLDP_CAPTYPE_BRIDGE",
	3: "LLDP_CAPTYPE_ROUTER",
	4: "LLDP_CAPTYPE_WLAN",
	5: "LLDP_CAPTYPE_TELEPHONE",
	6: "LLDP_CAPTYPE_DOCSIS",
	7: "LLDP_CAPTYPE_STATION",
}
var LldpCapType_value = map[string]int32{
	"LLDP_CAPTYPE_OTHER":     0,
	"LLDP_CAPTYPE_REPEATER":  1,
	"LLDP_CAPTYPE_BRIDGE":    2,
	"LLDP_CAPTYPE_ROUTER":    3,
	"LLDP_CAPTYPE_WLAN":      4,
	"LLDP_CAPTYPE_TELEPHONE": 5,
	"LLDP_CAPTYPE_DOCSIS":    6,
	"LLDP_CAPTYPE_STATION":   7,
}

func (x LldpCapType) String() string {
	return proto.EnumName(LldpCapType_name, int32(x))
}
func (LldpCapType) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{4} }

type LldpIfStats struct {
	TxCount        uint32 `protobuf:"varint,1,opt,name=TxCount,proto3" json:"TxCount,omitempty"`
	RxCount        uint32 `protobuf:"varint,2,opt,name=RxCount,proto3" json:"RxCount,omitempty"`
	RxDiscarded    uint32 `protobuf:"varint,3,opt,name=RxDiscarded,proto3" json:"RxDiscarded,omitempty"`
	RxUnrecognized uint32 `protobuf:"varint,4,opt,name=RxUnrecognized,proto3" json:"RxUnrecognized,omitempty"`
	AgeoutCount    uint32 `protobuf:"varint,5,opt,name=AgeoutCount,proto3" json:"AgeoutCount,omitempty"`
	InsertCount    uint32 `protobuf:"varint,6,opt,name=InsertCount,proto3" json:"InsertCount,omitempty"`
	DeleteCount    uint32 `protobuf:"varint,7,opt,name=DeleteCount,proto3" json:"DeleteCount,omitempty"`
}

func (m *LldpIfStats) Reset()                    { *m = LldpIfStats{} }
func (m *LldpIfStats) String() string            { return proto.CompactTextString(m) }
func (*LldpIfStats) ProtoMessage()               {}
func (*LldpIfStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

func (m *LldpIfStats) GetTxCount() uint32 {
	if m != nil {
		return m.TxCount
	}
	return 0
}

func (m *LldpIfStats) GetRxCount() uint32 {
	if m != nil {
		return m.RxCount
	}
	return 0
}

func (m *LldpIfStats) GetRxDiscarded() uint32 {
	if m != nil {
		return m.RxDiscarded
	}
	return 0
}

func (m *LldpIfStats) GetRxUnrecognized() uint32 {
	if m != nil {
		return m.RxUnrecognized
	}
	return 0
}

func (m *LldpIfStats) GetAgeoutCount() uint32 {
	if m != nil {
		return m.AgeoutCount
	}
	return 0
}

func (m *LldpIfStats) GetInsertCount() uint32 {
	if m != nil {
		return m.InsertCount
	}
	return 0
}

func (m *LldpIfStats) GetDeleteCount() uint32 {
	if m != nil {
		return m.DeleteCount
	}
	return 0
}

// Key-type and value for Identified
type LldpId struct {
	Type  LldpIdType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.LldpIdType" json:"Type,omitempty"`
	Value []byte     `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LldpId) Reset()                    { *m = LldpId{} }
func (m *LldpId) String() string            { return proto.CompactTextString(m) }
func (*LldpId) ProtoMessage()               {}
func (*LldpId) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

func (m *LldpId) GetType() LldpIdType {
	if m != nil {
		return m.Type
	}
	return LldpIdType_LLDPID_SUBTYPE_NONE
}

func (m *LldpId) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type LldpChassisCapabilitySpec struct {
	CapType    LldpCapType `protobuf:"varint,1,opt,name=CapType,proto3,enum=pds.LldpCapType" json:"CapType,omitempty"`
	CapEnabled bool        `protobuf:"varint,2,opt,name=CapEnabled,proto3" json:"CapEnabled,omitempty"`
}

func (m *LldpChassisCapabilitySpec) Reset()         { *m = LldpChassisCapabilitySpec{} }
func (m *LldpChassisCapabilitySpec) String() string { return proto.CompactTextString(m) }
func (*LldpChassisCapabilitySpec) ProtoMessage()    {}
func (*LldpChassisCapabilitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{2}
}

func (m *LldpChassisCapabilitySpec) GetCapType() LldpCapType {
	if m != nil {
		return m.CapType
	}
	return LldpCapType_LLDP_CAPTYPE_OTHER
}

func (m *LldpChassisCapabilitySpec) GetCapEnabled() bool {
	if m != nil {
		return m.CapEnabled
	}
	return false
}

type LldpIfChassisSpec struct {
	SysName    string                       `protobuf:"bytes,1,opt,name=SysName,proto3" json:"SysName,omitempty"`
	ChassisId  *LldpId                      `protobuf:"bytes,2,opt,name=ChassisId" json:"ChassisId,omitempty"`
	SysDescr   string                       `protobuf:"bytes,3,opt,name=SysDescr,proto3" json:"SysDescr,omitempty"`
	MgmtIP     *IPAddress                   `protobuf:"bytes,4,opt,name=MgmtIP" json:"MgmtIP,omitempty"`
	Capability []*LldpChassisCapabilitySpec `protobuf:"bytes,5,rep,name=Capability" json:"Capability,omitempty"`
}

func (m *LldpIfChassisSpec) Reset()                    { *m = LldpIfChassisSpec{} }
func (m *LldpIfChassisSpec) String() string            { return proto.CompactTextString(m) }
func (*LldpIfChassisSpec) ProtoMessage()               {}
func (*LldpIfChassisSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{3} }

func (m *LldpIfChassisSpec) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *LldpIfChassisSpec) GetChassisId() *LldpId {
	if m != nil {
		return m.ChassisId
	}
	return nil
}

func (m *LldpIfChassisSpec) GetSysDescr() string {
	if m != nil {
		return m.SysDescr
	}
	return ""
}

func (m *LldpIfChassisSpec) GetMgmtIP() *IPAddress {
	if m != nil {
		return m.MgmtIP
	}
	return nil
}

func (m *LldpIfChassisSpec) GetCapability() []*LldpChassisCapabilitySpec {
	if m != nil {
		return m.Capability
	}
	return nil
}

type LldpIfPortSpec struct {
	PortId    *LldpId `protobuf:"bytes,1,opt,name=PortId" json:"PortId,omitempty"`
	PortDescr string  `protobuf:"bytes,2,opt,name=PortDescr,proto3" json:"PortDescr,omitempty"`
	Ttl       uint32  `protobuf:"varint,3,opt,name=Ttl,proto3" json:"Ttl,omitempty"`
}

func (m *LldpIfPortSpec) Reset()                    { *m = LldpIfPortSpec{} }
func (m *LldpIfPortSpec) String() string            { return proto.CompactTextString(m) }
func (*LldpIfPortSpec) ProtoMessage()               {}
func (*LldpIfPortSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{4} }

func (m *LldpIfPortSpec) GetPortId() *LldpId {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *LldpIfPortSpec) GetPortDescr() string {
	if m != nil {
		return m.PortDescr
	}
	return ""
}

func (m *LldpIfPortSpec) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type LldpIfSpec struct {
	IfName            string             `protobuf:"bytes,1,opt,name=IfName,proto3" json:"IfName,omitempty"`
	RouterId          uint32             `protobuf:"varint,2,opt,name=RouterId,proto3" json:"RouterId,omitempty"`
	Proto             LldpProtoMode      `protobuf:"varint,3,opt,name=Proto,proto3,enum=pds.LldpProtoMode" json:"Proto,omitempty"`
	Age               uint32             `protobuf:"varint,4,opt,name=Age,proto3" json:"Age,omitempty"`
	LldpIfChassisSpec *LldpIfChassisSpec `protobuf:"bytes,5,opt,name=LldpIfChassisSpec" json:"LldpIfChassisSpec,omitempty"`
	LldpIfPortSpec    *LldpIfPortSpec    `protobuf:"bytes,6,opt,name=LldpIfPortSpec" json:"LldpIfPortSpec,omitempty"`
}

func (m *LldpIfSpec) Reset()                    { *m = LldpIfSpec{} }
func (m *LldpIfSpec) String() string            { return proto.CompactTextString(m) }
func (*LldpIfSpec) ProtoMessage()               {}
func (*LldpIfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{5} }

func (m *LldpIfSpec) GetIfName() string {
	if m != nil {
		return m.IfName
	}
	return ""
}

func (m *LldpIfSpec) GetRouterId() uint32 {
	if m != nil {
		return m.RouterId
	}
	return 0
}

func (m *LldpIfSpec) GetProto() LldpProtoMode {
	if m != nil {
		return m.Proto
	}
	return LldpProtoMode_LLDP_MODE_NONE
}

func (m *LldpIfSpec) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *LldpIfSpec) GetLldpIfChassisSpec() *LldpIfChassisSpec {
	if m != nil {
		return m.LldpIfChassisSpec
	}
	return nil
}

func (m *LldpIfSpec) GetLldpIfPortSpec() *LldpIfPortSpec {
	if m != nil {
		return m.LldpIfPortSpec
	}
	return nil
}

type LldpSpec struct {
	LldpIfSpec  *LldpIfSpec `protobuf:"bytes,1,opt,name=LldpIfSpec" json:"LldpIfSpec,omitempty"`
	LldpNbrSpec *LldpIfSpec `protobuf:"bytes,2,opt,name=LldpNbrSpec" json:"LldpNbrSpec,omitempty"`
}

func (m *LldpSpec) Reset()                    { *m = LldpSpec{} }
func (m *LldpSpec) String() string            { return proto.CompactTextString(m) }
func (*LldpSpec) ProtoMessage()               {}
func (*LldpSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{6} }

func (m *LldpSpec) GetLldpIfSpec() *LldpIfSpec {
	if m != nil {
		return m.LldpIfSpec
	}
	return nil
}

func (m *LldpSpec) GetLldpNbrSpec() *LldpIfSpec {
	if m != nil {
		return m.LldpNbrSpec
	}
	return nil
}

// Uplink configuration (if interface type is IF_TYPE_UPLINK)
type UplinkSpec struct {
	// physical port id corresponding to this interface
	PortId []byte `protobuf:"bytes,1,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagged
	NativeVlanId uint32 `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
	// Lldp info for the uplink interface
	LldpSpec *LldpSpec `protobuf:"bytes,3,opt,name=LldpSpec" json:"LldpSpec,omitempty"`
}

func (m *UplinkSpec) Reset()                    { *m = UplinkSpec{} }
func (m *UplinkSpec) String() string            { return proto.CompactTextString(m) }
func (*UplinkSpec) ProtoMessage()               {}
func (*UplinkSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{7} }

func (m *UplinkSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *UplinkSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

func (m *UplinkSpec) GetLldpSpec() *LldpSpec {
	if m != nil {
		return m.LldpSpec
	}
	return nil
}

// Uplink port-channel configuration (i.e., if interface type is
// IF_TYPE_UPLINK_PC)
type UplinkPCSpec struct {
	// member interfaces of this port-channel in the form of bitmap
	// (e.g. if uplink interfaces 1 and 2 part of this port channel
	// this is set to 0x11
	MemberIfBitmap uint64 `protobuf:"varint,1,opt,name=MemberIfBitmap,proto3" json:"MemberIfBitmap,omitempty"`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagge
	NativeVlanId uint32 `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
}

func (m *UplinkPCSpec) Reset()                    { *m = UplinkPCSpec{} }
func (m *UplinkPCSpec) String() string            { return proto.CompactTextString(m) }
func (*UplinkPCSpec) ProtoMessage()               {}
func (*UplinkPCSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{8} }

func (m *UplinkPCSpec) GetMemberIfBitmap() uint64 {
	if m != nil {
		return m.MemberIfBitmap
	}
	return 0
}

func (m *UplinkPCSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

// L3 interface configuration
type L3IfSpec struct {
	// vpc/vrf this L3 interface belongs to
	VpcId []byte `protobuf:"bytes,1,opt,name=VpcId,proto3" json:"VpcId,omitempty" meta:mandatory`
	// IP address, prefix of this L3 interface
	Prefix *IPPrefix `protobuf:"bytes,2,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
	// Physical port of this L3 interface
	PortId []byte `protobuf:"bytes,3,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory`
	// (optional) encap used for packet rewrites if this is a L3 sub interface
	Encap *Encap `protobuf:"bytes,4,opt,name=Encap" json:"Encap,omitempty"`
	// MAC address of this L3 interface
	MACAddress uint64 `protobuf:"varint,5,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
}

func (m *L3IfSpec) Reset()                    { *m = L3IfSpec{} }
func (m *L3IfSpec) String() string            { return proto.CompactTextString(m) }
func (*L3IfSpec) ProtoMessage()               {}
func (*L3IfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{9} }

func (m *L3IfSpec) GetVpcId() []byte {
	if m != nil {
		return m.VpcId
	}
	return nil
}

func (m *L3IfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *L3IfSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *L3IfSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *L3IfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

// Loopback interface configuration
type LoopbackIfSpec struct {
	// IP address hosted on the loopback interface
	// NOTE: This IP address is in underlay VPC
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
}

func (m *LoopbackIfSpec) Reset()                    { *m = LoopbackIfSpec{} }
func (m *LoopbackIfSpec) String() string            { return proto.CompactTextString(m) }
func (*LoopbackIfSpec) ProtoMessage()               {}
func (*LoopbackIfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{10} }

func (m *LoopbackIfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

// Inband control interface configuration
type ControlIfSpec struct {
	// IP address hosted on the inband control interface
	Prefix     *IPPrefix  `protobuf:"bytes,1,opt,name=Prefix" json:"Prefix,omitempty" meta:mandatory`
	MACAddress uint64     `protobuf:"varint,2,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	Gateway    *IPAddress `protobuf:"bytes,3,opt,name=Gateway" json:"Gateway,omitempty"`
}

func (m *ControlIfSpec) Reset()                    { *m = ControlIfSpec{} }
func (m *ControlIfSpec) String() string            { return proto.CompactTextString(m) }
func (*ControlIfSpec) ProtoMessage()               {}
func (*ControlIfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{11} }

func (m *ControlIfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ControlIfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

func (m *ControlIfSpec) GetGateway() *IPAddress {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// HostIfSpec represents a host visisble device (e.g. eth interface)
// NOTE: host interfaces can't be created or deleted via the API, they are
//       created during bringup of DSC; only policies (for example, (mirror
//       policy) can be applied on such interfaces and they can't be brought
//       down or up as they are host devices and DSC has no control over them
type HostIfSpec struct {
}

func (m *HostIfSpec) Reset()                    { *m = HostIfSpec{} }
func (m *HostIfSpec) String() string            { return proto.CompactTextString(m) }
func (*HostIfSpec) ProtoMessage()               {}
func (*HostIfSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{12} }

// InterfaceSpec is used to add or update of an interface
type InterfaceSpec struct {
	// unique interface id
	// NOTE: interface ids start from 1, for IF_TYPE_UPLINK this id is in the
	//       range [1...max-ports#] and same for IF_TYPE_UPLINK_PC
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// type of the interface
	Type IfType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.IfType" json:"Type,omitempty" meta:mandatory,immutable`
	// port up|down adminstratively
	AdminStatus IfStatus `protobuf:"varint,3,opt,name=AdminStatus,proto3,enum=pds.IfStatus" json:"AdminStatus,omitempty"`
	// interface type specific configuration
	//
	// Types that are valid to be assigned to Ifinfo:
	//	*InterfaceSpec_UplinkSpec
	//	*InterfaceSpec_UplinkPCSpec
	//	*InterfaceSpec_L3IfSpec
	//	*InterfaceSpec_LoopbackIfSpec
	//	*InterfaceSpec_ControlIfSpec
	//	*InterfaceSpec_HostIfSpec
	Ifinfo isInterfaceSpec_Ifinfo `protobuf_oneof:"ifinfo"`
	// Tx/egress mirror session id list, if any
	TxMirrorSessionId [][]byte `protobuf:"bytes,10,rep,name=TxMirrorSessionId" json:"TxMirrorSessionId,omitempty"`
	// Rx/ingress mirror session id list, if any
	RxMirrorSessionId [][]byte `protobuf:"bytes,11,rep,name=RxMirrorSessionId" json:"RxMirrorSessionId,omitempty"`
}

func (m *InterfaceSpec) Reset()                    { *m = InterfaceSpec{} }
func (m *InterfaceSpec) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec) ProtoMessage()               {}
func (*InterfaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{13} }

type isInterfaceSpec_Ifinfo interface {
	isInterfaceSpec_Ifinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceSpec_UplinkSpec struct {
	UplinkSpec *UplinkSpec `protobuf:"bytes,4,opt,name=UplinkSpec,oneof"`
}
type InterfaceSpec_UplinkPCSpec struct {
	UplinkPCSpec *UplinkPCSpec `protobuf:"bytes,5,opt,name=UplinkPCSpec,oneof"`
}
type InterfaceSpec_L3IfSpec struct {
	L3IfSpec *L3IfSpec `protobuf:"bytes,6,opt,name=L3IfSpec,oneof"`
}
type InterfaceSpec_LoopbackIfSpec struct {
	LoopbackIfSpec *LoopbackIfSpec `protobuf:"bytes,7,opt,name=LoopbackIfSpec,oneof"`
}
type InterfaceSpec_ControlIfSpec struct {
	ControlIfSpec *ControlIfSpec `protobuf:"bytes,8,opt,name=ControlIfSpec,oneof"`
}
type InterfaceSpec_HostIfSpec struct {
	HostIfSpec *HostIfSpec `protobuf:"bytes,9,opt,name=HostIfSpec,oneof"`
}

func (*InterfaceSpec_UplinkSpec) isInterfaceSpec_Ifinfo()     {}
func (*InterfaceSpec_UplinkPCSpec) isInterfaceSpec_Ifinfo()   {}
func (*InterfaceSpec_L3IfSpec) isInterfaceSpec_Ifinfo()       {}
func (*InterfaceSpec_LoopbackIfSpec) isInterfaceSpec_Ifinfo() {}
func (*InterfaceSpec_ControlIfSpec) isInterfaceSpec_Ifinfo()  {}
func (*InterfaceSpec_HostIfSpec) isInterfaceSpec_Ifinfo()     {}

func (m *InterfaceSpec) GetIfinfo() isInterfaceSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (m *InterfaceSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *InterfaceSpec) GetType() IfType {
	if m != nil {
		return m.Type
	}
	return IfType_IF_TYPE_NONE
}

func (m *InterfaceSpec) GetAdminStatus() IfStatus {
	if m != nil {
		return m.AdminStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceSpec) GetUplinkSpec() *UplinkSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkSpec); ok {
		return x.UplinkSpec
	}
	return nil
}

func (m *InterfaceSpec) GetUplinkPCSpec() *UplinkPCSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkPCSpec); ok {
		return x.UplinkPCSpec
	}
	return nil
}

func (m *InterfaceSpec) GetL3IfSpec() *L3IfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_L3IfSpec); ok {
		return x.L3IfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetLoopbackIfSpec() *LoopbackIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_LoopbackIfSpec); ok {
		return x.LoopbackIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetControlIfSpec() *ControlIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_ControlIfSpec); ok {
		return x.ControlIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetHostIfSpec() *HostIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_HostIfSpec); ok {
		return x.HostIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetTxMirrorSessionId() [][]byte {
	if m != nil {
		return m.TxMirrorSessionId
	}
	return nil
}

func (m *InterfaceSpec) GetRxMirrorSessionId() [][]byte {
	if m != nil {
		return m.RxMirrorSessionId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceSpec_OneofMarshaler, _InterfaceSpec_OneofUnmarshaler, _InterfaceSpec_OneofSizer, []interface{}{
		(*InterfaceSpec_UplinkSpec)(nil),
		(*InterfaceSpec_UplinkPCSpec)(nil),
		(*InterfaceSpec_L3IfSpec)(nil),
		(*InterfaceSpec_LoopbackIfSpec)(nil),
		(*InterfaceSpec_ControlIfSpec)(nil),
		(*InterfaceSpec_HostIfSpec)(nil),
	}
}

func _InterfaceSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceSpec)
	// ifinfo
	switch x := m.Ifinfo.(type) {
	case *InterfaceSpec_UplinkSpec:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkSpec); err != nil {
			return err
		}
	case *InterfaceSpec_UplinkPCSpec:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkPCSpec); err != nil {
			return err
		}
	case *InterfaceSpec_L3IfSpec:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3IfSpec); err != nil {
			return err
		}
	case *InterfaceSpec_LoopbackIfSpec:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoopbackIfSpec); err != nil {
			return err
		}
	case *InterfaceSpec_ControlIfSpec:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ControlIfSpec); err != nil {
			return err
		}
	case *InterfaceSpec_HostIfSpec:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HostIfSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InterfaceSpec.Ifinfo has unexpected type %T", x)
	}
	return nil
}

func _InterfaceSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceSpec)
	switch tag {
	case 4: // ifinfo.UplinkSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_UplinkSpec{msg}
		return true, err
	case 5: // ifinfo.UplinkPCSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkPCSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_UplinkPCSpec{msg}
		return true, err
	case 6: // ifinfo.L3IfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L3IfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_L3IfSpec{msg}
		return true, err
	case 7: // ifinfo.LoopbackIfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoopbackIfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_LoopbackIfSpec{msg}
		return true, err
	case 8: // ifinfo.ControlIfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControlIfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_ControlIfSpec{msg}
		return true, err
	case 9: // ifinfo.HostIfSpec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HostIfSpec)
		err := b.DecodeMessage(msg)
		m.Ifinfo = &InterfaceSpec_HostIfSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceSpec)
	// ifinfo
	switch x := m.Ifinfo.(type) {
	case *InterfaceSpec_UplinkSpec:
		s := proto.Size(x.UplinkSpec)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_UplinkPCSpec:
		s := proto.Size(x.UplinkPCSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_L3IfSpec:
		s := proto.Size(x.L3IfSpec)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_LoopbackIfSpec:
		s := proto.Size(x.LoopbackIfSpec)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_ControlIfSpec:
		s := proto.Size(x.ControlIfSpec)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceSpec_HostIfSpec:
		s := proto.Size(x.HostIfSpec)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// operational status of uplink interface
type UplinkIfStatus struct {
	// lif id associated with this uplink
	LifId uint32 `protobuf:"varint,1,opt,name=LifId,proto3" json:"LifId,omitempty"`
}

func (m *UplinkIfStatus) Reset()                    { *m = UplinkIfStatus{} }
func (m *UplinkIfStatus) String() string            { return proto.CompactTextString(m) }
func (*UplinkIfStatus) ProtoMessage()               {}
func (*UplinkIfStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{14} }

func (m *UplinkIfStatus) GetLifId() uint32 {
	if m != nil {
		return m.LifId
	}
	return 0
}

// operational status of loopback interface
type LoopbackIfStatus struct {
	// loopback interface name in linux
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *LoopbackIfStatus) Reset()                    { *m = LoopbackIfStatus{} }
func (m *LoopbackIfStatus) String() string            { return proto.CompactTextString(m) }
func (*LoopbackIfStatus) ProtoMessage()               {}
func (*LoopbackIfStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{15} }

func (m *LoopbackIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// operational status of host interfaces
type HostIfStatus struct {
	// host interface can have one or more lifs behind it
	LifId [][]byte `protobuf:"bytes,1,rep,name=LifId" json:"LifId,omitempty"`
	// MAC address of this interface
	MacAddress uint64 `protobuf:"varint,2,opt,name=MacAddress,proto3" json:"MacAddress,omitempty"`
	// operational status of this interface
	Status IfStatus `protobuf:"varint,3,opt,name=Status,proto3,enum=pds.IfStatus" json:"Status,omitempty"`
}

func (m *HostIfStatus) Reset()                    { *m = HostIfStatus{} }
func (m *HostIfStatus) String() string            { return proto.CompactTextString(m) }
func (*HostIfStatus) ProtoMessage()               {}
func (*HostIfStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{16} }

func (m *HostIfStatus) GetLifId() [][]byte {
	if m != nil {
		return m.LifId
	}
	return nil
}

func (m *HostIfStatus) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *HostIfStatus) GetStatus() IfStatus {
	if m != nil {
		return m.Status
	}
	return IfStatus_IF_STATUS_NONE
}

// operational status of an interface, if any
type InterfaceStatus struct {
	// encoded interface index of this interface
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// operational status of the interface
	OperStatus IfStatus `protobuf:"varint,2,opt,name=OperStatus,proto3,enum=pds.IfStatus" json:"OperStatus,omitempty"`
	// Types that are valid to be assigned to Ifstatus:
	//	*InterfaceStatus_UplinkIfStatus
	//	*InterfaceStatus_LoopbackIfStatus
	//	*InterfaceStatus_HostIfStatus
	Ifstatus isInterfaceStatus_Ifstatus `protobuf_oneof:"ifstatus"`
}

func (m *InterfaceStatus) Reset()                    { *m = InterfaceStatus{} }
func (m *InterfaceStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStatus) ProtoMessage()               {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{17} }

type isInterfaceStatus_Ifstatus interface {
	isInterfaceStatus_Ifstatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceStatus_UplinkIfStatus struct {
	UplinkIfStatus *UplinkIfStatus `protobuf:"bytes,3,opt,name=UplinkIfStatus,oneof"`
}
type InterfaceStatus_LoopbackIfStatus struct {
	LoopbackIfStatus *LoopbackIfStatus `protobuf:"bytes,4,opt,name=LoopbackIfStatus,oneof"`
}
type InterfaceStatus_HostIfStatus struct {
	HostIfStatus *HostIfStatus `protobuf:"bytes,5,opt,name=HostIfStatus,oneof"`
}

func (*InterfaceStatus_UplinkIfStatus) isInterfaceStatus_Ifstatus()   {}
func (*InterfaceStatus_LoopbackIfStatus) isInterfaceStatus_Ifstatus() {}
func (*InterfaceStatus_HostIfStatus) isInterfaceStatus_Ifstatus()     {}

func (m *InterfaceStatus) GetIfstatus() isInterfaceStatus_Ifstatus {
	if m != nil {
		return m.Ifstatus
	}
	return nil
}

func (m *InterfaceStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *InterfaceStatus) GetOperStatus() IfStatus {
	if m != nil {
		return m.OperStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceStatus) GetUplinkIfStatus() *UplinkIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_UplinkIfStatus); ok {
		return x.UplinkIfStatus
	}
	return nil
}

func (m *InterfaceStatus) GetLoopbackIfStatus() *LoopbackIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_LoopbackIfStatus); ok {
		return x.LoopbackIfStatus
	}
	return nil
}

func (m *InterfaceStatus) GetHostIfStatus() *HostIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_HostIfStatus); ok {
		return x.HostIfStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceStatus_OneofMarshaler, _InterfaceStatus_OneofUnmarshaler, _InterfaceStatus_OneofSizer, []interface{}{
		(*InterfaceStatus_UplinkIfStatus)(nil),
		(*InterfaceStatus_LoopbackIfStatus)(nil),
		(*InterfaceStatus_HostIfStatus)(nil),
	}
}

func _InterfaceStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceStatus)
	// ifstatus
	switch x := m.Ifstatus.(type) {
	case *InterfaceStatus_UplinkIfStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkIfStatus); err != nil {
			return err
		}
	case *InterfaceStatus_LoopbackIfStatus:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoopbackIfStatus); err != nil {
			return err
		}
	case *InterfaceStatus_HostIfStatus:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HostIfStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InterfaceStatus.Ifstatus has unexpected type %T", x)
	}
	return nil
}

func _InterfaceStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceStatus)
	switch tag {
	case 3: // ifstatus.UplinkIfStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkIfStatus)
		err := b.DecodeMessage(msg)
		m.Ifstatus = &InterfaceStatus_UplinkIfStatus{msg}
		return true, err
	case 4: // ifstatus.LoopbackIfStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoopbackIfStatus)
		err := b.DecodeMessage(msg)
		m.Ifstatus = &InterfaceStatus_LoopbackIfStatus{msg}
		return true, err
	case 5: // ifstatus.HostIfStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HostIfStatus)
		err := b.DecodeMessage(msg)
		m.Ifstatus = &InterfaceStatus_HostIfStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceStatus)
	// ifstatus
	switch x := m.Ifstatus.(type) {
	case *InterfaceStatus_UplinkIfStatus:
		s := proto.Size(x.UplinkIfStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStatus_LoopbackIfStatus:
		s := proto.Size(x.LoopbackIfStatus)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStatus_HostIfStatus:
		s := proto.Size(x.HostIfStatus)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UplinkIfStats struct {
	LldpIfStats *LldpIfStats `protobuf:"bytes,1,opt,name=LldpIfStats" json:"LldpIfStats,omitempty"`
}

func (m *UplinkIfStats) Reset()                    { *m = UplinkIfStats{} }
func (m *UplinkIfStats) String() string            { return proto.CompactTextString(m) }
func (*UplinkIfStats) ProtoMessage()               {}
func (*UplinkIfStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{18} }

func (m *UplinkIfStats) GetLldpIfStats() *LldpIfStats {
	if m != nil {
		return m.LldpIfStats
	}
	return nil
}

type UplinkPCStats struct {
}

func (m *UplinkPCStats) Reset()                    { *m = UplinkPCStats{} }
func (m *UplinkPCStats) String() string            { return proto.CompactTextString(m) }
func (*UplinkPCStats) ProtoMessage()               {}
func (*UplinkPCStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{19} }

type L3IfStats struct {
}

func (m *L3IfStats) Reset()                    { *m = L3IfStats{} }
func (m *L3IfStats) String() string            { return proto.CompactTextString(m) }
func (*L3IfStats) ProtoMessage()               {}
func (*L3IfStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{20} }

type LoopbackIfStats struct {
}

func (m *LoopbackIfStats) Reset()                    { *m = LoopbackIfStats{} }
func (m *LoopbackIfStats) String() string            { return proto.CompactTextString(m) }
func (*LoopbackIfStats) ProtoMessage()               {}
func (*LoopbackIfStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{21} }

type ControlIfStats struct {
}

func (m *ControlIfStats) Reset()                    { *m = ControlIfStats{} }
func (m *ControlIfStats) String() string            { return proto.CompactTextString(m) }
func (*ControlIfStats) ProtoMessage()               {}
func (*ControlIfStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{22} }

// stats for an interface, if any
type InterfaceStats struct {
	// Types that are valid to be assigned to Ifstats:
	//	*InterfaceStats_UplinkIfStats
	//	*InterfaceStats_UplinkPCStats
	//	*InterfaceStats_L3IfStats
	//	*InterfaceStats_LoopbackIfStats
	//	*InterfaceStats_ControlIfStats
	Ifstats isInterfaceStats_Ifstats `protobuf_oneof:"ifstats"`
}

func (m *InterfaceStats) Reset()                    { *m = InterfaceStats{} }
func (m *InterfaceStats) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStats) ProtoMessage()               {}
func (*InterfaceStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{23} }

type isInterfaceStats_Ifstats interface {
	isInterfaceStats_Ifstats()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceStats_UplinkIfStats struct {
	UplinkIfStats *UplinkIfStats `protobuf:"bytes,1,opt,name=UplinkIfStats,oneof"`
}
type InterfaceStats_UplinkPCStats struct {
	UplinkPCStats *UplinkPCStats `protobuf:"bytes,2,opt,name=UplinkPCStats,oneof"`
}
type InterfaceStats_L3IfStats struct {
	L3IfStats *L3IfStats `protobuf:"bytes,3,opt,name=L3IfStats,oneof"`
}
type InterfaceStats_LoopbackIfStats struct {
	LoopbackIfStats *LoopbackIfStats `protobuf:"bytes,4,opt,name=LoopbackIfStats,oneof"`
}
type InterfaceStats_ControlIfStats struct {
	ControlIfStats *ControlIfStats `protobuf:"bytes,5,opt,name=ControlIfStats,oneof"`
}

func (*InterfaceStats_UplinkIfStats) isInterfaceStats_Ifstats()   {}
func (*InterfaceStats_UplinkPCStats) isInterfaceStats_Ifstats()   {}
func (*InterfaceStats_L3IfStats) isInterfaceStats_Ifstats()       {}
func (*InterfaceStats_LoopbackIfStats) isInterfaceStats_Ifstats() {}
func (*InterfaceStats_ControlIfStats) isInterfaceStats_Ifstats()  {}

func (m *InterfaceStats) GetIfstats() isInterfaceStats_Ifstats {
	if m != nil {
		return m.Ifstats
	}
	return nil
}

func (m *InterfaceStats) GetUplinkIfStats() *UplinkIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_UplinkIfStats); ok {
		return x.UplinkIfStats
	}
	return nil
}

func (m *InterfaceStats) GetUplinkPCStats() *UplinkPCStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_UplinkPCStats); ok {
		return x.UplinkPCStats
	}
	return nil
}

func (m *InterfaceStats) GetL3IfStats() *L3IfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_L3IfStats); ok {
		return x.L3IfStats
	}
	return nil
}

func (m *InterfaceStats) GetLoopbackIfStats() *LoopbackIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_LoopbackIfStats); ok {
		return x.LoopbackIfStats
	}
	return nil
}

func (m *InterfaceStats) GetControlIfStats() *ControlIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_ControlIfStats); ok {
		return x.ControlIfStats
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InterfaceStats) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InterfaceStats_OneofMarshaler, _InterfaceStats_OneofUnmarshaler, _InterfaceStats_OneofSizer, []interface{}{
		(*InterfaceStats_UplinkIfStats)(nil),
		(*InterfaceStats_UplinkPCStats)(nil),
		(*InterfaceStats_L3IfStats)(nil),
		(*InterfaceStats_LoopbackIfStats)(nil),
		(*InterfaceStats_ControlIfStats)(nil),
	}
}

func _InterfaceStats_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InterfaceStats)
	// ifstats
	switch x := m.Ifstats.(type) {
	case *InterfaceStats_UplinkIfStats:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkIfStats); err != nil {
			return err
		}
	case *InterfaceStats_UplinkPCStats:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UplinkPCStats); err != nil {
			return err
		}
	case *InterfaceStats_L3IfStats:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3IfStats); err != nil {
			return err
		}
	case *InterfaceStats_LoopbackIfStats:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoopbackIfStats); err != nil {
			return err
		}
	case *InterfaceStats_ControlIfStats:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ControlIfStats); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InterfaceStats.Ifstats has unexpected type %T", x)
	}
	return nil
}

func _InterfaceStats_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InterfaceStats)
	switch tag {
	case 1: // ifstats.UplinkIfStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkIfStats)
		err := b.DecodeMessage(msg)
		m.Ifstats = &InterfaceStats_UplinkIfStats{msg}
		return true, err
	case 2: // ifstats.UplinkPCStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UplinkPCStats)
		err := b.DecodeMessage(msg)
		m.Ifstats = &InterfaceStats_UplinkPCStats{msg}
		return true, err
	case 3: // ifstats.L3IfStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L3IfStats)
		err := b.DecodeMessage(msg)
		m.Ifstats = &InterfaceStats_L3IfStats{msg}
		return true, err
	case 4: // ifstats.LoopbackIfStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoopbackIfStats)
		err := b.DecodeMessage(msg)
		m.Ifstats = &InterfaceStats_LoopbackIfStats{msg}
		return true, err
	case 5: // ifstats.ControlIfStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControlIfStats)
		err := b.DecodeMessage(msg)
		m.Ifstats = &InterfaceStats_ControlIfStats{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InterfaceStats_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InterfaceStats)
	// ifstats
	switch x := m.Ifstats.(type) {
	case *InterfaceStats_UplinkIfStats:
		s := proto.Size(x.UplinkIfStats)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStats_UplinkPCStats:
		s := proto.Size(x.UplinkPCStats)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStats_L3IfStats:
		s := proto.Size(x.L3IfStats)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStats_LoopbackIfStats:
		s := proto.Size(x.LoopbackIfStats)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InterfaceStats_ControlIfStats:
		s := proto.Size(x.ControlIfStats)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// interface Object
type Interface struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *InterfaceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *InterfaceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *InterfaceStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{24} }

func (m *Interface) GetSpec() *InterfaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Interface) GetStatus() *InterfaceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Interface) GetStats() *InterfaceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// interface create and update request
type InterfaceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// batched requests
	Request []*InterfaceSpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *InterfaceRequest) Reset()                    { *m = InterfaceRequest{} }
func (m *InterfaceRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceRequest) ProtoMessage()               {}
func (*InterfaceRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{25} }

func (m *InterfaceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceRequest) GetRequest() []*InterfaceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// interface create and update response
type InterfaceResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*InterfaceStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *InterfaceResponse) Reset()                    { *m = InterfaceResponse{} }
func (m *InterfaceResponse) String() string            { return proto.CompactTextString(m) }
func (*InterfaceResponse) ProtoMessage()               {}
func (*InterfaceResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{26} }

func (m *InterfaceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceResponse) GetResponse() []*InterfaceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface get request
type InterfaceGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *InterfaceGetRequest) Reset()                    { *m = InterfaceGetRequest{} }
func (m *InterfaceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetRequest) ProtoMessage()               {}
func (*InterfaceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{27} }

func (m *InterfaceGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface get response
type InterfaceGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*Interface `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *InterfaceGetResponse) Reset()                    { *m = InterfaceGetResponse{} }
func (m *InterfaceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*InterfaceGetResponse) ProtoMessage()               {}
func (*InterfaceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{28} }

func (m *InterfaceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceGetResponse) GetResponse() []*Interface {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface delete request
type InterfaceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *InterfaceDeleteRequest) Reset()                    { *m = InterfaceDeleteRequest{} }
func (m *InterfaceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*InterfaceDeleteRequest) ProtoMessage()               {}
func (*InterfaceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{29} }

func (m *InterfaceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface delete response
type InterfaceDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *InterfaceDeleteResponse) Reset()         { *m = InterfaceDeleteResponse{} }
func (m *InterfaceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*InterfaceDeleteResponse) ProtoMessage()    {}
func (*InterfaceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{30}
}

func (m *InterfaceDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// / Lif (Logical interface) object represents a device (eth/storage etc.)
// / NOTE: Lif objects are internal and host devices can have multiple lifs
// /       behind them
type LifSpec struct {
	// unique key of the lif
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// type of the lif device
	Type LifType `protobuf:"varint,2,opt,name=Type,proto3,enum=types.LifType" json:"Type,omitempty"`
	// MAC address of the lif, if any
	MacAddress uint64 `protobuf:"varint,3,opt,name=MacAddress,proto3" json:"MacAddress,omitempty"`
	// pinned uplink interface, if applicable for this device
	PinnedInterface []byte `protobuf:"bytes,4,opt,name=PinnedInterface,proto3" json:"PinnedInterface,omitempty"`
}

func (m *LifSpec) Reset()                    { *m = LifSpec{} }
func (m *LifSpec) String() string            { return proto.CompactTextString(m) }
func (*LifSpec) ProtoMessage()               {}
func (*LifSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{31} }

func (m *LifSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LifSpec) GetType() LifType {
	if m != nil {
		return m.Type
	}
	return LifType_LIF_TYPE_NONE
}

func (m *LifSpec) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *LifSpec) GetPinnedInterface() []byte {
	if m != nil {
		return m.PinnedInterface
	}
	return nil
}

type LifStatus struct {
	// encoded ifindex of this lif
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// name of this lif (as seen on the host)
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// admin state of the lif (reflects PF/VF status on the host/VM)
	AdminState IfStatus `protobuf:"varint,3,opt,name=AdminState,proto3,enum=pds.IfStatus" json:"AdminState,omitempty"`
	// operational status of this lif
	Status IfStatus `protobuf:"varint,4,opt,name=Status,proto3,enum=pds.IfStatus" json:"Status,omitempty"`
	// nexthop hw idx of this lif, if any
	NhIndex uint32 `protobuf:"varint,5,opt,name=NhIndex,proto3" json:"NhIndex,omitempty"`
}

func (m *LifStatus) Reset()                    { *m = LifStatus{} }
func (m *LifStatus) String() string            { return proto.CompactTextString(m) }
func (*LifStatus) ProtoMessage()               {}
func (*LifStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{32} }

func (m *LifStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LifStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LifStatus) GetAdminState() IfStatus {
	if m != nil {
		return m.AdminState
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *LifStatus) GetStatus() IfStatus {
	if m != nil {
		return m.Status
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *LifStatus) GetNhIndex() uint32 {
	if m != nil {
		return m.NhIndex
	}
	return 0
}

type LifStats struct {
}

func (m *LifStats) Reset()                    { *m = LifStats{} }
func (m *LifStats) String() string            { return proto.CompactTextString(m) }
func (*LifStats) ProtoMessage()               {}
func (*LifStats) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{33} }

type Lif struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *LifSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *LifStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *LifStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Lif) Reset()                    { *m = Lif{} }
func (m *Lif) String() string            { return proto.CompactTextString(m) }
func (*Lif) ProtoMessage()               {}
func (*Lif) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{34} }

func (m *Lif) GetSpec() *LifSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Lif) GetStatus() *LifStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Lif) GetStats() *LifStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type LifGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *LifGetRequest) Reset()                    { *m = LifGetRequest{} }
func (m *LifGetRequest) String() string            { return proto.CompactTextString(m) }
func (*LifGetRequest) ProtoMessage()               {}
func (*LifGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{35} }

func (m *LifGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type LifGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*Lif    `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *LifGetResponse) Reset()                    { *m = LifGetResponse{} }
func (m *LifGetResponse) String() string            { return proto.CompactTextString(m) }
func (*LifGetResponse) ProtoMessage()               {}
func (*LifGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{36} }

func (m *LifGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LifGetResponse) GetResponse() []*Lif {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*LldpIfStats)(nil), "pds.LldpIfStats")
	proto.RegisterType((*LldpId)(nil), "pds.LldpId")
	proto.RegisterType((*LldpChassisCapabilitySpec)(nil), "pds.LldpChassisCapabilitySpec")
	proto.RegisterType((*LldpIfChassisSpec)(nil), "pds.LldpIfChassisSpec")
	proto.RegisterType((*LldpIfPortSpec)(nil), "pds.LldpIfPortSpec")
	proto.RegisterType((*LldpIfSpec)(nil), "pds.LldpIfSpec")
	proto.RegisterType((*LldpSpec)(nil), "pds.LldpSpec")
	proto.RegisterType((*UplinkSpec)(nil), "pds.UplinkSpec")
	proto.RegisterType((*UplinkPCSpec)(nil), "pds.UplinkPCSpec")
	proto.RegisterType((*L3IfSpec)(nil), "pds.L3IfSpec")
	proto.RegisterType((*LoopbackIfSpec)(nil), "pds.LoopbackIfSpec")
	proto.RegisterType((*ControlIfSpec)(nil), "pds.ControlIfSpec")
	proto.RegisterType((*HostIfSpec)(nil), "pds.HostIfSpec")
	proto.RegisterType((*InterfaceSpec)(nil), "pds.InterfaceSpec")
	proto.RegisterType((*UplinkIfStatus)(nil), "pds.UplinkIfStatus")
	proto.RegisterType((*LoopbackIfStatus)(nil), "pds.LoopbackIfStatus")
	proto.RegisterType((*HostIfStatus)(nil), "pds.HostIfStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "pds.InterfaceStatus")
	proto.RegisterType((*UplinkIfStats)(nil), "pds.UplinkIfStats")
	proto.RegisterType((*UplinkPCStats)(nil), "pds.UplinkPCStats")
	proto.RegisterType((*L3IfStats)(nil), "pds.L3IfStats")
	proto.RegisterType((*LoopbackIfStats)(nil), "pds.LoopbackIfStats")
	proto.RegisterType((*ControlIfStats)(nil), "pds.ControlIfStats")
	proto.RegisterType((*InterfaceStats)(nil), "pds.InterfaceStats")
	proto.RegisterType((*Interface)(nil), "pds.Interface")
	proto.RegisterType((*InterfaceRequest)(nil), "pds.InterfaceRequest")
	proto.RegisterType((*InterfaceResponse)(nil), "pds.InterfaceResponse")
	proto.RegisterType((*InterfaceGetRequest)(nil), "pds.InterfaceGetRequest")
	proto.RegisterType((*InterfaceGetResponse)(nil), "pds.InterfaceGetResponse")
	proto.RegisterType((*InterfaceDeleteRequest)(nil), "pds.InterfaceDeleteRequest")
	proto.RegisterType((*InterfaceDeleteResponse)(nil), "pds.InterfaceDeleteResponse")
	proto.RegisterType((*LifSpec)(nil), "pds.LifSpec")
	proto.RegisterType((*LifStatus)(nil), "pds.LifStatus")
	proto.RegisterType((*LifStats)(nil), "pds.LifStats")
	proto.RegisterType((*Lif)(nil), "pds.Lif")
	proto.RegisterType((*LifGetRequest)(nil), "pds.LifGetRequest")
	proto.RegisterType((*LifGetResponse)(nil), "pds.LifGetResponse")
	proto.RegisterEnum("pds.IfType", IfType_name, IfType_value)
	proto.RegisterEnum("pds.IfStatus", IfStatus_name, IfStatus_value)
	proto.RegisterEnum("pds.LldpIdType", LldpIdType_name, LldpIdType_value)
	proto.RegisterEnum("pds.LldpProtoMode", LldpProtoMode_name, LldpProtoMode_value)
	proto.RegisterEnum("pds.LldpCapType", LldpCapType_name, LldpCapType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IfSvc service

type IfSvcClient interface {
	InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error)
	InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error)
	LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error)
	// given a uuid of a lif, clear its stats or else clear stats of all lifs
	LifStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type ifSvcClient struct {
	cc *grpc.ClientConn
}

func NewIfSvcClient(cc *grpc.ClientConn) IfSvcClient {
	return &ifSvcClient{cc}
}

func (c *ifSvcClient) InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error) {
	out := new(InterfaceDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error) {
	out := new(InterfaceGetResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/InterfaceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error) {
	out := new(LifGetResponse)
	err := grpc.Invoke(ctx, "/pds.IfSvc/LifGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) LifStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/pds.IfSvc/LifStatsReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IfSvc service

type IfSvcServer interface {
	InterfaceCreate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceUpdate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceDelete(context.Context, *InterfaceDeleteRequest) (*InterfaceDeleteResponse, error)
	InterfaceGet(context.Context, *InterfaceGetRequest) (*InterfaceGetResponse, error)
	LifGet(context.Context, *LifGetRequest) (*LifGetResponse, error)
	// given a uuid of a lif, clear its stats or else clear stats of all lifs
	LifStatsReset(context.Context, *Id) (*Empty, error)
}

func RegisterIfSvcServer(s *grpc.Server, srv IfSvcServer) {
	s.RegisterService(&_IfSvc_serviceDesc, srv)
}

func _IfSvc_InterfaceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceCreate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceDelete(ctx, req.(*InterfaceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceGet(ctx, req.(*InterfaceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_LifGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).LifGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/LifGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).LifGet(ctx, req.(*LifGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_LifStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).LifStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/LifStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).LifStatsReset(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _IfSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.IfSvc",
	HandlerType: (*IfSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InterfaceCreate",
			Handler:    _IfSvc_InterfaceCreate_Handler,
		},
		{
			MethodName: "InterfaceUpdate",
			Handler:    _IfSvc_InterfaceUpdate_Handler,
		},
		{
			MethodName: "InterfaceDelete",
			Handler:    _IfSvc_InterfaceDelete_Handler,
		},
		{
			MethodName: "InterfaceGet",
			Handler:    _IfSvc_InterfaceGet_Handler,
		},
		{
			MethodName: "LifGet",
			Handler:    _IfSvc_LifGet_Handler,
		},
		{
			MethodName: "LifStatsReset",
			Handler:    _IfSvc_LifStatsReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "interface.proto",
}

func (m *LldpIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TxCount))
	}
	if m.RxCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.RxCount))
	}
	if m.RxDiscarded != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.RxDiscarded))
	}
	if m.RxUnrecognized != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.RxUnrecognized))
	}
	if m.AgeoutCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.AgeoutCount))
	}
	if m.InsertCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.InsertCount))
	}
	if m.DeleteCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.DeleteCount))
	}
	return i, nil
}

func (m *LldpId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *LldpChassisCapabilitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpChassisCapabilitySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CapType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.CapType))
	}
	if m.CapEnabled {
		dAtA[i] = 0x10
		i++
		if m.CapEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LldpIfChassisSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfChassisSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SysName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.SysName)))
		i += copy(dAtA[i:], m.SysName)
	}
	if m.ChassisId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ChassisId.Size()))
		n1, err := m.ChassisId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.SysDescr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.SysDescr)))
		i += copy(dAtA[i:], m.SysDescr)
	}
	if m.MgmtIP != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MgmtIP.Size()))
		n2, err := m.MgmtIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Capability) > 0 {
		for _, msg := range m.Capability {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LldpIfPortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfPortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.PortId.Size()))
		n3, err := m.PortId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.PortDescr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortDescr)))
		i += copy(dAtA[i:], m.PortDescr)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *LldpIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.IfName)))
		i += copy(dAtA[i:], m.IfName)
	}
	if m.RouterId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.RouterId))
	}
	if m.Proto != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Proto))
	}
	if m.Age != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Age))
	}
	if m.LldpIfChassisSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpIfChassisSpec.Size()))
		n4, err := m.LldpIfChassisSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.LldpIfPortSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpIfPortSpec.Size()))
		n5, err := m.LldpIfPortSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LldpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LldpIfSpec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpIfSpec.Size()))
		n6, err := m.LldpIfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LldpNbrSpec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpNbrSpec.Size()))
		n7, err := m.LldpNbrSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *UplinkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if m.NativeVlanId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
	}
	if m.LldpSpec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpSpec.Size()))
		n8, err := m.LldpSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *UplinkPCSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemberIfBitmap != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MemberIfBitmap))
	}
	if m.NativeVlanId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
	}
	return i, nil
}

func (m *L3IfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VpcId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.VpcId)))
		i += copy(dAtA[i:], m.VpcId)
	}
	if m.Prefix != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n9, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.PortId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if m.Encap != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Encap.Size()))
		n10, err := m.Encap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MACAddress != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
	}
	return i, nil
}

func (m *LoopbackIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n11, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *ControlIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlIfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Prefix.Size()))
		n12, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.MACAddress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
	}
	if m.Gateway != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Gateway.Size()))
		n13, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *HostIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InterfaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
	}
	if m.AdminStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.AdminStatus))
	}
	if m.Ifinfo != nil {
		nn14, err := m.Ifinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			dAtA[i] = 0x52
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceSpec_UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkSpec.Size()))
		n15, err := m.UplinkSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *InterfaceSpec_UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkPCSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkPCSpec.Size()))
		n16, err := m.UplinkPCSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *InterfaceSpec_L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L3IfSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.L3IfSpec.Size()))
		n17, err := m.L3IfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *InterfaceSpec_LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoopbackIfSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LoopbackIfSpec.Size()))
		n18, err := m.LoopbackIfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *InterfaceSpec_ControlIfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ControlIfSpec != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ControlIfSpec.Size()))
		n19, err := m.ControlIfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *InterfaceSpec_HostIfSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HostIfSpec != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.HostIfSpec.Size()))
		n20, err := m.HostIfSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *UplinkIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LifId))
	}
	return i, nil
}

func (m *LoopbackIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *HostIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LifId) > 0 {
		for _, b := range m.LifId {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.MacAddress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MacAddress))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.OperStatus))
	}
	if m.Ifstatus != nil {
		nn21, err := m.Ifstatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	return i, nil
}

func (m *InterfaceStatus_UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkIfStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkIfStatus.Size()))
		n22, err := m.UplinkIfStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *InterfaceStatus_LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoopbackIfStatus != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LoopbackIfStatus.Size()))
		n23, err := m.LoopbackIfStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *InterfaceStatus_HostIfStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HostIfStatus != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.HostIfStatus.Size()))
		n24, err := m.HostIfStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *UplinkIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkIfStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LldpIfStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LldpIfStats.Size()))
		n25, err := m.LldpIfStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *UplinkPCStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkPCStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *L3IfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3IfStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *LoopbackIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ControlIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlIfStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ifstats != nil {
		nn26, err := m.Ifstats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *InterfaceStats_UplinkIfStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkIfStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkIfStats.Size()))
		n27, err := m.UplinkIfStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *InterfaceStats_UplinkPCStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UplinkPCStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkPCStats.Size()))
		n28, err := m.UplinkPCStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *InterfaceStats_L3IfStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L3IfStats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.L3IfStats.Size()))
		n29, err := m.L3IfStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *InterfaceStats_LoopbackIfStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoopbackIfStats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.LoopbackIfStats.Size()))
		n30, err := m.LoopbackIfStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *InterfaceStats_ControlIfStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ControlIfStats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ControlIfStats.Size()))
		n31, err := m.ControlIfStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
		n32, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ObjMeta.Size()))
		n33, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
		n34, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
		n35, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Stats.Size()))
		n36, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *InterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.BatchCtxt.Size()))
		n37, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.BatchCtxt.Size()))
		n38, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *InterfaceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA40 := make([]byte, len(m.ApiStatus)*10)
		var j39 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	return i, nil
}

func (m *LifSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
	}
	if m.MacAddress != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MacAddress))
	}
	if len(m.PinnedInterface) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PinnedInterface)))
		i += copy(dAtA[i:], m.PinnedInterface)
	}
	return i, nil
}

func (m *LifStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AdminState != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.AdminState))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status))
	}
	if m.NhIndex != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.NhIndex))
	}
	return i, nil
}

func (m *LifStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Lif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
		n41, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ObjMeta.Size()))
		n42, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
		n43, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
		n44, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Stats.Size()))
		n45, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *LifGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *LifGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LldpIfStats) Size() (n int) {
	var l int
	_ = l
	if m.TxCount != 0 {
		n += 1 + sovInterface(uint64(m.TxCount))
	}
	if m.RxCount != 0 {
		n += 1 + sovInterface(uint64(m.RxCount))
	}
	if m.RxDiscarded != 0 {
		n += 1 + sovInterface(uint64(m.RxDiscarded))
	}
	if m.RxUnrecognized != 0 {
		n += 1 + sovInterface(uint64(m.RxUnrecognized))
	}
	if m.AgeoutCount != 0 {
		n += 1 + sovInterface(uint64(m.AgeoutCount))
	}
	if m.InsertCount != 0 {
		n += 1 + sovInterface(uint64(m.InsertCount))
	}
	if m.DeleteCount != 0 {
		n += 1 + sovInterface(uint64(m.DeleteCount))
	}
	return n
}

func (m *LldpId) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *LldpChassisCapabilitySpec) Size() (n int) {
	var l int
	_ = l
	if m.CapType != 0 {
		n += 1 + sovInterface(uint64(m.CapType))
	}
	if m.CapEnabled {
		n += 2
	}
	return n
}

func (m *LldpIfChassisSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.SysName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ChassisId != nil {
		l = m.ChassisId.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.SysDescr)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MgmtIP != nil {
		l = m.MgmtIP.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Capability) > 0 {
		for _, e := range m.Capability {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *LldpIfPortSpec) Size() (n int) {
	var l int
	_ = l
	if m.PortId != nil {
		l = m.PortId.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.PortDescr)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovInterface(uint64(m.Ttl))
	}
	return n
}

func (m *LldpIfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.IfName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.RouterId != 0 {
		n += 1 + sovInterface(uint64(m.RouterId))
	}
	if m.Proto != 0 {
		n += 1 + sovInterface(uint64(m.Proto))
	}
	if m.Age != 0 {
		n += 1 + sovInterface(uint64(m.Age))
	}
	if m.LldpIfChassisSpec != nil {
		l = m.LldpIfChassisSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LldpIfPortSpec != nil {
		l = m.LldpIfPortSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *LldpSpec) Size() (n int) {
	var l int
	_ = l
	if m.LldpIfSpec != nil {
		l = m.LldpIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LldpNbrSpec != nil {
		l = m.LldpNbrSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *UplinkSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	if m.LldpSpec != nil {
		l = m.LldpSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *UplinkPCSpec) Size() (n int) {
	var l int
	_ = l
	if m.MemberIfBitmap != 0 {
		n += 1 + sovInterface(uint64(m.MemberIfBitmap))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	return n
}

func (m *L3IfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	return n
}

func (m *LoopbackIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *ControlIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *HostIfSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InterfaceSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	if m.AdminStatus != 0 {
		n += 1 + sovInterface(uint64(m.AdminStatus))
	}
	if m.Ifinfo != nil {
		n += m.Ifinfo.Size()
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceSpec_UplinkSpec) Size() (n int) {
	var l int
	_ = l
	if m.UplinkSpec != nil {
		l = m.UplinkSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_UplinkPCSpec) Size() (n int) {
	var l int
	_ = l
	if m.UplinkPCSpec != nil {
		l = m.UplinkPCSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_L3IfSpec) Size() (n int) {
	var l int
	_ = l
	if m.L3IfSpec != nil {
		l = m.L3IfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_LoopbackIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.LoopbackIfSpec != nil {
		l = m.LoopbackIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_ControlIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.ControlIfSpec != nil {
		l = m.ControlIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_HostIfSpec) Size() (n int) {
	var l int
	_ = l
	if m.HostIfSpec != nil {
		l = m.HostIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *UplinkIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.LifId != 0 {
		n += 1 + sovInterface(uint64(m.LifId))
	}
	return n
}

func (m *LoopbackIfStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *HostIfStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.LifId) > 0 {
		for _, b := range m.LifId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.MacAddress != 0 {
		n += 1 + sovInterface(uint64(m.MacAddress))
	}
	if m.Status != 0 {
		n += 1 + sovInterface(uint64(m.Status))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovInterface(uint64(m.OperStatus))
	}
	if m.Ifstatus != nil {
		n += m.Ifstatus.Size()
	}
	return n
}

func (m *InterfaceStatus_UplinkIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.UplinkIfStatus != nil {
		l = m.UplinkIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStatus_LoopbackIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.LoopbackIfStatus != nil {
		l = m.LoopbackIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStatus_HostIfStatus) Size() (n int) {
	var l int
	_ = l
	if m.HostIfStatus != nil {
		l = m.HostIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *UplinkIfStats) Size() (n int) {
	var l int
	_ = l
	if m.LldpIfStats != nil {
		l = m.LldpIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *UplinkPCStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *L3IfStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *LoopbackIfStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ControlIfStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InterfaceStats) Size() (n int) {
	var l int
	_ = l
	if m.Ifstats != nil {
		n += m.Ifstats.Size()
	}
	return n
}

func (m *InterfaceStats_UplinkIfStats) Size() (n int) {
	var l int
	_ = l
	if m.UplinkIfStats != nil {
		l = m.UplinkIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_UplinkPCStats) Size() (n int) {
	var l int
	_ = l
	if m.UplinkPCStats != nil {
		l = m.UplinkPCStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_L3IfStats) Size() (n int) {
	var l int
	_ = l
	if m.L3IfStats != nil {
		l = m.L3IfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_LoopbackIfStats) Size() (n int) {
	var l int
	_ = l
	if m.LoopbackIfStats != nil {
		l = m.LoopbackIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_ControlIfStats) Size() (n int) {
	var l int
	_ = l
	if m.ControlIfStats != nil {
		l = m.ControlIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *Interface) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovInterface(uint64(e))
		}
		n += 1 + sovInterface(uint64(l)) + l
	}
	return n
}

func (m *LifSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	if m.MacAddress != 0 {
		n += 1 + sovInterface(uint64(m.MacAddress))
	}
	l = len(m.PinnedInterface)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *LifStatus) Size() (n int) {
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.AdminState != 0 {
		n += 1 + sovInterface(uint64(m.AdminState))
	}
	if m.Status != 0 {
		n += 1 + sovInterface(uint64(m.Status))
	}
	if m.NhIndex != 0 {
		n += 1 + sovInterface(uint64(m.NhIndex))
	}
	return n
}

func (m *LifStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Lif) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *LifGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *LifGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func sovInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInterface(x uint64) (n int) {
	return sovInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LldpIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCount", wireType)
			}
			m.TxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxCount", wireType)
			}
			m.RxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDiscarded", wireType)
			}
			m.RxDiscarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDiscarded |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxUnrecognized", wireType)
			}
			m.RxUnrecognized = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxUnrecognized |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgeoutCount", wireType)
			}
			m.AgeoutCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgeoutCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertCount", wireType)
			}
			m.InsertCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCount", wireType)
			}
			m.DeleteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (LldpIdType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpChassisCapabilitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpChassisCapabilitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpChassisCapabilitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapType", wireType)
			}
			m.CapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapType |= (LldpCapType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CapEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfChassisSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfChassisSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfChassisSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChassisId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChassisId == nil {
				m.ChassisId = &LldpId{}
			}
			if err := m.ChassisId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysDescr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysDescr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtIP == nil {
				m.MgmtIP = &IPAddress{}
			}
			if err := m.MgmtIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capability = append(m.Capability, &LldpChassisCapabilitySpec{})
			if err := m.Capability[len(m.Capability)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfPortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfPortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfPortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortId == nil {
				m.PortId = &LldpId{}
			}
			if err := m.PortId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDescr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortDescr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			m.RouterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= (LldpProtoMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfChassisSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfChassisSpec == nil {
				m.LldpIfChassisSpec = &LldpIfChassisSpec{}
			}
			if err := m.LldpIfChassisSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfPortSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfPortSpec == nil {
				m.LldpIfPortSpec = &LldpIfPortSpec{}
			}
			if err := m.LldpIfPortSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfSpec == nil {
				m.LldpIfSpec = &LldpIfSpec{}
			}
			if err := m.LldpIfSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpNbrSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpNbrSpec == nil {
				m.LldpNbrSpec = &LldpIfSpec{}
			}
			if err := m.LldpNbrSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpSpec == nil {
				m.LldpSpec = &LldpSpec{}
			}
			if err := m.LldpSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkPCSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkPCSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkPCSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberIfBitmap", wireType)
			}
			m.MemberIfBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberIfBitmap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3IfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3IfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3IfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = append(m.VpcId[:0], dAtA[iNdEx:postIndex]...)
			if m.VpcId == nil {
				m.VpcId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &IPAddress{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (IfType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			m.AdminStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminStatus |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkSpec{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPCSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkPCSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkPCSpec{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3IfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3IfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_L3IfSpec{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_LoopbackIfSpec{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControlIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_ControlIfSpec{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_HostIfSpec{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMirrorSessionId = append(m.TxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.TxMirrorSessionId[len(m.TxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxMirrorSessionId = append(m.RxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.RxMirrorSessionId[len(m.RxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifId", wireType)
			}
			m.LifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LifId = append(m.LifId, make([]byte, postIndex-iNdEx))
			copy(m.LifId[len(m.LifId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			m.MacAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_UplinkIfStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_LoopbackIfStatus{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_HostIfStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfStats == nil {
				m.LldpIfStats = &LldpIfStats{}
			}
			if err := m.LldpIfStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkPCStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkPCStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkPCStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3IfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3IfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3IfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_UplinkIfStats{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkPCStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_UplinkPCStats{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3IfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3IfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_L3IfStats{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_LoopbackIfStats{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControlIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_ControlIfStats{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InterfaceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InterfaceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &InterfaceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &InterfaceSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &InterfaceStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Interface{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInterface
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInterface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (LifType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			m.MacAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedInterface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinnedInterface = append(m.PinnedInterface[:0], dAtA[iNdEx:postIndex]...)
			if m.PinnedInterface == nil {
				m.PinnedInterface = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			m.AdminState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminState |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (IfStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NhIndex", wireType)
			}
			m.NhIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NhIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &LifSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LifStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &LifStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Lif{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInterface   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("interface.proto", fileDescriptorInterface) }

var fileDescriptorInterface = []byte{
	// 2253 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xb7, 0x3e, 0x2c, 0xc9, 0x4f, 0x1f, 0x1e, 0xb7, 0x1d, 0xaf, 0x62, 0x52, 0x51, 0x6a, 0x96,
	0x4d, 0x79, 0x5d, 0xc1, 0x21, 0x0a, 0xbb, 0x2c, 0xc9, 0x66, 0x41, 0x33, 0x52, 0xe2, 0xa9, 0xd5,
	0xc7, 0x54, 0x4b, 0xce, 0x02, 0x17, 0xd7, 0x58, 0x6a, 0x25, 0x43, 0xa4, 0xd1, 0xa0, 0x19, 0x2f,
	0x36, 0x14, 0xe7, 0xbd, 0x73, 0xe2, 0xc0, 0x8d, 0x13, 0x27, 0x8a, 0xff, 0x81, 0x03, 0xdc, 0xf6,
	0x48, 0x71, 0x50, 0x41, 0x8e, 0xb9, 0xe1, 0x7f, 0x00, 0xaa, 0x3f, 0x66, 0xa6, 0x67, 0x24, 0xbc,
	0x89, 0x8b, 0x2a, 0x2e, 0x2e, 0xf5, 0xef, 0x7d, 0xbf, 0xd7, 0xef, 0x75, 0xf7, 0x18, 0x36, 0x6d,
	0xc7, 0x27, 0xf3, 0xb1, 0x35, 0x24, 0x87, 0xee, 0x7c, 0xe6, 0xcf, 0x50, 0xc6, 0x1d, 0x79, 0x7b,
	0x9b, 0x53, 0xe2, 0x5b, 0xf7, 0xe9, 0x1f, 0x8e, 0xee, 0x15, 0xfd, 0x0b, 0x97, 0x78, 0x7c, 0xa1,
	0xfe, 0x2b, 0x05, 0xc5, 0xf6, 0x64, 0xe4, 0x1a, 0xe3, 0xbe, 0x6f, 0xf9, 0x1e, 0xaa, 0x42, 0x7e,
	0x70, 0xae, 0xcf, 0xce, 0x1c, 0xbf, 0x9a, 0xba, 0x93, 0xda, 0x2f, 0xe3, 0x60, 0x49, 0x29, 0x58,
	0x50, 0xd2, 0x9c, 0x22, 0x96, 0xe8, 0x0e, 0x14, 0xf1, 0x79, 0xd3, 0xf6, 0x86, 0xd6, 0x7c, 0x44,
	0x46, 0xd5, 0x0c, 0xa3, 0xca, 0x10, 0xba, 0x0b, 0x15, 0x7c, 0x7e, 0xec, 0xcc, 0xc9, 0x70, 0xf6,
	0xc2, 0xb1, 0x7f, 0x49, 0x46, 0xd5, 0x2c, 0x63, 0x4a, 0xa0, 0x54, 0x53, 0xe3, 0x05, 0x99, 0x9d,
	0xf9, 0xdc, 0xce, 0x3a, 0xd7, 0x24, 0x41, 0x94, 0xc3, 0x70, 0x3c, 0x32, 0x17, 0x1c, 0x39, 0xce,
	0x21, 0x41, 0x94, 0xa3, 0x49, 0x26, 0xc4, 0x27, 0x9c, 0x23, 0xcf, 0x39, 0x24, 0x48, 0xd5, 0x21,
	0xc7, 0x42, 0x1e, 0xa1, 0xf7, 0x21, 0x3b, 0xb8, 0x70, 0x09, 0x0b, 0xb5, 0x52, 0xdf, 0x3c, 0x74,
	0x47, 0xde, 0x21, 0x27, 0x51, 0x18, 0x33, 0x22, 0xda, 0x81, 0xf5, 0xe7, 0xd6, 0xe4, 0x8c, 0xb0,
	0xb0, 0x4b, 0x98, 0x2f, 0xd4, 0x17, 0x70, 0x93, 0x72, 0xea, 0x2f, 0x2d, 0xcf, 0xb3, 0x3d, 0xdd,
	0x72, 0xad, 0x53, 0x7b, 0x62, 0xfb, 0x17, 0x7d, 0x97, 0x0c, 0xd1, 0x01, 0xe4, 0x75, 0xcb, 0x95,
	0x54, 0x2b, 0xa1, 0x6a, 0x81, 0xe3, 0x80, 0x01, 0xdd, 0x06, 0xd0, 0x2d, 0xb7, 0xe5, 0x58, 0xa7,
	0x13, 0x32, 0x62, 0x36, 0x0a, 0x58, 0x42, 0xd4, 0x45, 0x0a, 0xb6, 0x78, 0x85, 0x84, 0x2d, 0x66,
	0xa1, 0x0a, 0xf9, 0xfe, 0x85, 0xd7, 0xb5, 0xa6, 0xdc, 0xc2, 0x06, 0x0e, 0x96, 0xe8, 0x43, 0xd8,
	0x10, 0x8c, 0x06, 0x57, 0x57, 0xac, 0x17, 0xa5, 0xc0, 0x70, 0x44, 0x45, 0x7b, 0x50, 0xe8, 0x5f,
	0x78, 0x4d, 0xe2, 0x0d, 0xe7, 0xac, 0x6a, 0x1b, 0x38, 0x5c, 0xa3, 0x7d, 0xc8, 0x75, 0x5e, 0x4c,
	0x7d, 0xc3, 0x64, 0xa5, 0x2a, 0xd6, 0x95, 0x43, 0xbe, 0x6d, 0x0c, 0xb3, 0x31, 0x1a, 0xcd, 0x89,
	0xe7, 0x61, 0x41, 0x47, 0x9f, 0xb1, 0x00, 0x44, 0xf8, 0xd5, 0xf5, 0x3b, 0x99, 0xfd, 0x62, 0xfd,
	0x76, 0x14, 0xef, 0xaa, 0x04, 0x61, 0x49, 0x42, 0x25, 0x50, 0xe1, 0xf1, 0x99, 0xb3, 0xb9, 0xcf,
	0x82, 0x7b, 0x1f, 0x72, 0xf4, 0xb7, 0x31, 0x62, 0xb1, 0x25, 0xfc, 0x17, 0x24, 0x74, 0x0b, 0x36,
	0xe8, 0x2f, 0xee, 0x7d, 0x9a, 0x79, 0x1f, 0x01, 0x48, 0x81, 0xcc, 0xc0, 0x9f, 0x88, 0xbd, 0x48,
	0x7f, 0xaa, 0xff, 0x4e, 0x01, 0x88, 0x9d, 0x4e, 0x6d, 0xec, 0x42, 0xce, 0x18, 0x4b, 0xf9, 0x13,
	0x2b, 0x9a, 0x13, 0x3c, 0x3b, 0xf3, 0xc9, 0x5c, 0x64, 0xaf, 0x8c, 0xc3, 0x35, 0xda, 0x87, 0x75,
	0x93, 0x76, 0x0d, 0x53, 0x5b, 0xa9, 0xa3, 0xd0, 0x2d, 0x86, 0x76, 0x66, 0x23, 0x82, 0x39, 0x03,
	0x35, 0xdf, 0x78, 0x41, 0xc4, 0x2e, 0xa7, 0x3f, 0x51, 0x73, 0x45, 0x15, 0xd9, 0x06, 0x2f, 0xd6,
	0x77, 0xa3, 0xf0, 0x64, 0x2a, 0x5e, 0x51, 0xf6, 0xc7, 0xc9, 0x5c, 0xb1, 0x0e, 0x28, 0xd6, 0xb7,
	0x25, 0x15, 0x01, 0x09, 0x27, 0x58, 0x55, 0x07, 0x0a, 0x14, 0x61, 0x8a, 0xee, 0xcb, 0xc9, 0x10,
	0x69, 0x96, 0xf6, 0xff, 0x98, 0x57, 0x49, 0xca, 0xd7, 0x03, 0x3e, 0x27, 0xba, 0xa7, 0x73, 0x26,
	0x91, 0x5e, 0x2d, 0x21, 0xf3, 0xa8, 0x5f, 0xa5, 0x00, 0x8e, 0xdd, 0x89, 0xed, 0xbc, 0x12, 0x4d,
	0x21, 0x57, 0xb5, 0xa4, 0xa1, 0xcb, 0x45, 0xad, 0x42, 0xe7, 0xd2, 0xa3, 0xa9, 0xe5, 0x8c, 0x2c,
	0x7f, 0x36, 0xbf, 0x08, 0x8b, 0xab, 0x42, 0xa9, 0x6b, 0xf9, 0xf6, 0x97, 0xe4, 0xf9, 0xc4, 0x72,
	0xc2, 0x4a, 0xc4, 0x30, 0xf4, 0x61, 0x14, 0x0e, 0x2b, 0x48, 0xb1, 0x5e, 0x0e, 0xdd, 0x61, 0xce,
	0x84, 0x64, 0xf5, 0xa7, 0x50, 0xe2, 0x8e, 0x98, 0x3a, 0x73, 0xe5, 0x2e, 0x54, 0x3a, 0x64, 0x7a,
	0x4a, 0xe6, 0xc6, 0x58, 0xb3, 0xfd, 0xa9, 0xe5, 0x32, 0x97, 0xb2, 0x38, 0x81, 0xbe, 0x8d, 0x1b,
	0xea, 0x3f, 0x53, 0x50, 0x68, 0x3f, 0x14, 0x59, 0xda, 0x87, 0xf5, 0xe7, 0xee, 0xf0, 0xca, 0x10,
	0x39, 0x03, 0x7a, 0x0c, 0x39, 0x73, 0x4e, 0xc6, 0xf6, 0x79, 0x98, 0xca, 0xa0, 0xbf, 0x38, 0xfc,
	0x5f, 0xd2, 0xc3, 0x68, 0x52, 0x2a, 0x33, 0x6f, 0x91, 0xca, 0xf5, 0x96, 0x33, 0xb4, 0x5c, 0xd1,
	0xc7, 0x25, 0x61, 0x87, 0x61, 0x98, 0x93, 0xe8, 0x0c, 0xea, 0x34, 0x74, 0xd1, 0xd8, 0x6c, 0x57,
	0x66, 0xb1, 0x84, 0xa8, 0x1d, 0xa8, 0xb4, 0x67, 0x33, 0xf7, 0xd4, 0x1a, 0xbe, 0x12, 0x81, 0x46,
	0xee, 0xa7, 0xde, 0xd9, 0x7d, 0xf5, 0xb7, 0x29, 0x28, 0xeb, 0x33, 0xc7, 0x9f, 0xcf, 0x26, 0xff,
	0x03, 0x75, 0x09, 0xef, 0xd3, 0x49, 0xef, 0xe9, 0x34, 0x7e, 0x66, 0xf9, 0xe4, 0x17, 0xd6, 0x85,
	0xd8, 0x27, 0xcb, 0xb3, 0x2c, 0x60, 0x50, 0x4b, 0x00, 0x47, 0x33, 0xcf, 0xe7, 0x6e, 0xa9, 0x7f,
	0xcc, 0x43, 0xd9, 0x08, 0x0e, 0x55, 0xe6, 0xa8, 0x0a, 0xe9, 0x2b, 0xab, 0x9b, 0x36, 0x46, 0xe8,
	0x89, 0x38, 0x55, 0xd2, 0x6c, 0x4a, 0xf0, 0xe1, 0x65, 0x8c, 0x29, 0xa4, 0xdd, 0xba, 0x5c, 0xd4,
	0xaa, 0x71, 0x91, 0x7b, 0xf6, 0x74, 0x7a, 0xe6, 0xd3, 0x59, 0x2f, 0xce, 0x9b, 0xfb, 0x50, 0x6c,
	0x8c, 0xa6, 0xb6, 0x43, 0x0f, 0xe4, 0x33, 0x4f, 0xcc, 0x9a, 0xb2, 0xd0, 0xc2, 0x41, 0x2c, 0x73,
	0xa0, 0x89, 0xdc, 0x66, 0xa2, 0xcc, 0xbc, 0x33, 0x23, 0x58, 0xfb, 0xc1, 0xe5, 0xa2, 0xf6, 0x11,
	0xb3, 0x3c, 0x9c, 0x39, 0x9e, 0x3f, 0xb7, 0x6c, 0xc7, 0xf7, 0x9e, 0xfc, 0x2a, 0x16, 0xdd, 0x21,
	0xb5, 0xff, 0xe4, 0x89, 0xf1, 0xf4, 0x64, 0xf0, 0x13, 0xb3, 0x75, 0x72, 0x6c, 0xb6, 0x8d, 0xee,
	0xe7, 0xbf, 0x3e, 0x5a, 0xc3, 0x72, 0x1b, 0x9f, 0xc5, 0x7b, 0x49, 0xcc, 0xb0, 0x2d, 0xc9, 0x1e,
	0x27, 0x68, 0x9f, 0x5e, 0x2e, 0x6a, 0x9f, 0x5c, 0xc7, 0xe2, 0x89, 0xa9, 0x53, 0xa3, 0xf1, 0x96,
	0x3d, 0x8d, 0xba, 0x4c, 0xcc, 0x3c, 0xd1, 0xed, 0x02, 0xd4, 0x3e, 0xba, 0x5c, 0xd4, 0x1e, 0xbc,
	0x9b, 0xb9, 0xf6, 0x43, 0x6a, 0x27, 0xea, 0xde, 0x8b, 0xe4, 0x36, 0x67, 0xb7, 0x87, 0x70, 0xba,
	0xc6, 0x48, 0xda, 0xa3, 0xcb, 0x45, 0xed, 0xe3, 0x77, 0xb4, 0xd7, 0xeb, 0x99, 0x5a, 0x43, 0xff,
	0xfc, 0x68, 0x0d, 0x27, 0xfb, 0xe9, 0x2c, 0xd1, 0x11, 0xd5, 0x02, 0xb3, 0xcc, 0x8f, 0x98, 0x18,
	0xe5, 0x3a, 0x95, 0xd4, 0x7b, 0xdd, 0x01, 0xee, 0xb5, 0x8f, 0xd6, 0x70, 0xa2, 0xef, 0x6c, 0x79,
	0xbb, 0x57, 0x37, 0xa4, 0xad, 0x13, 0xc1, 0xda, 0xc7, 0x97, 0x8b, 0x5a, 0xfd, 0xdd, 0x0c, 0x1e,
	0xf5, 0xfa, 0x03, 0xba, 0x6f, 0x22, 0x2d, 0xe8, 0x1e, 0x6c, 0x0d, 0xce, 0x3b, 0xf6, 0x7c, 0x3e,
	0x9b, 0xf7, 0x89, 0xe7, 0xd9, 0x33, 0x3a, 0x50, 0xe1, 0x4e, 0x66, 0xbf, 0x84, 0x97, 0x09, 0x94,
	0x1b, 0x2f, 0x71, 0x17, 0x39, 0xf7, 0x12, 0x41, 0x2b, 0x40, 0xce, 0x1e, 0xdb, 0xce, 0x78, 0xa6,
	0xde, 0x85, 0x0a, 0xdf, 0x36, 0x41, 0xab, 0xd0, 0xeb, 0x5b, 0xdb, 0x1e, 0x8b, 0xa6, 0x2d, 0x63,
	0xbe, 0x50, 0xef, 0x82, 0x22, 0x55, 0x80, 0x73, 0x22, 0xc8, 0x3a, 0xd1, 0x85, 0x80, 0xfd, 0x56,
	0x5f, 0x41, 0x49, 0xc4, 0xb0, 0xa4, 0x8d, 0xfa, 0xc2, 0x17, 0x6c, 0x02, 0x59, 0xc3, 0xe4, 0x04,
	0x0a, 0x11, 0xf4, 0x01, 0xe4, 0xae, 0xea, 0x66, 0x41, 0x54, 0x7f, 0x9f, 0x86, 0xcd, 0x28, 0xab,
	0xdc, 0x60, 0x15, 0xf2, 0xc6, 0xd8, 0x70, 0x46, 0xe4, 0x3c, 0xb8, 0x90, 0x8b, 0x25, 0xfa, 0x0e,
	0x40, 0xcf, 0x25, 0x73, 0xa1, 0x38, 0xbd, 0x4a, 0xb1, 0xc4, 0x80, 0x9e, 0x24, 0x33, 0x23, 0x86,
	0xe1, 0xb6, 0xd4, 0xb9, 0x01, 0x89, 0x6e, 0xd0, 0x44, 0x1a, 0xf5, 0xe5, 0x84, 0x89, 0x51, 0x73,
	0x23, 0xd9, 0x1d, 0x81, 0x8a, 0xe5, 0x0c, 0x7f, 0x3f, 0x9e, 0xcd, 0xd8, 0xec, 0x90, 0x09, 0xb4,
	0xfb, 0xe5, 0xb5, 0x06, 0x50, 0xb0, 0xc7, 0x1e, 0xcf, 0x92, 0x0e, 0x65, 0xd9, 0x37, 0x0f, 0xd5,
	0x63, 0x4f, 0x18, 0x71, 0x82, 0x28, 0xf2, 0xd5, 0x84, 0xe2, 0x58, 0x66, 0x52, 0x37, 0x03, 0x25,
	0xa6, 0xce, 0x81, 0x22, 0x6c, 0xb0, 0x39, 0xc0, 0x16, 0x5b, 0xb0, 0x19, 0xf7, 0xdd, 0x53, 0x15,
	0xa8, 0x44, 0xad, 0xc3, 0x90, 0x3f, 0xa7, 0xa1, 0x12, 0xab, 0x96, 0x87, 0x1e, 0x25, 0x5c, 0x13,
	0xbe, 0xa0, 0xa5, 0x14, 0xd3, 0x08, 0x13, 0x51, 0x3c, 0x4a, 0x78, 0x24, 0xee, 0x05, 0x28, 0x3e,
	0x58, 0xe3, 0xb2, 0x02, 0x40, 0x87, 0x92, 0xf3, 0xa2, 0xac, 0x95, 0x68, 0x3a, 0x0a, 0x99, 0x88,
	0x05, 0xfd, 0x68, 0x29, 0x3e, 0x51, 0xcb, 0x9d, 0x15, 0xb5, 0xa4, 0xb2, 0x49, 0x76, 0xba, 0x9b,
	0xe2, 0xe9, 0x10, 0xb5, 0xdc, 0x4e, 0x0c, 0x2c, 0x21, 0x9f, 0x60, 0xd6, 0x36, 0x20, 0xcf, 0xeb,
	0xe9, 0xa9, 0x7f, 0x4d, 0xc3, 0x46, 0x98, 0x46, 0xf4, 0x18, 0x0a, 0x74, 0x92, 0x74, 0x88, 0x6f,
	0x89, 0xe4, 0x55, 0x0e, 0xd9, 0xdb, 0x35, 0x40, 0xb5, 0xcd, 0xaf, 0x17, 0xb5, 0xd4, 0x9b, 0x45,
	0x2d, 0x7f, 0xcf, 0x76, 0x26, 0xb6, 0x43, 0x70, 0x28, 0x80, 0x7e, 0x08, 0xf9, 0xde, 0xe9, 0xcf,
	0x98, 0x6c, 0x5a, 0x1c, 0x11, 0x4c, 0x56, 0x80, 0xda, 0xae, 0x10, 0x65, 0x87, 0xf6, 0xbd, 0xd9,
	0xd4, 0xf6, 0xc9, 0xd4, 0xf5, 0x2f, 0x70, 0x20, 0x85, 0x1e, 0x41, 0x56, 0xba, 0x4e, 0xf2, 0xd4,
	0xc7, 0xc6, 0x9c, 0x86, 0xa8, 0xb8, 0xe7, 0x92, 0xa1, 0x24, 0xce, 0x64, 0x90, 0x16, 0xf6, 0xb8,
	0x9c, 0xca, 0x44, 0x3b, 0x6b, 0x3b, 0x6f, 0x16, 0x35, 0x85, 0x6f, 0x64, 0x49, 0x83, 0x90, 0x44,
	0x9f, 0xc1, 0xfa, 0x72, 0x32, 0xe3, 0x7b, 0x4c, 0xdb, 0x7e, 0xb3, 0xa8, 0x6d, 0xb2, 0xd4, 0x49,
	0x0a, 0xb8, 0x98, 0xea, 0x82, 0x12, 0x72, 0x63, 0xf2, 0xf3, 0x33, 0xe2, 0xf9, 0x74, 0x6f, 0x68,
	0x96, 0x3f, 0x7c, 0xa9, 0xfb, 0xe7, 0x7e, 0xd8, 0x1b, 0xfc, 0xfe, 0x13, 0xe2, 0x38, 0x62, 0x41,
	0xf7, 0x20, 0x2f, 0x44, 0xab, 0x69, 0xf6, 0x96, 0x5b, 0x91, 0x06, 0x1c, 0xb0, 0xa8, 0x67, 0xb0,
	0x25, 0x59, 0xf4, 0xdc, 0x99, 0xe3, 0x11, 0x6a, 0xb2, 0xe1, 0xda, 0x22, 0x1b, 0xc1, 0x03, 0x98,
	0x9b, 0x0c, 0x71, 0x1c, 0xb1, 0xa0, 0xef, 0x42, 0x21, 0x90, 0x15, 0x36, 0x57, 0x26, 0x0f, 0x87,
	0x5c, 0xea, 0x07, 0xb0, 0x1d, 0x12, 0x9f, 0x11, 0x3f, 0x88, 0xb5, 0x22, 0x6e, 0x67, 0x74, 0x34,
	0xa7, 0x8d, 0x91, 0x3a, 0x87, 0x9d, 0x38, 0xdb, 0x35, 0x1d, 0x3c, 0x58, 0x72, 0xb0, 0x12, 0x77,
	0x50, 0x72, 0xed, 0xc7, 0xb0, 0x1b, 0xc2, 0xfc, 0xab, 0xc3, 0x75, 0x2b, 0xc1, 0xa3, 0x49, 0x87,
	0xd1, 0x18, 0xf0, 0xde, 0x92, 0xe6, 0xd5, 0x01, 0x65, 0xbe, 0x21, 0x20, 0xfa, 0x34, 0xcb, 0xb7,
	0x6d, 0x7e, 0x30, 0x57, 0xa2, 0x2b, 0x2d, 0xbb, 0xbe, 0xaa, 0xb1, 0xeb, 0x6b, 0x45, 0xa8, 0x69,
	0xdb, 0x63, 0xe9, 0x9b, 0x48, 0xfc, 0xc0, 0xcb, 0x2c, 0x1d, 0x78, 0xfb, 0xb0, 0x69, 0xda, 0x8e,
	0x43, 0x46, 0xa1, 0xc3, 0xac, 0x2b, 0x4a, 0x38, 0x09, 0xab, 0x7f, 0x48, 0xc1, 0x06, 0xf5, 0xe4,
	0x9b, 0x4e, 0x3b, 0x04, 0x59, 0xf6, 0x5a, 0xe7, 0x2f, 0x7d, 0xf6, 0x9b, 0x9e, 0x80, 0xe1, 0x3d,
	0x98, 0xac, 0x3e, 0x5a, 0x25, 0x06, 0xe9, 0x14, 0xce, 0x5e, 0x71, 0x0a, 0x53, 0x1f, 0xba, 0x2f,
	0xb9, 0x0f, 0xfc, 0x03, 0x54, 0xb0, 0x54, 0x01, 0x0a, 0xc2, 0x55, 0x4f, 0xfd, 0x53, 0x1a, 0x32,
	0x6d, 0x7b, 0xfc, 0x7f, 0x1e, 0x58, 0xdf, 0x8b, 0x0d, 0xac, 0x12, 0x9f, 0xde, 0xbc, 0xae, 0x57,
	0x8c, 0xaa, 0x4f, 0x13, 0xa3, 0xaa, 0x12, 0xca, 0xbd, 0xcd, 0x90, 0xfa, 0x24, 0x3e, 0xa4, 0xca,
	0xb2, 0xf0, 0xd5, 0xe3, 0xa9, 0x06, 0xe5, 0xb6, 0x3d, 0xbe, 0xa2, 0x5f, 0xc7, 0x50, 0x09, 0x18,
	0xae, 0xd9, 0xa9, 0xdf, 0x5e, 0xea, 0xd4, 0x42, 0xe0, 0x5f, 0xd4, 0xa3, 0x07, 0xbf, 0x49, 0x41,
	0x8e, 0xbf, 0xc8, 0x90, 0x02, 0xa5, 0xe0, 0xd2, 0xda, 0xed, 0x75, 0x5b, 0xca, 0x1a, 0x42, 0x50,
	0x89, 0xbf, 0x47, 0x94, 0x14, 0xba, 0x01, 0x5b, 0x4b, 0x6f, 0x14, 0x25, 0x8d, 0x2a, 0x00, 0xd1,
	0x5b, 0x42, 0xc9, 0xa0, 0x1d, 0x50, 0x92, 0x77, 0x7d, 0x25, 0x8b, 0xb6, 0x61, 0x33, 0x71, 0x11,
	0x57, 0xd6, 0x65, 0xbb, 0xf4, 0xb2, 0xac, 0xe4, 0x0e, 0x9a, 0x50, 0x90, 0xae, 0xa2, 0xd4, 0x87,
	0xfe, 0xa0, 0x31, 0x38, 0xee, 0x07, 0x7e, 0x71, 0x09, 0x81, 0x1d, 0x9b, 0x4a, 0x2a, 0xce, 0xd5,
	0xec, 0x7d, 0xd1, 0x55, 0xd2, 0x07, 0x7f, 0x0f, 0x3e, 0x73, 0xb1, 0x4f, 0x98, 0xe8, 0x3d, 0xd8,
	0x6e, 0xb7, 0x9b, 0xa6, 0xd1, 0x3c, 0xe9, 0x1f, 0x6b, 0x72, 0x94, 0x37, 0xe1, 0x46, 0x82, 0x60,
	0x3c, 0xed, 0x36, 0x3a, 0x2d, 0x25, 0x85, 0xf6, 0x60, 0x77, 0x89, 0xd4, 0x68, 0x1b, 0x8d, 0xbe,
	0x92, 0x46, 0x55, 0xd8, 0x49, 0xd0, 0xda, 0x3d, 0xbd, 0xd1, 0x56, 0x32, 0x68, 0x17, 0x50, 0x82,
	0xd2, 0x69, 0xe8, 0x4a, 0x96, 0xa6, 0x2e, 0xa9, 0xcd, 0x54, 0xd6, 0x57, 0x38, 0x66, 0xf6, 0xf0,
	0x40, 0xc9, 0xad, 0xb0, 0xae, 0x1f, 0x35, 0xfa, 0x7d, 0xa3, 0xaf, 0xe4, 0x0f, 0x7e, 0x97, 0x82,
	0x72, 0xec, 0x7b, 0x1b, 0x4d, 0x01, 0xe5, 0x3e, 0xe9, 0xf4, 0x9a, 0x72, 0x01, 0x23, 0x8c, 0xfe,
	0x52, 0x52, 0xb4, 0x06, 0x11, 0xa6, 0x37, 0xcd, 0xe7, 0x0f, 0x94, 0xf4, 0x32, 0x58, 0x57, 0x32,
	0x68, 0x0b, 0xca, 0x11, 0xd8, 0x6a, 0x9a, 0x4a, 0x36, 0x0e, 0x3d, 0x6d, 0x52, 0xf7, 0x63, 0xa2,
	0xfd, 0x5e, 0xb7, 0x63, 0x2a, 0xb9, 0x83, 0xbf, 0x89, 0x8f, 0xe9, 0xc1, 0xa7, 0x5d, 0x91, 0x92,
	0x13, 0xbd, 0x61, 0xb2, 0x40, 0x7a, 0x83, 0xa3, 0x16, 0x8e, 0x72, 0x1f, 0xe2, 0xb8, 0x65, 0xb6,
	0x1a, 0x83, 0x16, 0x56, 0x52, 0x41, 0x5a, 0x42, 0x92, 0x86, 0x8d, 0xe6, 0xb3, 0x96, 0x92, 0x5e,
	0x22, 0xe0, 0xde, 0x31, 0x95, 0xc8, 0x04, 0xf9, 0x0d, 0x09, 0x5f, 0xb4, 0x1b, 0x5d, 0x25, 0x1b,
	0xa4, 0x31, 0x84, 0x07, 0xad, 0x76, 0xcb, 0x3c, 0xa2, 0x09, 0x5a, 0x5f, 0xd2, 0xd5, 0xec, 0xe9,
	0x34, 0xbf, 0xb9, 0xa0, 0xba, 0x21, 0x81, 0x6e, 0x2d, 0xa3, 0xd7, 0x55, 0xf2, 0xf5, 0xaf, 0x32,
	0xb0, 0x6e, 0x8c, 0xfb, 0x5f, 0xd2, 0x7b, 0x4e, 0xf4, 0x46, 0xd1, 0xe7, 0x84, 0x0e, 0xd6, 0x1b,
	0x89, 0xc3, 0x90, 0x77, 0xf7, 0xde, 0x6e, 0x12, 0x16, 0x27, 0xe4, 0x5a, 0x4c, 0xc7, 0xb1, 0x3b,
	0xba, 0x96, 0x8e, 0xae, 0xa4, 0x83, 0x9f, 0x86, 0xe8, 0x5b, 0x71, 0xe6, 0xd8, 0xe9, 0xbb, 0x77,
	0x6b, 0x35, 0x31, 0xd4, 0xd7, 0x82, 0x92, 0x7c, 0x57, 0x40, 0xd5, 0x38, 0x7f, 0x34, 0xb5, 0xf6,
	0x6e, 0xae, 0xa0, 0x84, 0x6a, 0x1e, 0x42, 0x8e, 0x8f, 0x30, 0x84, 0x82, 0xc1, 0x23, 0x89, 0x6e,
	0xc7, 0xb0, 0x50, 0xe8, 0x80, 0x0d, 0x46, 0xfe, 0x4c, 0x21, 0x1e, 0xf1, 0xd1, 0x46, 0xf0, 0x85,
	0x6a, 0xb4, 0x17, 0x7e, 0xb0, 0xa3, 0x93, 0x54, 0x5d, 0xd3, 0x4a, 0x7f, 0x79, 0x7d, 0x3b, 0xf5,
	0xf5, 0xeb, 0xdb, 0xa9, 0x7f, 0xbc, 0xbe, 0x9d, 0x3a, 0xcd, 0xb1, 0x7f, 0xe3, 0x3c, 0xfc, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x99, 0x2a, 0xa8, 0xb3, 0xfc, 0x19, 0x00, 0x00,
}
