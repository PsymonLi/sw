// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MemoryProfile int32

const (
	MemoryProfile_MEMORY_PROFILE_DEFAULT MemoryProfile = 0
)

var MemoryProfile_name = map[int32]string{
	0: "MEMORY_PROFILE_DEFAULT",
}
var MemoryProfile_value = map[string]int32{
	"MEMORY_PROFILE_DEFAULT": 0,
}

func (x MemoryProfile) String() string {
	return proto.EnumName(MemoryProfile_name, int32(x))
}
func (MemoryProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

type DeviceProfile int32

const (
	DeviceProfile_DEVICE_PROFILE_DEFAULT DeviceProfile = 0
	DeviceProfile_DEVICE_PROFILE_2PF     DeviceProfile = 1
	DeviceProfile_DEVICE_PROFILE_3PF     DeviceProfile = 2
	DeviceProfile_DEVICE_PROFILE_4PF     DeviceProfile = 3
	DeviceProfile_DEVICE_PROFILE_5PF     DeviceProfile = 4
	DeviceProfile_DEVICE_PROFILE_6PF     DeviceProfile = 5
	DeviceProfile_DEVICE_PROFILE_7PF     DeviceProfile = 6
	DeviceProfile_DEVICE_PROFILE_8PF     DeviceProfile = 7
)

var DeviceProfile_name = map[int32]string{
	0: "DEVICE_PROFILE_DEFAULT",
	1: "DEVICE_PROFILE_2PF",
	2: "DEVICE_PROFILE_3PF",
	3: "DEVICE_PROFILE_4PF",
	4: "DEVICE_PROFILE_5PF",
	5: "DEVICE_PROFILE_6PF",
	6: "DEVICE_PROFILE_7PF",
	7: "DEVICE_PROFILE_8PF",
}
var DeviceProfile_value = map[string]int32{
	"DEVICE_PROFILE_DEFAULT": 0,
	"DEVICE_PROFILE_2PF":     1,
	"DEVICE_PROFILE_3PF":     2,
	"DEVICE_PROFILE_4PF":     3,
	"DEVICE_PROFILE_5PF":     4,
	"DEVICE_PROFILE_6PF":     5,
	"DEVICE_PROFILE_7PF":     6,
	"DEVICE_PROFILE_8PF":     7,
}

func (x DeviceProfile) String() string {
	return proto.EnumName(DeviceProfile_name, int32(x))
}
func (DeviceProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

type DeviceOperMode int32

const (
	DeviceOperMode_DEVICE_OPER_MODE_NONE DeviceOperMode = 0
	// /< bump-in-the-wire mode with workloads on uplink port(s)
	DeviceOperMode_DEVICE_OPER_MODE_BITW DeviceOperMode = 1
	// /< host path mode with workloads on pcie
	DeviceOperMode_DEVICE_OPER_MODE_HOST DeviceOperMode = 2
)

var DeviceOperMode_name = map[int32]string{
	0: "DEVICE_OPER_MODE_NONE",
	1: "DEVICE_OPER_MODE_BITW",
	2: "DEVICE_OPER_MODE_HOST",
}
var DeviceOperMode_value = map[string]int32{
	"DEVICE_OPER_MODE_NONE": 0,
	"DEVICE_OPER_MODE_BITW": 1,
	"DEVICE_OPER_MODE_HOST": 2,
}

func (x DeviceOperMode) String() string {
	return proto.EnumName(DeviceOperMode_name, int32(x))
}
func (DeviceOperMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

// device operational status
type DeviceState int32

const (
	DeviceState_SWITCH_STATE_NONE DeviceState = 0
	DeviceState_SWITCH_STATE_UP   DeviceState = 1
	DeviceState_SWITCH_STATE_DOWN DeviceState = 2
	DeviceState_SWITCH_STATE_ERR  DeviceState = 3
)

var DeviceState_name = map[int32]string{
	0: "SWITCH_STATE_NONE",
	1: "SWITCH_STATE_UP",
	2: "SWITCH_STATE_DOWN",
	3: "SWITCH_STATE_ERR",
}
var DeviceState_value = map[string]int32{
	"SWITCH_STATE_NONE": 0,
	"SWITCH_STATE_UP":   1,
	"SWITCH_STATE_DOWN": 2,
	"SWITCH_STATE_ERR":  3,
}

func (x DeviceState) String() string {
	return proto.EnumName(DeviceState_name, int32(x))
}
func (DeviceState) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

// device health status, multiple conditions can happen
type DeviceHealth int32

const (
	DeviceHealth_DEVICE_HEALTH_NONE            DeviceHealth = 0
	DeviceHealth_DEVICE_HEALTH_OK              DeviceHealth = 1
	DeviceHealth_DEVICE_HEALTH_SERVICE_DOWN    DeviceHealth = 2
	DeviceHealth_DEVICE_HEALTH_REBOOT_REQUIRED DeviceHealth = 3
	DeviceHealth_DEVICE_HEALTH_LOW_MEMORY      DeviceHealth = 4
	DeviceHealth_DEVICE_HEALTH_HARDWARE_ERROR  DeviceHealth = 5
)

var DeviceHealth_name = map[int32]string{
	0: "DEVICE_HEALTH_NONE",
	1: "DEVICE_HEALTH_OK",
	2: "DEVICE_HEALTH_SERVICE_DOWN",
	3: "DEVICE_HEALTH_REBOOT_REQUIRED",
	4: "DEVICE_HEALTH_LOW_MEMORY",
	5: "DEVICE_HEALTH_HARDWARE_ERROR",
}
var DeviceHealth_value = map[string]int32{
	"DEVICE_HEALTH_NONE":            0,
	"DEVICE_HEALTH_OK":              1,
	"DEVICE_HEALTH_SERVICE_DOWN":    2,
	"DEVICE_HEALTH_REBOOT_REQUIRED": 3,
	"DEVICE_HEALTH_LOW_MEMORY":      4,
	"DEVICE_HEALTH_HARDWARE_ERROR":  5,
}

func (x DeviceHealth) String() string {
	return proto.EnumName(DeviceHealth_name, int32(x))
}
func (DeviceHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

// device configuration
type DeviceSpec struct {
	// local IP address in the underlay (i.e. MyTEP IP or local TEP IP)
	IPAddr *IPAddress `protobuf:"bytes,1,opt,name=IPAddr" json:"IPAddr,omitempty"`
	// system MAC (NAPLES's system MAC will be used if not provided)
	MACAddr uint64 `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	// IP address of the gateway in the underlay
	GatewayIP *IPAddress `protobuf:"bytes,3,opt,name=GatewayIP" json:"GatewayIP,omitempty"`
	// operational mode of the device
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	DevOperMode DeviceOperMode `protobuf:"varint,4,opt,name=DevOperMode,proto3,enum=pds.DeviceOperMode" json:"DevOperMode,omitempty" meta:mandatory`
	// Memory Profile (only MEMORY_PROFILE_DEFAULT is supported)
	// NOTE: when a device profile is changed, it will take affect after next
	// reboot of NAPLES/DSC
	MemoryProfile MemoryProfile `protobuf:"varint,5,opt,name=MemoryProfile,proto3,enum=pds.MemoryProfile" json:"MemoryProfile,omitempty" meta:mandatory`
	// Device Profile
	DeviceProfile DeviceProfile `protobuf:"varint,6,opt,name=DeviceProfile,proto3,enum=pds.DeviceProfile" json:"DeviceProfile,omitempty" meta:mandatory`
	// if BridgingEn is true, L2 functionality based on MAC addresses kicks in
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	BridgingEn bool `protobuf:"varint,7,opt,name=BridgingEn,proto3" json:"BridgingEn,omitempty" meta:mandatory`
	// if LearningEn is true, MAC and IP learning is enabled
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	LearningEn bool `protobuf:"varint,8,opt,name=LearningEn,proto3" json:"LearningEn,omitempty" meta:mandatory`
	// LearnAgeTimeout is the aging timeout (in seconds) for learnt MAC or IP
	// addresses if LearningEn is set to true. If this is not set and learning is
	// enabled, default value is assumed for aging
	LearnAgeTimeout uint32 `protobuf:"varint,9,opt,name=LearnAgeTimeout,proto3" json:"LearnAgeTimeout,omitempty" meta:range:30-86400,meta:default=300`
	// enable the control plane stack for overlay routing
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	OverlayRoutingEn bool `protobuf:"varint,10,opt,name=OverlayRoutingEn,proto3" json:"OverlayRoutingEn,omitempty" meta:mandatory`
}

func (m *DeviceSpec) Reset()                    { *m = DeviceSpec{} }
func (m *DeviceSpec) String() string            { return proto.CompactTextString(m) }
func (*DeviceSpec) ProtoMessage()               {}
func (*DeviceSpec) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

func (m *DeviceSpec) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

func (m *DeviceSpec) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *DeviceSpec) GetGatewayIP() *IPAddress {
	if m != nil {
		return m.GatewayIP
	}
	return nil
}

func (m *DeviceSpec) GetDevOperMode() DeviceOperMode {
	if m != nil {
		return m.DevOperMode
	}
	return DeviceOperMode_DEVICE_OPER_MODE_NONE
}

func (m *DeviceSpec) GetMemoryProfile() MemoryProfile {
	if m != nil {
		return m.MemoryProfile
	}
	return MemoryProfile_MEMORY_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetDeviceProfile() DeviceProfile {
	if m != nil {
		return m.DeviceProfile
	}
	return DeviceProfile_DEVICE_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetBridgingEn() bool {
	if m != nil {
		return m.BridgingEn
	}
	return false
}

func (m *DeviceSpec) GetLearningEn() bool {
	if m != nil {
		return m.LearningEn
	}
	return false
}

func (m *DeviceSpec) GetLearnAgeTimeout() uint32 {
	if m != nil {
		return m.LearnAgeTimeout
	}
	return 0
}

func (m *DeviceSpec) GetOverlayRoutingEn() bool {
	if m != nil {
		return m.OverlayRoutingEn
	}
	return false
}

// operational status of the device, if any
type DeviceStatus struct {
	// operaional state of the device
	State DeviceState `protobuf:"varint,1,opt,name=State,proto3,enum=pds.DeviceState" json:"State,omitempty"`
	// System MAC address (can be used to uniquely identify the device in cluster)
	SystemMACAddress uint64 `protobuf:"varint,2,opt,name=SystemMACAddress,proto3" json:"SystemMACAddress,omitempty"`
	// serial number of the device
	SerialNumber string `protobuf:"bytes,3,opt,name=SerialNumber,proto3" json:"SerialNumber,omitempty"`
	// SKU/part numnber
	Sku string `protobuf:"bytes,4,opt,name=Sku,proto3" json:"Sku,omitempty"`
	// version of the firmware running
	FirmwareVersion string `protobuf:"bytes,5,opt,name=FirmwareVersion,proto3" json:"FirmwareVersion,omitempty"`
	// Memory Capacity
	Memory uint32 `protobuf:"varint,6,opt,name=Memory,proto3" json:"Memory,omitempty"`
	// Product Name
	ProductName string `protobuf:"bytes,7,opt,name=ProductName,proto3" json:"ProductName,omitempty"`
	// Manufacturing date
	ManufacturingDate string `protobuf:"bytes,8,opt,name=ManufacturingDate,proto3" json:"ManufacturingDate,omitempty"`
}

func (m *DeviceStatus) Reset()                    { *m = DeviceStatus{} }
func (m *DeviceStatus) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatus) ProtoMessage()               {}
func (*DeviceStatus) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

func (m *DeviceStatus) GetState() DeviceState {
	if m != nil {
		return m.State
	}
	return DeviceState_SWITCH_STATE_NONE
}

func (m *DeviceStatus) GetSystemMACAddress() uint64 {
	if m != nil {
		return m.SystemMACAddress
	}
	return 0
}

func (m *DeviceStatus) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *DeviceStatus) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *DeviceStatus) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *DeviceStatus) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DeviceStatus) GetManufacturingDate() string {
	if m != nil {
		return m.ManufacturingDate
	}
	return ""
}

// stats of the device, if any
type DeviceStatsEntry struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *DeviceStatsEntry) Reset()                    { *m = DeviceStatsEntry{} }
func (m *DeviceStatsEntry) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatsEntry) ProtoMessage()               {}
func (*DeviceStatsEntry) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

func (m *DeviceStatsEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceStatsEntry) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DeviceStats struct {
	Ingress []*DeviceStatsEntry `protobuf:"bytes,1,rep,name=Ingress" json:"Ingress,omitempty"`
	Egress  []*DeviceStatsEntry `protobuf:"bytes,2,rep,name=Egress" json:"Egress,omitempty"`
}

func (m *DeviceStats) Reset()                    { *m = DeviceStats{} }
func (m *DeviceStats) String() string            { return proto.CompactTextString(m) }
func (*DeviceStats) ProtoMessage()               {}
func (*DeviceStats) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

func (m *DeviceStats) GetIngress() []*DeviceStatsEntry {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *DeviceStats) GetEgress() []*DeviceStatsEntry {
	if m != nil {
		return m.Egress
	}
	return nil
}

// device object
type Device struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *DeviceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *DeviceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *DeviceStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

func (m *Device) GetSpec() *DeviceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Device) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Device) GetStats() *DeviceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// device create and update request
type DeviceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt  `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   *DeviceSpec `protobuf:"bytes,2,opt,name=Request" json:"Request,omitempty"`
}

func (m *DeviceRequest) Reset()                    { *m = DeviceRequest{} }
func (m *DeviceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceRequest) ProtoMessage()               {}
func (*DeviceRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{5} }

func (m *DeviceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *DeviceRequest) GetRequest() *DeviceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// device create and update response
type DeviceResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *DeviceStatus `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceResponse) Reset()                    { *m = DeviceResponse{} }
func (m *DeviceResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceResponse) ProtoMessage()               {}
func (*DeviceResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{6} }

func (m *DeviceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceResponse) GetResponse() *DeviceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// device get request
type DeviceGetRequest struct {
}

func (m *DeviceGetRequest) Reset()                    { *m = DeviceGetRequest{} }
func (m *DeviceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetRequest) ProtoMessage()               {}
func (*DeviceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{7} }

// device get response
type DeviceGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *Device   `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceGetResponse) Reset()                    { *m = DeviceGetResponse{} }
func (m *DeviceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetResponse) ProtoMessage()               {}
func (*DeviceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{8} }

func (m *DeviceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceGetResponse) GetResponse() *Device {
	if m != nil {
		return m.Response
	}
	return nil
}

// device delete request
type DeviceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
}

func (m *DeviceDeleteRequest) Reset()                    { *m = DeviceDeleteRequest{} }
func (m *DeviceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteRequest) ProtoMessage()               {}
func (*DeviceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{9} }

func (m *DeviceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

// device delete response
type DeviceDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *DeviceDeleteResponse) Reset()                    { *m = DeviceDeleteResponse{} }
func (m *DeviceDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteResponse) ProtoMessage()               {}
func (*DeviceDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{10} }

func (m *DeviceDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterType((*DeviceSpec)(nil), "pds.DeviceSpec")
	proto.RegisterType((*DeviceStatus)(nil), "pds.DeviceStatus")
	proto.RegisterType((*DeviceStatsEntry)(nil), "pds.DeviceStatsEntry")
	proto.RegisterType((*DeviceStats)(nil), "pds.DeviceStats")
	proto.RegisterType((*Device)(nil), "pds.Device")
	proto.RegisterType((*DeviceRequest)(nil), "pds.DeviceRequest")
	proto.RegisterType((*DeviceResponse)(nil), "pds.DeviceResponse")
	proto.RegisterType((*DeviceGetRequest)(nil), "pds.DeviceGetRequest")
	proto.RegisterType((*DeviceGetResponse)(nil), "pds.DeviceGetResponse")
	proto.RegisterType((*DeviceDeleteRequest)(nil), "pds.DeviceDeleteRequest")
	proto.RegisterType((*DeviceDeleteResponse)(nil), "pds.DeviceDeleteResponse")
	proto.RegisterEnum("pds.MemoryProfile", MemoryProfile_name, MemoryProfile_value)
	proto.RegisterEnum("pds.DeviceProfile", DeviceProfile_name, DeviceProfile_value)
	proto.RegisterEnum("pds.DeviceOperMode", DeviceOperMode_name, DeviceOperMode_value)
	proto.RegisterEnum("pds.DeviceState", DeviceState_name, DeviceState_value)
	proto.RegisterEnum("pds.DeviceHealth", DeviceHealth_name, DeviceHealth_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeviceSvc service

type DeviceSvcClient interface {
	DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error)
	DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error)
}

type deviceSvcClient struct {
	cc *grpc.ClientConn
}

func NewDeviceSvcClient(cc *grpc.ClientConn) DeviceSvcClient {
	return &deviceSvcClient{cc}
}

func (c *deviceSvcClient) DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error) {
	out := new(DeviceGetResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error) {
	out := new(DeviceDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DeviceSvc service

type DeviceSvcServer interface {
	DeviceCreate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceUpdate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error)
	DeviceDelete(context.Context, *DeviceDeleteRequest) (*DeviceDeleteResponse, error)
}

func RegisterDeviceSvcServer(s *grpc.Server, srv DeviceSvcServer) {
	s.RegisterService(&_DeviceSvc_serviceDesc, srv)
}

func _DeviceSvc_DeviceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceGet(ctx, req.(*DeviceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, req.(*DeviceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeviceSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.DeviceSvc",
	HandlerType: (*DeviceSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeviceCreate",
			Handler:    _DeviceSvc_DeviceCreate_Handler,
		},
		{
			MethodName: "DeviceUpdate",
			Handler:    _DeviceSvc_DeviceUpdate_Handler,
		},
		{
			MethodName: "DeviceGet",
			Handler:    _DeviceSvc_DeviceGet_Handler,
		},
		{
			MethodName: "DeviceDelete",
			Handler:    _DeviceSvc_DeviceDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "device.proto",
}

func (m *DeviceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.IPAddr.Size()))
		n1, err := m.IPAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MACAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.GatewayIP.Size()))
		n2, err := m.GatewayIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DevOperMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		dAtA[i] = 0x38
		i++
		if m.BridgingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearningEn {
		dAtA[i] = 0x40
		i++
		if m.LearningEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnAgeTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnAgeTimeout))
	}
	if m.OverlayRoutingEn {
		dAtA[i] = 0x50
		i++
		if m.OverlayRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeviceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.SystemMACAddress))
	}
	if len(m.SerialNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SerialNumber)))
		i += copy(dAtA[i:], m.SerialNumber)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.FirmwareVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareVersion)))
		i += copy(dAtA[i:], m.FirmwareVersion)
	}
	if m.Memory != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Memory))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.ManufacturingDate) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ManufacturingDate)))
		i += copy(dAtA[i:], m.ManufacturingDate)
	}
	return i, nil
}

func (m *DeviceStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DeviceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ObjMeta.Size()))
		n4, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Spec.Size()))
		n5, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Stats.Size()))
		n7, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n8, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Request.Size()))
		n9, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n10, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DeviceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeviceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n11, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DeviceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n12, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DeviceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DeviceSpec) Size() (n int) {
	var l int
	_ = l
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovDevice(uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		l = m.GatewayIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.DevOperMode != 0 {
		n += 1 + sovDevice(uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		n += 1 + sovDevice(uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		n += 1 + sovDevice(uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		n += 2
	}
	if m.LearningEn {
		n += 2
	}
	if m.LearnAgeTimeout != 0 {
		n += 1 + sovDevice(uint64(m.LearnAgeTimeout))
	}
	if m.OverlayRoutingEn {
		n += 2
	}
	return n
}

func (m *DeviceStatus) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDevice(uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		n += 1 + sovDevice(uint64(m.SystemMACAddress))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovDevice(uint64(m.Memory))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ManufacturingDate)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceStatsEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovDevice(uint64(m.Count))
	}
	return n
}

func (m *DeviceStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceGetRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeviceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	return n
}

func sovDevice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayIP == nil {
				m.GatewayIP = &IPAddress{}
			}
			if err := m.GatewayIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevOperMode", wireType)
			}
			m.DevOperMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevOperMode |= (DeviceOperMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryProfile", wireType)
			}
			m.MemoryProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryProfile |= (MemoryProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfile", wireType)
			}
			m.DeviceProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceProfile |= (DeviceProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BridgingEn = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearningEn = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnAgeTimeout", wireType)
			}
			m.LearnAgeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnAgeTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlayRoutingEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DeviceState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMACAddress", wireType)
			}
			m.SystemMACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemMACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManufacturingDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManufacturingDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &DeviceStatsEntry{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &DeviceStatsEntry{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DeviceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DeviceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeviceSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &DeviceStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Device{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("device.proto", fileDescriptorDevice) }

var fileDescriptorDevice = []byte{
	// 1194 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xd1, 0x72, 0xda, 0x46,
	0x14, 0x8d, 0x00, 0x83, 0xb9, 0xd8, 0x66, 0xbd, 0x76, 0x3c, 0x84, 0x49, 0x6d, 0xca, 0x74, 0x5a,
	0xea, 0x3a, 0x8e, 0x07, 0xa7, 0x49, 0x9a, 0xa4, 0xcd, 0x20, 0x23, 0x02, 0x53, 0xb0, 0xd4, 0x05,
	0xc7, 0xd3, 0x27, 0x46, 0x81, 0x35, 0x51, 0x0a, 0x92, 0x2a, 0xad, 0x9c, 0xf2, 0x03, 0xfd, 0x98,
	0xfe, 0x43, 0xa7, 0xaf, 0x7d, 0xcc, 0x4c, 0xdf, 0x99, 0x4e, 0xfa, 0x96, 0xc7, 0x7c, 0x41, 0x47,
	0x2b, 0x09, 0x24, 0x50, 0x3a, 0xd3, 0xbc, 0x78, 0xb4, 0xe7, 0x9e, 0x73, 0xf7, 0xee, 0xf5, 0xd9,
	0xbb, 0xc0, 0xc6, 0x90, 0x5e, 0x6b, 0x03, 0x7a, 0x6c, 0x5a, 0x06, 0x33, 0x70, 0xd2, 0x1c, 0xda,
	0x45, 0x18, 0x19, 0x23, 0xc3, 0x03, 0x8a, 0xf9, 0x09, 0x65, 0xea, 0x5d, 0xf7, 0x8f, 0x0f, 0xe4,
	0xd8, 0xd4, 0xa4, 0xb6, 0xb7, 0x28, 0xff, 0x93, 0x02, 0xa8, 0x73, 0x7d, 0xd7, 0xa4, 0x03, 0x5c,
	0x81, 0x74, 0x4b, 0xa9, 0x0d, 0x87, 0x56, 0x41, 0x28, 0x09, 0x95, 0x5c, 0x15, 0x1d, 0x7b, 0x64,
	0x0f, 0xa4, 0xb6, 0x4d, 0xfc, 0x38, 0x2e, 0x40, 0xa6, 0x53, 0x3b, 0xe3, 0xd4, 0x44, 0x49, 0xa8,
	0xa4, 0x48, 0xb0, 0xc4, 0xc7, 0x90, 0x7d, 0xa6, 0x32, 0xfa, 0x5a, 0x9d, 0xb6, 0x94, 0x42, 0xf2,
	0x03, 0x69, 0x16, 0x14, 0xdc, 0x82, 0x5c, 0x9d, 0x5e, 0xcb, 0x26, 0xb5, 0x3a, 0xc6, 0x90, 0x16,
	0x52, 0x25, 0xa1, 0xb2, 0x55, 0xdd, 0x39, 0x36, 0x87, 0xf6, 0xb1, 0x57, 0x59, 0x10, 0x12, 0xf1,
	0xfb, 0xd9, 0xc1, 0x96, 0x7b, 0x92, 0x47, 0x13, 0x55, 0x1f, 0xaa, 0xcc, 0xb0, 0xa6, 0x24, 0xac,
	0xc5, 0x6d, 0xd8, 0xec, 0xd0, 0x89, 0x61, 0x4d, 0x15, 0xcb, 0xb8, 0xd2, 0xc6, 0xb4, 0xb0, 0xc6,
	0x93, 0x61, 0x9e, 0x2c, 0x12, 0x89, 0xcd, 0x15, 0x15, 0xbb, 0xd9, 0xbc, 0x02, 0x82, 0x6c, 0xe9,
	0x50, 0xb6, 0x48, 0x24, 0x3e, 0x5b, 0x84, 0x82, 0xab, 0x00, 0xa2, 0xa5, 0x0d, 0x47, 0x9a, 0x3e,
	0x92, 0xf4, 0x42, 0xa6, 0x24, 0x54, 0xd6, 0x63, 0x65, 0x21, 0x96, 0xab, 0x69, 0x53, 0xd5, 0xd2,
	0x3d, 0xcd, 0xfa, 0x87, 0x35, 0x0b, 0x16, 0x26, 0x90, 0xe7, 0xab, 0xda, 0x88, 0xf6, 0xb4, 0x09,
	0x35, 0x1c, 0x56, 0xc8, 0x96, 0x84, 0xca, 0xa6, 0x58, 0x79, 0x3f, 0x3b, 0xf8, 0x8c, 0x0b, 0x2d,
	0x55, 0x1f, 0xd1, 0x47, 0xa7, 0x27, 0x77, 0x1e, 0xde, 0xbf, 0x77, 0x72, 0x72, 0xc4, 0xb1, 0x21,
	0xbd, 0x52, 0x9d, 0x31, 0xfb, 0xf6, 0xf4, 0xe4, 0x84, 0x2c, 0x27, 0xc0, 0xdf, 0x01, 0x92, 0xaf,
	0xa9, 0x35, 0x56, 0xa7, 0xc4, 0x70, 0x98, 0x57, 0x0d, 0x7c, 0xb0, 0x9a, 0x15, 0x6e, 0xf9, 0xb7,
	0x04, 0x6c, 0xf8, 0x2e, 0x63, 0x2a, 0x73, 0x6c, 0xfc, 0x39, 0xac, 0xb9, 0x5f, 0x94, 0xdb, 0x6c,
	0xab, 0x8a, 0x42, 0x2d, 0xe5, 0x38, 0xf1, 0xc2, 0xf8, 0x10, 0x50, 0x77, 0x6a, 0x33, 0x3a, 0xf1,
	0xcd, 0x45, 0x6d, 0xdb, 0xb7, 0xdb, 0x0a, 0x8e, 0xcb, 0xb0, 0xd1, 0xa5, 0x96, 0xa6, 0x8e, 0xcf,
	0x9d, 0xc9, 0x0b, 0x6a, 0x71, 0xeb, 0x65, 0x49, 0x04, 0xc3, 0x08, 0x92, 0xdd, 0x9f, 0x1c, 0xee,
	0xb1, 0x2c, 0x71, 0x3f, 0x71, 0x05, 0xf2, 0x0d, 0xcd, 0x9a, 0xbc, 0x56, 0x2d, 0xfa, 0x9c, 0x5a,
	0xb6, 0x66, 0xe8, 0xdc, 0x34, 0x59, 0xb2, 0x0c, 0xe3, 0x3d, 0x48, 0x7b, 0xfe, 0xe0, 0x3e, 0xd8,
	0x24, 0xfe, 0x0a, 0x97, 0x20, 0xa7, 0x58, 0xc6, 0xd0, 0x19, 0xb0, 0x73, 0x75, 0x42, 0xf9, 0x7f,
	0x36, 0x4b, 0xc2, 0x10, 0x3e, 0x82, 0xed, 0x8e, 0xaa, 0x3b, 0x57, 0xea, 0x80, 0x39, 0x96, 0xa6,
	0x8f, 0xea, 0xee, 0xc9, 0xd7, 0x39, 0x6f, 0x35, 0x50, 0x7e, 0x02, 0x68, 0xd1, 0x09, 0x5b, 0xd2,
	0x99, 0x35, 0xc5, 0x18, 0x52, 0x3c, 0xb9, 0xc0, 0x45, 0xfc, 0x1b, 0xef, 0xc2, 0xda, 0x99, 0xe1,
	0xe8, 0xcc, 0x6f, 0x88, 0xb7, 0x28, 0x4f, 0xf8, 0x6d, 0x0a, 0xd4, 0xf8, 0x2e, 0x64, 0x5a, 0xfa,
	0x88, 0xf7, 0x4d, 0x28, 0x25, 0x2b, 0xb9, 0xea, 0xcd, 0xa5, 0x56, 0x7b, 0x1b, 0x90, 0x80, 0x85,
	0xef, 0x40, 0x5a, 0x1a, 0xf9, 0x7d, 0xfe, 0x0f, 0xbe, 0x4f, 0x2a, 0xff, 0x9e, 0x80, 0xb4, 0x17,
	0xc4, 0x8f, 0x61, 0xbd, 0x37, 0x35, 0x69, 0x87, 0x32, 0xd5, 0x9f, 0x1e, 0x5b, 0xc7, 0x7c, 0xec,
	0x04, 0xa8, 0x98, 0x7f, 0x33, 0x3b, 0x10, 0xde, 0xcd, 0x0e, 0x32, 0x47, 0x9a, 0x3e, 0xd6, 0x74,
	0x4a, 0xe6, 0x02, 0xfc, 0x14, 0x32, 0xf2, 0x8b, 0x57, 0x5c, 0x9b, 0xe0, 0xda, 0x4d, 0x4f, 0xeb,
	0x83, 0xe2, 0x9e, 0x2f, 0xe5, 0x5e, 0x3b, 0x32, 0x26, 0x1a, 0xa3, 0x13, 0x93, 0x4d, 0x49, 0xa0,
	0xc2, 0x0f, 0x20, 0xe5, 0x4e, 0x30, 0x7f, 0xe0, 0xe4, 0xc3, 0x55, 0x9b, 0x74, 0x20, 0x62, 0x57,
	0x6b, 0x9b, 0x74, 0x10, 0xd2, 0x72, 0x01, 0x7e, 0x0a, 0x69, 0xcf, 0x94, 0xdc, 0x15, 0xb9, 0xea,
	0xf6, 0xd2, 0x81, 0x1d, 0x5b, 0xdc, 0x7d, 0x37, 0x3b, 0x40, 0x36, 0xff, 0x0e, 0xc9, 0x7d, 0x19,
	0x7e, 0xec, 0x79, 0xd9, 0xe6, 0xbe, 0xc9, 0xad, 0x78, 0xd9, 0x16, 0x77, 0xde, 0xcd, 0x0e, 0xf2,
	0xae, 0x3c, 0xac, 0xf6, 0x34, 0xe5, 0x57, 0xc1, 0x8c, 0x21, 0xf4, 0x67, 0x87, 0xda, 0xcc, 0x9d,
	0x9e, 0xa2, 0xca, 0x06, 0x2f, 0xcf, 0xd8, 0x2f, 0x6c, 0x69, 0x08, 0xcf, 0x71, 0xb2, 0xa0, 0xe0,
	0x2f, 0x21, 0xe3, 0x4b, 0xfd, 0xc6, 0x2d, 0x1f, 0x9d, 0x04, 0xf1, 0xb2, 0x01, 0x5b, 0xc1, 0x5e,
	0xb6, 0x69, 0xe8, 0x36, 0x75, 0x37, 0xab, 0x99, 0x9a, 0x7f, 0xfc, 0xe0, 0x2a, 0x7a, 0x9b, 0xcd,
	0x71, 0xb2, 0xa0, 0xe0, 0x3b, 0xb0, 0x1e, 0x68, 0xfd, 0xdd, 0x56, 0xbb, 0x45, 0xe6, 0x94, 0x32,
	0x0e, 0x9c, 0xfc, 0x8c, 0xb2, 0xa0, 0x88, 0x31, 0x6c, 0x87, 0xb0, 0x8f, 0xac, 0xe3, 0x8b, 0x95,
	0x3a, 0x72, 0xa1, 0x3a, 0x42, 0x15, 0x48, 0xb0, 0xe3, 0x61, 0x75, 0x3a, 0xa6, 0xec, 0x63, 0x9b,
	0x5c, 0x6e, 0xc0, 0x6e, 0x34, 0xcd, 0xc7, 0xd5, 0x7d, 0xf8, 0xd5, 0xd2, 0xfb, 0x84, 0x8b, 0xb0,
	0xd7, 0x91, 0x3a, 0x32, 0xf9, 0xb1, 0xaf, 0x10, 0xb9, 0xd1, 0x6a, 0x4b, 0xfd, 0xba, 0xd4, 0xa8,
	0x5d, 0xb4, 0x7b, 0xe8, 0xc6, 0xe1, 0x5f, 0xc2, 0xd2, 0xfb, 0xe3, 0xb2, 0xeb, 0xd2, 0xf3, 0xd6,
	0x99, 0xb4, 0xca, 0xc6, 0x7b, 0x80, 0x97, 0x62, 0x55, 0xa5, 0x81, 0x84, 0x18, 0xfc, 0x54, 0x69,
	0xa0, 0x44, 0x0c, 0x7e, 0x4f, 0x69, 0xa0, 0x64, 0x0c, 0xfe, 0xb5, 0xd2, 0x40, 0xa9, 0x18, 0xfc,
	0xbe, 0xd2, 0x40, 0x6b, 0x31, 0xf8, 0x03, 0xa5, 0x81, 0xd2, 0x31, 0xf8, 0x43, 0xa5, 0x81, 0x32,
	0x87, 0x6a, 0x60, 0xc2, 0xf9, 0xa3, 0x7d, 0x0b, 0x6e, 0xfa, 0x4c, 0x59, 0x91, 0x48, 0xbf, 0x23,
	0xd7, 0xa5, 0xfe, 0xb9, 0x7c, 0x2e, 0xa1, 0x1b, 0xb1, 0x21, 0xb1, 0xd5, 0xbb, 0x44, 0x42, 0x6c,
	0xa8, 0x29, 0x77, 0x7b, 0x28, 0x71, 0x78, 0x15, 0x1e, 0x81, 0x14, 0xdf, 0x84, 0xed, 0xee, 0x65,
	0xab, 0x77, 0xd6, 0xec, 0x77, 0x7b, 0xb5, 0xde, 0x3c, 0xf7, 0x0e, 0xe4, 0x23, 0xf0, 0x85, 0x82,
	0x84, 0x15, 0x6e, 0x5d, 0xbe, 0x3c, 0x47, 0x09, 0xbc, 0x0b, 0x28, 0x02, 0x4b, 0x84, 0xa0, 0xe4,
	0xe1, 0x1f, 0x42, 0xf0, 0xaa, 0x35, 0xa9, 0x3a, 0x66, 0x2f, 0x43, 0x67, 0x6e, 0x4a, 0xb5, 0x76,
	0xaf, 0x19, 0x6c, 0xb5, 0x0b, 0x28, 0x8a, 0xcb, 0xdf, 0x23, 0x01, 0xef, 0x43, 0x31, 0x8a, 0x76,
	0x25, 0xc2, 0x97, 0xfe, 0xa6, 0x9f, 0xc2, 0x27, 0xd1, 0x38, 0x91, 0x44, 0x59, 0xee, 0xf5, 0x89,
	0xf4, 0xc3, 0x45, 0x8b, 0x48, 0x75, 0x94, 0xc4, 0xb7, 0xa1, 0x10, 0xa5, 0xb4, 0xe5, 0xcb, 0xbe,
	0x67, 0x28, 0x94, 0xc2, 0x25, 0xb8, 0x1d, 0x8d, 0x36, 0x6b, 0xa4, 0x7e, 0x59, 0x23, 0xbc, 0x7e,
	0x99, 0xa0, 0xb5, 0xea, 0xaf, 0x09, 0xc8, 0xfa, 0xad, 0xba, 0x1e, 0xe0, 0x6f, 0x82, 0xe3, 0x9c,
	0x59, 0xd4, 0x6d, 0x5c, 0xf8, 0x87, 0x8e, 0x7f, 0x73, 0x8a, 0x3b, 0x11, 0xcc, 0xbf, 0x65, 0x37,
	0x16, 0xd2, 0x0b, 0x73, 0xf8, 0x3f, 0xa5, 0x4f, 0x82, 0x12, 0x9e, 0x51, 0x86, 0xc3, 0xaf, 0xcd,
	0x62, 0x68, 0x14, 0xf7, 0x96, 0xe1, 0xb9, 0x5a, 0x0a, 0x36, 0xf6, 0x6e, 0x26, 0x2e, 0x84, 0x98,
	0x91, 0x3b, 0x5f, 0xbc, 0x15, 0x13, 0x09, 0xd2, 0x88, 0x1b, 0x7f, 0xbe, 0xdd, 0x17, 0xde, 0xbc,
	0xdd, 0x17, 0xfe, 0x7e, 0xbb, 0x2f, 0xbc, 0x48, 0xf3, 0xdf, 0xc6, 0xa7, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x51, 0x9c, 0xc6, 0x3c, 0x5a, 0x0b, 0x00, 0x00,
}
