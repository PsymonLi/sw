// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MemoryProfile int32

const (
	MemoryProfile_MEMORY_PROFILE_DEFAULT MemoryProfile = 0
)

var MemoryProfile_name = map[int32]string{
	0: "MEMORY_PROFILE_DEFAULT",
}
var MemoryProfile_value = map[string]int32{
	"MEMORY_PROFILE_DEFAULT": 0,
}

func (x MemoryProfile) String() string {
	return proto.EnumName(MemoryProfile_name, int32(x))
}
func (MemoryProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

type DeviceProfile int32

const (
	DeviceProfile_DEVICE_PROFILE_DEFAULT DeviceProfile = 0
	DeviceProfile_DEVICE_PROFILE_2PF     DeviceProfile = 1
	DeviceProfile_DEVICE_PROFILE_3PF     DeviceProfile = 2
	DeviceProfile_DEVICE_PROFILE_4PF     DeviceProfile = 3
	DeviceProfile_DEVICE_PROFILE_5PF     DeviceProfile = 4
	DeviceProfile_DEVICE_PROFILE_6PF     DeviceProfile = 5
	DeviceProfile_DEVICE_PROFILE_7PF     DeviceProfile = 6
	DeviceProfile_DEVICE_PROFILE_8PF     DeviceProfile = 7
)

var DeviceProfile_name = map[int32]string{
	0: "DEVICE_PROFILE_DEFAULT",
	1: "DEVICE_PROFILE_2PF",
	2: "DEVICE_PROFILE_3PF",
	3: "DEVICE_PROFILE_4PF",
	4: "DEVICE_PROFILE_5PF",
	5: "DEVICE_PROFILE_6PF",
	6: "DEVICE_PROFILE_7PF",
	7: "DEVICE_PROFILE_8PF",
}
var DeviceProfile_value = map[string]int32{
	"DEVICE_PROFILE_DEFAULT": 0,
	"DEVICE_PROFILE_2PF":     1,
	"DEVICE_PROFILE_3PF":     2,
	"DEVICE_PROFILE_4PF":     3,
	"DEVICE_PROFILE_5PF":     4,
	"DEVICE_PROFILE_6PF":     5,
	"DEVICE_PROFILE_7PF":     6,
	"DEVICE_PROFILE_8PF":     7,
}

func (x DeviceProfile) String() string {
	return proto.EnumName(DeviceProfile_name, int32(x))
}
func (DeviceProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

type DeviceOperMode int32

const (
	DeviceOperMode_DEVICE_OPER_MODE_NONE DeviceOperMode = 0
	// /< bump-in-the-wire mode with workloads on uplink port(s)
	DeviceOperMode_DEVICE_OPER_MODE_BITW DeviceOperMode = 1
	// /< host path mode with workloads on pcie
	DeviceOperMode_DEVICE_OPER_MODE_HOST DeviceOperMode = 2
)

var DeviceOperMode_name = map[int32]string{
	0: "DEVICE_OPER_MODE_NONE",
	1: "DEVICE_OPER_MODE_BITW",
	2: "DEVICE_OPER_MODE_HOST",
}
var DeviceOperMode_value = map[string]int32{
	"DEVICE_OPER_MODE_NONE": 0,
	"DEVICE_OPER_MODE_BITW": 1,
	"DEVICE_OPER_MODE_HOST": 2,
}

func (x DeviceOperMode) String() string {
	return proto.EnumName(DeviceOperMode_name, int32(x))
}
func (DeviceOperMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

// device operational status
type DeviceState int32

const (
	DeviceState_SWITCH_STATE_NONE DeviceState = 0
	DeviceState_SWITCH_STATE_UP   DeviceState = 1
	DeviceState_SWITCH_STATE_DOWN DeviceState = 2
	DeviceState_SWITCH_STATE_ERR  DeviceState = 3
)

var DeviceState_name = map[int32]string{
	0: "SWITCH_STATE_NONE",
	1: "SWITCH_STATE_UP",
	2: "SWITCH_STATE_DOWN",
	3: "SWITCH_STATE_ERR",
}
var DeviceState_value = map[string]int32{
	"SWITCH_STATE_NONE": 0,
	"SWITCH_STATE_UP":   1,
	"SWITCH_STATE_DOWN": 2,
	"SWITCH_STATE_ERR":  3,
}

func (x DeviceState) String() string {
	return proto.EnumName(DeviceState_name, int32(x))
}
func (DeviceState) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

// device health status, multiple conditions can happen
type DeviceHealth int32

const (
	DeviceHealth_DEVICE_HEALTH_NONE            DeviceHealth = 0
	DeviceHealth_DEVICE_HEALTH_OK              DeviceHealth = 1
	DeviceHealth_DEVICE_HEALTH_SERVICE_DOWN    DeviceHealth = 2
	DeviceHealth_DEVICE_HEALTH_REBOOT_REQUIRED DeviceHealth = 3
	DeviceHealth_DEVICE_HEALTH_LOW_MEMORY      DeviceHealth = 4
	DeviceHealth_DEVICE_HEALTH_HARDWARE_ERROR  DeviceHealth = 5
)

var DeviceHealth_name = map[int32]string{
	0: "DEVICE_HEALTH_NONE",
	1: "DEVICE_HEALTH_OK",
	2: "DEVICE_HEALTH_SERVICE_DOWN",
	3: "DEVICE_HEALTH_REBOOT_REQUIRED",
	4: "DEVICE_HEALTH_LOW_MEMORY",
	5: "DEVICE_HEALTH_HARDWARE_ERROR",
}
var DeviceHealth_value = map[string]int32{
	"DEVICE_HEALTH_NONE":            0,
	"DEVICE_HEALTH_OK":              1,
	"DEVICE_HEALTH_SERVICE_DOWN":    2,
	"DEVICE_HEALTH_REBOOT_REQUIRED": 3,
	"DEVICE_HEALTH_LOW_MEMORY":      4,
	"DEVICE_HEALTH_HARDWARE_ERROR":  5,
}

func (x DeviceHealth) String() string {
	return proto.EnumName(DeviceHealth_name, int32(x))
}
func (DeviceHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

// device configuration
type DeviceSpec struct {
	// local IP address in the underlay (i.e. MyTEP IP or local TEP IP)
	IPAddr *IPAddress `protobuf:"bytes,1,opt,name=IPAddr" json:"IPAddr,omitempty"`
	// system MAC (NAPLES's system MAC will be used if not provided)
	MACAddr uint64 `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	// IP address of the gateway in the underlay
	GatewayIP *IPAddress `protobuf:"bytes,3,opt,name=GatewayIP" json:"GatewayIP,omitempty"`
	// operational mode of the device
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	DevOperMode DeviceOperMode `protobuf:"varint,4,opt,name=DevOperMode,proto3,enum=pds.DeviceOperMode" json:"DevOperMode,omitempty" meta:mandatory`
	// Memory Profile (only MEMORY_PROFILE_DEFAULT is supported)
	// NOTE: when a device profile is changed, it will take affect after next
	// reboot of NAPLES/DSC
	MemoryProfile MemoryProfile `protobuf:"varint,5,opt,name=MemoryProfile,proto3,enum=pds.MemoryProfile" json:"MemoryProfile,omitempty" meta:mandatory`
	// Device Profile
	DeviceProfile DeviceProfile `protobuf:"varint,6,opt,name=DeviceProfile,proto3,enum=pds.DeviceProfile" json:"DeviceProfile,omitempty" meta:mandatory`
	// if BridgingEn is true, L2 functionality based on MAC addresses kicks in
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	BridgingEn bool `protobuf:"varint,7,opt,name=BridgingEn,proto3" json:"BridgingEn,omitempty" meta:mandatory`
	// if LearningEn is true, MAC and IP learning is enabled
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	LearningEn bool `protobuf:"varint,8,opt,name=LearningEn,proto3" json:"LearningEn,omitempty" meta:mandatory`
	// LearnAgeTimeout is the aging timeout (in seconds) for learnt MAC or IP
	// addresses if LearningEn is set to true. If this is not set and learning is
	// enabled, default value is assumed for aging
	LearnAgeTimeout uint32 `protobuf:"varint,9,opt,name=LearnAgeTimeout,proto3" json:"LearnAgeTimeout,omitempty" meta:range:30-86400,meta:default=300`
	// priority of IP mapping entries (this priority, if configured, will be
	// used to break the tie in case both LPM/prefix and a mapping entry are
	// hit in the datapath (i.e., /32 IP mapping entry is also in some LPM
	// prefix)
	// NOTE:
	// 1. by default IP mapping always takes precedence over LPM hit and
	//    default value of this attribute is 0 (lower the numerical value,
	//    the higher the priority, hence 0 is the highest priority)
	// 2. valid priority value range is 0 to 1023
	// 3. if mapping and route are both hit and both have same priority,
	//    mapping result will take precedence over route (even if it is /32 route)
	// 4. if the value of this attribute is updated on the fly, it will not
	//    affect the flows/sessions that are already created, but it will take
	//    affect only on the new sessions/flows created after such an update
	IPMappingPriority uint32 `protobuf:"varint,10,opt,name=IPMappingPriority,proto3" json:"IPMappingPriority,omitempty" meta:range:0-1023`
	// firewal (if enabled) action trasnposition logic dictates how the policy
	// lookup results are processed when multiple security policies are applied
	// on a packet
	FwPolicyXposnScheme FwPolicyXposn `protobuf:"varint,11,opt,name=FwPolicyXposnScheme,proto3,enum=types.FwPolicyXposn" json:"FwPolicyXposnScheme,omitempty" meta:default=FW_POLICY_XPOSN_GLOBAL_PRIORITY`
	// enable the control plane stack for overlay routing
	// NOTE: when OverlayRoutingEn is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	OverlayRoutingEn bool `protobuf:"varint,12,opt,name=OverlayRoutingEn,proto3" json:"OverlayRoutingEn,omitempty" meta:mandatory`
	// when SymmetricRoutingEn is set to true, outgoing inter-subnet (encapped)
	// traffic carries VPC's VxLAN vnid and incoming inter-subnet (encapped)
	// traffic is expected to come with VPC's VxLAN vnid. If SymmetricRoutingEn is
	// set to false (default behavior), outgoing inter-subnet (encapped) traffic
	// carries egress subnet's VxLAN vnid and incoming inter-subnet (encapped)
	// traffic is expected to come with destination subnet's VxLAN vnid
	// NOTE: if the value of this attribute is updated on the fly, it will not
	//       affect the flows/sessions that are already created, but it will take
	//       affect only on the new sessions/flows created after such an update
	SymmetricRoutingEn bool `protobuf:"varint,13,opt,name=SymmetricRoutingEn,proto3" json:"SymmetricRoutingEn,omitempty" meta:default=false`
}

func (m *DeviceSpec) Reset()                    { *m = DeviceSpec{} }
func (m *DeviceSpec) String() string            { return proto.CompactTextString(m) }
func (*DeviceSpec) ProtoMessage()               {}
func (*DeviceSpec) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

func (m *DeviceSpec) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

func (m *DeviceSpec) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *DeviceSpec) GetGatewayIP() *IPAddress {
	if m != nil {
		return m.GatewayIP
	}
	return nil
}

func (m *DeviceSpec) GetDevOperMode() DeviceOperMode {
	if m != nil {
		return m.DevOperMode
	}
	return DeviceOperMode_DEVICE_OPER_MODE_NONE
}

func (m *DeviceSpec) GetMemoryProfile() MemoryProfile {
	if m != nil {
		return m.MemoryProfile
	}
	return MemoryProfile_MEMORY_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetDeviceProfile() DeviceProfile {
	if m != nil {
		return m.DeviceProfile
	}
	return DeviceProfile_DEVICE_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetBridgingEn() bool {
	if m != nil {
		return m.BridgingEn
	}
	return false
}

func (m *DeviceSpec) GetLearningEn() bool {
	if m != nil {
		return m.LearningEn
	}
	return false
}

func (m *DeviceSpec) GetLearnAgeTimeout() uint32 {
	if m != nil {
		return m.LearnAgeTimeout
	}
	return 0
}

func (m *DeviceSpec) GetIPMappingPriority() uint32 {
	if m != nil {
		return m.IPMappingPriority
	}
	return 0
}

func (m *DeviceSpec) GetFwPolicyXposnScheme() FwPolicyXposn {
	if m != nil {
		return m.FwPolicyXposnScheme
	}
	return FwPolicyXposn_FW_POLICY_XPOSN_NONE
}

func (m *DeviceSpec) GetOverlayRoutingEn() bool {
	if m != nil {
		return m.OverlayRoutingEn
	}
	return false
}

func (m *DeviceSpec) GetSymmetricRoutingEn() bool {
	if m != nil {
		return m.SymmetricRoutingEn
	}
	return false
}

// operational status of the device, if any
type DeviceStatus struct {
	// operational state of the device
	State DeviceState `protobuf:"varint,1,opt,name=State,proto3,enum=pds.DeviceState" json:"State,omitempty"`
	// system MAC address (can be used to uniquely identify the device in cluster)
	SystemMACAddress uint64 `protobuf:"varint,2,opt,name=SystemMACAddress,proto3" json:"SystemMACAddress,omitempty"`
	// serial number of the device
	SerialNumber string `protobuf:"bytes,3,opt,name=SerialNumber,proto3" json:"SerialNumber,omitempty"`
	// SKU/part numnber
	Sku string `protobuf:"bytes,4,opt,name=Sku,proto3" json:"Sku,omitempty"`
	// version of the firmware running
	FirmwareVersion string `protobuf:"bytes,5,opt,name=FirmwareVersion,proto3" json:"FirmwareVersion,omitempty"`
	// memory capacity
	Memory uint32 `protobuf:"varint,6,opt,name=Memory,proto3" json:"Memory,omitempty"`
	// product name
	ProductName string `protobuf:"bytes,7,opt,name=ProductName,proto3" json:"ProductName,omitempty"`
	// manufacturing date
	ManufacturingDate string `protobuf:"bytes,8,opt,name=ManufacturingDate,proto3" json:"ManufacturingDate,omitempty"`
	// device description
	Description string `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	// vendor identifier
	VendorID string `protobuf:"bytes,10,opt,name=VendorID,proto3" json:"VendorID,omitempty"`
	// chip type
	ChipType AsicType `protobuf:"varint,11,opt,name=ChipType,proto3,enum=types.AsicType" json:"ChipType,omitempty"`
	// hardware revision
	HardwareRevision string `protobuf:"bytes,12,opt,name=HardwareRevision,proto3" json:"HardwareRevision,omitempty"`
	// CPU vendor
	CpuVendor string `protobuf:"bytes,13,opt,name=CpuVendor,proto3" json:"CpuVendor,omitempty"`
	// CPU specification
	CpuSpecification string `protobuf:"bytes,14,opt,name=CpuSpecification,proto3" json:"CpuSpecification,omitempty"`
	// SoC OS version
	SocOSVersion string `protobuf:"bytes,15,opt,name=SocOSVersion,proto3" json:"SocOSVersion,omitempty"`
	// SoC disk size
	SocDiskSize string `protobuf:"bytes,16,opt,name=SocDiskSize,proto3" json:"SocDiskSize,omitempty"`
	// PCIe specification
	PCIeSpecification string `protobuf:"bytes,17,opt,name=PCIeSpecification,proto3" json:"PCIeSpecification,omitempty"`
	// PCIe bus information
	PCIeBusInfo string `protobuf:"bytes,18,opt,name=PCIeBusInfo,proto3" json:"PCIeBusInfo,omitempty"`
	// number of PCIe ports
	NumPCIePorts uint32 `protobuf:"varint,19,opt,name=NumPCIePorts,proto3" json:"NumPCIePorts,omitempty"`
	// Number of uplink ports
	NumPorts uint32 `protobuf:"varint,20,opt,name=NumPorts,proto3" json:"NumPorts,omitempty"`
	// vendor name
	VendorName string `protobuf:"bytes,21,opt,name=VendorName,proto3" json:"VendorName,omitempty"`
	// PXE version
	PXEVersion float32 `protobuf:"fixed32,22,opt,name=PXEVersion,proto3" json:"PXEVersion,omitempty"`
	// UEFI version
	UEFIVersion float32 `protobuf:"fixed32,23,opt,name=UEFIVersion,proto3" json:"UEFIVersion,omitempty"`
	// number of host interfaces
	NumHostIf uint32 `protobuf:"varint,24,opt,name=NumHostIf,proto3" json:"NumHostIf,omitempty"`
	// version of the firmware running
	FirmwareDescription string `protobuf:"bytes,26,opt,name=FirmwareDescription,proto3" json:"FirmwareDescription,omitempty"`
	// version of the firmware running
	FirmwareBuildTime string `protobuf:"bytes,27,opt,name=FirmwareBuildTime,proto3" json:"FirmwareBuildTime,omitempty"`
}

func (m *DeviceStatus) Reset()                    { *m = DeviceStatus{} }
func (m *DeviceStatus) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatus) ProtoMessage()               {}
func (*DeviceStatus) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

func (m *DeviceStatus) GetState() DeviceState {
	if m != nil {
		return m.State
	}
	return DeviceState_SWITCH_STATE_NONE
}

func (m *DeviceStatus) GetSystemMACAddress() uint64 {
	if m != nil {
		return m.SystemMACAddress
	}
	return 0
}

func (m *DeviceStatus) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *DeviceStatus) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *DeviceStatus) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *DeviceStatus) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DeviceStatus) GetManufacturingDate() string {
	if m != nil {
		return m.ManufacturingDate
	}
	return ""
}

func (m *DeviceStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DeviceStatus) GetVendorID() string {
	if m != nil {
		return m.VendorID
	}
	return ""
}

func (m *DeviceStatus) GetChipType() AsicType {
	if m != nil {
		return m.ChipType
	}
	return AsicType_ASIC_TYPE_NONE
}

func (m *DeviceStatus) GetHardwareRevision() string {
	if m != nil {
		return m.HardwareRevision
	}
	return ""
}

func (m *DeviceStatus) GetCpuVendor() string {
	if m != nil {
		return m.CpuVendor
	}
	return ""
}

func (m *DeviceStatus) GetCpuSpecification() string {
	if m != nil {
		return m.CpuSpecification
	}
	return ""
}

func (m *DeviceStatus) GetSocOSVersion() string {
	if m != nil {
		return m.SocOSVersion
	}
	return ""
}

func (m *DeviceStatus) GetSocDiskSize() string {
	if m != nil {
		return m.SocDiskSize
	}
	return ""
}

func (m *DeviceStatus) GetPCIeSpecification() string {
	if m != nil {
		return m.PCIeSpecification
	}
	return ""
}

func (m *DeviceStatus) GetPCIeBusInfo() string {
	if m != nil {
		return m.PCIeBusInfo
	}
	return ""
}

func (m *DeviceStatus) GetNumPCIePorts() uint32 {
	if m != nil {
		return m.NumPCIePorts
	}
	return 0
}

func (m *DeviceStatus) GetNumPorts() uint32 {
	if m != nil {
		return m.NumPorts
	}
	return 0
}

func (m *DeviceStatus) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *DeviceStatus) GetPXEVersion() float32 {
	if m != nil {
		return m.PXEVersion
	}
	return 0
}

func (m *DeviceStatus) GetUEFIVersion() float32 {
	if m != nil {
		return m.UEFIVersion
	}
	return 0
}

func (m *DeviceStatus) GetNumHostIf() uint32 {
	if m != nil {
		return m.NumHostIf
	}
	return 0
}

func (m *DeviceStatus) GetFirmwareDescription() string {
	if m != nil {
		return m.FirmwareDescription
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareBuildTime() string {
	if m != nil {
		return m.FirmwareBuildTime
	}
	return ""
}

// stats of the device, if any
type DeviceStatsEntry struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *DeviceStatsEntry) Reset()                    { *m = DeviceStatsEntry{} }
func (m *DeviceStatsEntry) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatsEntry) ProtoMessage()               {}
func (*DeviceStatsEntry) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

func (m *DeviceStatsEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceStatsEntry) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DeviceStats struct {
	Ingress []*DeviceStatsEntry `protobuf:"bytes,1,rep,name=Ingress" json:"Ingress,omitempty"`
	Egress  []*DeviceStatsEntry `protobuf:"bytes,2,rep,name=Egress" json:"Egress,omitempty"`
}

func (m *DeviceStats) Reset()                    { *m = DeviceStats{} }
func (m *DeviceStats) String() string            { return proto.CompactTextString(m) }
func (*DeviceStats) ProtoMessage()               {}
func (*DeviceStats) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

func (m *DeviceStats) GetIngress() []*DeviceStatsEntry {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *DeviceStats) GetEgress() []*DeviceStatsEntry {
	if m != nil {
		return m.Egress
	}
	return nil
}

// device object
type Device struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *DeviceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *DeviceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *DeviceStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

func (m *Device) GetSpec() *DeviceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Device) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Device) GetStats() *DeviceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// device create and update request
type DeviceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt  `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   *DeviceSpec `protobuf:"bytes,2,opt,name=Request" json:"Request,omitempty"`
}

func (m *DeviceRequest) Reset()                    { *m = DeviceRequest{} }
func (m *DeviceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceRequest) ProtoMessage()               {}
func (*DeviceRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{5} }

func (m *DeviceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *DeviceRequest) GetRequest() *DeviceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// device create and update response
type DeviceResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *DeviceStatus `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceResponse) Reset()                    { *m = DeviceResponse{} }
func (m *DeviceResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceResponse) ProtoMessage()               {}
func (*DeviceResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{6} }

func (m *DeviceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceResponse) GetResponse() *DeviceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// device get request
type DeviceGetRequest struct {
}

func (m *DeviceGetRequest) Reset()                    { *m = DeviceGetRequest{} }
func (m *DeviceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetRequest) ProtoMessage()               {}
func (*DeviceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{7} }

// device get response
type DeviceGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *Device   `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceGetResponse) Reset()                    { *m = DeviceGetResponse{} }
func (m *DeviceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetResponse) ProtoMessage()               {}
func (*DeviceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{8} }

func (m *DeviceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceGetResponse) GetResponse() *Device {
	if m != nil {
		return m.Response
	}
	return nil
}

// device delete request
type DeviceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
}

func (m *DeviceDeleteRequest) Reset()                    { *m = DeviceDeleteRequest{} }
func (m *DeviceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteRequest) ProtoMessage()               {}
func (*DeviceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{9} }

func (m *DeviceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

// device delete response
type DeviceDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *DeviceDeleteResponse) Reset()                    { *m = DeviceDeleteResponse{} }
func (m *DeviceDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteResponse) ProtoMessage()               {}
func (*DeviceDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{10} }

func (m *DeviceDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterType((*DeviceSpec)(nil), "pds.DeviceSpec")
	proto.RegisterType((*DeviceStatus)(nil), "pds.DeviceStatus")
	proto.RegisterType((*DeviceStatsEntry)(nil), "pds.DeviceStatsEntry")
	proto.RegisterType((*DeviceStats)(nil), "pds.DeviceStats")
	proto.RegisterType((*Device)(nil), "pds.Device")
	proto.RegisterType((*DeviceRequest)(nil), "pds.DeviceRequest")
	proto.RegisterType((*DeviceResponse)(nil), "pds.DeviceResponse")
	proto.RegisterType((*DeviceGetRequest)(nil), "pds.DeviceGetRequest")
	proto.RegisterType((*DeviceGetResponse)(nil), "pds.DeviceGetResponse")
	proto.RegisterType((*DeviceDeleteRequest)(nil), "pds.DeviceDeleteRequest")
	proto.RegisterType((*DeviceDeleteResponse)(nil), "pds.DeviceDeleteResponse")
	proto.RegisterEnum("pds.MemoryProfile", MemoryProfile_name, MemoryProfile_value)
	proto.RegisterEnum("pds.DeviceProfile", DeviceProfile_name, DeviceProfile_value)
	proto.RegisterEnum("pds.DeviceOperMode", DeviceOperMode_name, DeviceOperMode_value)
	proto.RegisterEnum("pds.DeviceState", DeviceState_name, DeviceState_value)
	proto.RegisterEnum("pds.DeviceHealth", DeviceHealth_name, DeviceHealth_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeviceSvc service

type DeviceSvcClient interface {
	DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error)
	DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error)
}

type deviceSvcClient struct {
	cc *grpc.ClientConn
}

func NewDeviceSvcClient(cc *grpc.ClientConn) DeviceSvcClient {
	return &deviceSvcClient{cc}
}

func (c *deviceSvcClient) DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error) {
	out := new(DeviceGetResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error) {
	out := new(DeviceDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DeviceSvc service

type DeviceSvcServer interface {
	DeviceCreate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceUpdate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error)
	DeviceDelete(context.Context, *DeviceDeleteRequest) (*DeviceDeleteResponse, error)
}

func RegisterDeviceSvcServer(s *grpc.Server, srv DeviceSvcServer) {
	s.RegisterService(&_DeviceSvc_serviceDesc, srv)
}

func _DeviceSvc_DeviceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceGet(ctx, req.(*DeviceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, req.(*DeviceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeviceSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.DeviceSvc",
	HandlerType: (*DeviceSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeviceCreate",
			Handler:    _DeviceSvc_DeviceCreate_Handler,
		},
		{
			MethodName: "DeviceUpdate",
			Handler:    _DeviceSvc_DeviceUpdate_Handler,
		},
		{
			MethodName: "DeviceGet",
			Handler:    _DeviceSvc_DeviceGet_Handler,
		},
		{
			MethodName: "DeviceDelete",
			Handler:    _DeviceSvc_DeviceDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "device.proto",
}

func (m *DeviceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.IPAddr.Size()))
		n1, err := m.IPAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MACAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.GatewayIP.Size()))
		n2, err := m.GatewayIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DevOperMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		dAtA[i] = 0x38
		i++
		if m.BridgingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearningEn {
		dAtA[i] = 0x40
		i++
		if m.LearningEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnAgeTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnAgeTimeout))
	}
	if m.IPMappingPriority != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.IPMappingPriority))
	}
	if m.FwPolicyXposnScheme != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.FwPolicyXposnScheme))
	}
	if m.OverlayRoutingEn {
		dAtA[i] = 0x60
		i++
		if m.OverlayRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SymmetricRoutingEn {
		dAtA[i] = 0x68
		i++
		if m.SymmetricRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeviceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.SystemMACAddress))
	}
	if len(m.SerialNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SerialNumber)))
		i += copy(dAtA[i:], m.SerialNumber)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.FirmwareVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareVersion)))
		i += copy(dAtA[i:], m.FirmwareVersion)
	}
	if m.Memory != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Memory))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.ManufacturingDate) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ManufacturingDate)))
		i += copy(dAtA[i:], m.ManufacturingDate)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorID)))
		i += copy(dAtA[i:], m.VendorID)
	}
	if m.ChipType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ChipType))
	}
	if len(m.HardwareRevision) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HardwareRevision)))
		i += copy(dAtA[i:], m.HardwareRevision)
	}
	if len(m.CpuVendor) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuVendor)))
		i += copy(dAtA[i:], m.CpuVendor)
	}
	if len(m.CpuSpecification) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuSpecification)))
		i += copy(dAtA[i:], m.CpuSpecification)
	}
	if len(m.SocOSVersion) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocOSVersion)))
		i += copy(dAtA[i:], m.SocOSVersion)
	}
	if len(m.SocDiskSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocDiskSize)))
		i += copy(dAtA[i:], m.SocDiskSize)
	}
	if len(m.PCIeSpecification) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeSpecification)))
		i += copy(dAtA[i:], m.PCIeSpecification)
	}
	if len(m.PCIeBusInfo) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeBusInfo)))
		i += copy(dAtA[i:], m.PCIeBusInfo)
	}
	if m.NumPCIePorts != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPCIePorts))
	}
	if m.NumPorts != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPorts))
	}
	if len(m.VendorName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorName)))
		i += copy(dAtA[i:], m.VendorName)
	}
	if m.PXEVersion != 0 {
		dAtA[i] = 0xb5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PXEVersion))))
		i += 4
	}
	if m.UEFIVersion != 0 {
		dAtA[i] = 0xbd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UEFIVersion))))
		i += 4
	}
	if m.NumHostIf != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumHostIf))
	}
	if len(m.FirmwareDescription) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareDescription)))
		i += copy(dAtA[i:], m.FirmwareDescription)
	}
	if len(m.FirmwareBuildTime) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareBuildTime)))
		i += copy(dAtA[i:], m.FirmwareBuildTime)
	}
	return i, nil
}

func (m *DeviceStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DeviceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ObjMeta.Size()))
		n4, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Spec.Size()))
		n5, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Stats.Size()))
		n7, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n8, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Request.Size()))
		n9, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n10, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DeviceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeviceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n11, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DeviceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n12, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DeviceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DeviceSpec) Size() (n int) {
	var l int
	_ = l
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovDevice(uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		l = m.GatewayIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.DevOperMode != 0 {
		n += 1 + sovDevice(uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		n += 1 + sovDevice(uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		n += 1 + sovDevice(uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		n += 2
	}
	if m.LearningEn {
		n += 2
	}
	if m.LearnAgeTimeout != 0 {
		n += 1 + sovDevice(uint64(m.LearnAgeTimeout))
	}
	if m.IPMappingPriority != 0 {
		n += 1 + sovDevice(uint64(m.IPMappingPriority))
	}
	if m.FwPolicyXposnScheme != 0 {
		n += 1 + sovDevice(uint64(m.FwPolicyXposnScheme))
	}
	if m.OverlayRoutingEn {
		n += 2
	}
	if m.SymmetricRoutingEn {
		n += 2
	}
	return n
}

func (m *DeviceStatus) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDevice(uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		n += 1 + sovDevice(uint64(m.SystemMACAddress))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovDevice(uint64(m.Memory))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ManufacturingDate)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ChipType != 0 {
		n += 1 + sovDevice(uint64(m.ChipType))
	}
	l = len(m.HardwareRevision)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuVendor)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuSpecification)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocOSVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocDiskSize)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeSpecification)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeBusInfo)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.NumPCIePorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPCIePorts))
	}
	if m.NumPorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPorts))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.PXEVersion != 0 {
		n += 6
	}
	if m.UEFIVersion != 0 {
		n += 6
	}
	if m.NumHostIf != 0 {
		n += 2 + sovDevice(uint64(m.NumHostIf))
	}
	l = len(m.FirmwareDescription)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareBuildTime)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceStatsEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovDevice(uint64(m.Count))
	}
	return n
}

func (m *DeviceStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceGetRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeviceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	return n
}

func sovDevice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayIP == nil {
				m.GatewayIP = &IPAddress{}
			}
			if err := m.GatewayIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevOperMode", wireType)
			}
			m.DevOperMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevOperMode |= (DeviceOperMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryProfile", wireType)
			}
			m.MemoryProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryProfile |= (MemoryProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfile", wireType)
			}
			m.DeviceProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceProfile |= (DeviceProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BridgingEn = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearningEn = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnAgeTimeout", wireType)
			}
			m.LearnAgeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnAgeTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMappingPriority", wireType)
			}
			m.IPMappingPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPMappingPriority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwPolicyXposnScheme", wireType)
			}
			m.FwPolicyXposnScheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwPolicyXposnScheme |= (FwPolicyXposn(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlayRoutingEn = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymmetricRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SymmetricRoutingEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DeviceState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMACAddress", wireType)
			}
			m.SystemMACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemMACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManufacturingDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManufacturingDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChipType", wireType)
			}
			m.ChipType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChipType |= (AsicType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpecification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSpecification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocOSVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocOSVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocDiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocDiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeSpecification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeSpecification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeBusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeBusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPCIePorts", wireType)
			}
			m.NumPCIePorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPCIePorts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPorts", wireType)
			}
			m.NumPorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPorts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PXEVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PXEVersion = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEFIVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UEFIVersion = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHostIf", wireType)
			}
			m.NumHostIf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumHostIf |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareBuildTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareBuildTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &DeviceStatsEntry{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &DeviceStatsEntry{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DeviceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DeviceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeviceSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &DeviceStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Device{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("device.proto", fileDescriptorDevice) }

var fileDescriptorDevice = []byte{
	// 1586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdf, 0x72, 0xda, 0xce,
	0x15, 0x8e, 0xb0, 0x0d, 0x66, 0xb1, 0x8d, 0xbc, 0xd8, 0xae, 0x42, 0x53, 0x43, 0x99, 0x4e, 0x4b,
	0x1d, 0xdb, 0xa1, 0x38, 0x4d, 0xd2, 0x24, 0x6d, 0x06, 0x81, 0x30, 0x9a, 0x02, 0x52, 0x17, 0x1c,
	0x27, 0x57, 0x8c, 0x22, 0x16, 0xac, 0x04, 0xfd, 0xa9, 0xfe, 0x38, 0xa1, 0x0f, 0xd0, 0xb7, 0xea,
	0x74, 0x7a, 0xd7, 0xcb, 0xcc, 0xf4, 0x9e, 0xe9, 0xe4, 0xd2, 0x97, 0x7e, 0x82, 0xce, 0xae, 0x24,
	0x90, 0x80, 0x74, 0xe6, 0x97, 0x1b, 0x46, 0xfb, 0x9d, 0xef, 0x3b, 0x7b, 0xf6, 0xe8, 0x9c, 0xa3,
	0x05, 0xec, 0x0c, 0xf1, 0xad, 0xa6, 0xe2, 0x73, 0xcb, 0x36, 0x5d, 0x13, 0x6e, 0x58, 0x43, 0x27,
	0x0f, 0xc6, 0xe6, 0xd8, 0xf4, 0x81, 0x7c, 0x56, 0xc7, 0xae, 0xf2, 0x84, 0xfc, 0x04, 0x40, 0xc6,
	0x9d, 0x5a, 0xd8, 0xf1, 0x17, 0xa5, 0xbb, 0x24, 0x00, 0x0d, 0xaa, 0xef, 0x59, 0x58, 0x85, 0x65,
	0x90, 0x14, 0xe5, 0xda, 0x70, 0x68, 0x73, 0x4c, 0x91, 0x29, 0x67, 0xaa, 0xec, 0xb9, 0x4f, 0xf6,
	0x41, 0xec, 0x38, 0x28, 0xb0, 0x43, 0x0e, 0xa4, 0x3a, 0xb5, 0x3a, 0xa5, 0x26, 0x8a, 0x4c, 0x79,
	0x13, 0x85, 0x4b, 0x78, 0x0e, 0xd2, 0x97, 0x8a, 0x8b, 0x3f, 0x2b, 0x53, 0x51, 0xe6, 0x36, 0xbe,
	0xe3, 0x66, 0x41, 0x81, 0x22, 0xc8, 0x34, 0xf0, 0xad, 0x64, 0x61, 0xbb, 0x63, 0x0e, 0x31, 0xb7,
	0x59, 0x64, 0xca, 0x7b, 0xd5, 0xdc, 0xb9, 0x35, 0x74, 0xce, 0xfd, 0xc8, 0x42, 0x13, 0x0f, 0xef,
	0x67, 0x85, 0x3d, 0x72, 0x92, 0x97, 0xba, 0x62, 0x0c, 0x15, 0xd7, 0xb4, 0xa7, 0x28, 0xaa, 0x85,
	0x6d, 0xb0, 0xdb, 0xc1, 0xba, 0x69, 0x4f, 0x65, 0xdb, 0x1c, 0x69, 0x13, 0xcc, 0x6d, 0x51, 0x67,
	0x90, 0x3a, 0x8b, 0x59, 0xd6, 0xfa, 0x8a, 0x8b, 0x89, 0x37, 0x3f, 0x80, 0xd0, 0x5b, 0x32, 0xe2,
	0x2d, 0x66, 0x59, 0xef, 0x2d, 0x46, 0x81, 0x55, 0x00, 0x78, 0x5b, 0x1b, 0x8e, 0x35, 0x63, 0x2c,
	0x18, 0x5c, 0xaa, 0xc8, 0x94, 0xb7, 0xd7, 0xca, 0x22, 0x2c, 0xa2, 0x69, 0x63, 0xc5, 0x36, 0x7c,
	0xcd, 0xf6, 0xf7, 0x35, 0x0b, 0x16, 0x44, 0x20, 0x4b, 0x57, 0xb5, 0x31, 0xee, 0x6b, 0x3a, 0x36,
	0x3d, 0x97, 0x4b, 0x17, 0x99, 0xf2, 0x2e, 0x5f, 0xbe, 0x9f, 0x15, 0x7e, 0x45, 0x85, 0xb6, 0x62,
	0x8c, 0xf1, 0xcb, 0x8b, 0xca, 0xd9, 0x8b, 0x67, 0x4f, 0x2b, 0x95, 0x53, 0x8a, 0x0d, 0xf1, 0x48,
	0xf1, 0x26, 0xee, 0x1f, 0x2f, 0x2a, 0x15, 0xb4, 0xec, 0x00, 0xd6, 0xc1, 0xbe, 0x28, 0x77, 0x14,
	0xcb, 0xd2, 0x8c, 0xb1, 0x6c, 0x6b, 0xa6, 0xad, 0xb9, 0x53, 0x0e, 0x50, 0xaf, 0x87, 0xf7, 0xb3,
	0xc2, 0x7e, 0xc4, 0x6b, 0xe5, 0xec, 0x77, 0x95, 0xea, 0x05, 0x5a, 0xe5, 0xc3, 0x2f, 0x20, 0xd7,
	0xfc, 0x2c, 0x9b, 0x13, 0x4d, 0x9d, 0xbe, 0xb3, 0x4c, 0xc7, 0xe8, 0xa9, 0x37, 0x58, 0xc7, 0x5c,
	0x86, 0x26, 0xf5, 0x20, 0xa8, 0x90, 0x18, 0x83, 0xaf, 0xdc, 0xcf, 0x0a, 0xf1, 0xf0, 0x9a, 0xd7,
	0x03, 0x59, 0x6a, 0x8b, 0xf5, 0xf7, 0x83, 0x77, 0xb2, 0xd4, 0xeb, 0x0e, 0x2e, 0xdb, 0x12, 0x5f,
	0x6b, 0x0f, 0x64, 0x24, 0x4a, 0x48, 0xec, 0xbf, 0x47, 0xeb, 0xb6, 0x80, 0x7f, 0x02, 0xac, 0x74,
	0x8b, 0xed, 0x89, 0x32, 0x45, 0xa6, 0xe7, 0xfa, 0xc9, 0xdc, 0xf9, 0x6e, 0x32, 0x57, 0xb8, 0xb0,
	0x09, 0x60, 0x6f, 0xaa, 0xeb, 0xd8, 0xb5, 0x35, 0x75, 0xe1, 0x61, 0x97, 0x7a, 0x38, 0xba, 0x9f,
	0x15, 0x60, 0x2c, 0xc4, 0x91, 0x32, 0x71, 0x30, 0x5a, 0xa3, 0x28, 0xfd, 0x2b, 0x05, 0x76, 0x82,
	0x66, 0x73, 0x15, 0xd7, 0x73, 0xe0, 0xaf, 0xc1, 0x16, 0x79, 0xc2, 0xb4, 0xdb, 0xf6, 0xaa, 0x6c,
	0xa4, 0xb2, 0x28, 0x8e, 0x7c, 0x33, 0x3c, 0x01, 0x6c, 0x6f, 0xea, 0xb8, 0x58, 0x0f, 0x7a, 0x0c,
	0x3b, 0x4e, 0xd0, 0x75, 0x2b, 0x38, 0x2c, 0x81, 0x9d, 0x1e, 0xb6, 0x35, 0x65, 0xd2, 0xf5, 0xf4,
	0x0f, 0xd8, 0xa6, 0x1d, 0x98, 0x46, 0x31, 0x0c, 0xb2, 0x60, 0xa3, 0xf7, 0xc9, 0xa3, 0xad, 0x96,
	0x46, 0xe4, 0x11, 0x96, 0x41, 0xb6, 0xa9, 0xd9, 0xfa, 0x67, 0xc5, 0xc6, 0x6f, 0xb1, 0xed, 0x68,
	0xa6, 0x41, 0x7b, 0x27, 0x8d, 0x96, 0x61, 0x78, 0x04, 0x92, 0x7e, 0x9b, 0xd0, 0x76, 0xd8, 0x45,
	0xc1, 0x0a, 0x16, 0x41, 0x46, 0xb6, 0xcd, 0xa1, 0xa7, 0xba, 0x5d, 0x45, 0xc7, 0xb4, 0xc0, 0xd3,
	0x28, 0x0a, 0xc1, 0x53, 0xb0, 0xdf, 0x51, 0x0c, 0x6f, 0xa4, 0xa8, 0xae, 0x67, 0x6b, 0xc6, 0xb8,
	0x41, 0x4e, 0xbe, 0x4d, 0x79, 0xab, 0x06, 0xe2, 0xaf, 0x81, 0x1d, 0xd5, 0xd6, 0x2c, 0x97, 0x44,
	0x93, 0xf6, 0xfd, 0x45, 0x20, 0x98, 0x07, 0xdb, 0x6f, 0xb1, 0x31, 0x34, 0x6d, 0xb1, 0x41, 0x8b,
	0x31, 0x8d, 0xe6, 0x6b, 0xf8, 0x18, 0x6c, 0xd7, 0x6f, 0x34, 0xab, 0x3f, 0xb5, 0xc2, 0x0a, 0xcb,
	0x06, 0x15, 0x56, 0x73, 0x34, 0x95, 0xc0, 0x68, 0x4e, 0x20, 0xe9, 0x6d, 0x29, 0xf6, 0x90, 0x9c,
	0x12, 0xe1, 0x5b, 0x8d, 0x9e, 0x7e, 0x87, 0x3a, 0x5c, 0xc1, 0xe1, 0x23, 0x90, 0xae, 0x5b, 0x9e,
	0xbf, 0x0f, 0x2d, 0x81, 0x34, 0x5a, 0x00, 0xc4, 0x53, 0xdd, 0xf2, 0xc8, 0x28, 0xd5, 0x46, 0x9a,
	0xaa, 0xd0, 0xc8, 0xf7, 0x7c, 0x4f, 0xcb, 0x38, 0x7d, 0x51, 0xa6, 0x2a, 0xf5, 0xc2, 0x7c, 0x67,
	0x83, 0x17, 0x15, 0xc1, 0x48, 0x12, 0x7a, 0xa6, 0xda, 0xd0, 0x9c, 0x4f, 0x3d, 0xed, 0x6f, 0x98,
	0x63, 0xfd, 0x24, 0x44, 0x20, 0x92, 0x54, 0xb9, 0x2e, 0xe2, 0xf8, 0x96, 0xfb, 0x7e, 0x52, 0x57,
	0x0c, 0xf4, 0x25, 0xd5, 0x45, 0xcc, 0x7b, 0x8e, 0x68, 0x8c, 0x4c, 0x0e, 0x06, 0x2f, 0x69, 0x01,
	0x91, 0xa8, 0xba, 0x9e, 0x4e, 0x10, 0xd9, 0xb4, 0x5d, 0x87, 0xcb, 0xd1, 0x97, 0x1c, 0xc3, 0x48,
	0xe2, 0xc9, 0x9a, 0xda, 0x0f, 0xa8, 0x7d, 0xbe, 0x86, 0xc7, 0x00, 0xf8, 0xb9, 0xa0, 0x55, 0x70,
	0x48, 0x37, 0x88, 0x20, 0xc4, 0x2e, 0xbf, 0x13, 0xc2, 0x33, 0x1f, 0x15, 0x99, 0x72, 0x02, 0x45,
	0x10, 0x12, 0xe1, 0x95, 0xd0, 0x14, 0x43, 0xc2, 0xcf, 0x28, 0x21, 0x0a, 0x91, 0x37, 0xd0, 0xf5,
	0xf4, 0x96, 0xe9, 0xb8, 0xe2, 0x88, 0xe3, 0xe8, 0xf6, 0x0b, 0x00, 0x56, 0x40, 0x2e, 0xac, 0xd8,
	0x68, 0xf9, 0xe4, 0x69, 0x20, 0xeb, 0x4c, 0x24, 0x83, 0x21, 0xcc, 0x7b, 0xda, 0x64, 0x48, 0x86,
	0x1e, 0xf7, 0x73, 0x3f, 0x83, 0x2b, 0x86, 0xd2, 0x6b, 0xc0, 0x2e, 0x1a, 0xd4, 0x11, 0x0c, 0xd7,
	0x9e, 0x42, 0x08, 0x36, 0xe9, 0x69, 0x19, 0x2a, 0xa2, 0xcf, 0xf0, 0x00, 0x6c, 0xd5, 0x4d, 0xcf,
	0x70, 0x83, 0x3e, 0xf5, 0x17, 0x25, 0x9d, 0x7e, 0xeb, 0x42, 0x35, 0x7c, 0x02, 0x52, 0xa2, 0x31,
	0xa6, 0xed, 0xcc, 0x14, 0x37, 0xca, 0x99, 0xea, 0xe1, 0xd2, 0x04, 0xf0, 0x37, 0x40, 0x21, 0x0b,
	0x9e, 0x81, 0xa4, 0x30, 0x0e, 0xda, 0xff, 0xff, 0xf0, 0x03, 0x52, 0xe9, 0x1f, 0x09, 0x90, 0xf4,
	0x8d, 0xf0, 0x15, 0xd8, 0x26, 0xb5, 0xde, 0xc1, 0xae, 0x12, 0x7c, 0xdb, 0xf7, 0xce, 0xe9, 0xa5,
	0x20, 0x44, 0xf9, 0xec, 0xd7, 0x59, 0x81, 0xb9, 0x9b, 0x15, 0x52, 0xa7, 0x9a, 0x31, 0xd1, 0x0c,
	0x8c, 0xe6, 0x02, 0xf8, 0x06, 0xa4, 0xa4, 0x0f, 0x1f, 0xa9, 0x36, 0x41, 0xb5, 0xbb, 0xbe, 0x36,
	0x00, 0xf9, 0xa3, 0x40, 0x4a, 0x47, 0xe9, 0xa9, 0xa9, 0x6b, 0x2e, 0xd6, 0x2d, 0x77, 0x8a, 0x42,
	0x15, 0x7c, 0x0e, 0x36, 0x49, 0x21, 0x06, 0xd7, 0x81, 0x6c, 0x34, 0x6a, 0x0b, 0xab, 0x3c, 0x24,
	0x5a, 0xc7, 0xc2, 0x6a, 0x44, 0x4b, 0x05, 0xf0, 0x0d, 0x48, 0xfa, 0xb3, 0x92, 0x0e, 0xab, 0x4c,
	0x75, 0x7f, 0xe9, 0xc0, 0x9e, 0xc3, 0x1f, 0xdc, 0xcd, 0x0a, 0xac, 0x43, 0x9f, 0x23, 0xf2, 0x40,
	0x06, 0x5f, 0xf9, 0x23, 0xd6, 0xa1, 0xe3, 0x2c, 0xb3, 0x32, 0x62, 0x1d, 0x3e, 0x77, 0x37, 0x2b,
	0x64, 0x89, 0x3c, 0xaa, 0xf6, 0x35, 0xa5, 0x8f, 0xe1, 0x0d, 0x00, 0xe1, 0xbf, 0x7a, 0xd8, 0x71,
	0xc9, 0xdd, 0x86, 0x57, 0x5c, 0xf5, 0xa6, 0xee, 0x7e, 0x71, 0x97, 0xae, 0x48, 0x73, 0x1c, 0x2d,
	0x28, 0xf0, 0xb7, 0x20, 0x15, 0x48, 0x83, 0xc4, 0x2d, 0x1f, 0x1d, 0x85, 0xf6, 0x92, 0x09, 0xf6,
	0xc2, 0xbd, 0x1c, 0xcb, 0x34, 0x1c, 0x4c, 0x36, 0xab, 0x59, 0x5a, 0x70, 0xfc, 0xf0, 0x0b, 0x11,
	0x0c, 0xb1, 0x10, 0x47, 0x0b, 0x0a, 0x3c, 0x03, 0xdb, 0xa1, 0x36, 0xd8, 0x6d, 0x35, 0x5b, 0x68,
	0x4e, 0x29, 0xc1, 0xb0, 0x92, 0x2f, 0xb1, 0x1b, 0x06, 0x31, 0x01, 0xfb, 0x11, 0xec, 0x07, 0xe3,
	0xf8, 0xcd, 0x4a, 0x1c, 0x99, 0x48, 0x1c, 0x91, 0x08, 0x04, 0x90, 0xf3, 0xb1, 0x06, 0x9e, 0x60,
	0xf7, 0x47, 0x93, 0x5c, 0x6a, 0x82, 0x83, 0xb8, 0x9b, 0x1f, 0x8b, 0xfb, 0xe4, 0xf1, 0xd2, 0xed,
	0x11, 0xe6, 0xc1, 0x51, 0x47, 0xe8, 0x48, 0xe8, 0xfd, 0x40, 0x46, 0x52, 0x53, 0x6c, 0x0b, 0x83,
	0x86, 0xd0, 0xac, 0x5d, 0xb5, 0xfb, 0xec, 0x83, 0x93, 0xff, 0x30, 0x4b, 0xb7, 0x43, 0xc2, 0x6e,
	0x08, 0x6f, 0xc5, 0xba, 0xb0, 0xca, 0x86, 0x47, 0x00, 0x2e, 0xd9, 0xaa, 0x72, 0x93, 0x65, 0xd6,
	0xe0, 0x17, 0x72, 0x93, 0x4d, 0xac, 0xc1, 0x9f, 0xca, 0x4d, 0x76, 0x63, 0x0d, 0xfe, 0x7b, 0xb9,
	0xc9, 0x6e, 0xae, 0xc1, 0x9f, 0xc9, 0x4d, 0x76, 0x6b, 0x0d, 0xfe, 0x5c, 0x6e, 0xb2, 0xc9, 0x35,
	0xf8, 0x0b, 0xb9, 0xc9, 0xa6, 0x4e, 0x94, 0xb0, 0x08, 0xe7, 0x57, 0xea, 0x87, 0xe0, 0x30, 0x60,
	0x4a, 0xb2, 0x80, 0x06, 0x1d, 0xa9, 0x21, 0x0c, 0xba, 0x52, 0x57, 0x60, 0x1f, 0xac, 0x35, 0xf1,
	0x62, 0xff, 0x9a, 0x65, 0xd6, 0x9a, 0x5a, 0x52, 0xaf, 0xcf, 0x26, 0x4e, 0x46, 0xd1, 0x11, 0x88,
	0xe1, 0x21, 0xd8, 0xef, 0x5d, 0x8b, 0xfd, 0x7a, 0x6b, 0xd0, 0xeb, 0xd7, 0xfa, 0x73, 0xdf, 0x39,
	0x90, 0x8d, 0xc1, 0x57, 0x32, 0xcb, 0xac, 0x70, 0x1b, 0xd2, 0x75, 0x97, 0x4d, 0xc0, 0x03, 0xc0,
	0xc6, 0x60, 0x01, 0x21, 0x76, 0xe3, 0xe4, 0x9f, 0x4c, 0x78, 0xd9, 0x6a, 0x61, 0x65, 0xe2, 0xde,
	0x44, 0xce, 0xdc, 0x12, 0x6a, 0xed, 0x7e, 0x2b, 0xdc, 0xea, 0x00, 0xb0, 0x71, 0x5c, 0xfa, 0x33,
	0xcb, 0xc0, 0x63, 0x90, 0x8f, 0xa3, 0x3d, 0x01, 0xd1, 0x65, 0xb0, 0xe9, 0x2f, 0xc1, 0x2f, 0xe2,
	0x76, 0x24, 0xf0, 0x92, 0xd4, 0x1f, 0x20, 0xe1, 0x2f, 0x57, 0x22, 0x12, 0x1a, 0xec, 0x06, 0x7c,
	0x04, 0xb8, 0x38, 0xa5, 0x2d, 0x5d, 0x0f, 0xfc, 0x82, 0x62, 0x37, 0x61, 0x11, 0x3c, 0x8a, 0x5b,
	0x5b, 0x35, 0xd4, 0xb8, 0xae, 0x21, 0x1a, 0xbf, 0x84, 0xd8, 0xad, 0xea, 0xdf, 0x13, 0x20, 0x1d,
	0xa4, 0xea, 0x56, 0x85, 0x7f, 0x08, 0x8f, 0x53, 0xb7, 0x31, 0x49, 0x5c, 0xf4, 0x6f, 0x48, 0xd0,
	0x39, 0xf9, 0x5c, 0x0c, 0x0b, 0xba, 0xec, 0xc1, 0x42, 0x7a, 0x65, 0x0d, 0x7f, 0xa2, 0xf4, 0x75,
	0x18, 0xc2, 0x25, 0x76, 0x61, 0xf4, 0x6b, 0xb3, 0x18, 0x1a, 0xf9, 0xa3, 0x65, 0x78, 0xae, 0x16,
	0xc2, 0x8d, 0xfd, 0xce, 0x84, 0x5c, 0x84, 0x19, 0xeb, 0xf9, 0xfc, 0xc3, 0x35, 0x96, 0xd0, 0x0d,
	0xbf, 0xf3, 0xef, 0x6f, 0xc7, 0xcc, 0xd7, 0x6f, 0xc7, 0xcc, 0x7f, 0xbf, 0x1d, 0x33, 0x1f, 0x92,
	0xf4, 0x9f, 0xeb, 0xc5, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x54, 0x5c, 0x18, 0xea, 0xf8, 0x0e,
	0x00, 0x00,
}
