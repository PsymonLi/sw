// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MemoryProfile int32

const (
	MemoryProfile_MEMORY_PROFILE_DEFAULT MemoryProfile = 0
	// router profile will support 256K routes per IPv4
	// route table and a total of 32 such route tables
	MemoryProfile_MEMORY_PROFILE_ROUTER MemoryProfile = 1
)

var MemoryProfile_name = map[int32]string{
	0: "MEMORY_PROFILE_DEFAULT",
	1: "MEMORY_PROFILE_ROUTER",
}
var MemoryProfile_value = map[string]int32{
	"MEMORY_PROFILE_DEFAULT": 0,
	"MEMORY_PROFILE_ROUTER":  1,
}

func (x MemoryProfile) String() string {
	return proto.EnumName(MemoryProfile_name, int32(x))
}
func (MemoryProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

type DeviceProfile int32

const (
	DeviceProfile_DEVICE_PROFILE_DEFAULT DeviceProfile = 0
	DeviceProfile_DEVICE_PROFILE_2PF     DeviceProfile = 1
	DeviceProfile_DEVICE_PROFILE_3PF     DeviceProfile = 2
	DeviceProfile_DEVICE_PROFILE_4PF     DeviceProfile = 3
	DeviceProfile_DEVICE_PROFILE_5PF     DeviceProfile = 4
	DeviceProfile_DEVICE_PROFILE_6PF     DeviceProfile = 5
	DeviceProfile_DEVICE_PROFILE_7PF     DeviceProfile = 6
	DeviceProfile_DEVICE_PROFILE_8PF     DeviceProfile = 7
	DeviceProfile_DEVICE_PROFILE_16PF    DeviceProfile = 8
	DeviceProfile_DEVICE_PROFILE_32PF    DeviceProfile = 9
	DeviceProfile_DEVICE_PROFILE_32VF    DeviceProfile = 10
)

var DeviceProfile_name = map[int32]string{
	0:  "DEVICE_PROFILE_DEFAULT",
	1:  "DEVICE_PROFILE_2PF",
	2:  "DEVICE_PROFILE_3PF",
	3:  "DEVICE_PROFILE_4PF",
	4:  "DEVICE_PROFILE_5PF",
	5:  "DEVICE_PROFILE_6PF",
	6:  "DEVICE_PROFILE_7PF",
	7:  "DEVICE_PROFILE_8PF",
	8:  "DEVICE_PROFILE_16PF",
	9:  "DEVICE_PROFILE_32PF",
	10: "DEVICE_PROFILE_32VF",
}
var DeviceProfile_value = map[string]int32{
	"DEVICE_PROFILE_DEFAULT": 0,
	"DEVICE_PROFILE_2PF":     1,
	"DEVICE_PROFILE_3PF":     2,
	"DEVICE_PROFILE_4PF":     3,
	"DEVICE_PROFILE_5PF":     4,
	"DEVICE_PROFILE_6PF":     5,
	"DEVICE_PROFILE_7PF":     6,
	"DEVICE_PROFILE_8PF":     7,
	"DEVICE_PROFILE_16PF":    8,
	"DEVICE_PROFILE_32PF":    9,
	"DEVICE_PROFILE_32VF":    10,
}

func (x DeviceProfile) String() string {
	return proto.EnumName(DeviceProfile_name, int32(x))
}
func (DeviceProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

// operational mode of the device
// NOTE:
// multiple connectivity models are possible in SMART_SWITCH and SMART_SERVICE
// modes:
//     a. one uplink handles traffic from/to host side and other uplink handles
//        traffic from/to fabric/sdn
//     b. both uplinks can send and receive traffic from/to host and from/to
//        fabric side (i.e., both links are treated the same way and probably
//        ECMP-ed), this connectivity model is useful when DSC is deployed
//        behind/alongside a switch and switch is redirecting traffic to DSCs
//        (aka. sidecar model) and making forwarding decisions
type DeviceOperMode int32

const (
	DeviceOperMode_DEVICE_OPER_MODE_NONE DeviceOperMode = 0
	// HOST mode with workloads on pcie; it is flow based and supports all
	// features (IP services like firewall, NAT etc.) depending on the memory
	// profile configured
	DeviceOperMode_DEVICE_OPER_MODE_HOST DeviceOperMode = 1
	// in SMART_SWITCH mode, DSC acts as bump-in-the-wire device; it is flow
	// based and does forwarding (based on mappings and routes) while
	// supporting all IP (smart) service features (and is flow based) depending
	// on the memory profile configured; the switch connected via the sdn
	// port(s) will do only underlay routing on the encapped (by DSC) traiffc
	DeviceOperMode_DEVICE_OPER_MODE_BITW_SMART_SWITCH DeviceOperMode = 2
	// in SMART_SERVICE mode, DSC is flow based and provides IP service
	// features; it doesn't do forwarding (i.e. L2 or L3 lookups), i.e. no
	// L2/L3 mappings need to be configured and IP routing is not enabled
	DeviceOperMode_DEVICE_OPER_MODE_BITW_SMART_SERVICE DeviceOperMode = 3
	// in CLASSIC_SWITCH mode, DSC performs routing and no IP services are
	// performed; additionally this is not flow based mode and hence every
	// packet is subjected to route table and/or mapping lookups (routes are
	// either programmed via grpc or distributed via control protocol like BGP)
	DeviceOperMode_DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH DeviceOperMode = 4
)

var DeviceOperMode_name = map[int32]string{
	0: "DEVICE_OPER_MODE_NONE",
	1: "DEVICE_OPER_MODE_HOST",
	2: "DEVICE_OPER_MODE_BITW_SMART_SWITCH",
	3: "DEVICE_OPER_MODE_BITW_SMART_SERVICE",
	4: "DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH",
}
var DeviceOperMode_value = map[string]int32{
	"DEVICE_OPER_MODE_NONE":                0,
	"DEVICE_OPER_MODE_HOST":                1,
	"DEVICE_OPER_MODE_BITW_SMART_SWITCH":   2,
	"DEVICE_OPER_MODE_BITW_SMART_SERVICE":  3,
	"DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH": 4,
}

func (x DeviceOperMode) String() string {
	return proto.EnumName(DeviceOperMode_name, int32(x))
}
func (DeviceOperMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

// supported learn modes
type LearnMode int32

const (
	LearnMode_LEARN_MODE_NONE LearnMode = 0
	// in LEARN_MODE_NOTIFY mode, when a unknown MAC/IP is seen, notification
	// is generated via operd to the app, learn module will not populate the
	// p4 tables with the MAC or IP; they will be programmed when app comes back
	// and install vnics and/or IP mappings because of these learn notifications
	// NOTE:
	// 1. as learn events are simply notified to app, learn module doesn't need to
	//    perform aging of the MAC/IP entries in this mode.
	// 2. in order to de-dup back-to-back learn events and not bombard the app
	//    listening  to these notifications, some state will be maintained about
	//    the notified MAC/IP entries and will be deleted within short time
	LearnMode_LEARN_MODE_NOTIFY LearnMode = 1
	// in LEARN_MODE_AUTO, learn module will learn and automatically program the
	// learnt MAC/IP in the datapath. Additionally, notifications will be
	// generated for the clients of interest via operd
	LearnMode_LEARN_MODE_AUTO LearnMode = 2
)

var LearnMode_name = map[int32]string{
	0: "LEARN_MODE_NONE",
	1: "LEARN_MODE_NOTIFY",
	2: "LEARN_MODE_AUTO",
}
var LearnMode_value = map[string]int32{
	"LEARN_MODE_NONE":   0,
	"LEARN_MODE_NOTIFY": 1,
	"LEARN_MODE_AUTO":   2,
}

func (x LearnMode) String() string {
	return proto.EnumName(LearnMode_name, int32(x))
}
func (LearnMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

// device operational status
type DeviceState int32

const (
	DeviceState_SWITCH_STATE_NONE DeviceState = 0
	DeviceState_SWITCH_STATE_UP   DeviceState = 1
	DeviceState_SWITCH_STATE_DOWN DeviceState = 2
	DeviceState_SWITCH_STATE_ERR  DeviceState = 3
)

var DeviceState_name = map[int32]string{
	0: "SWITCH_STATE_NONE",
	1: "SWITCH_STATE_UP",
	2: "SWITCH_STATE_DOWN",
	3: "SWITCH_STATE_ERR",
}
var DeviceState_value = map[string]int32{
	"SWITCH_STATE_NONE": 0,
	"SWITCH_STATE_UP":   1,
	"SWITCH_STATE_DOWN": 2,
	"SWITCH_STATE_ERR":  3,
}

func (x DeviceState) String() string {
	return proto.EnumName(DeviceState_name, int32(x))
}
func (DeviceState) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

// device health status, multiple conditions can happen
type DeviceHealth int32

const (
	DeviceHealth_DEVICE_HEALTH_NONE            DeviceHealth = 0
	DeviceHealth_DEVICE_HEALTH_OK              DeviceHealth = 1
	DeviceHealth_DEVICE_HEALTH_SERVICE_DOWN    DeviceHealth = 2
	DeviceHealth_DEVICE_HEALTH_REBOOT_REQUIRED DeviceHealth = 3
	DeviceHealth_DEVICE_HEALTH_LOW_MEMORY      DeviceHealth = 4
	DeviceHealth_DEVICE_HEALTH_HARDWARE_ERROR  DeviceHealth = 5
)

var DeviceHealth_name = map[int32]string{
	0: "DEVICE_HEALTH_NONE",
	1: "DEVICE_HEALTH_OK",
	2: "DEVICE_HEALTH_SERVICE_DOWN",
	3: "DEVICE_HEALTH_REBOOT_REQUIRED",
	4: "DEVICE_HEALTH_LOW_MEMORY",
	5: "DEVICE_HEALTH_HARDWARE_ERROR",
}
var DeviceHealth_value = map[string]int32{
	"DEVICE_HEALTH_NONE":            0,
	"DEVICE_HEALTH_OK":              1,
	"DEVICE_HEALTH_SERVICE_DOWN":    2,
	"DEVICE_HEALTH_REBOOT_REQUIRED": 3,
	"DEVICE_HEALTH_LOW_MEMORY":      4,
	"DEVICE_HEALTH_HARDWARE_ERROR":  5,
}

func (x DeviceHealth) String() string {
	return proto.EnumName(DeviceHealth_name, int32(x))
}
func (DeviceHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorDevice, []int{5} }

// supported types of packets for learning
// NOTE: when all learn sources are set to false, LearnMode must be set to
//       LEARN_MODE_NONE
type LearnSource struct {
	// when ArpLearnEn is set to true, learning will happen from ARP/GARP/RARP
	// traffic
	ArpLearnEn bool `protobuf:"varint,1,opt,name=ArpLearnEn,proto3" json:"ArpLearnEn,omitempty" meta:default=true`
	// when DhcpLearnEn is se to true, learning will happen from DHCP traffic
	DhcpLearnEn bool `protobuf:"varint,2,opt,name=DhcpLearnEn,proto3" json:"DhcpLearnEn,omitempty" meta:default=true`
	// when DataPktLearnEn is set to true, learning will happen from non-protocol
	// data traffic
	DataPktLearnEn bool `protobuf:"varint,3,opt,name=DataPktLearnEn,proto3" json:"DataPktLearnEn,omitempty" meta:default=true`
}

func (m *LearnSource) Reset()                    { *m = LearnSource{} }
func (m *LearnSource) String() string            { return proto.CompactTextString(m) }
func (*LearnSource) ProtoMessage()               {}
func (*LearnSource) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{0} }

func (m *LearnSource) GetArpLearnEn() bool {
	if m != nil {
		return m.ArpLearnEn
	}
	return false
}

func (m *LearnSource) GetDhcpLearnEn() bool {
	if m != nil {
		return m.DhcpLearnEn
	}
	return false
}

func (m *LearnSource) GetDataPktLearnEn() bool {
	if m != nil {
		return m.DataPktLearnEn
	}
	return false
}

// MAC/IP learning related configuration knobs
type LearnSpec struct {
	// NOTE: when LearnMode mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	LearnMode LearnMode `protobuf:"varint,1,opt,name=LearnMode,proto3,enum=pds.LearnMode" json:"LearnMode,omitempty" meta:default=LEARN_MODE_NONE`
	// LearnAgeTimeout is the aging timeout (in seconds) for learnt MAC or IP
	// addresses if LearningEn is set to true. If this is not set and learning is
	// enabled, default value is assumed for aging
	LearnAgeTimeout uint32 `protobuf:"varint,2,opt,name=LearnAgeTimeout,proto3" json:"LearnAgeTimeout,omitempty" meta:range:30-86400,meta:default=300`
	// LearnSource captures packet types that can result in MAC/IP learning
	LearnSource *LearnSource `protobuf:"bytes,3,opt,name=LearnSource" json:"LearnSource,omitempty" LearnMode!=LEARN_MODE_NONE`
}

func (m *LearnSpec) Reset()                    { *m = LearnSpec{} }
func (m *LearnSpec) String() string            { return proto.CompactTextString(m) }
func (*LearnSpec) ProtoMessage()               {}
func (*LearnSpec) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{1} }

func (m *LearnSpec) GetLearnMode() LearnMode {
	if m != nil {
		return m.LearnMode
	}
	return LearnMode_LEARN_MODE_NONE
}

func (m *LearnSpec) GetLearnAgeTimeout() uint32 {
	if m != nil {
		return m.LearnAgeTimeout
	}
	return 0
}

func (m *LearnSpec) GetLearnSource() *LearnSource {
	if m != nil {
		return m.LearnSource
	}
	return nil
}

type DeviceSpec struct {
	// local IP address in the underlay (i.e. MyTEP IP or local TEP IP)
	IPAddr *IPAddress `protobuf:"bytes,1,opt,name=IPAddr" json:"IPAddr,omitempty"`
	// system MAC (NAPLES's system MAC will be used if not provided)
	MACAddr uint64 `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	// IP address of the gateway in the underlay
	GatewayIP *IPAddress `protobuf:"bytes,3,opt,name=GatewayIP" json:"GatewayIP,omitempty"`
	// operational mode of the device
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	DevOperMode DeviceOperMode `protobuf:"varint,4,opt,name=DevOperMode,proto3,enum=pds.DeviceOperMode" json:"DevOperMode,omitempty" meta:mandatory, persisted`
	// Memory Profile (only MEMORY_PROFILE_DEFAULT is supported)
	// NOTE: when a device profile is changed, it will take affect after next
	// reboot of NAPLES/DSC
	MemoryProfile MemoryProfile `protobuf:"varint,5,opt,name=MemoryProfile,proto3,enum=pds.MemoryProfile" json:"MemoryProfile,omitempty" meta:mandatory,persisted`
	// Device Profile
	DeviceProfile DeviceProfile `protobuf:"varint,6,opt,name=DeviceProfile,proto3,enum=pds.DeviceProfile" json:"DeviceProfile,omitempty" meta:mandatory,persisted`
	// if BridgingEn is true, L2 functionality based on MAC addresses kicks in
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	BridgingEn bool `protobuf:"varint,7,opt,name=BridgingEn,proto3" json:"BridgingEn,omitempty" meta:mandatory`
	// MAC/IP learning controls
	// NOTE: if LearnSpec is not configured learning is disabled by default
	LearnSpec *LearnSpec `protobuf:"bytes,8,opt,name=LearnSpec" json:"LearnSpec,omitempty"`
	// priority of IP mapping entries (this priority, if configured, will be
	// used to break the tie in case both LPM/prefix and a mapping entry are
	// hit in the datapath (i.e., /32 IP mapping entry is also in some LPM
	// prefix)
	// NOTE:
	// 1. by default IP mapping always takes precedence over LPM hit and
	//    default value of this attribute is 0 (lower the numerical value,
	//    the higher the priority, hence 0 is the highest priority)
	// 2. valid priority value range is 0 to 1023
	// 3. if mapping and route are both hit and both have same priority,
	//    mapping result will take precedence over route (even if it is /32 route)
	// 4. if the value of this attribute is updated on the fly, it will not
	//    affect the flows/sessions that are already created, but it will take
	//    affect only on the new sessions/flows created after such an update
	IPMappingPriority uint32 `protobuf:"varint,9,opt,name=IPMappingPriority,proto3" json:"IPMappingPriority,omitempty" meta:range:0-1023`
	// firewall (if enabled) action transposition logic dictates how the policy
	// lookup results are processed when multiple security policies are applied
	// on a packet
	FwPolicyXposnScheme FwPolicyXposn `protobuf:"varint,10,opt,name=FwPolicyXposnScheme,proto3,enum=types.FwPolicyXposn" json:"FwPolicyXposnScheme,omitempty" meta:default=FW_POLICY_XPOSN_GLOBAL_PRIORITY`
	// enable the control plane stack for overlay routing
	// NOTE: when OverlayRoutingEn is modified, it will take affect only after
	//       next reboot of NAPLES/DSC
	OverlayRoutingEn bool `protobuf:"varint,11,opt,name=OverlayRoutingEn,proto3" json:"OverlayRoutingEn,omitempty" meta:mandatory`
	// when SymmetricRoutingEn is set to true, outgoing inter-subnet (encapped)
	// traffic carries VPC's VxLAN vnid and incoming inter-subnet (encapped)
	// traffic is expected to come with VPC's VxLAN vnid. If SymmetricRoutingEn is
	// set to false (default behavior), outgoing inter-subnet (encapped) traffic
	// carries egress subnet's VxLAN vnid and incoming inter-subnet (encapped)
	// traffic is expected to come with destination subnet's VxLAN vnid
	// NOTE: if the value of this attribute is updated on the fly, it will not
	//       affect the flows/sessions that are already created, but it will take
	//       affect only on the new sessions/flows created after such an update
	SymmetricRoutingEn bool `protobuf:"varint,12,opt,name=SymmetricRoutingEn,proto3" json:"SymmetricRoutingEn,omitempty" meta:default=false`
	// TxPolicerId, if configured, will rate limit the Tx bandwidth (bytes per
	// second) or PPS (packets per second) of all host interfaces put together
	// to the configured value
	TxPolicerId []byte `protobuf:"bytes,13,opt,name=TxPolicerId,proto3" json:"TxPolicerId,omitempty"`
	// SysName, if configured, will be used to advertise as system name in
	// protocols like LLDP etc. it cannot be longer than 64 bytes
	SysName string `protobuf:"bytes,14,opt,name=SysName,proto3" json:"SysName,omitempty"`
}

func (m *DeviceSpec) Reset()                    { *m = DeviceSpec{} }
func (m *DeviceSpec) String() string            { return proto.CompactTextString(m) }
func (*DeviceSpec) ProtoMessage()               {}
func (*DeviceSpec) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{2} }

func (m *DeviceSpec) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

func (m *DeviceSpec) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *DeviceSpec) GetGatewayIP() *IPAddress {
	if m != nil {
		return m.GatewayIP
	}
	return nil
}

func (m *DeviceSpec) GetDevOperMode() DeviceOperMode {
	if m != nil {
		return m.DevOperMode
	}
	return DeviceOperMode_DEVICE_OPER_MODE_NONE
}

func (m *DeviceSpec) GetMemoryProfile() MemoryProfile {
	if m != nil {
		return m.MemoryProfile
	}
	return MemoryProfile_MEMORY_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetDeviceProfile() DeviceProfile {
	if m != nil {
		return m.DeviceProfile
	}
	return DeviceProfile_DEVICE_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetBridgingEn() bool {
	if m != nil {
		return m.BridgingEn
	}
	return false
}

func (m *DeviceSpec) GetLearnSpec() *LearnSpec {
	if m != nil {
		return m.LearnSpec
	}
	return nil
}

func (m *DeviceSpec) GetIPMappingPriority() uint32 {
	if m != nil {
		return m.IPMappingPriority
	}
	return 0
}

func (m *DeviceSpec) GetFwPolicyXposnScheme() FwPolicyXposn {
	if m != nil {
		return m.FwPolicyXposnScheme
	}
	return FwPolicyXposn_FW_POLICY_XPOSN_NONE
}

func (m *DeviceSpec) GetOverlayRoutingEn() bool {
	if m != nil {
		return m.OverlayRoutingEn
	}
	return false
}

func (m *DeviceSpec) GetSymmetricRoutingEn() bool {
	if m != nil {
		return m.SymmetricRoutingEn
	}
	return false
}

func (m *DeviceSpec) GetTxPolicerId() []byte {
	if m != nil {
		return m.TxPolicerId
	}
	return nil
}

func (m *DeviceSpec) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

// operational status of the device, if any
type DeviceStatus struct {
	// operational state of the device
	State DeviceState `protobuf:"varint,1,opt,name=State,proto3,enum=pds.DeviceState" json:"State,omitempty"`
	// system MAC address (can be used to uniquely identify the device in cluster)
	SystemMACAddress uint64 `protobuf:"varint,2,opt,name=SystemMACAddress,proto3" json:"SystemMACAddress,omitempty"`
	// serial number of the device
	SerialNumber string `protobuf:"bytes,3,opt,name=SerialNumber,proto3" json:"SerialNumber,omitempty"`
	// SKU/part numnber
	Sku string `protobuf:"bytes,4,opt,name=Sku,proto3" json:"Sku,omitempty"`
	// version of the firmware running
	FirmwareVersion string `protobuf:"bytes,5,opt,name=FirmwareVersion,proto3" json:"FirmwareVersion,omitempty"`
	// memory capacity
	Memory uint32 `protobuf:"varint,6,opt,name=Memory,proto3" json:"Memory,omitempty"`
	// product name
	ProductName string `protobuf:"bytes,7,opt,name=ProductName,proto3" json:"ProductName,omitempty"`
	// manufacturing date
	ManufacturingDate string `protobuf:"bytes,8,opt,name=ManufacturingDate,proto3" json:"ManufacturingDate,omitempty"`
	// device description
	Description string `protobuf:"bytes,9,opt,name=Description,proto3" json:"Description,omitempty"`
	// vendor identifier
	VendorID string `protobuf:"bytes,10,opt,name=VendorID,proto3" json:"VendorID,omitempty"`
	// chip type
	ChipType AsicType `protobuf:"varint,11,opt,name=ChipType,proto3,enum=types.AsicType" json:"ChipType,omitempty"`
	// hardware revision
	HardwareRevision string `protobuf:"bytes,12,opt,name=HardwareRevision,proto3" json:"HardwareRevision,omitempty"`
	// CPU vendor
	CpuVendor string `protobuf:"bytes,13,opt,name=CpuVendor,proto3" json:"CpuVendor,omitempty"`
	// CPU specification
	CpuSpecification string `protobuf:"bytes,14,opt,name=CpuSpecification,proto3" json:"CpuSpecification,omitempty"`
	// SoC OS version
	SocOSVersion string `protobuf:"bytes,15,opt,name=SocOSVersion,proto3" json:"SocOSVersion,omitempty"`
	// SoC disk size
	SocDiskSize string `protobuf:"bytes,16,opt,name=SocDiskSize,proto3" json:"SocDiskSize,omitempty"`
	// PCIe specification
	PCIeSpecification string `protobuf:"bytes,17,opt,name=PCIeSpecification,proto3" json:"PCIeSpecification,omitempty"`
	// PCIe bus information
	PCIeBusInfo string `protobuf:"bytes,18,opt,name=PCIeBusInfo,proto3" json:"PCIeBusInfo,omitempty"`
	// number of PCIe ports
	NumPCIePorts uint32 `protobuf:"varint,19,opt,name=NumPCIePorts,proto3" json:"NumPCIePorts,omitempty"`
	// Number of uplink ports
	NumPorts uint32 `protobuf:"varint,20,opt,name=NumPorts,proto3" json:"NumPorts,omitempty"`
	// vendor name
	VendorName string `protobuf:"bytes,21,opt,name=VendorName,proto3" json:"VendorName,omitempty"`
	// PXE version
	PXEVersion float32 `protobuf:"fixed32,22,opt,name=PXEVersion,proto3" json:"PXEVersion,omitempty"`
	// UEFI version
	UEFIVersion float32 `protobuf:"fixed32,23,opt,name=UEFIVersion,proto3" json:"UEFIVersion,omitempty"`
	// number of host interfaces
	NumHostIf uint32 `protobuf:"varint,24,opt,name=NumHostIf,proto3" json:"NumHostIf,omitempty"`
	// version of the firmware running
	FirmwareDescription string `protobuf:"bytes,26,opt,name=FirmwareDescription,proto3" json:"FirmwareDescription,omitempty"`
	// version of the firmware running
	FirmwareBuildTime string `protobuf:"bytes,27,opt,name=FirmwareBuildTime,proto3" json:"FirmwareBuildTime,omitempty"`
}

func (m *DeviceStatus) Reset()                    { *m = DeviceStatus{} }
func (m *DeviceStatus) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatus) ProtoMessage()               {}
func (*DeviceStatus) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{3} }

func (m *DeviceStatus) GetState() DeviceState {
	if m != nil {
		return m.State
	}
	return DeviceState_SWITCH_STATE_NONE
}

func (m *DeviceStatus) GetSystemMACAddress() uint64 {
	if m != nil {
		return m.SystemMACAddress
	}
	return 0
}

func (m *DeviceStatus) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *DeviceStatus) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *DeviceStatus) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *DeviceStatus) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DeviceStatus) GetManufacturingDate() string {
	if m != nil {
		return m.ManufacturingDate
	}
	return ""
}

func (m *DeviceStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DeviceStatus) GetVendorID() string {
	if m != nil {
		return m.VendorID
	}
	return ""
}

func (m *DeviceStatus) GetChipType() AsicType {
	if m != nil {
		return m.ChipType
	}
	return AsicType_ASIC_TYPE_NONE
}

func (m *DeviceStatus) GetHardwareRevision() string {
	if m != nil {
		return m.HardwareRevision
	}
	return ""
}

func (m *DeviceStatus) GetCpuVendor() string {
	if m != nil {
		return m.CpuVendor
	}
	return ""
}

func (m *DeviceStatus) GetCpuSpecification() string {
	if m != nil {
		return m.CpuSpecification
	}
	return ""
}

func (m *DeviceStatus) GetSocOSVersion() string {
	if m != nil {
		return m.SocOSVersion
	}
	return ""
}

func (m *DeviceStatus) GetSocDiskSize() string {
	if m != nil {
		return m.SocDiskSize
	}
	return ""
}

func (m *DeviceStatus) GetPCIeSpecification() string {
	if m != nil {
		return m.PCIeSpecification
	}
	return ""
}

func (m *DeviceStatus) GetPCIeBusInfo() string {
	if m != nil {
		return m.PCIeBusInfo
	}
	return ""
}

func (m *DeviceStatus) GetNumPCIePorts() uint32 {
	if m != nil {
		return m.NumPCIePorts
	}
	return 0
}

func (m *DeviceStatus) GetNumPorts() uint32 {
	if m != nil {
		return m.NumPorts
	}
	return 0
}

func (m *DeviceStatus) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *DeviceStatus) GetPXEVersion() float32 {
	if m != nil {
		return m.PXEVersion
	}
	return 0
}

func (m *DeviceStatus) GetUEFIVersion() float32 {
	if m != nil {
		return m.UEFIVersion
	}
	return 0
}

func (m *DeviceStatus) GetNumHostIf() uint32 {
	if m != nil {
		return m.NumHostIf
	}
	return 0
}

func (m *DeviceStatus) GetFirmwareDescription() string {
	if m != nil {
		return m.FirmwareDescription
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareBuildTime() string {
	if m != nil {
		return m.FirmwareBuildTime
	}
	return ""
}

// stats of the device, if any
type DeviceStatsEntry struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *DeviceStatsEntry) Reset()                    { *m = DeviceStatsEntry{} }
func (m *DeviceStatsEntry) String() string            { return proto.CompactTextString(m) }
func (*DeviceStatsEntry) ProtoMessage()               {}
func (*DeviceStatsEntry) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{4} }

func (m *DeviceStatsEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceStatsEntry) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DeviceStats struct {
	Ingress []*DeviceStatsEntry `protobuf:"bytes,1,rep,name=Ingress" json:"Ingress,omitempty"`
	Egress  []*DeviceStatsEntry `protobuf:"bytes,2,rep,name=Egress" json:"Egress,omitempty"`
}

func (m *DeviceStats) Reset()                    { *m = DeviceStats{} }
func (m *DeviceStats) String() string            { return proto.CompactTextString(m) }
func (*DeviceStats) ProtoMessage()               {}
func (*DeviceStats) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{5} }

func (m *DeviceStats) GetIngress() []*DeviceStatsEntry {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *DeviceStats) GetEgress() []*DeviceStatsEntry {
	if m != nil {
		return m.Egress
	}
	return nil
}

// device object
type Device struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *DeviceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *DeviceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *DeviceStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{6} }

func (m *Device) GetSpec() *DeviceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Device) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Device) GetStats() *DeviceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// device create and update request
type DeviceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt  `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   *DeviceSpec `protobuf:"bytes,2,opt,name=Request" json:"Request,omitempty"`
}

func (m *DeviceRequest) Reset()                    { *m = DeviceRequest{} }
func (m *DeviceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceRequest) ProtoMessage()               {}
func (*DeviceRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{7} }

func (m *DeviceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *DeviceRequest) GetRequest() *DeviceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// device create and update response
type DeviceResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *DeviceStatus `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceResponse) Reset()                    { *m = DeviceResponse{} }
func (m *DeviceResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceResponse) ProtoMessage()               {}
func (*DeviceResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{8} }

func (m *DeviceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceResponse) GetResponse() *DeviceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// device get request
type DeviceGetRequest struct {
}

func (m *DeviceGetRequest) Reset()                    { *m = DeviceGetRequest{} }
func (m *DeviceGetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetRequest) ProtoMessage()               {}
func (*DeviceGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{9} }

// device get response
type DeviceGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *Device   `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *DeviceGetResponse) Reset()                    { *m = DeviceGetResponse{} }
func (m *DeviceGetResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceGetResponse) ProtoMessage()               {}
func (*DeviceGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{10} }

func (m *DeviceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceGetResponse) GetResponse() *Device {
	if m != nil {
		return m.Response
	}
	return nil
}

// device delete request
type DeviceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
}

func (m *DeviceDeleteRequest) Reset()                    { *m = DeviceDeleteRequest{} }
func (m *DeviceDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteRequest) ProtoMessage()               {}
func (*DeviceDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{11} }

func (m *DeviceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

// device delete response
type DeviceDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *DeviceDeleteResponse) Reset()                    { *m = DeviceDeleteResponse{} }
func (m *DeviceDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeviceDeleteResponse) ProtoMessage()               {}
func (*DeviceDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDevice, []int{12} }

func (m *DeviceDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterType((*LearnSource)(nil), "pds.LearnSource")
	proto.RegisterType((*LearnSpec)(nil), "pds.LearnSpec")
	proto.RegisterType((*DeviceSpec)(nil), "pds.DeviceSpec")
	proto.RegisterType((*DeviceStatus)(nil), "pds.DeviceStatus")
	proto.RegisterType((*DeviceStatsEntry)(nil), "pds.DeviceStatsEntry")
	proto.RegisterType((*DeviceStats)(nil), "pds.DeviceStats")
	proto.RegisterType((*Device)(nil), "pds.Device")
	proto.RegisterType((*DeviceRequest)(nil), "pds.DeviceRequest")
	proto.RegisterType((*DeviceResponse)(nil), "pds.DeviceResponse")
	proto.RegisterType((*DeviceGetRequest)(nil), "pds.DeviceGetRequest")
	proto.RegisterType((*DeviceGetResponse)(nil), "pds.DeviceGetResponse")
	proto.RegisterType((*DeviceDeleteRequest)(nil), "pds.DeviceDeleteRequest")
	proto.RegisterType((*DeviceDeleteResponse)(nil), "pds.DeviceDeleteResponse")
	proto.RegisterEnum("pds.MemoryProfile", MemoryProfile_name, MemoryProfile_value)
	proto.RegisterEnum("pds.DeviceProfile", DeviceProfile_name, DeviceProfile_value)
	proto.RegisterEnum("pds.DeviceOperMode", DeviceOperMode_name, DeviceOperMode_value)
	proto.RegisterEnum("pds.LearnMode", LearnMode_name, LearnMode_value)
	proto.RegisterEnum("pds.DeviceState", DeviceState_name, DeviceState_value)
	proto.RegisterEnum("pds.DeviceHealth", DeviceHealth_name, DeviceHealth_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeviceSvc service

type DeviceSvcClient interface {
	DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error)
	DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error)
	DeviceStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type deviceSvcClient struct {
	cc *grpc.ClientConn
}

func NewDeviceSvcClient(cc *grpc.ClientConn) DeviceSvcClient {
	return &deviceSvcClient{cc}
}

func (c *deviceSvcClient) DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error) {
	out := new(DeviceGetResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error) {
	out := new(DeviceDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/pds.DeviceSvc/DeviceStatsReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DeviceSvc service

type DeviceSvcServer interface {
	DeviceCreate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceUpdate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error)
	DeviceDelete(context.Context, *DeviceDeleteRequest) (*DeviceDeleteResponse, error)
	DeviceStatsReset(context.Context, *Empty) (*Empty, error)
}

func RegisterDeviceSvcServer(s *grpc.Server, srv DeviceSvcServer) {
	s.RegisterService(&_DeviceSvc_serviceDesc, srv)
}

func _DeviceSvc_DeviceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceGet(ctx, req.(*DeviceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, req.(*DeviceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceStatsReset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeviceSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.DeviceSvc",
	HandlerType: (*DeviceSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeviceCreate",
			Handler:    _DeviceSvc_DeviceCreate_Handler,
		},
		{
			MethodName: "DeviceUpdate",
			Handler:    _DeviceSvc_DeviceUpdate_Handler,
		},
		{
			MethodName: "DeviceGet",
			Handler:    _DeviceSvc_DeviceGet_Handler,
		},
		{
			MethodName: "DeviceDelete",
			Handler:    _DeviceSvc_DeviceDelete_Handler,
		},
		{
			MethodName: "DeviceStatsReset",
			Handler:    _DeviceSvc_DeviceStatsReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "device.proto",
}

func (m *LearnSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArpLearnEn {
		dAtA[i] = 0x8
		i++
		if m.ArpLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DhcpLearnEn {
		dAtA[i] = 0x10
		i++
		if m.DhcpLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DataPktLearnEn {
		dAtA[i] = 0x18
		i++
		if m.DataPktLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LearnSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LearnMode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnMode))
	}
	if m.LearnAgeTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnAgeTimeout))
	}
	if m.LearnSource != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnSource.Size()))
		n1, err := m.LearnSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DeviceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.IPAddr.Size()))
		n2, err := m.IPAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.MACAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.GatewayIP.Size()))
		n3, err := m.GatewayIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DevOperMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		dAtA[i] = 0x38
		i++
		if m.BridgingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSpec != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.LearnSpec.Size()))
		n4, err := m.LearnSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IPMappingPriority != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.IPMappingPriority))
	}
	if m.FwPolicyXposnScheme != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.FwPolicyXposnScheme))
	}
	if m.OverlayRoutingEn {
		dAtA[i] = 0x58
		i++
		if m.OverlayRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SymmetricRoutingEn {
		dAtA[i] = 0x60
		i++
		if m.SymmetricRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TxPolicerId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.TxPolicerId)))
		i += copy(dAtA[i:], m.TxPolicerId)
	}
	if len(m.SysName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SysName)))
		i += copy(dAtA[i:], m.SysName)
	}
	return i, nil
}

func (m *DeviceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.SystemMACAddress))
	}
	if len(m.SerialNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SerialNumber)))
		i += copy(dAtA[i:], m.SerialNumber)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.FirmwareVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareVersion)))
		i += copy(dAtA[i:], m.FirmwareVersion)
	}
	if m.Memory != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Memory))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.ManufacturingDate) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ManufacturingDate)))
		i += copy(dAtA[i:], m.ManufacturingDate)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.VendorID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorID)))
		i += copy(dAtA[i:], m.VendorID)
	}
	if m.ChipType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ChipType))
	}
	if len(m.HardwareRevision) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HardwareRevision)))
		i += copy(dAtA[i:], m.HardwareRevision)
	}
	if len(m.CpuVendor) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuVendor)))
		i += copy(dAtA[i:], m.CpuVendor)
	}
	if len(m.CpuSpecification) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuSpecification)))
		i += copy(dAtA[i:], m.CpuSpecification)
	}
	if len(m.SocOSVersion) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocOSVersion)))
		i += copy(dAtA[i:], m.SocOSVersion)
	}
	if len(m.SocDiskSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocDiskSize)))
		i += copy(dAtA[i:], m.SocDiskSize)
	}
	if len(m.PCIeSpecification) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeSpecification)))
		i += copy(dAtA[i:], m.PCIeSpecification)
	}
	if len(m.PCIeBusInfo) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeBusInfo)))
		i += copy(dAtA[i:], m.PCIeBusInfo)
	}
	if m.NumPCIePorts != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPCIePorts))
	}
	if m.NumPorts != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPorts))
	}
	if len(m.VendorName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorName)))
		i += copy(dAtA[i:], m.VendorName)
	}
	if m.PXEVersion != 0 {
		dAtA[i] = 0xb5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PXEVersion))))
		i += 4
	}
	if m.UEFIVersion != 0 {
		dAtA[i] = 0xbd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UEFIVersion))))
		i += 4
	}
	if m.NumHostIf != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.NumHostIf))
	}
	if len(m.FirmwareDescription) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareDescription)))
		i += copy(dAtA[i:], m.FirmwareDescription)
	}
	if len(m.FirmwareBuildTime) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareBuildTime)))
		i += copy(dAtA[i:], m.FirmwareBuildTime)
	}
	return i, nil
}

func (m *DeviceStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DeviceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDevice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.TypeMeta.Size()))
		n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ObjMeta.Size()))
		n6, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Spec.Size()))
		n7, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Status.Size()))
		n8, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Stats.Size()))
		n9, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n10, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Request.Size()))
		n11, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n12, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DeviceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeviceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.Response.Size()))
		n13, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DeviceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.BatchCtxt.Size()))
		n14, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *DeviceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LearnSource) Size() (n int) {
	var l int
	_ = l
	if m.ArpLearnEn {
		n += 2
	}
	if m.DhcpLearnEn {
		n += 2
	}
	if m.DataPktLearnEn {
		n += 2
	}
	return n
}

func (m *LearnSpec) Size() (n int) {
	var l int
	_ = l
	if m.LearnMode != 0 {
		n += 1 + sovDevice(uint64(m.LearnMode))
	}
	if m.LearnAgeTimeout != 0 {
		n += 1 + sovDevice(uint64(m.LearnAgeTimeout))
	}
	if m.LearnSource != nil {
		l = m.LearnSource.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceSpec) Size() (n int) {
	var l int
	_ = l
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovDevice(uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		l = m.GatewayIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.DevOperMode != 0 {
		n += 1 + sovDevice(uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		n += 1 + sovDevice(uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		n += 1 + sovDevice(uint64(m.DeviceProfile))
	}
	if m.BridgingEn {
		n += 2
	}
	if m.LearnSpec != nil {
		l = m.LearnSpec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.IPMappingPriority != 0 {
		n += 1 + sovDevice(uint64(m.IPMappingPriority))
	}
	if m.FwPolicyXposnScheme != 0 {
		n += 1 + sovDevice(uint64(m.FwPolicyXposnScheme))
	}
	if m.OverlayRoutingEn {
		n += 2
	}
	if m.SymmetricRoutingEn {
		n += 2
	}
	l = len(m.TxPolicerId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SysName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceStatus) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDevice(uint64(m.State))
	}
	if m.SystemMACAddress != 0 {
		n += 1 + sovDevice(uint64(m.SystemMACAddress))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovDevice(uint64(m.Memory))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ManufacturingDate)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ChipType != 0 {
		n += 1 + sovDevice(uint64(m.ChipType))
	}
	l = len(m.HardwareRevision)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuVendor)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuSpecification)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocOSVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocDiskSize)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeSpecification)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeBusInfo)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.NumPCIePorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPCIePorts))
	}
	if m.NumPorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPorts))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.PXEVersion != 0 {
		n += 6
	}
	if m.UEFIVersion != 0 {
		n += 6
	}
	if m.NumHostIf != 0 {
		n += 2 + sovDevice(uint64(m.NumHostIf))
	}
	l = len(m.FirmwareDescription)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareBuildTime)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceStatsEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovDevice(uint64(m.Count))
	}
	return n
}

func (m *DeviceStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceGetRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeviceGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	return n
}

func (m *DeviceDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	return n
}

func sovDevice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LearnSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArpLearnEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DhcpLearnEn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPktLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataPktLearnEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnMode", wireType)
			}
			m.LearnMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnMode |= (LearnMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnAgeTimeout", wireType)
			}
			m.LearnAgeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnAgeTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnSource == nil {
				m.LearnSource = &LearnSource{}
			}
			if err := m.LearnSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayIP == nil {
				m.GatewayIP = &IPAddress{}
			}
			if err := m.GatewayIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevOperMode", wireType)
			}
			m.DevOperMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevOperMode |= (DeviceOperMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryProfile", wireType)
			}
			m.MemoryProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryProfile |= (MemoryProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfile", wireType)
			}
			m.DeviceProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceProfile |= (DeviceProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BridgingEn = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnSpec == nil {
				m.LearnSpec = &LearnSpec{}
			}
			if err := m.LearnSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMappingPriority", wireType)
			}
			m.IPMappingPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPMappingPriority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwPolicyXposnScheme", wireType)
			}
			m.FwPolicyXposnScheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwPolicyXposnScheme |= (FwPolicyXposn(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlayRoutingEn = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymmetricRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SymmetricRoutingEn = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPolicerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxPolicerId = append(m.TxPolicerId[:0], dAtA[iNdEx:postIndex]...)
			if m.TxPolicerId == nil {
				m.TxPolicerId = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DeviceState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMACAddress", wireType)
			}
			m.SystemMACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemMACAddress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManufacturingDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManufacturingDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChipType", wireType)
			}
			m.ChipType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChipType |= (AsicType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpecification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSpecification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocOSVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocOSVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocDiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocDiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeSpecification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeSpecification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeBusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeBusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPCIePorts", wireType)
			}
			m.NumPCIePorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPCIePorts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPorts", wireType)
			}
			m.NumPorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPorts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PXEVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PXEVersion = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEFIVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UEFIVersion = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHostIf", wireType)
			}
			m.NumHostIf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumHostIf |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareBuildTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareBuildTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &DeviceStatsEntry{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &DeviceStatsEntry{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DeviceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DeviceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeviceSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &DeviceStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Device{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("device.proto", fileDescriptorDevice) }

var fileDescriptorDevice = []byte{
	// 1879 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5f, 0x73, 0xdb, 0xc6,
	0x11, 0x37, 0x28, 0x59, 0x12, 0x97, 0x92, 0x08, 0x1d, 0x25, 0x85, 0x66, 0x15, 0x51, 0x61, 0x33,
	0x89, 0xaa, 0xca, 0x0a, 0x23, 0x25, 0x71, 0x9a, 0x3f, 0xcd, 0x10, 0x24, 0x68, 0x61, 0x4a, 0x12,
	0xe8, 0x91, 0x92, 0xec, 0x27, 0x0e, 0x0c, 0x9e, 0x28, 0xc4, 0x24, 0x80, 0x02, 0x07, 0xd9, 0xec,
	0x6b, 0xbf, 0x47, 0x3f, 0x47, 0x1f, 0xda, 0xe9, 0xe4, 0xad, 0x8f, 0xf9, 0x04, 0x9c, 0x8e, 0x1f,
	0xdd, 0x37, 0x7e, 0x82, 0xce, 0x1d, 0x00, 0x12, 0x20, 0x59, 0x77, 0xe2, 0x17, 0x0d, 0xef, 0xb7,
	0xbb, 0xbf, 0xdb, 0xdd, 0xdb, 0xdd, 0x3b, 0x08, 0x36, 0x7b, 0xe4, 0xde, 0x34, 0xc8, 0x99, 0xe3,
	0xda, 0xd4, 0x46, 0x2b, 0x4e, 0xcf, 0x2b, 0x40, 0xdf, 0xee, 0xdb, 0x01, 0x50, 0xc8, 0x0e, 0x09,
	0xd5, 0x3f, 0x63, 0x7f, 0x42, 0x20, 0x43, 0x47, 0x0e, 0xf1, 0x82, 0x45, 0xe9, 0xef, 0x02, 0x64,
	0x1a, 0x44, 0x77, 0xad, 0xb6, 0xed, 0xbb, 0x06, 0x41, 0x5f, 0x02, 0x54, 0x5c, 0x87, 0x23, 0xb2,
	0x95, 0x17, 0x8e, 0x84, 0xe3, 0x0d, 0x69, 0x6f, 0x32, 0x2e, 0xee, 0x30, 0x82, 0x6f, 0x7a, 0xe4,
	0x56, 0xf7, 0x07, 0xf4, 0x7b, 0xea, 0xfa, 0x04, 0xc7, 0x14, 0xd1, 0x13, 0xc8, 0xd4, 0xee, 0x8c,
	0xa9, 0x5d, 0xea, 0x5d, 0x76, 0x71, 0x4d, 0xf4, 0x3d, 0x6c, 0xd7, 0x74, 0xaa, 0x6b, 0x2f, 0x69,
	0x64, 0xbb, 0xf2, 0x2e, 0xdb, 0x39, 0xe5, 0xd2, 0x5f, 0x52, 0x90, 0x0e, 0xdc, 0x77, 0x88, 0x81,
	0x5a, 0xe1, 0xa2, 0x69, 0xf7, 0x08, 0xf7, 0x7d, 0xfb, 0x7c, 0xfb, 0xcc, 0xe9, 0x79, 0x67, 0x53,
	0x54, 0x3a, 0x9a, 0x8c, 0x8b, 0x07, 0x09, 0xde, 0x86, 0x5c, 0xc1, 0xad, 0x6e, 0x53, 0xad, 0xc9,
	0xdd, 0x96, 0xda, 0x92, 0xf1, 0x8c, 0x02, 0x61, 0xc8, 0xf2, 0x45, 0xa5, 0x4f, 0x3a, 0xe6, 0x90,
	0xd8, 0x3e, 0xe5, 0x91, 0x6d, 0x49, 0xc7, 0x93, 0x71, 0xf1, 0x63, 0xce, 0xe2, 0xea, 0x56, 0x9f,
	0x7c, 0x73, 0x51, 0x7e, 0xfc, 0xf5, 0x57, 0x5f, 0x94, 0xcb, 0xa7, 0x09, 0xe6, 0x8b, 0x72, 0x19,
	0xcf, 0x13, 0x20, 0x9c, 0xc8, 0x37, 0x8f, 0x36, 0x73, 0x2e, 0xce, 0xbc, 0x0c, 0x70, 0xe9, 0x70,
	0x32, 0x2e, 0x16, 0xa6, 0x9e, 0x7c, 0xb4, 0xe0, 0x65, 0x9c, 0xa4, 0xf4, 0x9f, 0x35, 0x80, 0x1a,
	0x2f, 0x02, 0x9e, 0x86, 0x63, 0x58, 0x53, 0xb4, 0x4a, 0xaf, 0xe7, 0xf2, 0x1c, 0x30, 0xf6, 0xe0,
	0xc4, 0x03, 0x90, 0x78, 0x1e, 0x0e, 0xe5, 0x28, 0x0f, 0xeb, 0xcd, 0x4a, 0x95, 0xab, 0xb2, 0xc0,
	0x56, 0x71, 0xb4, 0x44, 0x67, 0x90, 0x7e, 0xaa, 0x53, 0xf2, 0x4a, 0x1f, 0x29, 0xda, 0xd4, 0xc9,
	0x79, 0x9a, 0x99, 0x0a, 0xea, 0x40, 0xa6, 0x46, 0xee, 0x55, 0x87, 0xb8, 0x3c, 0xf9, 0xab, 0x3c,
	0xf9, 0x39, 0x1e, 0x56, 0xe0, 0x59, 0x24, 0x92, 0x3e, 0x9c, 0x8c, 0x8b, 0x8f, 0x78, 0x9e, 0x86,
	0xba, 0xd5, 0xd3, 0xa9, 0xed, 0x8e, 0x4e, 0x8f, 0x1c, 0xe2, 0x7a, 0xa6, 0x47, 0x49, 0x0f, 0xc7,
	0x69, 0xd0, 0x35, 0x6c, 0x35, 0xc9, 0xd0, 0x76, 0x47, 0x9a, 0x6b, 0xdf, 0x9a, 0x03, 0x92, 0x7f,
	0xc8, 0x79, 0x11, 0xe7, 0x4d, 0x48, 0xa4, 0x83, 0xc9, 0xb8, 0x98, 0x9f, 0xa3, 0x9d, 0xb1, 0x26,
	0x69, 0x18, 0x6f, 0xe0, 0x55, 0xc4, 0xbb, 0x16, 0xe3, 0x4d, 0x48, 0xfe, 0x1f, 0x6f, 0x42, 0x19,
	0x9d, 0x03, 0x48, 0xae, 0xd9, 0xeb, 0x9b, 0x56, 0x5f, 0xb6, 0xf2, 0xeb, 0xbc, 0x92, 0xd1, 0x64,
	0x5c, 0xdc, 0x4e, 0x12, 0xe0, 0x98, 0x16, 0x3a, 0x8d, 0x55, 0x70, 0x7e, 0x83, 0x67, 0x3a, 0x56,
	0xb4, 0x0c, 0xc5, 0xb1, 0x12, 0xaf, 0xc2, 0x8e, 0xa2, 0x35, 0x75, 0xc7, 0x31, 0xad, 0xbe, 0xe6,
	0x9a, 0xb6, 0x6b, 0xd2, 0x51, 0x3e, 0xcd, 0x8b, 0x72, 0xd6, 0x32, 0x41, 0x51, 0x96, 0x1f, 0x7f,
	0x5e, 0x3e, 0xbf, 0xc0, 0x8b, 0xfa, 0xe8, 0x35, 0xe4, 0xea, 0xaf, 0x34, 0x7b, 0x60, 0x1a, 0xa3,
	0x67, 0x8e, 0xed, 0x59, 0x6d, 0xe3, 0x8e, 0x0c, 0x49, 0x1e, 0x78, 0x12, 0x76, 0xc3, 0x63, 0x4e,
	0x68, 0x48, 0xe5, 0xc9, 0xb8, 0x98, 0xac, 0xee, 0xfa, 0x4d, 0x57, 0x53, 0x1b, 0x4a, 0xf5, 0x79,
	0xf7, 0x99, 0xa6, 0xb6, 0x5b, 0xdd, 0xa7, 0x0d, 0x55, 0xaa, 0x34, 0xba, 0x1a, 0x56, 0x54, 0xac,
	0x74, 0x9e, 0xe3, 0x65, 0x5b, 0xa0, 0xdf, 0x83, 0xa8, 0xde, 0x13, 0x77, 0xa0, 0x8f, 0xb0, 0xed,
	0xd3, 0x20, 0x4d, 0x99, 0xff, 0x99, 0xa6, 0x05, 0x5d, 0x54, 0x07, 0xd4, 0x1e, 0x0d, 0x87, 0x84,
	0xba, 0xa6, 0x31, 0x63, 0xd8, 0xe4, 0x0c, 0xfb, 0x93, 0x71, 0x11, 0x25, 0x5c, 0xbc, 0xd5, 0x07,
	0x1e, 0xc1, 0x4b, 0x2c, 0xd0, 0x11, 0x64, 0x3a, 0xaf, 0xb9, 0x7b, 0xc4, 0x55, 0x7a, 0xf9, 0xad,
	0x23, 0xe1, 0x78, 0x13, 0xc7, 0x21, 0xd6, 0x1a, 0xed, 0x91, 0xd7, 0xd2, 0x87, 0x24, 0xbf, 0x7d,
	0x24, 0x1c, 0xa7, 0x71, 0xb4, 0x2c, 0xfd, 0xb4, 0x0e, 0x9b, 0x61, 0xb7, 0x51, 0x9d, 0xfa, 0x1e,
	0xfa, 0x04, 0x1e, 0xb2, 0x5f, 0xd1, 0xc8, 0x11, 0x63, 0x55, 0xc4, 0x71, 0x1c, 0x88, 0xd1, 0x09,
	0x88, 0xed, 0x91, 0x47, 0xc9, 0x30, 0x6c, 0x32, 0xe2, 0x79, 0x61, 0xdb, 0x2d, 0xe0, 0xa8, 0x04,
	0x9b, 0x6d, 0xe2, 0x9a, 0xfa, 0xa0, 0xe5, 0x0f, 0x5f, 0x10, 0x97, 0xb7, 0x60, 0x1a, 0x27, 0x30,
	0x24, 0xc2, 0x4a, 0xfb, 0xa5, 0xcf, 0x7b, 0x2d, 0x8d, 0xd9, 0x4f, 0x74, 0x0c, 0xd9, 0xba, 0xe9,
	0x0e, 0x5f, 0xe9, 0x2e, 0xb9, 0x66, 0x35, 0x6a, 0x5b, 0xbc, 0x63, 0xd2, 0x78, 0x1e, 0x46, 0xfb,
	0xb0, 0x16, 0xb4, 0x04, 0x2f, 0xfd, 0x2d, 0x1c, 0xae, 0x58, 0x62, 0x34, 0xd7, 0xee, 0xf9, 0x06,
	0xe5, 0xa1, 0xaf, 0x73, 0xeb, 0x38, 0x84, 0x4e, 0x61, 0xa7, 0xa9, 0x5b, 0xfe, 0xad, 0x6e, 0x50,
	0xdf, 0x35, 0xad, 0x7e, 0x8d, 0x45, 0xbe, 0xc1, 0xf5, 0x16, 0x05, 0x8c, 0xaf, 0x46, 0x3c, 0xc3,
	0x35, 0x1d, 0xca, 0xbc, 0x49, 0x07, 0x7c, 0x31, 0x08, 0x15, 0x60, 0xe3, 0x9a, 0x58, 0x3d, 0xdb,
	0x55, 0x6a, 0xbc, 0x02, 0xd3, 0x78, 0xba, 0x46, 0xbf, 0x85, 0x8d, 0xea, 0x9d, 0xe9, 0x74, 0x46,
	0x0e, 0xe1, 0x65, 0xb2, 0x7d, 0x9e, 0x0d, 0xab, 0xb3, 0xe2, 0x99, 0x06, 0x83, 0xf1, 0x54, 0x81,
	0xa5, 0xf7, 0x52, 0x77, 0x7b, 0x2c, 0x4a, 0x4c, 0xee, 0x4d, 0x1e, 0xfd, 0x26, 0x27, 0x5c, 0xc0,
	0xd1, 0x01, 0xa4, 0xab, 0x8e, 0x1f, 0xec, 0xc3, 0x4f, 0x3f, 0x8d, 0x67, 0x00, 0x63, 0xaa, 0x3a,
	0x3e, 0xeb, 0x37, 0xf3, 0xd6, 0x34, 0x74, 0xee, 0x79, 0x50, 0x04, 0x0b, 0x38, 0x3f, 0x28, 0xdb,
	0x50, 0xdb, 0x51, 0xbe, 0xb3, 0xe1, 0x41, 0xc5, 0x30, 0x96, 0x84, 0xb6, 0x6d, 0xd4, 0x4c, 0xef,
	0x65, 0xdb, 0xfc, 0x33, 0xc9, 0x8b, 0x41, 0x12, 0x62, 0x10, 0x4b, 0xaa, 0x56, 0x55, 0x48, 0x72,
	0xcb, 0x9d, 0x20, 0xa9, 0x0b, 0x02, 0x7e, 0x48, 0x55, 0x85, 0x48, 0xbe, 0xa7, 0x58, 0xb7, 0x76,
	0x1e, 0x85, 0x87, 0x34, 0x83, 0x98, 0x57, 0x2d, 0x7f, 0xc8, 0x10, 0xcd, 0x76, 0xa9, 0x97, 0xcf,
	0xf1, 0x43, 0x4e, 0x60, 0x2c, 0xf1, 0x6c, 0xcd, 0xe5, 0xbb, 0x5c, 0x3e, 0x5d, 0xa3, 0x43, 0x80,
	0x20, 0x17, 0xbc, 0x0a, 0xf6, 0xf8, 0x06, 0x31, 0x84, 0xc9, 0xb5, 0x67, 0x72, 0x14, 0xf3, 0xfe,
	0x91, 0x70, 0x9c, 0xc2, 0x31, 0x84, 0x79, 0x78, 0x25, 0xd7, 0x95, 0x48, 0xe1, 0x03, 0xae, 0x10,
	0x87, 0xd8, 0x09, 0xb4, 0xfc, 0xe1, 0xa5, 0xed, 0x51, 0xe5, 0x36, 0x9f, 0xe7, 0xdb, 0xcf, 0x00,
	0x54, 0x86, 0x5c, 0x54, 0xb1, 0xf1, 0xf2, 0x29, 0x70, 0x47, 0x96, 0x89, 0x58, 0x06, 0x23, 0x58,
	0xf2, 0xcd, 0x41, 0x8f, 0xdd, 0xb7, 0xf9, 0x5f, 0x05, 0x19, 0x5c, 0x10, 0x94, 0xbe, 0x03, 0x71,
	0xd6, 0xa0, 0x9e, 0x6c, 0x51, 0x77, 0x84, 0x10, 0xac, 0xf2, 0x68, 0x05, 0x6e, 0xc4, 0x7f, 0xa3,
	0x5d, 0x78, 0x58, 0xb5, 0x7d, 0x8b, 0x86, 0x7d, 0x1a, 0x2c, 0x4a, 0x43, 0x7e, 0xd9, 0x45, 0xd6,
	0xe8, 0x33, 0x58, 0x57, 0xac, 0x3e, 0x6f, 0x67, 0xe1, 0x68, 0xe5, 0x38, 0x73, 0xbe, 0x37, 0x37,
	0x01, 0x82, 0x0d, 0x70, 0xa4, 0x85, 0x1e, 0xc3, 0x9a, 0xdc, 0x0f, 0xdb, 0xff, 0x1d, 0xfa, 0xa1,
	0x52, 0xe9, 0x1f, 0x29, 0x58, 0x0b, 0x84, 0xe8, 0x5b, 0xd8, 0x60, 0xb5, 0xde, 0x24, 0x54, 0x0f,
	0x2f, 0xf7, 0xed, 0x33, 0xfe, 0xb4, 0x8b, 0x50, 0x29, 0xfb, 0xf3, 0xb8, 0x28, 0xbc, 0x1d, 0x17,
	0xd7, 0x4f, 0x4d, 0x6b, 0x60, 0x5a, 0x04, 0x4f, 0x0d, 0xd0, 0x0f, 0xb0, 0xae, 0xbe, 0xf8, 0x91,
	0xdb, 0xa6, 0xb8, 0xed, 0x56, 0x60, 0x1b, 0x82, 0xd2, 0x7e, 0x68, 0xca, 0xc7, 0xf0, 0xa9, 0x3d,
	0x34, 0x29, 0x19, 0x3a, 0x74, 0x84, 0x23, 0x2b, 0xf4, 0x04, 0x56, 0xf9, 0x2d, 0x15, 0xbc, 0x07,
	0xb2, 0x71, 0xaf, 0x1d, 0x62, 0x48, 0x88, 0xd9, 0x7a, 0x0e, 0x31, 0x62, 0xb6, 0xdc, 0x00, 0xfd,
	0x00, 0x6b, 0xc1, 0xac, 0xe4, 0xc3, 0x2a, 0x73, 0xbe, 0x33, 0x17, 0xb0, 0xef, 0x49, 0xbb, 0x6f,
	0xc7, 0x45, 0xd1, 0xe3, 0xbf, 0x63, 0xe6, 0xa1, 0x19, 0xfa, 0x36, 0x18, 0xb1, 0x1e, 0x1f, 0x67,
	0x99, 0x85, 0x11, 0xeb, 0x49, 0xb9, 0xb7, 0xe3, 0x62, 0x96, 0x99, 0xc7, 0xad, 0x03, 0x9b, 0xd2,
	0x8f, 0xd1, 0x6d, 0x8f, 0xc9, 0x9f, 0x7c, 0xe2, 0x51, 0xf6, 0xb8, 0x91, 0x74, 0x6a, 0xdc, 0x55,
	0xe9, 0x6b, 0x3a, 0xf7, 0x46, 0x9a, 0xe2, 0x78, 0xa6, 0x82, 0x7e, 0x03, 0xeb, 0xa1, 0x69, 0x98,
	0xb8, 0xf9, 0xd0, 0x71, 0x24, 0x2f, 0xd9, 0xb0, 0x1d, 0xed, 0xe5, 0x39, 0xb6, 0xe5, 0x11, 0xb6,
	0x59, 0xc5, 0x31, 0xc3, 0xf0, 0xa3, 0x1b, 0x22, 0x1c, 0x62, 0x11, 0x8e, 0x67, 0x2a, 0xe8, 0x31,
	0x6c, 0x44, 0xb6, 0xe1, 0x6e, 0x8b, 0xd9, 0xc2, 0x53, 0x95, 0x12, 0x8a, 0x2a, 0xf9, 0x29, 0xa1,
	0x91, 0x13, 0x03, 0xd8, 0x89, 0x61, 0xef, 0xe9, 0xc7, 0xa7, 0x0b, 0x7e, 0x64, 0x62, 0x7e, 0xc4,
	0x3c, 0x90, 0x21, 0x17, 0x60, 0x35, 0x32, 0x20, 0xf4, 0x7d, 0x93, 0x5c, 0xaa, 0xc3, 0x6e, 0x92,
	0xe6, 0xfd, 0xfc, 0x3e, 0xa9, 0xcf, 0xbd, 0x19, 0x51, 0x01, 0xf6, 0x9b, 0x72, 0x53, 0xc5, 0xcf,
	0xbb, 0x1a, 0x56, 0xeb, 0x4a, 0x43, 0xee, 0xd6, 0xe4, 0x7a, 0xe5, 0xaa, 0xd1, 0x11, 0x1f, 0xa0,
	0x47, 0xb0, 0x37, 0x27, 0xc3, 0xea, 0x55, 0x47, 0xc6, 0xa2, 0x70, 0xf2, 0xd7, 0xd4, 0xdc, 0x23,
	0x91, 0x11, 0xd5, 0xe4, 0x6b, 0xa5, 0x2a, 0x2f, 0x21, 0xda, 0x07, 0x34, 0x27, 0x3b, 0xd7, 0xea,
	0xa2, 0xb0, 0x04, 0xbf, 0xd0, 0xea, 0x62, 0x6a, 0x09, 0xfe, 0x85, 0x56, 0x17, 0x57, 0x96, 0xe0,
	0x5f, 0x6a, 0x75, 0x71, 0x75, 0x09, 0xfe, 0x95, 0x56, 0x17, 0x1f, 0x2e, 0xc1, 0x9f, 0x68, 0x75,
	0x71, 0x6d, 0x09, 0xfe, 0xb5, 0x56, 0x17, 0xd7, 0xd1, 0x07, 0x90, 0x9b, 0xc3, 0x3f, 0x67, 0x44,
	0x1b, 0x4b, 0x04, 0x17, 0x2c, 0x82, 0xf4, 0x52, 0xc1, 0x75, 0x5d, 0x84, 0x93, 0x9f, 0x84, 0xa8,
	0xd6, 0xa7, 0xef, 0xf5, 0x47, 0xb0, 0x17, 0xea, 0xaa, 0x9a, 0x8c, 0x67, 0x9f, 0x2b, 0x41, 0xa6,
	0x17, 0x44, 0x97, 0x6a, 0xbb, 0x23, 0x0a, 0xe8, 0x13, 0x28, 0x2d, 0x88, 0x24, 0xa5, 0x73, 0xd3,
	0x6d, 0x37, 0x2b, 0xb8, 0xd3, 0x6d, 0xdf, 0x28, 0x9d, 0xea, 0xa5, 0x98, 0x42, 0x9f, 0xc2, 0xaf,
	0xdf, 0xa9, 0x27, 0x63, 0x26, 0x14, 0x57, 0xd0, 0x31, 0x7c, 0xbc, 0x5c, 0xb1, 0xda, 0xa8, 0xb4,
	0xdb, 0x4a, 0x35, 0xa2, 0x5c, 0x3d, 0x69, 0xc4, 0xbe, 0x18, 0x51, 0x0e, 0xb2, 0x73, 0x9f, 0x59,
	0xe2, 0x03, 0xb4, 0x07, 0x3b, 0x09, 0xb0, 0xa3, 0xd4, 0x9f, 0x8b, 0xc2, 0x9c, 0x6e, 0xe5, 0xaa,
	0xa3, 0x8a, 0xa9, 0x93, 0xdb, 0xf8, 0xbd, 0x40, 0x98, 0x69, 0xb0, 0x51, 0xb7, 0xdd, 0xa9, 0x74,
	0xa6, 0x8c, 0x39, 0xc8, 0x26, 0xe0, 0x2b, 0x4d, 0x14, 0x16, 0x74, 0x6b, 0xea, 0x4d, 0x4b, 0x4c,
	0xa1, 0x5d, 0x10, 0x13, 0xb0, 0x8c, 0xb1, 0xb8, 0x72, 0xf2, 0x4f, 0x21, 0x7a, 0x81, 0x5e, 0x12,
	0x7d, 0x40, 0xef, 0x62, 0xa7, 0x7d, 0x29, 0x57, 0x1a, 0x9d, 0xcb, 0x68, 0xab, 0x5d, 0x10, 0x93,
	0xb8, 0xfa, 0x07, 0x51, 0x40, 0x87, 0x50, 0x48, 0xa2, 0x61, 0xe6, 0xa2, 0x4d, 0x3f, 0x82, 0x0f,
	0x93, 0x72, 0x2c, 0x4b, 0xaa, 0xda, 0xe9, 0x62, 0xf9, 0x8f, 0x57, 0x0a, 0x96, 0x6b, 0xe2, 0x0a,
	0x3a, 0x80, 0x7c, 0x52, 0xa5, 0xa1, 0xde, 0x74, 0x83, 0x4e, 0x12, 0x57, 0xd1, 0x11, 0x1c, 0x24,
	0xa5, 0x97, 0x15, 0x5c, 0xbb, 0xa9, 0x60, 0xee, 0xbf, 0x8a, 0xc5, 0x87, 0xe7, 0x7f, 0x4b, 0x41,
	0x3a, 0x4c, 0xd5, 0xbd, 0x81, 0x7e, 0x17, 0x85, 0x53, 0x75, 0x09, 0x4b, 0x5c, 0xfc, 0x3b, 0x2c,
	0x1c, 0x27, 0x85, 0x5c, 0x02, 0x0b, 0x47, 0xcf, 0x83, 0x99, 0xe9, 0x95, 0xd3, 0xfb, 0x85, 0xa6,
	0xdf, 0x45, 0x2e, 0x3c, 0x25, 0x14, 0xc5, 0xaf, 0xe0, 0xd9, 0x24, 0x2d, 0xec, 0xcf, 0xc3, 0x53,
	0x6b, 0x39, 0xda, 0x38, 0x18, 0x57, 0x28, 0x1f, 0xd3, 0x4c, 0x0c, 0xc2, 0xc2, 0xa3, 0x25, 0x92,
	0x29, 0x4d, 0x39, 0xf1, 0x10, 0xc1, 0xc4, 0x23, 0x14, 0x6d, 0x86, 0xe3, 0x4d, 0x66, 0x97, 0x58,
	0x21, 0xb1, 0x2a, 0x3d, 0x90, 0x36, 0xff, 0xf5, 0xe6, 0x50, 0xf8, 0xf9, 0xcd, 0xa1, 0xf0, 0xef,
	0x37, 0x87, 0xc2, 0x8b, 0x35, 0xfe, 0x6f, 0x9c, 0x8b, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x79,
	0x02, 0x3f, 0xa9, 0x05, 0x12, 0x00, 0x00,
}
