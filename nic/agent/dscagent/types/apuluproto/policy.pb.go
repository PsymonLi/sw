// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policy.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// security rule attributes
type SecurityRuleAttrs struct {
	// stateful rule results in flow/session creation whereas stateless rule
	// will not result in flow creation
	Stateful bool `protobuf:"varint,1,opt,name=Stateful,proto3" json:"Stateful,omitempty" meta:mandatory`
	// priority of this rule (lower the numeric value, higher the priority is)
	Priority uint32 `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty" meta:range:0-1022`
	// rule match criteria
	Match *RuleMatch `protobuf:"bytes,3,opt,name=Match" json:"Match,omitempty"`
	// action to take when this rule is matched
	Action SecurityRuleAction `protobuf:"varint,4,opt,name=Action,proto3,enum=types.SecurityRuleAction" json:"Action,omitempty" meta:mandatory`
}

func (m *SecurityRuleAttrs) Reset()                    { *m = SecurityRuleAttrs{} }
func (m *SecurityRuleAttrs) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleAttrs) ProtoMessage()               {}
func (*SecurityRuleAttrs) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{0} }

func (m *SecurityRuleAttrs) GetStateful() bool {
	if m != nil {
		return m.Stateful
	}
	return false
}

func (m *SecurityRuleAttrs) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SecurityRuleAttrs) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *SecurityRuleAttrs) GetAction() SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

// SecurityRuleInfo is a single rule in the security policy
type SecurityRuleInfo struct {
	// optional rule id needed if incremental route ADD/DEL/UPD functionality is needed
	Id    []byte             `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Attrs *SecurityRuleAttrs `protobuf:"bytes,2,opt,name=Attrs" json:"Attrs,omitempty" meta:mandatory`
}

func (m *SecurityRuleInfo) Reset()                    { *m = SecurityRuleInfo{} }
func (m *SecurityRuleInfo) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleInfo) ProtoMessage()               {}
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{1} }

func (m *SecurityRuleInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleInfo) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// security policy configuration
type SecurityPolicySpec struct {
	// unique identifier of security policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// IPv4 or IPv6 policy
	AddrFamily IPAF `protobuf:"varint,2,opt,name=AddrFamily,proto3,enum=types.IPAF" json:"AddrFamily,omitempty" meta:mandatory,immutable`
	// DefaultFWAction is the action taken by the firewall when SG policies are
	// configured on vnic but no rule is hit. Similarly, when NACLs are configured
	// on a subnet and no rule is hit, this action is taken by the firewall
	// if this attribute is not set, by default "allow" action is assumed
	DefaultFWAction SecurityRuleAction `protobuf:"varint,3,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_ALLOW`
	// list of security rules
	Rules []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=Rules" json:"Rules,omitempty" meta:mandatory`
}

func (m *SecurityPolicySpec) Reset()                    { *m = SecurityPolicySpec{} }
func (m *SecurityPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicySpec) ProtoMessage()               {}
func (*SecurityPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{2} }

func (m *SecurityPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicySpec) GetAddrFamily() IPAF {
	if m != nil {
		return m.AddrFamily
	}
	return IPAF_IP_AF_NONE
}

func (m *SecurityPolicySpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityPolicySpec) GetRules() []*SecurityRuleInfo {
	if m != nil {
		return m.Rules
	}
	return nil
}

// operational status of security policy, if any
type SecurityPolicyStatus struct {
}

func (m *SecurityPolicyStatus) Reset()                    { *m = SecurityPolicyStatus{} }
func (m *SecurityPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStatus) ProtoMessage()               {}
func (*SecurityPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{3} }

// stats of security policy, if any
type SecurityPolicyStats struct {
}

func (m *SecurityPolicyStats) Reset()                    { *m = SecurityPolicyStats{} }
func (m *SecurityPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStats) ProtoMessage()               {}
func (*SecurityPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{4} }

// security policy object
type SecurityPolicy struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityPolicyStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityPolicy) Reset()                    { *m = SecurityPolicy{} }
func (m *SecurityPolicy) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicy) ProtoMessage()               {}
func (*SecurityPolicy) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{5} }

func (m *SecurityPolicy) GetSpec() *SecurityPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityPolicy) GetStatus() *SecurityPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityPolicy) GetStats() *SecurityPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy create and update request
type SecurityPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt            `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   []*SecurityPolicySpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *SecurityPolicyRequest) Reset()                    { *m = SecurityPolicyRequest{} }
func (m *SecurityPolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyRequest) ProtoMessage()               {}
func (*SecurityPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{6} }

func (m *SecurityPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyRequest) GetRequest() []*SecurityPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy create and update response
type SecurityPolicyResponse struct {
	ApiStatus ApiStatus               `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityPolicyStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityPolicyResponse) Reset()                    { *m = SecurityPolicyResponse{} }
func (m *SecurityPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyResponse) ProtoMessage()               {}
func (*SecurityPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{7} }

func (m *SecurityPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyResponse) GetResponse() []*SecurityPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy get request
type SecurityPolicyGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityPolicyGetRequest) Reset()                    { *m = SecurityPolicyGetRequest{} }
func (m *SecurityPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetRequest) ProtoMessage()               {}
func (*SecurityPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{8} }

func (m *SecurityPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy get response
type SecurityPolicyGetResponse struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityPolicy `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityPolicyGetResponse) Reset()                    { *m = SecurityPolicyGetResponse{} }
func (m *SecurityPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetResponse) ProtoMessage()               {}
func (*SecurityPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{9} }

func (m *SecurityPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyGetResponse) GetResponse() []*SecurityPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy delete request
type SecurityPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityPolicyDeleteRequest) Reset()         { *m = SecurityPolicyDeleteRequest{} }
func (m *SecurityPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{10}
}

func (m *SecurityPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy delete response
type SecurityPolicyDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityPolicyDeleteResponse) Reset()         { *m = SecurityPolicyDeleteResponse{} }
func (m *SecurityPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{11}
}

func (m *SecurityPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// unique id to identify a security policy rule
type SecurityPolicyRuleId struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId []byte `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
}

func (m *SecurityPolicyRuleId) Reset()                    { *m = SecurityPolicyRuleId{} }
func (m *SecurityPolicyRuleId) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyRuleId) ProtoMessage()               {}
func (*SecurityPolicyRuleId) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{12} }

func (m *SecurityPolicyRuleId) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicyRuleId) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

// security rule configuration
type SecurityRuleSpec struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId []byte `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
	// rule information
	Attrs *SecurityRuleAttrs `protobuf:"bytes,3,opt,name=Attrs" json:"Attrs,omitempty" meta:mandatory`
}

func (m *SecurityRuleSpec) Reset()                    { *m = SecurityRuleSpec{} }
func (m *SecurityRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleSpec) ProtoMessage()               {}
func (*SecurityRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{13} }

func (m *SecurityRuleSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleSpec) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

func (m *SecurityRuleSpec) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// operational status of the security rule, if any
type SecurityRuleStatus struct {
}

func (m *SecurityRuleStatus) Reset()                    { *m = SecurityRuleStatus{} }
func (m *SecurityRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStatus) ProtoMessage()               {}
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{14} }

// stats of the security rule, if any
type SecurityRuleStats struct {
}

func (m *SecurityRuleStats) Reset()                    { *m = SecurityRuleStats{} }
func (m *SecurityRuleStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStats) ProtoMessage()               {}
func (*SecurityRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{15} }

// security rule object
type SecurityRule struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityRuleSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityRuleStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityRuleStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityRule) Reset()                    { *m = SecurityRule{} }
func (m *SecurityRule) String() string            { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()               {}
func (*SecurityRule) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{16} }

func (m *SecurityRule) GetSpec() *SecurityRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityRule) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityRule) GetStats() *SecurityRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy rule create and update request
type SecurityRuleRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// security policy rule configuration
	Request *SecurityRuleSpec `protobuf:"bytes,2,opt,name=Request" json:"Request,omitempty"`
}

func (m *SecurityRuleRequest) Reset()                    { *m = SecurityRuleRequest{} }
func (m *SecurityRuleRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleRequest) ProtoMessage()               {}
func (*SecurityRuleRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{17} }

func (m *SecurityRuleRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleRequest) GetRequest() *SecurityRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy rule create and update response
type SecurityRuleResponse struct {
	// success or failure status
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// operational status
	Response *SecurityRuleStatus `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *SecurityRuleResponse) Reset()                    { *m = SecurityRuleResponse{} }
func (m *SecurityRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleResponse) ProtoMessage()               {}
func (*SecurityRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{18} }

func (m *SecurityRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleResponse) GetResponse() *SecurityRuleStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule get request
type SecurityRuleGetRequest struct {
	// list of id/key of the security policy rules of interest
	Id []*SecurityPolicyRuleId `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty" meta:mandatory`
}

func (m *SecurityRuleGetRequest) Reset()                    { *m = SecurityRuleGetRequest{} }
func (m *SecurityRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetRequest) ProtoMessage()               {}
func (*SecurityRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{19} }

func (m *SecurityRuleGetRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule get response
type SecurityRuleGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// security policy rule information
	Response []*SecurityRule `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityRuleGetResponse) Reset()                    { *m = SecurityRuleGetResponse{} }
func (m *SecurityRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetResponse) ProtoMessage()               {}
func (*SecurityRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{20} }

func (m *SecurityRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleGetResponse) GetResponse() []*SecurityRule {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule delete request
type SecurityRuleDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// id/key list of the security policy rule(s) to be deleted
	Id []*SecurityPolicyRuleId `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityRuleDeleteRequest) Reset()                    { *m = SecurityRuleDeleteRequest{} }
func (m *SecurityRuleDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteRequest) ProtoMessage()               {}
func (*SecurityRuleDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{21} }

func (m *SecurityRuleDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleDeleteRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule delete response
type SecurityRuleDeleteResponse struct {
	// API status code
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityRuleDeleteResponse) Reset()         { *m = SecurityRuleDeleteResponse{} }
func (m *SecurityRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteResponse) ProtoMessage()    {}
func (*SecurityRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{22}
}

func (m *SecurityRuleDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// security profile configuration
// NOTE:
// 1. currently security profile object is global and only a singleton object,
//    any attempt to create multiple objects will be treated as an error
// 2. if no object is created, indicated default values will be used
type SecurityProfileSpec struct {
	// unique identifier of security profile
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// ConnTrackEn, if set to true, will enable full connection tracking
	ConnTrackEn bool `protobuf:"varint,2,opt,name=ConnTrackEn,proto3" json:"ConnTrackEn,omitempty" meta:default=false`
	// DefaultFWAction is the action taken by the smartnic when no policies are
	// configured on the subnet or vnic (note that this case is different from
	// having a policy configured but no rules are configured in that policy)
	DefaultFWAction SecurityRuleAction `protobuf:"varint,3,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_ALLOW`
	// timeouts for established sessions per TCP/UDP/ICMP and other protocols
	TCPIdleTimeout   uint32 `protobuf:"varint,4,opt,name=TCPIdleTimeout,proto3" json:"TCPIdleTimeout,omitempty" meta:range:5-86400, meta:default=600`
	UDPIdleTimeout   uint32 `protobuf:"varint,5,opt,name=UDPIdleTimeout,proto3" json:"UDPIdleTimeout,omitempty" meta:range:5-86400, meta:default=120`
	ICMPIdleTimeout  uint32 `protobuf:"varint,6,opt,name=ICMPIdleTimeout,proto3" json:"ICMPIdleTimeout,omitempty" meta:range:5-86400, meta:default=15`
	OtherIdleTimeout uint32 `protobuf:"varint,7,opt,name=OtherIdleTimeout,proto3" json:"OtherIdleTimeout,omitempty" meta:range:30-86400, meta:default=90`
	// TCP specific timeouts
	// TCPCnxnSetupTimeout is the maximum allowed time since first SYN seen to
	// 3-way handshake completion, session gets cleaned up if 3-way handshake is
	// not completed and session moves to ESTABLISHED state by then
	TCPCnxnSetupTimeout uint32 `protobuf:"varint,8,opt,name=TCPCnxnSetupTimeout,proto3" json:"TCPCnxnSetupTimeout,omitempty" meta:range:1-60, meta:default=10`
	// TCPHalfCloseTimeout is the maximum allowed time since first FIN seen to
	// 3/4way close, session gets cleaned up if this timer elapses.
	TCPHalfCloseTimeout uint32 `protobuf:"varint,9,opt,name=TCPHalfCloseTimeout,proto3" json:"TCPHalfCloseTimeout,omitempty" meta:range:1-172800, meta:default=120`
	// TCPCloseTimeout is wait time since FIN is seen from *both* sides (or RST)
	// before cleaning up the session
	TCPCloseTimeout uint32 `protobuf:"varint,10,opt,name=TCPCloseTimeout,proto3" json:"TCPCloseTimeout,omitempty" meta:range:1-300, meta:default=15`
	// timeouts applicable to sessions installed with drop action
	TCPDropTimeout   uint32 `protobuf:"varint,11,opt,name=TCPDropTimeout,proto3" json:"TCPDropTimeout,omitempty" meta:range:1-300, meta:default=90`
	UDPDropTimeout   uint32 `protobuf:"varint,12,opt,name=UDPDropTimeout,proto3" json:"UDPDropTimeout,omitempty" meta:range:1-172800, meta:default=60`
	ICMPDropTimeout  uint32 `protobuf:"varint,13,opt,name=ICMPDropTimeout,proto3" json:"ICMPDropTimeout,omitempty" meta:range:1-300, meta:default=30`
	OtherDropTimeout uint32 `protobuf:"varint,14,opt,name=OtherDropTimeout,proto3" json:"OtherDropTimeout,omitempty" meta:range:1-300, meta:default=60`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{23} }

func (m *SecurityProfileSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityProfileSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SecurityProfileSpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTCPIdleTimeout() uint32 {
	if m != nil {
		return m.TCPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPIdleTimeout() uint32 {
	if m != nil {
		return m.UDPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPIdleTimeout() uint32 {
	if m != nil {
		return m.ICMPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherIdleTimeout() uint32 {
	if m != nil {
		return m.OtherIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCnxnSetupTimeout() uint32 {
	if m != nil {
		return m.TCPCnxnSetupTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPHalfCloseTimeout() uint32 {
	if m != nil {
		return m.TCPHalfCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCloseTimeout() uint32 {
	if m != nil {
		return m.TCPCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPDropTimeout() uint32 {
	if m != nil {
		return m.TCPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPDropTimeout() uint32 {
	if m != nil {
		return m.UDPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPDropTimeout() uint32 {
	if m != nil {
		return m.ICMPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherDropTimeout() uint32 {
	if m != nil {
		return m.OtherDropTimeout
	}
	return 0
}

// operational status of security profile, if any
type SecurityProfileStatus struct {
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{24} }

// stats of security profile, if any
type SecurityProfileStats struct {
}

func (m *SecurityProfileStats) Reset()                    { *m = SecurityProfileStats{} }
func (m *SecurityProfileStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStats) ProtoMessage()               {}
func (*SecurityProfileStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{25} }

// security profile object
type SecurityProfile struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityProfileSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityProfileStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityProfileStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityProfile) Reset()                    { *m = SecurityProfile{} }
func (m *SecurityProfile) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfile) ProtoMessage()               {}
func (*SecurityProfile) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{26} }

func (m *SecurityProfile) GetSpec() *SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityProfile) GetStatus() *SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityProfile) GetStats() *SecurityProfileStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security profile create and update request
type SecurityProfileRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt             `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   []*SecurityProfileSpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *SecurityProfileRequest) Reset()                    { *m = SecurityProfileRequest{} }
func (m *SecurityProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileRequest) ProtoMessage()               {}
func (*SecurityProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{27} }

func (m *SecurityProfileRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileRequest) GetRequest() []*SecurityProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security profile create and update response
type SecurityProfileResponse struct {
	ApiStatus ApiStatus                `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityProfileStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityProfileResponse) Reset()                    { *m = SecurityProfileResponse{} }
func (m *SecurityProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponse) ProtoMessage()               {}
func (*SecurityProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{28} }

func (m *SecurityProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileResponse) GetResponse() []*SecurityProfileStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile get request
type SecurityProfileGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityProfileGetRequest) Reset()                    { *m = SecurityProfileGetRequest{} }
func (m *SecurityProfileGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequest) ProtoMessage()               {}
func (*SecurityProfileGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{29} }

func (m *SecurityProfileGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile get response
type SecurityProfileGetResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityProfile `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityProfileGetResponse) Reset()         { *m = SecurityProfileGetResponse{} }
func (m *SecurityProfileGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponse) ProtoMessage()    {}
func (*SecurityProfileGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{30}
}

func (m *SecurityProfileGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileGetResponse) GetResponse() []*SecurityProfile {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile delete request
type SecurityProfileDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityProfileDeleteRequest) Reset()         { *m = SecurityProfileDeleteRequest{} }
func (m *SecurityProfileDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequest) ProtoMessage()    {}
func (*SecurityProfileDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{31}
}

func (m *SecurityProfileDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile delete response
type SecurityProfileDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityProfileDeleteResponse) Reset()         { *m = SecurityProfileDeleteResponse{} }
func (m *SecurityProfileDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponse) ProtoMessage()    {}
func (*SecurityProfileDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{32}
}

func (m *SecurityProfileDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*SecurityRuleAttrs)(nil), "pds.SecurityRuleAttrs")
	proto.RegisterType((*SecurityRuleInfo)(nil), "pds.SecurityRuleInfo")
	proto.RegisterType((*SecurityPolicySpec)(nil), "pds.SecurityPolicySpec")
	proto.RegisterType((*SecurityPolicyStatus)(nil), "pds.SecurityPolicyStatus")
	proto.RegisterType((*SecurityPolicyStats)(nil), "pds.SecurityPolicyStats")
	proto.RegisterType((*SecurityPolicy)(nil), "pds.SecurityPolicy")
	proto.RegisterType((*SecurityPolicyRequest)(nil), "pds.SecurityPolicyRequest")
	proto.RegisterType((*SecurityPolicyResponse)(nil), "pds.SecurityPolicyResponse")
	proto.RegisterType((*SecurityPolicyGetRequest)(nil), "pds.SecurityPolicyGetRequest")
	proto.RegisterType((*SecurityPolicyGetResponse)(nil), "pds.SecurityPolicyGetResponse")
	proto.RegisterType((*SecurityPolicyDeleteRequest)(nil), "pds.SecurityPolicyDeleteRequest")
	proto.RegisterType((*SecurityPolicyDeleteResponse)(nil), "pds.SecurityPolicyDeleteResponse")
	proto.RegisterType((*SecurityPolicyRuleId)(nil), "pds.SecurityPolicyRuleId")
	proto.RegisterType((*SecurityRuleSpec)(nil), "pds.SecurityRuleSpec")
	proto.RegisterType((*SecurityRuleStatus)(nil), "pds.SecurityRuleStatus")
	proto.RegisterType((*SecurityRuleStats)(nil), "pds.SecurityRuleStats")
	proto.RegisterType((*SecurityRule)(nil), "pds.SecurityRule")
	proto.RegisterType((*SecurityRuleRequest)(nil), "pds.SecurityRuleRequest")
	proto.RegisterType((*SecurityRuleResponse)(nil), "pds.SecurityRuleResponse")
	proto.RegisterType((*SecurityRuleGetRequest)(nil), "pds.SecurityRuleGetRequest")
	proto.RegisterType((*SecurityRuleGetResponse)(nil), "pds.SecurityRuleGetResponse")
	proto.RegisterType((*SecurityRuleDeleteRequest)(nil), "pds.SecurityRuleDeleteRequest")
	proto.RegisterType((*SecurityRuleDeleteResponse)(nil), "pds.SecurityRuleDeleteResponse")
	proto.RegisterType((*SecurityProfileSpec)(nil), "pds.SecurityProfileSpec")
	proto.RegisterType((*SecurityProfileStatus)(nil), "pds.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileStats)(nil), "pds.SecurityProfileStats")
	proto.RegisterType((*SecurityProfile)(nil), "pds.SecurityProfile")
	proto.RegisterType((*SecurityProfileRequest)(nil), "pds.SecurityProfileRequest")
	proto.RegisterType((*SecurityProfileResponse)(nil), "pds.SecurityProfileResponse")
	proto.RegisterType((*SecurityProfileGetRequest)(nil), "pds.SecurityProfileGetRequest")
	proto.RegisterType((*SecurityProfileGetResponse)(nil), "pds.SecurityProfileGetResponse")
	proto.RegisterType((*SecurityProfileDeleteRequest)(nil), "pds.SecurityProfileDeleteRequest")
	proto.RegisterType((*SecurityProfileDeleteResponse)(nil), "pds.SecurityProfileDeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SecurityPolicySvc service

type SecurityPolicySvcClient interface {
	// security policy APIs
	SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error)
	SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error)
	// security policy rule APIs
	SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error)
}

type securityPolicySvcClient struct {
	cc *grpc.ClientConn
}

func NewSecurityPolicySvcClient(cc *grpc.ClientConn) SecurityPolicySvcClient {
	return &securityPolicySvcClient{cc}
}

func (c *securityPolicySvcClient) SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error) {
	out := new(SecurityPolicyGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error) {
	out := new(SecurityPolicyDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error) {
	out := new(SecurityRuleGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error) {
	out := new(SecurityRuleDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error) {
	out := new(SecurityProfileGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error) {
	out := new(SecurityProfileDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SecurityPolicySvc service

type SecurityPolicySvcServer interface {
	// security policy APIs
	SecurityPolicyCreate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(context.Context, *SecurityPolicyGetRequest) (*SecurityPolicyGetResponse, error)
	SecurityPolicyDelete(context.Context, *SecurityPolicyDeleteRequest) (*SecurityPolicyDeleteResponse, error)
	// security policy rule APIs
	SecurityRuleCreate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleGet(context.Context, *SecurityRuleGetRequest) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(context.Context, *SecurityRuleDeleteRequest) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileGet(context.Context, *SecurityProfileGetRequest) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(context.Context, *SecurityProfileDeleteRequest) (*SecurityProfileDeleteResponse, error)
}

func RegisterSecurityPolicySvcServer(s *grpc.Server, srv SecurityPolicySvcServer) {
	s.RegisterService(&_SecurityPolicySvc_serviceDesc, srv)
}

func _SecurityPolicySvc_SecurityPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, req.(*SecurityPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, req.(*SecurityPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, req.(*SecurityRuleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, req.(*SecurityRuleDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, req.(*SecurityProfileGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, req.(*SecurityProfileDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SecurityPolicySvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SecurityPolicySvc",
	HandlerType: (*SecurityPolicySvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityPolicyCreate",
			Handler:    _SecurityPolicySvc_SecurityPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityPolicyUpdate",
			Handler:    _SecurityPolicySvc_SecurityPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityPolicyGet",
			Handler:    _SecurityPolicySvc_SecurityPolicyGet_Handler,
		},
		{
			MethodName: "SecurityPolicyDelete",
			Handler:    _SecurityPolicySvc_SecurityPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityRuleCreate",
			Handler:    _SecurityPolicySvc_SecurityRuleCreate_Handler,
		},
		{
			MethodName: "SecurityRuleUpdate",
			Handler:    _SecurityPolicySvc_SecurityRuleUpdate_Handler,
		},
		{
			MethodName: "SecurityRuleGet",
			Handler:    _SecurityPolicySvc_SecurityRuleGet_Handler,
		},
		{
			MethodName: "SecurityRuleDelete",
			Handler:    _SecurityPolicySvc_SecurityRuleDelete_Handler,
		},
		{
			MethodName: "SecurityProfileCreate",
			Handler:    _SecurityPolicySvc_SecurityProfileCreate_Handler,
		},
		{
			MethodName: "SecurityProfileUpdate",
			Handler:    _SecurityPolicySvc_SecurityProfileUpdate_Handler,
		},
		{
			MethodName: "SecurityProfileGet",
			Handler:    _SecurityPolicySvc_SecurityProfileGet_Handler,
		},
		{
			MethodName: "SecurityProfileDelete",
			Handler:    _SecurityPolicySvc_SecurityProfileDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "policy.proto",
}

func (m *SecurityRuleAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleAttrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stateful {
		dAtA[i] = 0x8
		i++
		if m.Stateful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Priority))
	}
	if m.Match != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Match.Size()))
		n1, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Action != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *SecurityRuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Attrs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Attrs.Size()))
		n2, err := m.Attrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SecurityPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.AddrFamily != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.AddrFamily))
	}
	if m.DefaultFWAction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n4, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n5, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n7, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SecurityPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n8, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n9, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA11 := make([]byte, len(m.ApiStatus)*10)
		var j10 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *SecurityPolicyRuleId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRuleId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SecurityPolicyId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i += copy(dAtA[i:], m.SecurityPolicyId)
	}
	return i, nil
}

func (m *SecurityRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SecurityPolicyId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i += copy(dAtA[i:], m.SecurityPolicyId)
	}
	if m.Attrs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Attrs.Size()))
		n12, err := m.Attrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *SecurityRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n14, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n15, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n16, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n17, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *SecurityRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n18, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Request.Size()))
		n19, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *SecurityRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Response.Size()))
		n20, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *SecurityRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, msg := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n21, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Id) > 0 {
		for _, msg := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA23 := make([]byte, len(m.ApiStatus)*10)
		var j22 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	return i, nil
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ConnTrackEn {
		dAtA[i] = 0x10
		i++
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultFWAction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
	}
	if m.TCPIdleTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPIdleTimeout))
	}
	if m.UDPIdleTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPIdleTimeout))
	}
	if m.ICMPIdleTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPIdleTimeout))
	}
	if m.OtherIdleTimeout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherIdleTimeout))
	}
	if m.TCPCnxnSetupTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCnxnSetupTimeout))
	}
	if m.TCPHalfCloseTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPHalfCloseTimeout))
	}
	if m.TCPCloseTimeout != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCloseTimeout))
	}
	if m.TCPDropTimeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPDropTimeout))
	}
	if m.UDPDropTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPDropTimeout))
	}
	if m.ICMPDropTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPDropTimeout))
	}
	if m.OtherDropTimeout != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherDropTimeout))
	}
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n24, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n25, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n26, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n27, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n28, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *SecurityProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n29, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityProfileGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n30, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA32 := make([]byte, len(m.ApiStatus)*10)
		var j31 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j31))
		i += copy(dAtA[i:], dAtA32[:j31])
	}
	return i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SecurityRuleAttrs) Size() (n int) {
	var l int
	_ = l
	if m.Stateful {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovPolicy(uint64(m.Priority))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPolicy(uint64(m.Action))
	}
	return n
}

func (m *SecurityRuleInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.AddrFamily != 0 {
		n += 1 + sovPolicy(uint64(m.AddrFamily))
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityPolicyStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityPolicy) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityPolicyRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func (m *SecurityPolicyRuleId) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityRuleStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityRule) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ConnTrackEn {
		n += 2
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if m.TCPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPIdleTimeout))
	}
	if m.UDPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPIdleTimeout))
	}
	if m.ICMPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPIdleTimeout))
	}
	if m.OtherIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherIdleTimeout))
	}
	if m.TCPCnxnSetupTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCnxnSetupTimeout))
	}
	if m.TCPHalfCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPHalfCloseTimeout))
	}
	if m.TCPCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCloseTimeout))
	}
	if m.TCPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPDropTimeout))
	}
	if m.UDPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPDropTimeout))
	}
	if m.ICMPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPDropTimeout))
	}
	if m.OtherDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherDropTimeout))
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfileStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfile) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityProfileRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityRuleAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stateful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stateful = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrFamily", wireType)
			}
			m.AddrFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrFamily |= (IPAF(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &SecurityRuleInfo{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRuleId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &SecurityRuleSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &SecurityRuleStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRule{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPIdleTimeout", wireType)
			}
			m.TCPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPIdleTimeout", wireType)
			}
			m.UDPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPIdleTimeout", wireType)
			}
			m.ICMPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherIdleTimeout", wireType)
			}
			m.OtherIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCnxnSetupTimeout", wireType)
			}
			m.TCPCnxnSetupTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCnxnSetupTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPHalfCloseTimeout", wireType)
			}
			m.TCPHalfCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPHalfCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCloseTimeout", wireType)
			}
			m.TCPCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPDropTimeout", wireType)
			}
			m.TCPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPDropTimeout", wireType)
			}
			m.UDPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPDropTimeout", wireType)
			}
			m.ICMPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDropTimeout", wireType)
			}
			m.OtherDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityProfileSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityProfileStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfile{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("policy.proto", fileDescriptorPolicy) }

var fileDescriptorPolicy = []byte{
	// 1552 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x6f, 0x13, 0xc7,
	0x1b, 0x66, 0x6d, 0x92, 0x98, 0x71, 0x62, 0x87, 0xc9, 0x3f, 0xc7, 0x81, 0xac, 0xd9, 0x1f, 0xfc,
	0x30, 0x25, 0x09, 0x8e, 0x53, 0x52, 0xa0, 0x42, 0x60, 0x3b, 0x01, 0xac, 0x26, 0x38, 0x6c, 0x9c,
	0x46, 0x55, 0x45, 0xe9, 0x62, 0x4f, 0xc0, 0xad, 0xed, 0xdd, 0x7a, 0xc7, 0x88, 0xb4, 0xa8, 0x55,
	0xfb, 0x01, 0x7a, 0xee, 0xc7, 0xe9, 0xb1, 0x87, 0x1e, 0xb8, 0xf4, 0xd8, 0x55, 0x8b, 0xd4, 0x0b,
	0x47, 0xdf, 0x2b, 0x55, 0x3b, 0x33, 0xde, 0x9d, 0xdd, 0x1d, 0x3b, 0x61, 0x41, 0xe2, 0x12, 0x25,
	0x33, 0xef, 0xf3, 0xcc, 0xfb, 0x3e, 0x3b, 0xf3, 0xcc, 0x3b, 0x0a, 0x18, 0x37, 0xf4, 0x66, 0xa3,
	0x76, 0xb8, 0x62, 0x74, 0x74, 0xac, 0xc3, 0xa8, 0x51, 0x37, 0xd3, 0xe0, 0x89, 0xfe, 0x44, 0xa7,
	0x03, 0xe9, 0x64, 0x0b, 0x61, 0xed, 0x8a, 0xfd, 0x83, 0x0d, 0xc4, 0xf1, 0xa1, 0x81, 0x4c, 0xfa,
	0x87, 0xf2, 0x8f, 0x04, 0x4e, 0xef, 0xa2, 0x5a, 0xb7, 0xd3, 0xc0, 0x87, 0x6a, 0xb7, 0x89, 0x0a,
	0x18, 0x77, 0x4c, 0xb8, 0x02, 0x62, 0xbb, 0x58, 0xc3, 0xe8, 0xa0, 0xdb, 0x4c, 0x49, 0x19, 0x29,
	0x1b, 0x2b, 0xc2, 0x9e, 0x25, 0x27, 0x6c, 0x92, 0x1b, 0x2d, 0xad, 0x5d, 0xd7, 0xb0, 0xde, 0x39,
	0x54, 0x9d, 0x18, 0xb8, 0x0a, 0x62, 0x3b, 0x9d, 0x86, 0x6e, 0x93, 0xa4, 0x22, 0x19, 0x29, 0x3b,
	0x51, 0x9c, 0xe9, 0x59, 0xf2, 0x69, 0x12, 0xdf, 0xd1, 0xda, 0x4f, 0xd0, 0x8d, 0xdc, 0xf2, 0x6a,
	0x2e, 0x9f, 0x57, 0x9d, 0x30, 0xf8, 0x7f, 0x30, 0xb2, 0xad, 0xe1, 0xda, 0xd3, 0x54, 0x34, 0x23,
	0x65, 0xe3, 0xf9, 0xc9, 0x15, 0x9a, 0x95, 0x9d, 0x03, 0x19, 0x57, 0xe9, 0x34, 0xdc, 0x04, 0xa3,
	0x85, 0x1a, 0x6e, 0xe8, 0xed, 0xd4, 0xc9, 0x8c, 0x94, 0x4d, 0xe4, 0xe7, 0x59, 0xa0, 0x27, 0x69,
	0x12, 0x20, 0xcc, 0x91, 0x81, 0x95, 0x9f, 0x24, 0x30, 0xc9, 0x43, 0xca, 0xed, 0x03, 0x1d, 0x2e,
	0x81, 0x48, 0xb9, 0x4e, 0x0a, 0x1c, 0x2f, 0x9e, 0xe9, 0x59, 0x72, 0xca, 0x0b, 0x5e, 0x6a, 0xb4,
	0x5a, 0x5d, 0xac, 0x3d, 0x6e, 0x22, 0x35, 0x52, 0xae, 0xc3, 0xdb, 0x60, 0x84, 0xa8, 0x43, 0x2a,
	0x8c, 0xe7, 0x67, 0x57, 0x8c, 0xba, 0x2f, 0x0d, 0x7b, 0x56, 0x98, 0x05, 0x05, 0x2a, 0xbf, 0x46,
	0x00, 0xec, 0x03, 0x76, 0xc8, 0x47, 0xdb, 0x35, 0x50, 0xed, 0x0d, 0xd3, 0x28, 0x03, 0x50, 0xa8,
	0xd7, 0x3b, 0x77, 0xb4, 0x56, 0xa3, 0x49, 0xd5, 0x4e, 0xe4, 0xe3, 0x4c, 0x94, 0xf2, 0x4e, 0xe1,
	0xce, 0x11, 0x14, 0x1c, 0x18, 0x1a, 0x20, 0xb9, 0x81, 0x0e, 0xb4, 0x6e, 0x13, 0xdf, 0xd9, 0x67,
	0x22, 0x47, 0x8f, 0x12, 0xf9, 0x72, 0xcf, 0x92, 0x2f, 0x12, 0xf6, 0x3a, 0x85, 0xde, 0xdc, 0xdd,
	0x2c, 0xed, 0xa9, 0xe5, 0xea, 0x67, 0x8f, 0xd4, 0xbd, 0xad, 0xcd, 0x47, 0x85, 0x52, 0xb5, 0x5c,
	0xb9, 0xff, 0xa8, 0xb0, 0xb5, 0x55, 0xd9, 0x57, 0xfd, 0xf4, 0xf0, 0x16, 0x18, 0xb1, 0xb9, 0xcc,
	0xd4, 0xc9, 0x4c, 0x34, 0x1b, 0xcf, 0xcf, 0x04, 0x34, 0xb4, 0xbf, 0x8b, 0x58, 0x42, 0x82, 0x53,
	0x66, 0xc1, 0xb4, 0x4f, 0x41, 0xac, 0xe1, 0xae, 0xa9, 0xcc, 0x80, 0xa9, 0xe0, 0xb8, 0xa9, 0xfc,
	0x19, 0x01, 0x09, 0xef, 0x38, 0xfc, 0x18, 0xc4, 0xaa, 0x87, 0x06, 0xda, 0x46, 0x58, 0x23, 0x9a,
	0xc7, 0xf3, 0x89, 0x15, 0x72, 0x3a, 0xfa, 0xa3, 0xc5, 0xe4, 0x4b, 0x4b, 0x96, 0x5e, 0x5b, 0xf2,
	0xd8, 0x52, 0xa3, 0xdd, 0x6c, 0xb4, 0x91, 0xea, 0x00, 0xe0, 0x2d, 0x30, 0x56, 0x79, 0xfc, 0x15,
	0xc1, 0xd2, 0x5d, 0x30, 0x41, 0xb1, 0x6c, 0xb0, 0x38, 0xcb, 0xa0, 0x24, 0xfb, 0x25, 0xbd, 0xd5,
	0xc0, 0xa8, 0x65, 0xe0, 0x43, 0xb5, 0x8f, 0x82, 0xb7, 0xc0, 0x49, 0xfb, 0x9b, 0xb3, 0x5d, 0x3f,
	0xe7, 0xa9, 0xdf, 0xdd, 0x12, 0x45, 0x68, 0x73, 0x98, 0x06, 0xaa, 0x71, 0x1c, 0x04, 0x08, 0xef,
	0x82, 0x51, 0x5a, 0x32, 0x39, 0x0f, 0xf1, 0xfc, 0xbc, 0x88, 0x82, 0x04, 0x14, 0xa7, 0x5f, 0x5b,
	0xf2, 0xa4, 0x49, 0x7e, 0xe7, 0x68, 0x18, 0x1c, 0x96, 0xc0, 0x08, 0xd1, 0x28, 0x35, 0x42, 0x78,
	0x52, 0x03, 0x78, 0xcc, 0xe2, 0xd4, 0x6b, 0x4b, 0x4e, 0xda, 0x34, 0x3c, 0x0b, 0xc5, 0x2a, 0xdf,
	0x82, 0x19, 0x2f, 0x44, 0x45, 0xdf, 0x74, 0x91, 0x89, 0xe1, 0x0a, 0x38, 0x55, 0xb4, 0xcf, 0x6f,
	0x09, 0x3f, 0xc7, 0x4c, 0xe6, 0xfe, 0x11, 0x77, 0xc6, 0x55, 0x37, 0x04, 0xae, 0x82, 0x31, 0x06,
	0x4d, 0x45, 0xc8, 0xd6, 0x18, 0x24, 0x8d, 0xda, 0x8f, 0x53, 0x7e, 0x00, 0xb3, 0xfe, 0xb5, 0x4d,
	0x43, 0x6f, 0x9b, 0xc8, 0x5e, 0xbc, 0x60, 0x34, 0x98, 0x4c, 0x12, 0xd9, 0xd1, 0xfd, 0xc5, 0x9d,
	0x71, 0xd5, 0x0d, 0x81, 0x57, 0x41, 0xac, 0x8f, 0x65, 0xab, 0x0f, 0x56, 0x55, 0x75, 0x42, 0x95,
	0x0f, 0x40, 0xca, 0x1b, 0x71, 0x17, 0xe1, 0x7e, 0xfd, 0x09, 0x76, 0xa6, 0xa3, 0xd9, 0x71, 0xfb,
	0xd4, 0x2a, 0x2f, 0xc0, 0xbc, 0x20, 0x36, 0x64, 0xbe, 0x57, 0x02, 0xf9, 0x4e, 0x09, 0xf2, 0xe5,
	0x32, 0x7d, 0x08, 0x16, 0xbc, 0x73, 0x1b, 0xa8, 0x89, 0x30, 0x0a, 0xfb, 0xb1, 0x68, 0x71, 0x11,
	0xa7, 0xb8, 0xfb, 0xe0, 0x8c, 0x98, 0x5e, 0x5c, 0x5f, 0xf4, 0x88, 0xfa, 0x94, 0x9f, 0x25, 0xff,
	0x29, 0x27, 0xd6, 0x50, 0x7f, 0x43, 0xa7, 0xbc, 0xe7, 0x5a, 0x3e, 0x65, 0x21, 0x49, 0x1f, 0x8d,
	0x0d, 0xa0, 0x94, 0xdf, 0x7d, 0xb7, 0x47, 0x08, 0xdb, 0x7e, 0x67, 0xc9, 0xb8, 0xf7, 0x50, 0x34,
	0xec, 0x3d, 0x34, 0xed, 0x5e, 0x43, 0xa4, 0x1a, 0xaa, 0xfa, 0x94, 0xb7, 0x13, 0xa0, 0x07, 0xfc,
	0x8f, 0x08, 0x18, 0xe7, 0x47, 0xdf, 0xb3, 0x7d, 0xde, 0xf4, 0xd8, 0x67, 0xf0, 0xfa, 0x38, 0xc2,
	0x3c, 0x37, 0x7d, 0xe6, 0x39, 0x17, 0x24, 0x38, 0x8e, 0x75, 0x16, 0xbc, 0xd6, 0x39, 0x2b, 0x64,
	0x19, 0x6e, 0x9c, 0xcf, 0xdc, 0xfb, 0xca, 0x06, 0x84, 0x3d, 0x89, 0x57, 0x78, 0xdb, 0x1c, 0x2c,
	0x89, 0x6b, 0x9a, 0xdf, 0xb9, 0x27, 0x8b, 0xae, 0x1b, 0xd2, 0x82, 0xd6, 0x3c, 0x16, 0x34, 0x4c,
	0x4b, 0xce, 0x86, 0xf6, 0x5d, 0xc7, 0xb6, 0xe7, 0x39, 0xbb, 0xbc, 0xe9, 0xd8, 0xa5, 0xd8, 0x7b,
	0xe9, 0xf9, 0x17, 0xee, 0x69, 0xdb, 0x80, 0x9e, 0x83, 0xb9, 0x00, 0x71, 0xc8, 0xc2, 0x96, 0x03,
	0xde, 0x7a, 0x3a, 0x50, 0x18, 0x57, 0xd2, 0x33, 0xd7, 0xd7, 0xed, 0x99, 0xb7, 0xf3, 0xd5, 0x4b,
	0x8e, 0xaf, 0x0e, 0x53, 0x81, 0x54, 0xbc, 0x05, 0xd2, 0xa2, 0x75, 0x43, 0x1a, 0xee, 0xbf, 0x31,
	0xae, 0x7d, 0xea, 0xe8, 0x07, 0x0d, 0x66, 0x71, 0x0a, 0x67, 0x71, 0x03, 0xb4, 0x87, 0xd7, 0x40,
	0xbc, 0xa4, 0xb7, 0xdb, 0xd5, 0x8e, 0x56, 0xfb, 0x7a, 0xb3, 0x4d, 0x36, 0x43, 0xac, 0x38, 0xdb,
	0xb3, 0x64, 0xe8, 0xe9, 0x12, 0x0f, 0xb4, 0xa6, 0x89, 0x54, 0x3e, 0xf4, 0x3d, 0xb4, 0x9f, 0x3b,
	0x20, 0x51, 0x2d, 0xed, 0x94, 0xeb, 0x4d, 0x54, 0x6d, 0xb4, 0x90, 0xde, 0xc5, 0xc4, 0x07, 0x26,
	0x8a, 0xd9, 0x9e, 0x25, 0x9f, 0xe7, 0x5e, 0x2b, 0x57, 0x97, 0xaf, 0xad, 0x7f, 0x98, 0xcb, 0x2d,
	0x65, 0x3c, 0x2b, 0xad, 0xe7, 0x72, 0xaa, 0x0f, 0x6f, 0x33, 0xee, 0x6d, 0x78, 0x18, 0x47, 0xde,
	0x80, 0x71, 0x35, 0x9f, 0x53, 0x7d, 0x78, 0xf8, 0x00, 0x24, 0xcb, 0xa5, 0x6d, 0x0f, 0xe5, 0x28,
	0xa1, 0xbc, 0xd8, 0xb3, 0xe4, 0xff, 0x1d, 0x4d, 0x79, 0x55, 0xf5, 0xe3, 0x61, 0x15, 0x4c, 0x56,
	0xf0, 0x53, 0xd4, 0xe1, 0x39, 0xc7, 0x84, 0x69, 0xae, 0xe5, 0x84, 0xa4, 0xd7, 0x73, 0x6a, 0x80,
	0x01, 0x7e, 0x0a, 0xa6, 0xaa, 0xa5, 0x9d, 0x52, 0xfb, 0x79, 0x7b, 0x17, 0xe1, 0xae, 0xd1, 0x27,
	0x8e, 0x11, 0xe2, 0xf3, 0x3d, 0x4b, 0xce, 0x70, 0xc4, 0xab, 0xcb, 0xeb, 0x81, 0x4c, 0x73, 0xaa,
	0x88, 0x00, 0x7e, 0x4e, 0x78, 0xef, 0x69, 0xcd, 0x83, 0x52, 0x53, 0x37, 0x9d, 0x84, 0x4f, 0x11,
	0xde, 0x4b, 0x3d, 0x4b, 0xbe, 0xe0, 0xe1, 0x5d, 0xfd, 0x28, 0x7f, 0x4d, 0x28, 0xac, 0x88, 0x05,
	0x56, 0x40, 0xd2, 0x5e, 0x93, 0x27, 0x06, 0x84, 0xf8, 0x42, 0xcf, 0x92, 0xcf, 0x79, 0x88, 0xd7,
	0x84, 0xda, 0xfa, 0xd0, 0x70, 0x9b, 0x6c, 0xa9, 0x8d, 0x8e, 0xee, 0x08, 0x10, 0x3f, 0x36, 0xdf,
	0x75, 0xba, 0x9f, 0x38, 0x30, 0xdb, 0x4f, 0x3c, 0xdd, 0xb8, 0xf0, 0x43, 0x0d, 0xa8, 0x7b, 0x9d,
	0xee, 0x27, 0x9e, 0xb1, 0x42, 0xf7, 0x13, 0x4f, 0x39, 0x71, 0xec, 0x0c, 0xd7, 0x72, 0xaa, 0x1f,
	0x0d, 0x1f, 0xb0, 0xdd, 0xc4, 0x33, 0x26, 0x8e, 0xcd, 0xb8, 0xde, 0xdf, 0x4a, 0x1c, 0x5c, 0x99,
	0xe3, 0x9e, 0x11, 0xcc, 0x7e, 0xa8, 0x31, 0xf1, 0xcf, 0x3d, 0x77, 0xc2, 0x54, 0xfe, 0x8e, 0x80,
	0xa4, 0x6f, 0xe2, 0x3d, 0x77, 0x26, 0xb7, 0x3d, 0x9d, 0x89, 0xef, 0x35, 0xe5, 0x5a, 0xea, 0x90,
	0xe6, 0xe4, 0x9e, 0xaf, 0x39, 0x49, 0x0b, 0x39, 0x8e, 0xd3, 0x9f, 0x6c, 0x78, 0xfb, 0x93, 0xf9,
	0x41, 0x44, 0xc3, 0x5b, 0x94, 0x17, 0xdc, 0xfb, 0x8a, 0x62, 0xc2, 0xde, 0x6b, 0x79, 0xff, 0xe3,
	0x6e, 0xa0, 0x3c, 0x6e, 0xa3, 0xf2, 0xa3, 0xe4, 0xde, 0xe9, 0xce, 0xf2, 0x21, 0xef, 0xf4, 0xf5,
	0xc0, 0x9d, 0x3e, 0x44, 0x5b, 0xee, 0x72, 0xbf, 0xcc, 0x3d, 0xda, 0x68, 0xc8, 0x90, 0x17, 0xde,
	0xf7, 0xee, 0x8d, 0xcc, 0x07, 0x87, 0x4c, 0x39, 0x17, 0x48, 0x79, 0x5a, 0x94, 0x32, 0x97, 0xec,
	0x17, 0xdc, 0x23, 0x8c, 0x4e, 0xbe, 0xdb, 0x47, 0x5e, 0x05, 0x9c, 0x1d, 0xc0, 0x1f, 0xae, 0xe9,
	0xc8, 0xff, 0x12, 0x73, 0x1f, 0x1c, 0xec, 0x85, 0xfd, 0xac, 0x06, 0x1f, 0xf8, 0x9f, 0x7e, 0xa5,
	0x0e, 0xd2, 0x30, 0x82, 0x69, 0x51, 0x3f, 0x44, 0x4b, 0x4b, 0x2f, 0x08, 0xe7, 0x98, 0x2e, 0x27,
	0x82, 0x94, 0x7b, 0x46, 0xfd, 0x2d, 0x29, 0xab, 0xfe, 0xd4, 0xef, 0x22, 0x0c, 0xcf, 0x0a, 0x30,
	0xee, 0x86, 0x49, 0x2f, 0x0e, 0x9a, 0x76, 0x58, 0x1f, 0xfa, 0x13, 0xa5, 0x0a, 0xc3, 0x8c, 0x00,
	0xe9, 0xf9, 0xb8, 0xe9, 0x73, 0x43, 0x22, 0x1c, 0xfa, 0x4f, 0xbc, 0xcf, 0x3e, 0x26, 0x6c, 0x2a,
	0xd8, 0xde, 0x32, 0xd2, 0x79, 0xc1, 0xcc, 0x20, 0x32, 0x26, 0x69, 0x48, 0xb2, 0xfb, 0xae, 0x9b,
	0xb3, 0xfe, 0x1d, 0x2e, 0x04, 0xe2, 0x39, 0x29, 0xcf, 0x88, 0x27, 0x1d, 0xbe, 0x7d, 0x6f, 0x72,
	0x4c, 0xc6, 0xc5, 0x00, 0xca, 0x2b, 0xa2, 0x3c, 0x70, 0x9e, 0xfb, 0xee, 0xfe, 0x8b, 0x8a, 0xa9,
	0xb8, 0x20, 0x3c, 0x9d, 0xc2, 0x74, 0x7d, 0x6e, 0x26, 0x64, 0x65, 0x72, 0xbe, 0x15, 0x2b, 0x27,
	0x82, 0x6b, 0x48, 0x3e, 0x11, 0x02, 0xb6, 0xe6, 0x13, 0x21, 0xe8, 0x64, 0xca, 0x09, 0xf8, 0x65,
	0x20, 0x5d, 0x26, 0xf0, 0x39, 0x11, 0xd6, 0xab, 0xb1, 0x32, 0x2c, 0xa4, 0xbf, 0x42, 0x71, 0xfc,
	0xb7, 0x57, 0x8b, 0xd2, 0xcb, 0x57, 0x8b, 0xd2, 0x5f, 0xaf, 0x16, 0xa5, 0xc7, 0xa3, 0xe4, 0x5f,
	0x15, 0x6b, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x1f, 0xa6, 0x61, 0xe9, 0x18, 0x00, 0x00,
}
