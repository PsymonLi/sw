// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policy.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ALG specifices with Application Level Gateway (ALG) should be invoked
// when a rule match happens. This ALG will also be reported in the flow
// logs
// NOTE:
// 1. TFTP, DNS ALGs are supported on UDP only
// 2. FTP, RTSP ALGs are supported on TCP only
// 3. SUNRPC and MSRPC ALGs are supported on both TCP and UDP
type ALG int32

const (
	ALG_ALG_NONE ALG = 0
	// TFTP ALG
	ALG_ALG_TFTP ALG = 1
	// FTP ALG
	ALG_ALG_FTP ALG = 2
	// DNS ALG
	ALG_ALG_DNS ALG = 3
	// SUNRPC ALG
	ALG_ALG_SUNRPC ALG = 4
	// MSRPC ALG
	ALG_ALG_MSRPC ALG = 5
	// RTSP ALG
	ALG_ALG_RTSP ALG = 6
)

var ALG_name = map[int32]string{
	0: "ALG_NONE",
	1: "ALG_TFTP",
	2: "ALG_FTP",
	3: "ALG_DNS",
	4: "ALG_SUNRPC",
	5: "ALG_MSRPC",
	6: "ALG_RTSP",
}
var ALG_value = map[string]int32{
	"ALG_NONE":   0,
	"ALG_TFTP":   1,
	"ALG_FTP":    2,
	"ALG_DNS":    3,
	"ALG_SUNRPC": 4,
	"ALG_MSRPC":  5,
	"ALG_RTSP":   6,
}

func (x ALG) String() string {
	return proto.EnumName(ALG_name, int32(x))
}
func (ALG) EnumDescriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{0} }

// FTP ALG specific options
type FTPOptions struct {
	// allow FTP data sessions with IP address that is different from
	// control sessions
	AllowIPMismatch bool `protobuf:"varint,1,opt,name=AllowIPMismatch,proto3" json:"AllowIPMismatch,omitempty"`
}

func (m *FTPOptions) Reset()                    { *m = FTPOptions{} }
func (m *FTPOptions) String() string            { return proto.CompactTextString(m) }
func (*FTPOptions) ProtoMessage()               {}
func (*FTPOptions) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{0} }

func (m *FTPOptions) GetAllowIPMismatch() bool {
	if m != nil {
		return m.AllowIPMismatch
	}
	return false
}

// DNS ALG specific options
type DNSOptions struct {
	// DNS session will be closed if response is not seen for a DNS query within
	// ResponseTimeout seconds
	ResponseTimeout uint32 `protobuf:"varint,1,opt,name=ResponseTimeout,proto3" json:"ResponseTimeout,omitempty" meta:default=60`
	//  when DropMultiQueryMessage is set, drop DNS query messages that contain
	//  more than one DNS query in same packet
	DropMultiQueryMessage bool `protobuf:"varint,2,opt,name=DropMultiQueryMessage,proto3" json:"DropMultiQueryMessage,omitempty"`
	// when DropLargeDomainNameMessage is set, DNS mwessages containing domain
	// name exceeding 255 bytes are dropped
	DropLargeDomainNameMessage bool `protobuf:"varint,3,opt,name=DropLargeDomainNameMessage,proto3" json:"DropLargeDomainNameMessage,omitempty"`
	// when DropLongLabelMessage is set, DNS messages containing labels
	// exceeding 63 bytes are dropped
	DropLongLabelMessage bool `protobuf:"varint,4,opt,name=DropLongLabelMessage,proto3" json:"DropLongLabelMessage,omitempty"`
	// when DropMultiZonePackets is set, DNS messages containing more than one
	// zone are dropped
	DropMultiZonePackets bool `protobuf:"varint,5,opt,name=DropMultiZonePackets,proto3" json:"DropMultiZonePackets,omitempty"`
	// MaxMessageLength defines the maximum length of the DNS query/response
	// message the ALG will handle
	MaxMessageLength uint32 `protobuf:"varint,6,opt,name=MaxMessageLength,proto3" json:"MaxMessageLength,omitempty" meta:range:512-8192,meta:default=512`
}

func (m *DNSOptions) Reset()                    { *m = DNSOptions{} }
func (m *DNSOptions) String() string            { return proto.CompactTextString(m) }
func (*DNSOptions) ProtoMessage()               {}
func (*DNSOptions) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{1} }

func (m *DNSOptions) GetResponseTimeout() uint32 {
	if m != nil {
		return m.ResponseTimeout
	}
	return 0
}

func (m *DNSOptions) GetDropMultiQueryMessage() bool {
	if m != nil {
		return m.DropMultiQueryMessage
	}
	return false
}

func (m *DNSOptions) GetDropLargeDomainNameMessage() bool {
	if m != nil {
		return m.DropLargeDomainNameMessage
	}
	return false
}

func (m *DNSOptions) GetDropLongLabelMessage() bool {
	if m != nil {
		return m.DropLongLabelMessage
	}
	return false
}

func (m *DNSOptions) GetDropMultiZonePackets() bool {
	if m != nil {
		return m.DropMultiZonePackets
	}
	return false
}

func (m *DNSOptions) GetMaxMessageLength() uint32 {
	if m != nil {
		return m.MaxMessageLength
	}
	return 0
}

// MSRPC ALG specific options
type MSRPCOptions struct {
	// RPC program uuids
	ProgramId [][]byte `protobuf:"bytes,1,rep,name=ProgramId" json:"ProgramId,omitempty"`
}

func (m *MSRPCOptions) Reset()                    { *m = MSRPCOptions{} }
func (m *MSRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*MSRPCOptions) ProtoMessage()               {}
func (*MSRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{2} }

func (m *MSRPCOptions) GetProgramId() [][]byte {
	if m != nil {
		return m.ProgramId
	}
	return nil
}

// SunRPC ALG specific options
type SunRPCOptions struct {
	// RPC program uuids
	ProgramId [][]byte `protobuf:"bytes,1,rep,name=ProgramId" json:"ProgramId,omitempty"`
}

func (m *SunRPCOptions) Reset()                    { *m = SunRPCOptions{} }
func (m *SunRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*SunRPCOptions) ProtoMessage()               {}
func (*SunRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{3} }

func (m *SunRPCOptions) GetProgramId() [][]byte {
	if m != nil {
		return m.ProgramId
	}
	return nil
}

type ALGSpec struct {
	// ALG to invoke (if set to ALG_NONE, no ALG is invoked)
	ALG ALG `protobuf:"varint,1,opt,name=ALG,proto3,enum=pds.ALG" json:"ALG,omitempty"`
	// ALG specific options, if any
	//
	// Types that are valid to be assigned to AlgOptions:
	//	*ALGSpec_FTPOptions
	//	*ALGSpec_DNSOptions
	//	*ALGSpec_MSRPCOptions
	//	*ALGSpec_SunRPCOptions
	AlgOptions isALGSpec_AlgOptions `protobuf_oneof:"alg_options"`
	// IdleTimeout indicates ALG specific session timeout in seconds
	// if IdleTimeout is not set, timeout from SecurityProfile object
	// is applied on both control and data sessions of the ALG
	IdleTimeout uint32 `protobuf:"varint,6,opt,name=IdleTimeout,proto3" json:"IdleTimeout,omitempty"`
}

func (m *ALGSpec) Reset()                    { *m = ALGSpec{} }
func (m *ALGSpec) String() string            { return proto.CompactTextString(m) }
func (*ALGSpec) ProtoMessage()               {}
func (*ALGSpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{4} }

type isALGSpec_AlgOptions interface {
	isALGSpec_AlgOptions()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ALGSpec_FTPOptions struct {
	FTPOptions *FTPOptions `protobuf:"bytes,2,opt,name=FTPOptions,oneof"`
}
type ALGSpec_DNSOptions struct {
	DNSOptions *DNSOptions `protobuf:"bytes,3,opt,name=DNSOptions,oneof"`
}
type ALGSpec_MSRPCOptions struct {
	MSRPCOptions *MSRPCOptions `protobuf:"bytes,4,opt,name=MSRPCOptions,oneof"`
}
type ALGSpec_SunRPCOptions struct {
	SunRPCOptions *SunRPCOptions `protobuf:"bytes,5,opt,name=SunRPCOptions,oneof"`
}

func (*ALGSpec_FTPOptions) isALGSpec_AlgOptions()    {}
func (*ALGSpec_DNSOptions) isALGSpec_AlgOptions()    {}
func (*ALGSpec_MSRPCOptions) isALGSpec_AlgOptions()  {}
func (*ALGSpec_SunRPCOptions) isALGSpec_AlgOptions() {}

func (m *ALGSpec) GetAlgOptions() isALGSpec_AlgOptions {
	if m != nil {
		return m.AlgOptions
	}
	return nil
}

func (m *ALGSpec) GetALG() ALG {
	if m != nil {
		return m.ALG
	}
	return ALG_ALG_NONE
}

func (m *ALGSpec) GetFTPOptions() *FTPOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_FTPOptions); ok {
		return x.FTPOptions
	}
	return nil
}

func (m *ALGSpec) GetDNSOptions() *DNSOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_DNSOptions); ok {
		return x.DNSOptions
	}
	return nil
}

func (m *ALGSpec) GetMSRPCOptions() *MSRPCOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_MSRPCOptions); ok {
		return x.MSRPCOptions
	}
	return nil
}

func (m *ALGSpec) GetSunRPCOptions() *SunRPCOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_SunRPCOptions); ok {
		return x.SunRPCOptions
	}
	return nil
}

func (m *ALGSpec) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ALGSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ALGSpec_OneofMarshaler, _ALGSpec_OneofUnmarshaler, _ALGSpec_OneofSizer, []interface{}{
		(*ALGSpec_FTPOptions)(nil),
		(*ALGSpec_DNSOptions)(nil),
		(*ALGSpec_MSRPCOptions)(nil),
		(*ALGSpec_SunRPCOptions)(nil),
	}
}

func _ALGSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ALGSpec)
	// alg_options
	switch x := m.AlgOptions.(type) {
	case *ALGSpec_FTPOptions:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FTPOptions); err != nil {
			return err
		}
	case *ALGSpec_DNSOptions:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DNSOptions); err != nil {
			return err
		}
	case *ALGSpec_MSRPCOptions:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MSRPCOptions); err != nil {
			return err
		}
	case *ALGSpec_SunRPCOptions:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SunRPCOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ALGSpec.AlgOptions has unexpected type %T", x)
	}
	return nil
}

func _ALGSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ALGSpec)
	switch tag {
	case 2: // alg_options.FTPOptions
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FTPOptions)
		err := b.DecodeMessage(msg)
		m.AlgOptions = &ALGSpec_FTPOptions{msg}
		return true, err
	case 3: // alg_options.DNSOptions
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DNSOptions)
		err := b.DecodeMessage(msg)
		m.AlgOptions = &ALGSpec_DNSOptions{msg}
		return true, err
	case 4: // alg_options.MSRPCOptions
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MSRPCOptions)
		err := b.DecodeMessage(msg)
		m.AlgOptions = &ALGSpec_MSRPCOptions{msg}
		return true, err
	case 5: // alg_options.SunRPCOptions
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SunRPCOptions)
		err := b.DecodeMessage(msg)
		m.AlgOptions = &ALGSpec_SunRPCOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ALGSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ALGSpec)
	// alg_options
	switch x := m.AlgOptions.(type) {
	case *ALGSpec_FTPOptions:
		s := proto.Size(x.FTPOptions)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ALGSpec_DNSOptions:
		s := proto.Size(x.DNSOptions)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ALGSpec_MSRPCOptions:
		s := proto.Size(x.MSRPCOptions)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ALGSpec_SunRPCOptions:
		s := proto.Size(x.SunRPCOptions)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// security rule attributes
type SecurityRuleAttrs struct {
	// stateful rule results in flow/session creation whereas stateless rule
	// will not result in flow creation
	Stateful bool `protobuf:"varint,1,opt,name=Stateful,proto3" json:"Stateful,omitempty" meta:mandatory`
	// priority of this rule (lower the numeric value, higher the priority is)
	// if there are multiple rules with same highest priority that match the
	// packet, the first such matching rule in the policy is picked (i.e., based on
	// the order, first in the list of such matching rules)
	Priority uint32 `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty" meta:range:0-1022`
	// rule match criteria
	Match *RuleMatch `protobuf:"bytes,3,opt,name=Match" json:"Match,omitempty"`
	// action to take when this rule is matched
	Action SecurityRuleAction `protobuf:"varint,4,opt,name=Action,proto3,enum=types.SecurityRuleAction" json:"Action,omitempty" meta:mandatory`
	// ALGSpec contains optional ALG specific behavior, if ALG is enabled for
	// this rule
	ALGSpec *ALGSpec `protobuf:"bytes,5,opt,name=ALGSpec" json:"ALGSpec,omitempty"`
}

func (m *SecurityRuleAttrs) Reset()                    { *m = SecurityRuleAttrs{} }
func (m *SecurityRuleAttrs) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleAttrs) ProtoMessage()               {}
func (*SecurityRuleAttrs) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{5} }

func (m *SecurityRuleAttrs) GetStateful() bool {
	if m != nil {
		return m.Stateful
	}
	return false
}

func (m *SecurityRuleAttrs) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SecurityRuleAttrs) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *SecurityRuleAttrs) GetAction() SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityRuleAttrs) GetALGSpec() *ALGSpec {
	if m != nil {
		return m.ALGSpec
	}
	return nil
}

// SecurityRuleInfo is a single rule in the security policy
type SecurityRuleInfo struct {
	// optional rule id needed if incremental route ADD/DEL/UPD functionality is needed
	Id    []byte             `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Attrs *SecurityRuleAttrs `protobuf:"bytes,2,opt,name=Attrs" json:"Attrs,omitempty" meta:mandatory`
}

func (m *SecurityRuleInfo) Reset()                    { *m = SecurityRuleInfo{} }
func (m *SecurityRuleInfo) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleInfo) ProtoMessage()               {}
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{6} }

func (m *SecurityRuleInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleInfo) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// security policy configuration
type SecurityPolicySpec struct {
	// unique identifier of security policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// IPv4 or IPv6 policy
	AddrFamily IPAF `protobuf:"varint,2,opt,name=AddrFamily,proto3,enum=types.IPAF" json:"AddrFamily,omitempty" meta:mandatory,immutable`
	// DefaultFWAction is the action taken by the firewall when SG policies are
	// configured on vnic but no rule is hit. Similarly, when NACLs are configured
	// on a subnet and no rule is hit, this action is taken by the firewall.
	// if this attribute is not set, it will inherit from security profile and if
	// that is also not set then  default "deny" action is enforced
	// NOTE: when no policy is configured on subnet and vnic, this knob doesn't
	//       apply and traffic is allowed in that case
	DefaultFWAction SecurityRuleAction `protobuf:"varint,3,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_NONE`
	// list of security rules
	Rules []*SecurityRuleInfo `protobuf:"bytes,4,rep,name=Rules" json:"Rules,omitempty" meta:mandatory`
}

func (m *SecurityPolicySpec) Reset()                    { *m = SecurityPolicySpec{} }
func (m *SecurityPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicySpec) ProtoMessage()               {}
func (*SecurityPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{7} }

func (m *SecurityPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicySpec) GetAddrFamily() IPAF {
	if m != nil {
		return m.AddrFamily
	}
	return IPAF_IP_AF_NONE
}

func (m *SecurityPolicySpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityPolicySpec) GetRules() []*SecurityRuleInfo {
	if m != nil {
		return m.Rules
	}
	return nil
}

// operational status of security policy, if any
type SecurityPolicyStatus struct {
}

func (m *SecurityPolicyStatus) Reset()                    { *m = SecurityPolicyStatus{} }
func (m *SecurityPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStatus) ProtoMessage()               {}
func (*SecurityPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{8} }

// stats of security policy, if any
type SecurityPolicyStats struct {
	// per security rule statistics
	RuleStats []*SecurityRuleStats `protobuf:"bytes,1,rep,name=RuleStats" json:"RuleStats,omitempty"`
}

func (m *SecurityPolicyStats) Reset()                    { *m = SecurityPolicyStats{} }
func (m *SecurityPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyStats) ProtoMessage()               {}
func (*SecurityPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{9} }

func (m *SecurityPolicyStats) GetRuleStats() []*SecurityRuleStats {
	if m != nil {
		return m.RuleStats
	}
	return nil
}

// security policy object
type SecurityPolicy struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityPolicyStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityPolicy) Reset()                    { *m = SecurityPolicy{} }
func (m *SecurityPolicy) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicy) ProtoMessage()               {}
func (*SecurityPolicy) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{10} }

func (m *SecurityPolicy) GetSpec() *SecurityPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityPolicy) GetStatus() *SecurityPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityPolicy) GetStats() *SecurityPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy create and update request
type SecurityPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt            `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   []*SecurityPolicySpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *SecurityPolicyRequest) Reset()                    { *m = SecurityPolicyRequest{} }
func (m *SecurityPolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyRequest) ProtoMessage()               {}
func (*SecurityPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{11} }

func (m *SecurityPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyRequest) GetRequest() []*SecurityPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy create and update response
type SecurityPolicyResponse struct {
	ApiStatus ApiStatus               `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityPolicyStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityPolicyResponse) Reset()                    { *m = SecurityPolicyResponse{} }
func (m *SecurityPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyResponse) ProtoMessage()               {}
func (*SecurityPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{12} }

func (m *SecurityPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyResponse) GetResponse() []*SecurityPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy get request
type SecurityPolicyGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityPolicyGetRequest) Reset()                    { *m = SecurityPolicyGetRequest{} }
func (m *SecurityPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetRequest) ProtoMessage()               {}
func (*SecurityPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{13} }

func (m *SecurityPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy get response
type SecurityPolicyGetResponse struct {
	ApiStatus ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityPolicy `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityPolicyGetResponse) Reset()                    { *m = SecurityPolicyGetResponse{} }
func (m *SecurityPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyGetResponse) ProtoMessage()               {}
func (*SecurityPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{14} }

func (m *SecurityPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyGetResponse) GetResponse() []*SecurityPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy delete request
type SecurityPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityPolicyDeleteRequest) Reset()         { *m = SecurityPolicyDeleteRequest{} }
func (m *SecurityPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{15}
}

func (m *SecurityPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy delete response
type SecurityPolicyDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityPolicyDeleteResponse) Reset()         { *m = SecurityPolicyDeleteResponse{} }
func (m *SecurityPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{16}
}

func (m *SecurityPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// unique id to identify a security policy rule
type SecurityPolicyRuleId struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId []byte `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
}

func (m *SecurityPolicyRuleId) Reset()                    { *m = SecurityPolicyRuleId{} }
func (m *SecurityPolicyRuleId) String() string            { return proto.CompactTextString(m) }
func (*SecurityPolicyRuleId) ProtoMessage()               {}
func (*SecurityPolicyRuleId) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{17} }

func (m *SecurityPolicyRuleId) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicyRuleId) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

// security rule configuration
type SecurityRuleSpec struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId []byte `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
	// rule information
	Attrs *SecurityRuleAttrs `protobuf:"bytes,3,opt,name=Attrs" json:"Attrs,omitempty" meta:mandatory`
}

func (m *SecurityRuleSpec) Reset()                    { *m = SecurityRuleSpec{} }
func (m *SecurityRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleSpec) ProtoMessage()               {}
func (*SecurityRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{18} }

func (m *SecurityRuleSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleSpec) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

func (m *SecurityRuleSpec) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// operational status of the security rule, if any
type SecurityRuleStatus struct {
}

func (m *SecurityRuleStatus) Reset()                    { *m = SecurityRuleStatus{} }
func (m *SecurityRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStatus) ProtoMessage()               {}
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{19} }

// stats of the security rule, if any
type SecurityRuleStats struct {
	// number of times the rule is hit
	NumRuleHit uint64 `protobuf:"varint,1,opt,name=NumRuleHit,proto3" json:"NumRuleHit,omitempty"`
}

func (m *SecurityRuleStats) Reset()                    { *m = SecurityRuleStats{} }
func (m *SecurityRuleStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStats) ProtoMessage()               {}
func (*SecurityRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{20} }

func (m *SecurityRuleStats) GetNumRuleHit() uint64 {
	if m != nil {
		return m.NumRuleHit
	}
	return 0
}

// security rule object
type SecurityRule struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityRuleSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityRuleStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityRuleStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityRule) Reset()                    { *m = SecurityRule{} }
func (m *SecurityRule) String() string            { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()               {}
func (*SecurityRule) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{21} }

func (m *SecurityRule) GetSpec() *SecurityRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityRule) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityRule) GetStats() *SecurityRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy rule create and update request
type SecurityRuleRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// security policy rule configuration
	Request *SecurityRuleSpec `protobuf:"bytes,2,opt,name=Request" json:"Request,omitempty"`
}

func (m *SecurityRuleRequest) Reset()                    { *m = SecurityRuleRequest{} }
func (m *SecurityRuleRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleRequest) ProtoMessage()               {}
func (*SecurityRuleRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{22} }

func (m *SecurityRuleRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleRequest) GetRequest() *SecurityRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy rule create and update response
type SecurityRuleResponse struct {
	// success or failure status
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// operational status
	Response *SecurityRuleStatus `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *SecurityRuleResponse) Reset()                    { *m = SecurityRuleResponse{} }
func (m *SecurityRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleResponse) ProtoMessage()               {}
func (*SecurityRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{23} }

func (m *SecurityRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleResponse) GetResponse() *SecurityRuleStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule get request
type SecurityRuleGetRequest struct {
	// list of id/key of the security policy rules of interest
	Id []*SecurityPolicyRuleId `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty" meta:mandatory`
}

func (m *SecurityRuleGetRequest) Reset()                    { *m = SecurityRuleGetRequest{} }
func (m *SecurityRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetRequest) ProtoMessage()               {}
func (*SecurityRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{24} }

func (m *SecurityRuleGetRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule get response
type SecurityRuleGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// security policy rule information
	Response []*SecurityRule `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityRuleGetResponse) Reset()                    { *m = SecurityRuleGetResponse{} }
func (m *SecurityRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetResponse) ProtoMessage()               {}
func (*SecurityRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{25} }

func (m *SecurityRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleGetResponse) GetResponse() []*SecurityRule {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule delete request
type SecurityRuleDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	// id/key list of the security policy rule(s) to be deleted
	Id []*SecurityPolicyRuleId `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityRuleDeleteRequest) Reset()                    { *m = SecurityRuleDeleteRequest{} }
func (m *SecurityRuleDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteRequest) ProtoMessage()               {}
func (*SecurityRuleDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{26} }

func (m *SecurityRuleDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleDeleteRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule delete response
type SecurityRuleDeleteResponse struct {
	// API status code
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityRuleDeleteResponse) Reset()         { *m = SecurityRuleDeleteResponse{} }
func (m *SecurityRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteResponse) ProtoMessage()    {}
func (*SecurityRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{27}
}

func (m *SecurityRuleDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// security profile configuration
// NOTE:
// 1. currently security profile object is global and only a singleton object,
//    any attempt to create multiple objects will be treated as an error
// 2. if no object is created, indicated default values will be used
type SecurityProfileSpec struct {
	// unique identifier of security profile
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// ConnTrackEn, if set to true, will enable full connection tracking
	// NOTE: if ConnTrackEn is modified on the fly, it will take affect only on
	//       sessions created thereafter and doesn't affect existing sessions
	ConnTrackEn bool `protobuf:"varint,2,opt,name=ConnTrackEn,proto3" json:"ConnTrackEn,omitempty" meta:default=false`
	// DefaultFWAction is the action taken by the smartnic when policies are
	// configured on the subnet or vnic, no rule matches and default action for policy is none
	// this will have effect iff policy is attached on either vnic or subnet.
	// if no action is specified  in security profile, default action is "deny"
	DefaultFWAction SecurityRuleAction `protobuf:"varint,3,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_DENY`
	// timeouts for established sessions per TCP/UDP/ICMP and other protocols
	TCPIdleTimeout   uint32 `protobuf:"varint,4,opt,name=TCPIdleTimeout,proto3" json:"TCPIdleTimeout,omitempty" meta:range:5-86400, meta:default=600`
	UDPIdleTimeout   uint32 `protobuf:"varint,5,opt,name=UDPIdleTimeout,proto3" json:"UDPIdleTimeout,omitempty" meta:range:5-86400, meta:default=120`
	ICMPIdleTimeout  uint32 `protobuf:"varint,6,opt,name=ICMPIdleTimeout,proto3" json:"ICMPIdleTimeout,omitempty" meta:range:5-86400, meta:default=15`
	OtherIdleTimeout uint32 `protobuf:"varint,7,opt,name=OtherIdleTimeout,proto3" json:"OtherIdleTimeout,omitempty" meta:range:30-86400, meta:default=90`
	// TCP specific timeouts
	// TCPCnxnSetupTimeout is the maximum allowed time since first SYN seen to
	// 3-way handshake completion, session gets cleaned up if 3-way handshake is
	// not completed and session moves to ESTABLISHED state by then
	TCPCnxnSetupTimeout uint32 `protobuf:"varint,8,opt,name=TCPCnxnSetupTimeout,proto3" json:"TCPCnxnSetupTimeout,omitempty" meta:range:1-60, meta:default=10`
	// TCPHalfCloseTimeout is the maximum allowed time since first FIN seen to
	// 3/4way close, session gets cleaned up if this timer elapses.
	TCPHalfCloseTimeout uint32 `protobuf:"varint,9,opt,name=TCPHalfCloseTimeout,proto3" json:"TCPHalfCloseTimeout,omitempty" meta:range:1-172800, meta:default=120`
	// TCPCloseTimeout is wait time since FIN is seen from *both* sides (or RST)
	// before cleaning up the session
	TCPCloseTimeout uint32 `protobuf:"varint,10,opt,name=TCPCloseTimeout,proto3" json:"TCPCloseTimeout,omitempty" meta:range:1-300, meta:default=15`
	// timeouts applicable to sessions installed with drop action
	TCPDropTimeout   uint32 `protobuf:"varint,11,opt,name=TCPDropTimeout,proto3" json:"TCPDropTimeout,omitempty" meta:range:1-300, meta:default=90`
	UDPDropTimeout   uint32 `protobuf:"varint,12,opt,name=UDPDropTimeout,proto3" json:"UDPDropTimeout,omitempty" meta:range:1-172800, meta:default=60`
	ICMPDropTimeout  uint32 `protobuf:"varint,13,opt,name=ICMPDropTimeout,proto3" json:"ICMPDropTimeout,omitempty" meta:range:1-300, meta:default=30`
	OtherDropTimeout uint32 `protobuf:"varint,14,opt,name=OtherDropTimeout,proto3" json:"OtherDropTimeout,omitempty" meta:range:1-300, meta:default=60`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{28} }

func (m *SecurityProfileSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityProfileSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SecurityProfileSpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTCPIdleTimeout() uint32 {
	if m != nil {
		return m.TCPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPIdleTimeout() uint32 {
	if m != nil {
		return m.UDPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPIdleTimeout() uint32 {
	if m != nil {
		return m.ICMPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherIdleTimeout() uint32 {
	if m != nil {
		return m.OtherIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCnxnSetupTimeout() uint32 {
	if m != nil {
		return m.TCPCnxnSetupTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPHalfCloseTimeout() uint32 {
	if m != nil {
		return m.TCPHalfCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCloseTimeout() uint32 {
	if m != nil {
		return m.TCPCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPDropTimeout() uint32 {
	if m != nil {
		return m.TCPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPDropTimeout() uint32 {
	if m != nil {
		return m.UDPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPDropTimeout() uint32 {
	if m != nil {
		return m.ICMPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherDropTimeout() uint32 {
	if m != nil {
		return m.OtherDropTimeout
	}
	return 0
}

// operational status of security profile, if any
type SecurityProfileStatus struct {
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{29} }

// stats of security profile, if any
type SecurityProfileStats struct {
}

func (m *SecurityProfileStats) Reset()                    { *m = SecurityProfileStats{} }
func (m *SecurityProfileStats) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStats) ProtoMessage()               {}
func (*SecurityProfileStats) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{30} }

// security profile object
type SecurityProfile struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjMeta,embedded=ObjMeta" json:"meta,omitempty"`
	Spec           *SecurityProfileSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SecurityProfileStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SecurityProfileStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *SecurityProfile) Reset()                    { *m = SecurityProfile{} }
func (m *SecurityProfile) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfile) ProtoMessage()               {}
func (*SecurityProfile) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{31} }

func (m *SecurityProfile) GetSpec() *SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityProfile) GetStatus() *SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityProfile) GetStats() *SecurityProfileStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security profile create and update request
type SecurityProfileRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt             `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   []*SecurityProfileSpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *SecurityProfileRequest) Reset()                    { *m = SecurityProfileRequest{} }
func (m *SecurityProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileRequest) ProtoMessage()               {}
func (*SecurityProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{32} }

func (m *SecurityProfileRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileRequest) GetRequest() []*SecurityProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security profile create and update response
type SecurityProfileResponse struct {
	ApiStatus ApiStatus                `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityProfileStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityProfileResponse) Reset()                    { *m = SecurityProfileResponse{} }
func (m *SecurityProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileResponse) ProtoMessage()               {}
func (*SecurityProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{33} }

func (m *SecurityProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileResponse) GetResponse() []*SecurityProfileStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile get request
type SecurityProfileGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityProfileGetRequest) Reset()                    { *m = SecurityProfileGetRequest{} }
func (m *SecurityProfileGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequest) ProtoMessage()               {}
func (*SecurityProfileGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPolicy, []int{34} }

func (m *SecurityProfileGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile get response
type SecurityProfileGetResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SecurityProfile `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SecurityProfileGetResponse) Reset()         { *m = SecurityProfileGetResponse{} }
func (m *SecurityProfileGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponse) ProtoMessage()    {}
func (*SecurityProfileGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{35}
}

func (m *SecurityProfileGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileGetResponse) GetResponse() []*SecurityProfile {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile delete request
type SecurityProfileDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SecurityProfileDeleteRequest) Reset()         { *m = SecurityProfileDeleteRequest{} }
func (m *SecurityProfileDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequest) ProtoMessage()    {}
func (*SecurityProfileDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{36}
}

func (m *SecurityProfileDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile delete response
type SecurityProfileDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SecurityProfileDeleteResponse) Reset()         { *m = SecurityProfileDeleteResponse{} }
func (m *SecurityProfileDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponse) ProtoMessage()    {}
func (*SecurityProfileDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPolicy, []int{37}
}

func (m *SecurityProfileDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*FTPOptions)(nil), "pds.FTPOptions")
	proto.RegisterType((*DNSOptions)(nil), "pds.DNSOptions")
	proto.RegisterType((*MSRPCOptions)(nil), "pds.MSRPCOptions")
	proto.RegisterType((*SunRPCOptions)(nil), "pds.SunRPCOptions")
	proto.RegisterType((*ALGSpec)(nil), "pds.ALGSpec")
	proto.RegisterType((*SecurityRuleAttrs)(nil), "pds.SecurityRuleAttrs")
	proto.RegisterType((*SecurityRuleInfo)(nil), "pds.SecurityRuleInfo")
	proto.RegisterType((*SecurityPolicySpec)(nil), "pds.SecurityPolicySpec")
	proto.RegisterType((*SecurityPolicyStatus)(nil), "pds.SecurityPolicyStatus")
	proto.RegisterType((*SecurityPolicyStats)(nil), "pds.SecurityPolicyStats")
	proto.RegisterType((*SecurityPolicy)(nil), "pds.SecurityPolicy")
	proto.RegisterType((*SecurityPolicyRequest)(nil), "pds.SecurityPolicyRequest")
	proto.RegisterType((*SecurityPolicyResponse)(nil), "pds.SecurityPolicyResponse")
	proto.RegisterType((*SecurityPolicyGetRequest)(nil), "pds.SecurityPolicyGetRequest")
	proto.RegisterType((*SecurityPolicyGetResponse)(nil), "pds.SecurityPolicyGetResponse")
	proto.RegisterType((*SecurityPolicyDeleteRequest)(nil), "pds.SecurityPolicyDeleteRequest")
	proto.RegisterType((*SecurityPolicyDeleteResponse)(nil), "pds.SecurityPolicyDeleteResponse")
	proto.RegisterType((*SecurityPolicyRuleId)(nil), "pds.SecurityPolicyRuleId")
	proto.RegisterType((*SecurityRuleSpec)(nil), "pds.SecurityRuleSpec")
	proto.RegisterType((*SecurityRuleStatus)(nil), "pds.SecurityRuleStatus")
	proto.RegisterType((*SecurityRuleStats)(nil), "pds.SecurityRuleStats")
	proto.RegisterType((*SecurityRule)(nil), "pds.SecurityRule")
	proto.RegisterType((*SecurityRuleRequest)(nil), "pds.SecurityRuleRequest")
	proto.RegisterType((*SecurityRuleResponse)(nil), "pds.SecurityRuleResponse")
	proto.RegisterType((*SecurityRuleGetRequest)(nil), "pds.SecurityRuleGetRequest")
	proto.RegisterType((*SecurityRuleGetResponse)(nil), "pds.SecurityRuleGetResponse")
	proto.RegisterType((*SecurityRuleDeleteRequest)(nil), "pds.SecurityRuleDeleteRequest")
	proto.RegisterType((*SecurityRuleDeleteResponse)(nil), "pds.SecurityRuleDeleteResponse")
	proto.RegisterType((*SecurityProfileSpec)(nil), "pds.SecurityProfileSpec")
	proto.RegisterType((*SecurityProfileStatus)(nil), "pds.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileStats)(nil), "pds.SecurityProfileStats")
	proto.RegisterType((*SecurityProfile)(nil), "pds.SecurityProfile")
	proto.RegisterType((*SecurityProfileRequest)(nil), "pds.SecurityProfileRequest")
	proto.RegisterType((*SecurityProfileResponse)(nil), "pds.SecurityProfileResponse")
	proto.RegisterType((*SecurityProfileGetRequest)(nil), "pds.SecurityProfileGetRequest")
	proto.RegisterType((*SecurityProfileGetResponse)(nil), "pds.SecurityProfileGetResponse")
	proto.RegisterType((*SecurityProfileDeleteRequest)(nil), "pds.SecurityProfileDeleteRequest")
	proto.RegisterType((*SecurityProfileDeleteResponse)(nil), "pds.SecurityProfileDeleteResponse")
	proto.RegisterEnum("pds.ALG", ALG_name, ALG_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SecurityPolicySvc service

type SecurityPolicySvcClient interface {
	// security policy APIs
	SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error)
	SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error)
	// security policy rule APIs
	SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error)
}

type securityPolicySvcClient struct {
	cc *grpc.ClientConn
}

func NewSecurityPolicySvcClient(cc *grpc.ClientConn) SecurityPolicySvcClient {
	return &securityPolicySvcClient{cc}
}

func (c *securityPolicySvcClient) SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error) {
	out := new(SecurityPolicyGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error) {
	out := new(SecurityPolicyDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error) {
	out := new(SecurityRuleGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error) {
	out := new(SecurityRuleDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error) {
	out := new(SecurityProfileGetResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error) {
	out := new(SecurityProfileDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SecurityPolicySvc service

type SecurityPolicySvcServer interface {
	// security policy APIs
	SecurityPolicyCreate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(context.Context, *SecurityPolicyGetRequest) (*SecurityPolicyGetResponse, error)
	SecurityPolicyDelete(context.Context, *SecurityPolicyDeleteRequest) (*SecurityPolicyDeleteResponse, error)
	// security policy rule APIs
	SecurityRuleCreate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleGet(context.Context, *SecurityRuleGetRequest) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(context.Context, *SecurityRuleDeleteRequest) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileGet(context.Context, *SecurityProfileGetRequest) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(context.Context, *SecurityProfileDeleteRequest) (*SecurityProfileDeleteResponse, error)
}

func RegisterSecurityPolicySvcServer(s *grpc.Server, srv SecurityPolicySvcServer) {
	s.RegisterService(&_SecurityPolicySvc_serviceDesc, srv)
}

func _SecurityPolicySvc_SecurityPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, req.(*SecurityPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, req.(*SecurityPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, req.(*SecurityRuleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, req.(*SecurityRuleDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, req.(*SecurityProfileGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, req.(*SecurityProfileDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SecurityPolicySvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SecurityPolicySvc",
	HandlerType: (*SecurityPolicySvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityPolicyCreate",
			Handler:    _SecurityPolicySvc_SecurityPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityPolicyUpdate",
			Handler:    _SecurityPolicySvc_SecurityPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityPolicyGet",
			Handler:    _SecurityPolicySvc_SecurityPolicyGet_Handler,
		},
		{
			MethodName: "SecurityPolicyDelete",
			Handler:    _SecurityPolicySvc_SecurityPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityRuleCreate",
			Handler:    _SecurityPolicySvc_SecurityRuleCreate_Handler,
		},
		{
			MethodName: "SecurityRuleUpdate",
			Handler:    _SecurityPolicySvc_SecurityRuleUpdate_Handler,
		},
		{
			MethodName: "SecurityRuleGet",
			Handler:    _SecurityPolicySvc_SecurityRuleGet_Handler,
		},
		{
			MethodName: "SecurityRuleDelete",
			Handler:    _SecurityPolicySvc_SecurityRuleDelete_Handler,
		},
		{
			MethodName: "SecurityProfileCreate",
			Handler:    _SecurityPolicySvc_SecurityProfileCreate_Handler,
		},
		{
			MethodName: "SecurityProfileUpdate",
			Handler:    _SecurityPolicySvc_SecurityProfileUpdate_Handler,
		},
		{
			MethodName: "SecurityProfileGet",
			Handler:    _SecurityPolicySvc_SecurityProfileGet_Handler,
		},
		{
			MethodName: "SecurityProfileDelete",
			Handler:    _SecurityPolicySvc_SecurityProfileDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "policy.proto",
}

func (m *FTPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowIPMismatch {
		dAtA[i] = 0x8
		i++
		if m.AllowIPMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DNSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ResponseTimeout))
	}
	if m.DropMultiQueryMessage {
		dAtA[i] = 0x10
		i++
		if m.DropMultiQueryMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLargeDomainNameMessage {
		dAtA[i] = 0x18
		i++
		if m.DropLargeDomainNameMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLongLabelMessage {
		dAtA[i] = 0x20
		i++
		if m.DropLongLabelMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMultiZonePackets {
		dAtA[i] = 0x28
		i++
		if m.DropMultiZonePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxMessageLength != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.MaxMessageLength))
	}
	return i, nil
}

func (m *MSRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		for _, b := range m.ProgramId {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SunRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		for _, b := range m.ProgramId {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *ALGSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ALGSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ALG != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ALG))
	}
	if m.AlgOptions != nil {
		nn1, err := m.AlgOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.IdleTimeout))
	}
	return i, nil
}

func (m *ALGSpec_FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FTPOptions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.FTPOptions.Size()))
		n2, err := m.FTPOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *ALGSpec_DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DNSOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.DNSOptions.Size()))
		n3, err := m.DNSOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *ALGSpec_MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MSRPCOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.MSRPCOptions.Size()))
		n4, err := m.MSRPCOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *ALGSpec_SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SunRPCOptions != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.SunRPCOptions.Size()))
		n5, err := m.SunRPCOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *SecurityRuleAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleAttrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stateful {
		dAtA[i] = 0x8
		i++
		if m.Stateful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Priority))
	}
	if m.Match != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Match.Size()))
		n6, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Action != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Action))
	}
	if m.ALGSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ALGSpec.Size()))
		n7, err := m.ALGSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SecurityRuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Attrs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Attrs.Size()))
		n8, err := m.Attrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SecurityPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.AddrFamily != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.AddrFamily))
	}
	if m.DefaultFWAction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuleStats) > 0 {
		for _, msg := range m.RuleStats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n10, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n11, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n12, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n13, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *SecurityPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n14, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n15, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA17 := make([]byte, len(m.ApiStatus)*10)
		var j16 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	return i, nil
}

func (m *SecurityPolicyRuleId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRuleId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SecurityPolicyId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i += copy(dAtA[i:], m.SecurityPolicyId)
	}
	return i, nil
}

func (m *SecurityRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SecurityPolicyId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i += copy(dAtA[i:], m.SecurityPolicyId)
	}
	if m.Attrs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Attrs.Size()))
		n18, err := m.Attrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SecurityRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumRuleHit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.NumRuleHit))
	}
	return i, nil
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n19, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n20, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n21, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n22, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n23, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *SecurityRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n24, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Request.Size()))
		n25, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SecurityRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Response.Size()))
		n26, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *SecurityRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, msg := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n27, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Id) > 0 {
		for _, msg := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA29 := make([]byte, len(m.ApiStatus)*10)
		var j28 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	return i, nil
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ConnTrackEn {
		dAtA[i] = 0x10
		i++
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultFWAction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
	}
	if m.TCPIdleTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPIdleTimeout))
	}
	if m.UDPIdleTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPIdleTimeout))
	}
	if m.ICMPIdleTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPIdleTimeout))
	}
	if m.OtherIdleTimeout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherIdleTimeout))
	}
	if m.TCPCnxnSetupTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCnxnSetupTimeout))
	}
	if m.TCPHalfCloseTimeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPHalfCloseTimeout))
	}
	if m.TCPCloseTimeout != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCloseTimeout))
	}
	if m.TCPDropTimeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPDropTimeout))
	}
	if m.UDPDropTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPDropTimeout))
	}
	if m.ICMPDropTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPDropTimeout))
	}
	if m.OtherDropTimeout != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherDropTimeout))
	}
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SecurityProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.TypeMeta.Size()))
		n30, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ObjMeta.Size()))
		n31, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Spec.Size()))
		n32, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Status.Size()))
		n33, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Stats.Size()))
		n34, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *SecurityProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n35, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityProfileGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.BatchCtxt.Size()))
		n36, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SecurityProfileDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA38 := make([]byte, len(m.ApiStatus)*10)
		var j37 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	return i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FTPOptions) Size() (n int) {
	var l int
	_ = l
	if m.AllowIPMismatch {
		n += 2
	}
	return n
}

func (m *DNSOptions) Size() (n int) {
	var l int
	_ = l
	if m.ResponseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ResponseTimeout))
	}
	if m.DropMultiQueryMessage {
		n += 2
	}
	if m.DropLargeDomainNameMessage {
		n += 2
	}
	if m.DropLongLabelMessage {
		n += 2
	}
	if m.DropMultiZonePackets {
		n += 2
	}
	if m.MaxMessageLength != 0 {
		n += 1 + sovPolicy(uint64(m.MaxMessageLength))
	}
	return n
}

func (m *MSRPCOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		for _, b := range m.ProgramId {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SunRPCOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		for _, b := range m.ProgramId {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *ALGSpec) Size() (n int) {
	var l int
	_ = l
	if m.ALG != 0 {
		n += 1 + sovPolicy(uint64(m.ALG))
	}
	if m.AlgOptions != nil {
		n += m.AlgOptions.Size()
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.IdleTimeout))
	}
	return n
}

func (m *ALGSpec_FTPOptions) Size() (n int) {
	var l int
	_ = l
	if m.FTPOptions != nil {
		l = m.FTPOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_DNSOptions) Size() (n int) {
	var l int
	_ = l
	if m.DNSOptions != nil {
		l = m.DNSOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_MSRPCOptions) Size() (n int) {
	var l int
	_ = l
	if m.MSRPCOptions != nil {
		l = m.MSRPCOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_SunRPCOptions) Size() (n int) {
	var l int
	_ = l
	if m.SunRPCOptions != nil {
		l = m.SunRPCOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *SecurityRuleAttrs) Size() (n int) {
	var l int
	_ = l
	if m.Stateful {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovPolicy(uint64(m.Priority))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPolicy(uint64(m.Action))
	}
	if m.ALGSpec != nil {
		l = m.ALGSpec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.AddrFamily != 0 {
		n += 1 + sovPolicy(uint64(m.AddrFamily))
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityPolicyStats) Size() (n int) {
	var l int
	_ = l
	if len(m.RuleStats) > 0 {
		for _, e := range m.RuleStats {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicy) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityPolicyRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func (m *SecurityPolicyRuleId) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.NumRuleHit != 0 {
		n += 1 + sovPolicy(uint64(m.NumRuleHit))
	}
	return n
}

func (m *SecurityRule) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ConnTrackEn {
		n += 2
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if m.TCPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPIdleTimeout))
	}
	if m.UDPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPIdleTimeout))
	}
	if m.ICMPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPIdleTimeout))
	}
	if m.OtherIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherIdleTimeout))
	}
	if m.TCPCnxnSetupTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCnxnSetupTimeout))
	}
	if m.TCPHalfCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPHalfCloseTimeout))
	}
	if m.TCPCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCloseTimeout))
	}
	if m.TCPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPDropTimeout))
	}
	if m.UDPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPDropTimeout))
	}
	if m.ICMPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPDropTimeout))
	}
	if m.OtherDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherDropTimeout))
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfileStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SecurityProfile) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}

func (m *SecurityProfileRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FTPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIPMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIPMismatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimeout", wireType)
			}
			m.ResponseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQueryMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQueryMessage = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainNameMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainNameMessage = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLongLabelMessage = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiZonePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiZonePackets = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMessageLength", wireType)
			}
			m.MaxMessageLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMessageLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = append(m.ProgramId, make([]byte, postIndex-iNdEx))
			copy(m.ProgramId[len(m.ProgramId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SunRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SunRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SunRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = append(m.ProgramId, make([]byte, postIndex-iNdEx))
			copy(m.ProgramId[len(m.ProgramId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ALGSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ALGSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ALGSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALG", wireType)
			}
			m.ALG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ALG |= (ALG(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTPOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FTPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_FTPOptions{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DNSOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_DNSOptions{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSRPCOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MSRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_MSRPCOptions{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SunRPCOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SunRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_SunRPCOptions{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stateful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stateful = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALGSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ALGSpec == nil {
				m.ALGSpec = &ALGSpec{}
			}
			if err := m.ALGSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrFamily", wireType)
			}
			m.AddrFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrFamily |= (IPAF(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &SecurityRuleInfo{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleStats = append(m.RuleStats, &SecurityRuleStats{})
			if err := m.RuleStats[len(m.RuleStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRuleId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRuleHit", wireType)
			}
			m.NumRuleHit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRuleHit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &SecurityRuleSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &SecurityRuleStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRule{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= (SecurityRuleAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPIdleTimeout", wireType)
			}
			m.TCPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPIdleTimeout", wireType)
			}
			m.UDPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPIdleTimeout", wireType)
			}
			m.ICMPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherIdleTimeout", wireType)
			}
			m.OtherIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherIdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCnxnSetupTimeout", wireType)
			}
			m.TCPCnxnSetupTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCnxnSetupTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPHalfCloseTimeout", wireType)
			}
			m.TCPHalfCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPHalfCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCloseTimeout", wireType)
			}
			m.TCPCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCloseTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPDropTimeout", wireType)
			}
			m.TCPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPDropTimeout", wireType)
			}
			m.UDPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPDropTimeout", wireType)
			}
			m.ICMPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDropTimeout", wireType)
			}
			m.OtherDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherDropTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityProfileSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityProfileStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfile{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("policy.proto", fileDescriptorPolicy) }

var fileDescriptorPolicy = []byte{
	// 1983 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x73, 0x1a, 0xc9,
	0x15, 0x16, 0xe8, 0x17, 0x7a, 0x20, 0xc0, 0x2d, 0x59, 0x46, 0xd8, 0x2b, 0xe4, 0xc9, 0xae, 0xa3,
	0x75, 0x24, 0x19, 0x46, 0xb6, 0xd6, 0x76, 0xca, 0xf1, 0xf2, 0x43, 0x3f, 0xa8, 0x05, 0x84, 0x1b,
	0x14, 0xd7, 0x26, 0xb5, 0x51, 0xc6, 0xd0, 0xc2, 0x64, 0x81, 0x21, 0xcc, 0xe0, 0x58, 0xc9, 0x56,
	0x52, 0xc9, 0x3d, 0x39, 0xe7, 0xdf, 0xc8, 0x5f, 0x90, 0x6b, 0x0e, 0x39, 0xec, 0x25, 0xc7, 0x50,
	0x89, 0x8f, 0x3e, 0x72, 0x4e, 0x55, 0x52, 0xd3, 0x3d, 0xc3, 0xf4, 0xcc, 0x34, 0x48, 0xc6, 0x9b,
	0xf2, 0xc5, 0xe5, 0xe9, 0x7e, 0xdf, 0x37, 0xaf, 0xbf, 0x7e, 0xf3, 0xbd, 0x6e, 0x04, 0xa1, 0xae,
	0xda, 0x6a, 0xd6, 0x2e, 0x76, 0xbb, 0x3d, 0x55, 0x57, 0xd1, 0x6c, 0xb7, 0xae, 0xc5, 0xa1, 0xa1,
	0x36, 0x54, 0x36, 0x10, 0x8f, 0xb4, 0x89, 0xae, 0xdc, 0x33, 0xfe, 0x31, 0x07, 0x82, 0xfa, 0x45,
	0x97, 0x68, 0xec, 0x41, 0xda, 0x07, 0x38, 0xac, 0x96, 0x4f, 0xba, 0x7a, 0x53, 0xed, 0x68, 0x68,
	0x0b, 0x22, 0xe9, 0x56, 0x4b, 0xfd, 0x55, 0xbe, 0x5c, 0x6c, 0x6a, 0x6d, 0x45, 0xaf, 0xbd, 0x8c,
	0xf9, 0x36, 0x7d, 0x5b, 0x01, 0xec, 0x1e, 0x96, 0xfe, 0xeb, 0x07, 0xc8, 0x95, 0x2a, 0x16, 0xf0,
	0x09, 0x44, 0x30, 0xd1, 0xba, 0x6a, 0x47, 0x23, 0xd5, 0x66, 0x9b, 0xa8, 0x7d, 0x9d, 0x02, 0x97,
	0x33, 0x2b, 0xc3, 0x41, 0x82, 0x66, 0xf0, 0xb8, 0x4e, 0xce, 0x95, 0x7e, 0x4b, 0x7f, 0xb2, 0x9f,
	0xc4, 0xee, 0x58, 0x74, 0x1f, 0xae, 0xe7, 0x7a, 0x6a, 0xb7, 0xd8, 0x6f, 0xe9, 0xcd, 0x67, 0x7d,
	0xd2, 0xbb, 0x28, 0x12, 0x4d, 0x53, 0x1a, 0x24, 0xe6, 0xa7, 0x6f, 0x17, 0x4f, 0xa2, 0x1f, 0x41,
	0xdc, 0x98, 0x28, 0x28, 0xbd, 0x06, 0xc9, 0xa9, 0x6d, 0xa5, 0xd9, 0x29, 0x29, 0x6d, 0x62, 0x41,
	0x67, 0x29, 0x74, 0x42, 0x04, 0x92, 0x61, 0x95, 0xce, 0xaa, 0x9d, 0x46, 0x41, 0x79, 0x41, 0x5a,
	0x16, 0x72, 0x8e, 0x22, 0x85, 0x73, 0x16, 0x86, 0x26, 0xf3, 0x13, 0xb5, 0x43, 0xca, 0x4a, 0xed,
	0x6b, 0xa2, 0x6b, 0xb1, 0x79, 0x1b, 0xe3, 0x9e, 0x43, 0x55, 0x88, 0x16, 0x95, 0xd7, 0x26, 0x43,
	0x81, 0x74, 0x1a, 0xfa, 0xcb, 0xd8, 0x02, 0x55, 0x67, 0x6b, 0x38, 0x48, 0x7c, 0x4c, 0xd5, 0xe9,
	0x29, 0x9d, 0x06, 0x79, 0xfc, 0x20, 0x25, 0xef, 0x3c, 0x4c, 0x3d, 0x92, 0xb7, 0x1d, 0x8a, 0x3d,
	0x48, 0xc9, 0xd8, 0xc3, 0x20, 0x6d, 0x43, 0xa8, 0x58, 0xc1, 0xe5, 0xac, 0xb5, 0x05, 0xb7, 0x60,
	0xa9, 0xdc, 0x53, 0x1b, 0x3d, 0xa5, 0x9d, 0xaf, 0xc7, 0x7c, 0x9b, 0xb3, 0x5b, 0x21, 0x6c, 0x0f,
	0x48, 0x3b, 0xb0, 0x5c, 0xe9, 0x77, 0xae, 0x1c, 0xfe, 0x17, 0x3f, 0x2c, 0xa6, 0x0b, 0x47, 0x95,
	0x2e, 0xa9, 0xa1, 0x38, 0xcc, 0xa6, 0x0b, 0x47, 0x74, 0x3f, 0xc3, 0x72, 0x60, 0xb7, 0x5b, 0xd7,
	0x76, 0xd3, 0x85, 0x23, 0x6c, 0x0c, 0xa2, 0x14, 0x5f, 0x3e, 0x74, 0xb7, 0x82, 0x72, 0x84, 0x86,
	0xd8, 0xc3, 0xc7, 0x33, 0x98, 0xaf, 0xb1, 0x14, 0x5f, 0x38, 0x74, 0x97, 0x2c, 0x88, 0x3d, 0x6c,
	0x40, 0xb8, 0xea, 0xfa, 0xcc, 0xb9, 0x54, 0xba, 0x41, 0x41, 0xf9, 0x1a, 0x05, 0xf1, 0x13, 0xc7,
	0x33, 0xd8, 0xa9, 0xc9, 0x63, 0xd7, 0xaa, 0xe9, 0x36, 0x05, 0x65, 0x44, 0x91, 0x8e, 0x99, 0xe3,
	0x19, 0xec, 0x12, 0x68, 0x13, 0x82, 0xf9, 0x7a, 0x6b, 0x54, 0xce, 0x74, 0xc3, 0x30, 0x3f, 0x94,
	0x59, 0x86, 0xa0, 0xd2, 0x6a, 0x9c, 0xa9, 0x0c, 0x20, 0xfd, 0xd1, 0x0f, 0xd7, 0x2a, 0xa4, 0xd6,
	0xef, 0x35, 0xf5, 0x0b, 0xdc, 0x6f, 0x91, 0xb4, 0xae, 0xf7, 0x34, 0xb4, 0x0b, 0x81, 0x8a, 0xae,
	0xe8, 0xe4, 0xbc, 0xdf, 0x62, 0xdf, 0x52, 0x06, 0x0d, 0x07, 0x89, 0x30, 0xdd, 0xe0, 0xb6, 0xd2,
	0xa9, 0x2b, 0xba, 0xda, 0xbb, 0xc0, 0xa3, 0x18, 0x94, 0x82, 0x40, 0xb9, 0xd7, 0x54, 0x0d, 0x12,
	0xaa, 0xe7, 0x72, 0xe6, 0xfa, 0x70, 0x90, 0xb8, 0xc6, 0x15, 0x49, 0x72, 0x27, 0x95, 0x94, 0x65,
	0x3c, 0x0a, 0x43, 0x77, 0x60, 0xbe, 0x48, 0xbf, 0x55, 0x26, 0x66, 0x74, 0x97, 0x7d, 0xe0, 0x46,
	0x0e, 0x74, 0x1c, 0xb3, 0x69, 0x74, 0x00, 0x0b, 0xe9, 0x9a, 0x91, 0x2b, 0x15, 0x30, 0x2c, 0xaf,
	0x9b, 0x81, 0x8e, 0xa4, 0x69, 0x80, 0x30, 0x47, 0x13, 0x8c, 0xee, 0x8c, 0x4a, 0xc3, 0x94, 0x33,
	0x64, 0xd5, 0x84, 0x31, 0x86, 0xad, 0x49, 0xe9, 0x0f, 0x3e, 0x88, 0xf2, 0xd4, 0xf9, 0xce, 0xb9,
	0x8a, 0xb6, 0xc1, 0x4f, 0xeb, 0xcd, 0xb7, 0x15, 0xca, 0xdc, 0x1a, 0x0e, 0x12, 0x31, 0xe7, 0x4b,
	0xb6, 0x9b, 0xed, 0x76, 0x5f, 0x57, 0x5e, 0xb4, 0x08, 0xf6, 0xe7, 0xeb, 0xe8, 0x73, 0x98, 0xa7,
	0x2a, 0x9a, 0x95, 0xb5, 0xc6, 0xf6, 0xcd, 0xad, 0xb1, 0x30, 0x5b, 0x06, 0x94, 0xfe, 0xea, 0x07,
	0x64, 0x01, 0xca, 0xd4, 0x27, 0x69, 0x4d, 0xbf, 0x5b, 0x1a, 0x79, 0x80, 0x74, 0xbd, 0xde, 0x3b,
	0x54, 0xda, 0xcd, 0x16, 0xdb, 0x95, 0xb0, 0x1c, 0x34, 0xc5, 0xcb, 0x97, 0xd3, 0x87, 0x97, 0x50,
	0x70, 0x60, 0xa4, 0x42, 0x24, 0xc7, 0x3e, 0xeb, 0xc3, 0xe7, 0xe6, 0x66, 0xcc, 0x5e, 0xb6, 0x19,
	0x77, 0x87, 0x83, 0xc4, 0x1d, 0x87, 0x23, 0x54, 0x0e, 0xb2, 0xa7, 0x38, 0x5f, 0xfd, 0xf2, 0x0c,
	0x9f, 0x16, 0x0e, 0xce, 0xd2, 0xd9, 0x6a, 0xfe, 0xa4, 0x74, 0x56, 0x3a, 0x29, 0x1d, 0x60, 0x37,
	0x3b, 0x7a, 0x0a, 0xf3, 0x06, 0x95, 0xf1, 0xd1, 0xcc, 0x6e, 0x05, 0xe5, 0xeb, 0x1e, 0x09, 0x8d,
	0x6d, 0x11, 0x2b, 0x48, 0x71, 0xd2, 0x1a, 0xac, 0xba, 0x04, 0xd4, 0x15, 0xbd, 0xaf, 0x49, 0x5f,
	0xc0, 0x8a, 0x77, 0x5c, 0x43, 0xf7, 0x61, 0xc9, 0xc0, 0xd1, 0x07, 0xea, 0x2b, 0xa2, 0x6d, 0xa3,
	0xb3, 0xd8, 0x0e, 0x94, 0xfe, 0xe9, 0x87, 0xb0, 0x93, 0x0d, 0xfd, 0x10, 0x02, 0xd5, 0x8b, 0x2e,
	0x29, 0x12, 0x5d, 0xa1, 0x1b, 0x15, 0x94, 0xc3, 0xbb, 0xb4, 0x8b, 0x59, 0xa3, 0x99, 0xc8, 0xb7,
	0x83, 0x84, 0xef, 0xed, 0x20, 0xb1, 0xb8, 0xdd, 0xec, 0xb4, 0x9a, 0x1d, 0x82, 0x47, 0x00, 0xf4,
	0x14, 0x16, 0x4f, 0x5e, 0xfc, 0x82, 0x62, 0x59, 0xe9, 0x2c, 0x33, 0xac, 0x39, 0x98, 0x59, 0x33,
	0xa1, 0x74, 0xcd, 0xdb, 0x6a, 0xbb, 0xa9, 0x93, 0x76, 0x57, 0xbf, 0xc0, 0x16, 0x0a, 0x3d, 0x85,
	0x39, 0x5a, 0xe1, 0xec, 0x93, 0xba, 0xe1, 0x58, 0x81, 0x5d, 0x47, 0x19, 0x64, 0x70, 0x68, 0x5d,
	0x52, 0xe3, 0x38, 0x28, 0x10, 0x1d, 0xc1, 0x02, 0x13, 0xca, 0x74, 0xab, 0x75, 0x11, 0x05, 0x0d,
	0xc8, 0xac, 0xbe, 0x1d, 0x24, 0xa2, 0x1a, 0xfd, 0x3f, 0x47, 0x63, 0xc2, 0x51, 0x16, 0xe6, 0x99,
	0x98, 0xec, 0x63, 0x8b, 0x8d, 0xe1, 0xd1, 0x32, 0x2b, 0x6f, 0x07, 0x89, 0x88, 0x41, 0xc3, 0xb3,
	0x30, 0xac, 0xf4, 0x6b, 0xb8, 0xee, 0x84, 0x60, 0xf2, 0xcb, 0x3e, 0xd1, 0x74, 0xb4, 0x0b, 0x4b,
	0x19, 0xc3, 0x1c, 0xb2, 0xfa, 0x6b, 0xdd, 0x94, 0xd9, 0xf2, 0x8f, 0xd1, 0x38, 0xb6, 0x43, 0x50,
	0x0a, 0x16, 0x4d, 0x68, 0xcc, 0x4f, 0x37, 0x77, 0x9c, 0x34, 0xd8, 0x8a, 0x93, 0x7e, 0x07, 0x6b,
	0xee, 0x77, 0xb3, 0xee, 0x6f, 0xbc, 0x3c, 0xdd, 0x6d, 0x9a, 0x32, 0xb1, 0xfe, 0x62, 0xbd, 0x7c,
	0x34, 0x8e, 0xed, 0x10, 0xf4, 0x00, 0x02, 0x16, 0xd6, 0x7c, 0xfb, 0x78, 0x55, 0xf1, 0x28, 0x54,
	0xba, 0x0b, 0x31, 0x67, 0xc4, 0x11, 0xd1, 0xad, 0xf5, 0x87, 0x4d, 0x23, 0x30, 0xfa, 0x9f, 0x3f,
	0x5f, 0x97, 0xbe, 0x81, 0x75, 0x41, 0xec, 0x94, 0xf9, 0xde, 0xf3, 0xe4, 0xbb, 0x22, 0xc8, 0x97,
	0xcb, 0xf4, 0x2b, 0xb8, 0xe9, 0x9c, 0xcb, 0x91, 0x16, 0xd1, 0xc9, 0xb4, 0x9b, 0xc5, 0x16, 0xe7,
	0x1f, 0x2d, 0xae, 0x04, 0xb7, 0xc4, 0xf4, 0xe2, 0xf5, 0xcd, 0x5e, 0xb2, 0x3e, 0xe9, 0x4f, 0x3e,
	0xb7, 0x37, 0x50, 0x43, 0xa9, 0xbf, 0xa3, 0xbd, 0x1e, 0xdb, 0x7d, 0x82, 0xb1, 0xd0, 0xa4, 0x2f,
	0xc7, 0x7a, 0x50, 0xd2, 0xdf, 0x5d, 0x2d, 0x67, 0x0a, 0xaf, 0xff, 0xce, 0x92, 0xb1, 0x9b, 0xd7,
	0xec, 0xb4, 0xcd, 0x6b, 0xd5, 0xee, 0x5d, 0x96, 0x55, 0xf6, 0x35, 0x69, 0xcf, 0x79, 0xcc, 0x60,
	0xb6, 0xbb, 0x01, 0x50, 0xea, 0xb7, 0x8d, 0xe7, 0xe3, 0x26, 0xab, 0x8d, 0x39, 0xcc, 0x8d, 0x48,
	0xff, 0xf0, 0x43, 0x88, 0x47, 0x7d, 0x60, 0x7b, 0x7d, 0xe2, 0xb0, 0x57, 0x6f, 0x53, 0xba, 0xc4,
	0x5c, 0x0f, 0x5c, 0xe6, 0x7a, 0x43, 0xd8, 0x61, 0x2e, 0xb5, 0xd6, 0xb4, 0xd3, 0x5a, 0xc7, 0xf4,
	0xa9, 0x89, 0xc6, 0xfa, 0xca, 0xee, 0x82, 0x06, 0x60, 0xda, 0x2f, 0xf5, 0x1e, 0x6f, 0xab, 0xe3,
	0x25, 0xb1, 0x4d, 0xf5, 0x37, 0xf6, 0x97, 0xc7, 0xde, 0x3b, 0xa5, 0x45, 0xed, 0x39, 0x2c, 0x6a,
	0x92, 0x96, 0x9c, 0x4d, 0x3d, 0xb7, 0x1d, 0xdd, 0x98, 0xe7, 0xec, 0xf4, 0xc9, 0xc8, 0x4e, 0xc5,
	0xde, 0xcc, 0xfc, 0x41, 0x58, 0xf3, 0x86, 0x41, 0xbd, 0x86, 0x1b, 0x1e, 0xe2, 0x29, 0x17, 0xb6,
	0xe3, 0xf1, 0xde, 0x6b, 0x9e, 0x85, 0x71, 0x4b, 0x7a, 0x65, 0xfb, 0xbe, 0x31, 0xf3, 0x7e, 0xbe,
	0xfb, 0xe9, 0xc8, 0x77, 0x27, 0xa9, 0x40, 0x57, 0x5c, 0x80, 0xb8, 0xe8, 0xbd, 0x53, 0x1a, 0xf2,
	0x7f, 0x02, 0xdc, 0xa1, 0xac, 0xa7, 0x9e, 0x37, 0x4d, 0x0b, 0x94, 0x38, 0x0b, 0x1c, 0xa3, 0x3d,
	0x7a, 0x08, 0xc1, 0xac, 0xda, 0xe9, 0x54, 0x7b, 0x4a, 0xed, 0xeb, 0x83, 0x0e, 0xbb, 0x79, 0x67,
	0xd6, 0x86, 0x83, 0x04, 0x72, 0x1c, 0x3d, 0xcf, 0x95, 0x96, 0x46, 0x30, 0x1f, 0xfa, 0xff, 0x3c,
	0xd3, 0xe6, 0x0e, 0x4a, 0x5f, 0x7a, 0xcf, 0xb4, 0x65, 0x08, 0x57, 0xb3, 0x65, 0xfe, 0x76, 0x36,
	0x27, 0xbe, 0x4e, 0xef, 0x3c, 0xdc, 0xbf, 0x9f, 0x4c, 0x6e, 0x6f, 0xba, 0x7e, 0x80, 0x48, 0x62,
	0x17, 0xde, 0x60, 0x3c, 0xcd, 0x39, 0x18, 0xe7, 0xdf, 0x81, 0x31, 0x25, 0x27, 0xb1, 0x0b, 0x8f,
	0x9e, 0x41, 0x24, 0x9f, 0x2d, 0x96, 0x3d, 0x57, 0xc8, 0xcc, 0xf7, 0x87, 0x83, 0xc4, 0xf7, 0x2e,
	0xa7, 0x7c, 0x80, 0xdd, 0x78, 0x54, 0x85, 0xe8, 0x89, 0xfe, 0x92, 0xf4, 0x78, 0xce, 0x45, 0x61,
	0x9a, 0x7b, 0x49, 0x21, 0xe9, 0xa3, 0x24, 0xf6, 0x30, 0xa0, 0x1f, 0xc3, 0x4a, 0x35, 0x5b, 0xce,
	0x76, 0x5e, 0x77, 0x2a, 0x44, 0xef, 0x77, 0x2d, 0xe2, 0x00, 0x25, 0xfe, 0x78, 0x38, 0x48, 0x6c,
	0x72, 0xc4, 0xa9, 0x9d, 0x7d, 0x4f, 0xa6, 0x49, 0x2c, 0x22, 0x40, 0x3f, 0xa5, 0xbc, 0xc7, 0x4a,
	0xeb, 0x3c, 0xdb, 0x52, 0xed, 0x9f, 0x85, 0x96, 0x28, 0xef, 0xa7, 0xc3, 0x41, 0xe2, 0x13, 0x07,
	0x6f, 0xea, 0x33, 0xf9, 0xa1, 0x50, 0x58, 0x11, 0x0b, 0x3a, 0x81, 0x88, 0xf1, 0x4e, 0x9e, 0x18,
	0x28, 0xf1, 0x27, 0xc3, 0x41, 0xe2, 0xb6, 0x83, 0x78, 0x4f, 0xa8, 0xad, 0x0b, 0x8d, 0x8a, 0xb4,
	0xa4, 0x72, 0x3d, 0x75, 0x24, 0x40, 0xf0, 0xca, 0x7c, 0x8f, 0x58, 0x3d, 0x71, 0x60, 0xb3, 0x9e,
	0x78, 0xba, 0x90, 0x70, 0xa3, 0xc6, 0xac, 0x7b, 0x9f, 0xd5, 0x13, 0xcf, 0x78, 0xc2, 0xea, 0x89,
	0xa7, 0x5c, 0xbe, 0x72, 0x86, 0x7b, 0x49, 0xec, 0x46, 0xa3, 0x67, 0x66, 0x35, 0xf1, 0x8c, 0xe1,
	0x2b, 0x33, 0xee, 0x5b, 0xa5, 0xc4, 0xc1, 0xa5, 0x1b, 0xdc, 0x2d, 0xc3, 0x74, 0x1f, 0xe6, 0x4b,
	0xfc, 0x1d, 0xd2, 0x9e, 0xd0, 0xa4, 0x7f, 0xfb, 0x21, 0xe2, 0x9a, 0xf8, 0xc0, 0x07, 0x93, 0xcf,
	0x1d, 0x07, 0x13, 0xd7, 0x65, 0xcb, 0x76, 0xd4, 0x09, 0x67, 0x93, 0x63, 0xd7, 0xd9, 0x24, 0x2e,
	0xe4, 0xb8, 0xca, 0xf1, 0x24, 0xe7, 0x3c, 0x9e, 0xac, 0x8f, 0x23, 0x9a, 0x7c, 0x42, 0xf9, 0x86,
	0xbb, 0x7e, 0x31, 0xcc, 0xb4, 0x6d, 0x4d, 0x76, 0xdf, 0xfd, 0xc6, 0xca, 0x63, 0x9f, 0x53, 0x7e,
	0xef, 0xb3, 0x5b, 0xfa, 0xe8, 0xf5, 0x53, 0xb6, 0xf4, 0x7d, 0x4f, 0x4b, 0x9f, 0xa0, 0x2d, 0xd7,
	0xdb, 0x7f, 0xc0, 0xdd, 0xe9, 0x58, 0xc8, 0x84, 0x0b, 0xe0, 0x6f, 0xed, 0x86, 0xcc, 0x07, 0x4f,
	0x99, 0x72, 0xd2, 0x93, 0xf2, 0xaa, 0x28, 0x65, 0x2e, 0xd9, 0x9f, 0x71, 0x77, 0x34, 0x36, 0xf9,
	0xdd, 0xde, 0x01, 0x4f, 0xe0, 0xa3, 0x31, 0xfc, 0xd3, 0x9d, 0x39, 0xee, 0xbe, 0xa4, 0x3f, 0x0f,
	0xa3, 0x10, 0x04, 0xd2, 0x85, 0x23, 0xfa, 0x23, 0x54, 0x74, 0xc6, 0x7a, 0xaa, 0x1e, 0x56, 0xcb,
	0x51, 0x1f, 0x0a, 0xd2, 0x5f, 0x0c, 0xcf, 0x8c, 0x07, 0xbf, 0xf5, 0x90, 0x2b, 0x55, 0xa2, 0xb3,
	0x28, 0x0c, 0x60, 0x3c, 0x54, 0x4e, 0x4b, 0xb8, 0x9c, 0x8d, 0xce, 0xa1, 0x65, 0x58, 0x32, 0x9e,
	0xe9, 0x8f, 0xb8, 0xd1, 0x79, 0x8b, 0x06, 0x57, 0x2b, 0xe5, 0xe8, 0x82, 0xfc, 0xe7, 0x80, 0x7d,
	0xf3, 0x31, 0xaf, 0xfa, 0xaf, 0x6a, 0xe8, 0x99, 0xfb, 0x0e, 0x9a, 0xed, 0x11, 0x45, 0x27, 0x28,
	0x2e, 0x3a, 0x78, 0x31, 0x11, 0xe3, 0x37, 0x85, 0x73, 0xe6, 0x0e, 0xcc, 0x78, 0x29, 0x4f, 0xbb,
	0xf5, 0xf7, 0xa4, 0xac, 0xba, 0x53, 0x3f, 0x22, 0x3a, 0xfa, 0x48, 0x80, 0xb1, 0x4b, 0x33, 0xbe,
	0x31, 0x6e, 0x7a, 0xc4, 0xfa, 0x95, 0x3b, 0x51, 0xb6, 0x97, 0x68, 0x53, 0x80, 0x74, 0x94, 0x51,
	0xfc, 0xf6, 0x84, 0x88, 0x11, 0xfd, 0x17, 0xce, 0xfb, 0xa7, 0x29, 0x6c, 0xcc, 0x7b, 0x8e, 0x36,
	0x49, 0xd7, 0x05, 0x33, 0xe3, 0xc8, 0x4c, 0x49, 0xa7, 0x24, 0x2b, 0xd9, 0x7d, 0xc3, 0xbc, 0x28,
	0xa0, 0x9b, 0x9e, 0x78, 0x4e, 0xca, 0x5b, 0xe2, 0xc9, 0x11, 0xdf, 0x73, 0x67, 0x72, 0xa6, 0x8c,
	0x1b, 0x1e, 0x94, 0x53, 0xc4, 0xc4, 0xd8, 0x79, 0x6e, 0xdf, 0xdd, 0x2d, 0xd1, 0x54, 0xf1, 0xa6,
	0xd0, 0x07, 0x84, 0xe9, 0xba, 0x7c, 0x53, 0xc8, 0x6a, 0xca, 0xf9, 0x5e, 0xac, 0x9c, 0x08, 0xb6,
	0xf5, 0xb9, 0x44, 0xf0, 0x18, 0xa8, 0x4b, 0x04, 0xaf, 0x67, 0x4a, 0x33, 0xe8, 0xe7, 0x9e, 0x74,
	0x4d, 0x81, 0x6f, 0x8b, 0xb0, 0x4e, 0x8d, 0xa5, 0x49, 0x21, 0xd6, 0x1b, 0x32, 0xa1, 0xbf, 0xbd,
	0xd9, 0xf0, 0x7d, 0xfb, 0x66, 0xc3, 0xf7, 0xaf, 0x37, 0x1b, 0xbe, 0x17, 0x0b, 0xf4, 0x6f, 0x9b,
	0x7b, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x33, 0xb6, 0x51, 0x1a, 0x1d, 0x00, 0x00,
}
