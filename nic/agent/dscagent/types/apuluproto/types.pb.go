// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

/*
	Package pds is a generated protocol buffer package.

	It is generated from these files:
		types.proto
		vpc.proto
		device.proto
		policy.proto
		subnet.proto
		dhcp.proto
		interface.proto
		port.proto
		event.proto
		oper.proto
		cp_route.proto
		bgp.proto
		evpn.proto

	It has these top-level messages:
		Empty
		IPAddress
		IPRange
		IPv4Prefix
		IPv6Prefix
		IPPrefix
		IPSubnet
		AddressRange
		Address
		PortRange
		RuleL3Match
		PortMatch
		ICMPMatch
		RuleL4Match
		RuleMatch
		QinQTag
		EncapVal
		Encap
		BatchCtxt
		MACFlowKey
		FlowL4Info
		IPFlowKey
		FlowKey
		CommandMessage
		ConfigMessage
		ServiceRequestMessage
		ServiceResponseMessage
		VPCSpec
		VPCStatus
		VPCStats
		VPC
		VPCRequest
		VPCResponse
		VPCGetRequest
		VPCGetResponse
		VPCDeleteRequest
		VPCDeleteResponse
		VPCPeerSpec
		VPCPeerStatus
		VPCPeerStats
		VPCPeer
		VPCPeerRequest
		VPCPeerResponse
		VPCPeerGetRequest
		VPCPeerGetResponse
		VPCPeerDeleteRequest
		VPCPeerDeleteResponse
		DeviceSpec
		DeviceStatus
		DeviceStatsEntry
		DeviceStats
		Device
		DeviceRequest
		DeviceResponse
		DeviceGetRequest
		DeviceGetResponse
		DeviceDeleteRequest
		DeviceDeleteResponse
		SecurityRuleAttrs
		SecurityRuleInfo
		SecurityPolicySpec
		SecurityPolicyStatus
		SecurityPolicyStats
		SecurityPolicy
		SecurityPolicyRequest
		SecurityPolicyResponse
		SecurityPolicyGetRequest
		SecurityPolicyGetResponse
		SecurityPolicyDeleteRequest
		SecurityPolicyDeleteResponse
		SecurityPolicyRuleId
		SecurityRuleSpec
		SecurityRuleStatus
		SecurityRuleStats
		SecurityRule
		SecurityRuleRequest
		SecurityRuleResponse
		SecurityRuleGetRequest
		SecurityRuleGetResponse
		SecurityRuleDeleteRequest
		SecurityRuleDeleteResponse
		SecurityProfileSpec
		SecurityProfileStatus
		SecurityProfileStats
		SecurityProfile
		SecurityProfileRequest
		SecurityProfileResponse
		SecurityProfileGetRequest
		SecurityProfileGetResponse
		SecurityProfileDeleteRequest
		SecurityProfileDeleteResponse
		SubnetSpec
		SubnetStatus
		SubnetStats
		Subnet
		SubnetRequest
		SubnetResponse
		SubnetGetRequest
		SubnetGetResponse
		SubnetDeleteRequest
		SubnetDeleteResponse
		DHCPRelaySpec
		DHCPRelayStatus
		DHCPRelayStats
		DHCPProxySpec
		DHCPProxyStatus
		DHCPProxyStats
		DHCPPolicySpec
		DHCPPolicyStatus
		DHCPPolicyStats
		DHCPPolicy
		DHCPPolicyRequest
		DHCPPolicyResponse
		DHCPPolicyGetRequest
		DHCPPolicyGetResponse
		DHCPPolicyDeleteRequest
		DHCPPolicyDeleteResponse
		LldpIfStats
		LldpId
		LldpChassisCapabilitySpec
		LldpIfChassisSpec
		LldpIfPortSpec
		LldpIfSpec
		LldpSpec
		UplinkSpec
		UplinkPCSpec
		L3IfSpec
		LoopbackIfSpec
		ControlIfSpec
		InterfaceSpec
		UplinkIfStatus
		LoopbackIfStatus
		InterfaceStatus
		UplinkIfStats
		UplinkPCStats
		L3IfStats
		LoopbackIfStats
		ControlIfStats
		InterfaceStats
		Interface
		InterfaceRequest
		InterfaceResponse
		InterfaceGetRequest
		InterfaceGetResponse
		InterfaceDeleteRequest
		InterfaceDeleteResponse
		LifSpec
		LifStatus
		LifStats
		Lif
		LifGetRequest
		LifGetResponse
		MacStats
		MgmtMacStats
		PortStats
		PortSpec
		PortLinkStatus
		PortXcvrStatus
		PortStatus
		Port
		PortGetRequest
		PortGetResponse
		PortUpdateRequest
		PortUpdateResponse
		EventRequest
		EventResponse
		TechSupportSpec
		TechSupportStatus
		TechSupportStats
		TechSupport
		TechSupportRequest
		TechSupportResponse
		MetricsGetRequest
		CounterStatus
		CountersStatus
		MetricsGetResponse
		FlowLog
		Alert
		AlertsGetResponse
		CPRouteStatus
		CPRouteKey
		CPRouteKeyHandle
		CPRouteGetRequest
		CPRoute
		CPRouteGetResponse
		CPStaticRouteSpec
		CPStaticRouteRequest
		CPStaticRouteStatus
		CPStaticRoute
		CPStaticRouteResponse
		CPStaticRouteKey
		CPStaticRouteKeyHandle
		CPStaticRouteDeleteRequest
		CPStaticRouteDeleteResponse
		CPStaticRouteGetRequest
		CPStaticRouteGetResponse
		CPActiveRouteStatus
		CPActiveRouteKey
		CPActiveRouteKeyHandle
		CPActiveRouteGetRequest
		CPActiveRoute
		CPActiveRouteGetResponse
		CPRouteRedistStatus
		CPRouteRedistKey
		CPRouteRedistKeyHandle
		CPRouteRedistGetRequest
		CPRouteRedist
		CPRouteRedistGetResponse
		BGPSpec
		BGPStatus
		BGP
		BGPRequest
		BGPResponse
		BGPKeyHandle
		BGPDeleteRequest
		BGPDeleteResponse
		BGPGetRequest
		BGPGetResponse
		BGPPeerSpec
		BGPPeerStatus
		BGPPeer
		BGPPeerResponse
		BGPPeerRequest
		BGPPeerGetResponse
		BGPPeerKey
		BGPPeerKeyHandle
		BGPPeerDeleteRequest
		BGPPeerDeleteResponse
		BGPPeerGetRequest
		BGPPeerAfSpec
		BGPPeerAfStatus
		BGPPeerAf
		BGPPeerAfResponse
		BGPPeerAfRequest
		BGPPeerAfKey
		BGPPeerAfKeyHandle
		BGPPeerAfDeleteRequest
		BGPPeerAfDeleteResponse
		BGPPeerAfGetRequest
		BGPPeerAfGetResponse
		BGPClearRouteRequest
		BGPClearRouteResponse
		BGPNLRIPrefixStatus
		BGPNLRIPrefixKey
		BGPNLRIPrefix
		BGPNLRIPrefixGetResponse
		BGPNLRIPrefixKeyHandle
		BGPNLRIPrefixGetRequest
		BGPPrfxCntrsStatus
		BGPPrfxCntrsKey
		BGPPrfxCntrs
		BGPPrfxCntrsGetResponse
		BGPPrfxCntrsKeyHandle
		BGPPrfxCntrsGetRequest
		BGPRouteMapStatus
		BGPRouteMapKey
		BGPRouteMap
		BGPRouteMapGetResponse
		BGPRouteMapKeyHandle
		BGPRouteMapGetRequest
		EvpnEviSpec
		EvpnEviStatus
		EvpnEvi
		EvpnEviResponse
		EvpnEviRequest
		EvpnEviKey
		EvpnEviKeyHandle
		EvpnEviDeleteRequest
		EvpnEviDeleteResponse
		EvpnEviGetRequest
		EvpnEviGetResponse
		EvpnIpVrfSpec
		EvpnIpVrfStatus
		EvpnIpVrf
		EvpnIpVrfRequest
		EvpnIpVrfResponse
		EvpnIpVrfKey
		EvpnIpVrfKeyHandle
		EvpnIpVrfDeleteRequest
		EvpnIpVrfDeleteResponse
		EvpnIpVrfGetRequest
		EvpnIpVrfGetResponse
		EvpnEviRtSpec
		EvpnEviRtStatus
		EvpnEviRt
		EvpnEviRtResponse
		EvpnEviRtRequest
		EvpnEviRtKey
		EvpnEviRtKeyHandle
		EvpnEviRtDeleteRequest
		EvpnEviRtDeleteResponse
		EvpnEviRtGetRequest
		EvpnEviRtGetResponse
		EvpnIpVrfRtRequest
		EvpnIpVrfRtSpec
		EvpnIpVrfRtStatus
		EvpnIpVrfRt
		EvpnIpVrfRtResponse
		EvpnIpVrfRtKey
		EvpnIpVrfRtKeyHandle
		EvpnIpVrfRtDeleteRequest
		EvpnIpVrfRtDeleteResponse
		EvpnIpVrfRtGetRequest
		EvpnIpVrfRtGetResponse
		EvpnMacIpStatus
		EvpnMacIpKey
		EvpnMacIpKeyHandle
		EvpnMacIpGetRequest
		EvpnMacIp
		EvpnMacIpGetResponse
		EvpnBdStatus
		EvpnBdKey
		EvpnBdKeyHandle
		EvpnBdGetRequest
		EvpnBd
		EvpnBdGetResponse
		EvpnBdIfStatus
		EvpnBdIfKey
		EvpnBdIfKeyHandle
		EvpnBdIfGetRequest
		EvpnBdIf
		EvpnBdIfGetResponse
*/
package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import gogoproto "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/golang/protobuf/ptypes/any"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// goproto_enum_prefix from public import gogo.proto
var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

// goproto_enum_stringer from public import gogo.proto
var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

// enum_stringer from public import gogo.proto
var E_EnumStringer = gogoproto.E_EnumStringer

// enum_customname from public import gogo.proto
var E_EnumCustomname = gogoproto.E_EnumCustomname

// enumdecl from public import gogo.proto
var E_Enumdecl = gogoproto.E_Enumdecl

// enumvalue_customname from public import gogo.proto
var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

// goproto_getters_all from public import gogo.proto
var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

// goproto_enum_prefix_all from public import gogo.proto
var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

// goproto_stringer_all from public import gogo.proto
var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

// verbose_equal_all from public import gogo.proto
var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

// face_all from public import gogo.proto
var E_FaceAll = gogoproto.E_FaceAll

// gostring_all from public import gogo.proto
var E_GostringAll = gogoproto.E_GostringAll

// populate_all from public import gogo.proto
var E_PopulateAll = gogoproto.E_PopulateAll

// stringer_all from public import gogo.proto
var E_StringerAll = gogoproto.E_StringerAll

// onlyone_all from public import gogo.proto
var E_OnlyoneAll = gogoproto.E_OnlyoneAll

// equal_all from public import gogo.proto
var E_EqualAll = gogoproto.E_EqualAll

// description_all from public import gogo.proto
var E_DescriptionAll = gogoproto.E_DescriptionAll

// testgen_all from public import gogo.proto
var E_TestgenAll = gogoproto.E_TestgenAll

// benchgen_all from public import gogo.proto
var E_BenchgenAll = gogoproto.E_BenchgenAll

// marshaler_all from public import gogo.proto
var E_MarshalerAll = gogoproto.E_MarshalerAll

// unmarshaler_all from public import gogo.proto
var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

// stable_marshaler_all from public import gogo.proto
var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

// sizer_all from public import gogo.proto
var E_SizerAll = gogoproto.E_SizerAll

// goproto_enum_stringer_all from public import gogo.proto
var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

// enum_stringer_all from public import gogo.proto
var E_EnumStringerAll = gogoproto.E_EnumStringerAll

// unsafe_marshaler_all from public import gogo.proto
var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

// unsafe_unmarshaler_all from public import gogo.proto
var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

// goproto_extensions_map_all from public import gogo.proto
var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

// goproto_unrecognized_all from public import gogo.proto
var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

// gogoproto_import from public import gogo.proto
var E_GogoprotoImport = gogoproto.E_GogoprotoImport

// protosizer_all from public import gogo.proto
var E_ProtosizerAll = gogoproto.E_ProtosizerAll

// compare_all from public import gogo.proto
var E_CompareAll = gogoproto.E_CompareAll

// typedecl_all from public import gogo.proto
var E_TypedeclAll = gogoproto.E_TypedeclAll

// enumdecl_all from public import gogo.proto
var E_EnumdeclAll = gogoproto.E_EnumdeclAll

// goproto_registration from public import gogo.proto
var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

// goproto_getters from public import gogo.proto
var E_GoprotoGetters = gogoproto.E_GoprotoGetters

// goproto_stringer from public import gogo.proto
var E_GoprotoStringer = gogoproto.E_GoprotoStringer

// verbose_equal from public import gogo.proto
var E_VerboseEqual = gogoproto.E_VerboseEqual

// face from public import gogo.proto
var E_Face = gogoproto.E_Face

// gostring from public import gogo.proto
var E_Gostring = gogoproto.E_Gostring

// populate from public import gogo.proto
var E_Populate = gogoproto.E_Populate

// stringer from public import gogo.proto
var E_Stringer = gogoproto.E_Stringer

// onlyone from public import gogo.proto
var E_Onlyone = gogoproto.E_Onlyone

// equal from public import gogo.proto
var E_Equal = gogoproto.E_Equal

// description from public import gogo.proto
var E_Description = gogoproto.E_Description

// testgen from public import gogo.proto
var E_Testgen = gogoproto.E_Testgen

// benchgen from public import gogo.proto
var E_Benchgen = gogoproto.E_Benchgen

// marshaler from public import gogo.proto
var E_Marshaler = gogoproto.E_Marshaler

// unmarshaler from public import gogo.proto
var E_Unmarshaler = gogoproto.E_Unmarshaler

// stable_marshaler from public import gogo.proto
var E_StableMarshaler = gogoproto.E_StableMarshaler

// sizer from public import gogo.proto
var E_Sizer = gogoproto.E_Sizer

// unsafe_marshaler from public import gogo.proto
var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

// unsafe_unmarshaler from public import gogo.proto
var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

// goproto_extensions_map from public import gogo.proto
var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

// goproto_unrecognized from public import gogo.proto
var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

// protosizer from public import gogo.proto
var E_Protosizer = gogoproto.E_Protosizer

// compare from public import gogo.proto
var E_Compare = gogoproto.E_Compare

// typedecl from public import gogo.proto
var E_Typedecl = gogoproto.E_Typedecl

// nullable from public import gogo.proto
var E_Nullable = gogoproto.E_Nullable

// embed from public import gogo.proto
var E_Embed = gogoproto.E_Embed

// customtype from public import gogo.proto
var E_Customtype = gogoproto.E_Customtype

// customname from public import gogo.proto
var E_Customname = gogoproto.E_Customname

// jsontag from public import gogo.proto
var E_Jsontag = gogoproto.E_Jsontag

// moretags from public import gogo.proto
var E_Moretags = gogoproto.E_Moretags

// casttype from public import gogo.proto
var E_Casttype = gogoproto.E_Casttype

// castkey from public import gogo.proto
var E_Castkey = gogoproto.E_Castkey

// castvalue from public import gogo.proto
var E_Castvalue = gogoproto.E_Castvalue

// stdtime from public import gogo.proto
var E_Stdtime = gogoproto.E_Stdtime

// stdduration from public import gogo.proto
var E_Stdduration = gogoproto.E_Stdduration

// API return codes (more descriptive than protobuf enums)
type ApiStatus int32

const (
	ApiStatus_API_STATUS_OK                    ApiStatus = 0
	ApiStatus_API_STATUS_ERR                   ApiStatus = 1
	ApiStatus_API_STATUS_INVALID_ARG           ApiStatus = 2
	ApiStatus_API_STATUS_EXISTS_ALREADY        ApiStatus = 3
	ApiStatus_API_STATUS_OUT_OF_MEM            ApiStatus = 4
	ApiStatus_API_STATUS_NOT_FOUND             ApiStatus = 5
	ApiStatus_API_STATUS_OUT_OF_RESOURCE       ApiStatus = 6
	ApiStatus_API_STATUS_RETRY                 ApiStatus = 7
	ApiStatus_API_STATUS_OPERATION_NOT_ALLOWED ApiStatus = 8
)

var ApiStatus_name = map[int32]string{
	0: "API_STATUS_OK",
	1: "API_STATUS_ERR",
	2: "API_STATUS_INVALID_ARG",
	3: "API_STATUS_EXISTS_ALREADY",
	4: "API_STATUS_OUT_OF_MEM",
	5: "API_STATUS_NOT_FOUND",
	6: "API_STATUS_OUT_OF_RESOURCE",
	7: "API_STATUS_RETRY",
	8: "API_STATUS_OPERATION_NOT_ALLOWED",
}
var ApiStatus_value = map[string]int32{
	"API_STATUS_OK":                    0,
	"API_STATUS_ERR":                   1,
	"API_STATUS_INVALID_ARG":           2,
	"API_STATUS_EXISTS_ALREADY":        3,
	"API_STATUS_OUT_OF_MEM":            4,
	"API_STATUS_NOT_FOUND":             5,
	"API_STATUS_OUT_OF_RESOURCE":       6,
	"API_STATUS_RETRY":                 7,
	"API_STATUS_OPERATION_NOT_ALLOWED": 8,
}

func (x ApiStatus) String() string {
	return proto.EnumName(ApiStatus_name, int32(x))
}
func (ApiStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// IP address families
type IPAF int32

const (
	IPAF_IP_AF_NONE  IPAF = 0
	IPAF_IP_AF_INET  IPAF = 1
	IPAF_IP_AF_INET6 IPAF = 2
)

var IPAF_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}
var IPAF_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAF) String() string {
	return proto.EnumName(IPAF_name, int32(x))
}
func (IPAF) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type WildcardMatch int32

const (
	WildcardMatch_MATCH_NONE WildcardMatch = 0
	WildcardMatch_MATCH_ANY  WildcardMatch = 256
)

var WildcardMatch_name = map[int32]string{
	0:   "MATCH_NONE",
	256: "MATCH_ANY",
}
var WildcardMatch_value = map[string]int32{
	"MATCH_NONE": 0,
	"MATCH_ANY":  256,
}

func (x WildcardMatch) String() string {
	return proto.EnumName(WildcardMatch_name, int32(x))
}
func (WildcardMatch) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// direction in which policy is enforced
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
type RuleDir int32

const (
	RuleDir_RULE_DIR_NONE    RuleDir = 0
	RuleDir_RULE_DIR_INGRESS RuleDir = 1
	RuleDir_RULE_DIR_EGRESS  RuleDir = 2
)

var RuleDir_name = map[int32]string{
	0: "RULE_DIR_NONE",
	1: "RULE_DIR_INGRESS",
	2: "RULE_DIR_EGRESS",
}
var RuleDir_value = map[string]int32{
	"RULE_DIR_NONE":    0,
	"RULE_DIR_INGRESS": 1,
	"RULE_DIR_EGRESS":  2,
}

func (x RuleDir) String() string {
	return proto.EnumName(RuleDir_name, int32(x))
}
func (RuleDir) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// encap types in the network
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE     EncapType = 0
	EncapType_ENCAP_TYPE_DOT1Q    EncapType = 1
	EncapType_ENCAP_TYPE_QINQ     EncapType = 2
	EncapType_ENCAP_TYPE_MPLSoUDP EncapType = 3
	EncapType_ENCAP_TYPE_VXLAN    EncapType = 4
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_DOT1Q",
	2: "ENCAP_TYPE_QINQ",
	3: "ENCAP_TYPE_MPLSoUDP",
	4: "ENCAP_TYPE_VXLAN",
}
var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":     0,
	"ENCAP_TYPE_DOT1Q":    1,
	"ENCAP_TYPE_QINQ":     2,
	"ENCAP_TYPE_MPLSoUDP": 3,
	"ENCAP_TYPE_VXLAN":    4,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}
func (EncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

// Types of lif
type LifType int32

const (
	LifType_LIF_TYPE_NONE          LifType = 0
	LifType_LIF_TYPE_HOST          LifType = 1
	LifType_LIF_TYPE_HOST_MGMT     LifType = 2
	LifType_LIF_TYPE_OOB_MGMT      LifType = 3
	LifType_LIF_TYPE_INBAND_MGMT   LifType = 4
	LifType_LIF_TYPE_INTERNAL_MGMT LifType = 5
	LifType_LIF_TYPE_DATAPATH      LifType = 6
	LifType_LIF_TYPE_LEARN         LifType = 7
	LifType_LIF_TYPE_CONTROL       LifType = 8
)

var LifType_name = map[int32]string{
	0: "LIF_TYPE_NONE",
	1: "LIF_TYPE_HOST",
	2: "LIF_TYPE_HOST_MGMT",
	3: "LIF_TYPE_OOB_MGMT",
	4: "LIF_TYPE_INBAND_MGMT",
	5: "LIF_TYPE_INTERNAL_MGMT",
	6: "LIF_TYPE_DATAPATH",
	7: "LIF_TYPE_LEARN",
	8: "LIF_TYPE_CONTROL",
}
var LifType_value = map[string]int32{
	"LIF_TYPE_NONE":          0,
	"LIF_TYPE_HOST":          1,
	"LIF_TYPE_HOST_MGMT":     2,
	"LIF_TYPE_OOB_MGMT":      3,
	"LIF_TYPE_INBAND_MGMT":   4,
	"LIF_TYPE_INTERNAL_MGMT": 5,
	"LIF_TYPE_DATAPATH":      6,
	"LIF_TYPE_LEARN":         7,
	"LIF_TYPE_CONTROL":       8,
}

func (x LifType) String() string {
	return proto.EnumName(LifType_name, int32(x))
}
func (LifType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

// Security rule action is one of the below
type SecurityRuleAction int32

const (
	SecurityRuleAction_SECURITY_RULE_ACTION_NONE  SecurityRuleAction = 0
	SecurityRuleAction_SECURITY_RULE_ACTION_ALLOW SecurityRuleAction = 1
	SecurityRuleAction_SECURITY_RULE_ACTION_DENY  SecurityRuleAction = 2
)

var SecurityRuleAction_name = map[int32]string{
	0: "SECURITY_RULE_ACTION_NONE",
	1: "SECURITY_RULE_ACTION_ALLOW",
	2: "SECURITY_RULE_ACTION_DENY",
}
var SecurityRuleAction_value = map[string]int32{
	"SECURITY_RULE_ACTION_NONE":  0,
	"SECURITY_RULE_ACTION_ALLOW": 1,
	"SECURITY_RULE_ACTION_DENY":  2,
}

func (x SecurityRuleAction) String() string {
	return proto.EnumName(SecurityRuleAction_name, int32(x))
}
func (SecurityRuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_ACTION_NONE NatAction = 0
	// Address only static NAT
	NatAction_NAT_ACTION_STATIC NatAction = 1
	// address and port translation to the public (aka. Internet) address space
	NatAction_NAT_ACTION_NAPT_PUBLIC NatAction = 2
	// address and port translation to internal service address space
	NatAction_NAT_ACTION_NAPT_SVC NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_ACTION_NONE",
	1: "NAT_ACTION_STATIC",
	2: "NAT_ACTION_NAPT_PUBLIC",
	3: "NAT_ACTION_NAPT_SVC",
}
var NatAction_value = map[string]int32{
	"NAT_ACTION_NONE":        0,
	"NAT_ACTION_STATIC":      1,
	"NAT_ACTION_NAPT_PUBLIC": 2,
	"NAT_ACTION_NAPT_SVC":    3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}
func (NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

// Public/Internet or Service/Infra address
type AddressType int32

const (
	AddressType_ADDR_TYPE_NONE    AddressType = 0
	AddressType_ADDR_TYPE_PUBLIC  AddressType = 1
	AddressType_ADDR_TYPE_SERVICE AddressType = 2
)

var AddressType_name = map[int32]string{
	0: "ADDR_TYPE_NONE",
	1: "ADDR_TYPE_PUBLIC",
	2: "ADDR_TYPE_SERVICE",
}
var AddressType_value = map[string]int32{
	"ADDR_TYPE_NONE":    0,
	"ADDR_TYPE_PUBLIC":  1,
	"ADDR_TYPE_SERVICE": 2,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}
func (AddressType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// admin state of control plane objects
type AdminState int32

const (
	AdminState_ADMIN_STATE_NONE    AdminState = 0
	AdminState_ADMIN_STATE_ENABLE  AdminState = 1
	AdminState_ADMIN_STATE_DISABLE AdminState = 2
)

var AdminState_name = map[int32]string{
	0: "ADMIN_STATE_NONE",
	1: "ADMIN_STATE_ENABLE",
	2: "ADMIN_STATE_DISABLE",
}
var AdminState_value = map[string]int32{
	"ADMIN_STATE_NONE":    0,
	"ADMIN_STATE_ENABLE":  1,
	"ADMIN_STATE_DISABLE": 2,
}

func (x AdminState) String() string {
	return proto.EnumName(AdminState_name, int32(x))
}
func (AdminState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

// PortSpeed specifies the speed of the port
type PortSpeed int32

const (
	PortSpeed_PORT_SPEED_NONE  PortSpeed = 0
	PortSpeed_PORT_SPEED_10M   PortSpeed = 1
	PortSpeed_PORT_SPEED_100M  PortSpeed = 2
	PortSpeed_PORT_SPEED_1G    PortSpeed = 3
	PortSpeed_PORT_SPEED_10G   PortSpeed = 4
	PortSpeed_PORT_SPEED_25G   PortSpeed = 5
	PortSpeed_PORT_SPEED_40G   PortSpeed = 6
	PortSpeed_PORT_SPEED_50G   PortSpeed = 7
	PortSpeed_PORT_SPEED_100G  PortSpeed = 8
	PortSpeed_PORT_SPEED_RESVD PortSpeed = 9
)

var PortSpeed_name = map[int32]string{
	0: "PORT_SPEED_NONE",
	1: "PORT_SPEED_10M",
	2: "PORT_SPEED_100M",
	3: "PORT_SPEED_1G",
	4: "PORT_SPEED_10G",
	5: "PORT_SPEED_25G",
	6: "PORT_SPEED_40G",
	7: "PORT_SPEED_50G",
	8: "PORT_SPEED_100G",
	9: "PORT_SPEED_RESVD",
}
var PortSpeed_value = map[string]int32{
	"PORT_SPEED_NONE":  0,
	"PORT_SPEED_10M":   1,
	"PORT_SPEED_100M":  2,
	"PORT_SPEED_1G":    3,
	"PORT_SPEED_10G":   4,
	"PORT_SPEED_25G":   5,
	"PORT_SPEED_40G":   6,
	"PORT_SPEED_50G":   7,
	"PORT_SPEED_100G":  8,
	"PORT_SPEED_RESVD": 9,
}

func (x PortSpeed) String() string {
	return proto.EnumName(PortSpeed_name, int32(x))
}
func (PortSpeed) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type Command int32

const (
	Command_CMD_NONE                  Command = 0
	Command_CMD_MAPPING_DUMP          Command = 1
	Command_CMD_INTR_DUMP             Command = 2
	Command_CMD_INTR_CLEAR            Command = 3
	Command_CMD_API_ENGINE_STATS_DUMP Command = 4
	Command_CMD_FLOW_DUMP             Command = 5
	Command_CMD_STORE_STATS_DUMP      Command = 6
	Command_CMD_NAT_PB_DUMP           Command = 7
	Command_CMD_NACL_DUMP             Command = 8
	Command_CMD_PORT_FSM_DUMP         Command = 9
)

var Command_name = map[int32]string{
	0: "CMD_NONE",
	1: "CMD_MAPPING_DUMP",
	2: "CMD_INTR_DUMP",
	3: "CMD_INTR_CLEAR",
	4: "CMD_API_ENGINE_STATS_DUMP",
	5: "CMD_FLOW_DUMP",
	6: "CMD_STORE_STATS_DUMP",
	7: "CMD_NAT_PB_DUMP",
	8: "CMD_NACL_DUMP",
	9: "CMD_PORT_FSM_DUMP",
}
var Command_value = map[string]int32{
	"CMD_NONE":                  0,
	"CMD_MAPPING_DUMP":          1,
	"CMD_INTR_DUMP":             2,
	"CMD_INTR_CLEAR":            3,
	"CMD_API_ENGINE_STATS_DUMP": 4,
	"CMD_FLOW_DUMP":             5,
	"CMD_STORE_STATS_DUMP":      6,
	"CMD_NAT_PB_DUMP":           7,
	"CMD_NACL_DUMP":             8,
	"CMD_PORT_FSM_DUMP":         9,
}

func (x Command) String() string {
	return proto.EnumName(Command_name, int32(x))
}
func (Command) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

type ServiceRequestOp int32

const (
	ServiceRequestOp_SERVICE_OP_NONE   ServiceRequestOp = 0
	ServiceRequestOp_SERVICE_OP_CREATE ServiceRequestOp = 1
	ServiceRequestOp_SERVICE_OP_DELETE ServiceRequestOp = 2
	ServiceRequestOp_SERVICE_OP_UPDATE ServiceRequestOp = 3
	ServiceRequestOp_SERVICE_OP_READ   ServiceRequestOp = 4
)

var ServiceRequestOp_name = map[int32]string{
	0: "SERVICE_OP_NONE",
	1: "SERVICE_OP_CREATE",
	2: "SERVICE_OP_DELETE",
	3: "SERVICE_OP_UPDATE",
	4: "SERVICE_OP_READ",
}
var ServiceRequestOp_value = map[string]int32{
	"SERVICE_OP_NONE":   0,
	"SERVICE_OP_CREATE": 1,
	"SERVICE_OP_DELETE": 2,
	"SERVICE_OP_UPDATE": 3,
	"SERVICE_OP_READ":   4,
}

func (x ServiceRequestOp) String() string {
	return proto.EnumName(ServiceRequestOp_name, int32(x))
}
func (ServiceRequestOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

// Empty message
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// IP Address object
type IPAddress struct {
	Af IPAF `protobuf:"varint,1,opt,name=Af,proto3,enum=types.IPAF" json:"Af,omitempty" meta:mandatory`
	// IP address family
	//
	// Types that are valid to be assigned to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6 isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddress_V4Addr struct {
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=V4Addr,proto3,oneof"`
}
type IPAddress_V6Addr struct {
	V6Addr []byte `protobuf:"bytes,3,opt,name=V6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}
func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (m *IPAddress) GetAf() IPAF {
	if m != nil {
		return m.Af
	}
	return IPAF_IP_AF_NONE
}

func (m *IPAddress) GetV4Addr() uint32 {
	if x, ok := m.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (m *IPAddress) GetV6Addr() []byte {
	if x, ok := m.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddress_OneofMarshaler, _IPAddress_OneofUnmarshaler, _IPAddress_OneofSizer, []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
}

func _IPAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.V4Addr))
	case *IPAddress_V6Addr:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.V6Addr)
	case nil:
	default:
		return fmt.Errorf("IPAddress.V4OrV6 has unexpected type %T", x)
	}
	return nil
}

func _IPAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddress)
	switch tag {
	case 2: // v4_or_v6.V4Addr
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.V4OrV6 = &IPAddress_V4Addr{uint32(x)}
		return true, err
	case 3: // v4_or_v6.V6Addr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.V4OrV6 = &IPAddress_V6Addr{x}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case *IPAddress_V6Addr:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.V6Addr)))
		n += len(x.V6Addr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IP Range
type IPRange struct {
	// starting IP address
	Low *IPAddress `protobuf:"bytes,1,opt,name=Low" json:"Low,omitempty"`
	// ending IP address
	High *IPAddress `protobuf:"bytes,2,opt,name=High" json:"High,omitempty"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (m *IPRange) String() string            { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *IPRange) GetLow() *IPAddress {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *IPRange) GetHigh() *IPAddress {
	if m != nil {
		return m.High
	}
	return nil
}

// IPv4 Prefix
type IPv4Prefix struct {
	// IPv4 address portion
	Addr uint32 `protobuf:"fixed32,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	// prefix length
	Len uint32 `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-32`
}

func (m *IPv4Prefix) Reset()                    { *m = IPv4Prefix{} }
func (m *IPv4Prefix) String() string            { return proto.CompactTextString(m) }
func (*IPv4Prefix) ProtoMessage()               {}
func (*IPv4Prefix) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *IPv4Prefix) GetAddr() uint32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *IPv4Prefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IPv6 Prefix
type IPv6Prefix struct {
	// IPv6 address bytes
	Addr []byte `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	// prefix length
	Len uint32 `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-128`
}

func (m *IPv6Prefix) Reset()                    { *m = IPv6Prefix{} }
func (m *IPv6Prefix) String() string            { return proto.CompactTextString(m) }
func (*IPv6Prefix) ProtoMessage()               {}
func (*IPv6Prefix) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *IPv6Prefix) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *IPv6Prefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IP Prefix object
type IPPrefix struct {
	// IP prefix address
	Addr *IPAddress `protobuf:"bytes,1,opt,name=Addr" json:"Addr,omitempty"`
	// IP Prefix length
	Len uint32 `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-128`
}

func (m *IPPrefix) Reset()                    { *m = IPPrefix{} }
func (m *IPPrefix) String() string            { return proto.CompactTextString(m) }
func (*IPPrefix) ProtoMessage()               {}
func (*IPPrefix) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *IPPrefix) GetAddr() *IPAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *IPPrefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IPSubnet represents an IPv4 or IPv6 subnet
type IPSubnet struct {
	// Types that are valid to be assigned to Subnet:
	//	*IPSubnet_IPv4Subnet
	//	*IPSubnet_IPv6Subnet
	Subnet isIPSubnet_Subnet `protobuf_oneof:"subnet"`
}

func (m *IPSubnet) Reset()                    { *m = IPSubnet{} }
func (m *IPSubnet) String() string            { return proto.CompactTextString(m) }
func (*IPSubnet) ProtoMessage()               {}
func (*IPSubnet) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

type isIPSubnet_Subnet interface {
	isIPSubnet_Subnet()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPSubnet_IPv4Subnet struct {
	IPv4Subnet *IPPrefix `protobuf:"bytes,1,opt,name=IPv4Subnet,oneof"`
}
type IPSubnet_IPv6Subnet struct {
	IPv6Subnet *IPPrefix `protobuf:"bytes,2,opt,name=IPv6Subnet,oneof"`
}

func (*IPSubnet_IPv4Subnet) isIPSubnet_Subnet() {}
func (*IPSubnet_IPv6Subnet) isIPSubnet_Subnet() {}

func (m *IPSubnet) GetSubnet() isIPSubnet_Subnet {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *IPSubnet) GetIPv4Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_IPv4Subnet); ok {
		return x.IPv4Subnet
	}
	return nil
}

func (m *IPSubnet) GetIPv6Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_IPv6Subnet); ok {
		return x.IPv6Subnet
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSubnet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSubnet_OneofMarshaler, _IPSubnet_OneofUnmarshaler, _IPSubnet_OneofSizer, []interface{}{
		(*IPSubnet_IPv4Subnet)(nil),
		(*IPSubnet_IPv6Subnet)(nil),
	}
}

func _IPSubnet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSubnet)
	// subnet
	switch x := m.Subnet.(type) {
	case *IPSubnet_IPv4Subnet:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IPv4Subnet); err != nil {
			return err
		}
	case *IPSubnet_IPv6Subnet:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IPv6Subnet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSubnet.Subnet has unexpected type %T", x)
	}
	return nil
}

func _IPSubnet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSubnet)
	switch tag {
	case 1: // subnet.IPv4Subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Subnet = &IPSubnet_IPv4Subnet{msg}
		return true, err
	case 2: // subnet.IPv6Subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Subnet = &IPSubnet_IPv6Subnet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSubnet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSubnet)
	// subnet
	switch x := m.Subnet.(type) {
	case *IPSubnet_IPv4Subnet:
		s := proto.Size(x.IPv4Subnet)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSubnet_IPv6Subnet:
		s := proto.Size(x.IPv6Subnet)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AddressRange represents an IPv4 or IPv6 address range
type AddressRange struct {
	// Types that are valid to be assigned to Range:
	//	*AddressRange_IPv4Range
	//	*AddressRange_IPv6Range
	Range isAddressRange_Range `protobuf_oneof:"range"`
}

func (m *AddressRange) Reset()                    { *m = AddressRange{} }
func (m *AddressRange) String() string            { return proto.CompactTextString(m) }
func (*AddressRange) ProtoMessage()               {}
func (*AddressRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

type isAddressRange_Range interface {
	isAddressRange_Range()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AddressRange_IPv4Range struct {
	IPv4Range *IPRange `protobuf:"bytes,1,opt,name=IPv4Range,oneof"`
}
type AddressRange_IPv6Range struct {
	IPv6Range *IPRange `protobuf:"bytes,2,opt,name=IPv6Range,oneof"`
}

func (*AddressRange_IPv4Range) isAddressRange_Range() {}
func (*AddressRange_IPv6Range) isAddressRange_Range() {}

func (m *AddressRange) GetRange() isAddressRange_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *AddressRange) GetIPv4Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_IPv4Range); ok {
		return x.IPv4Range
	}
	return nil
}

func (m *AddressRange) GetIPv6Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_IPv6Range); ok {
		return x.IPv6Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AddressRange) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AddressRange_OneofMarshaler, _AddressRange_OneofUnmarshaler, _AddressRange_OneofSizer, []interface{}{
		(*AddressRange_IPv4Range)(nil),
		(*AddressRange_IPv6Range)(nil),
	}
}

func _AddressRange_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AddressRange)
	// range
	switch x := m.Range.(type) {
	case *AddressRange_IPv4Range:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IPv4Range); err != nil {
			return err
		}
	case *AddressRange_IPv6Range:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IPv6Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AddressRange.Range has unexpected type %T", x)
	}
	return nil
}

func _AddressRange_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AddressRange)
	switch tag {
	case 1: // range.IPv4Range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.Range = &AddressRange_IPv4Range{msg}
		return true, err
	case 2: // range.IPv6Range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPRange)
		err := b.DecodeMessage(msg)
		m.Range = &AddressRange_IPv6Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AddressRange_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AddressRange)
	// range
	switch x := m.Range.(type) {
	case *AddressRange_IPv4Range:
		s := proto.Size(x.IPv4Range)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AddressRange_IPv6Range:
		s := proto.Size(x.IPv6Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Address object is the prefix or range
type Address struct {
	// Types that are valid to be assigned to Address:
	//	*Address_Prefix
	//	*Address_Range
	Address isAddress_Address `protobuf_oneof:"address"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isAddress_Address interface {
	isAddress_Address()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Address_Prefix struct {
	Prefix *IPSubnet `protobuf:"bytes,1,opt,name=Prefix,oneof"`
}
type Address_Range struct {
	Range *AddressRange `protobuf:"bytes,2,opt,name=Range,oneof"`
}

func (*Address_Prefix) isAddress_Address() {}
func (*Address_Range) isAddress_Address()  {}

func (m *Address) GetAddress() isAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Address) GetPrefix() *IPSubnet {
	if x, ok := m.GetAddress().(*Address_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *Address) GetRange() *AddressRange {
	if x, ok := m.GetAddress().(*Address_Range); ok {
		return x.Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Address) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Address_OneofMarshaler, _Address_OneofUnmarshaler, _Address_OneofSizer, []interface{}{
		(*Address_Prefix)(nil),
		(*Address_Range)(nil),
	}
}

func _Address_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Address)
	// address
	switch x := m.Address.(type) {
	case *Address_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *Address_Range:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Address.Address has unexpected type %T", x)
	}
	return nil
}

func _Address_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Address)
	switch tag {
	case 1: // address.Prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSubnet)
		err := b.DecodeMessage(msg)
		m.Address = &Address_Prefix{msg}
		return true, err
	case 2: // address.Range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Address = &Address_Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Address_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Address)
	// address
	switch x := m.Address.(type) {
	case *Address_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Address_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PortRange object has low and high end of the port ranges
type PortRange struct {
	PortLow  uint32 `protobuf:"varint,1,opt,name=PortLow,proto3" json:"PortLow,omitempty" meta:range:0-65535`
	PortHigh uint32 `protobuf:"varint,2,opt,name=PortHigh,proto3" json:"PortHigh,omitempty" meta:range:0-65535`
}

func (m *PortRange) Reset()                    { *m = PortRange{} }
func (m *PortRange) String() string            { return proto.CompactTextString(m) }
func (*PortRange) ProtoMessage()               {}
func (*PortRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *PortRange) GetPortLow() uint32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *PortRange) GetPortHigh() uint32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

// L3 rule match criteria
type RuleL3Match struct {
	// IP Protocol
	//
	// Types that are valid to be assigned to Protomatch:
	//	*RuleL3Match_ProtoNum
	//	*RuleL3Match_ProtoWildcard
	Protomatch isRuleL3Match_Protomatch `protobuf_oneof:"protomatch"`
	// Types that are valid to be assigned to Srcmatch:
	//	*RuleL3Match_SrcPrefix
	//	*RuleL3Match_SrcRange
	//	*RuleL3Match_SrcTag
	Srcmatch isRuleL3Match_Srcmatch `protobuf_oneof:"srcmatch"`
	// Types that are valid to be assigned to Dstmatch:
	//	*RuleL3Match_DstPrefix
	//	*RuleL3Match_DstRange
	//	*RuleL3Match_DstTag
	Dstmatch isRuleL3Match_Dstmatch `protobuf_oneof:"dstmatch"`
}

func (m *RuleL3Match) Reset()                    { *m = RuleL3Match{} }
func (m *RuleL3Match) String() string            { return proto.CompactTextString(m) }
func (*RuleL3Match) ProtoMessage()               {}
func (*RuleL3Match) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type isRuleL3Match_Protomatch interface {
	isRuleL3Match_Protomatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRuleL3Match_Srcmatch interface {
	isRuleL3Match_Srcmatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRuleL3Match_Dstmatch interface {
	isRuleL3Match_Dstmatch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleL3Match_ProtoNum struct {
	ProtoNum uint32 `protobuf:"varint,1,opt,name=ProtoNum,proto3,oneof"`
}
type RuleL3Match_ProtoWildcard struct {
	ProtoWildcard WildcardMatch `protobuf:"varint,2,opt,name=ProtoWildcard,proto3,enum=types.WildcardMatch,oneof"`
}
type RuleL3Match_SrcPrefix struct {
	SrcPrefix *IPPrefix `protobuf:"bytes,3,opt,name=SrcPrefix,oneof"`
}
type RuleL3Match_SrcRange struct {
	SrcRange *AddressRange `protobuf:"bytes,4,opt,name=SrcRange,oneof"`
}
type RuleL3Match_SrcTag struct {
	SrcTag uint32 `protobuf:"varint,5,opt,name=SrcTag,proto3,oneof"`
}
type RuleL3Match_DstPrefix struct {
	DstPrefix *IPPrefix `protobuf:"bytes,6,opt,name=DstPrefix,oneof"`
}
type RuleL3Match_DstRange struct {
	DstRange *AddressRange `protobuf:"bytes,7,opt,name=DstRange,oneof"`
}
type RuleL3Match_DstTag struct {
	DstTag uint32 `protobuf:"varint,8,opt,name=DstTag,proto3,oneof"`
}

func (*RuleL3Match_ProtoNum) isRuleL3Match_Protomatch()      {}
func (*RuleL3Match_ProtoWildcard) isRuleL3Match_Protomatch() {}
func (*RuleL3Match_SrcPrefix) isRuleL3Match_Srcmatch()       {}
func (*RuleL3Match_SrcRange) isRuleL3Match_Srcmatch()        {}
func (*RuleL3Match_SrcTag) isRuleL3Match_Srcmatch()          {}
func (*RuleL3Match_DstPrefix) isRuleL3Match_Dstmatch()       {}
func (*RuleL3Match_DstRange) isRuleL3Match_Dstmatch()        {}
func (*RuleL3Match_DstTag) isRuleL3Match_Dstmatch()          {}

func (m *RuleL3Match) GetProtomatch() isRuleL3Match_Protomatch {
	if m != nil {
		return m.Protomatch
	}
	return nil
}
func (m *RuleL3Match) GetSrcmatch() isRuleL3Match_Srcmatch {
	if m != nil {
		return m.Srcmatch
	}
	return nil
}
func (m *RuleL3Match) GetDstmatch() isRuleL3Match_Dstmatch {
	if m != nil {
		return m.Dstmatch
	}
	return nil
}

func (m *RuleL3Match) GetProtoNum() uint32 {
	if x, ok := m.GetProtomatch().(*RuleL3Match_ProtoNum); ok {
		return x.ProtoNum
	}
	return 0
}

func (m *RuleL3Match) GetProtoWildcard() WildcardMatch {
	if x, ok := m.GetProtomatch().(*RuleL3Match_ProtoWildcard); ok {
		return x.ProtoWildcard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *RuleL3Match) GetSrcPrefix() *IPPrefix {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcPrefix); ok {
		return x.SrcPrefix
	}
	return nil
}

func (m *RuleL3Match) GetSrcRange() *AddressRange {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcRange); ok {
		return x.SrcRange
	}
	return nil
}

func (m *RuleL3Match) GetSrcTag() uint32 {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcTag); ok {
		return x.SrcTag
	}
	return 0
}

func (m *RuleL3Match) GetDstPrefix() *IPPrefix {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstPrefix); ok {
		return x.DstPrefix
	}
	return nil
}

func (m *RuleL3Match) GetDstRange() *AddressRange {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstRange); ok {
		return x.DstRange
	}
	return nil
}

func (m *RuleL3Match) GetDstTag() uint32 {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstTag); ok {
		return x.DstTag
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RuleL3Match) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RuleL3Match_OneofMarshaler, _RuleL3Match_OneofUnmarshaler, _RuleL3Match_OneofSizer, []interface{}{
		(*RuleL3Match_ProtoNum)(nil),
		(*RuleL3Match_ProtoWildcard)(nil),
		(*RuleL3Match_SrcPrefix)(nil),
		(*RuleL3Match_SrcRange)(nil),
		(*RuleL3Match_SrcTag)(nil),
		(*RuleL3Match_DstPrefix)(nil),
		(*RuleL3Match_DstRange)(nil),
		(*RuleL3Match_DstTag)(nil),
	}
}

func _RuleL3Match_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RuleL3Match)
	// protomatch
	switch x := m.Protomatch.(type) {
	case *RuleL3Match_ProtoNum:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ProtoNum))
	case *RuleL3Match_ProtoWildcard:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ProtoWildcard))
	case nil:
	default:
		return fmt.Errorf("RuleL3Match.Protomatch has unexpected type %T", x)
	}
	// srcmatch
	switch x := m.Srcmatch.(type) {
	case *RuleL3Match_SrcPrefix:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SrcPrefix); err != nil {
			return err
		}
	case *RuleL3Match_SrcRange:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SrcRange); err != nil {
			return err
		}
	case *RuleL3Match_SrcTag:
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.SrcTag))
	case nil:
	default:
		return fmt.Errorf("RuleL3Match.Srcmatch has unexpected type %T", x)
	}
	// dstmatch
	switch x := m.Dstmatch.(type) {
	case *RuleL3Match_DstPrefix:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstPrefix); err != nil {
			return err
		}
	case *RuleL3Match_DstRange:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DstRange); err != nil {
			return err
		}
	case *RuleL3Match_DstTag:
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DstTag))
	case nil:
	default:
		return fmt.Errorf("RuleL3Match.Dstmatch has unexpected type %T", x)
	}
	return nil
}

func _RuleL3Match_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RuleL3Match)
	switch tag {
	case 1: // protomatch.ProtoNum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Protomatch = &RuleL3Match_ProtoNum{uint32(x)}
		return true, err
	case 2: // protomatch.ProtoWildcard
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Protomatch = &RuleL3Match_ProtoWildcard{WildcardMatch(x)}
		return true, err
	case 3: // srcmatch.SrcPrefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Srcmatch = &RuleL3Match_SrcPrefix{msg}
		return true, err
	case 4: // srcmatch.SrcRange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Srcmatch = &RuleL3Match_SrcRange{msg}
		return true, err
	case 5: // srcmatch.SrcTag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Srcmatch = &RuleL3Match_SrcTag{uint32(x)}
		return true, err
	case 6: // dstmatch.DstPrefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPPrefix)
		err := b.DecodeMessage(msg)
		m.Dstmatch = &RuleL3Match_DstPrefix{msg}
		return true, err
	case 7: // dstmatch.DstRange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Dstmatch = &RuleL3Match_DstRange{msg}
		return true, err
	case 8: // dstmatch.DstTag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Dstmatch = &RuleL3Match_DstTag{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _RuleL3Match_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RuleL3Match)
	// protomatch
	switch x := m.Protomatch.(type) {
	case *RuleL3Match_ProtoNum:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ProtoNum))
	case *RuleL3Match_ProtoWildcard:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ProtoWildcard))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// srcmatch
	switch x := m.Srcmatch.(type) {
	case *RuleL3Match_SrcPrefix:
		s := proto.Size(x.SrcPrefix)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleL3Match_SrcRange:
		s := proto.Size(x.SrcRange)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleL3Match_SrcTag:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SrcTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dstmatch
	switch x := m.Dstmatch.(type) {
	case *RuleL3Match_DstPrefix:
		s := proto.Size(x.DstPrefix)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleL3Match_DstRange:
		s := proto.Size(x.DstRange)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleL3Match_DstTag:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DstTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TCP/UDP rule match criteria
type PortMatch struct {
	// source port range
	SrcPortRange *PortRange `protobuf:"bytes,1,opt,name=SrcPortRange" json:"SrcPortRange,omitempty"`
	// destination port range
	DstPortRange *PortRange `protobuf:"bytes,2,opt,name=DstPortRange" json:"DstPortRange,omitempty"`
}

func (m *PortMatch) Reset()                    { *m = PortMatch{} }
func (m *PortMatch) String() string            { return proto.CompactTextString(m) }
func (*PortMatch) ProtoMessage()               {}
func (*PortMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *PortMatch) GetSrcPortRange() *PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *PortMatch) GetDstPortRange() *PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// ICMPv4/ICMPv6 rule match criteria
type ICMPMatch struct {
	// ICMP type
	//
	// Types that are valid to be assigned to Typematch:
	//	*ICMPMatch_TypeNum
	//	*ICMPMatch_TypeWildcard
	Typematch isICMPMatch_Typematch `protobuf_oneof:"typematch"`
	// ICMP code
	//
	// Types that are valid to be assigned to Codematch:
	//	*ICMPMatch_CodeNum
	//	*ICMPMatch_CodeWildcard
	Codematch isICMPMatch_Codematch `protobuf_oneof:"codematch"`
}

func (m *ICMPMatch) Reset()                    { *m = ICMPMatch{} }
func (m *ICMPMatch) String() string            { return proto.CompactTextString(m) }
func (*ICMPMatch) ProtoMessage()               {}
func (*ICMPMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

type isICMPMatch_Typematch interface {
	isICMPMatch_Typematch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isICMPMatch_Codematch interface {
	isICMPMatch_Codematch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ICMPMatch_TypeNum struct {
	TypeNum uint32 `protobuf:"varint,1,opt,name=TypeNum,proto3,oneof"`
}
type ICMPMatch_TypeWildcard struct {
	TypeWildcard WildcardMatch `protobuf:"varint,2,opt,name=TypeWildcard,proto3,enum=types.WildcardMatch,oneof"`
}
type ICMPMatch_CodeNum struct {
	CodeNum uint32 `protobuf:"varint,3,opt,name=CodeNum,proto3,oneof"`
}
type ICMPMatch_CodeWildcard struct {
	CodeWildcard WildcardMatch `protobuf:"varint,4,opt,name=CodeWildcard,proto3,enum=types.WildcardMatch,oneof"`
}

func (*ICMPMatch_TypeNum) isICMPMatch_Typematch()      {}
func (*ICMPMatch_TypeWildcard) isICMPMatch_Typematch() {}
func (*ICMPMatch_CodeNum) isICMPMatch_Codematch()      {}
func (*ICMPMatch_CodeWildcard) isICMPMatch_Codematch() {}

func (m *ICMPMatch) GetTypematch() isICMPMatch_Typematch {
	if m != nil {
		return m.Typematch
	}
	return nil
}
func (m *ICMPMatch) GetCodematch() isICMPMatch_Codematch {
	if m != nil {
		return m.Codematch
	}
	return nil
}

func (m *ICMPMatch) GetTypeNum() uint32 {
	if x, ok := m.GetTypematch().(*ICMPMatch_TypeNum); ok {
		return x.TypeNum
	}
	return 0
}

func (m *ICMPMatch) GetTypeWildcard() WildcardMatch {
	if x, ok := m.GetTypematch().(*ICMPMatch_TypeWildcard); ok {
		return x.TypeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *ICMPMatch) GetCodeNum() uint32 {
	if x, ok := m.GetCodematch().(*ICMPMatch_CodeNum); ok {
		return x.CodeNum
	}
	return 0
}

func (m *ICMPMatch) GetCodeWildcard() WildcardMatch {
	if x, ok := m.GetCodematch().(*ICMPMatch_CodeWildcard); ok {
		return x.CodeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ICMPMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ICMPMatch_OneofMarshaler, _ICMPMatch_OneofUnmarshaler, _ICMPMatch_OneofSizer, []interface{}{
		(*ICMPMatch_TypeNum)(nil),
		(*ICMPMatch_TypeWildcard)(nil),
		(*ICMPMatch_CodeNum)(nil),
		(*ICMPMatch_CodeWildcard)(nil),
	}
}

func _ICMPMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ICMPMatch)
	// typematch
	switch x := m.Typematch.(type) {
	case *ICMPMatch_TypeNum:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TypeNum))
	case *ICMPMatch_TypeWildcard:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TypeWildcard))
	case nil:
	default:
		return fmt.Errorf("ICMPMatch.Typematch has unexpected type %T", x)
	}
	// codematch
	switch x := m.Codematch.(type) {
	case *ICMPMatch_CodeNum:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.CodeNum))
	case *ICMPMatch_CodeWildcard:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.CodeWildcard))
	case nil:
	default:
		return fmt.Errorf("ICMPMatch.Codematch has unexpected type %T", x)
	}
	return nil
}

func _ICMPMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ICMPMatch)
	switch tag {
	case 1: // typematch.TypeNum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Typematch = &ICMPMatch_TypeNum{uint32(x)}
		return true, err
	case 2: // typematch.TypeWildcard
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Typematch = &ICMPMatch_TypeWildcard{WildcardMatch(x)}
		return true, err
	case 3: // codematch.CodeNum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Codematch = &ICMPMatch_CodeNum{uint32(x)}
		return true, err
	case 4: // codematch.CodeWildcard
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Codematch = &ICMPMatch_CodeWildcard{WildcardMatch(x)}
		return true, err
	default:
		return false, nil
	}
}

func _ICMPMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ICMPMatch)
	// typematch
	switch x := m.Typematch.(type) {
	case *ICMPMatch_TypeNum:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TypeNum))
	case *ICMPMatch_TypeWildcard:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.TypeWildcard))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// codematch
	switch x := m.Codematch.(type) {
	case *ICMPMatch_CodeNum:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CodeNum))
	case *ICMPMatch_CodeWildcard:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CodeWildcard))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L4 rule match criteria
type RuleL4Match struct {
	// Types that are valid to be assigned to L4Info:
	//	*RuleL4Match_Ports
	//	*RuleL4Match_TypeCode
	L4Info isRuleL4Match_L4Info `protobuf_oneof:"l4info"`
}

func (m *RuleL4Match) Reset()                    { *m = RuleL4Match{} }
func (m *RuleL4Match) String() string            { return proto.CompactTextString(m) }
func (*RuleL4Match) ProtoMessage()               {}
func (*RuleL4Match) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isRuleL4Match_L4Info interface {
	isRuleL4Match_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleL4Match_Ports struct {
	Ports *PortMatch `protobuf:"bytes,1,opt,name=Ports,oneof"`
}
type RuleL4Match_TypeCode struct {
	TypeCode *ICMPMatch `protobuf:"bytes,2,opt,name=TypeCode,oneof"`
}

func (*RuleL4Match_Ports) isRuleL4Match_L4Info()    {}
func (*RuleL4Match_TypeCode) isRuleL4Match_L4Info() {}

func (m *RuleL4Match) GetL4Info() isRuleL4Match_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *RuleL4Match) GetPorts() *PortMatch {
	if x, ok := m.GetL4Info().(*RuleL4Match_Ports); ok {
		return x.Ports
	}
	return nil
}

func (m *RuleL4Match) GetTypeCode() *ICMPMatch {
	if x, ok := m.GetL4Info().(*RuleL4Match_TypeCode); ok {
		return x.TypeCode
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RuleL4Match) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RuleL4Match_OneofMarshaler, _RuleL4Match_OneofUnmarshaler, _RuleL4Match_OneofSizer, []interface{}{
		(*RuleL4Match_Ports)(nil),
		(*RuleL4Match_TypeCode)(nil),
	}
}

func _RuleL4Match_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RuleL4Match)
	// l4info
	switch x := m.L4Info.(type) {
	case *RuleL4Match_Ports:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ports); err != nil {
			return err
		}
	case *RuleL4Match_TypeCode:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypeCode); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RuleL4Match.L4Info has unexpected type %T", x)
	}
	return nil
}

func _RuleL4Match_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RuleL4Match)
	switch tag {
	case 1: // l4info.Ports
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PortMatch)
		err := b.DecodeMessage(msg)
		m.L4Info = &RuleL4Match_Ports{msg}
		return true, err
	case 2: // l4info.TypeCode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPMatch)
		err := b.DecodeMessage(msg)
		m.L4Info = &RuleL4Match_TypeCode{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RuleL4Match_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RuleL4Match)
	// l4info
	switch x := m.L4Info.(type) {
	case *RuleL4Match_Ports:
		s := proto.Size(x.Ports)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleL4Match_TypeCode:
		s := proto.Size(x.TypeCode)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// rule match criteria
type RuleMatch struct {
	// Layer 3 match criteria
	L3Match *RuleL3Match `protobuf:"bytes,1,opt,name=L3Match" json:"L3Match,omitempty"`
	// Layer 4 match criteria
	L4Match *RuleL4Match `protobuf:"bytes,2,opt,name=L4Match" json:"L4Match,omitempty"`
}

func (m *RuleMatch) Reset()                    { *m = RuleMatch{} }
func (m *RuleMatch) String() string            { return proto.CompactTextString(m) }
func (*RuleMatch) ProtoMessage()               {}
func (*RuleMatch) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *RuleMatch) GetL3Match() *RuleL3Match {
	if m != nil {
		return m.L3Match
	}
	return nil
}

func (m *RuleMatch) GetL4Match() *RuleL4Match {
	if m != nil {
		return m.L4Match
	}
	return nil
}

// QinQ vlan tag
type QinQTag struct {
	// Customer VLAN tag
	CTag uint32 `protobuf:"varint,1,opt,name=cTag,proto3" json:"cTag,omitempty" meta:mandatory`
	// Service VLAN tag
	STag uint32 `protobuf:"varint,2,opt,name=sTag,proto3" json:"sTag,omitempty" meta:mandatory`
}

func (m *QinQTag) Reset()                    { *m = QinQTag{} }
func (m *QinQTag) String() string            { return proto.CompactTextString(m) }
func (*QinQTag) ProtoMessage()               {}
func (*QinQTag) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *QinQTag) GetCTag() uint32 {
	if m != nil {
		return m.CTag
	}
	return 0
}

func (m *QinQTag) GetSTag() uint32 {
	if m != nil {
		return m.STag
	}
	return 0
}

// based on the encap type in the fabric, one can carry per vnic information
// for example, in case of MPLSoUDP, MPLS tag (along with source tunnel IP)
// can uniquely identify the vnic from where the packet is originating and
// another MPLS tag (along with the destination tunnel IP) can identify the
// destination VNIC
type EncapVal struct {
	// Types that are valid to be assigned to Val:
	//	*EncapVal_VlanId
	//	*EncapVal_MPLSTag
	//	*EncapVal_Vnid
	//	*EncapVal_QinQTag
	Val isEncapVal_Val `protobuf_oneof:"val"`
}

func (m *EncapVal) Reset()                    { *m = EncapVal{} }
func (m *EncapVal) String() string            { return proto.CompactTextString(m) }
func (*EncapVal) ProtoMessage()               {}
func (*EncapVal) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

type isEncapVal_Val interface {
	isEncapVal_Val()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EncapVal_VlanId struct {
	VlanId uint32 `protobuf:"varint,1,opt,name=VlanId,proto3,oneof"`
}
type EncapVal_MPLSTag struct {
	MPLSTag uint32 `protobuf:"varint,2,opt,name=MPLSTag,proto3,oneof"`
}
type EncapVal_Vnid struct {
	Vnid uint32 `protobuf:"varint,3,opt,name=Vnid,proto3,oneof"`
}
type EncapVal_QinQTag struct {
	QinQTag *QinQTag `protobuf:"bytes,4,opt,name=QinQTag,oneof"`
}

func (*EncapVal_VlanId) isEncapVal_Val()  {}
func (*EncapVal_MPLSTag) isEncapVal_Val() {}
func (*EncapVal_Vnid) isEncapVal_Val()    {}
func (*EncapVal_QinQTag) isEncapVal_Val() {}

func (m *EncapVal) GetVal() isEncapVal_Val {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *EncapVal) GetVlanId() uint32 {
	if x, ok := m.GetVal().(*EncapVal_VlanId); ok {
		return x.VlanId
	}
	return 0
}

func (m *EncapVal) GetMPLSTag() uint32 {
	if x, ok := m.GetVal().(*EncapVal_MPLSTag); ok {
		return x.MPLSTag
	}
	return 0
}

func (m *EncapVal) GetVnid() uint32 {
	if x, ok := m.GetVal().(*EncapVal_Vnid); ok {
		return x.Vnid
	}
	return 0
}

func (m *EncapVal) GetQinQTag() *QinQTag {
	if x, ok := m.GetVal().(*EncapVal_QinQTag); ok {
		return x.QinQTag
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EncapVal) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EncapVal_OneofMarshaler, _EncapVal_OneofUnmarshaler, _EncapVal_OneofSizer, []interface{}{
		(*EncapVal_VlanId)(nil),
		(*EncapVal_MPLSTag)(nil),
		(*EncapVal_Vnid)(nil),
		(*EncapVal_QinQTag)(nil),
	}
}

func _EncapVal_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EncapVal)
	// val
	switch x := m.Val.(type) {
	case *EncapVal_VlanId:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.VlanId))
	case *EncapVal_MPLSTag:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.MPLSTag))
	case *EncapVal_Vnid:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Vnid))
	case *EncapVal_QinQTag:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QinQTag); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EncapVal.Val has unexpected type %T", x)
	}
	return nil
}

func _EncapVal_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EncapVal)
	switch tag {
	case 1: // val.VlanId
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Val = &EncapVal_VlanId{uint32(x)}
		return true, err
	case 2: // val.MPLSTag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Val = &EncapVal_MPLSTag{uint32(x)}
		return true, err
	case 3: // val.Vnid
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Val = &EncapVal_Vnid{uint32(x)}
		return true, err
	case 4: // val.QinQTag
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QinQTag)
		err := b.DecodeMessage(msg)
		m.Val = &EncapVal_QinQTag{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EncapVal_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EncapVal)
	// val
	switch x := m.Val.(type) {
	case *EncapVal_VlanId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.VlanId))
	case *EncapVal_MPLSTag:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.MPLSTag))
	case *EncapVal_Vnid:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Vnid))
	case *EncapVal_QinQTag:
		s := proto.Size(x.QinQTag)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// fabric encap
type Encap struct {
	Type  EncapType `protobuf:"varint,1,opt,name=type,proto3,enum=types.EncapType" json:"type,omitempty"`
	Value *EncapVal `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Encap) Reset()                    { *m = Encap{} }
func (m *Encap) String() string            { return proto.CompactTextString(m) }
func (*Encap) ProtoMessage()               {}
func (*Encap) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *Encap) GetType() EncapType {
	if m != nil {
		return m.Type
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *Encap) GetValue() *EncapVal {
	if m != nil {
		return m.Value
	}
	return nil
}

// BatchCtxt is opaque to application(s) and is expected to be passed
// back (to identify the batch) in every API call of this batch until
// BatchCommit() or BatchAbort()
type BatchCtxt struct {
	// opaque cookie
	BatchCookie uint64 `protobuf:"varint,1,opt,name=BatchCookie,proto3" json:"BatchCookie,omitempty"`
}

func (m *BatchCtxt) Reset()                    { *m = BatchCtxt{} }
func (m *BatchCtxt) String() string            { return proto.CompactTextString(m) }
func (*BatchCtxt) ProtoMessage()               {}
func (*BatchCtxt) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *BatchCtxt) GetBatchCookie() uint64 {
	if m != nil {
		return m.BatchCookie
	}
	return 0
}

// flow key for non-IP flows
type MACFlowKey struct {
	// subnet identifier
	Subnet []byte `protobuf:"bytes,1,opt,name=Subnet,proto3" json:"Subnet,omitempty"`
	// source MAC address
	SrcMAC uint64 `protobuf:"varint,2,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	// destination MAC address
	DstMAC uint64 `protobuf:"varint,3,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	// 16 bits of Ethertype in the Ethernet header
	EtherType uint32 `protobuf:"varint,4,opt,name=EtherType,proto3" json:"EtherType,omitempty"`
}

func (m *MACFlowKey) Reset()                    { *m = MACFlowKey{} }
func (m *MACFlowKey) String() string            { return proto.CompactTextString(m) }
func (*MACFlowKey) ProtoMessage()               {}
func (*MACFlowKey) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *MACFlowKey) GetSubnet() []byte {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *MACFlowKey) GetSrcMAC() uint64 {
	if m != nil {
		return m.SrcMAC
	}
	return 0
}

func (m *MACFlowKey) GetDstMAC() uint64 {
	if m != nil {
		return m.DstMAC
	}
	return 0
}

func (m *MACFlowKey) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

// L4 portion of flow key tuple
type FlowL4Info struct {
	// Types that are valid to be assigned to L4Info:
	//	*FlowL4Info_TcpUdpInfo
	//	*FlowL4Info_IcmpInfo
	L4Info isFlowL4Info_L4Info `protobuf_oneof:"l4_info"`
}

func (m *FlowL4Info) Reset()                    { *m = FlowL4Info{} }
func (m *FlowL4Info) String() string            { return proto.CompactTextString(m) }
func (*FlowL4Info) ProtoMessage()               {}
func (*FlowL4Info) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

type isFlowL4Info_L4Info interface {
	isFlowL4Info_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowL4Info_TcpUdpInfo struct {
	TcpUdpInfo *FlowL4Info_TCPUDPInfo `protobuf:"bytes,1,opt,name=TcpUdpInfo,oneof"`
}
type FlowL4Info_IcmpInfo struct {
	IcmpInfo *FlowL4Info_ICMPInfo `protobuf:"bytes,2,opt,name=IcmpInfo,oneof"`
}

func (*FlowL4Info_TcpUdpInfo) isFlowL4Info_L4Info() {}
func (*FlowL4Info_IcmpInfo) isFlowL4Info_L4Info()   {}

func (m *FlowL4Info) GetL4Info() isFlowL4Info_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *FlowL4Info) GetTcpUdpInfo() *FlowL4Info_TCPUDPInfo {
	if x, ok := m.GetL4Info().(*FlowL4Info_TcpUdpInfo); ok {
		return x.TcpUdpInfo
	}
	return nil
}

func (m *FlowL4Info) GetIcmpInfo() *FlowL4Info_ICMPInfo {
	if x, ok := m.GetL4Info().(*FlowL4Info_IcmpInfo); ok {
		return x.IcmpInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowL4Info) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowL4Info_OneofMarshaler, _FlowL4Info_OneofUnmarshaler, _FlowL4Info_OneofSizer, []interface{}{
		(*FlowL4Info_TcpUdpInfo)(nil),
		(*FlowL4Info_IcmpInfo)(nil),
	}
}

func _FlowL4Info_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowL4Info)
	// l4_info
	switch x := m.L4Info.(type) {
	case *FlowL4Info_TcpUdpInfo:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdpInfo); err != nil {
			return err
		}
	case *FlowL4Info_IcmpInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowL4Info.L4Info has unexpected type %T", x)
	}
	return nil
}

func _FlowL4Info_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowL4Info)
	switch tag {
	case 1: // l4_info.TcpUdpInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowL4Info_TCPUDPInfo)
		err := b.DecodeMessage(msg)
		m.L4Info = &FlowL4Info_TcpUdpInfo{msg}
		return true, err
	case 2: // l4_info.IcmpInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowL4Info_ICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Info = &FlowL4Info_IcmpInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowL4Info_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowL4Info)
	// l4_info
	switch x := m.L4Info.(type) {
	case *FlowL4Info_TcpUdpInfo:
		s := proto.Size(x.TcpUdpInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowL4Info_IcmpInfo:
		s := proto.Size(x.IcmpInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// key fields for TCP/UDP flows
type FlowL4Info_TCPUDPInfo struct {
	SrcPort uint32 `protobuf:"varint,1,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort uint32 `protobuf:"varint,2,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *FlowL4Info_TCPUDPInfo) Reset()                    { *m = FlowL4Info_TCPUDPInfo{} }
func (m *FlowL4Info_TCPUDPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowL4Info_TCPUDPInfo) ProtoMessage()               {}
func (*FlowL4Info_TCPUDPInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20, 0} }

func (m *FlowL4Info_TCPUDPInfo) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *FlowL4Info_TCPUDPInfo) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// key fields for ICMP flows
type FlowL4Info_ICMPInfo struct {
	Type uint32 `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Id   uint32 `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *FlowL4Info_ICMPInfo) Reset()                    { *m = FlowL4Info_ICMPInfo{} }
func (m *FlowL4Info_ICMPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowL4Info_ICMPInfo) ProtoMessage()               {}
func (*FlowL4Info_ICMPInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20, 1} }

func (m *FlowL4Info_ICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowL4Info_ICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowL4Info_ICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// flow key for IP flows
type IPFlowKey struct {
	// VPC identifier
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	// source IP seen in the packet
	SrcIP *IPAddress `protobuf:"bytes,2,opt,name=SrcIP" json:"SrcIP,omitempty"`
	// destination IP seen in the packet
	DstIP *IPAddress `protobuf:"bytes,3,opt,name=DstIP" json:"DstIP,omitempty"`
	// IP protocol
	IPProtocol uint32 `protobuf:"varint,4,opt,name=IPProtocol,proto3" json:"IPProtocol,omitempty"`
	// L4 information of the flow key
	L4Info *FlowL4Info `protobuf:"bytes,5,opt,name=L4Info" json:"L4Info,omitempty"`
}

func (m *IPFlowKey) Reset()                    { *m = IPFlowKey{} }
func (m *IPFlowKey) String() string            { return proto.CompactTextString(m) }
func (*IPFlowKey) ProtoMessage()               {}
func (*IPFlowKey) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

func (m *IPFlowKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *IPFlowKey) GetSrcIP() *IPAddress {
	if m != nil {
		return m.SrcIP
	}
	return nil
}

func (m *IPFlowKey) GetDstIP() *IPAddress {
	if m != nil {
		return m.DstIP
	}
	return nil
}

func (m *IPFlowKey) GetIPProtocol() uint32 {
	if m != nil {
		return m.IPProtocol
	}
	return 0
}

func (m *IPFlowKey) GetL4Info() *FlowL4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

// flow key is either IP flow key or non-IP flow key
type FlowKey struct {
	// Types that are valid to be assigned to Key:
	//	*FlowKey_IPFlowKey
	//	*FlowKey_MACFlowKey
	Key isFlowKey_Key `protobuf_oneof:"key"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{22} }

type isFlowKey_Key interface {
	isFlowKey_Key()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowKey_IPFlowKey struct {
	IPFlowKey *IPFlowKey `protobuf:"bytes,1,opt,name=IPFlowKey,oneof"`
}
type FlowKey_MACFlowKey struct {
	MACFlowKey *MACFlowKey `protobuf:"bytes,2,opt,name=MACFlowKey,oneof"`
}

func (*FlowKey_IPFlowKey) isFlowKey_Key()  {}
func (*FlowKey_MACFlowKey) isFlowKey_Key() {}

func (m *FlowKey) GetKey() isFlowKey_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FlowKey) GetIPFlowKey() *IPFlowKey {
	if x, ok := m.GetKey().(*FlowKey_IPFlowKey); ok {
		return x.IPFlowKey
	}
	return nil
}

func (m *FlowKey) GetMACFlowKey() *MACFlowKey {
	if x, ok := m.GetKey().(*FlowKey_MACFlowKey); ok {
		return x.MACFlowKey
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKey_OneofMarshaler, _FlowKey_OneofUnmarshaler, _FlowKey_OneofSizer, []interface{}{
		(*FlowKey_IPFlowKey)(nil),
		(*FlowKey_MACFlowKey)(nil),
	}
}

func _FlowKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKey)
	// key
	switch x := m.Key.(type) {
	case *FlowKey_IPFlowKey:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IPFlowKey); err != nil {
			return err
		}
	case *FlowKey_MACFlowKey:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MACFlowKey); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKey.Key has unexpected type %T", x)
	}
	return nil
}

func _FlowKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKey)
	switch tag {
	case 1: // key.IPFlowKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPFlowKey)
		err := b.DecodeMessage(msg)
		m.Key = &FlowKey_IPFlowKey{msg}
		return true, err
	case 2: // key.MACFlowKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MACFlowKey)
		err := b.DecodeMessage(msg)
		m.Key = &FlowKey_MACFlowKey{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKey)
	// key
	switch x := m.Key.(type) {
	case *FlowKey_IPFlowKey:
		s := proto.Size(x.IPFlowKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_MACFlowKey:
		s := proto.Size(x.MACFlowKey)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandMessage struct {
	Command    Command               `protobuf:"varint,1,opt,name=Command,proto3,enum=types.Command" json:"Command,omitempty"`
	CommandMsg *google_protobuf1.Any `protobuf:"bytes,2,opt,name=CommandMsg" json:"CommandMsg,omitempty"`
}

func (m *CommandMessage) Reset()                    { *m = CommandMessage{} }
func (m *CommandMessage) String() string            { return proto.CompactTextString(m) }
func (*CommandMessage) ProtoMessage()               {}
func (*CommandMessage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *CommandMessage) GetCommand() Command {
	if m != nil {
		return m.Command
	}
	return Command_CMD_NONE
}

func (m *CommandMessage) GetCommandMsg() *google_protobuf1.Any {
	if m != nil {
		return m.CommandMsg
	}
	return nil
}

type ConfigMessage struct {
	ConfigOp  ServiceRequestOp      `protobuf:"varint,1,opt,name=ConfigOp,proto3,enum=types.ServiceRequestOp" json:"ConfigOp,omitempty"`
	ConfigMsg *google_protobuf1.Any `protobuf:"bytes,2,opt,name=ConfigMsg" json:"ConfigMsg,omitempty"`
}

func (m *ConfigMessage) Reset()                    { *m = ConfigMessage{} }
func (m *ConfigMessage) String() string            { return proto.CompactTextString(m) }
func (*ConfigMessage) ProtoMessage()               {}
func (*ConfigMessage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{24} }

func (m *ConfigMessage) GetConfigOp() ServiceRequestOp {
	if m != nil {
		return m.ConfigOp
	}
	return ServiceRequestOp_SERVICE_OP_NONE
}

func (m *ConfigMessage) GetConfigMsg() *google_protobuf1.Any {
	if m != nil {
		return m.ConfigMsg
	}
	return nil
}

type ServiceRequestMessage struct {
	Version int64 `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*ServiceRequestMessage_Command
	//	*ServiceRequestMessage_Config
	Request isServiceRequestMessage_Request `protobuf_oneof:"request"`
}

func (m *ServiceRequestMessage) Reset()                    { *m = ServiceRequestMessage{} }
func (m *ServiceRequestMessage) String() string            { return proto.CompactTextString(m) }
func (*ServiceRequestMessage) ProtoMessage()               {}
func (*ServiceRequestMessage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{25} }

type isServiceRequestMessage_Request interface {
	isServiceRequestMessage_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceRequestMessage_Command struct {
	Command *CommandMessage `protobuf:"bytes,2,opt,name=Command,oneof"`
}
type ServiceRequestMessage_Config struct {
	Config *ConfigMessage `protobuf:"bytes,3,opt,name=Config,oneof"`
}

func (*ServiceRequestMessage_Command) isServiceRequestMessage_Request() {}
func (*ServiceRequestMessage_Config) isServiceRequestMessage_Request()  {}

func (m *ServiceRequestMessage) GetRequest() isServiceRequestMessage_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ServiceRequestMessage) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ServiceRequestMessage) GetCommand() *CommandMessage {
	if x, ok := m.GetRequest().(*ServiceRequestMessage_Command); ok {
		return x.Command
	}
	return nil
}

func (m *ServiceRequestMessage) GetConfig() *ConfigMessage {
	if x, ok := m.GetRequest().(*ServiceRequestMessage_Config); ok {
		return x.Config
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServiceRequestMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServiceRequestMessage_OneofMarshaler, _ServiceRequestMessage_OneofUnmarshaler, _ServiceRequestMessage_OneofSizer, []interface{}{
		(*ServiceRequestMessage_Command)(nil),
		(*ServiceRequestMessage_Config)(nil),
	}
}

func _ServiceRequestMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServiceRequestMessage)
	// request
	switch x := m.Request.(type) {
	case *ServiceRequestMessage_Command:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Command); err != nil {
			return err
		}
	case *ServiceRequestMessage_Config:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Config); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServiceRequestMessage.Request has unexpected type %T", x)
	}
	return nil
}

func _ServiceRequestMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServiceRequestMessage)
	switch tag {
	case 2: // request.Command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandMessage)
		err := b.DecodeMessage(msg)
		m.Request = &ServiceRequestMessage_Command{msg}
		return true, err
	case 3: // request.Config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigMessage)
		err := b.DecodeMessage(msg)
		m.Request = &ServiceRequestMessage_Config{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServiceRequestMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServiceRequestMessage)
	// request
	switch x := m.Request.(type) {
	case *ServiceRequestMessage_Command:
		s := proto.Size(x.Command)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServiceRequestMessage_Config:
		s := proto.Size(x.Config)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServiceResponseMessage struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *google_protobuf1.Any `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *ServiceResponseMessage) Reset()                    { *m = ServiceResponseMessage{} }
func (m *ServiceResponseMessage) String() string            { return proto.CompactTextString(m) }
func (*ServiceResponseMessage) ProtoMessage()               {}
func (*ServiceResponseMessage) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{26} }

func (m *ServiceResponseMessage) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ServiceResponseMessage) GetResponse() *google_protobuf1.Any {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "types.Empty")
	proto.RegisterType((*IPAddress)(nil), "types.IPAddress")
	proto.RegisterType((*IPRange)(nil), "types.IPRange")
	proto.RegisterType((*IPv4Prefix)(nil), "types.IPv4Prefix")
	proto.RegisterType((*IPv6Prefix)(nil), "types.IPv6Prefix")
	proto.RegisterType((*IPPrefix)(nil), "types.IPPrefix")
	proto.RegisterType((*IPSubnet)(nil), "types.IPSubnet")
	proto.RegisterType((*AddressRange)(nil), "types.AddressRange")
	proto.RegisterType((*Address)(nil), "types.Address")
	proto.RegisterType((*PortRange)(nil), "types.PortRange")
	proto.RegisterType((*RuleL3Match)(nil), "types.RuleL3Match")
	proto.RegisterType((*PortMatch)(nil), "types.PortMatch")
	proto.RegisterType((*ICMPMatch)(nil), "types.ICMPMatch")
	proto.RegisterType((*RuleL4Match)(nil), "types.RuleL4Match")
	proto.RegisterType((*RuleMatch)(nil), "types.RuleMatch")
	proto.RegisterType((*QinQTag)(nil), "types.QinQTag")
	proto.RegisterType((*EncapVal)(nil), "types.EncapVal")
	proto.RegisterType((*Encap)(nil), "types.Encap")
	proto.RegisterType((*BatchCtxt)(nil), "types.BatchCtxt")
	proto.RegisterType((*MACFlowKey)(nil), "types.MACFlowKey")
	proto.RegisterType((*FlowL4Info)(nil), "types.FlowL4Info")
	proto.RegisterType((*FlowL4Info_TCPUDPInfo)(nil), "types.FlowL4Info.TCPUDPInfo")
	proto.RegisterType((*FlowL4Info_ICMPInfo)(nil), "types.FlowL4Info.ICMPInfo")
	proto.RegisterType((*IPFlowKey)(nil), "types.IPFlowKey")
	proto.RegisterType((*FlowKey)(nil), "types.FlowKey")
	proto.RegisterType((*CommandMessage)(nil), "types.CommandMessage")
	proto.RegisterType((*ConfigMessage)(nil), "types.ConfigMessage")
	proto.RegisterType((*ServiceRequestMessage)(nil), "types.ServiceRequestMessage")
	proto.RegisterType((*ServiceResponseMessage)(nil), "types.ServiceResponseMessage")
	proto.RegisterEnum("types.ApiStatus", ApiStatus_name, ApiStatus_value)
	proto.RegisterEnum("types.IPAF", IPAF_name, IPAF_value)
	proto.RegisterEnum("types.WildcardMatch", WildcardMatch_name, WildcardMatch_value)
	proto.RegisterEnum("types.RuleDir", RuleDir_name, RuleDir_value)
	proto.RegisterEnum("types.EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("types.LifType", LifType_name, LifType_value)
	proto.RegisterEnum("types.SecurityRuleAction", SecurityRuleAction_name, SecurityRuleAction_value)
	proto.RegisterEnum("types.NatAction", NatAction_name, NatAction_value)
	proto.RegisterEnum("types.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("types.AdminState", AdminState_name, AdminState_value)
	proto.RegisterEnum("types.PortSpeed", PortSpeed_name, PortSpeed_value)
	proto.RegisterEnum("types.Command", Command_name, Command_value)
	proto.RegisterEnum("types.ServiceRequestOp", ServiceRequestOp_name, ServiceRequestOp_value)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Af != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Af))
	}
	if m.V4OrV6 != nil {
		nn1, err := m.V4OrV6.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *IPAddress_V4Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.V4Addr))
	i += 4
	return i, nil
}
func (m *IPAddress_V6Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V6Addr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.V6Addr)))
		i += copy(dAtA[i:], m.V6Addr)
	}
	return i, nil
}
func (m *IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Low != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Low.Size()))
		n2, err := m.Low.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.High != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.High.Size()))
		n3, err := m.High.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *IPv4Prefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4Prefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Addr))
		i += 4
	}
	if m.Len != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
	}
	return i, nil
}

func (m *IPv6Prefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Prefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Len != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
	}
	return i, nil
}

func (m *IPPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Addr.Size()))
		n4, err := m.Addr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Len != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
	}
	return i, nil
}

func (m *IPSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSubnet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subnet != nil {
		nn5, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *IPSubnet_IPv4Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IPv4Subnet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPv4Subnet.Size()))
		n6, err := m.IPv4Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *IPSubnet_IPv6Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IPv6Subnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPv6Subnet.Size()))
		n7, err := m.IPv6Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *AddressRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		nn8, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *AddressRange_IPv4Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IPv4Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPv4Range.Size()))
		n9, err := m.IPv4Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *AddressRange_IPv6Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IPv6Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPv6Range.Size()))
		n10, err := m.IPv6Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		nn11, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *Address_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Prefix.Size()))
		n12, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Address_Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Range.Size()))
		n13, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortLow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortHigh))
	}
	return i, nil
}

func (m *RuleL3Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleL3Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protomatch != nil {
		nn14, err := m.Protomatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.Srcmatch != nil {
		nn15, err := m.Srcmatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.Dstmatch != nil {
		nn16, err := m.Dstmatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *RuleL3Match_ProtoNum) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.ProtoNum))
	return i, nil
}
func (m *RuleL3Match_ProtoWildcard) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.ProtoWildcard))
	return i, nil
}
func (m *RuleL3Match_SrcPrefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SrcPrefix != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcPrefix.Size()))
		n17, err := m.SrcPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *RuleL3Match_SrcRange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SrcRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcRange.Size()))
		n18, err := m.SrcRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *RuleL3Match_SrcTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.SrcTag))
	return i, nil
}
func (m *RuleL3Match_DstPrefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstPrefix != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstPrefix.Size()))
		n19, err := m.DstPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *RuleL3Match_DstRange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DstRange != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstRange.Size()))
		n20, err := m.DstRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *RuleL3Match_DstTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x40
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.DstTag))
	return i, nil
}
func (m *PortMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPortRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcPortRange.Size()))
		n21, err := m.SrcPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DstPortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstPortRange.Size()))
		n22, err := m.DstPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *ICMPMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typematch != nil {
		nn23, err := m.Typematch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if m.Codematch != nil {
		nn24, err := m.Codematch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	return i, nil
}

func (m *ICMPMatch_TypeNum) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.TypeNum))
	return i, nil
}
func (m *ICMPMatch_TypeWildcard) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.TypeWildcard))
	return i, nil
}
func (m *ICMPMatch_CodeNum) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.CodeNum))
	return i, nil
}
func (m *ICMPMatch_CodeWildcard) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.CodeWildcard))
	return i, nil
}
func (m *RuleL4Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleL4Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L4Info != nil {
		nn25, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	return i, nil
}

func (m *RuleL4Match_Ports) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ports != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ports.Size()))
		n26, err := m.Ports.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *RuleL4Match_TypeCode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TypeCode != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TypeCode.Size()))
		n27, err := m.TypeCode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *RuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L3Match != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L3Match.Size()))
		n28, err := m.L3Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.L4Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4Match.Size()))
		n29, err := m.L4Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *QinQTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QinQTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CTag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CTag))
	}
	if m.STag != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.STag))
	}
	return i, nil
}

func (m *EncapVal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapVal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Val != nil {
		nn30, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	return i, nil
}

func (m *EncapVal_VlanId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
	return i, nil
}
func (m *EncapVal_MPLSTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.MPLSTag))
	return i, nil
}
func (m *EncapVal_Vnid) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Vnid))
	return i, nil
}
func (m *EncapVal_QinQTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QinQTag != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.QinQTag.Size()))
		n31, err := m.QinQTag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *Encap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Encap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Value.Size()))
		n32, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *BatchCtxt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCtxt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCookie != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BatchCookie))
	}
	return i, nil
}

func (m *MACFlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MACFlowKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subnet)))
		i += copy(dAtA[i:], m.Subnet)
	}
	if m.SrcMAC != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcMAC))
	}
	if m.DstMAC != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstMAC))
	}
	if m.EtherType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EtherType))
	}
	return i, nil
}

func (m *FlowL4Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L4Info != nil {
		nn33, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn33
	}
	return i, nil
}

func (m *FlowL4Info_TcpUdpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpUdpInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.TcpUdpInfo.Size()))
		n34, err := m.TcpUdpInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *FlowL4Info_IcmpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IcmpInfo.Size()))
		n35, err := m.IcmpInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *FlowL4Info_TCPUDPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info_TCPUDPInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstPort))
	}
	return i, nil
}

func (m *FlowL4Info_ICMPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info_ICMPInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *IPFlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPFlowKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VPCId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	if m.SrcIP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcIP.Size()))
		n36, err := m.SrcIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.DstIP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DstIP.Size()))
		n37, err := m.DstIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.IPProtocol != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPProtocol))
	}
	if m.L4Info != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.L4Info.Size()))
		n38, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *FlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		nn39, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	return i, nil
}

func (m *FlowKey_IPFlowKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IPFlowKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IPFlowKey.Size()))
		n40, err := m.IPFlowKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *FlowKey_MACFlowKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MACFlowKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MACFlowKey.Size()))
		n41, err := m.MACFlowKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *CommandMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Command != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Command))
	}
	if m.CommandMsg != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.CommandMsg.Size()))
		n42, err := m.CommandMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ConfigMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigOp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConfigOp))
	}
	if m.ConfigMsg != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConfigMsg.Size()))
		n43, err := m.ConfigMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *ServiceRequestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRequestMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
	}
	if m.Request != nil {
		nn44, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn44
	}
	return i, nil
}

func (m *ServiceRequestMessage_Command) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Command != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Command.Size()))
		n45, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *ServiceRequestMessage_Config) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Config.Size()))
		n46, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *ServiceResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Response.Size()))
		n47, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IPAddress) Size() (n int) {
	var l int
	_ = l
	if m.Af != 0 {
		n += 1 + sovTypes(uint64(m.Af))
	}
	if m.V4OrV6 != nil {
		n += m.V4OrV6.Size()
	}
	return n
}

func (m *IPAddress_V4Addr) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *IPAddress_V6Addr) Size() (n int) {
	var l int
	_ = l
	if m.V6Addr != nil {
		l = len(m.V6Addr)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPRange) Size() (n int) {
	var l int
	_ = l
	if m.Low != nil {
		l = m.Low.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.High != nil {
		l = m.High.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IPv4Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Addr != 0 {
		n += 5
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	return n
}

func (m *IPv6Prefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	return n
}

func (m *IPPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	return n
}

func (m *IPSubnet) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		n += m.Subnet.Size()
	}
	return n
}

func (m *IPSubnet_IPv4Subnet) Size() (n int) {
	var l int
	_ = l
	if m.IPv4Subnet != nil {
		l = m.IPv4Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPSubnet_IPv6Subnet) Size() (n int) {
	var l int
	_ = l
	if m.IPv6Subnet != nil {
		l = m.IPv6Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		n += m.Range.Size()
	}
	return n
}

func (m *AddressRange_IPv4Range) Size() (n int) {
	var l int
	_ = l
	if m.IPv4Range != nil {
		l = m.IPv4Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange_IPv6Range) Size() (n int) {
	var l int
	_ = l
	if m.IPv6Range != nil {
		l = m.IPv6Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		n += m.Address.Size()
	}
	return n
}

func (m *Address_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address_Range) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortRange) Size() (n int) {
	var l int
	_ = l
	if m.PortLow != 0 {
		n += 1 + sovTypes(uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		n += 1 + sovTypes(uint64(m.PortHigh))
	}
	return n
}

func (m *RuleL3Match) Size() (n int) {
	var l int
	_ = l
	if m.Protomatch != nil {
		n += m.Protomatch.Size()
	}
	if m.Srcmatch != nil {
		n += m.Srcmatch.Size()
	}
	if m.Dstmatch != nil {
		n += m.Dstmatch.Size()
	}
	return n
}

func (m *RuleL3Match_ProtoNum) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ProtoNum))
	return n
}
func (m *RuleL3Match_ProtoWildcard) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ProtoWildcard))
	return n
}
func (m *RuleL3Match_SrcPrefix) Size() (n int) {
	var l int
	_ = l
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_SrcRange) Size() (n int) {
	var l int
	_ = l
	if m.SrcRange != nil {
		l = m.SrcRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_SrcTag) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.SrcTag))
	return n
}
func (m *RuleL3Match_DstPrefix) Size() (n int) {
	var l int
	_ = l
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_DstRange) Size() (n int) {
	var l int
	_ = l
	if m.DstRange != nil {
		l = m.DstRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_DstTag) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.DstTag))
	return n
}
func (m *PortMatch) Size() (n int) {
	var l int
	_ = l
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ICMPMatch) Size() (n int) {
	var l int
	_ = l
	if m.Typematch != nil {
		n += m.Typematch.Size()
	}
	if m.Codematch != nil {
		n += m.Codematch.Size()
	}
	return n
}

func (m *ICMPMatch_TypeNum) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.TypeNum))
	return n
}
func (m *ICMPMatch_TypeWildcard) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.TypeWildcard))
	return n
}
func (m *ICMPMatch_CodeNum) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.CodeNum))
	return n
}
func (m *ICMPMatch_CodeWildcard) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.CodeWildcard))
	return n
}
func (m *RuleL4Match) Size() (n int) {
	var l int
	_ = l
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	return n
}

func (m *RuleL4Match_Ports) Size() (n int) {
	var l int
	_ = l
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL4Match_TypeCode) Size() (n int) {
	var l int
	_ = l
	if m.TypeCode != nil {
		l = m.TypeCode.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleMatch) Size() (n int) {
	var l int
	_ = l
	if m.L3Match != nil {
		l = m.L3Match.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.L4Match != nil {
		l = m.L4Match.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *QinQTag) Size() (n int) {
	var l int
	_ = l
	if m.CTag != 0 {
		n += 1 + sovTypes(uint64(m.CTag))
	}
	if m.STag != 0 {
		n += 1 + sovTypes(uint64(m.STag))
	}
	return n
}

func (m *EncapVal) Size() (n int) {
	var l int
	_ = l
	if m.Val != nil {
		n += m.Val.Size()
	}
	return n
}

func (m *EncapVal_VlanId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VlanId))
	return n
}
func (m *EncapVal_MPLSTag) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.MPLSTag))
	return n
}
func (m *EncapVal_Vnid) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Vnid))
	return n
}
func (m *EncapVal_QinQTag) Size() (n int) {
	var l int
	_ = l
	if m.QinQTag != nil {
		l = m.QinQTag.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Encap) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BatchCtxt) Size() (n int) {
	var l int
	_ = l
	if m.BatchCookie != 0 {
		n += 1 + sovTypes(uint64(m.BatchCookie))
	}
	return n
}

func (m *MACFlowKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SrcMAC != 0 {
		n += 1 + sovTypes(uint64(m.SrcMAC))
	}
	if m.DstMAC != 0 {
		n += 1 + sovTypes(uint64(m.DstMAC))
	}
	if m.EtherType != 0 {
		n += 1 + sovTypes(uint64(m.EtherType))
	}
	return n
}

func (m *FlowL4Info) Size() (n int) {
	var l int
	_ = l
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	return n
}

func (m *FlowL4Info_TcpUdpInfo) Size() (n int) {
	var l int
	_ = l
	if m.TcpUdpInfo != nil {
		l = m.TcpUdpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowL4Info_IcmpInfo) Size() (n int) {
	var l int
	_ = l
	if m.IcmpInfo != nil {
		l = m.IcmpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowL4Info_TCPUDPInfo) Size() (n int) {
	var l int
	_ = l
	if m.SrcPort != 0 {
		n += 1 + sovTypes(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovTypes(uint64(m.DstPort))
	}
	return n
}

func (m *FlowL4Info_ICMPInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	return n
}

func (m *IPFlowKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SrcIP != nil {
		l = m.SrcIP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstIP != nil {
		l = m.DstIP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IPProtocol != 0 {
		n += 1 + sovTypes(uint64(m.IPProtocol))
	}
	if m.L4Info != nil {
		l = m.L4Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FlowKey) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		n += m.Key.Size()
	}
	return n
}

func (m *FlowKey_IPFlowKey) Size() (n int) {
	var l int
	_ = l
	if m.IPFlowKey != nil {
		l = m.IPFlowKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowKey_MACFlowKey) Size() (n int) {
	var l int
	_ = l
	if m.MACFlowKey != nil {
		l = m.MACFlowKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CommandMessage) Size() (n int) {
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovTypes(uint64(m.Command))
	}
	if m.CommandMsg != nil {
		l = m.CommandMsg.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConfigMessage) Size() (n int) {
	var l int
	_ = l
	if m.ConfigOp != 0 {
		n += 1 + sovTypes(uint64(m.ConfigOp))
	}
	if m.ConfigMsg != nil {
		l = m.ConfigMsg.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ServiceRequestMessage) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *ServiceRequestMessage_Command) Size() (n int) {
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServiceRequestMessage_Config) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServiceResponseMessage) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTypes(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Af", wireType)
			}
			m.Af = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Af |= (IPAF(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Addr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.V4OrV6 = &IPAddress_V4Addr{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.V4OrV6 = &IPAddress_V6Addr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Low == nil {
				m.Low = &IPAddress{}
			}
			if err := m.Low.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.High == nil {
				m.High = &IPAddress{}
			}
			if err := m.High.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4Prefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4Prefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4Prefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Prefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Prefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Prefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &IPAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_IPv4Subnet{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_IPv6Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_IPv4Range{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_IPv6Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortLow", wireType)
			}
			m.PortLow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortLow |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortHigh", wireType)
			}
			m.PortHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortHigh |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleL3Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleL3Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleL3Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protomatch = &RuleL3Match_ProtoNum{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WildcardMatch(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protomatch = &RuleL3Match_ProtoWildcard{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Srcmatch = &RuleL3Match_SrcPrefix{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Srcmatch = &RuleL3Match_SrcRange{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Srcmatch = &RuleL3Match_SrcTag{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dstmatch = &RuleL3Match_DstPrefix{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dstmatch = &RuleL3Match_DstRange{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dstmatch = &RuleL3Match_DstTag{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Typematch = &ICMPMatch_TypeNum{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WildcardMatch(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Typematch = &ICMPMatch_TypeWildcard{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Codematch = &ICMPMatch_CodeNum{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WildcardMatch(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Codematch = &ICMPMatch_CodeWildcard{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleL4Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleL4Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleL4Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_Ports{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_TypeCode{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L3Match == nil {
				m.L3Match = &RuleL3Match{}
			}
			if err := m.L3Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4Match == nil {
				m.L4Match = &RuleL4Match{}
			}
			if err := m.L4Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QinQTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QinQTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QinQTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTag", wireType)
			}
			m.CTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field STag", wireType)
			}
			m.STag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.STag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapVal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapVal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapVal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_VlanId{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPLSTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_MPLSTag{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_Vnid{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinQTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QinQTag{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Val = &EncapVal_QinQTag{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Encap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Encap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Encap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EncapType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &EncapVal{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCtxt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCtxt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCtxt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCookie", wireType)
			}
			m.BatchCookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchCookie |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MACFlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MACFlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MACFlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet[:0], dAtA[iNdEx:postIndex]...)
			if m.Subnet == nil {
				m.Subnet = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			m.SrcMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMAC |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			m.DstMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMAC |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			m.EtherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtherType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowL4Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowL4Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUdpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowL4Info_TCPUDPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &FlowL4Info_TcpUdpInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowL4Info_ICMPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &FlowL4Info_IcmpInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info_TCPUDPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPUDPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPUDPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info_ICMPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPFlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPFlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPFlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIP == nil {
				m.SrcIP = &IPAddress{}
			}
			if err := m.SrcIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIP == nil {
				m.DstIP = &IPAddress{}
			}
			if err := m.DstIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProtocol", wireType)
			}
			m.IPProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProtocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4Info == nil {
				m.L4Info = &FlowL4Info{}
			}
			if err := m.L4Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPFlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPFlowKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &FlowKey_IPFlowKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACFlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MACFlowKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &FlowKey_MACFlowKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= (Command(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommandMsg == nil {
				m.CommandMsg = &google_protobuf1.Any{}
			}
			if err := m.CommandMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOp", wireType)
			}
			m.ConfigOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigOp |= (ServiceRequestOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMsg == nil {
				m.ConfigMsg = &google_protobuf1.Any{}
			}
			if err := m.ConfigMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRequestMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRequestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRequestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ServiceRequestMessage_Command{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ServiceRequestMessage_Config{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &google_protobuf1.Any{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 2227 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xdf, 0x6e, 0xdb, 0xc8,
	0xf5, 0x36, 0x29, 0xc9, 0x92, 0x8e, 0xff, 0x84, 0x9e, 0x38, 0x5e, 0xc7, 0xd8, 0x75, 0x02, 0x62,
	0x37, 0xc8, 0x4f, 0xbf, 0xc6, 0xf1, 0x1f, 0xc5, 0x5d, 0x04, 0x6d, 0x51, 0x8a, 0xa4, 0x65, 0x62,
	0x25, 0x8a, 0x19, 0x52, 0x4e, 0xdc, 0x1b, 0x41, 0x91, 0x68, 0x45, 0x58, 0x59, 0x54, 0x48, 0xda,
	0x89, 0x83, 0x5e, 0xb4, 0x97, 0x45, 0x1f, 0xa0, 0x97, 0x7d, 0x91, 0x3e, 0x40, 0x2f, 0x7b, 0xb3,
	0xe8, 0x5d, 0x5a, 0xe4, 0x11, 0xf2, 0x00, 0x45, 0x71, 0x66, 0x86, 0x14, 0x25, 0xdb, 0x69, 0x7b,
	0x37, 0xe7, 0x3b, 0xdf, 0x7c, 0xe7, 0xcc, 0x99, 0x33, 0x33, 0x24, 0x2c, 0xc5, 0x57, 0x13, 0x3f,
	0xda, 0x99, 0x84, 0x41, 0x1c, 0x90, 0x02, 0x33, 0xb6, 0x60, 0x10, 0x0c, 0x02, 0x0e, 0x6d, 0xdd,
	0x1f, 0x04, 0xc1, 0x60, 0xe4, 0x3f, 0x65, 0xd6, 0xeb, 0x8b, 0xb3, 0xa7, 0xdd, 0xf1, 0x15, 0x77,
	0xa9, 0x45, 0x28, 0x98, 0xe7, 0x93, 0xf8, 0x4a, 0xfd, 0x2d, 0x94, 0x2d, 0x47, 0xeb, 0xf7, 0x43,
	0x3f, 0x8a, 0xc8, 0x53, 0x90, 0xb5, 0xb3, 0x4d, 0xe9, 0xa1, 0xf4, 0x78, 0x75, 0x7f, 0x69, 0x87,
	0xab, 0x5b, 0x8e, 0x76, 0x54, 0x23, 0x9f, 0x3f, 0x3e, 0x58, 0x3d, 0xf7, 0xe3, 0xee, 0xf3, 0xf3,
	0xee, 0xb8, 0xdf, 0x8d, 0x83, 0xf0, 0x8a, 0xca, 0xda, 0x19, 0xd9, 0x84, 0xc5, 0x93, 0x2a, 0xce,
	0xde, 0x94, 0x1f, 0x4a, 0x8f, 0x8b, 0xc7, 0x0b, 0x54, 0xd8, 0xcc, 0x73, 0xc8, 0x3c, 0xb9, 0x87,
	0xd2, 0xe3, 0x65, 0xe6, 0x61, 0x76, 0x0d, 0xa0, 0x74, 0x59, 0xed, 0x04, 0x61, 0xe7, 0xf2, 0x50,
	0x75, 0xa1, 0x68, 0x39, 0xb4, 0x3b, 0x1e, 0xf8, 0x44, 0x85, 0x5c, 0x23, 0x78, 0xc7, 0x82, 0x2f,
	0xed, 0x2b, 0xd3, 0xe0, 0x3c, 0x35, 0x8a, 0x4e, 0xf2, 0x2d, 0xe4, 0x8f, 0x87, 0x83, 0x37, 0x2c,
	0xd8, 0x4d, 0x24, 0xe6, 0x55, 0xeb, 0x00, 0x96, 0x73, 0x59, 0x75, 0x42, 0xff, 0x6c, 0xf8, 0x9e,
	0x10, 0xc8, 0xb3, 0x34, 0x50, 0xb8, 0x48, 0xd9, 0x98, 0x7c, 0x07, 0xb9, 0x86, 0x3f, 0x66, 0x32,
	0x2b, 0xb5, 0xbb, 0x9f, 0x3f, 0x3e, 0xb8, 0xc3, 0xd6, 0x16, 0x62, 0x22, 0xbf, 0xdc, 0x7d, 0x72,
	0xb0, 0x4f, 0xd1, 0xaf, 0x1e, 0x33, 0xa1, 0xc3, 0x1b, 0x84, 0x96, 0x85, 0xd0, 0xa3, 0xac, 0xd0,
	0xfa, 0xe7, 0x8f, 0x0f, 0x94, 0x19, 0xa1, 0xbd, 0xfd, 0xef, 0xb9, 0xd2, 0x2b, 0x28, 0x59, 0x8e,
	0xd0, 0xf9, 0x36, 0xa3, 0x73, 0xe3, 0x22, 0xfe, 0x27, 0xe5, 0x0f, 0xa8, 0xec, 0x5e, 0xbc, 0x1e,
	0xfb, 0x31, 0xd9, 0xe3, 0x0b, 0xe7, 0x96, 0xd0, 0xbf, 0x93, 0xea, 0xf3, 0xf0, 0xc7, 0x0b, 0x34,
	0x43, 0x12, 0x53, 0x0e, 0xc5, 0x14, 0xf9, 0x4b, 0x53, 0x04, 0xa9, 0x56, 0x82, 0xc5, 0x88, 0x8d,
	0xd4, 0x77, 0xb0, 0x9c, 0x24, 0xcd, 0xb6, 0x70, 0x07, 0x7b, 0xe9, 0xb2, 0xca, 0x0c, 0x11, 0x7e,
	0x35, 0xd5, 0x62, 0xe8, 0xf1, 0x02, 0x9d, 0x52, 0x04, 0xff, 0x90, 0xf3, 0xe5, 0x2f, 0xf0, 0x39,
	0xa5, 0x56, 0x84, 0x02, 0x5b, 0xbf, 0x3a, 0x82, 0x62, 0xd2, 0xb2, 0xff, 0x07, 0x8b, 0x3c, 0xcb,
	0x6b, 0xeb, 0xe5, 0xe9, 0x62, 0xe3, 0x89, 0xc2, 0xff, 0x3f, 0x14, 0xb2, 0xa1, 0xee, 0x0a, 0x66,
	0x76, 0x09, 0xc7, 0x0b, 0x94, 0x73, 0x6a, 0x65, 0x28, 0x76, 0xb9, 0x43, 0x7d, 0x0b, 0x65, 0x27,
	0x08, 0x63, 0x9e, 0xf3, 0x2e, 0x14, 0xd1, 0x48, 0x5a, 0x75, 0xa5, 0xb6, 0xf1, 0xf9, 0xe3, 0x03,
	0x32, 0xdd, 0x9b, 0xe7, 0xbb, 0x4f, 0x0e, 0x9f, 0x3d, 0x3b, 0x78, 0x46, 0x13, 0x1a, 0xd9, 0x87,
	0x12, 0x0e, 0xd3, 0xc6, 0xbd, 0x7d, 0x4a, 0xca, 0x53, 0xff, 0x98, 0x83, 0x25, 0x7a, 0x31, 0xf2,
	0x1b, 0x07, 0xcd, 0x6e, 0xdc, 0x7b, 0x43, 0xbe, 0x86, 0x92, 0x83, 0xe7, 0xd6, 0xbe, 0x38, 0xe7,
	0x61, 0x8f, 0x17, 0x68, 0x8a, 0x90, 0x5f, 0xc0, 0x0a, 0x1b, 0xbf, 0x1c, 0x8e, 0xfa, 0xbd, 0x6e,
	0xd8, 0x67, 0x61, 0x56, 0xf7, 0xd7, 0xc5, 0x02, 0x13, 0x98, 0x49, 0x1d, 0x2f, 0xd0, 0x59, 0x32,
	0x79, 0x0a, 0x65, 0x37, 0xec, 0x89, 0x22, 0xe6, 0x6e, 0xee, 0x00, 0x89, 0x4e, 0x39, 0x64, 0x0f,
	0x4a, 0x6e, 0xd8, 0xe3, 0xa5, 0xcc, 0xdf, 0x5e, 0x4a, 0x89, 0xa6, 0x34, 0xbc, 0x0d, 0xdc, 0xb0,
	0xe7, 0x75, 0x07, 0x9b, 0x05, 0x96, 0xbd, 0x44, 0x85, 0x8d, 0xd1, 0x8d, 0x28, 0x16, 0xd1, 0x17,
	0x6f, 0x8e, 0x2e, 0xd3, 0x29, 0x07, 0xa3, 0x1b, 0x11, 0xdf, 0x8c, 0xcd, 0xe2, 0xed, 0xd1, 0x65,
	0x9a, 0xd2, 0x30, 0xba, 0x11, 0xc5, 0x18, 0xbd, 0xc4, 0xa2, 0xcb, 0x54, 0xd8, 0xb5, 0x65, 0x00,
	0x76, 0x1f, 0x9e, 0x63, 0x69, 0xf0, 0x66, 0x8a, 0xc2, 0x5e, 0x3a, 0xee, 0x47, 0x31, 0x1b, 0xab,
	0xef, 0x78, 0x03, 0xf0, 0xad, 0xa8, 0xc2, 0x32, 0x96, 0x22, 0x69, 0x88, 0xb9, 0x63, 0x9c, 0xe2,
	0x74, 0x86, 0x85, 0xb3, 0x70, 0x09, 0xe9, 0x2c, 0xf9, 0xb6, 0x59, 0x59, 0x96, 0xfa, 0x93, 0x04,
	0x65, 0x4b, 0x6f, 0x3a, 0x3c, 0xf2, 0x16, 0x14, 0xbd, 0xab, 0x89, 0x9f, 0xed, 0x81, 0x04, 0x20,
	0xcf, 0x61, 0x19, 0x87, 0xff, 0x65, 0x07, 0xcc, 0x70, 0x51, 0x57, 0x0f, 0xfa, 0x4c, 0x37, 0x27,
	0x76, 0x27, 0x01, 0x50, 0x17, 0x87, 0xa9, 0x6e, 0xfe, 0x0b, 0xba, 0x12, 0x9d, 0xe1, 0xd6, 0x96,
	0xa0, 0x8c, 0x34, 0x5e, 0xcf, 0x25, 0x28, 0xf7, 0x82, 0x3e, 0x37, 0xd4, 0xb7, 0xa2, 0xbb, 0xab,
	0x7c, 0x61, 0x8f, 0xa1, 0x80, 0x6b, 0x8e, 0x6e, 0xa8, 0x65, 0x92, 0x31, 0x27, 0x90, 0x1d, 0x28,
	0x61, 0xea, 0x18, 0x66, 0xfe, 0x11, 0x48, 0xca, 0x84, 0x27, 0x23, 0xe1, 0xe0, 0x5d, 0x35, 0xaa,
	0x0e, 0xc7, 0x67, 0x81, 0x3a, 0x80, 0x32, 0x86, 0xe4, 0x01, 0x7f, 0x06, 0x45, 0x71, 0xb2, 0x44,
	0x48, 0x22, 0x54, 0x32, 0x67, 0x8e, 0x26, 0x14, 0xc6, 0xe6, 0x99, 0x8a, 0x98, 0x33, 0xec, 0x6a,
	0xc2, 0xe6, 0x03, 0xf5, 0x14, 0x8a, 0x2f, 0x86, 0xe3, 0x17, 0xd8, 0xdb, 0x8f, 0x20, 0xcf, 0x7a,
	0x9e, 0x5f, 0x14, 0x37, 0xbd, 0xa1, 0xcc, 0x8f, 0xbc, 0x08, 0x79, 0xf2, 0xed, 0x3c, 0xf4, 0xab,
	0x7f, 0x90, 0xa0, 0x64, 0x8e, 0x7b, 0xdd, 0xc9, 0x49, 0x77, 0xc4, 0x1e, 0xd8, 0x51, 0x77, 0x6c,
	0xf5, 0xd3, 0x66, 0x10, 0x36, 0xee, 0x67, 0xd3, 0x69, 0xb8, 0xa9, 0x22, 0xf6, 0x89, 0x00, 0xc8,
	0x3a, 0xe4, 0x4f, 0xc6, 0xc3, 0xbe, 0xd8, 0xe8, 0x05, 0xca, 0x2c, 0x52, 0x49, 0x73, 0x16, 0x07,
	0x3a, 0xb9, 0x86, 0x05, 0x8a, 0x0a, 0x62, 0x58, 0x2b, 0x40, 0xee, 0xb2, 0x3b, 0x52, 0x3d, 0x28,
	0xb0, 0x54, 0xf0, 0x39, 0x43, 0xae, 0xf8, 0x6a, 0x48, 0xb6, 0x83, 0xf9, 0x70, 0x1b, 0x28, 0xf3,
	0x92, 0xef, 0xa0, 0x70, 0xd9, 0x1d, 0x5d, 0xf8, 0x73, 0x4f, 0x4c, 0xb2, 0x1a, 0xca, 0xbd, 0xea,
	0x13, 0x28, 0xd7, 0xb0, 0x8a, 0x7a, 0xfc, 0x3e, 0x26, 0x0f, 0x61, 0x89, 0x1b, 0x41, 0xf0, 0xe3,
	0x90, 0x07, 0xc8, 0xd3, 0x2c, 0xa4, 0x86, 0x00, 0x4d, 0x4d, 0x3f, 0x1a, 0x05, 0xef, 0x7e, 0xf0,
	0xaf, 0xc8, 0x06, 0x2c, 0x66, 0x9e, 0xbe, 0x65, 0x2a, 0x2c, 0x86, 0x87, 0xbd, 0xa6, 0xa6, 0xb3,
	0xe0, 0x79, 0x2a, 0x2c, 0xc4, 0x8d, 0x28, 0x46, 0x3c, 0xc7, 0x71, 0x6e, 0x91, 0xaf, 0xa1, 0x6c,
	0xc6, 0x6f, 0xfc, 0x10, 0xd3, 0x67, 0xf5, 0x58, 0xa1, 0x53, 0x40, 0xfd, 0x93, 0x0c, 0x80, 0x11,
	0x1b, 0x55, 0x6b, 0x7c, 0x16, 0x90, 0x5f, 0x01, 0x78, 0xbd, 0x49, 0xbb, 0x3f, 0x41, 0x4b, 0x74,
	0xd3, 0xd7, 0x62, 0x75, 0x53, 0xda, 0x8e, 0xa7, 0x3b, 0x6d, 0xc3, 0xc1, 0x21, 0xbe, 0xa6, 0xd3,
	0x19, 0xe4, 0x7b, 0x28, 0x59, 0xbd, 0x73, 0x3e, 0x9b, 0xd7, 0x66, 0xeb, 0xfa, 0x6c, 0x6c, 0x6e,
	0x31, 0x37, 0x65, 0x6f, 0xfd, 0x1a, 0x60, 0xaa, 0x4a, 0x36, 0xa1, 0x28, 0x2e, 0x1c, 0xde, 0x0f,
	0x34, 0x31, 0xd1, 0x23, 0x2e, 0x15, 0xde, 0x0e, 0x34, 0x31, 0xb7, 0x6a, 0x50, 0x4a, 0x94, 0xf1,
	0xeb, 0xc6, 0x4b, 0xb6, 0x71, 0x85, 0xb2, 0x31, 0x62, 0xe9, 0x49, 0x5b, 0xa1, 0x6c, 0x4c, 0x56,
	0x41, 0xb6, 0x44, 0xfb, 0x50, 0xd9, 0xea, 0xe3, 0x3b, 0x39, 0xaa, 0x76, 0xd8, 0x11, 0xfb, 0x0b,
	0xde, 0x56, 0x4e, 0xb2, 0x1b, 0xeb, 0x50, 0x38, 0x71, 0x74, 0xd1, 0x9e, 0xcb, 0x94, 0x1b, 0xe4,
	0x11, 0x14, 0xdc, 0xb0, 0x67, 0x39, 0xb7, 0x7e, 0xc2, 0x71, 0x37, 0xf2, 0x8c, 0x28, 0xb6, 0x1c,
	0xf1, 0x20, 0xdd, 0xc0, 0x63, 0x6e, 0xb2, 0x8d, 0xdf, 0x2f, 0xec, 0x3d, 0xeb, 0x05, 0x23, 0xb1,
	0x59, 0x19, 0x04, 0x3f, 0x0f, 0x78, 0x0d, 0xd9, 0xc3, 0xb3, 0xb4, 0xbf, 0x76, 0xad, 0xb8, 0x54,
	0x10, 0xd4, 0x77, 0x50, 0x4c, 0x72, 0xdf, 0xcd, 0x2c, 0xe4, 0xda, 0x77, 0x9a, 0xc0, 0xf9, 0xa7,
	0x49, 0x32, 0xe3, 0x20, 0xdb, 0x89, 0x62, 0x71, 0x49, 0xac, 0xa9, 0x03, 0xf7, 0x7e, 0x6a, 0xe1,
	0x51, 0xfa, 0xd1, 0xbf, 0x52, 0x27, 0xb0, 0xaa, 0x07, 0xe7, 0x78, 0xd8, 0x9b, 0x7e, 0x14, 0x75,
	0x07, 0x3e, 0x79, 0x8c, 0x37, 0x32, 0x43, 0xc4, 0xb1, 0x4a, 0xce, 0xa3, 0x40, 0x69, 0xe2, 0x26,
	0x55, 0x80, 0x64, 0x6e, 0x34, 0x10, 0x71, 0xd7, 0x77, 0xf8, 0x77, 0xff, 0x4e, 0xf2, 0xdd, 0xbf,
	0xa3, 0x8d, 0xaf, 0x68, 0x86, 0xa7, 0xbe, 0x87, 0x15, 0x3d, 0x18, 0x9f, 0x0d, 0x07, 0x49, 0xc0,
	0x03, 0x28, 0x71, 0xa0, 0x35, 0x11, 0x11, 0xbf, 0x12, 0x11, 0x5d, 0x3f, 0xbc, 0x1c, 0xf6, 0x7c,
	0xea, 0xbf, 0xbd, 0xf0, 0xa3, 0xb8, 0x35, 0xa1, 0x29, 0x91, 0xec, 0x43, 0x59, 0xa8, 0xfc, 0x87,
	0xd0, 0x53, 0x9a, 0xfa, 0x67, 0x09, 0xee, 0xcd, 0x4a, 0x26, 0x29, 0x6c, 0x42, 0xf1, 0xc4, 0x0f,
	0xa3, 0x61, 0x30, 0x66, 0x19, 0xe4, 0x68, 0x62, 0x92, 0xbd, 0x69, 0x35, 0x78, 0x94, 0x7b, 0xb3,
	0xd5, 0x10, 0x0a, 0x78, 0x49, 0x25, 0x65, 0xd9, 0x81, 0x45, 0x1e, 0x53, 0xf4, 0xcf, 0x7a, 0x3a,
	0x23, 0xb3, 0x6a, 0xbc, 0x32, 0x39, 0x80, 0x5d, 0x1c, 0xf2, 0x74, 0xd4, 0x0f, 0xb0, 0x91, 0x26,
	0x18, 0x4d, 0x82, 0x71, 0xe4, 0x27, 0x19, 0xee, 0x40, 0x59, 0x9b, 0x0c, 0xdd, 0xb8, 0x1b, 0x5f,
	0x44, 0x73, 0xd7, 0x5d, 0x8a, 0xd3, 0x29, 0x85, 0xec, 0x42, 0x29, 0x91, 0xf8, 0x62, 0x79, 0x52,
	0x56, 0xe5, 0x5f, 0x52, 0x26, 0x04, 0x59, 0x83, 0x15, 0xcd, 0xb1, 0x3a, 0xae, 0xa7, 0x79, 0x6d,
	0xb7, 0xd3, 0xfa, 0x41, 0x59, 0x20, 0x04, 0x56, 0x33, 0x90, 0x49, 0xa9, 0x22, 0x91, 0x2d, 0xd8,
	0xc8, 0x60, 0x96, 0x7d, 0xa2, 0x35, 0x2c, 0xa3, 0xa3, 0xd1, 0xba, 0x22, 0x93, 0x6f, 0xe0, 0x7e,
	0x96, 0xff, 0xca, 0x72, 0x3d, 0xb7, 0xa3, 0x35, 0xa8, 0xa9, 0x19, 0xa7, 0x4a, 0x8e, 0xdc, 0x87,
	0x7b, 0xd9, 0x08, 0x6d, 0xaf, 0xd3, 0x3a, 0xea, 0x34, 0xcd, 0xa6, 0x92, 0x27, 0x9b, 0xb0, 0x9e,
	0x71, 0xd9, 0x2d, 0xaf, 0x73, 0xd4, 0x6a, 0xdb, 0x86, 0x52, 0x20, 0xdb, 0xb0, 0x75, 0x7d, 0x12,
	0x35, 0xdd, 0x56, 0x9b, 0xea, 0xa6, 0xb2, 0x48, 0xd6, 0x41, 0xc9, 0xf8, 0xa9, 0xe9, 0xd1, 0x53,
	0xa5, 0x48, 0xbe, 0x85, 0x87, 0xd9, 0x59, 0x8e, 0x49, 0x35, 0xcf, 0x6a, 0xd9, 0x4c, 0x59, 0x6b,
	0x34, 0x5a, 0x2f, 0x4d, 0x43, 0x29, 0x55, 0x7e, 0x0e, 0x79, 0xfc, 0xdf, 0x24, 0xab, 0x78, 0xac,
	0x3b, 0xda, 0x51, 0xc7, 0x6e, 0xd9, 0xa6, 0xb2, 0x30, 0xb5, 0x2d, 0xdb, 0xf4, 0x14, 0x89, 0xdc,
	0x81, 0xa5, 0xa9, 0x7d, 0xa8, 0xc8, 0x95, 0xa7, 0xb0, 0x32, 0xf3, 0x31, 0x82, 0x33, 0x9a, 0x9a,
	0xa7, 0x1f, 0x4f, 0x15, 0xca, 0xdc, 0xd6, 0xec, 0x53, 0xe5, 0x77, 0x72, 0xa5, 0x0e, 0x45, 0x7c,
	0xbe, 0x8d, 0x61, 0x88, 0x75, 0xa6, 0xed, 0x86, 0xd9, 0x31, 0x2c, 0x9a, 0xb0, 0xd7, 0x41, 0x49,
	0x21, 0xcb, 0xae, 0x53, 0xd3, 0x75, 0x15, 0x89, 0xdc, 0x85, 0x3b, 0x29, 0x6a, 0x72, 0x50, 0xae,
	0x7c, 0x80, 0x72, 0xfa, 0xd8, 0x21, 0xc3, 0xb4, 0x75, 0xcd, 0xe9, 0x78, 0xa7, 0x8e, 0x99, 0x11,
	0xcb, 0x80, 0x46, 0xcb, 0xdb, 0x7b, 0xc1, 0xc5, 0x32, 0xe8, 0x0b, 0xcb, 0x7e, 0xa1, 0xc8, 0xe4,
	0x2b, 0xb8, 0x9b, 0x01, 0xf1, 0xd1, 0x0e, 0xda, 0x86, 0xa3, 0xe4, 0xe6, 0x34, 0x4e, 0x5e, 0x35,
	0x34, 0x5b, 0xc9, 0x57, 0x7e, 0x92, 0xa0, 0xd8, 0x18, 0x9e, 0xb1, 0xd0, 0x6b, 0xb0, 0xd2, 0xb0,
	0x8e, 0x66, 0x02, 0x67, 0xa1, 0xe3, 0x96, 0x8b, 0x85, 0xdb, 0x00, 0x32, 0x03, 0x75, 0x9a, 0xf5,
	0xa6, 0xa7, 0xc8, 0xe4, 0x1e, 0xac, 0xa5, 0x78, 0xab, 0x55, 0xe3, 0x70, 0x0e, 0xbb, 0x20, 0x85,
	0x2d, 0xbb, 0xa6, 0xd9, 0x06, 0xf7, 0xe4, 0xb1, 0xeb, 0x32, 0x1e, 0xcf, 0xa4, 0xb6, 0xd6, 0xe0,
	0xbe, 0xc2, 0x8c, 0x98, 0xa1, 0x79, 0x9a, 0xa3, 0x79, 0xc7, 0xca, 0x22, 0x36, 0x6f, 0x0a, 0x37,
	0x4c, 0x8d, 0xda, 0x4a, 0x11, 0xd7, 0x95, 0x62, 0x7a, 0xcb, 0xf6, 0x68, 0xab, 0xa1, 0x94, 0x2a,
	0x21, 0x10, 0xd7, 0xef, 0x5d, 0x84, 0xc3, 0xf8, 0x0a, 0x37, 0x49, 0xeb, 0xc5, 0x78, 0x0f, 0x7c,
	0x03, 0xf7, 0x5d, 0x53, 0x6f, 0x53, 0xcb, 0x3b, 0xed, 0xb0, 0x7d, 0xd0, 0x74, 0xd1, 0x42, 0x6c,
	0xb5, 0xdb, 0xb0, 0x75, 0xa3, 0x9b, 0x75, 0x97, 0x22, 0xdd, 0x3a, 0xdd, 0x30, 0xed, 0x53, 0x45,
	0xae, 0x8c, 0xa0, 0x6c, 0x77, 0x63, 0x11, 0xea, 0x2e, 0xdc, 0xb1, 0x35, 0x6f, 0x2e, 0xc0, 0x3d,
	0x58, 0xcb, 0x80, 0xd8, 0xc9, 0x96, 0xce, 0xcf, 0x5f, 0x96, 0xab, 0x39, 0x5e, 0xc7, 0x69, 0xd7,
	0x1a, 0x96, 0xce, 0xf7, 0x73, 0xde, 0xe7, 0x9e, 0xe8, 0x4a, 0xae, 0x62, 0xc3, 0x92, 0x78, 0xc9,
	0xc4, 0x4b, 0xbb, 0xaa, 0x19, 0x06, 0x9d, 0x6f, 0x9b, 0x29, 0x26, 0x14, 0x25, 0x4c, 0x62, 0x8a,
	0xba, 0x26, 0x3d, 0xb1, 0x74, 0x53, 0x91, 0x2b, 0x2e, 0x80, 0xd6, 0x3f, 0x1f, 0x8e, 0xf1, 0xea,
	0xf0, 0xf9, 0xd4, 0xa6, 0xc5, 0x93, 0x4c, 0x05, 0x37, 0x80, 0x64, 0x51, 0xd3, 0xd6, 0x6a, 0x0d,
	0x53, 0x91, 0x30, 0xc9, 0x2c, 0x6e, 0x58, 0x2e, 0x73, 0xc8, 0x95, 0xbf, 0x4b, 0xfc, 0xc7, 0xc7,
	0x9d, 0xf8, 0x7e, 0x1f, 0x6b, 0xe2, 0xb4, 0xa8, 0xd7, 0x71, 0x1d, 0xd3, 0x34, 0x12, 0x4d, 0x02,
	0xab, 0x19, 0x70, 0x6f, 0xb7, 0xc9, 0x3b, 0x7b, 0x06, 0xdb, 0x6d, 0x2a, 0x32, 0xf6, 0x62, 0x16,
	0xac, 0x2b, 0xb9, 0x6b, 0x73, 0xeb, 0x4a, 0x7e, 0x0e, 0xdb, 0x7f, 0x56, 0x57, 0x0a, 0x73, 0x58,
	0x75, 0xb7, 0xce, 0x7b, 0x29, 0x83, 0x3d, 0xdb, 0xad, 0x2b, 0xc5, 0xeb, 0x71, 0xeb, 0x4a, 0x09,
	0x4b, 0x91, 0x01, 0xa9, 0xe9, 0x9e, 0x18, 0x4a, 0xb9, 0xf2, 0x0f, 0x29, 0x7d, 0x53, 0xc8, 0x32,
	0x94, 0xf4, 0xa6, 0x91, 0xa9, 0x3a, 0x5a, 0x4d, 0xcd, 0x71, 0x2c, 0xbb, 0xde, 0x31, 0xda, 0x4d,
	0x47, 0x91, 0x30, 0x7b, 0x44, 0x2d, 0xdb, 0xa3, 0x1c, 0x92, 0x31, 0x83, 0x14, 0xd2, 0xb1, 0x9d,
	0x95, 0x1c, 0xb6, 0x18, 0x62, 0x78, 0xd1, 0x99, 0x76, 0xdd, 0xb2, 0x4d, 0x56, 0x52, 0x97, 0x4f,
	0xc9, 0x27, 0x2a, 0x47, 0x8d, 0xd6, 0x4b, 0x0e, 0x15, 0xf0, 0x80, 0x21, 0xe4, 0x7a, 0x2d, 0x3a,
	0x43, 0x5e, 0xc4, 0xd5, 0xb0, 0xb4, 0x34, 0xaf, 0xe3, 0xd4, 0x38, 0x58, 0x4c, 0x14, 0x6c, 0x4d,
	0x6f, 0x70, 0xa8, 0x84, 0x0d, 0x81, 0x10, 0x5b, 0xe4, 0x91, 0xdb, 0xe4, 0x70, 0xb9, 0xf2, 0x7b,
	0x09, 0x94, 0xf9, 0xb7, 0x1b, 0x35, 0x45, 0xcb, 0x74, 0x5a, 0x4e, 0xa6, 0xad, 0x33, 0xa0, 0x4e,
	0x4d, 0xcd, 0x33, 0x79, 0xa3, 0x65, 0x60, 0xc3, 0x6c, 0x98, 0x9e, 0xc9, 0x2f, 0x8a, 0x0c, 0xdc,
	0x76, 0x0c, 0x64, 0xe7, 0xe6, 0x94, 0xf1, 0x7d, 0x51, 0xf2, 0xb5, 0xb5, 0xbf, 0x7e, 0xda, 0x96,
	0xfe, 0xf6, 0x69, 0x5b, 0xfa, 0xe7, 0xa7, 0x6d, 0xe9, 0x37, 0xb9, 0x49, 0x3f, 0x72, 0x16, 0x5e,
	0x2f, 0xb2, 0xb7, 0xef, 0xe0, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x46, 0xf4, 0x98, 0x2e, 0xbd,
	0x14, 0x00, 0x00,
}
