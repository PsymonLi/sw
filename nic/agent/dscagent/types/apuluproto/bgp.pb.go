// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bgp.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// BGP address family identifier
type BGPAfi int32

const (
	BGPAfi_BGP_AFI_NONE  BGPAfi = 0
	BGPAfi_BGP_AFI_IPV4  BGPAfi = 1
	BGPAfi_BGP_AFI_L2VPN BGPAfi = 25
)

var BGPAfi_name = map[int32]string{
	0:  "BGP_AFI_NONE",
	1:  "BGP_AFI_IPV4",
	25: "BGP_AFI_L2VPN",
}
var BGPAfi_value = map[string]int32{
	"BGP_AFI_NONE":  0,
	"BGP_AFI_IPV4":  1,
	"BGP_AFI_L2VPN": 25,
}

func (x BGPAfi) String() string {
	return proto.EnumName(BGPAfi_name, int32(x))
}
func (BGPAfi) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{0} }

// BGP sub-address family identitfier
type BGPSafi int32

const (
	BGPSafi_BGP_SAFI_NONE    BGPSafi = 0
	BGPSafi_BGP_SAFI_UNICAST BGPSafi = 1
	BGPSafi_BGP_SAFI_EVPN    BGPSafi = 70
)

var BGPSafi_name = map[int32]string{
	0:  "BGP_SAFI_NONE",
	1:  "BGP_SAFI_UNICAST",
	70: "BGP_SAFI_EVPN",
}
var BGPSafi_value = map[string]int32{
	"BGP_SAFI_NONE":    0,
	"BGP_SAFI_UNICAST": 1,
	"BGP_SAFI_EVPN":    70,
}

func (x BGPSafi) String() string {
	return proto.EnumName(BGPSafi_name, int32(x))
}
func (BGPSafi) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{1} }

// BGP peer RR client
type BGPPeerRRClient int32

const (
	BGPPeerRRClient_BGP_PEER_RR_NONE   BGPPeerRRClient = 0
	BGPPeerRRClient_BGP_PEER_RR_CLIENT BGPPeerRRClient = 1
)

var BGPPeerRRClient_name = map[int32]string{
	0: "BGP_PEER_RR_NONE",
	1: "BGP_PEER_RR_CLIENT",
}
var BGPPeerRRClient_value = map[string]int32{
	"BGP_PEER_RR_NONE":   0,
	"BGP_PEER_RR_CLIENT": 1,
}

func (x BGPPeerRRClient) String() string {
	return proto.EnumName(BGPPeerRRClient_name, int32(x))
}
func (BGPPeerRRClient) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{2} }

// BGP peer last_state
type BGPPeerState int32

const (
	BGPPeerState_BGP_PEER_STATE_NONE        BGPPeerState = 0
	BGPPeerState_BGP_PEER_STATE_IDLE        BGPPeerState = 1
	BGPPeerState_BGP_PEER_STATE_CONNECT     BGPPeerState = 2
	BGPPeerState_BGP_PEER_STATE_ACTIVE      BGPPeerState = 3
	BGPPeerState_BGP_PEER_STATE_OPENSENT    BGPPeerState = 4
	BGPPeerState_BGP_PEER_STATE_OPENCONFIRM BGPPeerState = 5
	BGPPeerState_BGP_PEER_STATE_ESTABLISHED BGPPeerState = 6
)

var BGPPeerState_name = map[int32]string{
	0: "BGP_PEER_STATE_NONE",
	1: "BGP_PEER_STATE_IDLE",
	2: "BGP_PEER_STATE_CONNECT",
	3: "BGP_PEER_STATE_ACTIVE",
	4: "BGP_PEER_STATE_OPENSENT",
	5: "BGP_PEER_STATE_OPENCONFIRM",
	6: "BGP_PEER_STATE_ESTABLISHED",
}
var BGPPeerState_value = map[string]int32{
	"BGP_PEER_STATE_NONE":        0,
	"BGP_PEER_STATE_IDLE":        1,
	"BGP_PEER_STATE_CONNECT":     2,
	"BGP_PEER_STATE_ACTIVE":      3,
	"BGP_PEER_STATE_OPENSENT":    4,
	"BGP_PEER_STATE_OPENCONFIRM": 5,
	"BGP_PEER_STATE_ESTABLISHED": 6,
}

func (x BGPPeerState) String() string {
	return proto.EnumName(BGPPeerState_name, int32(x))
}
func (BGPPeerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{3} }

type BGPASSize int32

const (
	BGPASSize_BGP_AS_SIZE_NONE       BGPASSize = 0
	BGPASSize_BGP_AS_SIZE_TWO_OCTET  BGPASSize = 1
	BGPASSize_BGP_AS_SIZE_FOUR_OCTET BGPASSize = 2
)

var BGPASSize_name = map[int32]string{
	0: "BGP_AS_SIZE_NONE",
	1: "BGP_AS_SIZE_TWO_OCTET",
	2: "BGP_AS_SIZE_FOUR_OCTET",
}
var BGPASSize_value = map[string]int32{
	"BGP_AS_SIZE_NONE":       0,
	"BGP_AS_SIZE_TWO_OCTET":  1,
	"BGP_AS_SIZE_FOUR_OCTET": 2,
}

func (x BGPASSize) String() string {
	return proto.EnumName(BGPASSize_name, int32(x))
}
func (BGPASSize) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{4} }

type BGPAddrType int32

const (
	BGPAddrType_BGP_ADDR_TYPE_OTHER     BGPAddrType = 0
	BGPAddrType_BGP_ADDR_TYPE_IPV4      BGPAddrType = 1
	BGPAddrType_BGP_ADDR_TYPE_IPV6      BGPAddrType = 2
	BGPAddrType_BGP_ADDR_TYPE_NSAP      BGPAddrType = 3
	BGPAddrType_BGP_ADDR_TYPE_HDLC      BGPAddrType = 4
	BGPAddrType_BGP_ADDR_TYPE_BBN1822   BGPAddrType = 5
	BGPAddrType_BGP_ADDR_TYPE_IEEE802   BGPAddrType = 6
	BGPAddrType_BGP_ADDR_TYPE_E163      BGPAddrType = 7
	BGPAddrType_BGP_ADDR_TYPE_E164      BGPAddrType = 8
	BGPAddrType_BGP_ADDR_TYPE_F69       BGPAddrType = 9
	BGPAddrType_BGP_ADDR_TYPE_X121      BGPAddrType = 10
	BGPAddrType_BGP_ADDR_TYPE_IPX       BGPAddrType = 11
	BGPAddrType_BGP_ADDR_TYPE_APPLETALK BGPAddrType = 12
	BGPAddrType_BGP_ADDR_TYPE_DECNETIV  BGPAddrType = 13
	BGPAddrType_BGP_ADDR_TYPE_BANYANVIN BGPAddrType = 14
	BGPAddrType_BGP_ADDR_TYPE_E164_NSAP BGPAddrType = 15
	BGPAddrType_BGP_ADDR_TYPE_IPV4_TNA  BGPAddrType = 16
	BGPAddrType_BGP_ADDR_TYPE_IPV6_TNA  BGPAddrType = 17
	BGPAddrType_BGP_ADDR_TYPE_NSAP_TNA  BGPAddrType = 18
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV4  BGPAddrType = 19
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV6  BGPAddrType = 20
	BGPAddrType_BGP_ADDR_TYPE_L2VPN     BGPAddrType = 25
)

var BGPAddrType_name = map[int32]string{
	0:  "BGP_ADDR_TYPE_OTHER",
	1:  "BGP_ADDR_TYPE_IPV4",
	2:  "BGP_ADDR_TYPE_IPV6",
	3:  "BGP_ADDR_TYPE_NSAP",
	4:  "BGP_ADDR_TYPE_HDLC",
	5:  "BGP_ADDR_TYPE_BBN1822",
	6:  "BGP_ADDR_TYPE_IEEE802",
	7:  "BGP_ADDR_TYPE_E163",
	8:  "BGP_ADDR_TYPE_E164",
	9:  "BGP_ADDR_TYPE_F69",
	10: "BGP_ADDR_TYPE_X121",
	11: "BGP_ADDR_TYPE_IPX",
	12: "BGP_ADDR_TYPE_APPLETALK",
	13: "BGP_ADDR_TYPE_DECNETIV",
	14: "BGP_ADDR_TYPE_BANYANVIN",
	15: "BGP_ADDR_TYPE_E164_NSAP",
	16: "BGP_ADDR_TYPE_IPV4_TNA",
	17: "BGP_ADDR_TYPE_IPV6_TNA",
	18: "BGP_ADDR_TYPE_NSAP_TNA",
	19: "BGP_ADDR_TYPE_VPN_IPV4",
	20: "BGP_ADDR_TYPE_VPN_IPV6",
	25: "BGP_ADDR_TYPE_L2VPN",
}
var BGPAddrType_value = map[string]int32{
	"BGP_ADDR_TYPE_OTHER":     0,
	"BGP_ADDR_TYPE_IPV4":      1,
	"BGP_ADDR_TYPE_IPV6":      2,
	"BGP_ADDR_TYPE_NSAP":      3,
	"BGP_ADDR_TYPE_HDLC":      4,
	"BGP_ADDR_TYPE_BBN1822":   5,
	"BGP_ADDR_TYPE_IEEE802":   6,
	"BGP_ADDR_TYPE_E163":      7,
	"BGP_ADDR_TYPE_E164":      8,
	"BGP_ADDR_TYPE_F69":       9,
	"BGP_ADDR_TYPE_X121":      10,
	"BGP_ADDR_TYPE_IPX":       11,
	"BGP_ADDR_TYPE_APPLETALK": 12,
	"BGP_ADDR_TYPE_DECNETIV":  13,
	"BGP_ADDR_TYPE_BANYANVIN": 14,
	"BGP_ADDR_TYPE_E164_NSAP": 15,
	"BGP_ADDR_TYPE_IPV4_TNA":  16,
	"BGP_ADDR_TYPE_IPV6_TNA":  17,
	"BGP_ADDR_TYPE_NSAP_TNA":  18,
	"BGP_ADDR_TYPE_VPN_IPV4":  19,
	"BGP_ADDR_TYPE_VPN_IPV6":  20,
	"BGP_ADDR_TYPE_L2VPN":     25,
}

func (x BGPAddrType) String() string {
	return proto.EnumName(BGPAddrType_name, int32(x))
}
func (BGPAddrType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{5} }

type BGPOperStatus int32

const (
	BGPOperStatus_BGP_OPER_STATUS_NONE       BGPOperStatus = 0
	BGPOperStatus_BGP_OPER_STATUS_UP         BGPOperStatus = 1
	BGPOperStatus_BGP_OPER_STATUS_DOWN       BGPOperStatus = 2
	BGPOperStatus_BGP_OPER_STATUS_GOING_UP   BGPOperStatus = 3
	BGPOperStatus_BGP_OPER_STATUS_GOING_DOWN BGPOperStatus = 4
	BGPOperStatus_BGP_OPER_STATUS_ACT_FAILED BGPOperStatus = 5
)

var BGPOperStatus_name = map[int32]string{
	0: "BGP_OPER_STATUS_NONE",
	1: "BGP_OPER_STATUS_UP",
	2: "BGP_OPER_STATUS_DOWN",
	3: "BGP_OPER_STATUS_GOING_UP",
	4: "BGP_OPER_STATUS_GOING_DOWN",
	5: "BGP_OPER_STATUS_ACT_FAILED",
}
var BGPOperStatus_value = map[string]int32{
	"BGP_OPER_STATUS_NONE":       0,
	"BGP_OPER_STATUS_UP":         1,
	"BGP_OPER_STATUS_DOWN":       2,
	"BGP_OPER_STATUS_GOING_UP":   3,
	"BGP_OPER_STATUS_GOING_DOWN": 4,
	"BGP_OPER_STATUS_ACT_FAILED": 5,
}

func (x BGPOperStatus) String() string {
	return proto.EnumName(BGPOperStatus_name, int32(x))
}
func (BGPOperStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{6} }

type BGPClearRouteOptions int32

const (
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE         BGPClearRouteOptions = 0
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_HARD         BGPClearRouteOptions = 1
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_IN   BGPClearRouteOptions = 2
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_OUT  BGPClearRouteOptions = 3
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_BOTH BGPClearRouteOptions = 4
)

var BGPClearRouteOptions_name = map[int32]string{
	0: "BGP_CLEAR_ROUTE_NONE",
	1: "BGP_CLEAR_ROUTE_HARD",
	2: "BGP_CLEAR_ROUTE_REFRESH_IN",
	3: "BGP_CLEAR_ROUTE_REFRESH_OUT",
	4: "BGP_CLEAR_ROUTE_REFRESH_BOTH",
}
var BGPClearRouteOptions_value = map[string]int32{
	"BGP_CLEAR_ROUTE_NONE":         0,
	"BGP_CLEAR_ROUTE_HARD":         1,
	"BGP_CLEAR_ROUTE_REFRESH_IN":   2,
	"BGP_CLEAR_ROUTE_REFRESH_OUT":  3,
	"BGP_CLEAR_ROUTE_REFRESH_BOTH": 4,
}

func (x BGPClearRouteOptions) String() string {
	return proto.EnumName(BGPClearRouteOptions_name, int32(x))
}
func (BGPClearRouteOptions) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{7} }

// NLRI source
type NLRISrc int32

const (
	NLRISrc_NLRI_NONE NLRISrc = 0
	NLRISrc_NLRI_PEER NLRISrc = 1
	NLRISrc_NLRI_AFM  NLRISrc = 2
	NLRISrc_NLRI_SELF NLRISrc = 3
)

var NLRISrc_name = map[int32]string{
	0: "NLRI_NONE",
	1: "NLRI_PEER",
	2: "NLRI_AFM",
	3: "NLRI_SELF",
}
var NLRISrc_value = map[string]int32{
	"NLRI_NONE": 0,
	"NLRI_PEER": 1,
	"NLRI_AFM":  2,
	"NLRI_SELF": 3,
}

func (x NLRISrc) String() string {
	return proto.EnumName(NLRISrc_name, int32(x))
}
func (NLRISrc) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{8} }

// BGP configuration
type BGPSpec struct {
	// unique key/identifier of BGP config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// the local autonomous system number
	LocalASN uint32 `protobuf:"varint,2,opt,name=LocalASN,proto3" json:"LocalASN,omitempty"`
	// router ID for this bgp instance
	RouterId uint32 `protobuf:"fixed32,3,opt,name=RouterId,proto3" json:"RouterId,omitempty"`
	// cluster ID of the local router. router ID will be used as cluster ID
	// if cluster ID is not configured or configured to zero
	ClusterId uint32 `protobuf:"fixed32,4,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
}

func (m *BGPSpec) Reset()                    { *m = BGPSpec{} }
func (m *BGPSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPSpec) ProtoMessage()               {}
func (*BGPSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{0} }

func (m *BGPSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPSpec) GetLocalASN() uint32 {
	if m != nil {
		return m.LocalASN
	}
	return 0
}

func (m *BGPSpec) GetRouterId() uint32 {
	if m != nil {
		return m.RouterId
	}
	return 0
}

func (m *BGPSpec) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

// operational status of BGP
type BGPStatus struct {
	// BGP current oper status
	Status BGPOperStatus `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPOperStatus" json:"Status,omitempty"`
	// The total number of Adj-RIB-Out routes currently allocated
	NumAdjRibOutRoutes uint32 `protobuf:"varint,2,opt,name=NumAdjRibOutRoutes,proto3" json:"NumAdjRibOutRoutes,omitempty"`
	// The peak number of Adj-RIB-Out routes that have been allocated at any one time
	PeakNumAdjRibOutRoutes uint32 `protobuf:"varint,3,opt,name=PeakNumAdjRibOutRoutes,proto3" json:"PeakNumAdjRibOutRoutes,omitempty"`
	// The maximum time remaining until route selection takes place following a restart, in hundredths of a second.
	RemDelayTime uint32 `protobuf:"varint,4,opt,name=RemDelayTime,proto3" json:"RemDelayTime,omitempty"`
	// The table version number of the Loc-RIB
	TableVer uint32 `protobuf:"varint,5,opt,name=TableVer,proto3" json:"TableVer,omitempty"`
}

func (m *BGPStatus) Reset()                    { *m = BGPStatus{} }
func (m *BGPStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPStatus) ProtoMessage()               {}
func (*BGPStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{1} }

func (m *BGPStatus) GetStatus() BGPOperStatus {
	if m != nil {
		return m.Status
	}
	return BGPOperStatus_BGP_OPER_STATUS_NONE
}

func (m *BGPStatus) GetNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.NumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetPeakNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.PeakNumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetRemDelayTime() uint32 {
	if m != nil {
		return m.RemDelayTime
	}
	return 0
}

func (m *BGPStatus) GetTableVer() uint32 {
	if m != nil {
		return m.TableVer
	}
	return 0
}

// BGP object
type BGP struct {
	Spec   *BGPSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGP) Reset()                    { *m = BGP{} }
func (m *BGP) String() string            { return proto.CompactTextString(m) }
func (*BGP) ProtoMessage()               {}
func (*BGP) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{2} }

func (m *BGP) GetSpec() *BGPSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGP) GetStatus() *BGPStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP create and update request
type BGPRequest struct {
	Request *BGPSpec `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPRequest) Reset()                    { *m = BGPRequest{} }
func (m *BGPRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPRequest) ProtoMessage()               {}
func (*BGPRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{3} }

func (m *BGPRequest) GetRequest() *BGPSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP create and update response
type BGPResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPResponse) Reset()                    { *m = BGPResponse{} }
func (m *BGPResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPResponse) ProtoMessage()               {}
func (*BGPResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{4} }

func (m *BGPResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP KeyHandle used in Get/Delete
type BGPKeyHandle struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *BGPKeyHandle) Reset()                    { *m = BGPKeyHandle{} }
func (m *BGPKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPKeyHandle) ProtoMessage()               {}
func (*BGPKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{5} }

func (m *BGPKeyHandle) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// BGP delete request
type BGPDeleteRequest struct {
	Request *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPDeleteRequest) Reset()                    { *m = BGPDeleteRequest{} }
func (m *BGPDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPDeleteRequest) ProtoMessage()               {}
func (*BGPDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{6} }

func (m *BGPDeleteRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP delete response
type BGPDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPDeleteResponse) Reset()                    { *m = BGPDeleteResponse{} }
func (m *BGPDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPDeleteResponse) ProtoMessage()               {}
func (*BGPDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{7} }

func (m *BGPDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP get request
type BGPGetRequest struct {
	Request *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPGetRequest) Reset()                    { *m = BGPGetRequest{} }
func (m *BGPGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPGetRequest) ProtoMessage()               {}
func (*BGPGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{8} }

func (m *BGPGetRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP get response
type BGPGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *BGP      `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *BGPGetResponse) Reset()                    { *m = BGPGetResponse{} }
func (m *BGPGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPGetResponse) ProtoMessage()               {}
func (*BGPGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{9} }

func (m *BGPGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPGetResponse) GetResponse() *BGP {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer configurations
type BGPPeerSpec struct {
	// unique key/identifier of peer
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// peer enable/disable admin state. if peer is not enabled then local router
	// must not initiate connections to the neighbor and must not respond to
	// TCP connections attempts from neighbor
	State AdminState `protobuf:"varint,2,opt,name=State,proto3,enum=types.AdminState" json:"State,omitempty"`
	// BGP local IP address. control plane chooses the local IP address of the
	// session if an all 0 IP address is provided
	LocalAddr *IPAddress `protobuf:"bytes,3,opt,name=LocalAddr" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,4,opt,name=PeerAddr" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// remote 4-byte AS number
	RemoteASN uint32 `protobuf:"varint,5,opt,name=RemoteASN,proto3" json:"RemoteASN,omitempty"`
	// send regular community attributes to neighbor
	SendComm bool `protobuf:"varint,6,opt,name=SendComm,proto3" json:"SendComm,omitempty"`
	// send extended community attributes to neighbor
	SendExtComm bool `protobuf:"varint,7,opt,name=SendExtComm,proto3" json:"SendExtComm,omitempty"`
	// peer is a route reflector client
	RRClient BGPPeerRRClient `protobuf:"varint,8,opt,name=RRClient,proto3,enum=pds.BGPPeerRRClient" json:"RRClient,omitempty"`
	// BGP session connect-retry timer in seconds
	ConnectRetry uint32 `protobuf:"varint,9,opt,name=ConnectRetry,proto3" json:"ConnectRetry,omitempty"`
	// BGP session configured holdtime timer in seconds
	HoldTime uint32 `protobuf:"varint,10,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session configured keepalive timer in seconds
	KeepAlive uint32 `protobuf:"varint,11,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// MD5 authentication
	Password []byte `protobuf:"bytes,12,opt,name=Password,proto3" json:"Password,omitempty"`
	// TTL
	TTL uint32 `protobuf:"varint,13,opt,name=TTL,proto3" json:"TTL,omitempty"`
}

func (m *BGPPeerSpec) Reset()                    { *m = BGPPeerSpec{} }
func (m *BGPPeerSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerSpec) ProtoMessage()               {}
func (*BGPPeerSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{10} }

func (m *BGPPeerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerSpec) GetState() AdminState {
	if m != nil {
		return m.State
	}
	return AdminState_ADMIN_STATE_NONE
}

func (m *BGPPeerSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetRemoteASN() uint32 {
	if m != nil {
		return m.RemoteASN
	}
	return 0
}

func (m *BGPPeerSpec) GetSendComm() bool {
	if m != nil {
		return m.SendComm
	}
	return false
}

func (m *BGPPeerSpec) GetSendExtComm() bool {
	if m != nil {
		return m.SendExtComm
	}
	return false
}

func (m *BGPPeerSpec) GetRRClient() BGPPeerRRClient {
	if m != nil {
		return m.RRClient
	}
	return BGPPeerRRClient_BGP_PEER_RR_NONE
}

func (m *BGPPeerSpec) GetConnectRetry() uint32 {
	if m != nil {
		return m.ConnectRetry
	}
	return 0
}

func (m *BGPPeerSpec) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerSpec) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerSpec) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *BGPPeerSpec) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// BGP peer status
type BGPPeerStatus struct {
	// BGP session status
	Status BGPPeerState `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPPeerState" json:"Status,omitempty"`
	// BGP session previous status
	PrevStatus BGPPeerState `protobuf:"varint,2,opt,name=PrevStatus,proto3,enum=pds.BGPPeerState" json:"PrevStatus,omitempty"`
	// last error received
	LastErrorRcvd []byte `protobuf:"bytes,3,opt,name=LastErrorRcvd,proto3" json:"LastErrorRcvd,omitempty"`
	// Last error sent
	LastErrorSent []byte `protobuf:"bytes,4,opt,name=LastErrorSent,proto3" json:"LastErrorSent,omitempty"`
	// selected local address of the peer
	LocalAddr *IPAddress `protobuf:"bytes,5,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP session holdtime in seconds established with peer
	HoldTime uint32 `protobuf:"varint,6,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session keepalive in seconds established with peer
	KeepAlive uint32 `protobuf:"varint,7,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// BGP The capabilities announced to the peer on the most recent open message sent to the peer.
	CapsSent uint32 `protobuf:"varint,8,opt,name=CapsSent,proto3" json:"CapsSent,omitempty"`
	// BGP The capabilities received on the most recent open message received from the peer.
	CapsRcvd uint32 `protobuf:"varint,9,opt,name=CapsRcvd,proto3" json:"CapsRcvd,omitempty"`
	// BGP The capabilities negotiated for the session with the peer
	CapsNeg uint32 `protobuf:"varint,10,opt,name=CapsNeg,proto3" json:"CapsNeg,omitempty"`
	// BGP The address family of the local address used by the transport connection for the peering session.
	SelLocalAddrType BGPAddrType `protobuf:"varint,11,opt,name=SelLocalAddrType,proto3,enum=pds.BGPAddrType" json:"SelLocalAddrType,omitempty"`
}

func (m *BGPPeerStatus) Reset()                    { *m = BGPPeerStatus{} }
func (m *BGPPeerStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerStatus) ProtoMessage()               {}
func (*BGPPeerStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{11} }

func (m *BGPPeerStatus) GetStatus() BGPPeerState {
	if m != nil {
		return m.Status
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetPrevStatus() BGPPeerState {
	if m != nil {
		return m.PrevStatus
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetLastErrorRcvd() []byte {
	if m != nil {
		return m.LastErrorRcvd
	}
	return nil
}

func (m *BGPPeerStatus) GetLastErrorSent() []byte {
	if m != nil {
		return m.LastErrorSent
	}
	return nil
}

func (m *BGPPeerStatus) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerStatus) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerStatus) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsSent() uint32 {
	if m != nil {
		return m.CapsSent
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsRcvd() uint32 {
	if m != nil {
		return m.CapsRcvd
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsNeg() uint32 {
	if m != nil {
		return m.CapsNeg
	}
	return 0
}

func (m *BGPPeerStatus) GetSelLocalAddrType() BGPAddrType {
	if m != nil {
		return m.SelLocalAddrType
	}
	return BGPAddrType_BGP_ADDR_TYPE_OTHER
}

// BGP peer object
type BGPPeer struct {
	Spec   *BGPPeerSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPPeerStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGPPeer) Reset()                    { *m = BGPPeer{} }
func (m *BGPPeer) String() string            { return proto.CompactTextString(m) }
func (*BGPPeer) ProtoMessage()               {}
func (*BGPPeer) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{12} }

func (m *BGPPeer) GetSpec() *BGPPeerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeer) GetStatus() *BGPPeerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer create and update response
type BGPPeerResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerResponse) Reset()                    { *m = BGPPeerResponse{} }
func (m *BGPPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerResponse) ProtoMessage()               {}
func (*BGPPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{13} }

func (m *BGPPeerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer create and update request
type BGPPeerRequest struct {
	Request []*BGPPeerSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerRequest) Reset()                    { *m = BGPPeerRequest{} }
func (m *BGPPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerRequest) ProtoMessage()               {}
func (*BGPPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{14} }

func (m *BGPPeerRequest) GetRequest() []*BGPPeerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer get response
type BGPPeerGetResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPPeer `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPPeerGetResponse) Reset()                    { *m = BGPPeerGetResponse{} }
func (m *BGPPeerGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerGetResponse) ProtoMessage()               {}
func (*BGPPeerGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{15} }

func (m *BGPPeerGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerGetResponse) GetResponse() []*BGPPeer {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer key parameters
type BGPPeerKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
}

func (m *BGPPeerKey) Reset()                    { *m = BGPPeerKey{} }
func (m *BGPPeerKey) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerKey) ProtoMessage()               {}
func (*BGPPeerKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{16} }

func (m *BGPPeerKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

// BGP peer get and delete key handle
type BGPPeerKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerKeyHandle_Id
	//	*BGPPeerKeyHandle_Key
	IdOrKey isBGPPeerKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *BGPPeerKeyHandle) Reset()                    { *m = BGPPeerKeyHandle{} }
func (m *BGPPeerKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerKeyHandle) ProtoMessage()               {}
func (*BGPPeerKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{17} }

type isBGPPeerKeyHandle_IdOrKey interface {
	isBGPPeerKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerKeyHandle_Key struct {
	Key *BGPPeerKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*BGPPeerKeyHandle_Id) isBGPPeerKeyHandle_IdOrKey()  {}
func (*BGPPeerKeyHandle_Key) isBGPPeerKeyHandle_IdOrKey() {}

func (m *BGPPeerKeyHandle) GetIdOrKey() isBGPPeerKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetKey() *BGPPeerKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPPeerKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPPeerKeyHandle_OneofMarshaler, _BGPPeerKeyHandle_OneofUnmarshaler, _BGPPeerKeyHandle_OneofSizer, []interface{}{
		(*BGPPeerKeyHandle_Id)(nil),
		(*BGPPeerKeyHandle_Key)(nil),
	}
}

func _BGPPeerKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPPeerKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *BGPPeerKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPPeerKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _BGPPeerKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPPeerKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &BGPPeerKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &BGPPeerKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPPeerKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPPeerKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *BGPPeerKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP peer delete request
type BGPPeerDeleteRequest struct {
	Request []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerDeleteRequest) Reset()                    { *m = BGPPeerDeleteRequest{} }
func (m *BGPPeerDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerDeleteRequest) ProtoMessage()               {}
func (*BGPPeerDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{18} }

func (m *BGPPeerDeleteRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerDeleteResponse) Reset()                    { *m = BGPPeerDeleteResponse{} }
func (m *BGPPeerDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerDeleteResponse) ProtoMessage()               {}
func (*BGPPeerDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{19} }

func (m *BGPPeerDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer get request
type BGPPeerGetRequest struct {
	Request []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerGetRequest) Reset()                    { *m = BGPPeerGetRequest{} }
func (m *BGPPeerGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerGetRequest) ProtoMessage()               {}
func (*BGPPeerGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{20} }

func (m *BGPPeerGetRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF configurations
type BGPPeerAfSpec struct {
	// unique key/identifier of peer AF config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,2,opt,name=LocalAddr" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,3,opt,name=PeerAddr" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,4,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty" meta:mandatory,immutable`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,5,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty" meta:mandatory,immutable`
	// enforce this router to set self as next-hop for advertised routes
	NexthopSelf bool `protobuf:"varint,6,opt,name=NexthopSelf,proto3" json:"NexthopSelf,omitempty"`
	// originate a default route to this peer
	DefaultOrig bool `protobuf:"varint,7,opt,name=DefaultOrig,proto3" json:"DefaultOrig,omitempty"`
}

func (m *BGPPeerAfSpec) Reset()                    { *m = BGPPeerAfSpec{} }
func (m *BGPPeerAfSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfSpec) ProtoMessage()               {}
func (*BGPPeerAfSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{21} }

func (m *BGPPeerAfSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerAfSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfSpec) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPPeerAfSpec) GetNexthopSelf() bool {
	if m != nil {
		return m.NexthopSelf
	}
	return false
}

func (m *BGPPeerAfSpec) GetDefaultOrig() bool {
	if m != nil {
		return m.DefaultOrig
	}
	return false
}

// BGP peer AF status
type BGPPeerAfStatus struct {
}

func (m *BGPPeerAfStatus) Reset()                    { *m = BGPPeerAfStatus{} }
func (m *BGPPeerAfStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfStatus) ProtoMessage()               {}
func (*BGPPeerAfStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{22} }

// BGP peer AF object
type BGPPeerAf struct {
	Spec   *BGPPeerAfSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPPeerAfStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGPPeerAf) Reset()                    { *m = BGPPeerAf{} }
func (m *BGPPeerAf) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAf) ProtoMessage()               {}
func (*BGPPeerAf) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{23} }

func (m *BGPPeerAf) GetSpec() *BGPPeerAfSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeerAf) GetStatus() *BGPPeerAfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer AF create and update response
type BGPPeerAfResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerAfResponse) Reset()                    { *m = BGPPeerAfResponse{} }
func (m *BGPPeerAfResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfResponse) ProtoMessage()               {}
func (*BGPPeerAfResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{24} }

func (m *BGPPeerAfResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer AF create and update request
type BGPPeerAfRequest struct {
	Request []*BGPPeerAfSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfRequest) Reset()                    { *m = BGPPeerAfRequest{} }
func (m *BGPPeerAfRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfRequest) ProtoMessage()               {}
func (*BGPPeerAfRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{25} }

func (m *BGPPeerAfRequest) GetRequest() []*BGPPeerAfSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer key parameters
type BGPPeerAfKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
}

func (m *BGPPeerAfKey) Reset()                    { *m = BGPPeerAfKey{} }
func (m *BGPPeerAfKey) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfKey) ProtoMessage()               {}
func (*BGPPeerAfKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{26} }

func (m *BGPPeerAfKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

// BGP peer delete spec
type BGPPeerAfKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerAfKeyHandle_Id
	//	*BGPPeerAfKeyHandle_Key
	IdOrKey isBGPPeerAfKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *BGPPeerAfKeyHandle) Reset()                    { *m = BGPPeerAfKeyHandle{} }
func (m *BGPPeerAfKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfKeyHandle) ProtoMessage()               {}
func (*BGPPeerAfKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{27} }

type isBGPPeerAfKeyHandle_IdOrKey interface {
	isBGPPeerAfKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerAfKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerAfKeyHandle_Key struct {
	Key *BGPPeerAfKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*BGPPeerAfKeyHandle_Id) isBGPPeerAfKeyHandle_IdOrKey()  {}
func (*BGPPeerAfKeyHandle_Key) isBGPPeerAfKeyHandle_IdOrKey() {}

func (m *BGPPeerAfKeyHandle) GetIdOrKey() isBGPPeerAfKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetKey() *BGPPeerAfKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPPeerAfKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPPeerAfKeyHandle_OneofMarshaler, _BGPPeerAfKeyHandle_OneofUnmarshaler, _BGPPeerAfKeyHandle_OneofSizer, []interface{}{
		(*BGPPeerAfKeyHandle_Id)(nil),
		(*BGPPeerAfKeyHandle_Key)(nil),
	}
}

func _BGPPeerAfKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPPeerAfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerAfKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *BGPPeerAfKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPPeerAfKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _BGPPeerAfKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPPeerAfKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &BGPPeerAfKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerAfKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &BGPPeerAfKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPPeerAfKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPPeerAfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerAfKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *BGPPeerAfKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP peer af delete request
type BGPPeerAfDeleteRequest struct {
	Request []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfDeleteRequest) Reset()                    { *m = BGPPeerAfDeleteRequest{} }
func (m *BGPPeerAfDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteRequest) ProtoMessage()               {}
func (*BGPPeerAfDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{28} }

func (m *BGPPeerAfDeleteRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerAfDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerAfDeleteResponse) Reset()                    { *m = BGPPeerAfDeleteResponse{} }
func (m *BGPPeerAfDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteResponse) ProtoMessage()               {}
func (*BGPPeerAfDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{29} }

func (m *BGPPeerAfDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer af get request
type BGPPeerAfGetRequest struct {
	Request []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfGetRequest) Reset()                    { *m = BGPPeerAfGetRequest{} }
func (m *BGPPeerAfGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfGetRequest) ProtoMessage()               {}
func (*BGPPeerAfGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{30} }

func (m *BGPPeerAfGetRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF get response
type BGPPeerAfGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPPeerAf `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPPeerAfGetResponse) Reset()                    { *m = BGPPeerAfGetResponse{} }
func (m *BGPPeerAfGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfGetResponse) ProtoMessage()               {}
func (*BGPPeerAfGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{31} }

func (m *BGPPeerAfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerAfGetResponse) GetResponse() []*BGPPeerAf {
	if m != nil {
		return m.Response
	}
	return nil
}

type BGPClearRouteRequest struct {
	// clear route options
	Option BGPClearRouteOptions `protobuf:"varint,1,opt,name=Option,proto3,enum=pds.BGPClearRouteOptions" json:"Option,omitempty"`
	// Types that are valid to be assigned to PeerOrPeeraf:
	//	*BGPClearRouteRequest_Peer
	//	*BGPClearRouteRequest_PeerAf
	PeerOrPeeraf isBGPClearRouteRequest_PeerOrPeeraf `protobuf_oneof:"peer_or_peeraf"`
}

func (m *BGPClearRouteRequest) Reset()                    { *m = BGPClearRouteRequest{} }
func (m *BGPClearRouteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPClearRouteRequest) ProtoMessage()               {}
func (*BGPClearRouteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{32} }

type isBGPClearRouteRequest_PeerOrPeeraf interface {
	isBGPClearRouteRequest_PeerOrPeeraf()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPClearRouteRequest_Peer struct {
	Peer *BGPPeerKeyHandle `protobuf:"bytes,2,opt,name=Peer,oneof"`
}
type BGPClearRouteRequest_PeerAf struct {
	PeerAf *BGPPeerAfKeyHandle `protobuf:"bytes,3,opt,name=PeerAf,oneof"`
}

func (*BGPClearRouteRequest_Peer) isBGPClearRouteRequest_PeerOrPeeraf()   {}
func (*BGPClearRouteRequest_PeerAf) isBGPClearRouteRequest_PeerOrPeeraf() {}

func (m *BGPClearRouteRequest) GetPeerOrPeeraf() isBGPClearRouteRequest_PeerOrPeeraf {
	if m != nil {
		return m.PeerOrPeeraf
	}
	return nil
}

func (m *BGPClearRouteRequest) GetOption() BGPClearRouteOptions {
	if m != nil {
		return m.Option
	}
	return BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE
}

func (m *BGPClearRouteRequest) GetPeer() *BGPPeerKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_Peer); ok {
		return x.Peer
	}
	return nil
}

func (m *BGPClearRouteRequest) GetPeerAf() *BGPPeerAfKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_PeerAf); ok {
		return x.PeerAf
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPClearRouteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPClearRouteRequest_OneofMarshaler, _BGPClearRouteRequest_OneofUnmarshaler, _BGPClearRouteRequest_OneofSizer, []interface{}{
		(*BGPClearRouteRequest_Peer)(nil),
		(*BGPClearRouteRequest_PeerAf)(nil),
	}
}

func _BGPClearRouteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPClearRouteRequest)
	// peer_or_peeraf
	switch x := m.PeerOrPeeraf.(type) {
	case *BGPClearRouteRequest_Peer:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Peer); err != nil {
			return err
		}
	case *BGPClearRouteRequest_PeerAf:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PeerAf); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPClearRouteRequest.PeerOrPeeraf has unexpected type %T", x)
	}
	return nil
}

func _BGPClearRouteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPClearRouteRequest)
	switch tag {
	case 2: // peer_or_peeraf.Peer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerKeyHandle)
		err := b.DecodeMessage(msg)
		m.PeerOrPeeraf = &BGPClearRouteRequest_Peer{msg}
		return true, err
	case 3: // peer_or_peeraf.PeerAf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerAfKeyHandle)
		err := b.DecodeMessage(msg)
		m.PeerOrPeeraf = &BGPClearRouteRequest_PeerAf{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPClearRouteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPClearRouteRequest)
	// peer_or_peeraf
	switch x := m.PeerOrPeeraf.(type) {
	case *BGPClearRouteRequest_Peer:
		s := proto.Size(x.Peer)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BGPClearRouteRequest_PeerAf:
		s := proto.Size(x.PeerAf)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP clear route response
type BGPClearRouteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPClearRouteResponse) Reset()                    { *m = BGPClearRouteResponse{} }
func (m *BGPClearRouteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPClearRouteResponse) ProtoMessage()               {}
func (*BGPClearRouteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{33} }

func (m *BGPClearRouteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP NLRI prefix table
type BGPNLRIPrefixStatus struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID uint32 `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
	// chosen as BGP best route or not
	BestRoute bool `protobuf:"varint,8,opt,name=BestRoute,proto3" json:"BestRoute,omitempty"`
	// AS path string
	ASPathStr []byte `protobuf:"bytes,9,opt,name=ASPathStr,proto3" json:"ASPathStr,omitempty"`
	// originator ID
	PathOrigId []byte `protobuf:"bytes,10,opt,name=PathOrigId,proto3" json:"PathOrigId,omitempty"`
	// next-hop address
	NextHopAddr []byte `protobuf:"bytes,11,opt,name=NextHopAddr,proto3" json:"NextHopAddr,omitempty"`
	// Size of each ASN in the AS path string
	ASSize BGPASSize `protobuf:"varint,12,opt,name=ASSize,proto3,enum=pds.BGPASSize" json:"ASSize,omitempty"`
	// Is this route part of an ECMP set
	EcmpRoute bool `protobuf:"varint,13,opt,name=EcmpRoute,proto3" json:"EcmpRoute,omitempty"`
	// Peer IP
	PeerAddr *IPAddress `protobuf:"bytes,14,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
}

func (m *BGPNLRIPrefixStatus) Reset()                    { *m = BGPNLRIPrefixStatus{} }
func (m *BGPNLRIPrefixStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixStatus) ProtoMessage()               {}
func (*BGPNLRIPrefixStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{34} }

func (m *BGPNLRIPrefixStatus) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixStatus) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetBestRoute() bool {
	if m != nil {
		return m.BestRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetASPathStr() []byte {
	if m != nil {
		return m.ASPathStr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPathOrigId() []byte {
	if m != nil {
		return m.PathOrigId
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetNextHopAddr() []byte {
	if m != nil {
		return m.NextHopAddr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetASSize() BGPASSize {
	if m != nil {
		return m.ASSize
	}
	return BGPASSize_BGP_AS_SIZE_NONE
}

func (m *BGPNLRIPrefixStatus) GetEcmpRoute() bool {
	if m != nil {
		return m.EcmpRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

// BGP NLRI prefix key object
type BGPNLRIPrefixKey struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID uint32 `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
}

func (m *BGPNLRIPrefixKey) Reset()                    { *m = BGPNLRIPrefixKey{} }
func (m *BGPNLRIPrefixKey) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKey) ProtoMessage()               {}
func (*BGPNLRIPrefixKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{35} }

func (m *BGPNLRIPrefixKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixKey) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixKey) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixKey) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

// BGP NLRI prefix object
type BGPNLRIPrefix struct {
	Status *BGPNLRIPrefixStatus `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *BGPNLRIPrefix) Reset()                    { *m = BGPNLRIPrefix{} }
func (m *BGPNLRIPrefix) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefix) ProtoMessage()               {}
func (*BGPNLRIPrefix) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{36} }

func (m *BGPNLRIPrefix) GetStatus() *BGPNLRIPrefixStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP NLRI prefix get response
type BGPNLRIPrefixGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPNLRIPrefix `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPNLRIPrefixGetResponse) Reset()                    { *m = BGPNLRIPrefixGetResponse{} }
func (m *BGPNLRIPrefixGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetResponse) ProtoMessage()               {}
func (*BGPNLRIPrefixGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{37} }

func (m *BGPNLRIPrefixGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPNLRIPrefixGetResponse) GetResponse() []*BGPNLRIPrefix {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP NLRI key handle
type BGPNLRIPrefixKeyHandle struct {
	Key *BGPNLRIPrefixKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *BGPNLRIPrefixKeyHandle) Reset()                    { *m = BGPNLRIPrefixKeyHandle{} }
func (m *BGPNLRIPrefixKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKeyHandle) ProtoMessage()               {}
func (*BGPNLRIPrefixKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{38} }

func (m *BGPNLRIPrefixKeyHandle) GetKey() *BGPNLRIPrefixKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGP NLRI prefix get request
type BGPNLRIPrefixGetRequest struct {
	Request []*BGPNLRIPrefixKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPNLRIPrefixGetRequest) Reset()                    { *m = BGPNLRIPrefixGetRequest{} }
func (m *BGPNLRIPrefixGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetRequest) ProtoMessage()               {}
func (*BGPNLRIPrefixGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{39} }

func (m *BGPNLRIPrefixGetRequest) GetRequest() []*BGPNLRIPrefixKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterType((*BGPSpec)(nil), "pds.BGPSpec")
	proto.RegisterType((*BGPStatus)(nil), "pds.BGPStatus")
	proto.RegisterType((*BGP)(nil), "pds.BGP")
	proto.RegisterType((*BGPRequest)(nil), "pds.BGPRequest")
	proto.RegisterType((*BGPResponse)(nil), "pds.BGPResponse")
	proto.RegisterType((*BGPKeyHandle)(nil), "pds.BGPKeyHandle")
	proto.RegisterType((*BGPDeleteRequest)(nil), "pds.BGPDeleteRequest")
	proto.RegisterType((*BGPDeleteResponse)(nil), "pds.BGPDeleteResponse")
	proto.RegisterType((*BGPGetRequest)(nil), "pds.BGPGetRequest")
	proto.RegisterType((*BGPGetResponse)(nil), "pds.BGPGetResponse")
	proto.RegisterType((*BGPPeerSpec)(nil), "pds.BGPPeerSpec")
	proto.RegisterType((*BGPPeerStatus)(nil), "pds.BGPPeerStatus")
	proto.RegisterType((*BGPPeer)(nil), "pds.BGPPeer")
	proto.RegisterType((*BGPPeerResponse)(nil), "pds.BGPPeerResponse")
	proto.RegisterType((*BGPPeerRequest)(nil), "pds.BGPPeerRequest")
	proto.RegisterType((*BGPPeerGetResponse)(nil), "pds.BGPPeerGetResponse")
	proto.RegisterType((*BGPPeerKey)(nil), "pds.BGPPeerKey")
	proto.RegisterType((*BGPPeerKeyHandle)(nil), "pds.BGPPeerKeyHandle")
	proto.RegisterType((*BGPPeerDeleteRequest)(nil), "pds.BGPPeerDeleteRequest")
	proto.RegisterType((*BGPPeerDeleteResponse)(nil), "pds.BGPPeerDeleteResponse")
	proto.RegisterType((*BGPPeerGetRequest)(nil), "pds.BGPPeerGetRequest")
	proto.RegisterType((*BGPPeerAfSpec)(nil), "pds.BGPPeerAfSpec")
	proto.RegisterType((*BGPPeerAfStatus)(nil), "pds.BGPPeerAfStatus")
	proto.RegisterType((*BGPPeerAf)(nil), "pds.BGPPeerAf")
	proto.RegisterType((*BGPPeerAfResponse)(nil), "pds.BGPPeerAfResponse")
	proto.RegisterType((*BGPPeerAfRequest)(nil), "pds.BGPPeerAfRequest")
	proto.RegisterType((*BGPPeerAfKey)(nil), "pds.BGPPeerAfKey")
	proto.RegisterType((*BGPPeerAfKeyHandle)(nil), "pds.BGPPeerAfKeyHandle")
	proto.RegisterType((*BGPPeerAfDeleteRequest)(nil), "pds.BGPPeerAfDeleteRequest")
	proto.RegisterType((*BGPPeerAfDeleteResponse)(nil), "pds.BGPPeerAfDeleteResponse")
	proto.RegisterType((*BGPPeerAfGetRequest)(nil), "pds.BGPPeerAfGetRequest")
	proto.RegisterType((*BGPPeerAfGetResponse)(nil), "pds.BGPPeerAfGetResponse")
	proto.RegisterType((*BGPClearRouteRequest)(nil), "pds.BGPClearRouteRequest")
	proto.RegisterType((*BGPClearRouteResponse)(nil), "pds.BGPClearRouteResponse")
	proto.RegisterType((*BGPNLRIPrefixStatus)(nil), "pds.BGPNLRIPrefixStatus")
	proto.RegisterType((*BGPNLRIPrefixKey)(nil), "pds.BGPNLRIPrefixKey")
	proto.RegisterType((*BGPNLRIPrefix)(nil), "pds.BGPNLRIPrefix")
	proto.RegisterType((*BGPNLRIPrefixGetResponse)(nil), "pds.BGPNLRIPrefixGetResponse")
	proto.RegisterType((*BGPNLRIPrefixKeyHandle)(nil), "pds.BGPNLRIPrefixKeyHandle")
	proto.RegisterType((*BGPNLRIPrefixGetRequest)(nil), "pds.BGPNLRIPrefixGetRequest")
	proto.RegisterEnum("pds.BGPAfi", BGPAfi_name, BGPAfi_value)
	proto.RegisterEnum("pds.BGPSafi", BGPSafi_name, BGPSafi_value)
	proto.RegisterEnum("pds.BGPPeerRRClient", BGPPeerRRClient_name, BGPPeerRRClient_value)
	proto.RegisterEnum("pds.BGPPeerState", BGPPeerState_name, BGPPeerState_value)
	proto.RegisterEnum("pds.BGPASSize", BGPASSize_name, BGPASSize_value)
	proto.RegisterEnum("pds.BGPAddrType", BGPAddrType_name, BGPAddrType_value)
	proto.RegisterEnum("pds.BGPOperStatus", BGPOperStatus_name, BGPOperStatus_value)
	proto.RegisterEnum("pds.BGPClearRouteOptions", BGPClearRouteOptions_name, BGPClearRouteOptions_value)
	proto.RegisterEnum("pds.NLRISrc", NLRISrc_name, NLRISrc_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BGPSvc service

type BGPSvcClient interface {
	BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error)
	BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error)
	BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error)
}

type bGPSvcClient struct {
	cc *grpc.ClientConn
}

func NewBGPSvcClient(cc *grpc.ClientConn) BGPSvcClient {
	return &bGPSvcClient{cc}
}

func (c *bGPSvcClient) BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error) {
	out := new(BGPDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error) {
	out := new(BGPGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error) {
	out := new(BGPPeerDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error) {
	out := new(BGPPeerGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error) {
	out := new(BGPPeerAfDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error) {
	out := new(BGPPeerAfGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error) {
	out := new(BGPClearRouteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPClearRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error) {
	out := new(BGPNLRIPrefixGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPNLRIPrefixGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BGPSvc service

type BGPSvcServer interface {
	BGPCreate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPUpdate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPDelete(context.Context, *BGPDeleteRequest) (*BGPDeleteResponse, error)
	BGPGet(context.Context, *BGPGetRequest) (*BGPGetResponse, error)
	BGPPeerCreate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerUpdate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerDelete(context.Context, *BGPPeerDeleteRequest) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(context.Context, *BGPPeerGetRequest) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(context.Context, *BGPPeerAfDeleteRequest) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(context.Context, *BGPPeerAfGetRequest) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(context.Context, *BGPClearRouteRequest) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(context.Context, *BGPNLRIPrefixGetRequest) (*BGPNLRIPrefixGetResponse, error)
}

func RegisterBGPSvcServer(s *grpc.Server, srv BGPSvcServer) {
	s.RegisterService(&_BGPSvc_serviceDesc, srv)
}

func _BGPSvc_BGPCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPCreate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPUpdate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPDelete(ctx, req.(*BGPDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPGet(ctx, req.(*BGPGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, req.(*BGPPeerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, req.(*BGPPeerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, req.(*BGPPeerAfDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, req.(*BGPPeerAfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPClearRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPClearRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPClearRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, req.(*BGPClearRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPNLRIPrefixGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPNLRIPrefixGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPNLRIPrefixGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, req.(*BGPNLRIPrefixGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BGPSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.BGPSvc",
	HandlerType: (*BGPSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BGPCreate",
			Handler:    _BGPSvc_BGPCreate_Handler,
		},
		{
			MethodName: "BGPUpdate",
			Handler:    _BGPSvc_BGPUpdate_Handler,
		},
		{
			MethodName: "BGPDelete",
			Handler:    _BGPSvc_BGPDelete_Handler,
		},
		{
			MethodName: "BGPGet",
			Handler:    _BGPSvc_BGPGet_Handler,
		},
		{
			MethodName: "BGPPeerCreate",
			Handler:    _BGPSvc_BGPPeerCreate_Handler,
		},
		{
			MethodName: "BGPPeerUpdate",
			Handler:    _BGPSvc_BGPPeerUpdate_Handler,
		},
		{
			MethodName: "BGPPeerDelete",
			Handler:    _BGPSvc_BGPPeerDelete_Handler,
		},
		{
			MethodName: "BGPPeerGet",
			Handler:    _BGPSvc_BGPPeerGet_Handler,
		},
		{
			MethodName: "BGPPeerAfCreate",
			Handler:    _BGPSvc_BGPPeerAfCreate_Handler,
		},
		{
			MethodName: "BGPPeerAfUpdate",
			Handler:    _BGPSvc_BGPPeerAfUpdate_Handler,
		},
		{
			MethodName: "BGPPeerAfDelete",
			Handler:    _BGPSvc_BGPPeerAfDelete_Handler,
		},
		{
			MethodName: "BGPPeerAfGet",
			Handler:    _BGPSvc_BGPPeerAfGet_Handler,
		},
		{
			MethodName: "BGPClearRoute",
			Handler:    _BGPSvc_BGPClearRoute_Handler,
		},
		{
			MethodName: "BGPNLRIPrefixGet",
			Handler:    _BGPSvc_BGPNLRIPrefixGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bgp.proto",
}

func (m *BGPSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.LocalASN != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalASN))
	}
	if m.RouterId != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RouterId))
		i += 4
	}
	if m.ClusterId != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClusterId))
		i += 4
	}
	return i, nil
}

func (m *BGPStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
	}
	if m.NumAdjRibOutRoutes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.NumAdjRibOutRoutes))
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeakNumAdjRibOutRoutes))
	}
	if m.RemDelayTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RemDelayTime))
	}
	if m.TableVer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.TableVer))
	}
	return i, nil
}

func (m *BGP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *BGPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n3, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *BGPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *BGPDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n4, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *BGPDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n5, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BGPGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Response.Size()))
		n6, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *BGPPeerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.State))
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n7, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n8, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RemoteASN != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RemoteASN))
	}
	if m.SendComm {
		dAtA[i] = 0x30
		i++
		if m.SendComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendExtComm {
		dAtA[i] = 0x38
		i++
		if m.SendExtComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RRClient != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RRClient))
	}
	if m.ConnectRetry != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.TTL != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.TTL))
	}
	return i, nil
}

func (m *BGPPeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
	}
	if m.PrevStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrevStatus))
	}
	if len(m.LastErrorRcvd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorRcvd)))
		i += copy(dAtA[i:], m.LastErrorRcvd)
	}
	if len(m.LastErrorSent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorSent)))
		i += copy(dAtA[i:], m.LastErrorSent)
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n9, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
	}
	if m.CapsSent != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsSent))
	}
	if m.CapsRcvd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsRcvd))
	}
	if m.CapsNeg != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsNeg))
	}
	if m.SelLocalAddrType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.SelLocalAddrType))
	}
	return i, nil
}

func (m *BGPPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n10, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n11, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *BGPPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n12, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n13, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *BGPPeerKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn14, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *BGPPeerKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *BGPPeerKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n15, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *BGPPeerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n16, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n17, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Afi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if m.NexthopSelf {
		dAtA[i] = 0x30
		i++
		if m.NexthopSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultOrig {
		dAtA[i] = 0x38
		i++
		if m.DefaultOrig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BGPPeerAfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BGPPeerAf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n18, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *BGPPeerAfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerAfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n20, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n21, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Afi != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	return i, nil
}

func (m *BGPPeerAfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn22, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *BGPPeerAfKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *BGPPeerAfKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n23, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *BGPPeerAfDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerAfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPClearRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Option != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Option))
	}
	if m.PeerOrPeeraf != nil {
		nn24, err := m.PeerOrPeeraf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	return i, nil
}

func (m *BGPClearRouteRequest_Peer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Peer.Size()))
		n25, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *BGPClearRouteRequest_PeerAf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PeerAf != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAf.Size()))
		n26, err := m.PeerAf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *BGPClearRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPNLRIPrefixStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Afi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
	}
	if m.BestRoute {
		dAtA[i] = 0x40
		i++
		if m.BestRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ASPathStr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.ASPathStr)))
		i += copy(dAtA[i:], m.ASPathStr)
	}
	if len(m.PathOrigId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.PathOrigId)))
		i += copy(dAtA[i:], m.PathOrigId)
	}
	if len(m.NextHopAddr) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.NextHopAddr)))
		i += copy(dAtA[i:], m.NextHopAddr)
	}
	if m.ASSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ASSize))
	}
	if m.EcmpRoute {
		dAtA[i] = 0x68
		i++
		if m.EcmpRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n27, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *BGPNLRIPrefixKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Afi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
	}
	return i, nil
}

func (m *BGPNLRIPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n28, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *BGPNLRIPrefixGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPNLRIPrefixKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n29, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *BGPNLRIPrefixGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintBgp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BGPSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalASN != 0 {
		n += 1 + sovBgp(uint64(m.LocalASN))
	}
	if m.RouterId != 0 {
		n += 5
	}
	if m.ClusterId != 0 {
		n += 5
	}
	return n
}

func (m *BGPStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.NumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumAdjRibOutRoutes))
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.PeakNumAdjRibOutRoutes))
	}
	if m.RemDelayTime != 0 {
		n += 1 + sovBgp(uint64(m.RemDelayTime))
	}
	if m.TableVer != 0 {
		n += 1 + sovBgp(uint64(m.TableVer))
	}
	return n
}

func (m *BGP) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPKeyHandle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBgp(uint64(m.State))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.RemoteASN != 0 {
		n += 1 + sovBgp(uint64(m.RemoteASN))
	}
	if m.SendComm {
		n += 2
	}
	if m.SendExtComm {
		n += 2
	}
	if m.RRClient != 0 {
		n += 1 + sovBgp(uint64(m.RRClient))
	}
	if m.ConnectRetry != 0 {
		n += 1 + sovBgp(uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovBgp(uint64(m.TTL))
	}
	return n
}

func (m *BGPPeerStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.PrevStatus != 0 {
		n += 1 + sovBgp(uint64(m.PrevStatus))
	}
	l = len(m.LastErrorRcvd)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.LastErrorSent)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	if m.CapsSent != 0 {
		n += 1 + sovBgp(uint64(m.CapsSent))
	}
	if m.CapsRcvd != 0 {
		n += 1 + sovBgp(uint64(m.CapsRcvd))
	}
	if m.CapsNeg != 0 {
		n += 1 + sovBgp(uint64(m.CapsNeg))
	}
	if m.SelLocalAddrType != 0 {
		n += 1 + sovBgp(uint64(m.SelLocalAddrType))
	}
	return n
}

func (m *BGPPeer) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerKey) Size() (n int) {
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *BGPPeerKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.NexthopSelf {
		n += 2
	}
	if m.DefaultOrig {
		n += 2
	}
	return n
}

func (m *BGPPeerAfStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BGPPeerAf) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerAfResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerAfRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfKey) Size() (n int) {
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	return n
}

func (m *BGPPeerAfKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *BGPPeerAfKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerAfGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPClearRouteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Option != 0 {
		n += 1 + sovBgp(uint64(m.Option))
	}
	if m.PeerOrPeeraf != nil {
		n += m.PeerOrPeeraf.Size()
	}
	return n
}

func (m *BGPClearRouteRequest_Peer) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteRequest_PeerAf) Size() (n int) {
	var l int
	_ = l
	if m.PeerAf != nil {
		l = m.PeerAf.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPNLRIPrefixStatus) Size() (n int) {
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	if m.BestRoute {
		n += 2
	}
	l = len(m.ASPathStr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.PathOrigId)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.NextHopAddr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.ASSize != 0 {
		n += 1 + sovBgp(uint64(m.ASSize))
	}
	if m.EcmpRoute {
		n += 2
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPNLRIPrefixKey) Size() (n int) {
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	return n
}

func (m *BGPNLRIPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPNLRIPrefixGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPNLRIPrefixKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPNLRIPrefixGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func sovBgp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBgp(x uint64) (n int) {
	return sovBgp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BGPSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalASN", wireType)
			}
			m.LocalASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalASN |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			m.RouterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (BGPOperStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAdjRibOutRoutes", wireType)
			}
			m.NumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAdjRibOutRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakNumAdjRibOutRoutes", wireType)
			}
			m.PeakNumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakNumAdjRibOutRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemDelayTime", wireType)
			}
			m.RemDelayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemDelayTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableVer", wireType)
			}
			m.TableVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &BGP{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (AdminState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteASN", wireType)
			}
			m.RemoteASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteASN |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendComm = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendExtComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendExtComm = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRClient", wireType)
			}
			m.RRClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RRClient |= (BGPPeerRRClient(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetry", wireType)
			}
			m.ConnectRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (BGPPeerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevStatus", wireType)
			}
			m.PrevStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevStatus |= (BGPPeerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorRcvd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorRcvd = append(m.LastErrorRcvd[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorRcvd == nil {
				m.LastErrorRcvd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorSent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorSent = append(m.LastErrorSent[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorSent == nil {
				m.LastErrorSent = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsSent", wireType)
			}
			m.CapsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsSent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsRcvd", wireType)
			}
			m.CapsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsRcvd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsNeg", wireType)
			}
			m.CapsNeg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsNeg |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelLocalAddrType", wireType)
			}
			m.SelLocalAddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelLocalAddrType |= (BGPAddrType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeer{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NexthopSelf = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOrig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultOrig = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerAfSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerAfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerAfKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerAfKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeerAf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= (BGPClearRouteOptions(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_Peer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_PeerAf{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= (NLRISrc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BestRoute = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASPathStr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ASPathStr = append(m.ASPathStr[:0], dAtA[iNdEx:postIndex]...)
			if m.ASPathStr == nil {
				m.ASPathStr = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOrigId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOrigId = append(m.PathOrigId[:0], dAtA[iNdEx:postIndex]...)
			if m.PathOrigId == nil {
				m.PathOrigId = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopAddr = append(m.NextHopAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.NextHopAddr == nil {
				m.NextHopAddr = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASSize", wireType)
			}
			m.ASSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ASSize |= (BGPASSize(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EcmpRoute = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= (NLRISrc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPNLRIPrefixStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPNLRIPrefix{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPNLRIPrefixKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPNLRIPrefixKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBgp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBgp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBgp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBgp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBgp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBgp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("bgp.proto", fileDescriptorBgp) }

var fileDescriptorBgp = []byte{
	// 2355 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0xbd, 0x73, 0x1b, 0xc7,
	0x15, 0xe7, 0x01, 0xe0, 0xd7, 0x02, 0x84, 0x96, 0x2b, 0x8a, 0x82, 0x28, 0x9a, 0xe2, 0x20, 0x8e,
	0xad, 0xc0, 0x1a, 0x5a, 0x84, 0x15, 0x8e, 0xe2, 0x28, 0x91, 0xef, 0x80, 0x23, 0x70, 0x21, 0x7c,
	0xb8, 0xec, 0x1d, 0x69, 0xd9, 0x0d, 0x06, 0x22, 0x16, 0x32, 0x6c, 0x7c, 0xe5, 0x70, 0x54, 0x04,
	0xf7, 0xa9, 0x32, 0xe9, 0x5d, 0xa7, 0x77, 0x95, 0x2a, 0x93, 0x7f, 0x20, 0x93, 0x2a, 0x45, 0x6a,
	0x25, 0xa3, 0xd2, 0xa5, 0xfb, 0xcc, 0x64, 0xf6, 0xe3, 0xf6, 0x3e, 0x29, 0xda, 0x50, 0x52, 0xa5,
	0x91, 0xb0, 0xef, 0xf7, 0xde, 0xdb, 0xb7, 0x6f, 0xdf, 0xfe, 0xde, 0xde, 0x12, 0xac, 0x3f, 0x7d,
	0x36, 0x3d, 0x98, 0xba, 0x13, 0x6f, 0x82, 0xb2, 0xd3, 0xde, 0x6c, 0x07, 0x3c, 0x9b, 0x3c, 0x9b,
	0x70, 0xc1, 0xce, 0xb5, 0x11, 0xf1, 0xba, 0xef, 0xd3, 0x7f, 0x84, 0x20, 0xef, 0xcd, 0xa7, 0x64,
	0xc6, 0x07, 0xe5, 0x3f, 0x28, 0x60, 0x55, 0x6b, 0x58, 0xf6, 0x94, 0x9c, 0xa3, 0x7b, 0x20, 0x63,
	0xf4, 0x4a, 0xca, 0xbe, 0x72, 0xb7, 0xa0, 0xed, 0x7e, 0xf7, 0xf2, 0x4e, 0x89, 0x1a, 0x7d, 0x38,
	0xea, 0x8e, 0x7b, 0x5d, 0x6f, 0xe2, 0xce, 0xef, 0x0d, 0x46, 0xa3, 0x0b, 0xaf, 0xfb, 0x74, 0x48,
	0x70, 0xc6, 0xe8, 0xa1, 0x1d, 0xb0, 0xd6, 0x9a, 0x9c, 0x77, 0x87, 0xaa, 0x6d, 0x96, 0x32, 0xfb,
	0xca, 0xdd, 0x0d, 0x2c, 0xc7, 0x14, 0xc3, 0x93, 0x0b, 0x8f, 0xb8, 0x46, 0xaf, 0x94, 0xdd, 0x57,
	0xee, 0xae, 0x62, 0x39, 0x46, 0xbb, 0x60, 0xbd, 0x36, 0xbc, 0x98, 0x71, 0x30, 0xc7, 0xc0, 0x40,
	0x50, 0xfe, 0xa7, 0x02, 0xd6, 0x69, 0x3c, 0x5e, 0xd7, 0xbb, 0x98, 0xa1, 0x0a, 0x58, 0xe1, 0xbf,
	0x58, 0x54, 0xc5, 0x2a, 0x3a, 0x98, 0xf6, 0x66, 0x07, 0x5a, 0xc3, 0x6a, 0x4f, 0x89, 0xcb, 0x11,
	0x2c, 0x34, 0xd0, 0x01, 0x40, 0xe6, 0xc5, 0x48, 0xed, 0x7d, 0x81, 0x07, 0x4f, 0xdb, 0x17, 0x1e,
	0x9b, 0x6f, 0x26, 0x22, 0x4b, 0x41, 0xd0, 0x11, 0xd8, 0xb6, 0x48, 0xf7, 0xcb, 0x14, 0x9b, 0x2c,
	0xb3, 0xb9, 0x04, 0x45, 0x65, 0x50, 0xc0, 0x64, 0x54, 0x27, 0xc3, 0xee, 0xdc, 0x19, 0x8c, 0x08,
	0x5b, 0xc2, 0x06, 0x8e, 0xc8, 0xe8, 0xfa, 0x1d, 0x9a, 0xa8, 0x33, 0xe2, 0x96, 0x96, 0x79, 0x6e,
	0xfc, 0x71, 0x79, 0x0e, 0xb2, 0x5a, 0xc3, 0x42, 0x0f, 0x40, 0x8e, 0x26, 0x9d, 0x2d, 0x2c, 0x5f,
	0x2d, 0xf8, 0x0b, 0xa3, 0x32, 0x0d, 0x7d, 0xfb, 0xf2, 0x4e, 0x71, 0x36, 0x25, 0xe7, 0xf7, 0x26,
	0xa3, 0x81, 0x47, 0x46, 0x53, 0x6f, 0x8e, 0x99, 0x36, 0x7a, 0x24, 0x13, 0x92, 0x61, 0x76, 0x45,
	0x69, 0xc7, 0xa4, 0xda, 0xd6, 0xb7, 0x2f, 0xef, 0xc0, 0x19, 0xfb, 0x1d, 0xb2, 0x15, 0x36, 0xe5,
	0x07, 0x00, 0x68, 0x0d, 0x0b, 0x93, 0xdf, 0x5c, 0x90, 0x99, 0x87, 0xde, 0x01, 0xab, 0xe2, 0x67,
	0x5a, 0x10, 0xd8, 0x07, 0xcb, 0xbf, 0x00, 0x79, 0x66, 0x35, 0x9b, 0x4e, 0xc6, 0x33, 0x82, 0x0e,
	0xc0, 0xba, 0x3a, 0x1d, 0x44, 0xb6, 0x05, 0x1e, 0xf0, 0x92, 0x92, 0x72, 0x1c, 0xa8, 0x94, 0xf7,
	0x40, 0x41, 0x6b, 0x58, 0x27, 0x64, 0xde, 0xec, 0x8e, 0x7b, 0x43, 0x82, 0x8a, 0x41, 0x95, 0xd1,
	0x3a, 0x2a, 0x3f, 0x06, 0x50, 0x6b, 0x58, 0x75, 0x32, 0x24, 0x1e, 0xf1, 0x43, 0x7b, 0x2f, 0x1e,
	0xda, 0xa6, 0x1f, 0x9a, 0xf4, 0x13, 0xc4, 0x57, 0x03, 0x9b, 0x21, 0x07, 0x0b, 0x46, 0xf9, 0x08,
	0x6c, 0x68, 0x0d, 0xab, 0x41, 0xbc, 0x85, 0x42, 0xe8, 0x83, 0xa2, 0x6f, 0xbd, 0xd8, 0xfc, 0xe8,
	0x6d, 0xb0, 0xe6, 0xdb, 0x8a, 0xad, 0x5d, 0xf3, 0xe7, 0xc3, 0x12, 0x29, 0x7f, 0x9d, 0x63, 0x7b,
	0x61, 0x11, 0xe2, 0x2e, 0x70, 0x62, 0xdf, 0x05, 0xcb, 0x74, 0x36, 0x3e, 0x41, 0xb1, 0xba, 0xe9,
	0xc7, 0xd3, 0x1b, 0x0d, 0xc6, 0x0c, 0xc0, 0x1c, 0x47, 0x2d, 0xb0, 0xce, 0x8f, 0x72, 0xaf, 0xe7,
	0xb2, 0xd3, 0x90, 0x97, 0xc1, 0x1b, 0x16, 0x15, 0x92, 0xd9, 0xec, 0x8a, 0xf9, 0x02, 0x07, 0xe8,
	0x57, 0x60, 0x8d, 0x06, 0xcc, 0x9c, 0xe5, 0x16, 0x72, 0x26, 0xed, 0x29, 0x79, 0x60, 0x32, 0x9a,
	0x78, 0x84, 0xb2, 0x0e, 0x3f, 0x59, 0x81, 0x80, 0x1e, 0x3b, 0x9b, 0x8c, 0x7b, 0xb5, 0xc9, 0x68,
	0x54, 0x5a, 0xd9, 0x57, 0xee, 0xae, 0x61, 0x39, 0x46, 0xfb, 0x20, 0x4f, 0x7f, 0xeb, 0x2f, 0x3c,
	0x06, 0xaf, 0x32, 0x38, 0x2c, 0x42, 0xf7, 0xc1, 0x1a, 0xc6, 0xb5, 0xe1, 0x80, 0x8c, 0xbd, 0xd2,
	0x1a, 0xcb, 0xd0, 0x96, 0xbf, 0x05, 0x74, 0x7e, 0x1f, 0xc3, 0x52, 0x8b, 0x52, 0x41, 0x6d, 0x32,
	0x1e, 0x93, 0x73, 0x0f, 0x13, 0xcf, 0x9d, 0x97, 0xd6, 0x39, 0x15, 0x84, 0x65, 0x34, 0xa6, 0xe6,
	0x64, 0xd8, 0x63, 0x54, 0x01, 0x38, 0x15, 0xf8, 0x63, 0xba, 0x9a, 0x13, 0x42, 0xa6, 0xea, 0x70,
	0xf0, 0x9c, 0x94, 0xf2, 0x7c, 0x35, 0x52, 0x40, 0x2d, 0xad, 0xee, 0x6c, 0xf6, 0xdb, 0x89, 0xdb,
	0x2b, 0x15, 0xd8, 0x71, 0x91, 0x63, 0x04, 0x41, 0xd6, 0x71, 0x5a, 0xa5, 0x0d, 0x66, 0x43, 0x7f,
	0x96, 0xff, 0x94, 0x65, 0x15, 0xcc, 0x4a, 0x83, 0x97, 0xd4, 0x4f, 0x62, 0xe4, 0xb9, 0x19, 0x5e,
	0x0d, 0xdf, 0x6f, 0x9f, 0x3b, 0x0f, 0x01, 0xb0, 0x5c, 0xf2, 0x3c, 0x44, 0x2d, 0xa9, 0xea, 0x21,
	0x25, 0xf4, 0x36, 0xd8, 0x68, 0x75, 0x67, 0x9e, 0xee, 0xba, 0x13, 0x17, 0x9f, 0x3f, 0xe7, 0x3c,
	0x5f, 0xc0, 0x51, 0x61, 0x44, 0xcb, 0xa6, 0x89, 0xcd, 0xc5, 0xb4, 0xa8, 0x90, 0x1e, 0x96, 0xa0,
	0xde, 0x96, 0xd3, 0x4b, 0x24, 0x5c, 0x51, 0xe1, 0x9c, 0xae, 0xbc, 0x2e, 0xa7, 0xab, 0x29, 0x39,
	0xad, 0x75, 0xa7, 0x33, 0xdb, 0xdf, 0xe3, 0x0d, 0x2c, 0xc7, 0x3e, 0xc6, 0x16, 0xb3, 0x1e, 0x60,
	0x6c, 0x1d, 0x25, 0xb0, 0x4a, 0x7f, 0x9b, 0xe4, 0x99, 0xd8, 0x44, 0x7f, 0x88, 0x1e, 0x01, 0x68,
	0x93, 0xa1, 0x8c, 0xcd, 0x99, 0x4f, 0xf9, 0x56, 0xd2, 0xf3, 0x2e, 0x12, 0xe8, 0xcb, 0x71, 0x42,
	0xb3, 0xfc, 0x3b, 0xde, 0x7e, 0x69, 0x8a, 0xd1, 0xc3, 0x48, 0x47, 0x80, 0x91, 0xf4, 0xbf, 0xbe,
	0x2b, 0x7c, 0x14, 0xeb, 0x0a, 0x28, 0xbe, 0x75, 0x57, 0x76, 0x06, 0x15, 0x5c, 0xf3, 0xcb, 0x7c,
	0x71, 0x06, 0x2d, 0x4a, 0x17, 0x9c, 0x42, 0x2b, 0x61, 0x0a, 0xcd, 0xa6, 0xad, 0x29, 0x60, 0xd0,
	0x31, 0x40, 0x42, 0xfe, 0x26, 0x2c, 0x7a, 0x37, 0xc2, 0xa2, 0xd9, 0x70, 0x4f, 0x63, 0x81, 0x05,
	0x4c, 0xfa, 0x05, 0x6b, 0x85, 0x54, 0x78, 0x42, 0xe6, 0xd1, 0x02, 0x54, 0xae, 0x2e, 0xc0, 0x7b,
	0x21, 0x4a, 0xcb, 0x5c, 0xa2, 0x2e, 0x35, 0xca, 0x67, 0xac, 0xc3, 0x89, 0xb9, 0x44, 0x17, 0x84,
	0x01, 0x73, 0x37, 0x97, 0x18, 0x3b, 0xff, 0x08, 0x64, 0x4f, 0xc8, 0x5c, 0xb8, 0xbb, 0x16, 0x0e,
	0x9b, 0x5a, 0x2d, 0x61, 0x8a, 0x6a, 0x79, 0xb0, 0x3e, 0xe8, 0x75, 0x26, 0x6e, 0xe7, 0x4b, 0x32,
	0x2f, 0x37, 0xc0, 0x96, 0xd0, 0x88, 0x76, 0xcf, 0xf7, 0xe3, 0x79, 0xbf, 0x11, 0xf7, 0x16, 0x6b,
	0x5f, 0x0d, 0x70, 0x23, 0xe6, 0x68, 0xc1, 0x1a, 0xa8, 0xb3, 0x56, 0x2c, 0x77, 0x71, 0xc1, 0x70,
	0xbe, 0x0e, 0xa8, 0x4c, 0xed, 0x2f, 0xd0, 0xe7, 0x22, 0xed, 0x2b, 0xf3, 0xdf, 0x6c, 0x5f, 0xd9,
	0x37, 0x6c, 0x5f, 0x3f, 0x07, 0x59, 0xb5, 0x3f, 0x60, 0x24, 0x58, 0xac, 0xe6, 0x25, 0x3f, 0xf4,
	0x07, 0x57, 0x78, 0xa0, 0x56, 0xe8, 0x97, 0x20, 0x67, 0x77, 0xfb, 0x03, 0x46, 0x90, 0xc5, 0xd0,
	0x65, 0xad, 0x7b, 0xa5, 0x39, 0xb3, 0xa3, 0x1d, 0xd0, 0x24, 0x2f, 0xbc, 0xcf, 0x27, 0x53, 0x9b,
	0x0c, 0xfb, 0xa2, 0x41, 0x86, 0x45, 0x54, 0xa3, 0x4e, 0xfa, 0xdd, 0x8b, 0xa1, 0xd7, 0x76, 0x07,
	0xcf, 0xfc, 0x1e, 0x19, 0x12, 0x95, 0x37, 0x25, 0x4f, 0xa8, 0x7d, 0xb1, 0xe7, 0xbf, 0xe7, 0x37,
	0x76, 0x2e, 0x43, 0x1f, 0x46, 0x48, 0x2c, 0x42, 0x44, 0x7c, 0x2f, 0x5f, 0x43, 0x63, 0x5a, 0x8c,
	0xc6, 0xb6, 0x62, 0xd6, 0xdf, 0x87, 0xc8, 0x6a, 0xb2, 0x02, 0xd5, 0xfe, 0xc2, 0x65, 0xfc, 0x91,
	0x3c, 0xb0, 0xd4, 0x09, 0xaf, 0xe2, 0x7b, 0xf1, 0x2a, 0x4e, 0x59, 0x5b, 0x50, 0xc2, 0xdf, 0x28,
	0xec, 0xd6, 0xcb, 0xa1, 0xff, 0x39, 0xc3, 0xa0, 0xb7, 0x78, 0x5d, 0x65, 0x13, 0x75, 0xc5, 0x2b,
	0x67, 0x5f, 0x54, 0x4e, 0x2e, 0x59, 0x39, 0xbc, 0x36, 0xca, 0x9f, 0x49, 0xfa, 0x65, 0xe1, 0x5e,
	0x4a, 0x52, 0x3f, 0x0e, 0x93, 0xd4, 0x66, 0x34, 0x03, 0x97, 0xd1, 0xd4, 0x09, 0xd8, 0x96, 0x3a,
	0x51, 0xa2, 0x3a, 0x8c, 0xe7, 0xf4, 0x66, 0xd2, 0x63, 0x8c, 0x1b, 0x0c, 0x70, 0x33, 0xe1, 0x6c,
	0xc1, 0x5d, 0x6e, 0x82, 0xeb, 0xd2, 0x55, 0x88, 0xae, 0x16, 0x08, 0xca, 0x95, 0x44, 0x2c, 0x3c,
	0x2d, 0xd8, 0xbe, 0x2a, 0x89, 0xf6, 0x55, 0x8c, 0xce, 0x1d, 0x6a, 0x60, 0x7f, 0x51, 0xd8, 0xa4,
	0xb5, 0x21, 0xe9, 0xba, 0xec, 0xcb, 0x34, 0x88, 0x7f, 0xa5, 0x3d, 0xf5, 0x06, 0x93, 0xb1, 0x98,
	0xf1, 0x96, 0xef, 0x22, 0x50, 0xe5, 0xf8, 0x0c, 0x0b, 0x45, 0xf4, 0x1e, 0xc8, 0x51, 0xff, 0x62,
	0x5b, 0xd3, 0xe9, 0xb9, 0xb9, 0x84, 0x99, 0x12, 0xf5, 0xcf, 0x83, 0x11, 0x6c, 0x78, 0x59, 0x7a,
	0x9a, 0x4b, 0x58, 0x28, 0x6a, 0x10, 0x14, 0xa7, 0x84, 0xb8, 0xb4, 0x20, 0xe8, 0xff, 0xdd, 0xbe,
	0xe8, 0x38, 0xe1, 0xe0, 0x17, 0xdc, 0xc4, 0xef, 0xb2, 0x6c, 0x17, 0xcd, 0x16, 0x36, 0x2c, 0x97,
	0xf4, 0x07, 0x2f, 0x44, 0x2a, 0xc5, 0x89, 0x50, 0xae, 0x38, 0x11, 0x99, 0xcb, 0x4e, 0x04, 0xda,
	0x06, 0x2b, 0xdc, 0xa1, 0xb8, 0xd8, 0x8a, 0x11, 0xbd, 0x5f, 0xf2, 0x5f, 0x2d, 0x32, 0x16, 0xdf,
	0xfe, 0x81, 0x00, 0x1d, 0x80, 0x3c, 0x5b, 0x8f, 0x3d, 0xb9, 0x70, 0xcf, 0x49, 0x84, 0xaa, 0x69,
	0x88, 0xb6, 0x7b, 0x8e, 0xc3, 0x0a, 0xa8, 0x02, 0x60, 0x68, 0x68, 0x8c, 0x7b, 0xe4, 0x85, 0xb8,
	0xd1, 0x26, 0xe4, 0x2c, 0xa2, 0xae, 0xf7, 0xb9, 0x51, 0x17, 0xd7, 0x5a, 0x31, 0xa2, 0x11, 0x69,
	0x64, 0xc6, 0x9f, 0x27, 0xd8, 0xa5, 0x76, 0x0d, 0x07, 0x02, 0x8a, 0xaa, 0x36, 0xd5, 0xb4, 0x3d,
	0x97, 0x5d, 0x6b, 0x0b, 0x38, 0x10, 0xa0, 0x3d, 0x00, 0xe8, 0x4f, 0xca, 0xed, 0x46, 0x8f, 0x5d,
	0x6d, 0x0b, 0x38, 0x24, 0xf1, 0x7b, 0x46, 0x73, 0x32, 0x65, 0x4c, 0x94, 0x67, 0x0a, 0x61, 0x11,
	0x7a, 0x07, 0xac, 0xa8, 0xb6, 0x3d, 0xf8, 0x8a, 0xb0, 0x6f, 0x94, 0x62, 0x50, 0xb1, 0x5c, 0x8a,
	0x05, 0x4a, 0xe3, 0xd0, 0xcf, 0x47, 0x53, 0x1e, 0xe5, 0x06, 0x8f, 0x52, 0x0a, 0x22, 0x74, 0x57,
	0xbc, 0xf2, 0x42, 0xf5, 0x6f, 0x85, 0x11, 0x74, 0xb0, 0xe9, 0x94, 0x61, 0xff, 0x7f, 0x76, 0xbc,
	0xac, 0xb2, 0xfb, 0x51, 0xb0, 0x7c, 0x74, 0x3f, 0xf2, 0xa9, 0x97, 0xaf, 0x96, 0xfc, 0xe5, 0xc5,
	0xcf, 0x85, 0xec, 0x93, 0x5f, 0x81, 0x52, 0x04, 0x7e, 0x13, 0xda, 0x3a, 0x48, 0xd0, 0x16, 0x4a,
	0xce, 0x1f, 0xa2, 0x2e, 0x95, 0x35, 0x84, 0xc8, 0xee, 0x89, 0x86, 0xf3, 0x2e, 0x6f, 0x2f, 0x4a,
	0x94, 0x87, 0x22, 0x9a, 0xac, 0xc1, 0x94, 0x2d, 0xd6, 0x06, 0x62, 0xe1, 0x73, 0xfe, 0xfb, 0x69,
	0x9c, 0xbf, 0x6f, 0xa7, 0xfa, 0x89, 0x71, 0x78, 0xe5, 0x31, 0x58, 0xe1, 0xe5, 0x82, 0x20, 0x6b,
	0xdd, 0x1d, 0xf5, 0xd8, 0xe8, 0x98, 0x6d, 0x53, 0x87, 0x4b, 0x61, 0x89, 0x61, 0x9d, 0x3d, 0x80,
	0x0a, 0xda, 0x64, 0x3b, 0xc0, 0x24, 0xad, 0xea, 0x99, 0x65, 0xc2, 0x5b, 0x15, 0x9d, 0x3f, 0xa4,
	0xd2, 0x4a, 0x12, 0xa8, 0x1d, 0x72, 0xb1, 0xc5, 0x2a, 0x96, 0x8b, 0x4e, 0x4d, 0xa3, 0xa6, 0xda,
	0x4e, 0xe0, 0x86, 0x49, 0x75, 0xea, 0xe6, 0xb8, 0xf2, 0x38, 0xf8, 0x12, 0xf3, 0x9f, 0x19, 0x84,
	0xad, 0xa5, 0xeb, 0xb8, 0x83, 0xb1, 0xef, 0x71, 0x9b, 0xb5, 0x6c, 0x29, 0xad, 0xb5, 0x0c, 0xdd,
	0x74, 0xa0, 0x52, 0xf9, 0x47, 0x70, 0xf5, 0xe0, 0xaf, 0x39, 0x37, 0x19, 0x43, 0x72, 0x45, 0xdb,
	0x51, 0x1d, 0xdd, 0xf7, 0x90, 0x04, 0x8c, 0x7a, 0x4b, 0x87, 0x0a, 0xda, 0x61, 0x1b, 0x14, 0x06,
	0x6a, 0x6d, 0xd3, 0xd4, 0x6b, 0x0e, 0xcc, 0xa0, 0x5b, 0x8c, 0xb9, 0xc3, 0x98, 0x5a, 0x73, 0x8c,
	0x33, 0x1d, 0x66, 0xd1, 0x6d, 0xb6, 0x29, 0x61, 0xa8, 0x6d, 0xe9, 0xa6, 0x4d, 0xc3, 0xca, 0xa1,
	0x3d, 0xb0, 0x93, 0x02, 0xd6, 0xda, 0xe6, 0xb1, 0x81, 0x3f, 0x86, 0xcb, 0x29, 0xb8, 0x6e, 0x3b,
	0xaa, 0xd6, 0x32, 0xec, 0xa6, 0x5e, 0x87, 0x2b, 0x95, 0x27, 0xec, 0x96, 0x29, 0xc8, 0x44, 0x64,
	0x44, 0xb5, 0x3b, 0xb6, 0xf1, 0x99, 0x5c, 0x8f, 0x08, 0xcd, 0x97, 0x3a, 0x9f, 0xb4, 0x3b, 0xed,
	0x9a, 0xa3, 0x3b, 0xc1, 0x8a, 0x7c, 0xe8, 0xb8, 0x7d, 0x8a, 0x05, 0x96, 0xa9, 0xfc, 0x8d, 0x3f,
	0xaa, 0xf9, 0xdf, 0xe4, 0x7e, 0x5a, 0xd4, 0x7a, 0x1d, 0x77, 0x9c, 0x4f, 0x2d, 0xbd, 0xd3, 0x76,
	0x9a, 0x3a, 0x0e, 0x32, 0x1e, 0x00, 0xa2, 0x18, 0xd2, 0xe4, 0x47, 0x30, 0x93, 0x94, 0x9b, 0xb6,
	0x6a, 0xc1, 0x6c, 0x52, 0xde, 0xac, 0xb7, 0x6a, 0x30, 0x27, 0xe3, 0x97, 0x72, 0x4d, 0x33, 0x0f,
	0x1f, 0x56, 0xab, 0x70, 0x39, 0x09, 0x19, 0xba, 0xae, 0x3f, 0xbc, 0x5f, 0x85, 0x2b, 0x49, 0x6f,
	0xfa, 0xe1, 0xd1, 0x07, 0x70, 0x35, 0x55, 0xfe, 0x00, 0xae, 0xa1, 0x1b, 0xec, 0x86, 0x1c, 0x92,
	0x1f, 0x1f, 0xfd, 0x0c, 0xae, 0x27, 0xd5, 0x9f, 0x1c, 0x56, 0x0f, 0x21, 0x48, 0xaa, 0x1b, 0xd6,
	0x13, 0x98, 0xf7, 0xf7, 0x3a, 0x10, 0xab, 0x96, 0xd5, 0xd2, 0x1d, 0xb5, 0x75, 0x02, 0x0b, 0x32,
	0xdb, 0x12, 0xac, 0xeb, 0x35, 0x53, 0x77, 0x8c, 0x33, 0xb8, 0x91, 0x34, 0xd4, 0x54, 0xf3, 0x53,
	0xd5, 0x3c, 0x33, 0x4c, 0x58, 0x4c, 0x82, 0x34, 0x66, 0x9e, 0xb6, 0x6b, 0x49, 0xaf, 0x34, 0xfd,
	0x1d, 0xc7, 0x54, 0x21, 0x4c, 0xc5, 0x8e, 0x18, 0xb6, 0x99, 0xc4, 0xa8, 0x3f, 0x86, 0xa1, 0x24,
	0x76, 0x66, 0x99, 0x7c, 0x5b, 0xaf, 0x5f, 0x8a, 0x1d, 0xc1, 0xad, 0x64, 0x8d, 0xf8, 0x2c, 0xf0,
	0x67, 0x85, 0x1d, 0xe9, 0xe0, 0xef, 0x13, 0xa8, 0xc4, 0xee, 0x69, 0xb4, 0xda, 0x79, 0x61, 0x9f,
	0xda, 0xb1, 0x13, 0x1c, 0x46, 0x4e, 0x2d, 0xa8, 0xa4, 0x59, 0xd4, 0xdb, 0x9f, 0x98, 0x30, 0x83,
	0x76, 0x19, 0x6b, 0x47, 0x90, 0x46, 0xdb, 0x30, 0x1b, 0xd4, 0x2e, 0xeb, 0x1f, 0xa1, 0x24, 0xca,
	0xac, 0x73, 0x69, 0xb8, 0x5a, 0x73, 0x3a, 0xc7, 0xaa, 0xd1, 0xd2, 0xeb, 0x70, 0xb9, 0xf2, 0x4d,
	0xfc, 0x4a, 0x29, 0xee, 0x89, 0x7e, 0x40, 0xb5, 0x96, 0xae, 0xe2, 0x0e, 0x6e, 0x9f, 0x06, 0x14,
	0x92, 0x82, 0x34, 0x55, 0x5c, 0x87, 0x8a, 0x3f, 0x59, 0x18, 0xc1, 0xfa, 0x31, 0xd6, 0xed, 0x66,
	0xc7, 0xa0, 0x4b, 0xb9, 0x03, 0x6e, 0x5f, 0x86, 0xb7, 0x4f, 0x1d, 0x98, 0x45, 0xfb, 0x60, 0xf7,
	0x32, 0x05, 0xad, 0xed, 0x34, 0x61, 0xae, 0x52, 0x07, 0xab, 0xa2, 0xc5, 0xa2, 0x0d, 0xb0, 0x4e,
	0x7f, 0xfa, 0x61, 0xf9, 0x43, 0xca, 0x26, 0x50, 0x41, 0x05, 0xb0, 0xc6, 0x86, 0xea, 0xf1, 0xc7,
	0x30, 0x23, 0x41, 0x5b, 0x6f, 0x1d, 0xc3, 0x6c, 0xf5, 0x8f, 0xab, 0x8c, 0xf9, 0xed, 0xe7, 0xe7,
	0xe8, 0x3e, 0xe3, 0x98, 0x9a, 0x4b, 0x28, 0x6d, 0xca, 0x27, 0x18, 0xd1, 0x21, 0x76, 0x60, 0x20,
	0x10, 0x8d, 0x6c, 0x49, 0x58, 0x9c, 0x4e, 0x7b, 0xdf, 0xdb, 0xe2, 0x11, 0xb3, 0xe0, 0x9f, 0x2e,
	0x48, 0xb6, 0xb8, 0xc8, 0x77, 0xd1, 0xce, 0x76, 0x5c, 0x2c, 0xad, 0x3f, 0x60, 0xb1, 0x36, 0x88,
	0x87, 0x64, 0x8b, 0x0d, 0x5a, 0xdf, 0xce, 0xf5, 0x88, 0x2c, 0x34, 0xa5, 0xff, 0x9c, 0x22, 0x96,
	0x76, 0x3d, 0xf2, 0x28, 0x26, 0x8c, 0xa3, 0x8f, 0xdd, 0x69, 0xd6, 0x62, 0x99, 0x3f, 0xc8, 0xba,
	0x29, 0xad, 0xc5, 0x92, 0x6f, 0x85, 0x15, 0xa3, 0xcb, 0xde, 0x49, 0x83, 0xa4, 0xa7, 0xc7, 0xf2,
	0xc5, 0x8e, 0x2e, 0x7f, 0x3b, 0xac, 0x1b, 0x4a, 0xc1, 0xcd, 0x84, 0x5c, 0x3a, 0xd0, 0x42, 0x6f,
	0x17, 0x22, 0x11, 0x37, 0x62, 0x9f, 0x57, 0xf1, 0xfc, 0x47, 0xdf, 0x11, 0x62, 0x3e, 0x44, 0x3a,
	0x7e, 0xb0, 0x0f, 0x33, 0xe4, 0x43, 0x24, 0xe5, 0x76, 0x54, 0x39, 0x9a, 0x96, 0xdd, 0x74, 0x50,
	0xfa, 0xd3, 0x43, 0x4f, 0x0d, 0x34, 0x35, 0xa5, 0xa8, 0x7e, 0x28, 0x39, 0xb7, 0x52, 0x90, 0xd8,
	0x4e, 0x05, 0x87, 0x1f, 0xa5, 0x7c, 0x38, 0x26, 0x76, 0x2a, 0xf9, 0x05, 0x57, 0x5e, 0x42, 0xbf,
	0x8e, 0xdd, 0xce, 0x69, 0x50, 0xbb, 0xc9, 0x4b, 0x58, 0x28, 0xb0, 0xb7, 0x2e, 0x41, 0x7d, 0x97,
	0x5a, 0xe1, 0xaf, 0xaf, 0xf6, 0x94, 0xbf, 0xbf, 0xda, 0x53, 0xfe, 0xf5, 0x6a, 0x4f, 0x79, 0xba,
	0xc2, 0xfe, 0x76, 0xfd, 0xc1, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x96, 0xbe, 0xe3, 0x23, 0xf7,
	0x1e, 0x00, 0x00,
}
