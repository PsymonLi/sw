// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: evpn.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// EVPN RD/RT config types - manual or auto-generated
type EvpnCfg int32

const (
	EvpnCfg_EVPN_CFG_NONE   EvpnCfg = 0
	EvpnCfg_EVPN_CFG_MANUAL EvpnCfg = 1
	EvpnCfg_EVPN_CFG_AUTO   EvpnCfg = 2
)

var EvpnCfg_name = map[int32]string{
	0: "EVPN_CFG_NONE",
	1: "EVPN_CFG_MANUAL",
	2: "EVPN_CFG_AUTO",
}
var EvpnCfg_value = map[string]int32{
	"EVPN_CFG_NONE":   0,
	"EVPN_CFG_MANUAL": 1,
	"EVPN_CFG_AUTO":   2,
}

func (x EvpnCfg) String() string {
	return proto.EnumName(EvpnCfg_name, int32(x))
}
func (EvpnCfg) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{0} }

// EVPN route-target import/export type
type EvpnRtType int32

const (
	EvpnRtType_EVPN_RT_NONE          EvpnRtType = 0
	EvpnRtType_EVPN_RT_IMPORT        EvpnRtType = 1
	EvpnRtType_EVPN_RT_EXPORT        EvpnRtType = 2
	EvpnRtType_EVPN_RT_IMPORT_EXPORT EvpnRtType = 3
)

var EvpnRtType_name = map[int32]string{
	0: "EVPN_RT_NONE",
	1: "EVPN_RT_IMPORT",
	2: "EVPN_RT_EXPORT",
	3: "EVPN_RT_IMPORT_EXPORT",
}
var EvpnRtType_value = map[string]int32{
	"EVPN_RT_NONE":          0,
	"EVPN_RT_IMPORT":        1,
	"EVPN_RT_EXPORT":        2,
	"EVPN_RT_IMPORT_EXPORT": 3,
}

func (x EvpnRtType) String() string {
	return proto.EnumName(EvpnRtType_name, int32(x))
}
func (EvpnRtType) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{1} }

// EVPN route source local/remote
type EvpnSource int32

const (
	EvpnSource_EVPN_SOURCE_NONE   EvpnSource = 0
	EvpnSource_EVPN_SOURCE_LOCAL  EvpnSource = 1
	EvpnSource_EVPN_SOURCE_REMOTE EvpnSource = 2
)

var EvpnSource_name = map[int32]string{
	0: "EVPN_SOURCE_NONE",
	1: "EVPN_SOURCE_LOCAL",
	2: "EVPN_SOURCE_REMOTE",
}
var EvpnSource_value = map[string]int32{
	"EVPN_SOURCE_NONE":   0,
	"EVPN_SOURCE_LOCAL":  1,
	"EVPN_SOURCE_REMOTE": 2,
}

func (x EvpnSource) String() string {
	return proto.EnumName(EvpnSource_name, int32(x))
}
func (EvpnSource) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{2} }

// EVPN operational status
type EvpnOperStatus int32

const (
	EvpnOperStatus_EVPN_OPER_STATUS_NONE       EvpnOperStatus = 0
	EvpnOperStatus_EVPN_OPER_STATUS_UP         EvpnOperStatus = 1
	EvpnOperStatus_EVPN_OPER_STATUS_DOWN       EvpnOperStatus = 2
	EvpnOperStatus_EVPN_OPER_STATUS_GOING_UP   EvpnOperStatus = 3
	EvpnOperStatus_EVPN_OPER_STATUS_GOING_DOWN EvpnOperStatus = 4
	EvpnOperStatus_EVPN_OPER_STATUS_ACT_FAILED EvpnOperStatus = 5
	EvpnOperStatus_EVPN_OPER_STATUS_QUIESCING  EvpnOperStatus = 6
	EvpnOperStatus_EVPN_OPER_STATUS_NOT_READY  EvpnOperStatus = 7
	EvpnOperStatus_EVPN_OPER_STATUS_FAILED     EvpnOperStatus = 8
	EvpnOperStatus_EVPN_OPER_STATUS_PRNT_FAILD EvpnOperStatus = 9
	EvpnOperStatus_EVPN_OPER_STATUS_FAILD_PERM EvpnOperStatus = 10
	EvpnOperStatus_EVPN_OPER_STATUS_FAILING    EvpnOperStatus = 11
)

var EvpnOperStatus_name = map[int32]string{
	0:  "EVPN_OPER_STATUS_NONE",
	1:  "EVPN_OPER_STATUS_UP",
	2:  "EVPN_OPER_STATUS_DOWN",
	3:  "EVPN_OPER_STATUS_GOING_UP",
	4:  "EVPN_OPER_STATUS_GOING_DOWN",
	5:  "EVPN_OPER_STATUS_ACT_FAILED",
	6:  "EVPN_OPER_STATUS_QUIESCING",
	7:  "EVPN_OPER_STATUS_NOT_READY",
	8:  "EVPN_OPER_STATUS_FAILED",
	9:  "EVPN_OPER_STATUS_PRNT_FAILD",
	10: "EVPN_OPER_STATUS_FAILD_PERM",
	11: "EVPN_OPER_STATUS_FAILING",
}
var EvpnOperStatus_value = map[string]int32{
	"EVPN_OPER_STATUS_NONE":       0,
	"EVPN_OPER_STATUS_UP":         1,
	"EVPN_OPER_STATUS_DOWN":       2,
	"EVPN_OPER_STATUS_GOING_UP":   3,
	"EVPN_OPER_STATUS_GOING_DOWN": 4,
	"EVPN_OPER_STATUS_ACT_FAILED": 5,
	"EVPN_OPER_STATUS_QUIESCING":  6,
	"EVPN_OPER_STATUS_NOT_READY":  7,
	"EVPN_OPER_STATUS_FAILED":     8,
	"EVPN_OPER_STATUS_PRNT_FAILD": 9,
	"EVPN_OPER_STATUS_FAILD_PERM": 10,
	"EVPN_OPER_STATUS_FAILING":    11,
}

func (x EvpnOperStatus) String() string {
	return proto.EnumName(EvpnOperStatus_name, int32(x))
}
func (EvpnOperStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{3} }

type EvpnOperReason int32

const (
	EvpnOperReason_EVPN_OPER_REASON_INVALID    EvpnOperReason = 0
	EvpnOperReason_EVPN_OPER_REASON_NONE       EvpnOperReason = 1
	EvpnOperReason_EVPN_ENTITY_NOT_UP          EvpnOperReason = 2
	EvpnOperReason_EVPN_ADMIN_CONFIG           EvpnOperReason = 3
	EvpnOperReason_EVPN_RESOURCE_FAILURE       EvpnOperReason = 4
	EvpnOperReason_EVPN_NO_IF_INFO             EvpnOperReason = 5
	EvpnOperReason_EVPN_EVI_NOT_UP             EvpnOperReason = 6
	EvpnOperReason_EVPN_BD_NOT_UP              EvpnOperReason = 7
	EvpnOperReason_EVPN_NO_ROUTE_DISTINGUISHER EvpnOperReason = 8
	EvpnOperReason_EVPN_ROUTE_DIST_CLASH       EvpnOperReason = 9
	EvpnOperReason_EVPN_NO_ESI                 EvpnOperReason = 10
	EvpnOperReason_EVPN_BAD_VNI                EvpnOperReason = 11
	EvpnOperReason_EVPN_VNI_CLASH              EvpnOperReason = 12
	EvpnOperReason_EVPN_VLAN_SUB_IF_EVI_CLASH  EvpnOperReason = 13
	EvpnOperReason_EVPN_NO_BGP_ID              EvpnOperReason = 14
	EvpnOperReason_EVPN_RT_TYPE_CLASH          EvpnOperReason = 15
	EvpnOperReason_EVPN_NO_RT                  EvpnOperReason = 16
	EvpnOperReason_EVPN_IP_VRF_NOT_UP          EvpnOperReason = 17
	EvpnOperReason_EVPN_NO_SYSTEM_MAC          EvpnOperReason = 18
	EvpnOperReason_EVPN_RT_CLASH               EvpnOperReason = 19
	EvpnOperReason_EVPN_NO_MCAST_GROUP         EvpnOperReason = 20
	EvpnOperReason_EVPN_NO_SOURCE_IP           EvpnOperReason = 21
	EvpnOperReason_EVPN_BAD_TNNL_DEST_TYPE     EvpnOperReason = 22
	EvpnOperReason_EVPN_NO_ROUTERS_MAC         EvpnOperReason = 23
)

var EvpnOperReason_name = map[int32]string{
	0:  "EVPN_OPER_REASON_INVALID",
	1:  "EVPN_OPER_REASON_NONE",
	2:  "EVPN_ENTITY_NOT_UP",
	3:  "EVPN_ADMIN_CONFIG",
	4:  "EVPN_RESOURCE_FAILURE",
	5:  "EVPN_NO_IF_INFO",
	6:  "EVPN_EVI_NOT_UP",
	7:  "EVPN_BD_NOT_UP",
	8:  "EVPN_NO_ROUTE_DISTINGUISHER",
	9:  "EVPN_ROUTE_DIST_CLASH",
	10: "EVPN_NO_ESI",
	11: "EVPN_BAD_VNI",
	12: "EVPN_VNI_CLASH",
	13: "EVPN_VLAN_SUB_IF_EVI_CLASH",
	14: "EVPN_NO_BGP_ID",
	15: "EVPN_RT_TYPE_CLASH",
	16: "EVPN_NO_RT",
	17: "EVPN_IP_VRF_NOT_UP",
	18: "EVPN_NO_SYSTEM_MAC",
	19: "EVPN_RT_CLASH",
	20: "EVPN_NO_MCAST_GROUP",
	21: "EVPN_NO_SOURCE_IP",
	22: "EVPN_BAD_TNNL_DEST_TYPE",
	23: "EVPN_NO_ROUTERS_MAC",
}
var EvpnOperReason_value = map[string]int32{
	"EVPN_OPER_REASON_INVALID":    0,
	"EVPN_OPER_REASON_NONE":       1,
	"EVPN_ENTITY_NOT_UP":          2,
	"EVPN_ADMIN_CONFIG":           3,
	"EVPN_RESOURCE_FAILURE":       4,
	"EVPN_NO_IF_INFO":             5,
	"EVPN_EVI_NOT_UP":             6,
	"EVPN_BD_NOT_UP":              7,
	"EVPN_NO_ROUTE_DISTINGUISHER": 8,
	"EVPN_ROUTE_DIST_CLASH":       9,
	"EVPN_NO_ESI":                 10,
	"EVPN_BAD_VNI":                11,
	"EVPN_VNI_CLASH":              12,
	"EVPN_VLAN_SUB_IF_EVI_CLASH":  13,
	"EVPN_NO_BGP_ID":              14,
	"EVPN_RT_TYPE_CLASH":          15,
	"EVPN_NO_RT":                  16,
	"EVPN_IP_VRF_NOT_UP":          17,
	"EVPN_NO_SYSTEM_MAC":          18,
	"EVPN_RT_CLASH":               19,
	"EVPN_NO_MCAST_GROUP":         20,
	"EVPN_NO_SOURCE_IP":           21,
	"EVPN_BAD_TNNL_DEST_TYPE":     22,
	"EVPN_NO_ROUTERS_MAC":         23,
}

func (x EvpnOperReason) String() string {
	return proto.EnumName(EvpnOperReason_name, int32(x))
}
func (EvpnOperReason) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{4} }

// EVPN EVI configuration
type EvpnEviSpec struct {
	// unique key/identifier of EVPN EVI
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to subnet
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory,immutable`
	// manual or auto route-distinguisher
	AutoRD EvpnCfg `protobuf:"varint,3,opt,name=AutoRD,proto3,enum=pds.EvpnCfg" json:"AutoRD,omitempty"`
	// 8 byte route-distinguisher, in case of manual configuration
	RD []byte `protobuf:"bytes,4,opt,name=RD,proto3" json:"RD,omitempty"`
	// manual or auto route-target. in case of manual route-target,
	// route-targets should be configured with EvpnEviRtSpec
	AutoRT EvpnCfg `protobuf:"varint,5,opt,name=AutoRT,proto3,enum=pds.EvpnCfg" json:"AutoRT,omitempty"`
	// route-target type, applicable to auto route-targets only
	RTType EvpnRtType `protobuf:"varint,6,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
}

func (m *EvpnEviSpec) Reset()                    { *m = EvpnEviSpec{} }
func (m *EvpnEviSpec) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviSpec) ProtoMessage()               {}
func (*EvpnEviSpec) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{0} }

func (m *EvpnEviSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnEviSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviSpec) GetAutoRD() EvpnCfg {
	if m != nil {
		return m.AutoRD
	}
	return EvpnCfg_EVPN_CFG_NONE
}

func (m *EvpnEviSpec) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *EvpnEviSpec) GetAutoRT() EvpnCfg {
	if m != nil {
		return m.AutoRT
	}
	return EvpnCfg_EVPN_CFG_NONE
}

func (m *EvpnEviSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN EVI, if any
type EvpnEviStatus struct {
	// in use route-distinguisher of the EVI
	RD []byte `protobuf:"bytes,1,opt,name=RD,proto3" json:"RD,omitempty"`
	// oper status
	Status EvpnOperStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=pds.EvpnOperStatus" json:"Status,omitempty"`
}

func (m *EvpnEviStatus) Reset()                    { *m = EvpnEviStatus{} }
func (m *EvpnEviStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviStatus) ProtoMessage()               {}
func (*EvpnEviStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{1} }

func (m *EvpnEviStatus) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *EvpnEviStatus) GetStatus() EvpnOperStatus {
	if m != nil {
		return m.Status
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

// EVPN EVI object
type EvpnEvi struct {
	Spec   *EvpnEviSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *EvpnEviStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnEvi) Reset()                    { *m = EvpnEvi{} }
func (m *EvpnEvi) String() string            { return proto.CompactTextString(m) }
func (*EvpnEvi) ProtoMessage()               {}
func (*EvpnEvi) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{2} }

func (m *EvpnEvi) GetSpec() *EvpnEviSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnEvi) GetStatus() *EvpnEviStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN EVI create and update response
type EvpnEviResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnEviResponse) Reset()                    { *m = EvpnEviResponse{} }
func (m *EvpnEviResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviResponse) ProtoMessage()               {}
func (*EvpnEviResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{3} }

func (m *EvpnEviResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI create and update request
type EvpnEviRequest struct {
	Request []*EvpnEviSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviRequest) Reset()                    { *m = EvpnEviRequest{} }
func (m *EvpnEviRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRequest) ProtoMessage()               {}
func (*EvpnEviRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{4} }

func (m *EvpnEviRequest) GetRequest() []*EvpnEviSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI key parameters
type EvpnEviKey struct {
	// reference to subnet spec
	SubnetId []byte `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
}

func (m *EvpnEviKey) Reset()                    { *m = EvpnEviKey{} }
func (m *EvpnEviKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviKey) ProtoMessage()               {}
func (*EvpnEviKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{5} }

func (m *EvpnEviKey) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

// EVPN EVI key handle for get and delete
type EvpnEviKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnEviKeyHandle_Id
	//	*EvpnEviKeyHandle_Key
	IdOrKey isEvpnEviKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *EvpnEviKeyHandle) Reset()                    { *m = EvpnEviKeyHandle{} }
func (m *EvpnEviKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviKeyHandle) ProtoMessage()               {}
func (*EvpnEviKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{6} }

type isEvpnEviKeyHandle_IdOrKey interface {
	isEvpnEviKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnEviKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnEviKeyHandle_Key struct {
	Key *EvpnEviKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*EvpnEviKeyHandle_Id) isEvpnEviKeyHandle_IdOrKey()  {}
func (*EvpnEviKeyHandle_Key) isEvpnEviKeyHandle_IdOrKey() {}

func (m *EvpnEviKeyHandle) GetIdOrKey() isEvpnEviKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnEviKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnEviKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnEviKeyHandle) GetKey() *EvpnEviKey {
	if x, ok := m.GetIdOrKey().(*EvpnEviKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EvpnEviKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EvpnEviKeyHandle_OneofMarshaler, _EvpnEviKeyHandle_OneofUnmarshaler, _EvpnEviKeyHandle_OneofSizer, []interface{}{
		(*EvpnEviKeyHandle_Id)(nil),
		(*EvpnEviKeyHandle_Key)(nil),
	}
}

func _EvpnEviKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EvpnEviKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnEviKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *EvpnEviKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EvpnEviKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _EvpnEviKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EvpnEviKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &EvpnEviKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EvpnEviKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &EvpnEviKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EvpnEviKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EvpnEviKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnEviKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *EvpnEviKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EVPN EVI delete request
type EvpnEviDeleteRequest struct {
	Request []*EvpnEviKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviDeleteRequest) Reset()                    { *m = EvpnEviDeleteRequest{} }
func (m *EvpnEviDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviDeleteRequest) ProtoMessage()               {}
func (*EvpnEviDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{7} }

func (m *EvpnEviDeleteRequest) GetRequest() []*EvpnEviKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI delete response
type EvpnEviDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnEviDeleteResponse) Reset()                    { *m = EvpnEviDeleteResponse{} }
func (m *EvpnEviDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviDeleteResponse) ProtoMessage()               {}
func (*EvpnEviDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{8} }

func (m *EvpnEviDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI get request
type EvpnEviGetRequest struct {
	Request []*EvpnEviKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviGetRequest) Reset()                    { *m = EvpnEviGetRequest{} }
func (m *EvpnEviGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviGetRequest) ProtoMessage()               {}
func (*EvpnEviGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{9} }

func (m *EvpnEviGetRequest) GetRequest() []*EvpnEviKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI get response
type EvpnEviGetResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnEvi `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnEviGetResponse) Reset()                    { *m = EvpnEviGetResponse{} }
func (m *EvpnEviGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviGetResponse) ProtoMessage()               {}
func (*EvpnEviGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{10} }

func (m *EvpnEviGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnEviGetResponse) GetResponse() []*EvpnEvi {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN IP VRF configuration
type EvpnIpVrfSpec struct {
	// unique key/identifier of EVPN IP VRF
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to VPC
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// VxLAN vnid
	VNI uint32 `protobuf:"varint,3,opt,name=VNI,proto3" json:"VNI,omitempty"`
	// 8 byte manual route-distinguisher, if not auto route-distinguisher
	RD []byte `protobuf:"bytes,4,opt,name=RD,proto3" json:"RD,omitempty"`
}

func (m *EvpnIpVrfSpec) Reset()                    { *m = EvpnIpVrfSpec{} }
func (m *EvpnIpVrfSpec) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfSpec) ProtoMessage()               {}
func (*EvpnIpVrfSpec) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{11} }

func (m *EvpnIpVrfSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnIpVrfSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfSpec) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *EvpnIpVrfSpec) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

// operational status of EVPN IP VRF, if any
type EvpnIpVrfStatus struct {
}

func (m *EvpnIpVrfStatus) Reset()                    { *m = EvpnIpVrfStatus{} }
func (m *EvpnIpVrfStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfStatus) ProtoMessage()               {}
func (*EvpnIpVrfStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{12} }

// EVPN IP VRF object
type EvpnIpVrf struct {
	Spec   *EvpnIpVrfSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *EvpnIpVrfStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnIpVrf) Reset()                    { *m = EvpnIpVrf{} }
func (m *EvpnIpVrf) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrf) ProtoMessage()               {}
func (*EvpnIpVrf) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{13} }

func (m *EvpnIpVrf) GetSpec() *EvpnIpVrfSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnIpVrf) GetStatus() *EvpnIpVrfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN IP VRF create and update request
type EvpnIpVrfRequest struct {
	Request []*EvpnIpVrfSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfRequest) Reset()                    { *m = EvpnIpVrfRequest{} }
func (m *EvpnIpVrfRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRequest) ProtoMessage()               {}
func (*EvpnIpVrfRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{14} }

func (m *EvpnIpVrfRequest) GetRequest() []*EvpnIpVrfSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF create and update response
type EvpnIpVrfResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnIpVrfResponse) Reset()                    { *m = EvpnIpVrfResponse{} }
func (m *EvpnIpVrfResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfResponse) ProtoMessage()               {}
func (*EvpnIpVrfResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{15} }

func (m *EvpnIpVrfResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF key parameters
type EvpnIpVrfKey struct {
	// reference to vpc spec
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
}

func (m *EvpnIpVrfKey) Reset()                    { *m = EvpnIpVrfKey{} }
func (m *EvpnIpVrfKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfKey) ProtoMessage()               {}
func (*EvpnIpVrfKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{16} }

func (m *EvpnIpVrfKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

// EVPN IP VRF key handle
type EvpnIpVrfKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnIpVrfKeyHandle_Id
	//	*EvpnIpVrfKeyHandle_Key
	IdOrKey isEvpnIpVrfKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *EvpnIpVrfKeyHandle) Reset()                    { *m = EvpnIpVrfKeyHandle{} }
func (m *EvpnIpVrfKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfKeyHandle) ProtoMessage()               {}
func (*EvpnIpVrfKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{17} }

type isEvpnIpVrfKeyHandle_IdOrKey interface {
	isEvpnIpVrfKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnIpVrfKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnIpVrfKeyHandle_Key struct {
	Key *EvpnIpVrfKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*EvpnIpVrfKeyHandle_Id) isEvpnIpVrfKeyHandle_IdOrKey()  {}
func (*EvpnIpVrfKeyHandle_Key) isEvpnIpVrfKeyHandle_IdOrKey() {}

func (m *EvpnIpVrfKeyHandle) GetIdOrKey() isEvpnIpVrfKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnIpVrfKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnIpVrfKeyHandle) GetKey() *EvpnIpVrfKey {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EvpnIpVrfKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EvpnIpVrfKeyHandle_OneofMarshaler, _EvpnIpVrfKeyHandle_OneofUnmarshaler, _EvpnIpVrfKeyHandle_OneofSizer, []interface{}{
		(*EvpnIpVrfKeyHandle_Id)(nil),
		(*EvpnIpVrfKeyHandle_Key)(nil),
	}
}

func _EvpnIpVrfKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EvpnIpVrfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnIpVrfKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *EvpnIpVrfKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EvpnIpVrfKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _EvpnIpVrfKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EvpnIpVrfKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &EvpnIpVrfKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EvpnIpVrfKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &EvpnIpVrfKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EvpnIpVrfKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EvpnIpVrfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnIpVrfKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *EvpnIpVrfKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EVPN IP VRF delete request
type EvpnIpVrfDeleteRequest struct {
	Request []*EvpnIpVrfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfDeleteRequest) Reset()                    { *m = EvpnIpVrfDeleteRequest{} }
func (m *EvpnIpVrfDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfDeleteRequest) ProtoMessage()               {}
func (*EvpnIpVrfDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{18} }

func (m *EvpnIpVrfDeleteRequest) GetRequest() []*EvpnIpVrfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF delete response
type EvpnIpVrfDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnIpVrfDeleteResponse) Reset()                    { *m = EvpnIpVrfDeleteResponse{} }
func (m *EvpnIpVrfDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfDeleteResponse) ProtoMessage()               {}
func (*EvpnIpVrfDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{19} }

func (m *EvpnIpVrfDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF get request
type EvpnIpVrfGetRequest struct {
	Request []*EvpnIpVrfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfGetRequest) Reset()                    { *m = EvpnIpVrfGetRequest{} }
func (m *EvpnIpVrfGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfGetRequest) ProtoMessage()               {}
func (*EvpnIpVrfGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{20} }

func (m *EvpnIpVrfGetRequest) GetRequest() []*EvpnIpVrfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF get response
type EvpnIpVrfGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnIpVrf `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnIpVrfGetResponse) Reset()                    { *m = EvpnIpVrfGetResponse{} }
func (m *EvpnIpVrfGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfGetResponse) ProtoMessage()               {}
func (*EvpnIpVrfGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{21} }

func (m *EvpnIpVrfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnIpVrfGetResponse) GetResponse() []*EvpnIpVrf {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN EVI RT Configuration
type EvpnEviRtSpec struct {
	// unique key/identifier of EVPN EVI RT
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to subnet
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory,immutable`
	// 8 byte route-target. first two octets represent type of extended community
	// octet 1: type or type-high, only 0,1 and 2 are allowed types
	// octet 2: sub-type or type-low, should always be 2 for route-target extended
	// community
	RT []byte `protobuf:"bytes,3,opt,name=RT,proto3" json:"RT,omitempty" meta:mandatory,immutable`
	// route-target import/export type. EVPN_RT_NONE is an invalid type for manual route-targets
	RTType EvpnRtType `protobuf:"varint,4,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
}

func (m *EvpnEviRtSpec) Reset()                    { *m = EvpnEviRtSpec{} }
func (m *EvpnEviRtSpec) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtSpec) ProtoMessage()               {}
func (*EvpnEviRtSpec) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{22} }

func (m *EvpnEviRtSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnEviRtSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviRtSpec) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

func (m *EvpnEviRtSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN EVI RT, if any
type EvpnEviRtStatus struct {
}

func (m *EvpnEviRtStatus) Reset()                    { *m = EvpnEviRtStatus{} }
func (m *EvpnEviRtStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtStatus) ProtoMessage()               {}
func (*EvpnEviRtStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{23} }

// EVPN EVI RT object
type EvpnEviRt struct {
	Spec   *EvpnEviRtSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *EvpnEviRtStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnEviRt) Reset()                    { *m = EvpnEviRt{} }
func (m *EvpnEviRt) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRt) ProtoMessage()               {}
func (*EvpnEviRt) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{24} }

func (m *EvpnEviRt) GetSpec() *EvpnEviRtSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnEviRt) GetStatus() *EvpnEviRtStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN EVI RT create and update response
type EvpnEviRtResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnEviRtResponse) Reset()                    { *m = EvpnEviRtResponse{} }
func (m *EvpnEviRtResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtResponse) ProtoMessage()               {}
func (*EvpnEviRtResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{25} }

func (m *EvpnEviRtResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EvpnEviRtSpec create and update request
type EvpnEviRtRequest struct {
	Request []*EvpnEviRtSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviRtRequest) Reset()                    { *m = EvpnEviRtRequest{} }
func (m *EvpnEviRtRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtRequest) ProtoMessage()               {}
func (*EvpnEviRtRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{26} }

func (m *EvpnEviRtRequest) GetRequest() []*EvpnEviRtSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT key
type EvpnEviRtKey struct {
	// reference to subnet spec
	SubnetId []byte `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	RT       []byte `protobuf:"bytes,2,opt,name=RT,proto3" json:"RT,omitempty"`
}

func (m *EvpnEviRtKey) Reset()                    { *m = EvpnEviRtKey{} }
func (m *EvpnEviRtKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtKey) ProtoMessage()               {}
func (*EvpnEviRtKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{27} }

func (m *EvpnEviRtKey) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviRtKey) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

// EVPN EVI RT Key Handle
type EvpnEviRtKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnEviRtKeyHandle_Id
	//	*EvpnEviRtKeyHandle_Key
	IdOrKey isEvpnEviRtKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *EvpnEviRtKeyHandle) Reset()                    { *m = EvpnEviRtKeyHandle{} }
func (m *EvpnEviRtKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtKeyHandle) ProtoMessage()               {}
func (*EvpnEviRtKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{28} }

type isEvpnEviRtKeyHandle_IdOrKey interface {
	isEvpnEviRtKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnEviRtKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnEviRtKeyHandle_Key struct {
	Key *EvpnEviRtKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*EvpnEviRtKeyHandle_Id) isEvpnEviRtKeyHandle_IdOrKey()  {}
func (*EvpnEviRtKeyHandle_Key) isEvpnEviRtKeyHandle_IdOrKey() {}

func (m *EvpnEviRtKeyHandle) GetIdOrKey() isEvpnEviRtKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnEviRtKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnEviRtKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnEviRtKeyHandle) GetKey() *EvpnEviRtKey {
	if x, ok := m.GetIdOrKey().(*EvpnEviRtKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EvpnEviRtKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EvpnEviRtKeyHandle_OneofMarshaler, _EvpnEviRtKeyHandle_OneofUnmarshaler, _EvpnEviRtKeyHandle_OneofSizer, []interface{}{
		(*EvpnEviRtKeyHandle_Id)(nil),
		(*EvpnEviRtKeyHandle_Key)(nil),
	}
}

func _EvpnEviRtKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EvpnEviRtKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnEviRtKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *EvpnEviRtKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EvpnEviRtKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _EvpnEviRtKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EvpnEviRtKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &EvpnEviRtKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EvpnEviRtKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &EvpnEviRtKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EvpnEviRtKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EvpnEviRtKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnEviRtKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *EvpnEviRtKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EVPN EVI RT delete request
type EvpnEviRtDeleteRequest struct {
	Request []*EvpnEviRtKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviRtDeleteRequest) Reset()                    { *m = EvpnEviRtDeleteRequest{} }
func (m *EvpnEviRtDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtDeleteRequest) ProtoMessage()               {}
func (*EvpnEviRtDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{29} }

func (m *EvpnEviRtDeleteRequest) GetRequest() []*EvpnEviRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT delete response
type EvpnEviRtDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnEviRtDeleteResponse) Reset()                    { *m = EvpnEviRtDeleteResponse{} }
func (m *EvpnEviRtDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtDeleteResponse) ProtoMessage()               {}
func (*EvpnEviRtDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{30} }

func (m *EvpnEviRtDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI RT get request
type EvpnEviRtGetRequest struct {
	Request []*EvpnEviRtKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnEviRtGetRequest) Reset()                    { *m = EvpnEviRtGetRequest{} }
func (m *EvpnEviRtGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtGetRequest) ProtoMessage()               {}
func (*EvpnEviRtGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{31} }

func (m *EvpnEviRtGetRequest) GetRequest() []*EvpnEviRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT get response
type EvpnEviRtGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnEviRt `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnEviRtGetResponse) Reset()                    { *m = EvpnEviRtGetResponse{} }
func (m *EvpnEviRtGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnEviRtGetResponse) ProtoMessage()               {}
func (*EvpnEviRtGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{32} }

func (m *EvpnEviRtGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnEviRtGetResponse) GetResponse() []*EvpnEviRt {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN EVI RT create/update request
type EvpnIpVrfRtRequest struct {
	Request []*EvpnIpVrfRtSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfRtRequest) Reset()                    { *m = EvpnIpVrfRtRequest{} }
func (m *EvpnIpVrfRtRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtRequest) ProtoMessage()               {}
func (*EvpnIpVrfRtRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{33} }

func (m *EvpnIpVrfRtRequest) GetRequest() []*EvpnIpVrfRtSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT Configuration
type EvpnIpVrfRtSpec struct {
	// unique key/identifier of EVPN IP VRF
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to VPC
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// 8 byte route-target. first two octets represent type of extended community
	// octet 1: type or type-high, only 0,1 and 2 are allowed types
	// octet 2: sub-type or type-low, should always be 2 for route-target extended
	// community
	RT []byte `protobuf:"bytes,3,opt,name=RT,proto3" json:"RT,omitempty" meta:mandatory,immutable`
	// route-target import/export type. EVPN_RT_NONE is an invalid type for manual route-targets
	RTType EvpnRtType `protobuf:"varint,4,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
}

func (m *EvpnIpVrfRtSpec) Reset()                    { *m = EvpnIpVrfRtSpec{} }
func (m *EvpnIpVrfRtSpec) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtSpec) ProtoMessage()               {}
func (*EvpnIpVrfRtSpec) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{34} }

func (m *EvpnIpVrfRtSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN IP VRF RT, if any
type EvpnIpVrfRtStatus struct {
}

func (m *EvpnIpVrfRtStatus) Reset()                    { *m = EvpnIpVrfRtStatus{} }
func (m *EvpnIpVrfRtStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtStatus) ProtoMessage()               {}
func (*EvpnIpVrfRtStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{35} }

// EVPN IP VRF RT object
type EvpnIpVrfRt struct {
	Spec   *EvpnIpVrfRtSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *EvpnIpVrfRtStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnIpVrfRt) Reset()                    { *m = EvpnIpVrfRt{} }
func (m *EvpnIpVrfRt) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRt) ProtoMessage()               {}
func (*EvpnIpVrfRt) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{36} }

func (m *EvpnIpVrfRt) GetSpec() *EvpnIpVrfRtSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnIpVrfRt) GetStatus() *EvpnIpVrfRtStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN IP VRF RT create and update response
type EvpnIpVrfRtResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnIpVrfRtResponse) Reset()                    { *m = EvpnIpVrfRtResponse{} }
func (m *EvpnIpVrfRtResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtResponse) ProtoMessage()               {}
func (*EvpnIpVrfRtResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{37} }

func (m *EvpnIpVrfRtResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF RT key parameters
type EvpnIpVrfRtKey struct {
	// reference to vpc spec
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	RT    []byte `protobuf:"bytes,2,opt,name=RT,proto3" json:"RT,omitempty"`
}

func (m *EvpnIpVrfRtKey) Reset()                    { *m = EvpnIpVrfRtKey{} }
func (m *EvpnIpVrfRtKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtKey) ProtoMessage()               {}
func (*EvpnIpVrfRtKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{38} }

func (m *EvpnIpVrfRtKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfRtKey) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

// EVPN IP VRF RT key handle
type EvpnIpVrfRtKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnIpVrfRtKeyHandle_Id
	//	*EvpnIpVrfRtKeyHandle_Key
	IdOrKey isEvpnIpVrfRtKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *EvpnIpVrfRtKeyHandle) Reset()                    { *m = EvpnIpVrfRtKeyHandle{} }
func (m *EvpnIpVrfRtKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtKeyHandle) ProtoMessage()               {}
func (*EvpnIpVrfRtKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{39} }

type isEvpnIpVrfRtKeyHandle_IdOrKey interface {
	isEvpnIpVrfRtKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnIpVrfRtKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnIpVrfRtKeyHandle_Key struct {
	Key *EvpnIpVrfRtKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*EvpnIpVrfRtKeyHandle_Id) isEvpnIpVrfRtKeyHandle_IdOrKey()  {}
func (*EvpnIpVrfRtKeyHandle_Key) isEvpnIpVrfRtKeyHandle_IdOrKey() {}

func (m *EvpnIpVrfRtKeyHandle) GetIdOrKey() isEvpnIpVrfRtKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnIpVrfRtKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfRtKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnIpVrfRtKeyHandle) GetKey() *EvpnIpVrfRtKey {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfRtKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EvpnIpVrfRtKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EvpnIpVrfRtKeyHandle_OneofMarshaler, _EvpnIpVrfRtKeyHandle_OneofUnmarshaler, _EvpnIpVrfRtKeyHandle_OneofSizer, []interface{}{
		(*EvpnIpVrfRtKeyHandle_Id)(nil),
		(*EvpnIpVrfRtKeyHandle_Key)(nil),
	}
}

func _EvpnIpVrfRtKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EvpnIpVrfRtKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnIpVrfRtKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *EvpnIpVrfRtKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EvpnIpVrfRtKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _EvpnIpVrfRtKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EvpnIpVrfRtKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &EvpnIpVrfRtKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EvpnIpVrfRtKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &EvpnIpVrfRtKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EvpnIpVrfRtKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EvpnIpVrfRtKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *EvpnIpVrfRtKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *EvpnIpVrfRtKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EVPN IP VRF RT delete request
type EvpnIpVrfRtDeleteRequest struct {
	Request []*EvpnIpVrfRtKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfRtDeleteRequest) Reset()                    { *m = EvpnIpVrfRtDeleteRequest{} }
func (m *EvpnIpVrfRtDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtDeleteRequest) ProtoMessage()               {}
func (*EvpnIpVrfRtDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{40} }

func (m *EvpnIpVrfRtDeleteRequest) GetRequest() []*EvpnIpVrfRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT delete response
type EvpnIpVrfRtDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *EvpnIpVrfRtDeleteResponse) Reset()                    { *m = EvpnIpVrfRtDeleteResponse{} }
func (m *EvpnIpVrfRtDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtDeleteResponse) ProtoMessage()               {}
func (*EvpnIpVrfRtDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{41} }

func (m *EvpnIpVrfRtDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF RT get request
type EvpnIpVrfRtGetRequest struct {
	Request []*EvpnIpVrfRtKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnIpVrfRtGetRequest) Reset()                    { *m = EvpnIpVrfRtGetRequest{} }
func (m *EvpnIpVrfRtGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtGetRequest) ProtoMessage()               {}
func (*EvpnIpVrfRtGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{42} }

func (m *EvpnIpVrfRtGetRequest) GetRequest() []*EvpnIpVrfRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT get response
type EvpnIpVrfRtGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnIpVrfRt `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnIpVrfRtGetResponse) Reset()                    { *m = EvpnIpVrfRtGetResponse{} }
func (m *EvpnIpVrfRtGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtGetResponse) ProtoMessage()               {}
func (*EvpnIpVrfRtGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{43} }

func (m *EvpnIpVrfRtGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnIpVrfRtGetResponse) GetResponse() []*EvpnIpVrfRt {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN MAC IP table entries
type EvpnMacIpStatus struct {
	EVIId      uint32     `protobuf:"varint,1,opt,name=EVIId,proto3" json:"EVIId,omitempty"`
	EthTagID   uint32     `protobuf:"varint,2,opt,name=EthTagID,proto3" json:"EthTagID,omitempty"`
	MACAddress []byte     `protobuf:"bytes,3,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	IPAddress  *IPAddress `protobuf:"bytes,4,opt,name=IPAddress" json:"IPAddress,omitempty"`
	PathID     uint32     `protobuf:"varint,5,opt,name=PathID,proto3" json:"PathID,omitempty"`
	Source     EvpnSource `protobuf:"varint,6,opt,name=Source,proto3,enum=pds.EvpnSource" json:"Source,omitempty"`
	NHAddress  *IPAddress `protobuf:"bytes,7,opt,name=NHAddress" json:"NHAddress,omitempty"`
	LocalIfId  uint32     `protobuf:"varint,8,opt,name=LocalIfId,proto3" json:"LocalIfId,omitempty"`
	Label      uint32     `protobuf:"varint,9,opt,name=Label,proto3" json:"Label,omitempty"`
	InUse      bool       `protobuf:"varint,10,opt,name=InUse,proto3" json:"InUse,omitempty"`
	Esi        string     `protobuf:"bytes,11,opt,name=Esi,proto3" json:"Esi,omitempty"`
	SeqNum     uint32     `protobuf:"varint,12,opt,name=SeqNum,proto3" json:"SeqNum,omitempty"`
	Sticky     bool       `protobuf:"varint,13,opt,name=Sticky,proto3" json:"Sticky,omitempty"`
}

func (m *EvpnMacIpStatus) Reset()                    { *m = EvpnMacIpStatus{} }
func (m *EvpnMacIpStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIpStatus) ProtoMessage()               {}
func (*EvpnMacIpStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{44} }

func (m *EvpnMacIpStatus) GetEVIId() uint32 {
	if m != nil {
		return m.EVIId
	}
	return 0
}

func (m *EvpnMacIpStatus) GetEthTagID() uint32 {
	if m != nil {
		return m.EthTagID
	}
	return 0
}

func (m *EvpnMacIpStatus) GetMACAddress() []byte {
	if m != nil {
		return m.MACAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetIPAddress() *IPAddress {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

func (m *EvpnMacIpStatus) GetSource() EvpnSource {
	if m != nil {
		return m.Source
	}
	return EvpnSource_EVPN_SOURCE_NONE
}

func (m *EvpnMacIpStatus) GetNHAddress() *IPAddress {
	if m != nil {
		return m.NHAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetLocalIfId() uint32 {
	if m != nil {
		return m.LocalIfId
	}
	return 0
}

func (m *EvpnMacIpStatus) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *EvpnMacIpStatus) GetInUse() bool {
	if m != nil {
		return m.InUse
	}
	return false
}

func (m *EvpnMacIpStatus) GetEsi() string {
	if m != nil {
		return m.Esi
	}
	return ""
}

func (m *EvpnMacIpStatus) GetSeqNum() uint32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *EvpnMacIpStatus) GetSticky() bool {
	if m != nil {
		return m.Sticky
	}
	return false
}

// EVPN MAC IP Table Key
type EvpnMacIpKey struct {
	EVIId      uint32     `protobuf:"varint,1,opt,name=EVIId,proto3" json:"EVIId,omitempty"`
	EthTagID   uint32     `protobuf:"varint,2,opt,name=EthTagID,proto3" json:"EthTagID,omitempty"`
	MACAddress []byte     `protobuf:"bytes,3,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	IPAddress  *IPAddress `protobuf:"bytes,4,opt,name=IPAddress" json:"IPAddress,omitempty"`
	PathID     uint32     `protobuf:"varint,5,opt,name=PathID,proto3" json:"PathID,omitempty"`
}

func (m *EvpnMacIpKey) Reset()                    { *m = EvpnMacIpKey{} }
func (m *EvpnMacIpKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIpKey) ProtoMessage()               {}
func (*EvpnMacIpKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{45} }

func (m *EvpnMacIpKey) GetEVIId() uint32 {
	if m != nil {
		return m.EVIId
	}
	return 0
}

func (m *EvpnMacIpKey) GetEthTagID() uint32 {
	if m != nil {
		return m.EthTagID
	}
	return 0
}

func (m *EvpnMacIpKey) GetMACAddress() []byte {
	if m != nil {
		return m.MACAddress
	}
	return nil
}

func (m *EvpnMacIpKey) GetIPAddress() *IPAddress {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *EvpnMacIpKey) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

// EVPN MAC IP Table key handle for get and delete
type EvpnMacIpKeyHandle struct {
	Key *EvpnMacIpKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *EvpnMacIpKeyHandle) Reset()                    { *m = EvpnMacIpKeyHandle{} }
func (m *EvpnMacIpKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIpKeyHandle) ProtoMessage()               {}
func (*EvpnMacIpKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{46} }

func (m *EvpnMacIpKeyHandle) GetKey() *EvpnMacIpKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// EVPN MAC IP get request
type EvpnMacIpGetRequest struct {
	Request []*EvpnMacIpKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnMacIpGetRequest) Reset()                    { *m = EvpnMacIpGetRequest{} }
func (m *EvpnMacIpGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIpGetRequest) ProtoMessage()               {}
func (*EvpnMacIpGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{47} }

func (m *EvpnMacIpGetRequest) GetRequest() []*EvpnMacIpKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN MAC IP
type EvpnMacIp struct {
	Status *EvpnMacIpStatus `protobuf:"bytes,1,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnMacIp) Reset()                    { *m = EvpnMacIp{} }
func (m *EvpnMacIp) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIp) ProtoMessage()               {}
func (*EvpnMacIp) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{48} }

func (m *EvpnMacIp) GetStatus() *EvpnMacIpStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN MAC IP get response
type EvpnMacIpGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnMacIp `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnMacIpGetResponse) Reset()                    { *m = EvpnMacIpGetResponse{} }
func (m *EvpnMacIpGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnMacIpGetResponse) ProtoMessage()               {}
func (*EvpnMacIpGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{49} }

func (m *EvpnMacIpGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnMacIpGetResponse) GetResponse() []*EvpnMacIp {
	if m != nil {
		return m.Response
	}
	return nil
}

type EvpnBdStatus struct {
	// Identifies a DC-EVPN entity
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// Index identifying the EVPN instance
	EviIndex uint32 `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
	// Operational status of the bridge domain
	OperStatus EvpnOperStatus `protobuf:"varint,3,opt,name=OperStatus,proto3,enum=pds.EvpnOperStatus" json:"OperStatus,omitempty"`
	// The reason for the bridge domain to be in its current oper status
	OperReason EvpnOperReason `protobuf:"varint,4,opt,name=OperReason,proto3,enum=pds.EvpnOperReason" json:"OperReason,omitempty"`
}

func (m *EvpnBdStatus) Reset()                    { *m = EvpnBdStatus{} }
func (m *EvpnBdStatus) String() string            { return proto.CompactTextString(m) }
func (*EvpnBdStatus) ProtoMessage()               {}
func (*EvpnBdStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{50} }

func (m *EvpnBdStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdStatus) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

func (m *EvpnBdStatus) GetOperStatus() EvpnOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

func (m *EvpnBdStatus) GetOperReason() EvpnOperReason {
	if m != nil {
		return m.OperReason
	}
	return EvpnOperReason_EVPN_OPER_REASON_INVALID
}

// EVPN BD Table Key
type EvpnBdKey struct {
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	EviIndex    uint32 `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
}

func (m *EvpnBdKey) Reset()                    { *m = EvpnBdKey{} }
func (m *EvpnBdKey) String() string            { return proto.CompactTextString(m) }
func (*EvpnBdKey) ProtoMessage()               {}
func (*EvpnBdKey) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{51} }

func (m *EvpnBdKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdKey) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

// EVPN BD Table key handle for get and delete
type EvpnBdKeyHandle struct {
	Key *EvpnBdKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *EvpnBdKeyHandle) Reset()                    { *m = EvpnBdKeyHandle{} }
func (m *EvpnBdKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EvpnBdKeyHandle) ProtoMessage()               {}
func (*EvpnBdKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{52} }

func (m *EvpnBdKeyHandle) GetKey() *EvpnBdKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// EVPN MAC IP get request
type EvpnBdGetRequest struct {
	Request []*EvpnBdKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *EvpnBdGetRequest) Reset()                    { *m = EvpnBdGetRequest{} }
func (m *EvpnBdGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EvpnBdGetRequest) ProtoMessage()               {}
func (*EvpnBdGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{53} }

func (m *EvpnBdGetRequest) GetRequest() []*EvpnBdKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN BD
type EvpnBd struct {
	Status *EvpnBdStatus `protobuf:"bytes,1,opt,name=Status" json:"status,omitempty"`
}

func (m *EvpnBd) Reset()                    { *m = EvpnBd{} }
func (m *EvpnBd) String() string            { return proto.CompactTextString(m) }
func (*EvpnBd) ProtoMessage()               {}
func (*EvpnBd) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{54} }

func (m *EvpnBd) GetStatus() *EvpnBdStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN BD get response
type EvpnBdGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*EvpnBd `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *EvpnBdGetResponse) Reset()                    { *m = EvpnBdGetResponse{} }
func (m *EvpnBdGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EvpnBdGetResponse) ProtoMessage()               {}
func (*EvpnBdGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEvpn, []int{55} }

func (m *EvpnBdGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnBdGetResponse) GetResponse() []*EvpnBd {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EvpnEviSpec)(nil), "pds.EvpnEviSpec")
	proto.RegisterType((*EvpnEviStatus)(nil), "pds.EvpnEviStatus")
	proto.RegisterType((*EvpnEvi)(nil), "pds.EvpnEvi")
	proto.RegisterType((*EvpnEviResponse)(nil), "pds.EvpnEviResponse")
	proto.RegisterType((*EvpnEviRequest)(nil), "pds.EvpnEviRequest")
	proto.RegisterType((*EvpnEviKey)(nil), "pds.EvpnEviKey")
	proto.RegisterType((*EvpnEviKeyHandle)(nil), "pds.EvpnEviKeyHandle")
	proto.RegisterType((*EvpnEviDeleteRequest)(nil), "pds.EvpnEviDeleteRequest")
	proto.RegisterType((*EvpnEviDeleteResponse)(nil), "pds.EvpnEviDeleteResponse")
	proto.RegisterType((*EvpnEviGetRequest)(nil), "pds.EvpnEviGetRequest")
	proto.RegisterType((*EvpnEviGetResponse)(nil), "pds.EvpnEviGetResponse")
	proto.RegisterType((*EvpnIpVrfSpec)(nil), "pds.EvpnIpVrfSpec")
	proto.RegisterType((*EvpnIpVrfStatus)(nil), "pds.EvpnIpVrfStatus")
	proto.RegisterType((*EvpnIpVrf)(nil), "pds.EvpnIpVrf")
	proto.RegisterType((*EvpnIpVrfRequest)(nil), "pds.EvpnIpVrfRequest")
	proto.RegisterType((*EvpnIpVrfResponse)(nil), "pds.EvpnIpVrfResponse")
	proto.RegisterType((*EvpnIpVrfKey)(nil), "pds.EvpnIpVrfKey")
	proto.RegisterType((*EvpnIpVrfKeyHandle)(nil), "pds.EvpnIpVrfKeyHandle")
	proto.RegisterType((*EvpnIpVrfDeleteRequest)(nil), "pds.EvpnIpVrfDeleteRequest")
	proto.RegisterType((*EvpnIpVrfDeleteResponse)(nil), "pds.EvpnIpVrfDeleteResponse")
	proto.RegisterType((*EvpnIpVrfGetRequest)(nil), "pds.EvpnIpVrfGetRequest")
	proto.RegisterType((*EvpnIpVrfGetResponse)(nil), "pds.EvpnIpVrfGetResponse")
	proto.RegisterType((*EvpnEviRtSpec)(nil), "pds.EvpnEviRtSpec")
	proto.RegisterType((*EvpnEviRtStatus)(nil), "pds.EvpnEviRtStatus")
	proto.RegisterType((*EvpnEviRt)(nil), "pds.EvpnEviRt")
	proto.RegisterType((*EvpnEviRtResponse)(nil), "pds.EvpnEviRtResponse")
	proto.RegisterType((*EvpnEviRtRequest)(nil), "pds.EvpnEviRtRequest")
	proto.RegisterType((*EvpnEviRtKey)(nil), "pds.EvpnEviRtKey")
	proto.RegisterType((*EvpnEviRtKeyHandle)(nil), "pds.EvpnEviRtKeyHandle")
	proto.RegisterType((*EvpnEviRtDeleteRequest)(nil), "pds.EvpnEviRtDeleteRequest")
	proto.RegisterType((*EvpnEviRtDeleteResponse)(nil), "pds.EvpnEviRtDeleteResponse")
	proto.RegisterType((*EvpnEviRtGetRequest)(nil), "pds.EvpnEviRtGetRequest")
	proto.RegisterType((*EvpnEviRtGetResponse)(nil), "pds.EvpnEviRtGetResponse")
	proto.RegisterType((*EvpnIpVrfRtRequest)(nil), "pds.EvpnIpVrfRtRequest")
	proto.RegisterType((*EvpnIpVrfRtSpec)(nil), "pds.EvpnIpVrfRtSpec")
	proto.RegisterType((*EvpnIpVrfRtStatus)(nil), "pds.EvpnIpVrfRtStatus")
	proto.RegisterType((*EvpnIpVrfRt)(nil), "pds.EvpnIpVrfRt")
	proto.RegisterType((*EvpnIpVrfRtResponse)(nil), "pds.EvpnIpVrfRtResponse")
	proto.RegisterType((*EvpnIpVrfRtKey)(nil), "pds.EvpnIpVrfRtKey")
	proto.RegisterType((*EvpnIpVrfRtKeyHandle)(nil), "pds.EvpnIpVrfRtKeyHandle")
	proto.RegisterType((*EvpnIpVrfRtDeleteRequest)(nil), "pds.EvpnIpVrfRtDeleteRequest")
	proto.RegisterType((*EvpnIpVrfRtDeleteResponse)(nil), "pds.EvpnIpVrfRtDeleteResponse")
	proto.RegisterType((*EvpnIpVrfRtGetRequest)(nil), "pds.EvpnIpVrfRtGetRequest")
	proto.RegisterType((*EvpnIpVrfRtGetResponse)(nil), "pds.EvpnIpVrfRtGetResponse")
	proto.RegisterType((*EvpnMacIpStatus)(nil), "pds.EvpnMacIpStatus")
	proto.RegisterType((*EvpnMacIpKey)(nil), "pds.EvpnMacIpKey")
	proto.RegisterType((*EvpnMacIpKeyHandle)(nil), "pds.EvpnMacIpKeyHandle")
	proto.RegisterType((*EvpnMacIpGetRequest)(nil), "pds.EvpnMacIpGetRequest")
	proto.RegisterType((*EvpnMacIp)(nil), "pds.EvpnMacIp")
	proto.RegisterType((*EvpnMacIpGetResponse)(nil), "pds.EvpnMacIpGetResponse")
	proto.RegisterType((*EvpnBdStatus)(nil), "pds.EvpnBdStatus")
	proto.RegisterType((*EvpnBdKey)(nil), "pds.EvpnBdKey")
	proto.RegisterType((*EvpnBdKeyHandle)(nil), "pds.EvpnBdKeyHandle")
	proto.RegisterType((*EvpnBdGetRequest)(nil), "pds.EvpnBdGetRequest")
	proto.RegisterType((*EvpnBd)(nil), "pds.EvpnBd")
	proto.RegisterType((*EvpnBdGetResponse)(nil), "pds.EvpnBdGetResponse")
	proto.RegisterEnum("pds.EvpnCfg", EvpnCfg_name, EvpnCfg_value)
	proto.RegisterEnum("pds.EvpnRtType", EvpnRtType_name, EvpnRtType_value)
	proto.RegisterEnum("pds.EvpnSource", EvpnSource_name, EvpnSource_value)
	proto.RegisterEnum("pds.EvpnOperStatus", EvpnOperStatus_name, EvpnOperStatus_value)
	proto.RegisterEnum("pds.EvpnOperReason", EvpnOperReason_name, EvpnOperReason_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EvpnSvc service

type EvpnSvcClient interface {
	EvpnEviCreate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error)
	EvpnEviUpdate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error)
	EvpnEviDelete(ctx context.Context, in *EvpnEviDeleteRequest, opts ...grpc.CallOption) (*EvpnEviDeleteResponse, error)
	EvpnEviGet(ctx context.Context, in *EvpnEviGetRequest, opts ...grpc.CallOption) (*EvpnEviGetResponse, error)
	EvpnEviRtCreate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error)
	EvpnEviRtUpdate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error)
	EvpnEviRtDelete(ctx context.Context, in *EvpnEviRtDeleteRequest, opts ...grpc.CallOption) (*EvpnEviRtDeleteResponse, error)
	EvpnEviRtGet(ctx context.Context, in *EvpnEviRtGetRequest, opts ...grpc.CallOption) (*EvpnEviRtGetResponse, error)
	EvpnIpVrfCreate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error)
	EvpnIpVrfUpdate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error)
	EvpnIpVrfDelete(ctx context.Context, in *EvpnIpVrfDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfDeleteResponse, error)
	EvpnIpVrfGet(ctx context.Context, in *EvpnIpVrfGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfGetResponse, error)
	EvpnIpVrfRtCreate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtUpdate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtDelete(ctx context.Context, in *EvpnIpVrfRtDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtDeleteResponse, error)
	EvpnIpVrfRtGet(ctx context.Context, in *EvpnIpVrfRtGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtGetResponse, error)
	EvpnMacIpGet(ctx context.Context, in *EvpnMacIpGetRequest, opts ...grpc.CallOption) (*EvpnMacIpGetResponse, error)
	EvpnBdGet(ctx context.Context, in *EvpnBdGetRequest, opts ...grpc.CallOption) (*EvpnBdGetResponse, error)
}

type evpnSvcClient struct {
	cc *grpc.ClientConn
}

func NewEvpnSvcClient(cc *grpc.ClientConn) EvpnSvcClient {
	return &evpnSvcClient{cc}
}

func (c *evpnSvcClient) EvpnEviCreate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error) {
	out := new(EvpnEviResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviUpdate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error) {
	out := new(EvpnEviResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviDelete(ctx context.Context, in *EvpnEviDeleteRequest, opts ...grpc.CallOption) (*EvpnEviDeleteResponse, error) {
	out := new(EvpnEviDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviGet(ctx context.Context, in *EvpnEviGetRequest, opts ...grpc.CallOption) (*EvpnEviGetResponse, error) {
	out := new(EvpnEviGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtCreate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error) {
	out := new(EvpnEviRtResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtUpdate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error) {
	out := new(EvpnEviRtResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtDelete(ctx context.Context, in *EvpnEviRtDeleteRequest, opts ...grpc.CallOption) (*EvpnEviRtDeleteResponse, error) {
	out := new(EvpnEviRtDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtGet(ctx context.Context, in *EvpnEviRtGetRequest, opts ...grpc.CallOption) (*EvpnEviRtGetResponse, error) {
	out := new(EvpnEviRtGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfCreate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error) {
	out := new(EvpnIpVrfResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfUpdate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error) {
	out := new(EvpnIpVrfResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfDelete(ctx context.Context, in *EvpnIpVrfDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfDeleteResponse, error) {
	out := new(EvpnIpVrfDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfGet(ctx context.Context, in *EvpnIpVrfGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfGetResponse, error) {
	out := new(EvpnIpVrfGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtCreate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error) {
	out := new(EvpnIpVrfRtResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtUpdate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error) {
	out := new(EvpnIpVrfRtResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtDelete(ctx context.Context, in *EvpnIpVrfRtDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtDeleteResponse, error) {
	out := new(EvpnIpVrfRtDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtGet(ctx context.Context, in *EvpnIpVrfRtGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtGetResponse, error) {
	out := new(EvpnIpVrfRtGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnMacIpGet(ctx context.Context, in *EvpnMacIpGetRequest, opts ...grpc.CallOption) (*EvpnMacIpGetResponse, error) {
	out := new(EvpnMacIpGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnMacIpGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnBdGet(ctx context.Context, in *EvpnBdGetRequest, opts ...grpc.CallOption) (*EvpnBdGetResponse, error) {
	out := new(EvpnBdGetResponse)
	err := grpc.Invoke(ctx, "/pds.EvpnSvc/EvpnBdGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EvpnSvc service

type EvpnSvcServer interface {
	EvpnEviCreate(context.Context, *EvpnEviRequest) (*EvpnEviResponse, error)
	EvpnEviUpdate(context.Context, *EvpnEviRequest) (*EvpnEviResponse, error)
	EvpnEviDelete(context.Context, *EvpnEviDeleteRequest) (*EvpnEviDeleteResponse, error)
	EvpnEviGet(context.Context, *EvpnEviGetRequest) (*EvpnEviGetResponse, error)
	EvpnEviRtCreate(context.Context, *EvpnEviRtRequest) (*EvpnEviRtResponse, error)
	EvpnEviRtUpdate(context.Context, *EvpnEviRtRequest) (*EvpnEviRtResponse, error)
	EvpnEviRtDelete(context.Context, *EvpnEviRtDeleteRequest) (*EvpnEviRtDeleteResponse, error)
	EvpnEviRtGet(context.Context, *EvpnEviRtGetRequest) (*EvpnEviRtGetResponse, error)
	EvpnIpVrfCreate(context.Context, *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error)
	EvpnIpVrfUpdate(context.Context, *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error)
	EvpnIpVrfDelete(context.Context, *EvpnIpVrfDeleteRequest) (*EvpnIpVrfDeleteResponse, error)
	EvpnIpVrfGet(context.Context, *EvpnIpVrfGetRequest) (*EvpnIpVrfGetResponse, error)
	EvpnIpVrfRtCreate(context.Context, *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtUpdate(context.Context, *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtDelete(context.Context, *EvpnIpVrfRtDeleteRequest) (*EvpnIpVrfRtDeleteResponse, error)
	EvpnIpVrfRtGet(context.Context, *EvpnIpVrfRtGetRequest) (*EvpnIpVrfRtGetResponse, error)
	EvpnMacIpGet(context.Context, *EvpnMacIpGetRequest) (*EvpnMacIpGetResponse, error)
	EvpnBdGet(context.Context, *EvpnBdGetRequest) (*EvpnBdGetResponse, error)
}

func RegisterEvpnSvcServer(s *grpc.Server, srv EvpnSvcServer) {
	s.RegisterService(&_EvpnSvc_serviceDesc, srv)
}

func _EvpnSvc_EvpnEviCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviCreate(ctx, req.(*EvpnEviRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviUpdate(ctx, req.(*EvpnEviRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviDelete(ctx, req.(*EvpnEviDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviGet(ctx, req.(*EvpnEviGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtCreate(ctx, req.(*EvpnEviRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtUpdate(ctx, req.(*EvpnEviRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtDelete(ctx, req.(*EvpnEviRtDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtGet(ctx, req.(*EvpnEviRtGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfCreate(ctx, req.(*EvpnIpVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfUpdate(ctx, req.(*EvpnIpVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfDelete(ctx, req.(*EvpnIpVrfDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfGet(ctx, req.(*EvpnIpVrfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtCreate(ctx, req.(*EvpnIpVrfRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtUpdate(ctx, req.(*EvpnIpVrfRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtDelete(ctx, req.(*EvpnIpVrfRtDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtGet(ctx, req.(*EvpnIpVrfRtGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnMacIpGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnMacIpGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnMacIpGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnMacIpGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnMacIpGet(ctx, req.(*EvpnMacIpGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnBdGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnBdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnBdGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnBdGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnBdGet(ctx, req.(*EvpnBdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EvpnSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.EvpnSvc",
	HandlerType: (*EvpnSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EvpnEviCreate",
			Handler:    _EvpnSvc_EvpnEviCreate_Handler,
		},
		{
			MethodName: "EvpnEviUpdate",
			Handler:    _EvpnSvc_EvpnEviUpdate_Handler,
		},
		{
			MethodName: "EvpnEviDelete",
			Handler:    _EvpnSvc_EvpnEviDelete_Handler,
		},
		{
			MethodName: "EvpnEviGet",
			Handler:    _EvpnSvc_EvpnEviGet_Handler,
		},
		{
			MethodName: "EvpnEviRtCreate",
			Handler:    _EvpnSvc_EvpnEviRtCreate_Handler,
		},
		{
			MethodName: "EvpnEviRtUpdate",
			Handler:    _EvpnSvc_EvpnEviRtUpdate_Handler,
		},
		{
			MethodName: "EvpnEviRtDelete",
			Handler:    _EvpnSvc_EvpnEviRtDelete_Handler,
		},
		{
			MethodName: "EvpnEviRtGet",
			Handler:    _EvpnSvc_EvpnEviRtGet_Handler,
		},
		{
			MethodName: "EvpnIpVrfCreate",
			Handler:    _EvpnSvc_EvpnIpVrfCreate_Handler,
		},
		{
			MethodName: "EvpnIpVrfUpdate",
			Handler:    _EvpnSvc_EvpnIpVrfUpdate_Handler,
		},
		{
			MethodName: "EvpnIpVrfDelete",
			Handler:    _EvpnSvc_EvpnIpVrfDelete_Handler,
		},
		{
			MethodName: "EvpnIpVrfGet",
			Handler:    _EvpnSvc_EvpnIpVrfGet_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtCreate",
			Handler:    _EvpnSvc_EvpnIpVrfRtCreate_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtUpdate",
			Handler:    _EvpnSvc_EvpnIpVrfRtUpdate_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtDelete",
			Handler:    _EvpnSvc_EvpnIpVrfRtDelete_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtGet",
			Handler:    _EvpnSvc_EvpnIpVrfRtGet_Handler,
		},
		{
			MethodName: "EvpnMacIpGet",
			Handler:    _EvpnSvc_EvpnMacIpGet_Handler,
		},
		{
			MethodName: "EvpnBdGet",
			Handler:    _EvpnSvc_EvpnBdGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evpn.proto",
}

func (m *EvpnEviSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if m.AutoRD != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.AutoRD))
	}
	if len(m.RD) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i += copy(dAtA[i:], m.RD)
	}
	if m.AutoRT != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.AutoRT))
	}
	if m.RTType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
	}
	return i, nil
}

func (m *EvpnEviStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RD) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i += copy(dAtA[i:], m.RD)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *EvpnEvi) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEvi) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *EvpnEviResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnEviRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	return i, nil
}

func (m *EvpnEviKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn3, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *EvpnEviKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *EvpnEviKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n4, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *EvpnEviDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnEviGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VPCId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	if m.VNI != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.VNI))
	}
	if len(m.RD) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i += copy(dAtA[i:], m.RD)
	}
	return i, nil
}

func (m *EvpnIpVrfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EvpnIpVrf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Spec.Size()))
		n5, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *EvpnIpVrfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnIpVrfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VPCId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	return i, nil
}

func (m *EvpnIpVrfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn7, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *EvpnIpVrfKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *EvpnIpVrfKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n8, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *EvpnIpVrfDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnIpVrfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviRtSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.RT) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i += copy(dAtA[i:], m.RT)
	}
	if m.RTType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
	}
	return i, nil
}

func (m *EvpnEviRtStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EvpnEviRt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Spec.Size()))
		n9, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *EvpnEviRtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnEviRtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviRtKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.RT) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i += copy(dAtA[i:], m.RT)
	}
	return i, nil
}

func (m *EvpnEviRtKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn11, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *EvpnEviRtKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *EvpnEviRtKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n12, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *EvpnEviRtDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviRtDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnEviRtGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnEviRtGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfRtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfRtSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VPCId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	if len(m.RT) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i += copy(dAtA[i:], m.RT)
	}
	if m.RTType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
	}
	return i, nil
}

func (m *EvpnIpVrfRtStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EvpnIpVrfRt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *EvpnIpVrfRtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnIpVrfRtKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VPCId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	if len(m.RT) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i += copy(dAtA[i:], m.RT)
	}
	return i, nil
}

func (m *EvpnIpVrfRtKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn15, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	return i, nil
}

func (m *EvpnIpVrfRtKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *EvpnIpVrfRtKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n16, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *EvpnIpVrfRtDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfRtDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EvpnIpVrfRtGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnIpVrfRtGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnMacIpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EVIId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EthTagID))
	}
	if len(m.MACAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.MACAddress)))
		i += copy(dAtA[i:], m.MACAddress)
	}
	if m.IPAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.IPAddress.Size()))
		n17, err := m.IPAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.PathID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.PathID))
	}
	if m.Source != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Source))
	}
	if m.NHAddress != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.NHAddress.Size()))
		n18, err := m.NHAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.LocalIfId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.LocalIfId))
	}
	if m.Label != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Label))
	}
	if m.InUse {
		dAtA[i] = 0x50
		i++
		if m.InUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Esi) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Esi)))
		i += copy(dAtA[i:], m.Esi)
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.SeqNum))
	}
	if m.Sticky {
		dAtA[i] = 0x68
		i++
		if m.Sticky {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EvpnMacIpKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EVIId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EthTagID))
	}
	if len(m.MACAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.MACAddress)))
		i += copy(dAtA[i:], m.MACAddress)
	}
	if m.IPAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.IPAddress.Size()))
		n19, err := m.IPAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.PathID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.PathID))
	}
	return i, nil
}

func (m *EvpnMacIpKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n20, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *EvpnMacIpGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnMacIp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n21, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *EvpnMacIpGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnBdStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
	}
	if m.OperStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperStatus))
	}
	if m.OperReason != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperReason))
	}
	return i, nil
}

func (m *EvpnBdKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
	}
	return i, nil
}

func (m *EvpnBdKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Key.Size()))
		n22, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *EvpnBdGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EvpnBd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status.Size()))
		n23, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *EvpnBdGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEvpn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintEvpn(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EvpnEviSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.AutoRD != 0 {
		n += 1 + sovEvpn(uint64(m.AutoRD))
	}
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.AutoRT != 0 {
		n += 1 + sovEvpn(uint64(m.AutoRT))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	return n
}

func (m *EvpnEviStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEvpn(uint64(m.Status))
	}
	return n
}

func (m *EvpnEvi) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnEviResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnEviRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnEviKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *EvpnEviKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnEviGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.VNI != 0 {
		n += 1 + sovEvpn(uint64(m.VNI))
	}
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnIpVrfStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EvpnIpVrf) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnIpVrfRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnIpVrfKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnIpVrfKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *EvpnIpVrfKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnIpVrfGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviRtSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	return n
}

func (m *EvpnEviRtStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EvpnEviRt) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnEviRtResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnEviRtRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviRtKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnEviRtKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *EvpnEviRtKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviRtKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviRtDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviRtDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnEviRtGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnEviRtGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfRtRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfRtSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	return n
}

func (m *EvpnIpVrfRtStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EvpnIpVrfRt) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnIpVrfRtResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnIpVrfRtKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnIpVrfRtKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *EvpnIpVrfRtKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfRtKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfRtDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfRtDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	return n
}

func (m *EvpnIpVrfRtGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnIpVrfRtGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnMacIpStatus) Size() (n int) {
	var l int
	_ = l
	if m.EVIId != 0 {
		n += 1 + sovEvpn(uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		n += 1 + sovEvpn(uint64(m.EthTagID))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.IPAddress != nil {
		l = m.IPAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.PathID != 0 {
		n += 1 + sovEvpn(uint64(m.PathID))
	}
	if m.Source != 0 {
		n += 1 + sovEvpn(uint64(m.Source))
	}
	if m.NHAddress != nil {
		l = m.NHAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.LocalIfId != 0 {
		n += 1 + sovEvpn(uint64(m.LocalIfId))
	}
	if m.Label != 0 {
		n += 1 + sovEvpn(uint64(m.Label))
	}
	if m.InUse {
		n += 2
	}
	l = len(m.Esi)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovEvpn(uint64(m.SeqNum))
	}
	if m.Sticky {
		n += 2
	}
	return n
}

func (m *EvpnMacIpKey) Size() (n int) {
	var l int
	_ = l
	if m.EVIId != 0 {
		n += 1 + sovEvpn(uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		n += 1 + sovEvpn(uint64(m.EthTagID))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.IPAddress != nil {
		l = m.IPAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.PathID != 0 {
		n += 1 + sovEvpn(uint64(m.PathID))
	}
	return n
}

func (m *EvpnMacIpKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnMacIpGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnMacIp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnMacIpGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnBdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovEvpn(uint64(m.OperStatus))
	}
	if m.OperReason != 0 {
		n += 1 + sovEvpn(uint64(m.OperReason))
	}
	return n
}

func (m *EvpnBdKey) Size() (n int) {
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	return n
}

func (m *EvpnBdKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnBdGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func (m *EvpnBd) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}

func (m *EvpnBdGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	return n
}

func sovEvpn(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEvpn(x uint64) (n int) {
	return sovEvpn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EvpnEviSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRD", wireType)
			}
			m.AutoRD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRD |= (EvpnCfg(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRT", wireType)
			}
			m.AutoRT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRT |= (EvpnCfg(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= (EvpnRtType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (EvpnOperStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEvi) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEvi: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEvi: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnEviSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnEviStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnEviKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnEviKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnEviKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnEvi{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnIpVrfSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnIpVrfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnIpVrfKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnIpVrfKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnIpVrfKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnIpVrf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= (EvpnRtType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnEviRtSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnEviRtStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnEviRtKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnEviRtKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnEviRtKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnEviRt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= (EvpnRtType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnIpVrfRtSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnIpVrfRtStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnIpVrfRtKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnIpVrfRtKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnIpVrfRtKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnIpVrfRt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVIId", wireType)
			}
			m.EVIId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EVIId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTagID", wireType)
			}
			m.EthTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTagID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = append(m.MACAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.MACAddress == nil {
				m.MACAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddress == nil {
				m.IPAddress = &IPAddress{}
			}
			if err := m.IPAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (EvpnSource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NHAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NHAddress == nil {
				m.NHAddress = &IPAddress{}
			}
			if err := m.NHAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIfId", wireType)
			}
			m.LocalIfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalIfId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InUse = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Esi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticky", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sticky = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVIId", wireType)
			}
			m.EVIId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EVIId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTagID", wireType)
			}
			m.EthTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTagID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = append(m.MACAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.MACAddress == nil {
				m.MACAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddress == nil {
				m.IPAddress = &IPAddress{}
			}
			if err := m.IPAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &EvpnMacIpKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnMacIpKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnMacIpStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnMacIp{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= (EvpnOperStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= (EvpnOperReason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &EvpnBdKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnBdKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnBdStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnBd{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvpn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEvpn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvpn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvpn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvpn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvpn   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("evpn.proto", fileDescriptorEvpn) }

var fileDescriptorEvpn = []byte{
	// 2131 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcb, 0x6e, 0xe3, 0xc8,
	0xd5, 0x36, 0xe5, 0xab, 0x4a, 0xb6, 0x5c, 0x2e, 0xdf, 0x68, 0x75, 0x8f, 0xdb, 0xd0, 0x3f, 0x3f,
	0xda, 0x70, 0x0c, 0x0f, 0xe2, 0x06, 0x82, 0x49, 0xa3, 0x81, 0x19, 0x4a, 0xa4, 0xe5, 0x82, 0x25,
	0x52, 0x53, 0xa4, 0x94, 0x74, 0x16, 0x21, 0xd4, 0x16, 0xdb, 0x63, 0x8c, 0x2d, 0x69, 0x24, 0xda,
	0x88, 0x1e, 0x20, 0x9b, 0x64, 0x93, 0x20, 0x2f, 0x91, 0x27, 0xc8, 0x33, 0x24, 0x59, 0x04, 0x79,
	0x82, 0x46, 0xd0, 0xcb, 0x59, 0x66, 0x19, 0x20, 0x40, 0xc0, 0xaa, 0x62, 0xb1, 0x78, 0x91, 0xad,
	0x56, 0xa3, 0x83, 0x6c, 0x0c, 0xf1, 0x5c, 0xbe, 0x3a, 0x75, 0xea, 0x7c, 0xa7, 0x2e, 0x06, 0xc0,
	0xbb, 0x1f, 0xf4, 0x4e, 0x06, 0xc3, 0xbe, 0xdf, 0x47, 0xf3, 0x83, 0xee, 0xa8, 0x04, 0xae, 0xfa,
	0x57, 0x7d, 0x26, 0x28, 0xad, 0xdf, 0x7a, 0x7e, 0xe7, 0x8b, 0xe0, 0x0f, 0x17, 0x14, 0xfc, 0xf1,
	0xc0, 0x1b, 0xb1, 0x8f, 0xf2, 0xbf, 0x14, 0x50, 0x30, 0xee, 0x07, 0x3d, 0xe3, 0xfe, 0xda, 0x1e,
	0x78, 0x97, 0xe8, 0x18, 0xe4, 0x70, 0x57, 0x55, 0x0e, 0x94, 0xc3, 0xd5, 0xca, 0xd3, 0x7f, 0xbe,
	0x7b, 0xa6, 0x06, 0x8e, 0x2f, 0x6f, 0x3b, 0xbd, 0x6e, 0xc7, 0xef, 0x0f, 0xc7, 0xc7, 0xd7, 0xb7,
	0xb7, 0x77, 0x7e, 0xe7, 0xcd, 0x8d, 0x47, 0x72, 0xb8, 0x8b, 0xbe, 0x04, 0x2b, 0xf6, 0xdd, 0x9b,
	0x9e, 0xe7, 0xe3, 0xae, 0x9a, 0x9b, 0xc2, 0x47, 0x58, 0xa3, 0xcf, 0xc1, 0x92, 0x76, 0xe7, 0xf7,
	0x89, 0xae, 0xce, 0x1f, 0x28, 0x87, 0xc5, 0xd3, 0xd5, 0x93, 0x41, 0x77, 0x74, 0x12, 0x44, 0x52,
	0x7d, 0x7b, 0x45, 0xb8, 0x0e, 0x15, 0x41, 0x8e, 0xe8, 0xea, 0x42, 0x80, 0x4c, 0x72, 0x44, 0x17,
	0x5e, 0x8e, 0xba, 0x38, 0xd1, 0xcb, 0x41, 0xcf, 0xc1, 0x12, 0x71, 0x9c, 0xf1, 0xc0, 0x53, 0x97,
	0xa8, 0xd5, 0xba, 0xb0, 0x22, 0x7e, 0x20, 0x26, 0x5c, 0x5d, 0xae, 0x83, 0xb5, 0x70, 0xee, 0x7e,
	0xc7, 0xbf, 0x1b, 0xf1, 0xf1, 0x14, 0x31, 0xde, 0x8f, 0xc0, 0x12, 0xd3, 0xd0, 0xd9, 0x15, 0x4f,
	0x37, 0x05, 0x92, 0x35, 0xf0, 0x86, 0x4c, 0x45, 0xb8, 0x49, 0xf9, 0xd7, 0x0a, 0x58, 0xe6, 0x70,
	0xe8, 0x4b, 0xb0, 0x10, 0xa4, 0x93, 0x42, 0x15, 0x4e, 0xa1, 0x70, 0xe3, 0x69, 0xae, 0xa0, 0x1f,
	0xde, 0x3d, 0x2b, 0x8e, 0x06, 0xde, 0xe5, 0x71, 0xff, 0xf6, 0xda, 0xf7, 0x6e, 0x07, 0xfe, 0x98,
	0x50, 0x0f, 0xf4, 0x75, 0x6c, 0xc8, 0xc2, 0x29, 0x8a, 0xf9, 0x52, 0x4d, 0x65, 0xeb, 0x87, 0x77,
	0xcf, 0xe0, 0x88, 0xfe, 0x96, 0xfc, 0xc3, 0x38, 0x34, 0xb0, 0xce, 0xcd, 0x89, 0x37, 0x1a, 0xf4,
	0x7b, 0x23, 0x0f, 0x9d, 0x80, 0xbc, 0x36, 0xe0, 0xde, 0x34, 0xa6, 0xe2, 0x29, 0x3c, 0x61, 0x65,
	0x20, 0xe4, 0x24, 0x32, 0x29, 0xbf, 0x02, 0x45, 0x01, 0xf1, 0xfd, 0x9d, 0x37, 0xf2, 0xd1, 0x11,
	0x58, 0xe6, 0x3f, 0x55, 0xe5, 0x60, 0x3e, 0x6b, 0x4e, 0x24, 0x34, 0x28, 0x1f, 0x02, 0xc0, 0xe5,
	0x17, 0xde, 0x18, 0x95, 0xa4, 0x1a, 0x61, 0x99, 0x15, 0xdf, 0xe5, 0x36, 0x80, 0x91, 0xe5, 0x79,
	0xa7, 0xd7, 0xbd, 0xf1, 0x10, 0x8c, 0x2a, 0xf0, 0x7c, 0x8e, 0x56, 0xd9, 0xff, 0x81, 0xf9, 0x0b,
	0x6f, 0xcc, 0xf3, 0xb1, 0x2e, 0x8f, 0x1b, 0x78, 0xcd, 0x91, 0x40, 0x5b, 0x29, 0x80, 0xfc, 0x75,
	0xd7, 0xed, 0x0f, 0xdd, 0xef, 0xbc, 0x71, 0xb9, 0x06, 0xb6, 0xb8, 0x85, 0xee, 0xdd, 0x78, 0xbe,
	0x17, 0xce, 0xe2, 0x8b, 0xe4, 0x2c, 0xb6, 0x93, 0x68, 0x34, 0x86, 0x68, 0x2a, 0x35, 0xb0, 0x9d,
	0x00, 0x9a, 0x31, 0xa3, 0x3a, 0xd8, 0xe0, 0x40, 0x35, 0xcf, 0x9f, 0x39, 0x9c, 0x1e, 0x40, 0x32,
	0xca, 0x6c, 0xb1, 0xa0, 0x43, 0xb0, 0x12, 0xfa, 0xaa, 0x39, 0x3a, 0xee, 0xaa, 0x3c, 0x2e, 0x11,
	0xda, 0xf2, 0x1f, 0x14, 0xc6, 0x10, 0x3c, 0x68, 0x0f, 0xdf, 0xce, 0xd0, 0x1f, 0x4e, 0xc1, 0x62,
	0xbb, 0x59, 0x9d, 0xb2, 0x39, 0x30, 0x53, 0x04, 0xc1, 0x7c, 0xdb, 0xc4, 0xb4, 0x2d, 0xac, 0x91,
	0xe0, 0x67, 0xb2, 0x0b, 0x94, 0x37, 0x58, 0x81, 0xb3, 0xa0, 0x58, 0x7a, 0x7f, 0xab, 0x80, 0xbc,
	0x90, 0xa1, 0x97, 0x31, 0xf6, 0x45, 0x0c, 0x12, 0xd3, 0x78, 0x80, 0x7f, 0x95, 0x04, 0xff, 0xb6,
	0x12, 0xde, 0xd3, 0x30, 0xf0, 0x6b, 0x56, 0xd6, 0xd4, 0x21, 0x5c, 0xeb, 0xe3, 0xe4, 0x5a, 0x67,
	0x84, 0x15, 0x2d, 0x74, 0x95, 0x95, 0x0b, 0x47, 0x98, 0xb1, 0xe6, 0x3e, 0x07, 0xab, 0x02, 0x24,
	0x60, 0xe2, 0x56, 0xb8, 0x1a, 0x8c, 0x86, 0xec, 0xa3, 0xfc, 0x0b, 0x56, 0x53, 0xa1, 0xd5, 0x44,
	0x16, 0xfe, 0xbf, 0xcc, 0xc2, 0x8d, 0x78, 0xf0, 0x93, 0x78, 0x78, 0x01, 0x76, 0x84, 0x4d, 0x9c,
	0x89, 0x3f, 0x4e, 0xa6, 0x63, 0x37, 0x8d, 0x98, 0x28, 0x7e, 0x0c, 0x76, 0x53, 0x60, 0x33, 0x66,
	0xe6, 0x1c, 0x6c, 0x0a, 0x28, 0x89, 0x8f, 0x33, 0x04, 0x35, 0x64, 0x9d, 0x26, 0x42, 0x9a, 0x91,
	0x93, 0x47, 0x29, 0x4e, 0x16, 0xe3, 0x63, 0x4b, 0xac, 0xfc, 0x9b, 0x22, 0xf6, 0x2d, 0xe2, 0xff,
	0x57, 0x77, 0xed, 0x63, 0x90, 0x23, 0x0e, 0xa5, 0xe6, 0xa3, 0xe3, 0xc4, 0xf6, 0xe1, 0x85, 0x87,
	0xf7, 0xe1, 0x8d, 0x68, 0xc7, 0xf2, 0x13, 0x84, 0xa6, 0xb2, 0x89, 0x84, 0x16, 0x19, 0x98, 0x89,
	0xd0, 0xd2, 0x78, 0x8f, 0x10, 0xba, 0x2a, 0xba, 0x37, 0x99, 0x79, 0x89, 0xc3, 0xae, 0xc0, 0x41,
	0x1e, 0xed, 0x0a, 0x62, 0x6e, 0x51, 0xb1, 0xbd, 0x64, 0x84, 0xa6, 0x9a, 0x47, 0xb6, 0x56, 0xda,
	0x34, 0x1d, 0xb6, 0xbc, 0xc1, 0x62, 0x84, 0x34, 0x0f, 0x7d, 0x3f, 0x94, 0xe6, 0xc2, 0xef, 0x01,
	0x9a, 0x53, 0x9b, 0xa9, 0x69, 0x1e, 0x8f, 0x24, 0x45, 0xf3, 0x18, 0xd8, 0xc7, 0xd1, 0x9c, 0x42,
	0x4d, 0x47, 0xf3, 0x49, 0x41, 0x0d, 0xc5, 0x81, 0x82, 0x23, 0x7d, 0x02, 0x9a, 0xb3, 0xc2, 0x88,
	0x68, 0xae, 0x4b, 0x8d, 0x39, 0xaa, 0x98, 0x93, 0x64, 0xf0, 0x89, 0x0d, 0x2a, 0x59, 0x33, 0x7f,
	0x55, 0xa4, 0xdd, 0x72, 0xa6, 0x76, 0x31, 0xcb, 0x26, 0xfe, 0x89, 0x1a, 0xc5, 0xa6, 0xbc, 0x2d,
	0x86, 0xad, 0xe2, 0xf7, 0xfc, 0x0a, 0xc3, 0xa5, 0xe8, 0x55, 0xac, 0x59, 0x64, 0xa6, 0xe7, 0x81,
	0x76, 0xa1, 0x27, 0xda, 0xc5, 0x4e, 0xca, 0x7f, 0x9a, 0x86, 0x61, 0x48, 0x1b, 0xcc, 0x47, 0xb4,
	0x8c, 0x9f, 0xb0, 0x73, 0x38, 0x87, 0x99, 0xb8, 0x87, 0xa7, 0xc8, 0xfe, 0x4b, 0x69, 0x57, 0x7a,
	0x98, 0xee, 0xcf, 0x65, 0xba, 0x6f, 0x26, 0xe7, 0x3a, 0x89, 0xf0, 0x16, 0x50, 0x25, 0xab, 0x38,
	0xe5, 0x5f, 0x24, 0x0b, 0x74, 0x2f, 0x0b, 0x35, 0xc1, 0xaf, 0x0b, 0xb0, 0x97, 0x01, 0x38, 0x63,
	0xd6, 0xea, 0xec, 0xd0, 0xce, 0xc1, 0x24, 0xe2, 0xcf, 0x14, 0xda, 0xbd, 0x74, 0x86, 0xf9, 0x38,
	0xf2, 0x1f, 0xa7, 0xc8, 0x0f, 0x93, 0xe3, 0x4b, 0xf4, 0xff, 0xdd, 0x3c, 0x23, 0x6e, 0xa3, 0x73,
	0x89, 0x07, 0x1c, 0x61, 0x0b, 0x2c, 0x1a, 0x6d, 0xcc, 0x97, 0x70, 0x8d, 0xb0, 0x8f, 0x60, 0x1b,
	0x30, 0xfc, 0x6f, 0x9d, 0xce, 0x15, 0xd6, 0xe9, 0x42, 0xae, 0x11, 0xf1, 0x8d, 0xf6, 0x01, 0x68,
	0x68, 0x55, 0xad, 0xdb, 0x1d, 0x7a, 0xa3, 0x11, 0x23, 0x24, 0x91, 0x24, 0xc1, 0x1c, 0x70, 0x33,
	0x54, 0x2f, 0xf0, 0xdb, 0x2a, 0x9b, 0x83, 0x90, 0x93, 0xc8, 0x04, 0xed, 0x80, 0xa5, 0x66, 0xc7,
	0xff, 0x16, 0xeb, 0xf4, 0x06, 0xbe, 0x46, 0xf8, 0x57, 0x40, 0x61, 0xbb, 0x7f, 0x37, 0xbc, 0x4c,
	0xdf, 0xb9, 0x99, 0x98, 0x70, 0x75, 0x30, 0xa0, 0x79, 0x1e, 0x0e, 0xb8, 0x3c, 0x69, 0x40, 0x61,
	0x82, 0x9e, 0x82, 0x7c, 0xbd, 0x7f, 0xd9, 0xb9, 0xc1, 0x6f, 0x71, 0x57, 0x5d, 0xa1, 0x63, 0x46,
	0x82, 0x20, 0x21, 0xf5, 0xce, 0x1b, 0xef, 0x46, 0xcd, 0xb3, 0x84, 0xd0, 0x8f, 0x40, 0x8a, 0x7b,
	0xad, 0x91, 0xa7, 0x82, 0x03, 0xe5, 0x70, 0x85, 0xb0, 0x8f, 0xe0, 0x62, 0x61, 0x8c, 0xae, 0xd5,
	0xc2, 0x81, 0x72, 0x98, 0x27, 0xc1, 0xcf, 0x60, 0x32, 0xb6, 0xf7, 0xbd, 0x79, 0x77, 0xab, 0xae,
	0xb2, 0xc9, 0xb0, 0x2f, 0x2a, 0xf7, 0xaf, 0x2f, 0xbf, 0x1b, 0xab, 0x6b, 0x14, 0x80, 0x7f, 0x95,
	0xff, 0xa8, 0xb0, 0x0d, 0x98, 0x2e, 0x09, 0x67, 0xe3, 0xff, 0xe6, 0x7a, 0x94, 0x7f, 0xca, 0x36,
	0x8f, 0x30, 0x52, 0xce, 0x7f, 0x7e, 0x93, 0x56, 0x12, 0x9b, 0x7b, 0x68, 0x45, 0x99, 0x1e, 0xee,
	0x9a, 0x54, 0x38, 0xdd, 0xae, 0x19, 0x1f, 0x25, 0xa2, 0x8e, 0xc5, 0xce, 0x70, 0x54, 0x2d, 0x9d,
	0xc3, 0x92, 0x8d, 0x59, 0xaa, 0xf0, 0x47, 0xda, 0x2a, 0xdf, 0x86, 0xa3, 0xd0, 0x3e, 0xc1, 0x36,
	0x4c, 0xc1, 0x25, 0x1e, 0xfe, 0x89, 0x2f, 0x7a, 0xa5, 0xcb, 0x9d, 0x0f, 0x40, 0xc1, 0xe8, 0xf9,
	0xd7, 0xfe, 0x18, 0xf7, 0xba, 0xde, 0xaf, 0xf8, 0xd2, 0xcb, 0x22, 0x5a, 0x00, 0xf7, 0xd7, 0x4c,
	0x1d, 0x16, 0x00, 0xff, 0x46, 0x2f, 0x00, 0x88, 0xde, 0x8e, 0xf8, 0xe3, 0x57, 0xe6, 0xb3, 0x92,
	0x64, 0x16, 0x3a, 0x11, 0xaf, 0x33, 0xea, 0xf7, 0xf8, 0x26, 0x19, 0x77, 0x62, 0x2a, 0x22, 0x99,
	0x95, 0x31, 0xcb, 0x7e, 0xa5, 0x1b, 0x54, 0xea, 0x47, 0x05, 0x5d, 0x7e, 0xc1, 0x5a, 0x11, 0x85,
	0xe2, 0xa5, 0x74, 0x20, 0x97, 0x52, 0x94, 0x3d, 0x6a, 0xc2, 0xea, 0xa8, 0xc2, 0xce, 0xbb, 0x95,
	0xae, 0x54, 0x44, 0x0f, 0x9c, 0x5e, 0x24, 0x70, 0xf9, 0x30, 0xb8, 0xc4, 0x74, 0xe8, 0xab, 0x44,
	0xf9, 0x6c, 0x48, 0x8e, 0x53, 0xd5, 0xce, 0x0d, 0x3b, 0x3b, 0xf0, 0x70, 0x66, 0x2c, 0x9c, 0xe7,
	0xa9, 0xc2, 0x29, 0x48, 0x71, 0x44, 0x55, 0x73, 0xa4, 0xb3, 0xb7, 0xc0, 0xea, 0xdb, 0x2b, 0xb4,
	0x01, 0xd6, 0x8c, 0x76, 0xd3, 0x74, 0xab, 0x67, 0x35, 0xd7, 0xb4, 0x4c, 0x03, 0xce, 0xa1, 0x4d,
	0xb0, 0x2e, 0x44, 0x0d, 0xcd, 0x6c, 0x69, 0x75, 0xa8, 0xc4, 0xec, 0xb4, 0x96, 0x63, 0xc1, 0xdc,
	0x51, 0x87, 0xbd, 0xa4, 0xb1, 0x53, 0x10, 0x82, 0x60, 0x95, 0x1a, 0x10, 0x27, 0xc4, 0x41, 0xa0,
	0x18, 0x4a, 0x70, 0xa3, 0x69, 0x11, 0x07, 0x2a, 0xb2, 0xcc, 0xf8, 0x39, 0x95, 0xe5, 0xd0, 0x1e,
	0xd8, 0x8e, 0xdb, 0x85, 0xaa, 0xf9, 0xa3, 0x6f, 0xd8, 0x10, 0xbc, 0x3b, 0x6f, 0x01, 0x48, 0x0d,
	0x6d, 0xab, 0x45, 0xaa, 0x46, 0x38, 0xcc, 0x36, 0xd8, 0x90, 0xa5, 0x75, 0xab, 0x4a, 0x03, 0xde,
	0x01, 0x48, 0x16, 0x13, 0xa3, 0x61, 0x39, 0x06, 0xcc, 0x1d, 0xfd, 0x3b, 0xc7, 0x8e, 0x2d, 0x52,
	0x01, 0x87, 0x01, 0x58, 0x4d, 0x83, 0xb8, 0xb6, 0xa3, 0x39, 0x2d, 0x3b, 0x04, 0xdf, 0x05, 0x9b,
	0x29, 0x55, 0xab, 0x09, 0x95, 0x4c, 0x1f, 0xdd, 0xfa, 0x99, 0x09, 0x73, 0xe8, 0x33, 0xb0, 0x97,
	0x52, 0xd5, 0x2c, 0x6c, 0xd6, 0x02, 0xcf, 0x79, 0xf4, 0x0c, 0x3c, 0x99, 0xa0, 0xa6, 0xfe, 0x0b,
	0x99, 0x06, 0x5a, 0xd5, 0x71, 0xcf, 0x34, 0x5c, 0x37, 0x74, 0xb8, 0x88, 0xf6, 0x41, 0x29, 0x65,
	0xf0, 0x4d, 0x0b, 0x1b, 0x76, 0x15, 0x9b, 0x35, 0xb8, 0x94, 0xa9, 0x37, 0x2d, 0xc7, 0x25, 0x86,
	0xa6, 0xbf, 0x86, 0xcb, 0xe8, 0x09, 0xd8, 0x4d, 0xe9, 0x39, 0xf8, 0x4a, 0xe6, 0xe8, 0x4d, 0x62,
	0xb2, 0xe1, 0x75, 0x98, 0xcf, 0x34, 0xa0, 0x3a, 0xb7, 0x69, 0x90, 0x06, 0x04, 0xe8, 0x29, 0x50,
	0x33, 0x0d, 0x82, 0xe0, 0x0a, 0x47, 0x7f, 0x59, 0x88, 0xf2, 0xcf, 0x7a, 0x41, 0xdc, 0x81, 0x18,
	0x9a, 0x6d, 0x99, 0x2e, 0x36, 0xdb, 0x5a, 0x1d, 0xeb, 0x70, 0x2e, 0x9e, 0x69, 0xae, 0xa5, 0xab,
	0x13, 0xad, 0xb1, 0x61, 0x3a, 0xd8, 0x79, 0x4d, 0xe7, 0xd8, 0x6a, 0xc2, 0x9c, 0x28, 0x09, 0x4d,
	0x6f, 0x60, 0xd3, 0xad, 0x5a, 0xe6, 0x19, 0xae, 0xc1, 0xf9, 0xa8, 0xd0, 0x0c, 0x5e, 0x14, 0x41,
	0x54, 0x2d, 0x62, 0xc0, 0x05, 0x51, 0xf3, 0xa6, 0xe5, 0xe2, 0x33, 0x17, 0x9b, 0x67, 0x16, 0x5c,
	0x14, 0x42, 0xa3, 0x8d, 0x43, 0xec, 0x25, 0x51, 0xc1, 0x15, 0x3d, 0x94, 0x2d, 0x8b, 0x94, 0x98,
	0x96, 0x4b, 0xac, 0x96, 0x63, 0xb8, 0x3a, 0xb6, 0x1d, 0x6c, 0xd6, 0x5a, 0xd8, 0x3e, 0x37, 0x08,
	0x5c, 0x89, 0x46, 0x16, 0x5a, 0xb7, 0x5a, 0xd7, 0xec, 0x73, 0x98, 0x47, 0xeb, 0xa0, 0x10, 0xfa,
	0x1a, 0x36, 0x86, 0x40, 0x10, 0xa9, 0xa2, 0xe9, 0x6e, 0xdb, 0xc4, 0xb0, 0x20, 0x86, 0x6c, 0x9b,
	0x98, 0xbb, 0xad, 0x8a, 0x35, 0x6e, 0xd7, 0x35, 0xd3, 0xb5, 0x5b, 0x95, 0x20, 0xec, 0x20, 0x4e,
	0xa6, 0x5f, 0x13, 0x3e, 0xa6, 0xe5, 0x56, 0x6a, 0x4d, 0x17, 0xeb, 0xb0, 0x28, 0xd2, 0x45, 0x1c,
	0xd7, 0x79, 0xdd, 0x34, 0xb8, 0xed, 0x3a, 0x2a, 0x02, 0x20, 0xc2, 0x77, 0x20, 0x14, 0x76, 0xb8,
	0xe9, 0xb6, 0xc9, 0x59, 0x38, 0xcd, 0x0d, 0x21, 0x37, 0x2d, 0xd7, 0x7e, 0x6d, 0x3b, 0x46, 0xc3,
	0x6d, 0x68, 0x55, 0x88, 0x44, 0x6f, 0x20, 0xe1, 0xac, 0x36, 0x05, 0x6f, 0x4c, 0xcb, 0x6d, 0x54,
	0x35, 0xdb, 0x71, 0x6b, 0xc4, 0x6a, 0x35, 0xe1, 0x96, 0x58, 0x9a, 0x00, 0x83, 0x2d, 0x02, 0x6e,
	0xc2, 0x6d, 0x51, 0x92, 0xc1, 0xa4, 0x1d, 0xd3, 0xac, 0xbb, 0xba, 0x61, 0xb3, 0x28, 0xe1, 0x8e,
	0x0c, 0x46, 0x13, 0x48, 0x6c, 0x3a, 0xf0, 0xee, 0xe9, 0x6f, 0x00, 0x6b, 0x64, 0xf6, 0xfd, 0x25,
	0x7a, 0x25, 0x9e, 0x9d, 0xaa, 0x43, 0xaf, 0xe3, 0x7b, 0x68, 0x33, 0x76, 0x77, 0x65, 0x2d, 0xbb,
	0x14, 0x7f, 0x5f, 0x09, 0x77, 0xd1, 0x39, 0xc9, 0xbb, 0x35, 0xe8, 0x7e, 0xb0, 0xf7, 0xb9, 0xf0,
	0x66, 0x97, 0x03, 0xb4, 0x27, 0x1b, 0xc6, 0x6e, 0x20, 0xa5, 0x52, 0x96, 0x4a, 0x20, 0x7d, 0x25,
	0xfe, 0x3b, 0x51, 0xf3, 0x7c, 0xb4, 0x23, 0xdb, 0x46, 0x1b, 0x55, 0x69, 0x37, 0x25, 0x17, 0x00,
	0x15, 0xe9, 0xb5, 0x8a, 0x27, 0x62, 0x3b, 0x71, 0x89, 0xe7, 0x20, 0x3b, 0x49, 0x71, 0x26, 0x06,
	0x4f, 0xc7, 0x07, 0x63, 0x98, 0x12, 0x06, 0x4f, 0xca, 0x93, 0xb8, 0x71, 0x3c, 0x2d, 0x4f, 0xb3,
	0x95, 0x02, 0xcf, 0x90, 0x5e, 0x97, 0x82, 0xd4, 0xa8, 0x71, 0x7b, 0x29, 0x39, 0x7b, 0x19, 0x9a,
	0xe4, 0xd4, 0xe8, 0x85, 0x26, 0x95, 0x1e, 0xf9, 0x49, 0xbc, 0x94, 0xbc, 0x5a, 0x67, 0x63, 0xa4,
	0xd2, 0x33, 0x25, 0x86, 0x29, 0x61, 0xa4, 0xd2, 0x93, 0x7e, 0x91, 0x96, 0xd2, 0x93, 0xf1, 0xc2,
	0x1c, 0xa5, 0x27, 0x7c, 0xe9, 0x95, 0xd2, 0x93, 0x78, 0x46, 0x2e, 0xed, 0x65, 0x68, 0xa4, 0x42,
	0x96, 0x9f, 0x30, 0x78, 0x82, 0x76, 0x53, 0xf7, 0x40, 0x0e, 0xa5, 0xa6, 0x15, 0x13, 0x90, 0x78,
	0x9a, 0x66, 0x42, 0x72, 0x62, 0x48, 0x3c, 0x59, 0x9f, 0x25, 0x1d, 0xe2, 0xe9, 0xda, 0x9f, 0xa4,
	0x16, 0xa8, 0x17, 0xb1, 0xc7, 0x8b, 0x20, 0x65, 0xa5, 0xa4, 0x8f, 0x94, 0xb4, 0x27, 0x99, 0xba,
	0x64, 0xf6, 0xc3, 0x93, 0xbf, 0x94, 0xfd, 0xc4, 0x3d, 0x45, 0xca, 0x7e, 0xf2, 0x9a, 0x40, 0x9b,
	0x50, 0x5e, 0x1c, 0x02, 0xa5, 0x92, 0x92, 0xcf, 0xa8, 0x52, 0x49, 0xc5, 0xce, 0x8a, 0xe5, 0xb9,
	0xca, 0xea, 0x9f, 0xdf, 0xef, 0x2b, 0x7f, 0x7f, 0xbf, 0xaf, 0xfc, 0xe3, 0xfd, 0xbe, 0xf2, 0x66,
	0x89, 0xfe, 0x07, 0xfd, 0xc5, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x6f, 0xa3, 0x81, 0xb5, 0x7e,
	0x1f, 0x00, 0x00,
}
