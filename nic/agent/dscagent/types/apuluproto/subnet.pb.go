// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: subnet.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import meta "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SubnetSpec captures subnet specific coniguration
type SubnetSpec struct {
	// unique identifier of the subnet
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// virtual private cloud this subnet is belongs to
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
	V4Prefix *IPv4Prefix `protobuf:"bytes,3,opt,name=V4Prefix" json:"V4Prefix,omitempty" meta:mandatory,immutable`
	// IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
	V6Prefix *IPv6Prefix `protobuf:"bytes,4,opt,name=V6Prefix" json:"V6Prefix,omitempty" meta:mandatory,immutable`
	// IPv4 Virtual Router (VR) IP of this subnet, this IP is owned by the device
	// and packets originated by this device carry this IP as source IP
	IPv4VirtualRouterIP uint32 `protobuf:"varint,5,opt,name=IPv4VirtualRouterIP,proto3" json:"IPv4VirtualRouterIP,omitempty"`
	// Ipv6 Virtual Router (VR) IP of this subnet, this IP is owned by the device
	// and packets originated by this device carry this IP as source IP
	IPv6VirtualRouterIP []byte `protobuf:"bytes,6,opt,name=IPv6VirtualRouterIP,proto3" json:"IPv6VirtualRouterIP,omitempty"`
	// Virtual Router (VR) MAC address, any packets originated or routed by
	// the device carry this MAC as source MAC
	VirtualRouterMac uint64 `protobuf:"varint,7,opt,name=VirtualRouterMac,proto3" json:"VirtualRouterMac,omitempty" meta:mandatory`
	// identifier of the IPv4 route table to be used
	V4RouteTableId []byte `protobuf:"bytes,8,opt,name=V4RouteTableId,proto3" json:"V4RouteTableId,omitempty" meta:mandatory`
	// identifier of the IPv6 route table to be used, if any
	V6RouteTableId []byte `protobuf:"bytes,9,opt,name=V6RouteTableId,proto3" json:"V6RouteTableId,omitempty"`
	// identifier of ingress IPv4 security policy to be enforced
	// NOTE: max. of 2 policies supported currently
	IngV4SecurityPolicyId [][]byte `protobuf:"bytes,10,rep,name=IngV4SecurityPolicyId" json:"IngV4SecurityPolicyId,omitempty"`
	// identifier of ingress IPv6 security policy to be enforced
	// NOTE: max. of 2 policies supported currently
	IngV6SecurityPolicyId [][]byte `protobuf:"bytes,11,rep,name=IngV6SecurityPolicyId" json:"IngV6SecurityPolicyId,omitempty"`
	// identifier of egress IPv4 security policy to be enforced
	// NOTE: max. of 2 policies supported currently
	EgV4SecurityPolicyId [][]byte `protobuf:"bytes,12,rep,name=EgV4SecurityPolicyId" json:"EgV4SecurityPolicyId,omitempty"`
	// identifier of egress IPv6 security policy to be enforced
	// NOTE: max. of 2 policies supported currently
	EgV6SecurityPolicyId [][]byte `protobuf:"bytes,13,rep,name=EgV6SecurityPolicyId" json:"EgV6SecurityPolicyId,omitempty"`
	// encapped traffic coming with the specified encap from fabric side will be
	// mapped to this subnet and traffic from workloads in this subnet will carry
	// this encap towards the fabric side
	FabricEncap *Encap `protobuf:"bytes,14,opt,name=FabricEncap" json:"FabricEncap,omitempty" meta:immutable`
	// when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
	// present, subnet needs to be attached to a PF/VF (aka. lif or host
	// interface), HostIf is list of such VF/PFs
	HostIf [][]byte `protobuf:"bytes,15,rep,name=HostIf" json:"HostIf,omitempty"`
	// DHCP policy to be applied in this subnet
	// NOTE:
	// 1. at any given time, a subnet can either have DHCP relay policy or
	//    DHCP proxy policy only and for simplicty on any given subnet we
	//    can't switch from one type of policy to another
	// 2. Multiple DHCP proxy policies per subnet is not supported
	// 3. More than two DHCP relay policies is not supported
	DHCPPolicyId [][]byte `protobuf:"bytes,16,rep,name=DHCPPolicyId" json:"DHCPPolicyId,omitempty"`
	// ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
	// header or in the Traffic Class field of IPv6 outer header, this value will
	// be written as-is (i.e., not interpreted) during encap time by the dataplane
	ToS uint32 `protobuf:"varint,17,opt,name=ToS,proto3" json:"ToS,omitempty"`
}

func (m *SubnetSpec) Reset()                    { *m = SubnetSpec{} }
func (m *SubnetSpec) String() string            { return proto.CompactTextString(m) }
func (*SubnetSpec) ProtoMessage()               {}
func (*SubnetSpec) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{0} }

func (m *SubnetSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SubnetSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *SubnetSpec) GetV4Prefix() *IPv4Prefix {
	if m != nil {
		return m.V4Prefix
	}
	return nil
}

func (m *SubnetSpec) GetV6Prefix() *IPv6Prefix {
	if m != nil {
		return m.V6Prefix
	}
	return nil
}

func (m *SubnetSpec) GetIPv4VirtualRouterIP() uint32 {
	if m != nil {
		return m.IPv4VirtualRouterIP
	}
	return 0
}

func (m *SubnetSpec) GetIPv6VirtualRouterIP() []byte {
	if m != nil {
		return m.IPv6VirtualRouterIP
	}
	return nil
}

func (m *SubnetSpec) GetVirtualRouterMac() uint64 {
	if m != nil {
		return m.VirtualRouterMac
	}
	return 0
}

func (m *SubnetSpec) GetV4RouteTableId() []byte {
	if m != nil {
		return m.V4RouteTableId
	}
	return nil
}

func (m *SubnetSpec) GetV6RouteTableId() []byte {
	if m != nil {
		return m.V6RouteTableId
	}
	return nil
}

func (m *SubnetSpec) GetIngV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV4SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetIngV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV6SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetEgV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV4SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetEgV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV6SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetFabricEncap() *Encap {
	if m != nil {
		return m.FabricEncap
	}
	return nil
}

func (m *SubnetSpec) GetHostIf() [][]byte {
	if m != nil {
		return m.HostIf
	}
	return nil
}

func (m *SubnetSpec) GetDHCPPolicyId() [][]byte {
	if m != nil {
		return m.DHCPPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetToS() uint32 {
	if m != nil {
		return m.ToS
	}
	return 0
}

// operational status of the subnet, if any
type SubnetStatus struct {
	// subnet hw id
	HwId uint32 `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
}

func (m *SubnetStatus) Reset()                    { *m = SubnetStatus{} }
func (m *SubnetStatus) String() string            { return proto.CompactTextString(m) }
func (*SubnetStatus) ProtoMessage()               {}
func (*SubnetStatus) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{1} }

func (m *SubnetStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

// stats of the subnet, if any
type SubnetStats struct {
}

func (m *SubnetStats) Reset()                    { *m = SubnetStats{} }
func (m *SubnetStats) String() string            { return proto.CompactTextString(m) }
func (*SubnetStats) ProtoMessage()               {}
func (*SubnetStats) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{2} }

// subnet object
type Subnet struct {
	*meta.TypeMeta `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	*meta.ObjMeta  `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           *SubnetSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         *SubnetStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
	Stats          *SubnetStats  `protobuf:"bytes,5,opt,name=Stats" json:"stats,omitempty"`
}

func (m *Subnet) Reset()                    { *m = Subnet{} }
func (m *Subnet) String() string            { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()               {}
func (*Subnet) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{3} }

func (m *Subnet) GetSpec() *SubnetSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Subnet) GetStatus() *SubnetStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Subnet) GetStats() *SubnetStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// subnet create and update request
type SubnetRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt    `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Request   []*SubnetSpec `protobuf:"bytes,2,rep,name=Request" json:"Request,omitempty"`
}

func (m *SubnetRequest) Reset()                    { *m = SubnetRequest{} }
func (m *SubnetRequest) String() string            { return proto.CompactTextString(m) }
func (*SubnetRequest) ProtoMessage()               {}
func (*SubnetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{4} }

func (m *SubnetRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SubnetRequest) GetRequest() []*SubnetSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// subnet create and update response
type SubnetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*SubnetStatus `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SubnetResponse) Reset()                    { *m = SubnetResponse{} }
func (m *SubnetResponse) String() string            { return proto.CompactTextString(m) }
func (*SubnetResponse) ProtoMessage()               {}
func (*SubnetResponse) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{5} }

func (m *SubnetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SubnetResponse) GetResponse() []*SubnetStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// subnet get request
type SubnetGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id" json:"Id,omitempty"`
}

func (m *SubnetGetRequest) Reset()                    { *m = SubnetGetRequest{} }
func (m *SubnetGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SubnetGetRequest) ProtoMessage()               {}
func (*SubnetGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{6} }

func (m *SubnetGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// subnet get response
type SubnetGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*Subnet `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *SubnetGetResponse) Reset()                    { *m = SubnetGetResponse{} }
func (m *SubnetGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SubnetGetResponse) ProtoMessage()               {}
func (*SubnetGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{7} }

func (m *SubnetGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SubnetGetResponse) GetResponse() []*Subnet {
	if m != nil {
		return m.Response
	}
	return nil
}

// subnet delete request
type SubnetDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt" json:"BatchCtxt,omitempty"`
	Id        [][]byte   `protobuf:"bytes,2,rep,name=Id" json:"Id,omitempty"`
}

func (m *SubnetDeleteRequest) Reset()                    { *m = SubnetDeleteRequest{} }
func (m *SubnetDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SubnetDeleteRequest) ProtoMessage()               {}
func (*SubnetDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{8} }

func (m *SubnetDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SubnetDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// subnet delete response
type SubnetDeleteResponse struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *SubnetDeleteResponse) Reset()                    { *m = SubnetDeleteResponse{} }
func (m *SubnetDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*SubnetDeleteResponse) ProtoMessage()               {}
func (*SubnetDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorSubnet, []int{9} }

func (m *SubnetDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*SubnetSpec)(nil), "pds.SubnetSpec")
	proto.RegisterType((*SubnetStatus)(nil), "pds.SubnetStatus")
	proto.RegisterType((*SubnetStats)(nil), "pds.SubnetStats")
	proto.RegisterType((*Subnet)(nil), "pds.Subnet")
	proto.RegisterType((*SubnetRequest)(nil), "pds.SubnetRequest")
	proto.RegisterType((*SubnetResponse)(nil), "pds.SubnetResponse")
	proto.RegisterType((*SubnetGetRequest)(nil), "pds.SubnetGetRequest")
	proto.RegisterType((*SubnetGetResponse)(nil), "pds.SubnetGetResponse")
	proto.RegisterType((*SubnetDeleteRequest)(nil), "pds.SubnetDeleteRequest")
	proto.RegisterType((*SubnetDeleteResponse)(nil), "pds.SubnetDeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SubnetSvc service

type SubnetSvcClient interface {
	SubnetCreate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error)
	SubnetUpdate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error)
	SubnetGet(ctx context.Context, in *SubnetGetRequest, opts ...grpc.CallOption) (*SubnetGetResponse, error)
	SubnetDelete(ctx context.Context, in *SubnetDeleteRequest, opts ...grpc.CallOption) (*SubnetDeleteResponse, error)
}

type subnetSvcClient struct {
	cc *grpc.ClientConn
}

func NewSubnetSvcClient(cc *grpc.ClientConn) SubnetSvcClient {
	return &subnetSvcClient{cc}
}

func (c *subnetSvcClient) SubnetCreate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error) {
	out := new(SubnetResponse)
	err := grpc.Invoke(ctx, "/pds.SubnetSvc/SubnetCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetUpdate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error) {
	out := new(SubnetResponse)
	err := grpc.Invoke(ctx, "/pds.SubnetSvc/SubnetUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetGet(ctx context.Context, in *SubnetGetRequest, opts ...grpc.CallOption) (*SubnetGetResponse, error) {
	out := new(SubnetGetResponse)
	err := grpc.Invoke(ctx, "/pds.SubnetSvc/SubnetGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetDelete(ctx context.Context, in *SubnetDeleteRequest, opts ...grpc.CallOption) (*SubnetDeleteResponse, error) {
	out := new(SubnetDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.SubnetSvc/SubnetDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SubnetSvc service

type SubnetSvcServer interface {
	SubnetCreate(context.Context, *SubnetRequest) (*SubnetResponse, error)
	SubnetUpdate(context.Context, *SubnetRequest) (*SubnetResponse, error)
	SubnetGet(context.Context, *SubnetGetRequest) (*SubnetGetResponse, error)
	SubnetDelete(context.Context, *SubnetDeleteRequest) (*SubnetDeleteResponse, error)
}

func RegisterSubnetSvcServer(s *grpc.Server, srv SubnetSvcServer) {
	s.RegisterService(&_SubnetSvc_serviceDesc, srv)
}

func _SubnetSvc_SubnetCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetCreate(ctx, req.(*SubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetUpdate(ctx, req.(*SubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetGet(ctx, req.(*SubnetGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetDelete(ctx, req.(*SubnetDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubnetSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SubnetSvc",
	HandlerType: (*SubnetSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubnetCreate",
			Handler:    _SubnetSvc_SubnetCreate_Handler,
		},
		{
			MethodName: "SubnetUpdate",
			Handler:    _SubnetSvc_SubnetUpdate_Handler,
		},
		{
			MethodName: "SubnetGet",
			Handler:    _SubnetSvc_SubnetGet_Handler,
		},
		{
			MethodName: "SubnetDelete",
			Handler:    _SubnetSvc_SubnetDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subnet.proto",
}

func (m *SubnetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VPCId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.VPCId)))
		i += copy(dAtA[i:], m.VPCId)
	}
	if m.V4Prefix != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.V4Prefix.Size()))
		n1, err := m.V4Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.V6Prefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.V6Prefix.Size()))
		n2, err := m.V6Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.IPv4VirtualRouterIP != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.IPv4VirtualRouterIP))
	}
	if len(m.IPv6VirtualRouterIP) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.IPv6VirtualRouterIP)))
		i += copy(dAtA[i:], m.IPv6VirtualRouterIP)
	}
	if m.VirtualRouterMac != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.VirtualRouterMac))
	}
	if len(m.V4RouteTableId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.V4RouteTableId)))
		i += copy(dAtA[i:], m.V4RouteTableId)
	}
	if len(m.V6RouteTableId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.V6RouteTableId)))
		i += copy(dAtA[i:], m.V6RouteTableId)
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for _, b := range m.IngV4SecurityPolicyId {
			dAtA[i] = 0x52
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for _, b := range m.IngV6SecurityPolicyId {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for _, b := range m.EgV4SecurityPolicyId {
			dAtA[i] = 0x62
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for _, b := range m.EgV6SecurityPolicyId {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FabricEncap != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.FabricEncap.Size()))
		n3, err := m.FabricEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.HostIf) > 0 {
		for _, b := range m.HostIf {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.DHCPPolicyId) > 0 {
		for _, b := range m.DHCPPolicyId {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.ToS != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.ToS))
	}
	return i, nil
}

func (m *SubnetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.HwId))
	}
	return i, nil
}

func (m *SubnetStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Subnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subnet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.TypeMeta.Size()))
		n4, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ObjMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.ObjMeta.Size()))
		n5, err := m.ObjMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.Spec.Size()))
		n6, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.Status.Size()))
		n7, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.Stats.Size()))
		n8, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SubnetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.BatchCtxt.Size()))
		n9, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SubnetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SubnetGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SubnetGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SubnetDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BatchCtxt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(m.BatchCtxt.Size()))
		n10, err := m.BatchCtxt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSubnet(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SubnetDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA12 := make([]byte, len(m.ApiStatus)*10)
		var j11 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintSubnet(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	return i, nil
}

func encodeVarintSubnet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SubnetSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.V4Prefix != nil {
		l = m.V4Prefix.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.V6Prefix != nil {
		l = m.V6Prefix.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.IPv4VirtualRouterIP != 0 {
		n += 1 + sovSubnet(uint64(m.IPv4VirtualRouterIP))
	}
	l = len(m.IPv6VirtualRouterIP)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.VirtualRouterMac != 0 {
		n += 1 + sovSubnet(uint64(m.VirtualRouterMac))
	}
	l = len(m.V4RouteTableId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.V6RouteTableId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for _, b := range m.IngV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for _, b := range m.IngV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for _, b := range m.EgV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for _, b := range m.EgV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.FabricEncap != nil {
		l = m.FabricEncap.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.HostIf) > 0 {
		for _, b := range m.HostIf {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.DHCPPolicyId) > 0 {
		for _, b := range m.DHCPPolicyId {
			l = len(b)
			n += 2 + l + sovSubnet(uint64(l))
		}
	}
	if m.ToS != 0 {
		n += 2 + sovSubnet(uint64(m.ToS))
	}
	return n
}

func (m *SubnetStatus) Size() (n int) {
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovSubnet(uint64(m.HwId))
	}
	return n
}

func (m *SubnetStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Subnet) Size() (n int) {
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	return n
}

func (m *SubnetRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	return n
}

func (m *SubnetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSubnet(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	return n
}

func (m *SubnetGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	return n
}

func (m *SubnetGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSubnet(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	return n
}

func (m *SubnetDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	return n
}

func (m *SubnetDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovSubnet(uint64(e))
		}
		n += 1 + sovSubnet(uint64(l)) + l
	}
	return n
}

func sovSubnet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSubnet(x uint64) (n int) {
	return sovSubnet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubnetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V4Prefix == nil {
				m.V4Prefix = &IPv4Prefix{}
			}
			if err := m.V4Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V6Prefix == nil {
				m.V6Prefix = &IPv6Prefix{}
			}
			if err := m.V6Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4VirtualRouterIP", wireType)
			}
			m.IPv4VirtualRouterIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv4VirtualRouterIP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6VirtualRouterIP", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPv6VirtualRouterIP = append(m.IPv6VirtualRouterIP[:0], dAtA[iNdEx:postIndex]...)
			if m.IPv6VirtualRouterIP == nil {
				m.IPv6VirtualRouterIP = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterMac", wireType)
			}
			m.VirtualRouterMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRouterMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4RouteTableId = append(m.V4RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V4RouteTableId == nil {
				m.V4RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6RouteTableId = append(m.V6RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V6RouteTableId == nil {
				m.V6RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV4SecurityPolicyId = append(m.IngV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV4SecurityPolicyId[len(m.IngV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV6SecurityPolicyId = append(m.IngV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV6SecurityPolicyId[len(m.IngV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV4SecurityPolicyId = append(m.EgV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV4SecurityPolicyId[len(m.EgV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV6SecurityPolicyId = append(m.EgV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV6SecurityPolicyId[len(m.EgV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FabricEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FabricEncap == nil {
				m.FabricEncap = &Encap{}
			}
			if err := m.FabricEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIf = append(m.HostIf, make([]byte, postIndex-iNdEx))
			copy(m.HostIf[len(m.HostIf)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DHCPPolicyId = append(m.DHCPPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.DHCPPolicyId[len(m.DHCPPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToS", wireType)
			}
			m.ToS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &meta.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &meta.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SubnetSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SubnetStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SubnetStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SubnetSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SubnetStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Subnet{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubnet
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubnet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubnet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSubnet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSubnet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSubnet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubnet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("subnet.proto", fileDescriptorSubnet) }

var fileDescriptorSubnet = []byte{
	// 825 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0x4d, 0x6f, 0xf2, 0x46,
	0x10, 0xc7, 0x6b, 0x43, 0x08, 0x19, 0x1b, 0x43, 0x96, 0x3c, 0x91, 0x8b, 0xaa, 0x80, 0x7c, 0x68,
	0xa9, 0x44, 0x69, 0x45, 0x11, 0x55, 0x9f, 0x54, 0xad, 0x6a, 0x42, 0x12, 0xab, 0x8a, 0x82, 0x4c,
	0xc2, 0xdd, 0xd8, 0x9b, 0xd4, 0x11, 0x60, 0xd7, 0x5e, 0xd2, 0xf0, 0x05, 0xfa, 0xc5, 0x7a, 0xe9,
	0x31, 0x9f, 0x00, 0x55, 0x39, 0xe6, 0x98, 0x43, 0xcf, 0x95, 0xd7, 0xeb, 0x17, 0xc0, 0x52, 0xf2,
	0xe4, 0x12, 0x79, 0x67, 0xe6, 0x37, 0xf3, 0x9f, 0xc9, 0xce, 0x0a, 0x10, 0xfd, 0xc5, 0x64, 0x8e,
	0x49, 0xdb, 0xf5, 0x1c, 0xe2, 0xa0, 0x9c, 0x6b, 0xf9, 0x35, 0xb8, 0x75, 0x6e, 0x9d, 0xd0, 0x50,
	0x2b, 0xcf, 0x30, 0x31, 0xbe, 0x0d, 0xfe, 0x30, 0x83, 0x40, 0x96, 0x2e, 0xf6, 0xc3, 0x83, 0xf2,
	0x5f, 0x01, 0x60, 0x44, 0xf9, 0x91, 0x8b, 0x4d, 0xd4, 0x02, 0x5e, 0xb3, 0x64, 0xae, 0xc1, 0x35,
	0x45, 0xf5, 0x8b, 0x97, 0x55, 0x5d, 0x0e, 0xb8, 0x8f, 0x33, 0x63, 0x6e, 0x19, 0xc4, 0xf1, 0x96,
	0x2d, 0x7b, 0x36, 0x5b, 0x10, 0x63, 0x32, 0xc5, 0x3a, 0xaf, 0x59, 0xa8, 0x03, 0x3b, 0xe3, 0x61,
	0x5f, 0xb3, 0x64, 0xfe, 0x0d, 0x40, 0x18, 0x8a, 0x7e, 0x83, 0xe2, 0xb8, 0x3b, 0xf4, 0xf0, 0x8d,
	0xfd, 0x20, 0xe7, 0x1a, 0x5c, 0x53, 0xe8, 0xec, 0xb7, 0x43, 0x41, 0xda, 0xf0, 0x9e, 0x39, 0x5e,
	0xc9, 0x14, 0x27, 0xa0, 0xc9, 0x7a, 0x2c, 0x59, 0x7e, 0x33, 0x59, 0xef, 0x8d, 0xc9, 0x58, 0x1c,
	0xfa, 0x0e, 0xaa, 0x81, 0x84, 0xb1, 0xed, 0x91, 0x85, 0x31, 0xd5, 0x9d, 0x05, 0xc1, 0x9e, 0x36,
	0x94, 0x77, 0x1a, 0x5c, 0xb3, 0xa4, 0x67, 0xb9, 0x18, 0xd1, 0xdb, 0x24, 0x0a, 0xc1, 0x34, 0xf4,
	0x2c, 0x17, 0xfa, 0x19, 0x2a, 0x6b, 0xa6, 0x0b, 0xc3, 0x94, 0x77, 0x1b, 0x5c, 0x33, 0xaf, 0xa2,
	0x97, 0x55, 0x5d, 0x5a, 0x57, 0xa9, 0x6f, 0xc5, 0xa2, 0x8f, 0x20, 0x8d, 0xbb, 0xf4, 0x78, 0x15,
	0xa8, 0xd7, 0x2c, 0xb9, 0x48, 0x47, 0x9f, 0x45, 0x6f, 0x44, 0xa2, 0x2f, 0x41, 0x1a, 0xf7, 0xd6,
	0xd8, 0x3d, 0x2a, 0x74, 0xc3, 0x8a, 0xba, 0xf0, 0x41, 0x9b, 0xdf, 0x8e, 0xbb, 0x23, 0x6c, 0x2e,
	0x3c, 0x9b, 0x2c, 0x87, 0xce, 0xd4, 0x36, 0x97, 0x9a, 0x25, 0x43, 0x23, 0xd7, 0x14, 0xf5, 0x6c,
	0x67, 0x44, 0xf5, 0xb6, 0x28, 0x21, 0xa1, 0xb6, 0x9c, 0xa8, 0x03, 0x07, 0x83, 0xac, 0x52, 0x22,
	0x85, 0x32, 0x7d, 0x8c, 0xd9, 0x2e, 0x54, 0x8a, 0x99, 0xed, 0x3a, 0x2a, 0x08, 0xa7, 0xc6, 0xc4,
	0xb3, 0xcd, 0xc1, 0xdc, 0x34, 0x5c, 0x59, 0xa2, 0x77, 0x45, 0x64, 0x77, 0x85, 0xda, 0x52, 0x23,
	0x4c, 0x2e, 0x47, 0x1a, 0x42, 0x87, 0x50, 0x38, 0x77, 0x7c, 0xa2, 0xdd, 0xc8, 0x65, 0x5a, 0x89,
	0x9d, 0x90, 0x02, 0xe2, 0xc9, 0x79, 0x7f, 0x18, 0xeb, 0xa8, 0x50, 0xef, 0x9a, 0x0d, 0x55, 0x20,
	0x77, 0xe5, 0x8c, 0xe4, 0x7d, 0x7a, 0x97, 0x82, 0x4f, 0x45, 0x01, 0x91, 0xed, 0x1d, 0x31, 0xc8,
	0xc2, 0x47, 0x08, 0xf2, 0xe7, 0x7f, 0xb2, 0xdd, 0x2b, 0xe9, 0xf4, 0x5b, 0x29, 0x81, 0x90, 0xc4,
	0xf8, 0xca, 0xdf, 0x3c, 0x14, 0xc2, 0x33, 0x3a, 0x86, 0xe2, 0xd5, 0xd2, 0xc5, 0x17, 0x98, 0x18,
	0x94, 0x10, 0x3a, 0x52, 0x9b, 0xae, 0x78, 0x64, 0x55, 0xcb, 0x8f, 0xab, 0x3a, 0xf7, 0xbc, 0xaa,
	0xef, 0xb6, 0xec, 0xf9, 0xd4, 0x9e, 0x63, 0x3d, 0x06, 0xd0, 0x00, 0xe0, 0x72, 0x72, 0x87, 0x4d,
	0x42, 0x71, 0x9e, 0xe2, 0xa5, 0x10, 0xbf, 0x9c, 0xdc, 0x51, 0xfa, 0x90, 0xd1, 0x74, 0x20, 0x2d,
	0x67, 0x66, 0x13, 0x3c, 0x73, 0xc9, 0x52, 0x4f, 0x81, 0xe8, 0x07, 0xc8, 0x07, 0x6f, 0x06, 0xdb,
	0xe2, 0x72, 0xdb, 0xb5, 0xfc, 0x76, 0xf2, 0x94, 0xa8, 0x28, 0xc0, 0x7d, 0x17, 0x9b, 0x29, 0x9c,
	0x02, 0xe8, 0x17, 0x28, 0x84, 0x4d, 0xc7, 0x3b, 0x9b, 0x42, 0xa9, 0x43, 0x3d, 0x78, 0x5e, 0xd5,
	0x2b, 0x3e, 0xfd, 0x4e, 0xe1, 0x0c, 0x43, 0xc7, 0xb0, 0x43, 0x27, 0x42, 0x77, 0x53, 0xe8, 0x54,
	0x36, 0x78, 0x5f, 0xad, 0x3e, 0xaf, 0xea, 0xe5, 0x00, 0x4f, 0xd3, 0x21, 0xa3, 0xdc, 0x41, 0x29,
	0x0c, 0xd5, 0xf1, 0x1f, 0x0b, 0xec, 0x13, 0xd4, 0x86, 0x3d, 0xd5, 0x20, 0xe6, 0xef, 0x7d, 0xf2,
	0x40, 0xd8, 0x30, 0x2b, 0xec, 0x66, 0xc4, 0x76, 0x3d, 0x09, 0x41, 0x5f, 0xc3, 0x2e, 0x43, 0x65,
	0xbe, 0x91, 0xcb, 0x68, 0x5d, 0x8f, 0xfc, 0x8a, 0x03, 0x52, 0x54, 0xcb, 0x77, 0x9d, 0xb9, 0x8f,
	0x83, 0x62, 0xbf, 0xba, 0x36, 0x6b, 0x3f, 0x28, 0x26, 0xc5, 0xc5, 0x62, 0xbb, 0x9e, 0x84, 0xa0,
	0x6f, 0xa0, 0x18, 0xb1, 0xac, 0xda, 0xf6, 0xb4, 0xf4, 0x38, 0x44, 0x51, 0xa0, 0x12, 0x7a, 0xce,
	0x92, 0xfe, 0x24, 0xf6, 0xa6, 0x07, 0xb7, 0x92, 0xd7, 0x2c, 0x65, 0x0a, 0xfb, 0xa9, 0x98, 0x77,
	0xea, 0xfa, 0x6a, 0x4b, 0x97, 0x90, 0xd2, 0x95, 0x52, 0x74, 0x0d, 0xd5, 0xd0, 0x76, 0x82, 0xa7,
	0x98, 0xe0, 0xf7, 0x0e, 0x3d, 0x6c, 0x82, 0x8f, 0x9b, 0x38, 0x85, 0x83, 0xf5, 0xb4, 0xd9, 0x7d,
	0xe4, 0x5e, 0xe9, 0xa3, 0xf3, 0x17, 0x0f, 0x7b, 0x6c, 0x96, 0xf7, 0x26, 0xfa, 0x31, 0x5a, 0xca,
	0xbe, 0x87, 0x0d, 0x82, 0x11, 0x4a, 0xf7, 0x14, 0x2a, 0xaf, 0x55, 0xd7, 0x6c, 0xac, 0xcb, 0xcf,
	0x12, 0xf4, 0xda, 0xb5, 0x3e, 0x11, 0xfd, 0x29, 0x92, 0x70, 0x86, 0x09, 0xfa, 0x90, 0x8a, 0x49,
	0xfe, 0x89, 0xb5, 0xc3, 0x4d, 0x73, 0x4c, 0x0f, 0xa2, 0xc2, 0xe1, 0x24, 0x90, 0x9c, 0x8a, 0x5c,
	0x9b, 0x79, 0xed, 0xf3, 0x0c, 0x4f, 0x94, 0x46, 0x15, 0xff, 0x79, 0x3a, 0xe2, 0x1e, 0x9f, 0x8e,
	0xb8, 0x7f, 0x9f, 0x8e, 0xb8, 0x49, 0x81, 0xfe, 0x3a, 0xf8, 0xfe, 0xff, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x96, 0x5b, 0x02, 0xf4, 0x5c, 0x08, 0x00, 0x00,
}
