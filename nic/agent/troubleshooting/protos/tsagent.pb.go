// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tsagent.proto

/*
	Package state is a generated protocol buffer package.

	Service name

	It is generated from these files:
		tsagent.proto

	It has these top-level messages:
		CopiedDropReasons
		DropRuleSpec
		DropMonitorObj
		FlowMonitorRuleSpec
		FlowMonitorObj
		MirrorSessionObj
*/
package state

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// copied from proto/hal/types.proto... Find out a way to include proto/hal/types.proto
// CopiedDropReasons
type CopiedDropReasons struct {
	DropMalformedPkt                bool `protobuf:"varint,1,opt,name=drop_malformed_pkt,json=dropMalformedPkt,proto3" json:"drop_malformed_pkt,omitempty"`
	DropInputMapping                bool `protobuf:"varint,2,opt,name=drop_input_mapping,json=dropInputMapping,proto3" json:"drop_input_mapping,omitempty"`
	DropInputMappingDejavu          bool `protobuf:"varint,3,opt,name=drop_input_mapping_dejavu,json=dropInputMappingDejavu,proto3" json:"drop_input_mapping_dejavu,omitempty"`
	DropFlowHit                     bool `protobuf:"varint,4,opt,name=drop_flow_hit,json=dropFlowHit,proto3" json:"drop_flow_hit,omitempty"`
	DropFlowMiss                    bool `protobuf:"varint,5,opt,name=drop_flow_miss,json=dropFlowMiss,proto3" json:"drop_flow_miss,omitempty"`
	DropNacl                        bool `protobuf:"varint,6,opt,name=drop_nacl,json=dropNacl,proto3" json:"drop_nacl,omitempty"`
	DropIpsg                        bool `protobuf:"varint,7,opt,name=drop_ipsg,json=dropIpsg,proto3" json:"drop_ipsg,omitempty"`
	DropIpNormalization             bool `protobuf:"varint,8,opt,name=drop_ip_normalization,json=dropIpNormalization,proto3" json:"drop_ip_normalization,omitempty"`
	DropTcpNormalization            bool `protobuf:"varint,9,opt,name=drop_tcp_normalization,json=dropTcpNormalization,proto3" json:"drop_tcp_normalization,omitempty"`
	DropTcpRstWithInvalidAckNum     bool `protobuf:"varint,10,opt,name=drop_tcp_rst_with_invalid_ack_num,json=dropTcpRstWithInvalidAckNum,proto3" json:"drop_tcp_rst_with_invalid_ack_num,omitempty"`
	DropTcpNonSynFirstPkt           bool `protobuf:"varint,11,opt,name=drop_tcp_non_syn_first_pkt,json=dropTcpNonSynFirstPkt,proto3" json:"drop_tcp_non_syn_first_pkt,omitempty"`
	DropIcmpNormalization           bool `protobuf:"varint,12,opt,name=drop_icmp_normalization,json=dropIcmpNormalization,proto3" json:"drop_icmp_normalization,omitempty"`
	DropInputPropertiesMiss         bool `protobuf:"varint,13,opt,name=drop_input_properties_miss,json=dropInputPropertiesMiss,proto3" json:"drop_input_properties_miss,omitempty"`
	DropTcpOutOfWindow              bool `protobuf:"varint,14,opt,name=drop_tcp_out_of_window,json=dropTcpOutOfWindow,proto3" json:"drop_tcp_out_of_window,omitempty"`
	DropTcpSplitHandshake           bool `protobuf:"varint,15,opt,name=drop_tcp_split_handshake,json=dropTcpSplitHandshake,proto3" json:"drop_tcp_split_handshake,omitempty"`
	DropTcpWinZeroDrop              bool `protobuf:"varint,16,opt,name=drop_tcp_win_zero_drop,json=dropTcpWinZeroDrop,proto3" json:"drop_tcp_win_zero_drop,omitempty"`
	DropTcpDataAfterFin             bool `protobuf:"varint,17,opt,name=drop_tcp_data_after_fin,json=dropTcpDataAfterFin,proto3" json:"drop_tcp_data_after_fin,omitempty"`
	DropTcpNonRstPktAfterRst        bool `protobuf:"varint,18,opt,name=drop_tcp_non_rst_pkt_after_rst,json=dropTcpNonRstPktAfterRst,proto3" json:"drop_tcp_non_rst_pkt_after_rst,omitempty"`
	DropTcpInvalidResponderFirstPkt bool `protobuf:"varint,19,opt,name=drop_tcp_invalid_responder_first_pkt,json=dropTcpInvalidResponderFirstPkt,proto3" json:"drop_tcp_invalid_responder_first_pkt,omitempty"`
	DropTcpUnexpectedPkt            bool `protobuf:"varint,20,opt,name=drop_tcp_unexpected_pkt,json=dropTcpUnexpectedPkt,proto3" json:"drop_tcp_unexpected_pkt,omitempty"`
	DropSrcLifMismatch              bool `protobuf:"varint,21,opt,name=drop_src_lif_mismatch,json=dropSrcLifMismatch,proto3" json:"drop_src_lif_mismatch,omitempty"`
	DropParserIcrcError             bool `protobuf:"varint,22,opt,name=drop_parser_icrc_error,json=dropParserIcrcError,proto3" json:"drop_parser_icrc_error,omitempty"`
	DropParseLenError               bool `protobuf:"varint,23,opt,name=drop_parse_len_error,json=dropParseLenError,proto3" json:"drop_parse_len_error,omitempty"`
	DropHardwareError               bool `protobuf:"varint,24,opt,name=drop_hardware_error,json=dropHardwareError,proto3" json:"drop_hardware_error,omitempty"`
}

func (m *CopiedDropReasons) Reset()                    { *m = CopiedDropReasons{} }
func (m *CopiedDropReasons) String() string            { return proto.CompactTextString(m) }
func (*CopiedDropReasons) ProtoMessage()               {}
func (*CopiedDropReasons) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{0} }

func (m *CopiedDropReasons) GetDropMalformedPkt() bool {
	if m != nil {
		return m.DropMalformedPkt
	}
	return false
}

func (m *CopiedDropReasons) GetDropInputMapping() bool {
	if m != nil {
		return m.DropInputMapping
	}
	return false
}

func (m *CopiedDropReasons) GetDropInputMappingDejavu() bool {
	if m != nil {
		return m.DropInputMappingDejavu
	}
	return false
}

func (m *CopiedDropReasons) GetDropFlowHit() bool {
	if m != nil {
		return m.DropFlowHit
	}
	return false
}

func (m *CopiedDropReasons) GetDropFlowMiss() bool {
	if m != nil {
		return m.DropFlowMiss
	}
	return false
}

func (m *CopiedDropReasons) GetDropNacl() bool {
	if m != nil {
		return m.DropNacl
	}
	return false
}

func (m *CopiedDropReasons) GetDropIpsg() bool {
	if m != nil {
		return m.DropIpsg
	}
	return false
}

func (m *CopiedDropReasons) GetDropIpNormalization() bool {
	if m != nil {
		return m.DropIpNormalization
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpNormalization() bool {
	if m != nil {
		return m.DropTcpNormalization
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpRstWithInvalidAckNum() bool {
	if m != nil {
		return m.DropTcpRstWithInvalidAckNum
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpNonSynFirstPkt() bool {
	if m != nil {
		return m.DropTcpNonSynFirstPkt
	}
	return false
}

func (m *CopiedDropReasons) GetDropIcmpNormalization() bool {
	if m != nil {
		return m.DropIcmpNormalization
	}
	return false
}

func (m *CopiedDropReasons) GetDropInputPropertiesMiss() bool {
	if m != nil {
		return m.DropInputPropertiesMiss
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpOutOfWindow() bool {
	if m != nil {
		return m.DropTcpOutOfWindow
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpSplitHandshake() bool {
	if m != nil {
		return m.DropTcpSplitHandshake
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpWinZeroDrop() bool {
	if m != nil {
		return m.DropTcpWinZeroDrop
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpDataAfterFin() bool {
	if m != nil {
		return m.DropTcpDataAfterFin
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpNonRstPktAfterRst() bool {
	if m != nil {
		return m.DropTcpNonRstPktAfterRst
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpInvalidResponderFirstPkt() bool {
	if m != nil {
		return m.DropTcpInvalidResponderFirstPkt
	}
	return false
}

func (m *CopiedDropReasons) GetDropTcpUnexpectedPkt() bool {
	if m != nil {
		return m.DropTcpUnexpectedPkt
	}
	return false
}

func (m *CopiedDropReasons) GetDropSrcLifMismatch() bool {
	if m != nil {
		return m.DropSrcLifMismatch
	}
	return false
}

func (m *CopiedDropReasons) GetDropParserIcrcError() bool {
	if m != nil {
		return m.DropParserIcrcError
	}
	return false
}

func (m *CopiedDropReasons) GetDropParseLenError() bool {
	if m != nil {
		return m.DropParseLenError
	}
	return false
}

func (m *CopiedDropReasons) GetDropHardwareError() bool {
	if m != nil {
		return m.DropHardwareError
	}
	return false
}

// DropRuleSpec
type DropRuleSpec struct {
	CopiedDropReasons `protobuf:"bytes,1,opt,name=DropReasons,embedded=DropReasons" json:",inline"`
}

func (m *DropRuleSpec) Reset()                    { *m = DropRuleSpec{} }
func (m *DropRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*DropRuleSpec) ProtoMessage()               {}
func (*DropRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{1} }

// DropMonitorObj maintains drop rule related id allocation and is storable in emdb
type DropMonitorObj struct {
	api.TypeMeta     `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta   `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec             DropRuleSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,inline"`
	RuleID           uint64       `protobuf:"varint,4,opt,name=RuleID,proto3" json:"rule-id,omitempty"`
	MirrorSessionIDs []uint64     `protobuf:"varint,5,rep,packed,name=MirrorSessionIDs" json:"mirror-ids,omitempty"`
}

func (m *DropMonitorObj) Reset()                    { *m = DropMonitorObj{} }
func (m *DropMonitorObj) String() string            { return proto.CompactTextString(m) }
func (*DropMonitorObj) ProtoMessage()               {}
func (*DropMonitorObj) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{2} }

func (m *DropMonitorObj) GetSpec() DropRuleSpec {
	if m != nil {
		return m.Spec
	}
	return DropRuleSpec{}
}

func (m *DropMonitorObj) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DropMonitorObj) GetMirrorSessionIDs() []uint64 {
	if m != nil {
		return m.MirrorSessionIDs
	}
	return nil
}

// FlowMonitorRuleSpec
type FlowMonitorRuleSpec struct {
	SourceIP      string `protobuf:"bytes,1,opt,name=SourceIP,proto3" json:"sip,omitempty"`
	DestIP        string `protobuf:"bytes,2,opt,name=DestIP,proto3" json:"dip,omitempty"`
	SourceMac     uint64 `protobuf:"varint,3,opt,name=SourceMac,proto3" json:"smac,omitempty"`
	DestMac       uint64 `protobuf:"varint,4,opt,name=DestMac,proto3" json:"dmac,omitempty"`
	EtherType     uint32 `protobuf:"varint,5,opt,name=EtherType,proto3" json:"ethertype,omitempty"`
	Protocol      uint32 `protobuf:"varint,6,opt,name=Protocol,proto3" json:"proto,omitempty"`
	SourceL4Port  uint32 `protobuf:"varint,7,opt,name=SourceL4Port,proto3" json:"srcl4port,omitempty"`
	DestL4Port    uint32 `protobuf:"varint,8,opt,name=DestL4Port,proto3" json:"destl4port,omitempty"`
	SourceGroupID uint64 `protobuf:"varint,9,opt,name=SourceGroupID,proto3" json:"srcGrp,omitempty"`
	DestGroupID   uint64 `protobuf:"varint,10,opt,name=DestGroupID,proto3" json:"destGrp,omitempty"`
}

func (m *FlowMonitorRuleSpec) Reset()                    { *m = FlowMonitorRuleSpec{} }
func (m *FlowMonitorRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleSpec) ProtoMessage()               {}
func (*FlowMonitorRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{3} }

func (m *FlowMonitorRuleSpec) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *FlowMonitorRuleSpec) GetDestIP() string {
	if m != nil {
		return m.DestIP
	}
	return ""
}

func (m *FlowMonitorRuleSpec) GetSourceMac() uint64 {
	if m != nil {
		return m.SourceMac
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestMac() uint64 {
	if m != nil {
		return m.DestMac
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetSourceL4Port() uint32 {
	if m != nil {
		return m.SourceL4Port
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestL4Port() uint32 {
	if m != nil {
		return m.DestL4Port
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetSourceGroupID() uint64 {
	if m != nil {
		return m.SourceGroupID
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestGroupID() uint64 {
	if m != nil {
		return m.DestGroupID
	}
	return 0
}

// FlowMonitorObj maintains flow rule related id allocation and is storable in emdb
type FlowMonitorObj struct {
	api.TypeMeta     `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta   `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec             FlowMonitorRuleSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,inline"`
	RuleID           uint64              `protobuf:"varint,4,opt,name=RuleID,proto3" json:"rule-id,omitempty"`
	MirrorSessionIDs []uint64            `protobuf:"varint,5,rep,packed,name=MirrorSessionIDs" json:"mirror-ids,omitempty"`
}

func (m *FlowMonitorObj) Reset()                    { *m = FlowMonitorObj{} }
func (m *FlowMonitorObj) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorObj) ProtoMessage()               {}
func (*FlowMonitorObj) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{4} }

func (m *FlowMonitorObj) GetSpec() FlowMonitorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return FlowMonitorRuleSpec{}
}

func (m *FlowMonitorObj) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *FlowMonitorObj) GetMirrorSessionIDs() []uint64 {
	if m != nil {
		return m.MirrorSessionIDs
	}
	return nil
}

// MirrorSessionObj maintains mirrorsession related id allocation and is storable in emdb
type MirrorSessionObj struct {
	api.TypeMeta       `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta     `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	MirrorID           uint64   `protobuf:"varint,3,opt,name=MirrorID,proto3" json:"MirrorID ,omitempty"`
	Created            bool     `protobuf:"varint,4,opt,name=Created,proto3" json:"MirrorCreated ,omitempty"`
	Handle             uint64   `protobuf:"varint,5,opt,name=Handle,proto3" json:"MirrorHandle ,omitempty"`
	FlowMonitorRuleIDs []uint64 `protobuf:"varint,6,rep,packed,name=FlowMonitorRuleIDs" json:"FlowRuleIDList ,omitempty"`
	DropMonitorRuleIDs []uint64 `protobuf:"varint,7,rep,packed,name=DropMonitorRuleIDs" json:"DropRuleIDList ,omitempty"`
}

func (m *MirrorSessionObj) Reset()                    { *m = MirrorSessionObj{} }
func (m *MirrorSessionObj) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionObj) ProtoMessage()               {}
func (*MirrorSessionObj) Descriptor() ([]byte, []int) { return fileDescriptorTsagent, []int{5} }

func (m *MirrorSessionObj) GetMirrorID() uint64 {
	if m != nil {
		return m.MirrorID
	}
	return 0
}

func (m *MirrorSessionObj) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

func (m *MirrorSessionObj) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *MirrorSessionObj) GetFlowMonitorRuleIDs() []uint64 {
	if m != nil {
		return m.FlowMonitorRuleIDs
	}
	return nil
}

func (m *MirrorSessionObj) GetDropMonitorRuleIDs() []uint64 {
	if m != nil {
		return m.DropMonitorRuleIDs
	}
	return nil
}

func init() {
	proto.RegisterType((*CopiedDropReasons)(nil), "tsagent.CopiedDropReasons")
	proto.RegisterType((*DropRuleSpec)(nil), "tsagent.DropRuleSpec")
	proto.RegisterType((*DropMonitorObj)(nil), "tsagent.DropMonitorObj")
	proto.RegisterType((*FlowMonitorRuleSpec)(nil), "tsagent.FlowMonitorRuleSpec")
	proto.RegisterType((*FlowMonitorObj)(nil), "tsagent.FlowMonitorObj")
	proto.RegisterType((*MirrorSessionObj)(nil), "tsagent.MirrorSessionObj")
}
func (m *CopiedDropReasons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopiedDropReasons) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMalformedPkt {
		dAtA[i] = 0x8
		i++
		if m.DropMalformedPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputMapping {
		dAtA[i] = 0x10
		i++
		if m.DropInputMapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputMappingDejavu {
		dAtA[i] = 0x18
		i++
		if m.DropInputMappingDejavu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropFlowHit {
		dAtA[i] = 0x20
		i++
		if m.DropFlowHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropFlowMiss {
		dAtA[i] = 0x28
		i++
		if m.DropFlowMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropNacl {
		dAtA[i] = 0x30
		i++
		if m.DropNacl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIpsg {
		dAtA[i] = 0x38
		i++
		if m.DropIpsg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIpNormalization {
		dAtA[i] = 0x40
		i++
		if m.DropIpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNormalization {
		dAtA[i] = 0x48
		i++
		if m.DropTcpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpRstWithInvalidAckNum {
		dAtA[i] = 0x50
		i++
		if m.DropTcpRstWithInvalidAckNum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNonSynFirstPkt {
		dAtA[i] = 0x58
		i++
		if m.DropTcpNonSynFirstPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropIcmpNormalization {
		dAtA[i] = 0x60
		i++
		if m.DropIcmpNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropInputPropertiesMiss {
		dAtA[i] = 0x68
		i++
		if m.DropInputPropertiesMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpOutOfWindow {
		dAtA[i] = 0x70
		i++
		if m.DropTcpOutOfWindow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpSplitHandshake {
		dAtA[i] = 0x78
		i++
		if m.DropTcpSplitHandshake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpWinZeroDrop {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpWinZeroDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpDataAfterFin {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpDataAfterFin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpNonRstPktAfterRst {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpNonRstPktAfterRst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpInvalidResponderFirstPkt {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpInvalidResponderFirstPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropTcpUnexpectedPkt {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropTcpUnexpectedPkt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropSrcLifMismatch {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropSrcLifMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropParserIcrcError {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropParserIcrcError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropParseLenError {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.DropParseLenError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropHardwareError {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.DropHardwareError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DropRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.CopiedDropReasons.Size()))
	n1, err := m.CopiedDropReasons.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *DropMonitorObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.Spec.Size()))
	n4, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.RuleID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.RuleID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		dAtA6 := make([]byte, len(m.MirrorSessionIDs)*10)
		var j5 int
		for _, num := range m.MirrorSessionIDs {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *FlowMonitorRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceIP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(len(m.SourceIP)))
		i += copy(dAtA[i:], m.SourceIP)
	}
	if len(m.DestIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(len(m.DestIP)))
		i += copy(dAtA[i:], m.DestIP)
	}
	if m.SourceMac != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.SourceMac))
	}
	if m.DestMac != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.DestMac))
	}
	if m.EtherType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.EtherType))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.Protocol))
	}
	if m.SourceL4Port != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.SourceL4Port))
	}
	if m.DestL4Port != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.DestL4Port))
	}
	if m.SourceGroupID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.SourceGroupID))
	}
	if m.DestGroupID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.DestGroupID))
	}
	return i, nil
}

func (m *FlowMonitorObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.TypeMeta.Size()))
	n7, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.ObjectMeta.Size()))
	n8, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.Spec.Size()))
	n9, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.RuleID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.RuleID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		dAtA11 := make([]byte, len(m.MirrorSessionIDs)*10)
		var j10 int
		for _, num := range m.MirrorSessionIDs {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *MirrorSessionObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.TypeMeta.Size()))
	n12, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x12
	i++
	i = encodeVarintTsagent(dAtA, i, uint64(m.ObjectMeta.Size()))
	n13, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.MirrorID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.MirrorID))
	}
	if m.Created {
		dAtA[i] = 0x20
		i++
		if m.Created {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Handle != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(m.Handle))
	}
	if len(m.FlowMonitorRuleIDs) > 0 {
		dAtA15 := make([]byte, len(m.FlowMonitorRuleIDs)*10)
		var j14 int
		for _, num := range m.FlowMonitorRuleIDs {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.DropMonitorRuleIDs) > 0 {
		dAtA17 := make([]byte, len(m.DropMonitorRuleIDs)*10)
		var j16 int
		for _, num := range m.DropMonitorRuleIDs {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTsagent(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	return i, nil
}

func encodeVarintTsagent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CopiedDropReasons) Size() (n int) {
	var l int
	_ = l
	if m.DropMalformedPkt {
		n += 2
	}
	if m.DropInputMapping {
		n += 2
	}
	if m.DropInputMappingDejavu {
		n += 2
	}
	if m.DropFlowHit {
		n += 2
	}
	if m.DropFlowMiss {
		n += 2
	}
	if m.DropNacl {
		n += 2
	}
	if m.DropIpsg {
		n += 2
	}
	if m.DropIpNormalization {
		n += 2
	}
	if m.DropTcpNormalization {
		n += 2
	}
	if m.DropTcpRstWithInvalidAckNum {
		n += 2
	}
	if m.DropTcpNonSynFirstPkt {
		n += 2
	}
	if m.DropIcmpNormalization {
		n += 2
	}
	if m.DropInputPropertiesMiss {
		n += 2
	}
	if m.DropTcpOutOfWindow {
		n += 2
	}
	if m.DropTcpSplitHandshake {
		n += 2
	}
	if m.DropTcpWinZeroDrop {
		n += 3
	}
	if m.DropTcpDataAfterFin {
		n += 3
	}
	if m.DropTcpNonRstPktAfterRst {
		n += 3
	}
	if m.DropTcpInvalidResponderFirstPkt {
		n += 3
	}
	if m.DropTcpUnexpectedPkt {
		n += 3
	}
	if m.DropSrcLifMismatch {
		n += 3
	}
	if m.DropParserIcrcError {
		n += 3
	}
	if m.DropParseLenError {
		n += 3
	}
	if m.DropHardwareError {
		n += 3
	}
	return n
}

func (m *DropRuleSpec) Size() (n int) {
	var l int
	_ = l
	l = m.CopiedDropReasons.Size()
	n += 1 + l + sovTsagent(uint64(l))
	return n
}

func (m *DropMonitorObj) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTsagent(uint64(l))
	if m.RuleID != 0 {
		n += 1 + sovTsagent(uint64(m.RuleID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		l = 0
		for _, e := range m.MirrorSessionIDs {
			l += sovTsagent(uint64(e))
		}
		n += 1 + sovTsagent(uint64(l)) + l
	}
	return n
}

func (m *FlowMonitorRuleSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceIP)
	if l > 0 {
		n += 1 + l + sovTsagent(uint64(l))
	}
	l = len(m.DestIP)
	if l > 0 {
		n += 1 + l + sovTsagent(uint64(l))
	}
	if m.SourceMac != 0 {
		n += 1 + sovTsagent(uint64(m.SourceMac))
	}
	if m.DestMac != 0 {
		n += 1 + sovTsagent(uint64(m.DestMac))
	}
	if m.EtherType != 0 {
		n += 1 + sovTsagent(uint64(m.EtherType))
	}
	if m.Protocol != 0 {
		n += 1 + sovTsagent(uint64(m.Protocol))
	}
	if m.SourceL4Port != 0 {
		n += 1 + sovTsagent(uint64(m.SourceL4Port))
	}
	if m.DestL4Port != 0 {
		n += 1 + sovTsagent(uint64(m.DestL4Port))
	}
	if m.SourceGroupID != 0 {
		n += 1 + sovTsagent(uint64(m.SourceGroupID))
	}
	if m.DestGroupID != 0 {
		n += 1 + sovTsagent(uint64(m.DestGroupID))
	}
	return n
}

func (m *FlowMonitorObj) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTsagent(uint64(l))
	if m.RuleID != 0 {
		n += 1 + sovTsagent(uint64(m.RuleID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		l = 0
		for _, e := range m.MirrorSessionIDs {
			l += sovTsagent(uint64(e))
		}
		n += 1 + sovTsagent(uint64(l)) + l
	}
	return n
}

func (m *MirrorSessionObj) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTsagent(uint64(l))
	if m.MirrorID != 0 {
		n += 1 + sovTsagent(uint64(m.MirrorID))
	}
	if m.Created {
		n += 2
	}
	if m.Handle != 0 {
		n += 1 + sovTsagent(uint64(m.Handle))
	}
	if len(m.FlowMonitorRuleIDs) > 0 {
		l = 0
		for _, e := range m.FlowMonitorRuleIDs {
			l += sovTsagent(uint64(e))
		}
		n += 1 + sovTsagent(uint64(l)) + l
	}
	if len(m.DropMonitorRuleIDs) > 0 {
		l = 0
		for _, e := range m.DropMonitorRuleIDs {
			l += sovTsagent(uint64(e))
		}
		n += 1 + sovTsagent(uint64(l)) + l
	}
	return n
}

func sovTsagent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTsagent(x uint64) (n int) {
	return sovTsagent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CopiedDropReasons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopiedDropReasons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopiedDropReasons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMalformedPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMalformedPkt = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputMapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputMapping = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputMappingDejavu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputMappingDejavu = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFlowHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropFlowHit = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFlowMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropFlowMiss = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropNacl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropNacl = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIpsg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIpsg = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIpNormalization = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNormalization = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpRstWithInvalidAckNum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpRstWithInvalidAckNum = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNonSynFirstPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNonSynFirstPkt = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIcmpNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropIcmpNormalization = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropInputPropertiesMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropInputPropertiesMiss = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpOutOfWindow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpOutOfWindow = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpSplitHandshake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpSplitHandshake = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpWinZeroDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpWinZeroDrop = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpDataAfterFin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpDataAfterFin = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpNonRstPktAfterRst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpNonRstPktAfterRst = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpInvalidResponderFirstPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpInvalidResponderFirstPkt = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTcpUnexpectedPkt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropTcpUnexpectedPkt = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropSrcLifMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropSrcLifMismatch = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropParserIcrcError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropParserIcrcError = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropParseLenError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropParseLenError = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropHardwareError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropHardwareError = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopiedDropReasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CopiedDropReasons.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleID", wireType)
			}
			m.RuleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTsagent
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTsagent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceMac", wireType)
			}
			m.SourceMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestMac", wireType)
			}
			m.DestMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			m.EtherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtherType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceL4Port", wireType)
			}
			m.SourceL4Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceL4Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestL4Port", wireType)
			}
			m.DestL4Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestL4Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGroupID", wireType)
			}
			m.SourceGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGroupID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestGroupID", wireType)
			}
			m.DestGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestGroupID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleID", wireType)
			}
			m.RuleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTsagent
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTsagent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTsagent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorID", wireType)
			}
			m.MirrorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Created = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Handle |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FlowMonitorRuleIDs = append(m.FlowMonitorRuleIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTsagent
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTsagent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FlowMonitorRuleIDs = append(m.FlowMonitorRuleIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMonitorRuleIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DropMonitorRuleIDs = append(m.DropMonitorRuleIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTsagent
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTsagent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DropMonitorRuleIDs = append(m.DropMonitorRuleIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMonitorRuleIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTsagent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTsagent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTsagent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTsagent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTsagent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTsagent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTsagent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTsagent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTsagent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTsagent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tsagent.proto", fileDescriptorTsagent) }

var fileDescriptorTsagent = []byte{
	// 1364 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6e, 0x1b, 0xb7,
	0x16, 0x8e, 0x12, 0xc5, 0x96, 0x29, 0xcb, 0xb1, 0x69, 0x3b, 0x9e, 0x38, 0xb9, 0x9e, 0x5c, 0x23,
	0x17, 0xc8, 0x05, 0x6c, 0x2b, 0xb5, 0x9d, 0xa4, 0x49, 0x80, 0xa2, 0x51, 0x64, 0x27, 0x02, 0xac,
	0x58, 0x95, 0x5d, 0x04, 0xc8, 0x66, 0x40, 0x73, 0x28, 0x89, 0xf1, 0x0c, 0x49, 0x90, 0x9c, 0xa8,
	0xce, 0xbe, 0xef, 0xd0, 0x7d, 0x5f, 0xa4, 0xbb, 0x66, 0x53, 0x20, 0xe8, 0x03, 0x08, 0x45, 0xba,
	0xd3, 0x13, 0x74, 0x59, 0x90, 0xf3, 0x2b, 0xdb, 0xdd, 0x06, 0xdd, 0x69, 0xce, 0xf7, 0x73, 0xc8,
	0x73, 0xc8, 0x43, 0x81, 0x9a, 0x56, 0xa8, 0x4f, 0x98, 0xde, 0x12, 0x92, 0x6b, 0x0e, 0xa7, 0x93,
	0xcf, 0xd5, 0x3b, 0x7d, 0xce, 0xfb, 0x01, 0xa9, 0x23, 0x41, 0xeb, 0x88, 0x31, 0xae, 0x91, 0xa6,
	0x9c, 0xa9, 0x98, 0xb6, 0xba, 0xd7, 0xa7, 0x7a, 0x10, 0x9d, 0x6c, 0x61, 0x1e, 0xd6, 0x05, 0x61,
	0x0a, 0x31, 0x9f, 0xd7, 0xd5, 0xb0, 0xfe, 0x9e, 0x30, 0x8a, 0x49, 0x3d, 0xd2, 0x34, 0x50, 0x46,
	0xda, 0x27, 0xac, 0xa8, 0xae, 0x53, 0x86, 0x83, 0xc8, 0x27, 0xa9, 0xcd, 0x66, 0xc1, 0xa6, 0xcf,
	0xfb, 0xbc, 0x6e, 0xc3, 0x27, 0x51, 0xcf, 0x7e, 0xd9, 0x0f, 0xfb, 0x2b, 0xa1, 0xff, 0xef, 0x1f,
	0xb2, 0x9a, 0x35, 0x86, 0x44, 0xa3, 0x98, 0xb6, 0xfe, 0xd7, 0x0c, 0x58, 0x78, 0xc1, 0x05, 0x25,
	0x7e, 0x53, 0x72, 0xd1, 0x25, 0x48, 0x71, 0xa6, 0xe0, 0x06, 0x80, 0xbe, 0xe4, 0xc2, 0x0b, 0x51,
	0xd0, 0xe3, 0x32, 0x24, 0xbe, 0x27, 0x4e, 0xb5, 0x53, 0xba, 0x5b, 0xba, 0x5f, 0xe9, 0xce, 0x1b,
	0xa4, 0x9d, 0x02, 0x9d, 0x53, 0x9d, 0xb1, 0x29, 0x13, 0x91, 0xf6, 0x42, 0x24, 0x04, 0x65, 0x7d,
	0xe7, 0x6a, 0xce, 0x6e, 0x19, 0xa0, 0x1d, 0xc7, 0xe1, 0x13, 0x70, 0xeb, 0x22, 0xdb, 0xf3, 0xc9,
	0x3b, 0xf4, 0x3e, 0x72, 0xae, 0x59, 0xd1, 0xcd, 0xf3, 0xa2, 0xa6, 0x45, 0xe1, 0x3a, 0xa8, 0x59,
	0x69, 0x2f, 0xe0, 0x43, 0x6f, 0x40, 0xb5, 0x53, 0xb6, 0xf4, 0xaa, 0x09, 0xee, 0x07, 0x7c, 0xf8,
	0x8a, 0x6a, 0x78, 0x0f, 0xcc, 0xe5, 0x9c, 0x90, 0x2a, 0xe5, 0x5c, 0xb7, 0xa4, 0xd9, 0x94, 0xd4,
	0xa6, 0x4a, 0xc1, 0xdb, 0x60, 0xc6, 0xb2, 0x18, 0xc2, 0x81, 0x33, 0x65, 0x09, 0x15, 0x13, 0x78,
	0x8d, 0x70, 0x90, 0x81, 0x54, 0xa8, 0xbe, 0x33, 0x9d, 0x83, 0x2d, 0xa1, 0xfa, 0x70, 0x1b, 0x2c,
	0x27, 0xa0, 0xc7, 0xb8, 0x0c, 0x51, 0x40, 0x3f, 0xd8, 0x7e, 0x39, 0x15, 0x4b, 0x5c, 0x8c, 0x89,
	0xaf, 0x8b, 0x10, 0xdc, 0x05, 0x76, 0x47, 0x9e, 0xc6, 0xe7, 0x45, 0x33, 0x56, 0xb4, 0x64, 0xd0,
	0x63, 0x7c, 0x4e, 0xb5, 0x0f, 0xfe, 0x9b, 0xa9, 0xa4, 0xd2, 0xde, 0x90, 0xea, 0x81, 0x47, 0xd9,
	0x7b, 0x14, 0x50, 0xdf, 0x43, 0xf8, 0xd4, 0x63, 0x51, 0xe8, 0x00, 0x6b, 0x70, 0x3b, 0x31, 0xe8,
	0x2a, 0xfd, 0x86, 0xea, 0x41, 0x2b, 0x26, 0x3d, 0xc7, 0xa7, 0xaf, 0xa3, 0x10, 0x3e, 0x01, 0xab,
	0x85, 0xec, 0xcc, 0x53, 0x67, 0xcc, 0xeb, 0x51, 0xe3, 0x68, 0x9a, 0x5a, 0xb5, 0x06, 0xcb, 0xd9,
	0x0a, 0xd8, 0xd1, 0x19, 0xdb, 0x37, 0xa8, 0xe9, 0xec, 0x23, 0xb0, 0x12, 0x6f, 0x16, 0x87, 0xe7,
	0x57, 0x3e, 0x9b, 0xeb, 0x5a, 0x38, 0x3c, 0xb7, 0xf4, 0x67, 0x49, 0xca, 0xb8, 0xc7, 0x42, 0x72,
	0x41, 0xa4, 0xa6, 0x44, 0xc5, 0x0d, 0xa9, 0x59, 0xe9, 0x4a, 0xd6, 0xe4, 0x4e, 0x86, 0xdb, 0xde,
	0x6c, 0x17, 0xaa, 0xc5, 0x23, 0xed, 0xf1, 0x9e, 0x37, 0xa4, 0xcc, 0xe7, 0x43, 0x67, 0xce, 0x0a,
	0x61, 0xb2, 0xd6, 0xc3, 0x48, 0x1f, 0xf6, 0xde, 0x58, 0x04, 0x3e, 0x06, 0x4e, 0xa6, 0x51, 0x22,
	0xa0, 0xda, 0x1b, 0x20, 0xe6, 0xab, 0x01, 0x3a, 0x25, 0xce, 0x8d, 0x89, 0x1d, 0x1e, 0x19, 0xf4,
	0x55, 0x0a, 0x4e, 0x24, 0x1b, 0x52, 0xe6, 0x7d, 0x20, 0x92, 0x7b, 0x26, 0xe2, 0xcc, 0x4f, 0x24,
	0x7b, 0x43, 0xd9, 0x5b, 0x22, 0xb9, 0xb9, 0x24, 0x70, 0x37, 0xa9, 0x8a, 0xd1, 0xf8, 0x48, 0x23,
	0x0f, 0xf5, 0x34, 0x91, 0x5e, 0x8f, 0x32, 0x67, 0x21, 0x3f, 0x04, 0xc7, 0x58, 0x34, 0x91, 0x46,
	0xcf, 0x0d, 0xb6, 0x4f, 0x19, 0xfc, 0x16, 0xac, 0x4d, 0xb4, 0x21, 0x69, 0x40, 0x22, 0x96, 0x4a,
	0x3b, 0xd0, 0x8a, 0x9d, 0xbc, 0x15, 0x5d, 0xdb, 0x05, 0xeb, 0xd0, 0x55, 0x1a, 0xb6, 0xc1, 0xbd,
	0xcc, 0x21, 0x3d, 0x07, 0x92, 0x28, 0xc1, 0x99, 0x6f, 0xd3, 0xa7, 0x2d, 0x5d, 0xb4, 0x3e, 0x6e,
	0xe2, 0x93, 0x1c, 0x86, 0x6e, 0x4a, 0xcc, 0x9a, 0xfb, 0xb0, 0xb0, 0x8d, 0x88, 0x91, 0x1f, 0x04,
	0xc1, 0x3a, 0xb9, 0xe9, 0x4b, 0x13, 0xc7, 0xf2, 0xfb, 0x0c, 0x34, 0xb2, 0xaf, 0x92, 0x0b, 0xa0,
	0x24, 0xf6, 0x02, 0xda, 0x33, 0x2d, 0x0d, 0x91, 0xc6, 0x03, 0x67, 0x39, 0x2f, 0xd8, 0x91, 0xc4,
	0x07, 0xb4, 0xd7, 0x4e, 0x10, 0xb8, 0x93, 0x14, 0x59, 0x20, 0xa9, 0x88, 0xf4, 0x28, 0x96, 0xd8,
	0x23, 0x52, 0x72, 0xe9, 0xdc, 0xcc, 0xeb, 0xd5, 0xb1, 0x60, 0x0b, 0x4b, 0xbc, 0x67, 0x20, 0x58,
	0x07, 0x4b, 0xb9, 0xc8, 0x0b, 0x08, 0x4b, 0x24, 0x2b, 0x56, 0xb2, 0x90, 0x49, 0x0e, 0x08, 0x8b,
	0x05, 0x5b, 0xc0, 0xfa, 0x78, 0x03, 0x24, 0xfd, 0x21, 0x92, 0x24, 0xe1, 0x3b, 0x39, 0xff, 0x55,
	0x82, 0x58, 0xfe, 0x3a, 0x02, 0xb3, 0x76, 0xe6, 0x45, 0x01, 0x39, 0x12, 0x04, 0xc3, 0xef, 0x40,
	0xb5, 0x30, 0x03, 0xed, 0xb4, 0xab, 0x6e, 0xaf, 0x6e, 0xa5, 0x33, 0xff, 0xc2, 0x94, 0x6c, 0x2c,
	0x7e, 0x1c, 0xb9, 0x57, 0x3e, 0x8d, 0xdc, 0xd2, 0x78, 0xe4, 0x4e, 0x6f, 0x50, 0x16, 0x50, 0x46,
	0xba, 0x45, 0x8f, 0xf5, 0x5f, 0xae, 0x82, 0x39, 0xf3, 0xdd, 0xe6, 0x8c, 0x6a, 0x2e, 0x0f, 0x4f,
	0xde, 0xc1, 0x07, 0xa0, 0x74, 0x9c, 0x78, 0xd7, 0xb6, 0x90, 0xa0, 0x5b, 0xc7, 0x67, 0x82, 0xb4,
	0x89, 0x46, 0x97, 0xdb, 0x95, 0x8e, 0xe1, 0x13, 0x50, 0x3a, 0xb4, 0xd3, 0xb4, 0xba, 0x7d, 0xc3,
	0x2a, 0x0e, 0x4f, 0xde, 0x11, 0xac, 0xad, 0x66, 0xb5, 0xa0, 0x99, 0x33, 0x63, 0x7d, 0x83, 0x87,
	0x54, 0x93, 0x50, 0xe8, 0xb3, 0x6e, 0xe9, 0x10, 0x7e, 0x03, 0xca, 0x66, 0x6b, 0x76, 0xac, 0x56,
	0xb7, 0x97, 0xb3, 0xbd, 0x14, 0xf7, 0x1d, 0xe7, 0x1d, 0x8f, 0xdc, 0xaa, 0x12, 0x04, 0xa7, 0x79,
	0xad, 0x0e, 0x6e, 0x82, 0x29, 0x43, 0x6b, 0x35, 0xed, 0xa4, 0x2d, 0x37, 0x96, 0xc7, 0x23, 0x77,
	0x41, 0x46, 0x01, 0xd9, 0xa4, 0x7e, 0x21, 0x53, 0x42, 0x82, 0x4d, 0x30, 0xdf, 0xa6, 0xa6, 0xb6,
	0x47, 0x44, 0x29, 0xca, 0x59, 0xab, 0x69, 0xa6, 0xef, 0xb5, 0xfb, 0xe5, 0x86, 0x33, 0x1e, 0xb9,
	0x4b, 0xa1, 0xc5, 0x36, 0xa9, 0xaf, 0x0a, 0xda, 0x0b, 0x8a, 0xa7, 0xb3, 0xbf, 0xff, 0x78, 0xab,
	0x02, 0xa7, 0x30, 0x67, 0x3d, 0xda, 0x5f, 0xff, 0xb9, 0x0c, 0x16, 0xed, 0xd8, 0x8e, 0x4b, 0x98,
	0x75, 0x6b, 0x13, 0x54, 0x8e, 0x78, 0x24, 0x31, 0x69, 0x75, 0x6c, 0x39, 0x67, 0x1a, 0x0b, 0xe3,
	0x91, 0x5b, 0x53, 0x54, 0x14, 0xcc, 0x33, 0x0a, 0xfc, 0x3f, 0x98, 0x6a, 0x12, 0xa5, 0x5b, 0x1d,
	0x5b, 0xc9, 0x84, 0xec, 0x4f, 0x90, 0x13, 0x02, 0x7c, 0x00, 0x66, 0x62, 0x59, 0x1b, 0xc5, 0x95,
	0x2b, 0x37, 0xa0, 0x29, 0xaf, 0x0a, 0x11, 0x2e, 0xd0, 0x73, 0x12, 0xdc, 0x00, 0xd3, 0x46, 0x6b,
	0xf8, 0xe5, 0x9c, 0xef, 0x4f, 0xf2, 0x53, 0x0a, 0x7c, 0x08, 0x66, 0xf6, 0xf4, 0x80, 0x48, 0xd3,
	0x78, 0xfb, 0x38, 0xd5, 0x1a, 0x2b, 0xe3, 0x91, 0xbb, 0x48, 0x4c, 0x50, 0x9f, 0x09, 0x52, 0x4c,
	0x92, 0x31, 0x61, 0x1d, 0x54, 0x3a, 0xe6, 0xc9, 0xc6, 0x3c, 0x7e, 0xb1, 0x6a, 0x8d, 0xc5, 0xf1,
	0xc8, 0xbd, 0x61, 0x9f, 0xf1, 0xe2, 0x96, 0x53, 0x12, 0x7c, 0x06, 0x66, 0xe3, 0x25, 0x1e, 0xec,
	0x76, 0xb8, 0xd4, 0xf6, 0x25, 0x4b, 0x52, 0x29, 0x89, 0x83, 0x5d, 0xc1, 0xa5, 0x2e, 0x08, 0x27,
	0xc8, 0xf0, 0x6b, 0x00, 0xcc, 0x7a, 0x13, 0x69, 0xc5, 0x4a, 0x6d, 0x13, 0x7d, 0xa2, 0xf4, 0x05,
	0x6d, 0x81, 0x0b, 0x9f, 0x82, 0x5a, 0xec, 0xf4, 0x52, 0xf2, 0x48, 0xb4, 0x9a, 0xf6, 0x8d, 0x2b,
	0x37, 0x96, 0xc6, 0x23, 0x77, 0x5e, 0x49, 0xfc, 0x52, 0x16, 0x6b, 0x3e, 0x49, 0x85, 0x8f, 0x41,
	0xd5, 0x38, 0xa5, 0x4a, 0x90, 0x1f, 0x3a, 0xdf, 0x86, 0x8b, 0xd2, 0x22, 0x73, 0xfd, 0xd7, 0xab,
	0x60, 0xae, 0x70, 0x4a, 0xbe, 0xf8, 0x45, 0xdb, 0x9b, 0xb8, 0x68, 0x77, 0xb2, 0x8b, 0x76, 0xc9,
	0xc9, 0xfd, 0x97, 0xdf, 0xb7, 0xdf, 0xae, 0x9d, 0x33, 0xfd, 0xe2, 0xb5, 0xdc, 0x01, 0x95, 0x78,
	0x01, 0xad, 0x66, 0x72, 0xfd, 0xec, 0x99, 0x4d, 0x63, 0x77, 0x8b, 0x87, 0x3d, 0x0d, 0xc2, 0x47,
	0x60, 0xfa, 0x85, 0x24, 0x48, 0x13, 0x3f, 0xfe, 0x53, 0xd8, 0xb8, 0x33, 0x1e, 0xb9, 0x4e, 0x0c,
	0x27, 0x40, 0x51, 0x98, 0x92, 0xe1, 0x0e, 0x98, 0x32, 0x7f, 0x06, 0x82, 0xf8, 0x26, 0x96, 0x1b,
	0xb7, 0xc7, 0x23, 0x77, 0x25, 0x96, 0xc5, 0xf1, 0xa2, 0x2a, 0xa1, 0xc2, 0x36, 0x80, 0xe7, 0x1a,
	0x6b, 0x2a, 0x3f, 0x65, 0x2b, 0xff, 0x9f, 0xf1, 0xc8, 0xbd, 0x65, 0xd0, 0x38, 0x7c, 0x40, 0x95,
	0x2e, 0x5a, 0x5c, 0x22, 0x34, 0x76, 0x85, 0x47, 0x22, 0xb5, 0x9b, 0xce, 0xed, 0xd2, 0x71, 0x7d,
	0x89, 0xdd, 0x45, 0xe1, 0x64, 0x3f, 0x1b, 0x2b, 0x1f, 0x3f, 0xaf, 0x95, 0x3e, 0x7d, 0x5e, 0x2b,
	0xfd, 0xf1, 0x79, 0xad, 0xf4, 0xd3, 0x9f, 0x6b, 0x57, 0xde, 0x5e, 0x57, 0x1a, 0x69, 0xd2, 0x29,
	0x9d, 0x4c, 0xd9, 0xd9, 0xb1, 0xf3, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x51, 0xa4, 0xe7,
	0xd7, 0x0c, 0x00, 0x00,
}
