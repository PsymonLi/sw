// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nmd.proto

/*
	Package nmd is a generated protocol buffer package.

	Service name

	It is generated from these files:
		nmd.proto

	It has these top-level messages:
		Naples
		NaplesSpec
		NaplesStatus
		NaplesCmdExecute
*/
package nmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import cluster2 "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Operational mode of a Naples
type MgmtMode int32

const (
	MgmtMode_HOST    MgmtMode = 0
	MgmtMode_NETWORK MgmtMode = 1
)

var MgmtMode_name = map[int32]string{
	0: "HOST",
	1: "NETWORK",
}
var MgmtMode_value = map[string]int32{
	"HOST":    0,
	"NETWORK": 1,
}

func (x MgmtMode) String() string {
	return proto.EnumName(MgmtMode_name, int32(x))
}
func (MgmtMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorNmd, []int{0} }

// Network Connectivity Mode (only if network managed)
type NetworkMode int32

const (
	NetworkMode_NONE   NetworkMode = 0
	NetworkMode_OOB    NetworkMode = 1
	NetworkMode_INBAND NetworkMode = 2
)

var NetworkMode_name = map[int32]string{
	0: "NONE",
	1: "OOB",
	2: "INBAND",
}
var NetworkMode_value = map[string]int32{
	"NONE":   0,
	"OOB":    1,
	"INBAND": 2,
}

func (x NetworkMode) String() string {
	return proto.EnumName(NetworkMode_name, int32(x))
}
func (NetworkMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorNmd, []int{1} }

type NaplesSpec_FeatureProfile int32

const (
	NaplesSpec_NONE                  NaplesSpec_FeatureProfile = 0
	NaplesSpec_CLASSIC_DEFAULT       NaplesSpec_FeatureProfile = 1
	NaplesSpec_CLASSIC_ETH_DEV_SCALE NaplesSpec_FeatureProfile = 2
)

var NaplesSpec_FeatureProfile_name = map[int32]string{
	0: "NONE",
	1: "CLASSIC_DEFAULT",
	2: "CLASSIC_ETH_DEV_SCALE",
}
var NaplesSpec_FeatureProfile_value = map[string]int32{
	"NONE":                  0,
	"CLASSIC_DEFAULT":       1,
	"CLASSIC_ETH_DEV_SCALE": 2,
}

func (x NaplesSpec_FeatureProfile) String() string {
	return proto.EnumName(NaplesSpec_FeatureProfile_name, int32(x))
}
func (NaplesSpec_FeatureProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorNmd, []int{1, 0}
}

type NaplesStatus_Transition int32

const (
	NaplesStatus_NONE                                NaplesStatus_Transition = 0
	NaplesStatus_DHCP_SENT                           NaplesStatus_Transition = 1
	NaplesStatus_DHCP_DONE                           NaplesStatus_Transition = 2
	NaplesStatus_DHCP_TIMEDOUT                       NaplesStatus_Transition = 3
	NaplesStatus_MISSING_VENDOR_SPECIFIED_ATTRIBUTES NaplesStatus_Transition = 4
	NaplesStatus_VENICE_REGISTRATION_SENT            NaplesStatus_Transition = 5
	NaplesStatus_VENICE_REGISTRATION_DONE            NaplesStatus_Transition = 6
	NaplesStatus_VENICE_UNREACHABLE                  NaplesStatus_Transition = 7
	NaplesStatus_REBOOT_PENDING                      NaplesStatus_Transition = 8
)

var NaplesStatus_Transition_name = map[int32]string{
	0: "NONE",
	1: "DHCP_SENT",
	2: "DHCP_DONE",
	3: "DHCP_TIMEDOUT",
	4: "MISSING_VENDOR_SPECIFIED_ATTRIBUTES",
	5: "VENICE_REGISTRATION_SENT",
	6: "VENICE_REGISTRATION_DONE",
	7: "VENICE_UNREACHABLE",
	8: "REBOOT_PENDING",
}
var NaplesStatus_Transition_value = map[string]int32{
	"NONE":                                0,
	"DHCP_SENT":                           1,
	"DHCP_DONE":                           2,
	"DHCP_TIMEDOUT":                       3,
	"MISSING_VENDOR_SPECIFIED_ATTRIBUTES": 4,
	"VENICE_REGISTRATION_SENT":            5,
	"VENICE_REGISTRATION_DONE":            6,
	"VENICE_UNREACHABLE":                  7,
	"REBOOT_PENDING":                      8,
}

func (x NaplesStatus_Transition) String() string {
	return proto.EnumName(NaplesStatus_Transition_name, int32(x))
}
func (NaplesStatus_Transition) EnumDescriptor() ([]byte, []int) { return fileDescriptorNmd, []int{2, 0} }

// Naples config object
type Naples struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the NIC.
	Spec NaplesSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the NIC.
	Status NaplesStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Naples) Reset()                    { *m = Naples{} }
func (m *Naples) String() string            { return proto.CompactTextString(m) }
func (*Naples) ProtoMessage()               {}
func (*Naples) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{0} }

func (m *Naples) GetSpec() NaplesSpec {
	if m != nil {
		return m.Spec
	}
	return NaplesSpec{}
}

func (m *Naples) GetStatus() NaplesStatus {
	if m != nil {
		return m.Status
	}
	return NaplesStatus{}
}

// NaplesSpec contains initial bootstrap configuration of the Naples I/O subsystem
type NaplesSpec struct {
	// PrimaryMAC is the MAC address of the primary PF exposed by SmartNIC
	PrimaryMAC string `protobuf:"bytes,1,opt,name=PrimaryMAC,proto3" json:"primary-mac,omitempty"`
	// Hostname is used as a user friendly identifier in logs/events
	Hostname string `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname,omitempty"`
	// IPConfig defines the static IP configuration. If not specified, DHCP will be attempted
	IPConfig *cluster2.IPConfig `protobuf:"bytes,3,opt,name=IPConfig" json:"ip-config,omitempty"`
	// Operational mode of the NIC
	Mode MgmtMode `protobuf:"varint,4,opt,name=Mode,proto3,enum=nmd.MgmtMode" json:"mode"`
	// Operational mode of the NIC
	NetworkMode NetworkMode `protobuf:"varint,5,opt,name=NetworkMode,proto3,enum=nmd.NetworkMode" json:"network-mode"`
	// MgmtVlan defines the vlan to be used in network managed mode. The default of 0
	// implies OOB 1G mgmt port is used for management. A non 0 vlan switches the
	// management port to a vlan on data ports.
	MgmtVlan uint32 `protobuf:"varint,6,opt,name=MgmtVlan,proto3" json:"vlan,omitempty"`
	// Controllers contains the list of controller IPs or Hostnames
	Controllers []string                  `protobuf:"bytes,7,rep,name=Controllers" json:"controllers,omitempty"`
	Profile     NaplesSpec_FeatureProfile `protobuf:"varint,8,opt,name=Profile,proto3,enum=nmd.NaplesSpec_FeatureProfile" json:"feature-profile,omitempty"`
}

func (m *NaplesSpec) Reset()                    { *m = NaplesSpec{} }
func (m *NaplesSpec) String() string            { return proto.CompactTextString(m) }
func (*NaplesSpec) ProtoMessage()               {}
func (*NaplesSpec) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{1} }

func (m *NaplesSpec) GetPrimaryMAC() string {
	if m != nil {
		return m.PrimaryMAC
	}
	return ""
}

func (m *NaplesSpec) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *NaplesSpec) GetIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *NaplesSpec) GetMode() MgmtMode {
	if m != nil {
		return m.Mode
	}
	return MgmtMode_HOST
}

func (m *NaplesSpec) GetNetworkMode() NetworkMode {
	if m != nil {
		return m.NetworkMode
	}
	return NetworkMode_NONE
}

func (m *NaplesSpec) GetMgmtVlan() uint32 {
	if m != nil {
		return m.MgmtVlan
	}
	return 0
}

func (m *NaplesSpec) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *NaplesSpec) GetProfile() NaplesSpec_FeatureProfile {
	if m != nil {
		return m.Profile
	}
	return NaplesSpec_NONE
}

// NaplesStatus contains current status of a Naples I/O subsystem
type NaplesStatus struct {
	// Current phase of the NIC adapter in the system
	Phase    cluster2.SmartNICStatus_Phase `protobuf:"varint,1,opt,name=Phase,proto3,enum=cluster.SmartNICStatus_Phase" json:"phase,omitempty"`
	IPConfig *cluster2.IPConfig            `protobuf:"bytes,2,opt,name=IPConfig" json:"ip-config"`
	// Resolved Controllers/Venice IPs
	Controllers     []string `protobuf:"bytes,3,rep,name=Controllers" json:"controllers,omitempty"`
	TransitionPhase string   `protobuf:"bytes,4,opt,name=TransitionPhase,proto3" json:"transition-phase,omitempty"`
	// Operational mode of the NIC
	Mode string `protobuf:"bytes,5,opt,name=Mode,proto3" json:"mode"`
	// Operational mode of the NIC
	NetworkMode string `protobuf:"bytes,6,opt,name=NetworkMode,proto3" json:"network-mode"`
}

func (m *NaplesStatus) Reset()                    { *m = NaplesStatus{} }
func (m *NaplesStatus) String() string            { return proto.CompactTextString(m) }
func (*NaplesStatus) ProtoMessage()               {}
func (*NaplesStatus) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{2} }

func (m *NaplesStatus) GetPhase() cluster2.SmartNICStatus_Phase {
	if m != nil {
		return m.Phase
	}
	return cluster2.SmartNICStatus_UNKNOWN
}

func (m *NaplesStatus) GetIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *NaplesStatus) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *NaplesStatus) GetTransitionPhase() string {
	if m != nil {
		return m.TransitionPhase
	}
	return ""
}

func (m *NaplesStatus) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *NaplesStatus) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

// NaplesCmdExecute contains information on what command to execute
type NaplesCmdExecute struct {
	// Executable to run on naples side
	Executable string `protobuf:"bytes,1,opt,name=Executable,proto3" json:"executable,omitempty"`
	// Flags for the executable to run on naples side
	Opts string `protobuf:"bytes,2,opt,name=Opts,proto3" json:"opts,omitempty"`
}

func (m *NaplesCmdExecute) Reset()                    { *m = NaplesCmdExecute{} }
func (m *NaplesCmdExecute) String() string            { return proto.CompactTextString(m) }
func (*NaplesCmdExecute) ProtoMessage()               {}
func (*NaplesCmdExecute) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{3} }

func (m *NaplesCmdExecute) GetExecutable() string {
	if m != nil {
		return m.Executable
	}
	return ""
}

func (m *NaplesCmdExecute) GetOpts() string {
	if m != nil {
		return m.Opts
	}
	return ""
}

func init() {
	proto.RegisterType((*Naples)(nil), "nmd.Naples")
	proto.RegisterType((*NaplesSpec)(nil), "nmd.NaplesSpec")
	proto.RegisterType((*NaplesStatus)(nil), "nmd.NaplesStatus")
	proto.RegisterType((*NaplesCmdExecute)(nil), "nmd.NaplesCmdExecute")
	proto.RegisterEnum("nmd.MgmtMode", MgmtMode_name, MgmtMode_value)
	proto.RegisterEnum("nmd.NetworkMode", NetworkMode_name, NetworkMode_value)
	proto.RegisterEnum("nmd.NaplesSpec_FeatureProfile", NaplesSpec_FeatureProfile_name, NaplesSpec_FeatureProfile_value)
	proto.RegisterEnum("nmd.NaplesStatus_Transition", NaplesStatus_Transition_name, NaplesStatus_Transition_value)
}
func (m *Naples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Naples) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *NaplesSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrimaryMAC) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.PrimaryMAC)))
		i += copy(dAtA[i:], m.PrimaryMAC)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.IPConfig.Size()))
		n5, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Mode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.Mode))
	}
	if m.NetworkMode != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.NetworkMode))
	}
	if m.MgmtVlan != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Profile != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.Profile))
	}
	return i, nil
}

func (m *NaplesStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.Phase))
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.IPConfig.Size()))
		n6, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TransitionPhase) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.TransitionPhase)))
		i += copy(dAtA[i:], m.TransitionPhase)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	return i, nil
}

func (m *NaplesCmdExecute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesCmdExecute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Executable) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Executable)))
		i += copy(dAtA[i:], m.Executable)
	}
	if len(m.Opts) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Opts)))
		i += copy(dAtA[i:], m.Opts)
	}
	return i, nil
}

func encodeVarintNmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Naples) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovNmd(uint64(l))
	return n
}

func (m *NaplesSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrimaryMAC)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovNmd(uint64(m.Mode))
	}
	if m.NetworkMode != 0 {
		n += 1 + sovNmd(uint64(m.NetworkMode))
	}
	if m.MgmtVlan != 0 {
		n += 1 + sovNmd(uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovNmd(uint64(l))
		}
	}
	if m.Profile != 0 {
		n += 1 + sovNmd(uint64(m.Profile))
	}
	return n
}

func (m *NaplesStatus) Size() (n int) {
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovNmd(uint64(m.Phase))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovNmd(uint64(l))
		}
	}
	l = len(m.TransitionPhase)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func (m *NaplesCmdExecute) Size() (n int) {
	var l int
	_ = l
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Opts)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func sovNmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNmd(x uint64) (n int) {
	return sovNmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Naples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Naples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Naples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &cluster2.IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (MgmtMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			m.NetworkMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMode |= (NetworkMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtVlan", wireType)
			}
			m.MgmtVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= (NaplesSpec_FeatureProfile(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (cluster2.SmartNICStatus_Phase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &cluster2.IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitionPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesCmdExecute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesCmdExecute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesCmdExecute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nmd.proto", fileDescriptorNmd) }

var fileDescriptorNmd = []byte{
	// 1044 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4d, 0x53, 0xdb, 0x46,
	0x18, 0x8e, 0xfc, 0xcd, 0x82, 0x8d, 0x58, 0x1a, 0x6a, 0x53, 0x82, 0xa9, 0xdb, 0x4c, 0x29, 0x83,
	0xed, 0x0c, 0xbd, 0x34, 0x4d, 0x2e, 0x96, 0xbc, 0x80, 0x5a, 0x2c, 0xb9, 0x96, 0x20, 0x47, 0x8f,
	0x90, 0x17, 0xa3, 0x56, 0x5a, 0xa9, 0xd2, 0x3a, 0x29, 0x33, 0xbd, 0x75, 0xc2, 0x8f, 0xe1, 0x97,
	0x70, 0xcc, 0xe4, 0xd4, 0x93, 0xa7, 0xc3, 0xd1, 0xbf, 0xa2, 0xa3, 0x95, 0x64, 0x2f, 0xcc, 0x90,
	0x99, 0x4c, 0x6f, 0xda, 0xf7, 0x7d, 0x9e, 0xe7, 0xfd, 0xdc, 0x15, 0x58, 0x22, 0xee, 0xa8, 0xe5,
	0x07, 0x1e, 0xf5, 0x60, 0x96, 0xb8, 0xa3, 0xcd, 0xad, 0xb1, 0xe7, 0x8d, 0x1d, 0xdc, 0x36, 0x7d,
	0xbb, 0x6d, 0x12, 0xe2, 0x51, 0x93, 0xda, 0x1e, 0x09, 0x63, 0xc8, 0x26, 0x1a, 0xdb, 0xf4, 0x72,
	0x72, 0xde, 0xb2, 0x3c, 0xb7, 0xed, 0x63, 0x12, 0x9a, 0x64, 0xe4, 0xb5, 0xc3, 0x77, 0xed, 0xb7,
	0x98, 0xd8, 0x16, 0x6e, 0x4f, 0xa8, 0xed, 0x84, 0x11, 0x75, 0x8c, 0x09, 0xcf, 0x6e, 0xdb, 0xc4,
	0x72, 0x26, 0x23, 0x9c, 0xca, 0x34, 0x39, 0x99, 0xb1, 0x37, 0xf6, 0xda, 0xcc, 0x7c, 0x3e, 0xb9,
	0x60, 0x27, 0x76, 0x60, 0x5f, 0x09, 0xfc, 0xf9, 0x23, 0x51, 0xa3, 0x1c, 0x5d, 0x4c, 0xcd, 0x04,
	0xf6, 0xe2, 0x13, 0x30, 0x86, 0x08, 0xdb, 0xa1, 0x6b, 0x06, 0x94, 0xd8, 0x56, 0xcc, 0x68, 0xbc,
	0xcf, 0x80, 0x82, 0x6a, 0xfa, 0x0e, 0x0e, 0xe1, 0x0b, 0x20, 0x18, 0x55, 0x61, 0x47, 0xd8, 0x5d,
	0x3e, 0x28, 0xb7, 0x4c, 0xdf, 0x6e, 0x19, 0x57, 0x3e, 0xee, 0x61, 0x6a, 0x4a, 0xeb, 0xb7, 0xd3,
	0xfa, 0x93, 0x0f, 0xd3, 0xba, 0x30, 0x9b, 0xd6, 0x8b, 0xfb, 0x36, 0x71, 0x6c, 0x82, 0x07, 0x82,
	0x01, 0x5f, 0x02, 0x41, 0xab, 0x66, 0x18, 0x63, 0x95, 0x31, 0xb4, 0xf3, 0xdf, 0xb0, 0x45, 0x19,
	0x67, 0x93, 0xe3, 0x54, 0xa2, 0x14, 0xf7, 0x3d, 0xd7, 0xa6, 0xd8, 0xf5, 0xe9, 0xd5, 0x40, 0xd0,
	0xe0, 0x2b, 0x90, 0xd3, 0x7d, 0x6c, 0x55, 0xb3, 0x09, 0x3b, 0x9a, 0x41, 0x9c, 0x47, 0x64, 0x96,
	0x36, 0x22, 0x76, 0xc4, 0x0c, 0x7d, 0x6c, 0x71, 0x4c, 0x46, 0x82, 0x32, 0x28, 0xe8, 0xd4, 0xa4,
	0x93, 0xb0, 0x9a, 0x63, 0xf4, 0x35, 0x9e, 0xce, 0x1c, 0x52, 0x35, 0x11, 0x10, 0x43, 0x76, 0xe6,
	0x24, 0x12, 0xea, 0x4f, 0x2b, 0x1f, 0xdf, 0xd7, 0x4a, 0xb0, 0x60, 0x79, 0xe4, 0xc2, 0x1e, 0x37,
	0xfe, 0xce, 0x03, 0xb0, 0x88, 0x0f, 0x5f, 0x02, 0xd0, 0x0f, 0x6c, 0xd7, 0x0c, 0xae, 0x7a, 0x1d,
	0x99, 0x35, 0x65, 0x49, 0xaa, 0xcd, 0xa6, 0xf5, 0xa7, 0x7e, 0x6c, 0x6d, 0xba, 0x26, 0x9f, 0x16,
	0x07, 0x86, 0x07, 0xa0, 0x74, 0xec, 0x85, 0x94, 0x98, 0x2e, 0x66, 0xbd, 0x59, 0x92, 0x36, 0x66,
	0xd3, 0x3a, 0xbc, 0x4c, 0x6c, 0x1c, 0x6b, 0x8e, 0x83, 0x87, 0xa0, 0xa4, 0xf4, 0x65, 0x96, 0x49,
	0xd2, 0x91, 0xb5, 0x96, 0xe5, 0x4c, 0x42, 0x8a, 0x83, 0x56, 0xea, 0x90, 0xbe, 0x9c, 0x4d, 0xeb,
	0xeb, 0xb6, 0xdf, 0x8c, 0x33, 0xe6, 0x75, 0x52, 0x08, 0x3c, 0x02, 0xb9, 0x9e, 0x37, 0xc2, 0xac,
	0x2d, 0x95, 0x83, 0x32, 0x6b, 0x4b, 0x6f, 0xec, 0xd2, 0xc8, 0x28, 0x7d, 0x7b, 0x73, 0x5d, 0xab,
	0xea, 0x34, 0x40, 0x64, 0xe2, 0xee, 0xc6, 0xb5, 0xce, 0x9d, 0xdf, 0xcf, 0xa6, 0xf5, 0x9c, 0xeb,
	0x8d, 0xf0, 0x80, 0x09, 0x40, 0x0b, 0x2c, 0xab, 0x98, 0xbe, 0xf3, 0x82, 0xdf, 0x99, 0x5e, 0x9e,
	0xe9, 0x89, 0x71, 0x9b, 0x17, 0x76, 0xa9, 0x7d, 0x73, 0x5d, 0xfb, 0xea, 0x81, 0x24, 0xe7, 0x8f,
	0x54, 0x57, 0x48, 0x7c, 0x6e, 0x32, 0x75, 0x5e, 0x15, 0xb6, 0x40, 0x29, 0x8a, 0x7f, 0xe6, 0x98,
	0xa4, 0x5a, 0xd8, 0x11, 0x76, 0xcb, 0x12, 0x8c, 0x46, 0xfe, 0xd6, 0x31, 0x09, 0x5f, 0x5d, 0x8a,
	0x81, 0xaf, 0xc0, 0xb2, 0xec, 0x11, 0x1a, 0x78, 0x8e, 0x83, 0x83, 0xb0, 0x5a, 0xdc, 0xc9, 0xa6,
	0x53, 0xb1, 0x16, 0x66, 0x8e, 0xc9, 0xa3, 0xe1, 0x1b, 0x50, 0xec, 0x07, 0xde, 0x85, 0xed, 0xe0,
	0x6a, 0x89, 0x55, 0xb3, 0xfd, 0x60, 0xe7, 0x5a, 0x87, 0xd8, 0xa4, 0x93, 0x00, 0x27, 0x28, 0xe9,
	0xd9, 0x6c, 0x5a, 0xaf, 0x5d, 0xc4, 0xb6, 0xa6, 0x1f, 0x1b, 0x39, 0xf1, 0x54, 0xad, 0xf1, 0x33,
	0xa8, 0xdc, 0x67, 0xc2, 0x12, 0xc8, 0xa9, 0x9a, 0x8a, 0xc4, 0x27, 0x70, 0x1d, 0xac, 0xca, 0x27,
	0x1d, 0x5d, 0x57, 0xe4, 0x61, 0x17, 0x1d, 0x76, 0x4e, 0x4f, 0x0c, 0x51, 0x80, 0x35, 0xf0, 0x34,
	0x35, 0x22, 0xe3, 0x78, 0xd8, 0x45, 0x67, 0x43, 0x5d, 0xee, 0x9c, 0x20, 0x31, 0xd3, 0xf8, 0x98,
	0x07, 0x2b, 0xfc, 0x1a, 0xc3, 0x3f, 0x40, 0xbe, 0x7f, 0x69, 0x86, 0x98, 0xad, 0x60, 0xe5, 0xe0,
	0xd9, 0x7c, 0x2b, 0xf4, 0xe8, 0x1a, 0xab, 0x8a, 0x1c, 0xe3, 0x5a, 0x0c, 0x24, 0xbd, 0xbe, 0xb9,
	0xae, 0x3d, 0x4f, 0xc7, 0xf1, 0x29, 0x64, 0x34, 0x98, 0x55, 0x3f, 0xfa, 0xe2, 0x2a, 0x8a, 0x23,
	0xc1, 0xd7, 0xdc, 0x2e, 0x66, 0x1e, 0xdb, 0xc5, 0xf2, 0x6c, 0x5a, 0x5f, 0x9a, 0xef, 0x22, 0xb7,
	0x81, 0x0f, 0x66, 0x94, 0xfd, 0xac, 0x19, 0x39, 0x60, 0xd5, 0x08, 0x4c, 0x12, 0xda, 0xd1, 0x93,
	0x19, 0xd7, 0x9d, 0x63, 0x37, 0x48, 0xba, 0xb9, 0xae, 0xed, 0xdc, 0xdf, 0xb3, 0xa4, 0x9c, 0x05,
	0x3e, 0xaa, 0x69, 0x93, 0xce, 0x8f, 0xcd, 0x87, 0xe5, 0x3d, 0x94, 0x86, 0x3f, 0x26, 0x97, 0x25,
	0xcf, 0x42, 0x7c, 0xce, 0xed, 0xf8, 0xf5, 0xfe, 0xed, 0x28, 0x30, 0x81, 0xff, 0x75, 0x17, 0x1a,
	0xff, 0x08, 0x00, 0x2c, 0x12, 0xe4, 0x56, 0xa8, 0x0c, 0x96, 0xba, 0xc7, 0x72, 0x7f, 0xa8, 0x23,
	0x35, 0x5a, 0x9e, 0xf4, 0xd8, 0x8d, 0xbc, 0x19, 0xb8, 0x06, 0xca, 0xec, 0x68, 0x28, 0x3d, 0xd4,
	0xd5, 0x4e, 0x0d, 0x31, 0x0b, 0xbf, 0x03, 0xdf, 0xf4, 0x14, 0x5d, 0x57, 0xd4, 0xa3, 0xe1, 0x19,
	0x52, 0xbb, 0xda, 0x60, 0xa8, 0xf7, 0x91, 0xac, 0x1c, 0x2a, 0xa8, 0x3b, 0xec, 0x18, 0xc6, 0x40,
	0x91, 0x4e, 0x0d, 0xa4, 0x8b, 0x39, 0xb8, 0x05, 0xaa, 0x67, 0x48, 0x55, 0x64, 0x34, 0x1c, 0xa0,
	0x23, 0x45, 0x37, 0x06, 0x1d, 0x43, 0xd1, 0xd4, 0x38, 0x50, 0xfe, 0x31, 0x2f, 0x8b, 0x5b, 0x80,
	0x1b, 0x00, 0x26, 0xde, 0x53, 0x75, 0x80, 0x3a, 0xf2, 0x71, 0x47, 0x3a, 0x41, 0x62, 0x11, 0x42,
	0x50, 0x19, 0x20, 0x49, 0xd3, 0x8c, 0x61, 0x1f, 0xa9, 0x5d, 0x45, 0x3d, 0x12, 0x4b, 0x8d, 0xbf,
	0x80, 0x18, 0xb7, 0x43, 0x76, 0x47, 0xe8, 0x4f, 0x6c, 0x4d, 0x68, 0xb4, 0x64, 0x20, 0xfe, 0x34,
	0xcf, 0x1d, 0x9c, 0xbc, 0xaf, 0x5b, 0xb7, 0xf1, 0xdf, 0xe2, 0x0b, 0x3c, 0xf7, 0xf0, 0x4f, 0xec,
	0x02, 0x0f, 0xf7, 0x40, 0x4e, 0xf3, 0x69, 0x98, 0x3e, 0xaf, 0x09, 0xaf, 0xe2, 0xf9, 0x94, 0x5f,
	0x2d, 0x86, 0xd9, 0xfb, 0x3a, 0x7e, 0x64, 0xd8, 0xdc, 0x4a, 0x20, 0x77, 0xac, 0xe9, 0x86, 0xf8,
	0x04, 0x2e, 0x83, 0xa2, 0x8a, 0x8c, 0x37, 0xda, 0xe0, 0x17, 0x51, 0xd8, 0xdb, 0xbf, 0x37, 0x4e,
	0xae, 0xf7, 0x45, 0x90, 0xd5, 0x34, 0x49, 0x14, 0x20, 0x00, 0x05, 0x45, 0x95, 0x3a, 0x6a, 0x57,
	0xcc, 0x48, 0x2b, 0xb7, 0x77, 0xdb, 0xc2, 0x87, 0xbb, 0x6d, 0xe1, 0xdf, 0xbb, 0x6d, 0xa1, 0x2f,
	0x9c, 0x17, 0xd8, 0x8f, 0xf4, 0x87, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x85, 0x5f, 0x9a,
	0x47, 0x08, 0x00, 0x00,
}
