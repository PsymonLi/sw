#include "nic/utils/agent_api/agent_api.hpp"
#include "nic/utils/agent_api/shared_constants.h"
#define IPv4_LEN 4
#define IPv6_LEN 16
#define L4PORT_LEN 2
#define LOG_SIZE(ev) ev.ByteSizeLong()
#define TYPE_TO_LG_SZ(type, sz_) {                                    \
    if (type == IPC_LOG_TYPE_FW) {                                    \
       fwlog::FWEvent ev; sz_ = (LOG_SIZE(ev) + IPC_HDR_SIZE);        \
    } else {                                                          \
       sz_ = IPC_BUF_SIZE;                                            \
    }                                                                 \
}

void ipc_logger::set_ipc_buf_sz (void)
{
    // Get max buffer size
    for (int type = 0; type < IPC_LOG_TYPE_MAX; type++) {
        int sz_;
        TYPE_TO_LG_SZ(type, sz_);
        IPC_BUF_SIZE = (sz_ > IPC_BUF_SIZE)?sz_:IPC_BUF_SIZE;
    }
}

void ipc_logger::set_ipc_instances (int numInst) 
{
    IPC_INSTANCES = numInst;
}

// init sets up shared memory for use by the ipc logger
int ipc_logger::init (void)
{
    // TBD: IPC message size needs to be dynamically
    // computed once we have a autogenerated API 
    // that does a sizeof() operation for uninitialized 
    // proto class
    // set_ipc_buf_sz();
    return ipc::setup_shm(IPC_MEM_SIZE, IPC_INSTANCES);
}

// deinit frees up the shared memory
void ipc_logger::deinit (void)
{
    ipc::tear_down_shm();
}

// factory creates a new instance of ipc_logger
ipc_logger *ipc_logger::factory (void)
{
    ipc *ipc_inst;

    ipc_inst = ipc::factory();
    if (ipc_inst == NULL) {
        return NULL;
    }

    ipc_logger *il = new(ipc_logger);
    il->pipe_ = ipc_inst;

    return il;
}

// fw_log reports a firewall event to the agent
void ipc_logger::fw_log (fwlog::FWEvent ev)
{
    uint8_t *buf = pipe_->get_buffer(LOG_SIZE(ev));
    if (buf == NULL) {
        return;
    }

    if (!ev.SerializeToArray(buf, LOG_SIZE(ev))) {
        return;
    }

    int size = ev.ByteSizeLong();
    pipe_->put_buffer(buf, size);
}
