//-----------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//-----------------------------------------------------------------------------
#define FTL_MAX_API_CONTEXTS 8

namespace sdk {
namespace table {
namespace FTL_MAKE_AFTYPE(internal) {

#define HINT_SLOT_IS_INVALID(_slot) \
        ((_slot) == FTL_MAKE_AFTYPE(apictx)::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_IS_VALID(_slot) \
        ((_slot) != FTL_MAKE_AFTYPE(apictx)::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_SET_INVALID(_slot) \
        ((_slot) = FTL_MAKE_AFTYPE(apictx)::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_IS_MORE(_slot) \
        ((_slot) == FTL_MAKE_AFTYPE(apictx)::hint_slot::HINT_SLOT_MORE)
#define HINT_SLOT_SET_MORE(_slot) \
        ((_slot) = FTL_MAKE_AFTYPE(apictx)::hint_slot::HINT_SLOT_MORE)
#define HINT_SLOT_IS_MATCH(_ctx) \
        (HINT_SLOT_IS_FREE((_ctx)->hint_slot) &&\
         HINT_SLOT_IS_MORE((_ctx)->hint_slot))
#define HINT_IS_VALID(_hint) \
        ((_hint) != FTL_MAKE_AFTYPE(apictx)::hint_index::HINT_INDEX_INVALID)
#define HINT_SET_INVALID(_hint) \
        ((_hint) = FTL_MAKE_AFTYPE(apictx)::hint_index::HINT_INDEX_INVALID)

#define PRINT_API_CTX(_name, _ctx) {\
    FTL_TRACE_VERBOSE("%s: %s, [%s]", _name, (_ctx)->idstr(), (_ctx)->metastr()); \
}

class FTL_MAKE_AFTYPE(apictx) {
public:
    enum hint_index {
        // Hint index 0 is reserved
        HINT_INDEX_INVALID = 0,
    };

    enum hint_slot {
        // Slot 0 is invalid. NCC always generates from Slot 1-to-N.
        HINT_SLOT_INVALID  = 0,
        HINT_SLOT_ONE = 1,
        HINT_SLOT_TWO = 2,
        HINT_SLOT_THREE = 3,
        HINT_SLOT_FOUR = 4,
        HINT_SLOT_FIVE = 5,
        // Slot 1 .... N are all valid slots, auto-generated by NCC.
        // Slot 0xFF is reserved for MoreHints.
        HINT_SLOT_MORE  = 0x7,
    };

public:
    // Flow Table Entry
    FTL_MAKE_AFTYPE(entry_t) entry;

    uint8_t hint_slot;
    uint16_t hash_msbits;
    uint16_t more_hashs;
    uint8_t level;

    bool match;
    bool exmatch;
    bool write_pending;
    bool inited;
    
    uint32_t table_id;
    
    // 32 Bits
    uint32_t table_index;
    uint32_t op;
    uint32_t clear_global_state:1;
    uint32_t clear_thread_local_state:1;
    // 32 Bits
    uint32_t hint;
    uint32_t thread_id:6;
    FTL_MAKE_AFTYPE(bucket) *bucket;
    
    // Properties of this table
    sdk::table::properties_t *props;
    // API Params of this context
    sdk_table_api_params_t *params;
    // Parent API Context: used for context nesting.
    // 1st level HintTable: pctx = MainTable context.
    // 2nd level HintTable: pctx = 1st level HintTable context.
    // and so on...
    FTL_MAKE_AFTYPE(apictx) *pctx;
    // Table stats
    tablestats *tstats;

public:
    FTL_MAKE_AFTYPE(apictx)() {}
    ~FTL_MAKE_AFTYPE(apictx)() {}

    // Debug string
    char* metastr() {
        static char str[256];
        FTL_SNPRINTF(str, sizeof(str), "%p: tid:%d,idx:%d,slt:%d,hnt:%d,"
                     "more:%d,pndg:%d,hmsb:%#x,mat:%d exmat:%d", this, table_id,
                     table_index, hint_slot, hint, more_hashs,
                     write_pending, hash_msbits, match, exmatch);
        return str;
    }

    const char* idstr() {
        static char str[32];
        FTL_SNPRINTF(str, sizeof(str), "%s%d-L%d", level ? "H" : "M",
                     table_index, level);
        return str;
    }

    bool is_max_recircs() {
        return (level >= props->max_recircs);
    }

    bool is_main() {
        return (level == 0);
    }

    void trace(bool trace_params = false,
               const char *fname = __builtin_FUNCTION()) {
        if (!props->entry_trace_en) return;
        static char buff[512];
        if (trace_params) {
            ((FTL_MAKE_AFTYPE(entry_t)*)params->entry)->tostr(buff, sizeof(buff));
        } else {
            entry.tostr(buff, sizeof(buff));
        }
        FTL_TRACE_VERBOSE("%s: input entry:%s hash_32b:%#x hash_valid:%d",
                          fname, buff, params->hash_32b, params->hash_valid);
        (void)buff;
        return;
    }

#if 0
    static void print_entry(FTL_MAKE_AFTYPE(entry_t)* entry,
                            uint32_t hash_32b, bool hash_valid) {
        static char buff[512];\
        entry->tostr(buff, sizeof(buff));
        FTL_TRACE_VERBOSE("input entry:%s hash_32b:%#x hash_valid:%d",
                          buff, hash_32b, hash_valid);
        (void)buff;
    }
#endif

    void init(sdk_table_api_op_t op, sdk_table_api_params_t *params,
              sdk::table::properties_t *props, tablestats *tstats,
              uint32_t thread_id) {
        memset(this, 0, sizeof(FTL_MAKE_AFTYPE(apictx)));
        this->op = op;
        this->props = props;
        this->params = params;
        this->tstats = tstats;
        this->thread_id = thread_id;
        if (params && params->entry) {
            trace(true);
        }
    }

    void init(FTL_MAKE_AFTYPE(apictx) *p) {
         memset(this, 0, sizeof(FTL_MAKE_AFTYPE(apictx)));
         this->op = p->op;
         this->hash_msbits = p->hash_msbits;
         this->level = p->level + 1;
         this->props = p->props;
         this->params = p->params;
         this->tstats = p->tstats;
         this->pctx = p;
		 this->thread_id = p->thread_id;
    }
};

} // namespace FTL_MAKE_AFTYPE(internal)
} // namespace table
} // namespace sdk
