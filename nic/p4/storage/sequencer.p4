/*****************************************************************************
 * sequencer.p4: This models the sequencer block in the P4+ pipeline of 
 *               Capri for sequencing the operations between different blocks 
 *               such as encryption, erasure coding etc
 *****************************************************************************/

/*****************************************************************************
 * High level notes regarding P4 tables/action and translation to Capri asm:
 * Table:  1. Fields in "reads" form the k-vector in asm
 *            Note: Masked fields are not used in lookup in this stage       
 *         2. Data read from lookup (memory access in our case) becomes args 
 *            to action handler and the d-vector in asm
 * Action: 1. Can use the arguments as d-vector and do table writes to those
 *         2. Can use fields defined in reads as k-vector and read those
 *         3. Can write to any area in PHV (the metadata)
 *         4. Can do a posted write to any memory location as long as address
 *            is known
 * Misc:   For locked table accesses:
 *         1. All pop operations to be aligned in stages 1/2
 *         2. All push operations to be aligned to stage 8
 *****************************************************************************/

#include "common/capri.h"
#include "common/sequencer.h"
#include "common/dummy.p4"


/****************************************************************************
 *  Stage: Load the sequencer entry's addr for the next stage to process
 ****************************************************************************/

action load(desc_entry_addr) {
  // Initialize Capri Intrinsic PHV to get the fields generated by NCC
  CAPRI_INTRINSIC_INIT(intrinsic)

  // Save data to PHV
  modify_field(seq.desc_entry_addr, desc_entry_addr);
  
  // Initialize tbl entry address to get this in the p vector
  modify_field(seq.tbl_entry_addr, intrinsic.table_addr_raw);

  // Load the sequencer entry address for the next stage
  CAPRI_LOAD_TABLE_OFFSET(intrinsic, seq.desc_entry_addr, 0, 
                          SEQ_DESC_ENTRY_SIZE, seq_desc_entry_check)
}

table seq_desc_entry_addr {
  reads {
    // Non masked fields (used in lookup)
    intrinsic.table_addr_raw			: exact;
  }
  actions {
    load;
  }
}

control process_seq_desc_entry_addr_load {
  apply(seq_desc_entry_addr);
}


/****************************************************************************
 *  Stage: Process the sequencer entry and determine the next submission 
 *         queue to push to.
 ****************************************************************************/
action check(is_valid, is_last, is_done, is_error, rsvd, desc_size, 
             desc_base_addr, next_sq_ctx_addr) {
  // Save data to PHV 
  modify_field(seq.is_valid, is_valid);
  modify_field(seq.is_last, is_last);
  modify_field(seq.is_done, is_done);
  modify_field(seq.is_error, is_error);
  modify_field(seq.rsvd, rsvd);
  modify_field(seq.desc_size, desc_size);
  modify_field(seq.desc_base_addr, desc_base_addr);
  modify_field(seq.next_sq_ctx_addr, next_sq_ctx_addr);

  // Scratch metadata for the I part of the K vector
  modify_field(scratch_metadata.tbl_entry_addr, seq.tbl_entry_addr);

  // If sequencer entry is not valid, break the chain
  if(seq.is_valid != 1) {
    exit();
  }

  // If this is not the last seq_entry in the list for this stage, 
  // set the addr of next_seq_ent for execution next time
  if(seq.is_last != 1) {
    modify_field(seq.desc_entry_addr,
                 seq.desc_entry_addr + SEQ_DESC_ENTRY_SIZE);
  }

  // Load the next submission queue address for the next stage
  CAPRI_LOAD_TABLE_OFFSET(intrinsic, seq.next_sq_ctx_addr, 0, Q_CTX_SIZE, 
                          seq_next_sq_entry_push)
}

table seq_desc_entry {
  reads {
    // Non masked fields (used in lookup)
    intrinsic.table_addr_raw			: exact;
  }
  actions {
    check;
  }
}

// Control function which selects the match/action for this stage
control process_seq_desc_entry_check {
  apply(seq_desc_entry);
}


/*****************************************************************************
 *  Stage: Enqueue descriptor to next submission queue. Prepare DMA commands 
 *         that will (a) add the descriptory and (b) increment the p_ndx and
 *         ring the doorbell for the next submission queue.
 *****************************************************************************/
action qpush(idx, state, c_ndx, p_ndx, p_ndx_db, c_ndx_db, base_addr,
             num_entries, paired_q_idx, rsvd) {
  // Save data to PHV 
  modify_field(next_sq_ctx.idx, idx);
  modify_field(next_sq_ctx.state, state);
  modify_field(next_sq_ctx.p_ndx, p_ndx);
  modify_field(next_sq_ctx.c_ndx, c_ndx);
  modify_field(next_sq_ctx.p_ndx_db, p_ndx_db);
  modify_field(next_sq_ctx.c_ndx_db, c_ndx_db);
  modify_field(next_sq_ctx.base_addr, base_addr);
  modify_field(next_sq_ctx.num_entries, num_entries);
  modify_field(next_sq_ctx.paired_q_idx, paired_q_idx);
  modify_field(next_sq_ctx.rsvd, rsvd);

  // Scratch metadata for the I part of the K vector
  modify_field(scratch_metadata.desc_base_addr, seq.desc_base_addr);
  modify_field(scratch_metadata.desc_size, seq.desc_size);
  modify_field(scratch_metadata.is_last, seq.is_last);
  modify_field(scratch_metadata.tbl_entry_addr, seq.tbl_entry_addr);
  modify_field(scratch_metadata.tbl_entry_db, seq.tbl_entry_db);
  modify_field(scratch_metadata.desc_entry_addr, seq.desc_entry_addr);

  // Intialize DMA commands so that fields are present in the PHV
  CAPRI_MEM2MEM_DMA_INIT(dma_cmd0)
  CAPRI_MEM2MEM_DMA_INIT(dma_cmd1)
  CAPRI_PHV2MEM_DMA_INIT(dma_cmd2)
  CAPRI_PHV2MEM_DMA_INIT(dma_cmd3)

  // Check for queue full condition before pushing
  if (QUEUE_CANT_PUSH(next_sq_ctx)) {

    // Exit pipeline here without error handling for now. This event of ROCE RQ
    // being full is so rare that it may not require special handling.
    exit();

  } else {

#if 0
    // In ASM: setup mem2mem DMA for the descriptor
    dmawr(next_sq_ctx.base_addr + (next_sq_ctx.p_ndx * SEQ_DESC_ENTRY_SIZE),
          seq.desc_base_addr ..
          seq.desc_base_addr + seq.desc_size);

    // Also issue DMA for saving p_ndx of next_sq and setting scheduler bit for 
    // calling sequencer (if it is not the last entry)
#endif

    // Push the entry to the queue
    QUEUE_PUSH(next_sq_ctx)

    // Update the done bit as queueing dma_cmds for pushing to next submission 
    // queue is now complete 
    modify_field(seq.is_done, 1);
  }
}

table seq_next_sq_ctx {
  reads {
    // Non masked fields (used in lookup)
    intrinsic.table_addr_raw			: exact;
  }
  actions {
    qpush;
  }
}

// Control function which selects the match/action for this stage
control process_seq_next_sq_entry_push {
  apply(seq_next_sq_ctx);
}


// Entry point of the sequencer block 
control process_sequencer {
  // Load the table corresponding to the current Sequencer entry address
  process_seq_desc_entry_addr_load();

  // Check the sequencer descriptor to determine the next submission queueu
  process_seq_desc_entry_check();

  // Push the descriptor the next submission queue
  process_seq_next_sq_entry_push();
}

// Entry point 
control ingress {
    process_sequencer();
}
// Dummy parser
parser start {
  return ingress;
}
