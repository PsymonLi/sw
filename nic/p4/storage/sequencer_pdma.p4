/*****************************************************************************
 * sequencer_pdma.p4: This models the PDMA portion of the sequencer block in 
 *                    the P4+ pipeline of Capri prior to sequencing operations 
 *****************************************************************************/

/*****************************************************************************
 * High level notes regarding P4 tables/action and translation to Capri asm:
 * Table:  1. Fields in "reads" form the k-vector in asm
 *            Note: Masked fields are not used in lookup in this stage       
 *         2. Data read from lookup (memory access in our case) becomes args 
 *            to action handler and the d-vector in asm
 * Action: 1. Can use the arguments as d-vector and do table writes to those
 *         2. Can use fields defined in reads as k-vector and read those
 *         3. Can write to any area in PHV (the metadata)
 *         4. Can do a posted write to any memory location as long as address
 *            is known
 * Misc:   For locked table accesses:
 *         1. All pop operations to be aligned in stages 1/2
 *         2. All push operations to be aligned to stage 8
 *****************************************************************************/

#include "common/capri.h"
#include "common/sequencer.h"
#include "common/dummy.p4"


/*****************************************************************************
 *  Stage: Check Sequencer SQ context. If busy bit set, yield control. Else
 *         set the busy bit, save SQ context to PHV and load the SQ entry.
 *****************************************************************************/

action qcheck(idx, state, c_ndx, p_ndx, p_ndx_db, c_ndx_db, base_addr,
              num_entries, paired_q_idx, rsvd) {

  // Initialize Capri Intrinsic PHV to get the fields generated by NCC
  CAPRI_INTRINSIC_INIT(intrinsic)

  // Save the SQ context into PHV
  modify_field(seq_sq_ctx.idx, idx);
  modify_field(seq_sq_ctx.state, state);
  modify_field(seq_sq_ctx.c_ndx, c_ndx);
  modify_field(seq_sq_ctx.p_ndx, p_ndx);
  modify_field(seq_sq_ctx.p_ndx_db, p_ndx_db);
  modify_field(seq_sq_ctx.c_ndx_db, c_ndx_db);
  modify_field(seq_sq_ctx.base_addr, base_addr);
  modify_field(seq_sq_ctx.num_entries, num_entries);
  modify_field(seq_sq_ctx.paired_q_idx, paired_q_idx);
  modify_field(seq_sq_ctx.rsvd, rsvd);

  // If busy state was set or queue is empty => yield contol
  if (QUEUE_CANT_POP(seq_sq_ctx)) {
    exit();
  } else {
    // Can pop => process the SQ context by locking it and loading the address 
    // for next stage
    QUEUE_LOCK_AND_LOAD(seq_sq_ctx, intrinsic, SEQ_SQ_ENTRY_SIZE,
                        SEQ_SQ_ENTRY_SIZE, seq_sq_entry_pop)
  }
}

table seq_sq_ctx {
  reads {
    // Non masked fields (used in lookup)
    intrinsic.table_addr_raw			: exact;
  }
  actions {
    qcheck;
  }
}

control process_seq_sq_ctx_check {
  apply(seq_sq_ctx);
}


/*****************************************************************************
 *  Stage: Pop the sequencer SQ entry. Initiate PDMA to DMA the payload into 
 *         HBM. Ring the doorbell for the sequencer which needs to be executed
 *         after this DMA. Ensure sequencer starts only after the completion 
 *         of payload DMA with a write fence.
 *****************************************************************************/

action qpop(pdma_src_addr, pdma_dst_addr, pdma_size, tbl_entry_db,
            tbl_entry_db_val, rsvd) {

  // Save Sequencer SQ entry state information in the PHV
  modify_field(seq_sq_ent.pdma_src_addr, pdma_src_addr);
  modify_field(seq_sq_ent.pdma_dst_addr, pdma_dst_addr);
  modify_field(seq_sq_ent.pdma_size, pdma_size);
  modify_field(seq_sq_ent.tbl_entry_db, tbl_entry_db);
  modify_field(seq_sq_ent.tbl_entry_db_val, tbl_entry_db_val);
  modify_field(seq_sq_ent.rsvd, rsvd);

  // Scratch metadata for the I part of the K vector
  modify_field(scratch_metadata.idx, seq_sq_ctx.idx);
  modify_field(scratch_metadata.state, seq_sq_ctx.state);
  modify_field(scratch_metadata.c_ndx, seq_sq_ctx.c_ndx);
  modify_field(scratch_metadata.num_entries, seq_sq_ctx.num_entries);

  // Pop the queue entry
  QUEUE_POP(seq_sq_ctx, SEQ_SQ_CTX_TABLE_BASE)

  // Intialize DMA commands so that fields are present in the PHV
  CAPRI_MEM2MEM_DMA_INIT(dma_cmd0)
  CAPRI_MEM2MEM_DMA_INIT(dma_cmd1)
  CAPRI_PHV2MEM_DMA_INIT(dma_cmd2)

#if 0
    // 1. Setup the PDMA for the data
    dmawr(seq_sq_ent.pdma_dst_addr, 
          seq_sq_ent.pdma_src_addr ..
          seq_sq_ent.pdma_src_addr + seq_sq_ent.pdma_size);
    // 2. DMA write of the doorbell
    dmawr(seq_sq_ent.tbl_entry_db, seq_sq_ent.tbl_entry_db_val);
#endif
}

table seq_sq_entry {
  reads {
    // Non masked fields (used in lookup)
    intrinsic.table_addr_raw			: exact;
  }
  actions {
    qpop;
  }
}

control process_seq_sq_entry_pop {
  apply(seq_sq_entry);
}


// Entry point of the sequencer PDMA block 
control process_sequencer_pdma {
  // Check the Sequencer SQ context prior to popping an entry
  process_seq_sq_ctx_check();

  // Pop an entry from the Sequencer SQ and setup the PDMA via mem2mem DMA
  process_seq_sq_entry_pop();
}

// Entry point 
control ingress {
    process_sequencer_pdma();
}
// Dummy parser
parser start {
  return ingress;
}
