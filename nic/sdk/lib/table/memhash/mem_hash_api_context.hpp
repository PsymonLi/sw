//-----------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//-----------------------------------------------------------------------------
#ifndef __MEM_HASH_TYPES_HPP__
#define __MEM_HASH_TYPES_HPP__

#include "include/sdk/base.hpp"
#include "include/sdk/table.hpp"
#include "lib/p4/p4_api.hpp"

#include "mem_hash_stats.hpp"
#include "mem_hash_txn.hpp"
#include "mem_hash_utils.hpp"

using sdk::table::sdk_table_factory_params_t;
using sdk::table::memhash::mem_hash_txn;

#define MEMHASH_MAX_API_CONTEXTS 8

namespace sdk {
namespace table {
namespace memhash {

#define HINT_SLOT_IS_INVALID(_slot) \
        ((_slot) == mem_hash_api_context::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_IS_VALID(_slot) \
        ((_slot) != mem_hash_api_context::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_SET_INVALID(_slot) \
        ((_slot) = mem_hash_api_context::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_IS_MORE(_slot) \
        ((_slot) == mem_hash_api_context::hint_slot::HINT_SLOT_MORE)
#define HINT_SLOT_SET_MORE(_slot) \
        ((_slot) = mem_hash_api_context::hint_slot::HINT_SLOT_MORE)
#define HINT_SLOT_IS_MATCH(_ctx) \
        (HINT_SLOT_IS_FREE((_ctx)->hint_slot) &&\
         HINT_SLOT_IS_MORE((_ctx)->hint_slot))
#define HINT_IS_VALID(_hint) \
        ((_hint) != mem_hash_api_context::hint_index::HINT_INDEX_INVALID)
#define HINT_SET_INVALID(_hint) \
        ((_hint) = mem_hash_api_context::hint_index::HINT_INDEX_INVALID)

#define PRINT_API_CTX(_name, _ctx) {\
    MEMHASH_TRACE_VERBOSE("%s: %s, [%s]", _name, (_ctx)->idstr(), (_ctx)->metastr()); \
}

class mem_hash_api_context {
public:
    enum match_type{
        MATCH_TYPE_NONE     = 0,
        MATCH_TYPE_EXM      = 1,
        MATCH_TYPE_HINT     = 2,
    };

    enum hint_index {
        // hint index 0 is reserved
        HINT_INDEX_INVALID = 0,
    };

    enum hint_slot {
        // slot 0 is invalid. NCC always generates from Slot 1-to-N.
        HINT_SLOT_INVALID  = 0,
        // slot 1 .... N are all valid slots, auto-generated by NCC.
        // slot 0xFF is reserved for MoreHints.
        HINT_SLOT_MORE  = 0xFF,
    };

public:
    // operation
    sdk_table_api_op_t op;
    // derived fields from input
    uint32_t hash_msbits;
    // SW Key and Data
    bool sw_valid;
    uint8_t sw_key[SDK_TABLE_MAX_SW_KEY_LEN];
    uint8_t sw_data[SDK_TABLE_MAX_SW_DATA_LEN];
    uint8_t sw_appdata[SDK_TABLE_MAX_SW_DATA_LEN];
    // NOTE NOTE NOTE:
    // some of the below fields are re-used by main table and hint table
    // DO NOT USE these to pass info between tables.
    uint32_t level;          // chaining level
    uint8_t table_id;
    uint32_t table_index;
    uint8_t hint_slot;
    uint32_t hint;
    bool more_hashs;
    bool write_pending;
    uint32_t match_type;
    void *bucket;
    // properties of this table
    sdk::table::properties_t *props;
    // API params of this context
    sdk_table_api_params_t *params;
    // parent API context: used for context nesting.
    // 1st level HintTable: pctx = maintable context.
    // 2nd level HintTable: pctx = 1st level hinttable context.
    // and so on...
    mem_hash_api_context *pctx;
    // handle to the entry
    sdk::table::handle_t *handle;
    // table stats
    mem_hash_table_stats *table_stats;
    // API transaction
    mem_hash_txn *txn;

public:
    // default constructor
    mem_hash_api_context(void) {
    }

    // destructor
    ~mem_hash_api_context(void) {
    }

    bool is_exact_match(void) {
        SDK_ASSERT(match_type != MATCH_TYPE_NONE);
        return match_type == MATCH_TYPE_EXM;
    }

    bool is_hint_match(void) {
        SDK_ASSERT(match_type != MATCH_TYPE_NONE);
        return match_type == MATCH_TYPE_HINT;
    }

    void set_exact_match(void) {
        match_type = MATCH_TYPE_EXM;
        return;
    }

    void set_hint_match(void) {
        match_type = MATCH_TYPE_HINT;
        return;
    }

    bool is_hint_valid(void) {
        return hint != HINT_INDEX_INVALID;
    }

    char* inputstr(void) {
        static char str[256];
#ifdef MEMHASH_TRACES_ENABLE
        snprintf(str, sizeof(str),
                 "k:%p,d:%p,hv:%d,h32b:%#x,cbd:%p",
                 params->key, params->appdata, params->hash_valid,
                 params->hash_32b, params->cbdata);
#endif
        return str;
    }

    // debug string
    char* metastr(void) {
        static char str[256];
#ifdef MEMHASH_TRACES_ENABLE
        snprintf(str, sizeof(str), "%p: tid:%d,idx:%d,slt:%d,hnt:%d,"
                 "more:%d,pndg:%d,hmsb:%#x,mt:%d", this, table_id,
                 table_index, hint_slot, hint, more_hashs,
                 write_pending, hash_msbits, match_type);
#endif
        return str;
    }

    const char* idstr(void) {
        static char str[32];
#ifdef MEMHASH_TRACES_ENABLE
        snprintf(str, sizeof(str), "%s%d-L%d", level ? "H" : "M",
                 table_index, level);
#endif
        return str;
    }

    bool is_max_recircs(void) {
        return (level >= props->max_recircs);
    }

} __attribute__((__packed__));

#define MEMHASH_API_CONTEXT_IS_MAIN(_ctx) ((_ctx)->level == 0)

#ifdef MEMHASH_TRACES_ENABLE
#define PRINT_INPUT(_ctx) \
{ \
    if (SDK_TABLE_API_OP_IS_CRUD(_ctx.op)) { \
        char *kstr = (char*)""; \
        char *dstr = (char*)""; \
        if (_ctx.props->key2str) { \
            kstr = _ctx.props->key2str(_ctx.params->key); \
        } else { \
            kstr = mem_hash_utils_rawstr(_ctx.params->key, \
                                         _ctx.props->swkey_len); \
        } \
        MEMHASH_TRACE_VERBOSE("- H:[%#x] K:[%s] Hdl:[%s]", \
                              _ctx.params->hash_32b, kstr, \
                              _ctx.handle->tostr()); \
        if (_ctx.params->appdata) { \
            if (_ctx.props->data2str) { \
                dstr = _ctx.props->data2str(_ctx.params->appdata); \
            } else { \
                dstr = mem_hash_utils_rawstr(_ctx.params->appdata, \
                                             _ctx.props->swappdata_len); \
            } \
        } \
        MEMHASH_TRACE_VERBOSE("- H:[%#x] D:[%s] Hdl:[%s]", \
                              _ctx.params->hash_32b, dstr, \
                              _ctx.handle->tostr()); \
    } \
}
#else
#define PRINT_INPUT(_ctx)
#endif

#define MEMHASH_API_CONTEXT_INIT_MAIN(_ctx, _op, _params, _props, _ts, _txn) \
{ \
    memset(&_ctx, 0, sizeof(mem_hash_api_context));\
    _ctx.op = _op; \
    _ctx.props = _props; \
    _ctx.params = _params; \
    _ctx.handle = &_params->handle; \
    _ctx.table_stats = _ts; \
    _ctx.txn = _txn; \
    PRINT_INPUT(_ctx); \
}

#define MEMHASH_API_CONTEXT_INIT(_dstctx, _parctx) \
{ \
    memset(_dstctx, 0, sizeof(mem_hash_api_context)); \
    _dstctx->op = _parctx->op; \
    _dstctx->hash_msbits = _parctx->hash_msbits; \
    _dstctx->level = _parctx->level + 1; \
    _dstctx->props = _parctx->props; \
    _dstctx->params = _parctx->params; \
    _dstctx->handle = _parctx->handle; \
    _dstctx->table_stats = _parctx->table_stats; \
    _dstctx->txn = _parctx->txn; \
    _dstctx->pctx = _parctx; \
}

#define MEMHASH_API_CONTEXT_PRINT_SW_FIELDS(_ctx) \
{ \
    MEMHASH_TRACE_DEBUG("memhash %s: TID:%d Idx:%d", _ctx->idstr(),\
                        _ctx->table_id, _ctx->table_index);\
    p4pd_global_table_ds_decoded_string_get(_ctx->table_id, _ctx->table_index,\
                                            _ctx->sw_key, NULL,\
                                            _ctx->sw_data, g_buff, sizeof(g_buff));\
    MEMHASH_TRACE_DEBUG("TID:%d, Idx:%u\n%s",\
                        _ctx->table_id, _ctx->table_index, g_buff);\
}

} // namespace memhash
} // namespace table
} // namespace sdk

#endif // __MEM_HASH_TYPES_HPP__
