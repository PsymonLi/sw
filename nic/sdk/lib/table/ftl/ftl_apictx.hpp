//-----------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//-----------------------------------------------------------------------------

#ifndef __FTL_APICTX_HPP__
#define __FTL_APICTX_HPP__

#include "include/sdk/base_table_entry.hpp"

#define FTL_MAX_API_CONTEXTS 8

namespace sdk {
namespace table {
namespace internal {

#define HINT_SLOT_IS_INVALID(_slot) \
        ((_slot) == Apictx::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_IS_VALID(_slot) \
        ((_slot) != Apictx::hint_slot::HINT_SLOT_INVALID)
#define HINT_SLOT_SET_INVALID(_slot) \
        ((_slot) = Apictx::hint_slot::HINT_SLOT_INVALID)
#define HINT_IS_VALID(_hint) \
        ((_hint) != Apictx::hint_index::HINT_INDEX_INVALID)
#define HINT_SET_INVALID(_hint) \
        ((_hint) = Apictx::hint_index::HINT_INDEX_INVALID)

#define PRINT_API_CTX(_name, _ctx) {\
    FTL_TRACE_VERBOSE("%s: %s, [%s]", _name, (_ctx)->idstr(), (_ctx)->metastr()); \
}

class Apictx {
private:
    // pointer to the ftl_base class using the apictx
    void *ftlbase_;

public:
    enum hint_index {
        // Hint index 0 is reserved
        HINT_INDEX_INVALID = 0,
    };

    enum hint_slot {
        // Slot 0 is invalid. NCC always generates from Slot 1-to-N.
        HINT_SLOT_INVALID  = 0,
        HINT_SLOT_ONE = 1,
        HINT_SLOT_TWO = 2,
        HINT_SLOT_THREE = 3,
        HINT_SLOT_FOUR = 4,
        HINT_SLOT_FIVE = 5,
        // Slot 1 .... N are all valid slots, auto-generated by NCC.
        // Slot 0xFF is reserved for MoreHints.
        HINT_SLOT_MORE  = 0x7,
    };

public:
    // Flow Table Entry size
    uint32_t entry_size;
    // Flow Table Entry
    base_table_entry_t *entry;

    uint8_t hint_slot;
    uint16_t hash_msbits;
    uint16_t more_hashs;
    uint8_t level;

    bool match;
    bool exmatch;
    bool write_pending;
    bool inited;
    
    uint32_t table_id;
    
    // 32 Bits
    uint32_t table_index;
    uint32_t op;
    uint32_t clear_global_state:1;
    uint32_t clear_thread_local_state:1;
    // 32 Bits
    uint32_t hint;
    uint32_t thread_id:6;
    Bucket *bucket;
    
    // Properties of this table
    sdk::table::properties_t *props;
    // API Params of this context
    sdk_table_api_params_t *params;
    // Parent API Context: used for context nesting.
    // 1st level hint_table: pctx = main_table context.
    // 2nd level hint_table: pctx = 1st level hint_table context.
    // and so on...
    Apictx *pctx;
    // Table stats
    tablestats *tstats;

public:
    Apictx() {}
    ~Apictx() {
    }

    // Debug string
    char* metastr() {
        static thread_local char str[256];
        FTL_SNPRINTF(str, sizeof(str), "%p: thread_id:%u,tid:%d,idx:%d,slt:%d,hnt:%d,"
                     "more:%d,pndg:%d,hmsb:%#x,mat:%d exmat:%d", this, thread_id, table_id,
                     table_index, hint_slot, hint, more_hashs,
                     write_pending, hash_msbits, match, exmatch);
        return str;
    }

    const char* idstr() {
        static thread_local char str[32];
        FTL_SNPRINTF(str, sizeof(str), "%s%d-L%d", level ? "H" : "M",
                     table_index, level);
        return str;
    }

    bool is_max_recircs() {
        return (level >= props->max_recircs);
    }

    bool is_main() {
        return (level == 0);
    }

    void trace(bool trace_params = false,
               const char *fname = __builtin_FUNCTION()) {
        if (!props->entry_trace_en) return;
        static thread_local char buff[512];
        if (trace_params) {
            params->entry->tostr(buff, sizeof(buff));
        } else {
            entry->tostr(buff, sizeof(buff));
        }
        FTL_TRACE_VERBOSE("%s: input entry:%s hash_32b:%#x hash_valid:%d",
                          fname, buff, params->hash_32b, params->hash_valid);
        (void)buff;
        return;
    }

    void *ftlbase(void) {
        return ftlbase_;
    }

#if 0
    static void print_entry(base_table_entry_t *entry,
                            uint32_t hash_32b, bool hash_valid) {
        static thread_local char buff[512];\
        entry->tostr(buff, sizeof(buff));
        FTL_TRACE_VERBOSE("input entry:%s hash_32b:%#x hash_valid:%d",
                          buff, hash_32b, hash_valid);
        (void)buff;
    }
#endif

    sdk_ret_t init(sdk_table_api_op_t op, sdk_table_api_params_t *params,
                   sdk::table::properties_t *props, tablestats *tstats,
                   uint32_t thread_id, void* ftlbase,
                   base_table_entry_t *entry, uint32_t entry_size) {
        memset(this, 0, sizeof(Apictx));

        this->entry = entry;
        this->entry->clear();

        this->ftlbase_ = ftlbase;
        this->entry_size = entry_size;
        this->op = op;
        this->props = props;
        this->params = params;
        this->tstats = tstats;
        this->thread_id = thread_id;
        if (params && params->entry) {
            trace(true);
        }
        return SDK_RET_OK;
    }

    sdk_ret_t init(Apictx *p, base_table_entry_t *entry) {
        memset(this, 0, sizeof(Apictx));

        this->entry = entry;
        this->entry->clear();

        this->ftlbase_ = p->ftlbase();
        this->entry_size = p->entry_size;
        this->op = p->op;
        this->hash_msbits = p->hash_msbits;
        this->level = p->level + 1;
        this->props = p->props;
        this->params = p->params;
        this->tstats = p->tstats;
        this->pctx = p;
        this->thread_id = p->thread_id;
        return SDK_RET_OK;
    }
};

} // namespace internal
} // namespace table
} // namespace sdk

#endif   // __FTL_APICTX_HPP__
