#include <inttypes.h>
#include <cstring>
#include "include/sdk/mem.hpp"
#include "platform/utils/mpartition.hpp"
// Below file is autogenerated for the given platform
#include "gen/platform/mem_regions.hpp"

namespace sdk {
namespace platform {
namespace utils {

mpartition *mpartition::instance_ = nullptr;

sdk_ret_t
mpartition::region_init(shmmgr *mmgr)
{

    base_addr_ = MEM_REGION_BASE_ADDR;
    mmgr_ = mmgr;

    char nlist[][64] = MEM_REGION_NAME_LIST;
    long slist[] = MEM_REGION_SIZE_LIST;
    long olist[] = MEM_REGION_START_OFFSET_LIST;
    cache_pipe_t  clist[] = MEM_REGION_CACHE_PIPE_LIST;
    int  rlist[] = MEM_REGION_RESET_LIST;

    regions_ = (mpartition_region_t *)
        SDK_CALLOC(SDK_MEM_ALLOC_ID_PLATFORM_MEMORY, MEM_REGION_COUNT * sizeof(mpartition_region_t));
    if (!regions_) {
        return SDK_RET_OOM;
    }

    num_regions_ = MEM_REGION_COUNT;
    mpartition_region_t *reg = regions_;
    for(int idx = 0; idx < MEM_REGION_COUNT; idx++) {
        std::strcpy(reg->mem_reg_name, nlist[idx]);
        reg->size =  slist[idx];
        reg->start_offset =  olist[idx];
        reg->cache_pipe =  clist[idx];
        reg->reset =  rlist[idx];

        SDK_TRACE_DEBUG("region : %s, size : %dkb, reset : %d, "
                        "start : 0x%" PRIx64 ", end : 0x%" PRIx64 "",
                        reg->mem_reg_name, reg->size, reg->reset,
                        addr(reg->start_offset),
                        addr(reg->start_offset + reg->size));
        reg++;
    }

    return SDK_RET_OK;
}

mpartition *
mpartition::init(shmmgr *mmgr)
{
    void          *mem;
    mpartition    *new_mpartition;

    if (mmgr) {
        mem = mmgr->alloc(sizeof(mpartition), 4, true);
    } else {
        mem = SDK_CALLOC(SDK_MEM_ALLOC_LIB_PLATFORM, sizeof(mpartition));
    }
    if (mem == NULL) {
        SDK_TRACE_ERR("Failed to create mpartition instance");
        return NULL;
    }
    new_mpartition = new (mem) mpartition();
    if (new_mpartition->region_init(mmgr) != SDK_RET_OK) {
        SDK_TRACE_ERR("Failed to initialize program info");
        new_mpartition->~mpartition();
        if (mmgr) {
            mmgr->free(mem);
        } else {
            SDK_FREE(SDK_MEM_ALLOC_LIB_PLATFORM, mem);
        }
        return NULL;
    }
    return new_mpartition;
}

mpartition *
mpartition::factory(shmmgr *mmgr)
{
    if (instance_ == nullptr) {
        instance_ = mpartition::init(mmgr);
    }
    return instance_;
}

mpartition *
mpartition::get_instance(void)
{
    return mpartition::factory(NULL);
}

void
mpartition::destroy(mpartition *mpartition)
{
    shmmgr    *mmgr;
    if (!mpartition) {
        return;
    }
    mmgr = mpartition->mmgr_;
    mpartition->~mpartition();
    if (mmgr) {
        mmgr->free(mpartition);
    } else {
        SDK_FREE(SDK_MEM_ALLOC_LIB_PLATFORM, mpartition);
    }
    instance_ = nullptr;
}

mem_addr_t
mpartition::start_offset (const char *reg_name)
{
    mpartition_region_t *reg = region(reg_name);
    return reg ? reg->start_offset : INVALID_MEM_ADDRESS;
}

mem_addr_t
mpartition::start_addr (const char *reg_name)
{
    mem_addr_t start_offset = this->start_offset(reg_name);
    return start_offset != INVALID_MEM_ADDRESS ? addr(start_offset) : INVALID_MEM_ADDRESS;
}

uint32_t
mpartition::size (const char *reg_name)
{
    mpartition_region_t *reg = region(reg_name);
    return reg ? reg->size : 0;
}

mpartition_region_t *
mpartition::region (const char *reg_name)
{
    mpartition_region_t      *reg;

    for (int i = 0; i < num_regions_; i++) {
        reg = &regions_[i];
        if (!std::strcmp(reg->mem_reg_name, reg_name)) {
            return reg;
        }
    }
    return NULL;
}

mpartition_region_t *
mpartition::region_by_address (uint64_t addr)
{
    mpartition_region_t      *reg;

    for (int i = 0; i < num_regions_; i++) {
        reg = &regions_[i];

        /*
        SDK_TRACE_DEBUG("Region: {}, Size_KB: {}, Start:{:#x} End:{:#x}, addr: {:#x}",
                        reg->mem_reg_name, reg->size,
                        offset(reg->start_offset),
                        offset(reg->start_offset + reg->size * 1024), addr);
        */

        if ((addr >= this->addr(reg->start_offset)) &&
            (addr < this->addr(reg->start_offset + (reg->size)))) {
            return reg;
        }
    }
    return NULL;
}

}   // namespace utils
}   // namespace platform
}   // namespace sdk

