#include <stdint.h>
#include <vector>
#include "nic/include/base.hpp"
#include "nic/sdk/include/sdk/eth.hpp"
#include "nic/sdk/include/sdk/ip.hpp"
#include "nic/sdk/lib/utils/utils.hpp"
#include "nic/athena/api/include/pds_vnic.h"
#include "nic/athena/api/include/pds_flow_cache.h"
#include "nic/athena/api/include/pds_flow_session_info.h"
#include "nic/athena/api/include//pds_flow_session_rewrite.h"
#include "nic/athena/api/include/pds_init.h"
#include "athena_gtest.hpp"

/* Functionality of Uplink-Uplink NACL (traffic coming on one uplink 
 * is redirected to another) is only verified in gtest. Packets not
 * tagged with mfr vlans should be redirected between uplinks and 
 * those having mfr vlans are instead redirected to ARM and hence,
 * should not be seen on the other uplink.
 */
#define MFR_TEST_VLAN_A 1000
#define MFR_TEST_VLAN_B 2000

//Following UDP, TCP, ICMP pkts do not have the above vlan tags

/*
 * UDP packet 
 */
static uint8_t g_pkt_ipv4_udp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x01,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x50, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x11, 0xB6, 0x9A, 0x02, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x02, 0x01, 0x03, 0xE8,
    0x27, 0x10, 0x00, 0x3C, 0xF3, 0x44, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
};

static uint8_t g_pkt_ipv6_udp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x01,
    0x86, 0xDD, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3C,
    0x11, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x01, 0x03, 0xE8, 0x27, 0x10, 0x00, 0x3C,
    0xA7, 0x45, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79
};

/*
 * TCP packet
 */
static uint8_t g_pkt_ipv4_tcp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x02,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x5C, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x06, 0xB6, 0x9A, 0x02, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x02, 0x01, 0x03, 0xE8,
    0x27, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x83, 0x7D,
    0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79
};

static uint8_t g_pkt_ipv6_tcp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x02,
    0x86, 0xDD, 0x60, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x06, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x01, 0x03, 0xE8, 0x27, 0x10, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02,
    0x20, 0x00, 0x37, 0x7E, 0x00, 0x00, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
};

/*
 * ICMP packet 
 */
static uint8_t g_pkt_ipv4_icmp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x04,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x01, 0xB6, 0xAB, 0x02, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x02, 0x01, 0x08, 0x00,
    0xC8, 0x94, 0x12, 0x34, 0x00, 0x00, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
};

static uint8_t g_pkt_ipv6_icmp[] = {
    0x00, 0x00, 0xF1, 0xD0, 0xD1, 0xD0, 0x00, 0x00,
    0x00, 0x40, 0x08, 0x01, 0x81, 0x00, 0x00, 0x04,
    0x86, 0xDD, 0x60, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x3A, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x01, 0x80, 0x00, 0x40, 0x18, 0x12, 0x34,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
};


sdk_ret_t
athena_gtest_test_mfr_uplink_nacl(void)
{
    sdk_ret_t ret = SDK_RET_OK, ret2 = SDK_RET_OK;
    uint8_t tx_port, rx_port;
    pds_ret_t pds_ret = PDS_RET_OK;
    uint16_t vlans[2] = {MFR_TEST_VLAN_A, MFR_TEST_VLAN_B};
    pds_mfg_mode_params_t params;

    params.vlans[0] = MFR_TEST_VLAN_A;
    params.vlans[1] = MFR_TEST_VLAN_B;

    //Set up the NACLs
    pds_ret = pds_mfg_mode_setup(&params);
    if (pds_ret != PDS_RET_OK) {
        printf("[%s] Failed to program mfr nacls, ret %u", __func__, pds_ret); 
        ret = (sdk_ret_t) pds_ret;
        goto cleanup;
    }

    //Test if packets not matching mfr vlans are redirected
    //from one uplink to another
    for(uint8_t i = 0; i != 2; ++i) {
        if(i == 0) {
            tx_port = g_h_port;
            rx_port = g_s_port;
        } else {
            tx_port = g_s_port;
            rx_port = g_h_port;
        }

        ret = send_packet("UDP-IPv4 pkt", g_pkt_ipv4_udp,
                            sizeof(g_pkt_ipv4_udp), tx_port,
                            g_pkt_ipv4_udp, sizeof(g_pkt_ipv4_udp), 
                            rx_port);
        
        if (ret != SDK_RET_OK) 
            goto cleanup;

        ret = send_packet("UDP-IPv6 pkt", g_pkt_ipv6_udp,
                            sizeof(g_pkt_ipv6_udp), tx_port,
                            g_pkt_ipv6_udp, sizeof(g_pkt_ipv6_udp), 
                            rx_port);
        
        if (ret != SDK_RET_OK) 
            goto cleanup;

        ret = send_packet("TCP-IPv4 pkt", g_pkt_ipv4_tcp,
                            sizeof(g_pkt_ipv4_tcp), tx_port,
                            g_pkt_ipv4_tcp, sizeof(g_pkt_ipv4_tcp), 
                            rx_port);

        if (ret != SDK_RET_OK) 
            goto cleanup;

        ret = send_packet("TCP-IPv6 pkt", g_pkt_ipv6_tcp,
                            sizeof(g_pkt_ipv6_tcp), tx_port,
                            g_pkt_ipv6_tcp, sizeof(g_pkt_ipv6_tcp), 
                            rx_port);

        if (ret != SDK_RET_OK) 
            goto cleanup;

        ret = send_packet("ICMP-IPv4 pkt", g_pkt_ipv4_icmp,
                            sizeof(g_pkt_ipv4_icmp), tx_port,
                            g_pkt_ipv4_icmp, sizeof(g_pkt_ipv4_icmp), 
                            rx_port);

        if (ret != SDK_RET_OK) 
            goto cleanup;

        ret = send_packet("ICMP-IPv6 pkt", g_pkt_ipv6_icmp,
                            sizeof(g_pkt_ipv6_icmp), tx_port,
                            g_pkt_ipv6_icmp, sizeof(g_pkt_ipv6_icmp), 
                            rx_port);

        if (ret != SDK_RET_OK) 
            goto cleanup;
    }

    //Test if packets matching mfr vlans are not received on the 
    //other uplink port. They would instead be redirected to ARM
    for(uint8_t i = 0; i != 2; ++i) {
        if(i == 0) {
            tx_port = g_h_port;
        } else {
            tx_port = g_s_port;
        }

        for(uint8_t j = 0; j != sizeof(vlans)/sizeof(uint16_t); ++j) { 
            printf("Sending pkts with vlan %u\n", vlans[j]);

            g_pkt_ipv4_udp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv4_udp[15] = vlans[j] & 0xFF;
            g_pkt_ipv6_udp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv6_udp[15] = vlans[j] & 0xFF;
            g_pkt_ipv4_tcp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv4_tcp[15] = vlans[j] & 0xFF;
            g_pkt_ipv6_tcp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv6_tcp[15] = vlans[j] & 0xFF;
            g_pkt_ipv4_icmp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv4_icmp[15] = vlans[j] & 0xFF;
            g_pkt_ipv6_icmp[14] = (vlans[j] >> 8) & 0xF; g_pkt_ipv6_icmp[15] = vlans[j] & 0xFF;
            
            ret = send_packet("UDP-IPv4 pkt", g_pkt_ipv4_udp,
                                sizeof(g_pkt_ipv4_udp), tx_port,
                                NULL, 0, 0);
            
            if (ret != SDK_RET_OK) 
                goto cleanup;

            ret = send_packet("UDP-IPv6 pkt", g_pkt_ipv6_udp,
                                sizeof(g_pkt_ipv6_udp), tx_port,
                                NULL, 0, 0);
            
            if (ret != SDK_RET_OK) 
                goto cleanup;

            ret = send_packet("TCP-IPv4 pkt", g_pkt_ipv4_tcp,
                                sizeof(g_pkt_ipv4_tcp), tx_port,
                                NULL, 0, 0);

            if (ret != SDK_RET_OK) 
                goto cleanup;

            ret = send_packet("TCP-IPv6 pkt", g_pkt_ipv6_tcp,
                                sizeof(g_pkt_ipv6_tcp), tx_port,
                                NULL, 0, 0);

            if (ret != SDK_RET_OK) 
                goto cleanup;

            ret = send_packet("ICMP-IPv4 pkt", g_pkt_ipv4_icmp,
                                sizeof(g_pkt_ipv4_icmp), tx_port,
                                NULL, 0, 0);

            if (ret != SDK_RET_OK) 
                goto cleanup;
            
            ret = send_packet("ICMP-IPv6 pkt", g_pkt_ipv6_icmp,
                                sizeof(g_pkt_ipv6_icmp), tx_port,
                                NULL, 0, 0);

            if (ret != SDK_RET_OK) 
                goto cleanup;
        }
    }

cleanup:
    pds_ret = pds_mfg_mode_teardown(&params);
    if (pds_ret != PDS_RET_OK) {
        printf("[%s] Failed to unprogram mfr nacls, ret %u", __func__, pds_ret); 
        ret = (sdk_ret_t) pds_ret;
    }

    return ret;
}
