//------------------------------------------------------------------------------
// protobuf specification for network security objects
//------------------------------------------------------------------------------

syntax = "proto3";

import "nic/delphi/example/hal/proto/types.proto";
import "nic/delphi/example/hal/proto/kh.proto";
import "nic/delphi/proto/delphi/delphi.proto";

package halproto;

// normalization feature actions upon detecting malformed packets
enum NormalizationAction {
  NORM_ACTION_NONE    = 0;
  NORM_ACTION_ALLOW   = 1;    // allow the packet as is
  NORM_ACTION_DROP    = 2;    // drop the packet
  NORM_ACTION_EDIT    = 3;    // reset/trim/fix invalid fields/flags
}


//------------------------------------------------------------------------------
// SecurityProfileSpec object captures feature knobs that are most likely
// shareable across L2 segments, vrfs, or even interfaces and most of the
// time operates on defaults. It is possible that there is only object of this
// kind in the system.
// NOTE: user is not expected to fill in all the fields explicitly, that job is
//       done by the agent. Agent will be exposing user visible knobs and fill
//       in the defaults when interacting with HAL.
//
// Expected defaults:
//
// 1. Any abnormal behavior w.r.t flags (IP or TCP), default action is drop
// 2. Anything to do with options, default behavior is to reset/trim
// 3. Any length related errors, default is truncate the pkt
//
// {
//     cnxn_tracking_en                    = true
//     tcp_non_syn_first_pkt_drop          = true
//
//     ip_normalization_en                 = true
//     {
//         ip_ttl_change_detect_en         = false
//         ip_rsvd_flags_action            = drop
//         ip_df_action                    = allow
//         ip_options_action               = allow
//         ip_invalid_len_action           = trim
//         ip_normalize_ttl                = 0 (applicable only for workload
//                                              generated traffic)
//     }
//
//     icmp_normalization_en               = true
//     {
//         icmp_invalid_code_action        = drop
//         icmp_deprecated_msgs_drop       = true
//         icmp_redirect_msg_drop          = true
//     }
//
//     tcp_normalization_en                = true
//     {
//         tcp_split_handshake_drop        = false
//         tcp_rsvd_flags_action           = drop
//         tcp_unexpected_mss_action       = strip
//         tcp_unexpected_win_scale_action = strip
//         tcp_urg_ptr_not_set_action      = reset
//         tcp_urg_flag_not_set_action     = reset
//         tcp_urg_payload_missing_action  = reset
//         tcp_rst_with_data_action        = drop
//         tcp_data_len_gt_mss_action      = trim  (if conntrack is enabled)
//         tcp_data_len_gt_win_size_action = trim  (if conntrack is enabled)
//         tcp_unexpected_ts_option_action = reset (if conntrack is enabled)
//         tcp_unexpected_echo_ts_action   = drop
//         tcp_ts_not_present_drop         = true  (if conntrack is enabled)
//         tcp_invalid_flags_drop          = true
//         tcp_nonsyn_noack_drop           = true
//         tcp_normalize_mss               = 0 (no tcp_mss normalization)
//     }
// }
//------------------------------------------------------------------------------
message SecurityProfileSpec {
  option (delphi.update_event) = true;
  delphi.ObjectMeta            Meta              = 1;
  SecurityProfileKeyHandle     Key               = 2;

  uint32                       session_idle_timeout               = 3;
  uint32                       tcp_cnxn_setup_timeout             = 4;
  uint32                       tcp_close_timeout                  = 5;
  uint32                       tcp_half_closed_timeout            = 6;
  uint32                       ip_normalize_ttl                   = 7;
  uint32                       tcp_drop_timeout                   = 8;
  uint32                       udp_drop_timeout                   = 9;
  uint32                       icmp_drop_timeout                  = 10;
  uint32                       drop_timeout                       = 11;
  uint32                       tcp_timeout                        = 12;
  uint32                       udp_timeout                        = 13;
  uint32                       icmp_timeout                       = 14;

  bool                         cnxn_tracking_en                   = 15;
  bool                         ipsg_en                            = 16;
  bool                         tcp_rtt_estimate_en                = 17;
  bool                         ip_normalization_en                = 18;
  bool                         tcp_normalization_en               = 19;
  bool                         icmp_normalization_en              = 20;
  bool                         ip_reassembly_en                   = 21;

  // IP normalization knobs
  bool                         ip_ttl_change_detect_en            = 22;
  bool                         ip_src_guard_en                    = 23;
  NormalizationAction          ip_rsvd_flags_action               = 24;
  NormalizationAction          ip_df_action                       = 25;
  NormalizationAction          ip_options_action                  = 26;
  NormalizationAction          ip_invalid_len_action              = 27;
  bool                         ip_spoof_pkt_drop                  = 28;
  bool                         ip_loose_src_routing_pkt_drop      = 29;
  bool                         ip_malformed_option_pkt_drop       = 30;
  bool                         ip_record_route_option_pkt_drop    = 31;
  bool                         ip_strict_src_routing_pkt_drop     = 32;
  bool                         ip_ts_option_pkt_drop              = 33;
  bool                         ip_unknown_option_pkt_drop         = 34;
  bool                         ip_stream_id_option_pkt_drop       = 35;
  bool                         ip_rsvd_fld_set_pkt_drop           = 36;
  bool                         ip_clear_df_bit                    = 37;

  // IPv6 knobs
  bool                         ipv6_anycast_src_drop              = 40;
  bool                         ipv6_v4_compatible_addr_drop       = 41;
  bool                         ipv6_needless_ip_frag_hdr_drop     = 42;
  bool                         ipv6_invalid_options_pkt_drop      = 43;
  bool                         ipv6_rsvd_fld_set_pkt_drop         = 44;
  bool                         ipv6_rtg_hdr_pkt_drop              = 45;
  bool                         ipv6_dst_options_hdr_pkt_drop      = 46;
  bool                         ipv6_hop_by_hop_options_pkt_drop   = 47;


  // ICMP/ICMPv6 normalization knobs
  NormalizationAction          icmp_invalid_code_action           = 50;
  bool                         icmp_deprecated_msgs_drop          = 51;
  bool                         icmp_redirect_msg_drop             = 52;
  bool                         icmp_dst_unreach_ignore_payload    = 53;
  bool                         icmp_param_prblm_ignore_payload    = 54;
  bool                         icmp_pkt_too_big_ignore_payload    = 55;
  bool                         icmp_redirect_ignore_payload       = 56;
  bool                         icmp_time_exceed_ignore_payload    = 57;
  bool                         icmp_error_drop                    = 58;
  bool                         icmp_fragments_drop                = 59;
  bool                         icmp_large_pkt_drop                = 60;
  bool                         icmp_ping_zero_id_drop             = 61;
  bool                         icmp_need_frag_suppress            = 62;
  bool                         icmp_time_exceed_suppress          = 63;
  bool                         icmpv6_large_msg_mtu_small_drop    = 64;


  // TCP normalization knobs
  bool                         tcp_split_handshake_drop           = 71;
  NormalizationAction          tcp_rsvd_flags_action              = 72;
  NormalizationAction          tcp_unexpected_mss_action          = 73;
  NormalizationAction          tcp_unexpected_win_scale_action    = 74;
  NormalizationAction          tcp_unexpected_sack_perm_action    = 75;
  NormalizationAction          tcp_urg_ptr_not_set_action         = 76;
  NormalizationAction          tcp_urg_flag_not_set_action        = 77;
  NormalizationAction          tcp_urg_payload_missing_action     = 78;
  NormalizationAction          tcp_rst_with_data_action           = 79;
  NormalizationAction          tcp_data_len_gt_mss_action         = 80;
  NormalizationAction          tcp_data_len_gt_win_size_action    = 81;
  NormalizationAction          tcp_unexpected_ts_option_action    = 82;
  NormalizationAction          tcp_unexpected_echo_ts_action      = 83;
  NormalizationAction          tcp_unexpected_sack_option_action  = 84;
  bool                         tcp_ts_not_present_drop            = 85;
  bool                         tcp_non_syn_first_pkt_drop         = 86;

  // We will check for the following cases for invalid TCP flags
  // 1. SYN + FIN
  // 2. SYN + RST
  // 3. All TCP flags set (tcp_flags = 0xFF)
  // 4. No TCP flags set (tcp_flags = 0x0)
  bool                         tcp_invalid_flags_drop             = 87;
  bool                         tcp_nonsyn_noack_drop              = 88;
  bool                         tcp_syn_with_data_drop             = 89;
  bool                         tcp_syn_ack_with_data_drop         = 90;
  bool                         tcp_overlapping_segments_drop      = 91;
  bool                         tcp_strip_timestamp_option         = 92;
  bool                         tcp_conn_track_bypass_window_err   = 93;
  bool                         tcp_conn_track_fin_rst_disable     = 94;
  bool                         tcp_urg_flag_ptr_clear             = 95;
  // Can we have zero as default but when configured the range is between 576 - 9216 ?
  uint32                       tcp_normalize_mss                  = 96;
  bool                         multicast_src_drop                 = 101;
}

// SecurityProfile operational status
message SecurityProfileStatus {
  option (delphi.update_event) = true;
  delphi.ObjectMeta            Meta              = 1;
  SecurityProfileKeyHandle     Key               = 2;
  fixed64    profile_handle                      = 3;    // id of the security profile returned by HAL
}


// SecurityProfileStats is the statistics object for each SecurityProfile profile
message SecurityProfileStats {
}


// Firewall policy actions
enum FirewallAction {
  FIREWALL_ACTION_NONE   = 0;
  FIREWALL_ACTION_ALLOW  = 1;
  FIREWALL_ACTION_DENY   = 2;
  FIREWALL_ACTION_REJECT = 3;
}

// Service object identifies an app defined by IP protocol and TCP/UDP port
// in most cases. This object also can specify blanket apps like all TCP or
// UDP traffic, all IP traffic, ICMP type/code combinations etc.
message Service {
    IPProtocol           ip_protocol   = 1;    // IP protocol
    oneof l4_info {
        uint32                 dst_port      = 2;    // TCP or UDP port,
                                                     // 0 for other protocols
        ICMPMsgType      icmp_msg_type = 3;
    }
    ALGName                    alg           = 4;                //  Identifies ALG name
}

// Applicaion Layer Gateway (ALG) names for invoking appropriate ALG
enum ALGName {
   APP_SVC_NONE       = 0;
   APP_SVC_TFTP       = 1;    // Trivial File Transfer Protocol
   APP_SVC_FTP        = 2;    // File Transfer Protocol
   APP_SVC_DNS        = 3;    // Domain Name System
   APP_SVC_SIP        = 4;    // Session Initiation Protocol
   APP_SVC_SUN_RPC    = 5;    // SUN Remote Procedure Call
   APP_SVC_MSFT_RPC   = 6;    // Microsoft Remote Procedure Call
   APP_SVC_RTSP       = 7;    // Real-Time Streaming Protocol
}

// FirewallRuleSpec defines a stateful firewall rule that is part of a
// SecurityGroupSpec
message FirewallRuleSpec {
    repeated  Service   svc                = 2;    // application service
    repeated  string    apps               = 3;    // For appid based policy enforcement
    FirewallAction      action             = 4;    // action to take
    bool                log                = 5;    // log if this rule is hit
}

// ingress policy for the security group
message SGPolicy {
  repeated FirewallRuleSpec    in_fw_rules       = 1;    // ingress firewall rules
  repeated FirewallRuleSpec    eg_fw_rules    = 2;    // egress firewall rules
}

// egress policy for the security group
//message EgressSGPolicy {
  //repeated FirewallRuleSpec    fw_rules       = 1;    // egress firewall rules
//}



// SecurityGroupPolicySpec captures the policy for a security group pair (aka. group of
// endpoints or enic interfaces) in both directions from workload's perspective.
// This policy will be attached to enic interface or an endpoint so it applies
// to the traffic from/to that workload. If no match is found for the new
// session in the slow path, either a drop flow will be installed or packet will
// be dropped without creating drop flow
message SecurityGroupPolicySpec {
  option (delphi.update_event) = true;
  delphi.ObjectMeta               Meta           = 1;
  SecurityGroupPolicyKeyHandle    Key            = 2;

  SGPolicy                        policy_rules   = 3;    // ingress policy
}


// security group operational status
message SecurityGroupPolicyStatus {
  option (delphi.update_event) = true;
  delphi.ObjectMeta              Meta              = 1;
  SecurityGroupPolicyKeyHandle     Key             = 2;

  fixed64    policy_handle            = 3;    // id of the security group returned by HAL
}



// SecurityGroupStats is the statistics object for a security group
message SecurityGroupPolicyStats {
}


message SecurityGroupSpec {
    option (delphi.update_event) = true;
    delphi.ObjectMeta              Meta              = 1;
    SecurityGroupKeyHandle         Key               = 2;
}

// security group operational status
message SecurityGroupStatus {
  option (delphi.update_event) = true;
  delphi.ObjectMeta              Meta              = 1;
  SecurityGroupKeyHandle         Key               = 2;
  fixed64                        sg_handle         = 3;    // id of the security group returned by HAL
}


// SecurityGroupStats is the statistics object for a security group
message SecurityGroupStats {
}

message ICMPMsg {
  ICMPMsgType     type = 1;  // ICMP Type
  uint32                code = 2;  // ICMP code
}

message DoSService {
    IPProtocol           ip_protocol   = 1;    // IP protocol
    oneof l4_info {
        uint32                 dst_port      = 2;    // TCP or UDP port,
                                                     // 0 for other protocols
        ICMPMsg                icmp_msg      = 3;
    }
}

// DoSSessionLimits captures the session limits to be enforced on a security
// group
message DoSSessionLimits {
  uint32    max_sessions       = 1;    // max. no of sessions
  uint32    blocking_timeout   = 2;    // cool off period once session count
                                       // comes below the above limit
}

// DoSPolicer is aggregate DoS policer object
message DoSPolicer {
  uint32    bytes_per_second = 1;    // max. bytes per second
  uint32    peak_rate        = 2;    // in bytes-per-second
  uint32    burst_size       = 3;    // in bytes
}

// DoSFloodLimits object captures the flood limits configuration
message DoSFloodLimits {
  // default and only action in restrict phase is Random Early Drop (RED)
  message RestrictLimits {
    uint32    pps               = 1;    // packet-per-second limit
    uint32    burst_pps         = 2;    // packets-per-second burst
    uint32    duration          = 3;    // restrict action duration in seconds
  }
  // default and only action in protection phase is drop
  message ProtectLimits {
    uint32    pps               = 1;    // packet-per-second limit
    uint32    burst_pps         = 2;    // packets-per-second burst
    uint32    duration          = 3;    // protect action duration in seconds
  }
  RestrictLimits    restrict_limits = 1;
  ProtectLimits     protect_limits  = 2;
}

// DoSProtectionSpec defines DoS protection policy for a security group
message DoSProtectionSpec {
  DoSService          svc                  = 1;    // (optional) application
                                                   // service for which rest of
                                                   // the DoS config to be
                                                   // applied on
  uint32              session_setup_rate   = 2;    // 0 inidicates no limits
  DoSSessionLimits    session_limits       = 3;    // session limits config
  DoSPolicer          policer              = 4;    // DoS policer configuration
  DoSFloodLimits      tcp_syn_flood_limits = 5;    // TCP SYN flood limits
  DoSFloodLimits      udp_flood_limits     = 6;    // UDP flood limits
  DoSFloodLimits      icmp_flood_limits    = 7;    // ICMP flood limits
  DoSFloodLimits      other_flood_limits   = 8;    // flood limits for all other
                                                   // traffic (IP and non-IP)
  uint64              peer_sg_handle       = 9;    // TO security group handle
}

// ingress policy for DoS
message IngressDoSPolicy {
    DoSProtectionSpec dos_protection = 1;   //ingress (D)DoS protection policy
}

// egress policy for DoS
message EgressDoSPolicy {
    DoSProtectionSpec dos_protection = 1;  //egress (D)DoS Protection policy
}

// DoSPolicySpec that has the ingressDosPolicy and EgressDoSPolicy,
// Spec is identified by the handle. HAL will assign a unique handle for each
// DoSPolicy object and the clients are expected to pass the handle for
// Get/Modify/Delete calls. Note that there is no identifier for this object
message DoSPolicySpec {
   ObjectMeta           meta              = 1;    // object meta
   IngressDoSPolicy           ingress_policy    = 2;    // ingress policy
   EgressDoSPolicy            egress_policy     = 3;    // egress policy
   fixed64                    dos_handle        = 4;    // dos policy handle
   repeated uint64            sg_handle         = 5;    // list of security group handles
}

// DoS operational status
message DoSPolicyStatus {
  fixed64    dos_handle = 1;    // id of the dos returned by HAL
}

// DoSPolicyStats is the statistics object for a security group
message DoSPolicyStats {
}


// predefined apps - default apps for which ALG functionality is invoked
enum PredefinedApps {
  APP_NAME_NONE           = 0;
  APP_NAME_TFTP           = 1;  // TFTP ALG
  APP_NAME_FTP            = 2;  // FTP ALG
  APP_NAME_SUNRPC_TCP     = 3;  // SUNRPC ALG
  APP_NAME_MSRPC          = 4;  // MSRPC ALG
  APP_NAME_DNS            = 5;  // DNS ALG
  APP_NAME_SIP            = 6;  // SIP ALG
  APP_NAME_RTSP           = 7;  // RTSP ALG
  APP_NAME_TRACEROUTE     = 8;  // TRACEROUTE ALG
  APP_NAME_IP             = 9;  // IP ALG (uni-directional flow per session)
  APP_NAME_ANY            = 10; // "any" app
}

// App - represents an application defined by (Protocol, port) combination
// along with all applicable parameters
message App {
    message AppPortInfo {
        repeated L4PortRange    dst_port_range = 1; // dst port range low, high value
        repeated L4PortRange    src_port_range = 2; // src port range low, high value
    }
    message ICMPAppInfo {
        uint32    icmp_type        = 1;
        uint32    icmp_code        = 2;
    }
    message ICMPv6AppInfo {
        uint32    icmpv6_type      = 1;
        uint32    icmpv6_code      = 2;
    }
    message RPCAppInfo {
        uint32    program_number   = 1;
    }
    message MSRPCAppInfo {
        uint32    uuid            = 1;
    }

    enum TraceLevel {
        TRACE_LEVEL_NONE      = 0;
        TRACE_LEVEL_BRIEF     = 1;
        TRACE_LEVEL_DETAIL    = 2;
        TRACE_LEVEL_EXTENSIVE = 3;
        TRACE_LEVEL_VERBOSE   = 4;
    }
    message TraceOptions {
        TraceLevel    level = 1;
    }

    IPProtocol    protocol        = 1;
    oneof L4AppInfo {
        AppPortInfo   port_info         = 2;
        ICMPAppInfo   icmp_info         = 3;
        ICMPv6AppInfo icmpv6_info       = 4;
        RPCAppInfo    rpc_info          = 5;
        MSRPCAppInfo  msrpc_cinfo       = 6;
    }
    PredefinedApps    alg               = 7;

    message FTPOptions {
        bool allow_mismatch_ip_address  = 1; // pass FTP packets with mismatched IP header address and payload
    }
    message DNSOptions {
        bool      drop_multi_question_packets       = 1; // drop pkt if number of questions > 1
        bool      drop_large_domain_name_packets    = 2; // drop if domain name size is > 255 bytes
        uint32    drop_long_label_packets           = 3; // drop if label length > 63
        uint32    drop_multizone_packets            = 4; // (DDNS) drop if number of zones > 1
        uint32    max_msg_length                    = 5; // default 512 (max. 8192) bytes
    }
    message MSRPCOptions {
        uint32 map_entry_timeout             = 1;
    }
    message SunRPCOptions {
        uint32 map_entry_timeout             = 1;
    }
    message SIPOptions {
        uint32 ctimeout                      = 1;
        uint32 dscp_code_point               = 2;
        uint32 media_inactivity_timeout      = 3;
        uint32 max_call_duration             = 4;
        uint32 t1_timer_value                = 5;
        uint32 t4_timer_value                = 6;
    }
    oneof AppOptions {
        FTPOptions    ftp_option_info        = 8;
        DNSOptions    dns_option_info        = 9;
        MSRPCOptions  msrp_coption_info      = 10;
        SunRPCOptions sun_rpc_pption_info    = 11;
        SIPOptions    sip_options            = 12;
    }
    uint32            idle_timeout           = 13;
    TraceOptions      trace_opts             = 14;
}

// ApplicationSpec is either a pre-defined pensando application or user-defined
// custom application
message ApplicationSpec {
    oneof apps {
        PredefinedApps    predefined_apps        = 1; //  Predefined apps
        App               application            = 2;
    }
}

message ApplicationStatus {
}

message Application {
    ObjectMeta     meta   = 1;
    ApplicationSpec      spec   = 2;
    ApplicationStatus    status = 3;
}

// group of applications to apply same policy on
message AppGroupSpec {
    repeated Application Apps = 2;
}

message AppGroupStatus {
}

message AppGroup {
    ObjectMeta    meta      = 1;
    AppGroupSpec        spec      = 2;
    AppGroupStatus      status    = 3;
}

// AppSec represents an application
enum SecurityAction {
    SECURITY_RULE_ACTION_NONE   = 0;
    SECURITY_RULE_ACTION_ALLOW  = 1;
    SECURITY_RULE_ACTION_DENY   = 2;
    SECURITY_RULE_ACTION_REJECT = 3;
}

enum LogAction {
    LOG_NONE                     = 0;
    LOG_ON_SESSION_START         = 1;
    LOG_ON_SESSION_END           = 2;
    LOG_ON_SESSION_START_AND_END = 3;
}

message SecurityRuleAction {
    SecurityAction  sec_action = 1;  // Identifies the security action related to the rule
    LogAction       log_action = 2;  // Identifies log actions related to the rule
}

message SecurityRuleSpec {
    uint64                          rule_id            = 1;
    bool                            enable             = 2;        // enable/disable
    SecurityRuleAction              action             = 3;        // action related to the rule
    bool                            count              = 4;        // Enable count of packets hitting the rule
    repeated Application            app                = 5;        // applications, if any, to invoke ALG
    repeated AppGroup               app_group          = 6;        // Comment TBD
    repeated IPAddressObj     src_address        = 7;        // source address(es)
    repeated uint32                 src_sg             = 8;       // source security group
    repeated IPAddressObj     dst_address        = 9;       // destination address(es)
    repeated uint32                 dst_sg             = 10;       // destination security group
    repeated L4PortRange      dst_port_range     = 11;       // dst port
    repeated L4PortRange      src_port_range     = 12;       // src port range

    bool                            conn_track_en      = 13;       // Enable connection tracking
}

// SecurityPolicySpec that contains set of SecurityRules
message SecurityPolicySpec {
    option (delphi.update_event) = true;
    delphi.ObjectMeta              Meta              = 1;
    SecurityPolicyKeyHandle        Key               = 2;

    repeated SecurityRuleSpec     rule               = 3;      // List of security rules
}

message SecurityPolicyStatus {
    option (delphi.update_event) = true;
    delphi.ObjectMeta              Meta              = 1;
    SecurityPolicyKeyHandle        Key               = 2;
    fixed64                  security_policy_handle  = 3; // id of the security policy returned by HAL
}


// SecurityPolicyStats - place holder
message SecurityPolicyStats {
}
