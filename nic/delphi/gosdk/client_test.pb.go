// Code generated by protoc-gen-go. DO NOT EDIT.
// source: client_test.proto

/*
Package gosdk is a generated protocol buffer package.

It is generated from these files:
	client_test.proto

It has these top-level messages:
	IntfIndex_
	InterfaceSpec_
*/
package gosdk

import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Interface id
type IntfIndex_ struct {
	Ifidx uint32 `protobuf:"varint,1,opt,name=Ifidx" json:"Ifidx,omitempty"`
}

func (m *IntfIndex_) Reset()                    { *m = IntfIndex_{} }
func (m *IntfIndex_) String() string            { return proto.CompactTextString(m) }
func (*IntfIndex_) ProtoMessage()               {}
func (*IntfIndex_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IntfIndex_) GetIfidx() uint32 {
	if m != nil {
		return m.Ifidx
	}
	return 0
}

// spec part of the object
type InterfaceSpec_ struct {
	Meta       *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key        *IntfIndex_        `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	MacAddress string             `protobuf:"bytes,3,opt,name=MacAddress" json:"MacAddress,omitempty"`
}

func (m *InterfaceSpec_) Reset()                    { *m = InterfaceSpec_{} }
func (m *InterfaceSpec_) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec_) ProtoMessage()               {}
func (*InterfaceSpec_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *InterfaceSpec_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *InterfaceSpec_) GetKey() *IntfIndex_ {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *InterfaceSpec_) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

type delphiWrapper interface {
	bubbleSave()
}

type InterfaceSpec struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	meta       *delphi.ObjectMeta
	key        *IntfIndex
	macAddress string
}

func (o *InterfaceSpec) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *InterfaceSpec) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *InterfaceSpec) GetKey() *IntfIndex {
	return o.key
}

func (o *InterfaceSpec) GetMacAddress() string {
	return o.macAddress
}

func (o *InterfaceSpec) SetMacAddress(val string) {
	o.macAddress = val
	o.bubbleSave()
}

func (o *InterfaceSpec) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *InterfaceSpec) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *InterfaceSpec) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewInterfaceSpec(sdkClient clientApi.Client) *InterfaceSpec {
	w := &InterfaceSpec{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "InterfaceSpec",
	}
	w.key = childNewIntfIndex(w, sdkClient)
	return w
}

func NewInterfaceSpecWithKey(sdkClient clientApi.Client, key *IntfIndex) *InterfaceSpec {
	w := NewInterfaceSpec(sdkClient)
	w.key = childNewIntfIndexWithValue(w, sdkClient, key)
	return w
}

func GetInterfaceSpec(sdkClient clientApi.Client, key *IntfIndex) *InterfaceSpec {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("InterfaceSpec", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*InterfaceSpec)
	if !ok {
		panic("Couldn't cast to InterfaceSpec")
	}
	return o
}

func childNewInterfaceSpec(parent delphiWrapper, sdkClient clientApi.Client) *InterfaceSpec {
	w := NewInterfaceSpec(sdkClient)
	w.parent = parent
	return w
}

func childNewInterfaceSpecWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *InterfaceSpec) *InterfaceSpec {
	w := childNewInterfaceSpec(parent, sdkClient)
	w.key = childNewIntfIndexWithValue(w, sdkClient, value.key)
	w.macAddress = value.macAddress
	return w
}

func (o *InterfaceSpec) GetProtoMsg() *InterfaceSpec_ {
	return &InterfaceSpec_{
		Meta:       o.meta,
		Key:        o.key.GetProtoMsg(),
		MacAddress: o.macAddress,
	}
}

func (o *InterfaceSpec) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *InterfaceSpec) GetKeyString() string {
	return obj.key.GetProtoMsg().String()
}

func (obj *InterfaceSpec) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(InterfaceSpecReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnInterfaceSpecCreate(obj)
			} else {
				rctr.OnInterfaceSpecUpdate(obj)
			}
		} else {
			rctr.OnInterfaceSpecDelete(obj)
		}
	}
}

type InterfaceSpecReactor interface {
	OnInterfaceSpecCreate(obj *InterfaceSpec)
	OnInterfaceSpecUpdate(obj *InterfaceSpec)
	OnInterfaceSpecDelete(obj *InterfaceSpec)
}

func (obj *InterfaceSpec) GetPath() string {
	return "InterfaceSpec" + "|" + obj.GetKeyString()
}

func newInterfaceSpecFromMessage(msg *InterfaceSpec_) *InterfaceSpec {
	return &InterfaceSpec{
		meta:       msg.Meta,
		key:        newIntfIndexFromMessage(msg.Key),
		macAddress: msg.MacAddress,
	}
}

func interfaceSpecFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg InterfaceSpec_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newInterfaceSpecFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func InterfaceSpecMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("InterfaceSpec", mode)
}

func InterfaceSpecMountKey(client clientApi.Client, key *IntfIndex, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("InterfaceSpec", keyString, mode)
}

func InterfaceSpecWatch(client clientApi.Client, reactor InterfaceSpecReactor) {
	client.WatchKind("InterfaceSpec", reactor)
}

type InterfaceSpecIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *InterfaceSpecIterator) Next() *InterfaceSpec {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*InterfaceSpec)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func InterfaceSpecList(client clientApi.Client) *InterfaceSpecIterator {
	return &InterfaceSpecIterator{
		objects: client.List("InterfaceSpec"),
		cur:     0,
	}
}

type IntfIndex struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	ifidx     uint32
}

func (o *IntfIndex) GetIfidx() uint32 {
	return o.ifidx
}

func (o *IntfIndex) SetIfidx(val uint32) {
	o.ifidx = val
	o.bubbleSave()
}

func (o *IntfIndex) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *IntfIndex) save() {
}

func NewIntfIndex(sdkClient clientApi.Client) *IntfIndex {
	w := &IntfIndex{}
	w.sdkClient = sdkClient
	return w
}

func childNewIntfIndex(parent delphiWrapper, sdkClient clientApi.Client) *IntfIndex {
	w := NewIntfIndex(sdkClient)
	w.parent = parent
	return w
}

func childNewIntfIndexWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *IntfIndex) *IntfIndex {
	w := childNewIntfIndex(parent, sdkClient)
	w.ifidx = value.ifidx
	return w
}

func (o *IntfIndex) GetProtoMsg() *IntfIndex_ {
	return &IntfIndex_{
		Ifidx: o.ifidx,
	}
}

func (o *IntfIndex) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newIntfIndexFromMessage(msg *IntfIndex_) *IntfIndex {
	return &IntfIndex{
		ifidx: msg.Ifidx,
	}
}

func init() {
	proto.RegisterType((*IntfIndex_)(nil), "gosdk.IntfIndex_")
	proto.RegisterType((*InterfaceSpec_)(nil), "gosdk.InterfaceSpec_")
	clientApi.RegisterFactory("InterfaceSpec", interfaceSpecFactory)
}

func init() { proto.RegisterFile("client_test.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 204 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4c, 0xce, 0xc9, 0x4c,
	0xcd, 0x2b, 0x89, 0x2f, 0x49, 0x2d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x4d,
	0xcf, 0x2f, 0x4e, 0xc9, 0x96, 0x52, 0xc9, 0xcb, 0x4c, 0xd6, 0x4f, 0x49, 0xcd, 0x29, 0xc8, 0xc8,
	0xd4, 0x07, 0x4b, 0xc0, 0x38, 0x10, 0x0a, 0xa2, 0x58, 0x49, 0x89, 0x8b, 0xcb, 0x33, 0xaf, 0x24,
	0xcd, 0x33, 0x2f, 0x25, 0xb5, 0x22, 0x5e, 0x48, 0x84, 0x8b, 0xd5, 0x33, 0x2d, 0x33, 0xa5, 0x42,
	0x82, 0x51, 0x81, 0x51, 0x83, 0x37, 0x08, 0xc2, 0x51, 0x6a, 0x66, 0xe4, 0xe2, 0xf3, 0xcc, 0x2b,
	0x49, 0x2d, 0x4a, 0x4b, 0x4c, 0x4e, 0x0d, 0x2e, 0x48, 0x4d, 0x8e, 0x17, 0x52, 0xe3, 0x62, 0xf1,
	0x4d, 0x2d, 0x49, 0x04, 0xab, 0xe3, 0x36, 0x12, 0xd2, 0x83, 0x9a, 0xe9, 0x9f, 0x94, 0x95, 0x9a,
	0x5c, 0x02, 0x92, 0x09, 0x02, 0xcb, 0x0b, 0x29, 0x73, 0x31, 0x7b, 0xa7, 0x56, 0x4a, 0x30, 0x81,
	0x95, 0x09, 0xea, 0x81, 0x5d, 0xa6, 0x87, 0xb0, 0x30, 0x08, 0x24, 0x2b, 0x24, 0xc7, 0xc5, 0xe5,
	0x9b, 0x98, 0xec, 0x98, 0x92, 0x52, 0x94, 0x5a, 0x5c, 0x2c, 0xc1, 0xac, 0xc0, 0xa8, 0xc1, 0x19,
	0x84, 0x24, 0x62, 0xc5, 0xd2, 0x30, 0x5d, 0x89, 0x31, 0x89, 0x0d, 0xec, 0x60, 0x63, 0x40, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x50, 0xa9, 0x7a, 0x14, 0xf2, 0x00, 0x00, 0x00,
}
