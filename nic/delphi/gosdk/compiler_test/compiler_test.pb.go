// Code generated by protoc-gen-go. DO NOT EDIT.
// source: compiler_test.proto

/*
Package compilertest is a generated protocol buffer package.

It is generated from these files:
	compiler_test.proto

It has these top-level messages:
	MessageA_
	MessageKey_
	MessageB_
	MessageC_
*/
package compilertest

import gosdk "github.com/pensando/sw/nic/delphi/gosdk"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Simplest possible message
type MessageA_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	StringValue string             `protobuf:"bytes,3,opt,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageA_) Reset()                    { *m = MessageA_{} }
func (m *MessageA_) String() string            { return proto.CompactTextString(m) }
func (*MessageA_) ProtoMessage()               {}
func (*MessageA_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MessageA_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageA_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *MessageA_) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

// Message with key being a message
type MessageKey_ struct {
	Value uint32 `protobuf:"varint,1,opt,name=Value" json:"Value,omitempty"`
}

func (m *MessageKey_) Reset()                    { *m = MessageKey_{} }
func (m *MessageKey_) String() string            { return proto.CompactTextString(m) }
func (*MessageKey_) ProtoMessage()               {}
func (*MessageKey_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MessageKey_) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type MessageB_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         *MessageKey_       `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	StringValue string             `protobuf:"bytes,3,opt,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageB_) Reset()                    { *m = MessageB_{} }
func (m *MessageB_) String() string            { return proto.CompactTextString(m) }
func (*MessageB_) ProtoMessage()               {}
func (*MessageB_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MessageB_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageB_) GetKey() *MessageKey_ {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MessageB_) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

// Message with an array field
type MessageC_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	StringValue []string           `protobuf:"bytes,3,rep,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageC_) Reset()                    { *m = MessageC_{} }
func (m *MessageC_) String() string            { return proto.CompactTextString(m) }
func (*MessageC_) ProtoMessage()               {}
func (*MessageC_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MessageC_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageC_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *MessageC_) GetStringValue() []string {
	if m != nil {
		return m.StringValue
	}
	return nil
}

type delphiWrapper interface {
	bubbleSave()
}

type MessageKey struct {
	sdkClient gosdk.Client
	parent    delphiWrapper
	value     uint32
}

func (o *MessageKey) GetValue() uint32 {
	return o.value
}

func (o *MessageKey) SetValue(val uint32) {
	o.value = val
	o.bubbleSave()
}

func (o *MessageKey) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageKey) save() {
}

func NewMessageKey(sdkClient gosdk.Client) *MessageKey {
	w := &MessageKey{}
	w.sdkClient = sdkClient
	return w
}

func childNewMessageKey(parent delphiWrapper, sdkClient gosdk.Client) *MessageKey {
	w := NewMessageKey(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageKeyWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *MessageKey) *MessageKey {
	w := childNewMessageKey(parent, sdkClient)
	w.value = value.value
	return w
}

func (o *MessageKey) GetProtoMsg() *MessageKey_ {
	return &MessageKey_{
		Value: o.value,
	}
}

func (o *MessageKey) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newMessageKeyFromMessage(msg *MessageKey_) *MessageKey {
	return &MessageKey{
		value: msg.Value,
	}
}

type MessageB struct {
	sdkClient   gosdk.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         *MessageKey
	stringValue string
}

func (o *MessageB) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageB) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageB) GetKey() *MessageKey {
	return o.key
}

func (o *MessageB) GetStringValue() string {
	return o.stringValue
}

func (o *MessageB) SetStringValue(val string) {
	o.stringValue = val
	o.bubbleSave()
}

func (o *MessageB) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageB) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageB) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageB(sdkClient gosdk.Client) *MessageB {
	w := &MessageB{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageB",
	}
	w.key = childNewMessageKey(w, sdkClient)
	return w
}

func NewMessageBWithKey(sdkClient gosdk.Client, key *MessageKey) *MessageB {
	w := NewMessageB(sdkClient)
	w.key = childNewMessageKeyWithValue(w, sdkClient, key)
	return w
}

func GetMessageB(sdkClient gosdk.Client, key *MessageKey) *MessageB {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("MessageB", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageB)
	if !ok {
		panic("Couldn't cast to MessageB")
	}
	return o
}

func childNewMessageB(parent delphiWrapper, sdkClient gosdk.Client) *MessageB {
	w := NewMessageB(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageBWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *MessageB) *MessageB {
	w := childNewMessageB(parent, sdkClient)
	w.key = childNewMessageKeyWithValue(w, sdkClient, value.key)
	w.stringValue = value.stringValue
	return w
}

func (o *MessageB) GetProtoMsg() *MessageB_ {
	return &MessageB_{
		Meta:        o.meta,
		Key:         o.key.GetProtoMsg(),
		StringValue: o.stringValue,
	}
}

func (o *MessageB) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageB) GetKeyString() string {
	return obj.key.GetProtoMsg().String()
}

func (obj *MessageB) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageBReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageBCreate(obj)
			} else {
				rctr.OnMessageBUpdate(obj)
			}
		} else {
			rctr.OnMessageBDelete(obj)
		}
	}
}

type MessageBReactor interface {
	OnMessageBCreate(obj *MessageB)
	OnMessageBUpdate(obj *MessageB)
	OnMessageBDelete(obj *MessageB)
}

func (obj *MessageB) GetPath() string {
	return "MessageB" + "|" + obj.GetKeyString()
}

func newMessageBFromMessage(msg *MessageB_) *MessageB {
	return &MessageB{
		meta:        msg.Meta,
		key:         newMessageKeyFromMessage(msg.Key),
		stringValue: msg.StringValue,
	}
}

func messageBFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg MessageB_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageBFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageBMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("MessageB", mode)
}

func MessageBWatch(client gosdk.Client, reactor MessageBReactor) {
	client.WatchKind("MessageB", reactor)
}

type MessageC struct {
	sdkClient   gosdk.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	stringValue *StringArray
}

func (o *MessageC) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageC) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageC) GetKey() uint32 {
	return o.key
}

func (o *MessageC) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *MessageC) GetStringValue() *StringArray {
	return o.stringValue
}

func (o *MessageC) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageC) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageC) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageC(sdkClient gosdk.Client) *MessageC {
	w := &MessageC{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageC",
	}
	w.stringValue = childNewStringArray(w, sdkClient)
	return w
}

func NewMessageCWithKey(sdkClient gosdk.Client, key uint32) *MessageC {
	w := NewMessageC(sdkClient)
	w.SetKey(key)
	return w
}

func GetMessageC(sdkClient gosdk.Client, key uint32) *MessageC {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("MessageC", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageC)
	if !ok {
		panic("Couldn't cast to MessageC")
	}
	return o
}

func childNewMessageC(parent delphiWrapper, sdkClient gosdk.Client) *MessageC {
	w := NewMessageC(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageCWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *MessageC) *MessageC {
	w := childNewMessageC(parent, sdkClient)
	w.key = value.key
	w.stringValue = childNewStringArrayWithValue(w, sdkClient, value.stringValue)
	return w
}

func (o *MessageC) GetProtoMsg() *MessageC_ {
	return &MessageC_{
		Meta:        o.meta,
		Key:         o.key,
		StringValue: o.stringValue.GetProtoMsg(),
	}
}

func (o *MessageC) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageC) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *MessageC) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageCReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageCCreate(obj)
			} else {
				rctr.OnMessageCUpdate(obj)
			}
		} else {
			rctr.OnMessageCDelete(obj)
		}
	}
}

type MessageCReactor interface {
	OnMessageCCreate(obj *MessageC)
	OnMessageCUpdate(obj *MessageC)
	OnMessageCDelete(obj *MessageC)
}

func (obj *MessageC) GetPath() string {
	return "MessageC" + "|" + obj.GetKeyString()
}

func newMessageCFromMessage(msg *MessageC_) *MessageC {
	return &MessageC{
		meta:        msg.Meta,
		key:         msg.Key,
		stringValue: newStringArrayFromMessage(msg.StringValue),
	}
}

func messageCFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg MessageC_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageCFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageCMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("MessageC", mode)
}

func MessageCWatch(client gosdk.Client, reactor MessageCReactor) {
	client.WatchKind("MessageC", reactor)
}

type MessageA struct {
	sdkClient   gosdk.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	stringValue string
}

func (o *MessageA) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageA) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageA) GetKey() uint32 {
	return o.key
}

func (o *MessageA) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *MessageA) GetStringValue() string {
	return o.stringValue
}

func (o *MessageA) SetStringValue(val string) {
	o.stringValue = val
	o.bubbleSave()
}

func (o *MessageA) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageA) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageA) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageA(sdkClient gosdk.Client) *MessageA {
	w := &MessageA{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageA",
	}
	return w
}

func NewMessageAWithKey(sdkClient gosdk.Client, key uint32) *MessageA {
	w := NewMessageA(sdkClient)
	w.SetKey(key)
	return w
}

func GetMessageA(sdkClient gosdk.Client, key uint32) *MessageA {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("MessageA", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageA)
	if !ok {
		panic("Couldn't cast to MessageA")
	}
	return o
}

func childNewMessageA(parent delphiWrapper, sdkClient gosdk.Client) *MessageA {
	w := NewMessageA(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageAWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *MessageA) *MessageA {
	w := childNewMessageA(parent, sdkClient)
	w.key = value.key
	w.stringValue = value.stringValue
	return w
}

func (o *MessageA) GetProtoMsg() *MessageA_ {
	return &MessageA_{
		Meta:        o.meta,
		Key:         o.key,
		StringValue: o.stringValue,
	}
}

func (o *MessageA) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageA) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *MessageA) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageAReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageACreate(obj)
			} else {
				rctr.OnMessageAUpdate(obj)
			}
		} else {
			rctr.OnMessageADelete(obj)
		}
	}
}

type MessageAReactor interface {
	OnMessageACreate(obj *MessageA)
	OnMessageAUpdate(obj *MessageA)
	OnMessageADelete(obj *MessageA)
}

func (obj *MessageA) GetPath() string {
	return "MessageA" + "|" + obj.GetKeyString()
}

func newMessageAFromMessage(msg *MessageA_) *MessageA {
	return &MessageA{
		meta:        msg.Meta,
		key:         msg.Key,
		stringValue: msg.StringValue,
	}
}

func messageAFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg MessageA_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageAFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageAMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("MessageA", mode)
}

func MessageAWatch(client gosdk.Client, reactor MessageAReactor) {
	client.WatchKind("MessageA", reactor)
}

type StringArray struct {
	parent delphiWrapper
	values []string
}

func (arr *StringArray) Append(value string) {
	arr.values = append(arr.values, value)
	arr.parent.bubbleSave()
}

func (arr *StringArray) Get(pos int) string {
	return arr.values[pos]
}

func (arr *StringArray) Length() int {
	return len(arr.values)
}

func newStringArrayFromMessage(msg []string) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, len(msg))
	copy(arr.values, msg)
	return arr
}

func childNewStringArray(parent delphiWrapper, sdkClient gosdk.Client) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, 0)
	arr.parent = parent
	return arr
}

func childNewStringArrayWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *StringArray) *StringArray {
	arr := childNewStringArray(parent, sdkClient)
	for _, v := range value.values {
		arr.values = append(arr.values, v)
	}
	return arr
}

func (arr *StringArray) GetProtoMsg() []string {
	v := make([]string, len(arr.values))
	copy(v, arr.values)
	return v
}

func init() {
	proto.RegisterType((*MessageA_)(nil), "compilertest.MessageA_")
	proto.RegisterType((*MessageKey_)(nil), "compilertest.MessageKey_")
	proto.RegisterType((*MessageB_)(nil), "compilertest.MessageB_")
	proto.RegisterType((*MessageC_)(nil), "compilertest.MessageC_")
	gosdk.RegisterFactory("MessageB", messageBFactory)
	gosdk.RegisterFactory("MessageC", messageCFactory)
	gosdk.RegisterFactory("MessageA", messageAFactory)
}

func init() { proto.RegisterFile("compiler_test.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 214 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4e, 0xce, 0xcf, 0x2d,
	0xc8, 0xcc, 0x49, 0x2d, 0x8a, 0x2f, 0x49, 0x2d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
	0xe2, 0x81, 0x09, 0x82, 0xc4, 0xa4, 0x54, 0xf2, 0x32, 0x93, 0xf5, 0x53, 0x52, 0x73, 0x0a, 0x32,
	0x32, 0xf5, 0xc1, 0xf2, 0x30, 0x0e, 0x84, 0x82, 0xe8, 0x51, 0x4a, 0xe7, 0xe2, 0xf4, 0x4d, 0x2d,
	0x2e, 0x4e, 0x4c, 0x4f, 0x75, 0x8c, 0x17, 0x52, 0xe3, 0x62, 0xf1, 0x4d, 0x2d, 0x49, 0x94, 0x60,
	0x54, 0x60, 0xd4, 0xe0, 0x36, 0x12, 0xd2, 0x83, 0xaa, 0xf4, 0x4f, 0xca, 0x4a, 0x4d, 0x2e, 0x01,
	0xc9, 0x04, 0x81, 0xe5, 0x85, 0x04, 0xb8, 0x98, 0xbd, 0x53, 0x2b, 0x25, 0x98, 0x14, 0x18, 0x35,
	0x78, 0x83, 0x40, 0x4c, 0x21, 0x05, 0x2e, 0xee, 0xe0, 0x92, 0xa2, 0xcc, 0xbc, 0xf4, 0xb0, 0xc4,
	0x9c, 0xd2, 0x54, 0x09, 0x66, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x64, 0x21, 0x25, 0x65, 0x2e, 0x6e,
	0xa8, 0x45, 0xde, 0xa9, 0x95, 0xf1, 0x42, 0x22, 0x5c, 0xac, 0x10, 0xa5, 0x8c, 0x60, 0x43, 0x20,
	0x1c, 0xa5, 0x26, 0x46, 0xb8, 0x73, 0x9c, 0x88, 0x77, 0x8e, 0x36, 0xc2, 0x39, 0xdc, 0x46, 0x92,
	0x7a, 0xc8, 0xa1, 0xa0, 0x87, 0x64, 0x27, 0xb1, 0x2e, 0x45, 0x04, 0x89, 0x33, 0x55, 0x83, 0x84,
	0x19, 0xcd, 0xa2, 0x24, 0x36, 0x70, 0x14, 0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x0e,
	0x25, 0x60, 0xcd, 0x01, 0x00, 0x00,
}
