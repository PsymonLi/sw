// Code generated by protoc-gen-go. DO NOT EDIT.
// source: compiler_test.proto

/*
Package compilertest is a generated protocol buffer package.

It is generated from these files:
	compiler_test.proto

It has these top-level messages:
	MessageA_
	MessageKey_
	MessageB_
	MessageC_
	MessageD_
*/
package compilertest

import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Simplest possible message
type MessageA_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	StringValue string             `protobuf:"bytes,3,opt,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageA_) Reset()                    { *m = MessageA_{} }
func (m *MessageA_) String() string            { return proto.CompactTextString(m) }
func (*MessageA_) ProtoMessage()               {}
func (*MessageA_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MessageA_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageA_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *MessageA_) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

// Message with key being a message
type MessageKey_ struct {
	Value uint32 `protobuf:"varint,1,opt,name=Value" json:"Value,omitempty"`
}

func (m *MessageKey_) Reset()                    { *m = MessageKey_{} }
func (m *MessageKey_) String() string            { return proto.CompactTextString(m) }
func (*MessageKey_) ProtoMessage()               {}
func (*MessageKey_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MessageKey_) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type MessageB_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         *MessageKey_       `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	StringValue string             `protobuf:"bytes,3,opt,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageB_) Reset()                    { *m = MessageB_{} }
func (m *MessageB_) String() string            { return proto.CompactTextString(m) }
func (*MessageB_) ProtoMessage()               {}
func (*MessageB_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MessageB_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageB_) GetKey() *MessageKey_ {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MessageB_) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

// Message with an array field
type MessageC_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	StringValue []string           `protobuf:"bytes,3,rep,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageC_) Reset()                    { *m = MessageC_{} }
func (m *MessageC_) String() string            { return proto.CompactTextString(m) }
func (*MessageC_) ProtoMessage()               {}
func (*MessageC_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MessageC_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageC_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *MessageC_) GetStringValue() []string {
	if m != nil {
		return m.StringValue
	}
	return nil
}

// Singleton message
type MessageD_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	StringValue string             `protobuf:"bytes,3,opt,name=StringValue" json:"StringValue,omitempty"`
}

func (m *MessageD_) Reset()                    { *m = MessageD_{} }
func (m *MessageD_) String() string            { return proto.CompactTextString(m) }
func (*MessageD_) ProtoMessage()               {}
func (*MessageD_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MessageD_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MessageD_) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

type delphiWrapper interface {
	bubbleSave()
}

type MessageB struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         *MessageKey
	stringValue string
}

func (o *MessageB) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageB) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageB) GetKey() *MessageKey {
	return o.key
}

func (o *MessageB) GetStringValue() string {
	return o.stringValue
}

func (o *MessageB) SetStringValue(val string) {
	o.stringValue = val
	o.bubbleSave()
}

func (o *MessageB) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageB) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageB) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageB(sdkClient clientApi.Client) *MessageB {
	w := &MessageB{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageB",
	}
	w.key = childNewMessageKey(w, sdkClient)
	return w
}

func NewMessageBWithKey(sdkClient clientApi.Client, key *MessageKey) *MessageB {
	w := NewMessageB(sdkClient)
	w.key = childNewMessageKeyWithValue(w, sdkClient, key)
	return w
}

func GetMessageB(sdkClient clientApi.Client, key *MessageKey) *MessageB {
	lookupKey := key.GetProtoMsg().String()
	b := sdkClient.GetObject("MessageB", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageB)
	if !ok {
		panic("Couldn't cast to MessageB")
	}
	return o
}

func childNewMessageB(parent delphiWrapper, sdkClient clientApi.Client) *MessageB {
	w := NewMessageB(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageBWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *MessageB) *MessageB {
	w := childNewMessageB(parent, sdkClient)
	w.key = childNewMessageKeyWithValue(w, sdkClient, value.key)
	w.stringValue = value.stringValue
	return w
}

func (o *MessageB) GetProtoMsg() *MessageB_ {
	return &MessageB_{
		Meta:        o.meta,
		Key:         o.key.GetProtoMsg(),
		StringValue: o.stringValue,
	}
}

func (o *MessageB) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageB) GetKeyString() string {
	return obj.key.GetProtoMsg().String()
}

func (obj *MessageB) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageBReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageBCreate(obj)
			} else {
				rctr.OnMessageBUpdate(obj)
			}
		} else {
			rctr.OnMessageBDelete(obj)
		}
	}
}

type MessageBReactor interface {
	OnMessageBCreate(obj *MessageB)
	OnMessageBUpdate(obj *MessageB)
	OnMessageBDelete(obj *MessageB)
}

func (obj *MessageB) GetPath() string {
	return "MessageB" + "|" + obj.GetKeyString()
}

func newMessageBFromMessage(msg *MessageB_) *MessageB {
	return &MessageB{
		meta:        msg.Meta,
		key:         newMessageKeyFromMessage(msg.Key),
		stringValue: msg.StringValue,
	}
}

func messageBFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg MessageB_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageBFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageBMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("MessageB", mode)
}

func MessageBMountKey(client clientApi.Client, key *MessageKey, mode delphi.MountMode) {
	keyString := key.GetProtoMsg().String()
	client.MountKindKey("MessageB", keyString, mode)
}

func MessageBWatch(client clientApi.Client, reactor MessageBReactor) {
	client.WatchKind("MessageB", reactor)
}

type MessageBIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *MessageBIterator) Next() *MessageB {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*MessageB)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func MessageBList(client clientApi.Client) *MessageBIterator {
	return &MessageBIterator{
		objects: client.List("MessageB"),
		cur:     0,
	}
}

type MessageC struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	stringValue *StringArray
}

func (o *MessageC) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageC) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageC) GetKey() uint32 {
	return o.key
}

func (o *MessageC) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *MessageC) GetStringValue() *StringArray {
	return o.stringValue
}

func (o *MessageC) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageC) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageC) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageC(sdkClient clientApi.Client) *MessageC {
	w := &MessageC{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageC",
	}
	w.stringValue = childNewStringArray(w, sdkClient)
	return w
}

func NewMessageCWithKey(sdkClient clientApi.Client, key uint32) *MessageC {
	w := NewMessageC(sdkClient)
	w.SetKey(key)
	return w
}

func GetMessageC(sdkClient clientApi.Client, key uint32) *MessageC {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("MessageC", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageC)
	if !ok {
		panic("Couldn't cast to MessageC")
	}
	return o
}

func childNewMessageC(parent delphiWrapper, sdkClient clientApi.Client) *MessageC {
	w := NewMessageC(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageCWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *MessageC) *MessageC {
	w := childNewMessageC(parent, sdkClient)
	w.key = value.key
	w.stringValue = childNewStringArrayWithValue(w, sdkClient, value.stringValue)
	return w
}

func (o *MessageC) GetProtoMsg() *MessageC_ {
	return &MessageC_{
		Meta:        o.meta,
		Key:         o.key,
		StringValue: o.stringValue.GetProtoMsg(),
	}
}

func (o *MessageC) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageC) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *MessageC) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageCReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageCCreate(obj)
			} else {
				rctr.OnMessageCUpdate(obj)
			}
		} else {
			rctr.OnMessageCDelete(obj)
		}
	}
}

type MessageCReactor interface {
	OnMessageCCreate(obj *MessageC)
	OnMessageCUpdate(obj *MessageC)
	OnMessageCDelete(obj *MessageC)
}

func (obj *MessageC) GetPath() string {
	return "MessageC" + "|" + obj.GetKeyString()
}

func newMessageCFromMessage(msg *MessageC_) *MessageC {
	return &MessageC{
		meta:        msg.Meta,
		key:         msg.Key,
		stringValue: newStringArrayFromMessage(msg.StringValue),
	}
}

func messageCFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg MessageC_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageCFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageCMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("MessageC", mode)
}

func MessageCMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("MessageC", keyString, mode)
}

func MessageCWatch(client clientApi.Client, reactor MessageCReactor) {
	client.WatchKind("MessageC", reactor)
}

type MessageCIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *MessageCIterator) Next() *MessageC {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*MessageC)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func MessageCList(client clientApi.Client) *MessageCIterator {
	return &MessageCIterator{
		objects: client.List("MessageC"),
		cur:     0,
	}
}

type MessageD struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	stringValue string
}

func (o *MessageD) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageD) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageD) GetStringValue() string {
	return o.stringValue
}

func (o *MessageD) SetStringValue(val string) {
	o.stringValue = val
	o.bubbleSave()
}

func (o *MessageD) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageD) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageD) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageD(sdkClient clientApi.Client) *MessageD {
	w := &MessageD{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageD",
	}
	return w
}

func GetMessageD(sdkClient clientApi.Client) *MessageD {
	b := sdkClient.GetObject("MessageD", "default")
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageD)
	if !ok {
		panic("Couldn't cast to MessageD")
	}
	return o
}

func childNewMessageD(parent delphiWrapper, sdkClient clientApi.Client) *MessageD {
	w := NewMessageD(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageDWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *MessageD) *MessageD {
	w := childNewMessageD(parent, sdkClient)
	w.stringValue = value.stringValue
	return w
}

func (o *MessageD) GetProtoMsg() *MessageD_ {
	return &MessageD_{
		Meta:        o.meta,
		StringValue: o.stringValue,
	}
}

func (o *MessageD) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageD) GetKeyString() string {
	return "default"
}

func (obj *MessageD) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageDReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageDCreate(obj)
			} else {
				rctr.OnMessageDUpdate(obj)
			}
		} else {
			rctr.OnMessageDDelete(obj)
		}
	}
}

type MessageDReactor interface {
	OnMessageDCreate(obj *MessageD)
	OnMessageDUpdate(obj *MessageD)
	OnMessageDDelete(obj *MessageD)
}

func (obj *MessageD) GetPath() string {
	return "MessageD" + "|" + obj.GetKeyString()
}

func newMessageDFromMessage(msg *MessageD_) *MessageD {
	return &MessageD{
		meta:        msg.Meta,
		stringValue: msg.StringValue,
	}
}

func messageDFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg MessageD_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageDFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageDMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("MessageD", mode)
}

func MessageDWatch(client clientApi.Client, reactor MessageDReactor) {
	client.WatchKind("MessageD", reactor)
}

type MessageDIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *MessageDIterator) Next() *MessageD {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*MessageD)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func MessageDList(client clientApi.Client) *MessageDIterator {
	return &MessageDIterator{
		objects: client.List("MessageD"),
		cur:     0,
	}
}

type MessageA struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	stringValue string
}

func (o *MessageA) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *MessageA) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *MessageA) GetKey() uint32 {
	return o.key
}

func (o *MessageA) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *MessageA) GetStringValue() string {
	return o.stringValue
}

func (o *MessageA) SetStringValue(val string) {
	o.stringValue = val
	o.bubbleSave()
}

func (o *MessageA) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageA) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *MessageA) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewMessageA(sdkClient clientApi.Client) *MessageA {
	w := &MessageA{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "MessageA",
	}
	return w
}

func NewMessageAWithKey(sdkClient clientApi.Client, key uint32) *MessageA {
	w := NewMessageA(sdkClient)
	w.SetKey(key)
	return w
}

func GetMessageA(sdkClient clientApi.Client, key uint32) *MessageA {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("MessageA", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*MessageA)
	if !ok {
		panic("Couldn't cast to MessageA")
	}
	return o
}

func childNewMessageA(parent delphiWrapper, sdkClient clientApi.Client) *MessageA {
	w := NewMessageA(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageAWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *MessageA) *MessageA {
	w := childNewMessageA(parent, sdkClient)
	w.key = value.key
	w.stringValue = value.stringValue
	return w
}

func (o *MessageA) GetProtoMsg() *MessageA_ {
	return &MessageA_{
		Meta:        o.meta,
		Key:         o.key,
		StringValue: o.stringValue,
	}
}

func (o *MessageA) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *MessageA) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *MessageA) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(MessageAReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnMessageACreate(obj)
			} else {
				rctr.OnMessageAUpdate(obj)
			}
		} else {
			rctr.OnMessageADelete(obj)
		}
	}
}

type MessageAReactor interface {
	OnMessageACreate(obj *MessageA)
	OnMessageAUpdate(obj *MessageA)
	OnMessageADelete(obj *MessageA)
}

func (obj *MessageA) GetPath() string {
	return "MessageA" + "|" + obj.GetKeyString()
}

func newMessageAFromMessage(msg *MessageA_) *MessageA {
	return &MessageA{
		meta:        msg.Meta,
		key:         msg.Key,
		stringValue: msg.StringValue,
	}
}

func messageAFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg MessageA_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newMessageAFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func MessageAMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("MessageA", mode)
}

func MessageAMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("MessageA", keyString, mode)
}

func MessageAWatch(client clientApi.Client, reactor MessageAReactor) {
	client.WatchKind("MessageA", reactor)
}

type MessageAIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *MessageAIterator) Next() *MessageA {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*MessageA)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func MessageAList(client clientApi.Client) *MessageAIterator {
	return &MessageAIterator{
		objects: client.List("MessageA"),
		cur:     0,
	}
}

type MessageKey struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	value     uint32
}

func (o *MessageKey) GetValue() uint32 {
	return o.value
}

func (o *MessageKey) SetValue(val uint32) {
	o.value = val
	o.bubbleSave()
}

func (o *MessageKey) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *MessageKey) save() {
}

func NewMessageKey(sdkClient clientApi.Client) *MessageKey {
	w := &MessageKey{}
	w.sdkClient = sdkClient
	return w
}

func childNewMessageKey(parent delphiWrapper, sdkClient clientApi.Client) *MessageKey {
	w := NewMessageKey(sdkClient)
	w.parent = parent
	return w
}

func childNewMessageKeyWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *MessageKey) *MessageKey {
	w := childNewMessageKey(parent, sdkClient)
	w.value = value.value
	return w
}

func (o *MessageKey) GetProtoMsg() *MessageKey_ {
	return &MessageKey_{
		Value: o.value,
	}
}

func (o *MessageKey) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func newMessageKeyFromMessage(msg *MessageKey_) *MessageKey {
	return &MessageKey{
		value: msg.Value,
	}
}

type StringArray struct {
	parent delphiWrapper
	values []string
}

func (arr *StringArray) Append(value string) {
	arr.values = append(arr.values, value)
	arr.parent.bubbleSave()
}

func (arr *StringArray) Get(pos int) string {
	return arr.values[pos]
}

func (arr *StringArray) Length() int {
	return len(arr.values)
}

func newStringArrayFromMessage(msg []string) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, len(msg))
	copy(arr.values, msg)
	return arr
}

func childNewStringArray(parent delphiWrapper, sdkClient clientApi.Client) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, 0)
	arr.parent = parent
	return arr
}

func childNewStringArrayWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *StringArray) *StringArray {
	arr := childNewStringArray(parent, sdkClient)
	for _, v := range value.values {
		arr.values = append(arr.values, v)
	}
	return arr
}

func (arr *StringArray) GetProtoMsg() []string {
	v := make([]string, len(arr.values))
	copy(v, arr.values)
	return v
}

func init() {
	proto.RegisterType((*MessageA_)(nil), "compilertest.MessageA_")
	proto.RegisterType((*MessageKey_)(nil), "compilertest.MessageKey_")
	proto.RegisterType((*MessageB_)(nil), "compilertest.MessageB_")
	proto.RegisterType((*MessageC_)(nil), "compilertest.MessageC_")
	proto.RegisterType((*MessageD_)(nil), "compilertest.MessageD_")
	clientApi.RegisterFactory("MessageB", messageBFactory)
	clientApi.RegisterFactory("MessageC", messageCFactory)
	clientApi.RegisterFactory("MessageD", messageDFactory)
	clientApi.RegisterFactory("MessageA", messageAFactory)
}

func init() { proto.RegisterFile("compiler_test.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4e, 0xce, 0xcf, 0x2d,
	0xc8, 0xcc, 0x49, 0x2d, 0x8a, 0x2f, 0x49, 0x2d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
	0xe2, 0x81, 0x09, 0x82, 0xc4, 0xa4, 0x54, 0xf2, 0x32, 0x93, 0xf5, 0x53, 0x52, 0x73, 0x0a, 0x32,
	0x32, 0xf5, 0xc1, 0xf2, 0x30, 0x0e, 0x84, 0x82, 0xe8, 0x51, 0x4a, 0xe7, 0xe2, 0xf4, 0x4d, 0x2d,
	0x2e, 0x4e, 0x4c, 0x4f, 0x75, 0x8c, 0x17, 0x52, 0xe3, 0x62, 0xf1, 0x4d, 0x2d, 0x49, 0x94, 0x60,
	0x54, 0x60, 0xd4, 0xe0, 0x36, 0x12, 0xd2, 0x83, 0xaa, 0xf4, 0x4f, 0xca, 0x4a, 0x4d, 0x2e, 0x01,
	0xc9, 0x04, 0x81, 0xe5, 0x85, 0x04, 0xb8, 0x98, 0xbd, 0x53, 0x2b, 0x25, 0x98, 0x14, 0x18, 0x35,
	0x78, 0x83, 0x40, 0x4c, 0x21, 0x05, 0x2e, 0xee, 0xe0, 0x92, 0xa2, 0xcc, 0xbc, 0xf4, 0xb0, 0xc4,
	0x9c, 0xd2, 0x54, 0x09, 0x66, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x64, 0x21, 0x25, 0x65, 0x2e, 0x6e,
	0xa8, 0x45, 0xde, 0xa9, 0x95, 0xf1, 0x42, 0x22, 0x5c, 0xac, 0x10, 0xa5, 0x8c, 0x60, 0x43, 0x20,
	0x1c, 0xa5, 0x26, 0x46, 0xb8, 0x73, 0x9c, 0x88, 0x77, 0x8e, 0x36, 0xc2, 0x39, 0xdc, 0x46, 0x92,
	0x7a, 0xc8, 0xa1, 0xa0, 0x87, 0x64, 0x27, 0xb1, 0x2e, 0x45, 0x04, 0x89, 0x33, 0x55, 0x83, 0x84,
	0x19, 0xdd, 0xa2, 0x68, 0xb8, 0x45, 0x2e, 0xc4, 0x5b, 0x44, 0xd0, 0xfd, 0x56, 0x2c, 0x1d, 0xd3,
	0x95, 0x18, 0x93, 0xd8, 0xc0, 0xf1, 0x6b, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x9a, 0x14,
	0xee, 0x2a, 0x02, 0x00, 0x00,
}
