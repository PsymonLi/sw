// {C} Copyright 2017 Pensando Systems Inc. All rights reserved

//------------------------------------------------------------------------------
// protobuf specification for HAL debug package
//------------------------------------------------------------------------------

syntax = "proto3";

import "types.proto";

package debug;
option go_package="halproto";

// HAL debug service
service Debug {
    rpc DebugInvoke (DebugRequestMsg) returns (DebugResponseMsg) {}
    rpc MemTrackGet (MemTrackGetRequestMsg) returns (MemTrackGetResponseMsg) {}
    rpc SlabGet (SlabGetRequestMsg) returns (SlabGetResponseMsg){}
}

// DebugKeyHandle uniquely identfies the table/register to access
message DebugKeyHandle {
    oneof key_or_handle {
        fixed32  table_id = 1;   // table ID being accessed
        fixed32  reg_id   = 2;   // register ID being accessed
    }
}

// Debug table and register Read/Write operation
enum DebugOperationType {
    DEBUG_OP_TYPE_NONE  = 0;    // operation type not specified in request
    DEBUG_OP_TYPE_READ  = 1;    // read the given table/register
    DEBUG_OP_TYPE_WRITE = 2;    // write to the given table/register
}

// DebugSpec msg is used to pass parameters for the Debug
message DebugSpec {
    DebugKeyHandle      key_or_handle   =   1;      // table/register ID to be accessed
    DebugOperationType  opn_type        =   2;      // read/write operation
    uint64              addr            =   3;      // address to be read/write
    uint32              reg_data        =   4;      // data to write
    uint32              index           =   5;      // index for tables
    bytes               swkey           =   6;      // structure typecast to char* and wrapped with string
    bytes               swkey_mask      =   7;      // structure typecast to char* and wrapped with string
    bytes               actiondata      =   8;      // structure typecast to char* and wrapped with string
}

// Batched DEBUG request message
message DebugRequestMsg {
    repeated DebugSpec  request = 1;
}

// DEBUG response
message DebugResponse {
    DebugSpec   rsp_data      =   1;
    fixed32     debug_status  =   2;    // DEBUG cmd status
    uint32      ret_data      =   3;      // return data for read operations
}

// Batched DEBUG response msg
message DebugResponseMsg {
    repeated DebugResponse    response = 1;
}

message MemTrackSpec {
  uint32    alloc_id = 1;    // allocation id stats are requested for (0xFFFFFFFF for all)
}

// MemTrackGetRequest is request msg with allocation id that info is requested for
message MemTrackGetRequest {
  types.ObjectMeta      meta             = 1;    // object meta
  MemTrackSpec          spec             = 2;    // qualifiers
}

// MemTrackGetRequestMsg is batched MemTrackGetRequest
message MemTrackGetRequestMsg {
  repeated MemTrackGetRequest    request = 1;    // individual request
}

// operational status of memory tracker object
message MemTrackStatus {
}

// stats per memory tracker object
message MemTrackStats {
  uint32    num_allocs    = 1;    // number of allocations with alloc_id
  uint32    num_frees     = 2;    // number of frees with alloc_id
}

// MemTrackGetResponse captures debug information per allocation id
message MemTrackGetResponse {
  types.ApiStatus    api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  MemTrackSpec       spec       = 2;    // spec (aka. identifier of mem track object)
  MemTrackStatus     status     = 3;    // oper status, if any
  MemTrackStats      stats      = 4;    // statistics
}

// MemTrackGetResponseMsg is batched MemTrackGetResponse
message MemTrackGetResponseMsg {
  repeated MemTrackGetResponse    response   = 1;    // response per allocation id
}

// SlabSpec identifies a slab
message SlabSpec {
  string name                 = 1;    // name of the slab
  uint32 id                   = 2;    // slab identifier
  uint32 element_size         = 3;    // size of each element
  uint32 elements_per_block   = 4;    // # of elements per block
  bool   thread_safe          = 5;    // thread safe allocation/free, if TRUE
  bool   grow_on_demand       = 6;    // grow the slab on demand, if TRUE
  bool   delay_delete         = 7;    // delay delete each element, if TRUE, instead of freeing immediately
  bool   zero_on_allocation   = 8;    // zero allocated mem. if TRUE
}

// operational status of slab, if any
message SlabStatus {
}

// per slab statistics
message SlabStats {
  uint32 num_elements_in_use = 1;    // number of elements in use
  uint32 num_allocs          = 2;    // number of alloc operations
  uint32 num_frees           = 3;    // number of free operations
  uint32 num_alloc_errors    = 4;    // number of alloc errors
  uint32 num_blocks          = 5;    // number of blocks allocated
}

// SlabGetRequest is GET request per slab
message SlabGetRequest {
  types.ObjectMeta      meta = 1;    // object meta
  uint32 id                  = 2;    // slab identifier
}

// SlabGetResponse is batched GET request
message SlabGetRequestMsg {
  repeated SlabGetRequest    request = 1;    // batched get request
}

// SlabGetResponse captures all information about a slab
message SlabGetResponse {
  types.ApiStatus    api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  SlabSpec           spec       = 2;    // slab attributes
  SlabStatus         status     = 3;    // operational status of the slab
  SlabStats          stats      = 4;    // stats of the slab
}

// SlabGetResponseMsg is batched response for GET operation
message SlabGetResponseMsg {
  repeated SlabGetResponse     response = 1;    // batched get response
}
