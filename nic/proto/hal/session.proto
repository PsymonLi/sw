//------------------------------------------------------------------------------
// protobuf specification for session/lif APIs
//------------------------------------------------------------------------------

syntax = "proto3";

import "types.proto";
import "nwsec.proto";
import "kh.proto";

package session;
option go_package="halproto";

// The session service definition
service Session {
  rpc SessionCreate (SessionRequestMsg) returns (SessionResponseMsg) {}
  rpc SessionDelete (SessionDeleteRequestMsg) returns (SessionDeleteResponseMsg) {}
  rpc SessionGet (SessionGetRequestMsg) returns (SessionGetResponseMsg) {}
}

// Key for L2 flows (i.e, non-IP flows)
message FlowKeyL2 {
  fixed64    smac           = 1;   // source MAC address
  fixed64    dmac           = 2;   // destination MAC address
  uint32     ether_type     = 4;   // ether type 
  uint32     l2_segment_id  = 3;   // L2 segment id
}

message FlowKeyTcpUdpInfo {
  uint32    sport = 1;         // TCP/UDP source port
  uint32    dport = 2;         // TCP/UDP destination port
}

message FlowKeyICMPInfo {
  uint32    type = 1;          // ICMP type
  uint32    code = 2;          // ICMP code
  uint32    id   = 3;          // ICMP id, if any
}

message FlowKeyESPInfo {
  uint32   spi = 1;            // Security Parameters Index (SPI)
}

// Key for IPv4 flows
message FlowKeyV4 {
  fixed32                  sip      = 1;    // source IP address
  fixed32                  dip      = 2;    // destination IP address
  types.IPProtocol         ip_proto = 3;    // IP protocol
  // TODO: add AH etc. here
  oneof l4_fields {
      FlowKeyTcpUdpInfo    tcp_udp  = 4;    // TCP/UDP ports
      FlowKeyICMPInfo      icmp     = 5;    // ICMP type, code and id
      FlowKeyESPInfo       esp      = 6;    // ESP type
  }
}

// Key for IPv6 flows
message FlowKeyV6 {
  types.IPAddress     sip           = 1;    // source IP address
  types.IPAddress     dip           = 2;    // destination IP address
  types.IPProtocol    ip_proto      = 3;    // IP protocol
  // TODO: add AH etc. here
  oneof l4_fields {
      FlowKeyTcpUdpInfo    tcp_udp  = 4;    // TCP/UDP ports
      FlowKeyICMPInfo      icmp     = 5;    // ICMP type, code and id
      FlowKeyESPInfo       esp      = 6;    // ESP type
  }
}

// FlowKey is the key for uni-directional flow
message FlowKey {
 oneof flow_key {
    FlowKeyL2    l2_key    = 1;    // L2 key
    FlowKeyV4    v4_key    = 2;    // IPv4 key
    FlowKeyV6    v6_key    = 3;    // IPv6 key
  }
}

// Types of NAT
enum NatType {
  NAT_TYPE_NONE         = 0;
  NAT_TYPE_SNAT         = 1;    // source NAT
  NAT_TYPE_DNAT         = 2;    // destination NAT
  NAT_TYPE_TWICE_NAT    = 3;    // twice NAT
}

// Flow actions
enum FlowAction {
  FLOW_ACTION_NONE        = 0;
  FLOW_ACTION_ALLOW       = 1;    // allow the packets
  FLOW_ACTION_DROP        = 2;    // drop the packets
}

// Flow TCP states
// TODO: Srini, please define all other states
enum FlowTCPState {
    FLOW_TCP_STATE_INIT            = 0;
    FLOW_TCP_STATE_SYN_RCVD        = 1;
    FLOW_TCP_STATE_ACK_RCVD        = 2;
    FLOW_TCP_STATE_SYN_ACK_RCVD    = 3;
    FLOW_TCP_STATE_ESTABLISHED     = 4;
    FLOW_TCP_STATE_FIN_RCVD        = 5;
    FLOW_TCP_STATE_BIDIR_FIN_RCVD  = 6;
    FLOW_TCP_STATE_RESET           = 7;
}

// App Types ... In sync with p4/nw/include/defines.h
// TODO: Revisit once we decide if flow drives app_id or service_lif
enum FlowType {
    FLOW_TYPE_NONE         = 0;
    FLOW_TYPE_CLASSIC_NIC  = 1;
    FLOW_TYPE_RDMA         = 2;
    FLOW_TYPE_TCPTLS       = 3;
    FLOW_TYPE_IPSEC        = 4;
    FLOW_TYPE_NDE          = 5;
    FLOW_TYPE_STORAGE      = 6;
    FLOW_TYPE_TELEMETRY    = 7;
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
message FlowInfo {
  FlowAction                         flow_action          = 1;     // flow action(s)
  NatType                            nat_type             = 2;     // NAT mode
  types.IPAddress                    nat_sip              = 3;     // source IP to NAT to
  uint32                             nat_sport            = 4;     // source port to NAT to
  types.IPAddress                    nat_dip              = 5;     // destination IP to NAT to
  uint32                             nat_dport            = 6;     // dstination port to NAT to
  fixed64                            nat_dmac             = 7;     // For DSR
  FlowTCPState                       tcp_state            = 8;     // TCP state, if any
  repeated kh.MirrorSessionKeyHandle ing_mirror_sessions  = 9  [(gogoproto.moretags) = "venice:constraints={range:0-7}"]; // list of mirror destinations
  repeated kh.MirrorSessionKeyHandle egr_mirror_sessions  = 10 [(gogoproto.moretags) = "venice:constraints={range:0-7}"];// list of mirror destinations
}


message ConnTrackExceptions {
  bool tcp_syn_retransmit                   = 1;
  bool tcp_win_zero_drop                    = 2;
  bool tcp_full_retransmit                  = 3;
  bool tcp_partial_overlap                  = 4;
  bool tcp_packet_reorder                   = 5;
  bool tcp_out_of_window                    = 6;
  bool tcp_invalid_ack_num                  = 7;
  bool tcp_normalization_drop               = 8;
  bool tcp_split_handshake_detected         = 9;
  bool tcp_data_after_fin                   = 10;
  bool tcp_non_rst_pkt_after_rst            = 11;
  bool tcp_invalid_first_pkt_from_responder = 12;
  bool tcp_unexpected_pkt                   = 13;
  bool tcp_rst_with_invalid_ack_num         = 14;
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
message ConnTrackInfo {
  fixed64              flow_create_ts = 1;    // flow creation timestamp
  fixed64              flow_bytes     = 2;    // number of bytes seen
  fixed32              flow_packets   = 3;    // number of packets seen
  ConnTrackExceptions  exceptions     = 4;    // exceptions seen in the flow
  fixed32              tcp_seq_num    = 5;    // TCP sequence number
  fixed32              tcp_ack_num    = 6;    // TCP ack number
  uint32               tcp_win_sz     = 7;    // TCP window size
  uint32               tcp_win_scale  = 8;    // TCP window scale
  uint32               tcp_mss        = 9;    // TCP MSS
}

// FlowData captures all the flow information
message FlowData {
  FlowInfo         flow_info = 1;          // flow forwarding, rewriting information
  ConnTrackInfo    conn_track_info = 2;    // connection state of the flow
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
message FlowSpec {
  FlowKey          flow_key        = 1;    // flow key
  FlowData         flow_data       = 2;    // flow data
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
message SessionSpec {
  types.ObjectMeta     meta                   = 1;    // object meta
  // session_id is unique session identifier
  fixed32              session_id             = 2 [(gogoproto.moretags) = "venice:\"key\""];
  bool                 conn_track_en          = 3;    // TRUE if connection tracking is ON
  bool                 tcp_ts_option          = 4;   // TCP timestamp option seen or not
  bool                 tcp_sack_perm_option   = 5;   // TCP SACK Permitted option negotiated or not
  sint32               iflow_syn_ack_delta    = 6;    // syn cookie delta of iflow
  FlowSpec             initiator_flow         = 7;    // initiator flow
  FlowSpec             responder_flow         = 8;    // responder flow
}

// SessionRequestMsg is batched session request message
message SessionRequestMsg {
  repeated SessionSpec    request = 1;  // batched sessions
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
message FlowStatus {
  fixed64             flow_handle     = 1;    // id of the flow (returned by HAL)
  ConnTrackInfo       conn_track_info = 2;    // connection tracking info
  bool                flow_coll       = 3;    // TODO: flow collision. Only till recirc works  
  uint32              flow_hash       = 4;    // TODO: REMOVE flow hash. Only for DOL testing
}

// TFTPInfo captures the operational status of TFTP ALG session
message TFTPALGInfo {
  bool                 iscontrol      = 1; // Is this flow control/data TFTP flow
  uint32               parse_error    = 2; // Number of parse errors recorded for this session
  uint32               unknown_opcode = 3; // Number of unknown opcode received
}

// RPCInfo captures the operational status of SUNRPC/MSFT RPC ALG session
message RPCALGInfo {
  bool                 iscontrol            = 1; // Is this flow control/data TFTP flow
  uint32               parse_error          = 2; // Number of parse errors recorded for this session
  uint32               num_data_sess        = 3; // Number of active data sessions associated with this control session
  uint32               num_exp_flows        = 4; // Number of expected flows opened by this session
  uint32               maxpkt_size_exceeded = 5; // Number of packets that exceeded maximum packet size while L7 reassembly 
} 

// SIPInfo captures the operational status of SIP ALG session
message SIPALGInfo {
  uint32               parse_error    = 1; // Number of parse errors recorded for this session
}

// FTPInfo captures the operational status of FTP ALG session
message FTPALGInfo {
  bool                 iscontrol      = 1; // Is this flow control/data TFTP flow
  uint32               parse_error    = 2; // Number of parse errors recorded for this session
}

// RTSPALGInfo captures the operational status of RTSP ALG session
message RTSPALGInfo {
  bool                 iscontrol      = 1; // Is this flow control/data TFTP flow
}

// DNSALGInfo captures the operational status of DNS ALG session
message DNSALGInfo {
  bool                 iscontrol      = 1; // Is this flow control/data TFTP flow
}

// SessionStatus captures the operational status of the session
message SessionStatus {
  fixed64                session_handle    = 1;    // id of the session (returned by HAL)
  FlowStatus             iflow_status      = 2;    // operational status of iflow
  FlowStatus             rflow_status      = 3;    // operational status of rflow
  uint32                 app_id            = 4;    // L7 app id
  uint32                 app_id_state      = 5;    // L7 app id state
  nwsec.ALGName          alg               = 6;    // ALG applied on the session
  oneof alg_info {
      TFTPALGInfo        tftp_info         = 7;   
      RPCALGInfo         rpc_info          = 8;
      SIPALGInfo         sip_info          = 9;
      RTSPALGInfo        rtsp_info         = 10;
      DNSALGInfo         dns_info          = 11;
      FTPALGInfo         ftp_info          = 12;
  } 
}

// SessionResponse is the response to one SessionSpec
message SessionResponse {
  types.ApiStatus       api_status  = 1;    // API status code
  SessionStatus         status      = 2;    // operational status
}

// SessionResponseMsg is the response to SessionRequestMsg
message SessionResponseMsg {
  repeated SessionResponse    response = 1;    // batched responses
}

// SessionDeleteRequest is used to delete a session
message SessionDeleteRequest {
  types.ObjectMeta    meta           = 1;    // object meta
  // session_handle is the handle of the session
  fixed64             session_handle = 2 [(gogoproto.moretags) = "venice:\"key\""];
}

// SessionDeleteRequestMsg is batched session delete request
message SessionDeleteRequestMsg {
  repeated SessionDeleteRequest    request = 1;  // batched delete request
}

// SessionDeleteResponse is response to session delete request
message SessionDeleteResponse {
  types.ApiStatus api_status = 1 [(gogoproto.moretags) = "venice:api_status"];    // API status code
  fixed64         session_handle = 2;         // session handle for which the API status is set
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
message SessionDeleteResponseMsg {
  repeated SessionDeleteResponse response = 1;    // batched response
}

// SessionGetRequest  is used to get information about a session
message SessionGetRequest {
  types.ObjectMeta    meta           = 1;    // object meta
  // session_handle is the handle of the session
  fixed64             session_handle = 2 [(gogoproto.moretags) = "venice:\"key\""];
}

// SessionGetRequestMsg  is batched get request
message SessionGetRequestMsg {
  repeated SessionGetRequest    request = 1; // batched get request
}

// FlowStats contains all the stats collected per flow
message FlowStats {
  fixed64    flow_permitted_packets      = 1;
  fixed64    flow_permitted_bytes        = 2;
  fixed64    flow_dropped_packets        = 3;
  fixed64    flow_dropped_bytes          = 4;
}

// SessionStats captures statistics of all its constituent flows
message SessionStats {
  FlowStats    initiator_flow_stats = 1;     // stats of initiator flow
  FlowStats    responder_flow_stats = 2;     // stats of responder flow
}

// SessionGetResponse is response to one SessionGetRequest
message SessionGetResponse {
 types.ApiStatus      api_status = 1;    // API status code
  SessionSpec         spec       = 2;
  SessionStatus       status     = 3;
  SessionStats        stats      = 4;
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
message SessionGetResponseMsg {
  types.ApiStatus                api_status = 1;    // API status code
  repeated SessionGetResponse    response   = 2;    // batched response
}
