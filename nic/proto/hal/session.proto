//------------------------------------------------------------------------------
// protobuf specification for session/lif APIs
//------------------------------------------------------------------------------

syntax = "proto3";

import "types.proto";
import "qos.proto";
import "telemetry.proto";
import "nwsec.proto";

package session;
option go_package="halproto";

// The session service definition
service Session {
  rpc SessionCreate (SessionRequestMsg) returns (SessionResponseMsg) {}
  rpc SessionDelete (SessionDeleteRequestMsg) returns (SessionDeleteResponseMsg) {}
  rpc SessionGet (SessionGetRequestMsg) returns (SessionGetResponseMsg) {}
}

// Key for L2 flows (i.e, non-IP flows)
message FlowKeyL2 {
  fixed64    smac           = 1;   // source MAC address
  fixed64    dmac           = 2;   // destination MAC address
  uint32     ether_type     = 4;   // ether type 
  uint32     l2_segment_id  = 3;   // L2 segment id
}

message FlowKeyTcpUdpInfo {
  uint32    sport = 1;         // TCP/UDP source port
  uint32    dport = 2;         // TCP/UDP destination port
}

message FlowKeyICMPInfo {
  uint32    type = 1;          // ICMP type
  uint32    code = 2;          // ICMP code
  uint32    id   = 3;          // ICMP id, if any
}

message FlowKeyESPInfo {
  uint32   spi = 1;            // Security Parameters Index (SPI)
}

// Key for IPv4 flows
message FlowKeyV4 {
  fixed32                  sip      = 1;    // source IP address
  fixed32                  dip      = 2;    // destination IP address
  types.IPProtocol         ip_proto = 3;    // IP protocol
  // TODO: add AH etc. here
  oneof l4_fields {
      FlowKeyTcpUdpInfo    tcp_udp  = 4;    // TCP/UDP ports
      FlowKeyICMPInfo      icmp     = 5;    // ICMP type, code and id
      FlowKeyESPInfo       esp      = 6;    // ESP type
  }
}

// Key for IPv6 flows
message FlowKeyV6 {
  types.IPAddress     sip           = 1;    // source IP address
  types.IPAddress     dip           = 2;    // destination IP address
  types.IPProtocol    ip_proto      = 3;    // IP protocol
  // TODO: add AH etc. here
  oneof l4_fields {
      FlowKeyTcpUdpInfo    tcp_udp  = 4;    // TCP/UDP ports
      FlowKeyICMPInfo      icmp     = 5;    // ICMP type, code and id
      FlowKeyESPInfo       esp      = 6;    // ESP type
  }
}

// FlowKey is the key for uni-directional flow
message FlowKey {
 oneof flow_key {
    FlowKeyL2    l2_key    = 1;    // L2 key
    FlowKeyV4    v4_key    = 2;    // IPv4 key
    FlowKeyV6    v6_key    = 3;    // IPv6 key
  }
}

// Types of NAT
enum NatType {
  NAT_TYPE_NONE         = 0;
  NAT_TYPE_SNAT         = 1;    // source NAT
  NAT_TYPE_DNAT         = 2;    // destination NAT
  NAT_TYPE_TWICE_NAT    = 3;    // twice NAT
}

// Flow actions
enum FlowAction {
  FLOW_ACTION_NONE        = 0;
  FLOW_ACTION_ALLOW       = 1;    // allow the packets
  FLOW_ACTION_DROP        = 2;    // drop the packets
}

// Flow TCP states
// TODO: Srini, please define all other states
enum FlowTCPState {
    FLOW_TCP_STATE_INIT            = 0;
    FLOW_TCP_STATE_SYN_RCVD        = 1;
    FLOW_TCP_STATE_ACK_RCVD        = 2;
    FLOW_TCP_STATE_SYN_ACK_RCVD    = 3;
    FLOW_TCP_STATE_ESTABLISHED     = 4;
    FLOW_TCP_STATE_FIN_RCVD        = 5;
    FLOW_TCP_STATE_BIDIR_FIN_RCVD  = 6;
    FLOW_TCP_STATE_RESET           = 7;
}

// App Types ... In sync with p4/nw/include/defines.h
// TODO: Revisit once we decide if flow drives app_id or service_lif
enum FlowType {
    FLOW_TYPE_NONE         = 0;
    FLOW_TYPE_CLASSIC_NIC  = 1;
    FLOW_TYPE_RDMA         = 2;
    FLOW_TYPE_TCPTLS       = 3;
    FLOW_TYPE_IPSEC        = 4;
    FLOW_TYPE_NDE          = 5;
    FLOW_TYPE_STORAGE      = 6;
    FLOW_TYPE_TELEMETRY    = 7;
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
message FlowInfo {
  FlowAction      flow_action    = 1;    // flow action(s)
  NatType         nat_type       = 2;    // NAT mode
  types.IPAddress nat_sip        = 3;    // source IP to NAT to
  uint32          nat_sport      = 4;    // source port to NAT to
  types.IPAddress nat_dip        = 5;    // destination IP to NAT to
  uint32          nat_dport      = 6;    // dstination port to NAT to
  fixed64         nat_dmac       = 7;    // For DSR
  FlowTCPState    tcp_state      = 8;    // TCP state, if any
  qos.QOSActions  in_qos_actions = 9;    // QOS actions for the flow coming in (ingress P4 pipeline)
  qos.QOSActions  eg_qos_actions = 10;    // QOS actions for the flow while going out (egress P4 pipeline)
  repeated telemetry.MirrorSessionId  ing_mirror_sessions = 11;   // Mirror sessions to copy the flow to
  repeated telemetry.MirrorSessionId  egr_mirror_sessions = 12;   // Mirror sessions to copy the flow to
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
message ConnTrackInfo {
  fixed64              flow_create_ts = 1;    // flow creation timestamp
  fixed64              flow_bytes     = 2;    // number of bytes seen
  fixed32              flow_packets   = 3;    // number of packets seen
  fixed32              exception_bits = 4;    // exceptions seen in the flow
  fixed32              tcp_seq_num    = 5;    // TCP sequence number
  fixed32              tcp_ack_num    = 6;    // TCP ack number
  uint32               tcp_win_sz     = 7;    // TCP window size
  uint32               tcp_win_scale  = 8;    // TCP window scale
  uint32               tcp_mss        = 9;    // TCP MSS
}

// FlowData captures all the flow information
message FlowData {
  FlowInfo         flow_info = 1;          // flow forwarding, rewriting information
  ConnTrackInfo    conn_track_info = 2;    // connection state of the flow
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
message FlowSpec {
  FlowKey          flow_key        = 1;    // flow key
  FlowData         flow_data       = 2;    // flow data
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
message SessionSpec {
  types.ObjectMeta     meta                   = 1;    // object meta
  // session_id is unique session identifier
  fixed32              session_id             = 2 [(gogoproto.jsontag) = "key"];
  bool                 conn_track_en          = 3;    // TRUE if connection tracking is ON
  bool                 tcp_ts_option          = 4;   // TCP timestamp option seen or not
  bool                 tcp_sack_perm_option   = 5;   // TCP SACK Permitted option negotiated or not
  sint32               iflow_syn_ack_delta    = 6;    // syn cookie delta of iflow
  FlowSpec             initiator_flow         = 7;    // initiator flow
  FlowSpec             responder_flow         = 8;    // responder flow
}

// SessionRequestMsg is batched session request message
message SessionRequestMsg {
  repeated SessionSpec    request = 1;  // batched sessions
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
message FlowStatus {
  fixed64             flow_handle     = 1;    // id of the flow (returned by HAL)
  ConnTrackInfo       conn_track_info = 2;    // connection tracking info
  bool                flow_coll       = 3;    // TODO: flow collision. Only till recirc works  
  uint32              flow_hash       = 4;    // TODO: REMOVE flow hash. Only for DOL testing
}

// TFTPInfo captures the operational status of TFTP ALG session
message TFTPALGInfo {
  uint32               parse_error    = 1; // Number of parse errors recorded for this session
  uint32               unknown_opcode = 2; // Number of unknown opcode received
}

// RPCInfo captures the operational status of SUNRPC/MSFT RPC ALG session
message RPCALGInfo {
  uint32               parse_error    = 1; // Number of parse errors recorded for this session
  uint32               num_data_sess  = 2; // Number of active data sessions associated with this control session
} 

// SIPInfo captures the operational status of SIP ALG session
message SIPALGInfo {
  uint32               parse_error    = 1; // Number of parse errors recorded for this session
}

// SessionStatus captures the operational status of the session
message SessionStatus {
  fixed64                session_handle    = 1;    // id of the session (returned by HAL)
  FlowStatus             iflow_status      = 2;    // operational status of iflow
  FlowStatus             rflow_status      = 3;    // operational status of rflow
  uint32                 app_id            = 4;    // L7 app id
  uint32                 app_id_state      = 5;    // L7 app id state
  nwsec.ALGName          alg               = 6;    // ALG applied on the session
  oneof alg_info {
      TFTPALGInfo        tftp_info          = 7;   
      RPCALGInfo         rpc_info           = 8;
      SIPALGInfo         sip_info           = 9;
  } 
}

// SessionResponse is the response to one SessionSpec
message SessionResponse {
  types.ApiStatus       api_status  = 1;    // API status code
  SessionStatus         status      = 2;    // operational status
}

// SessionResponseMsg is the response to SessionRequestMsg
message SessionResponseMsg {
  repeated SessionResponse    response = 1;    // batched responses
}

// SessionDeleteRequest is used to delete a session
message SessionDeleteRequest {
  types.ObjectMeta    meta           = 1;    // object meta
  // session_handle is the handle of the session
  fixed64             session_handle = 2 [(gogoproto.jsontag) = "key"];
}

// SessionDeleteRequestMsg is batched session delete request
message SessionDeleteRequestMsg {
  repeated SessionDeleteRequest    request = 1;  // batched delete request
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
message SessionDeleteResponseMsg {
  repeated types.ApiStatus    api_status = 1;    // API status code
}

// SessionGetRequest  is used to get information about a session
message SessionGetRequest {
  types.ObjectMeta    meta           = 1;    // object meta
  // session_handle is the handle of the session
  fixed64             session_handle = 2 [(gogoproto.jsontag) = "key"];
}

// SessionGetRequestMsg  is batched get request
message SessionGetRequestMsg {
  repeated SessionGetRequest    request = 1; // batched get request
}

// FlowStats contains all the stats collected per flow
// TODO - Srini please add all that we have in P4 for now
message FlowStats {
  fixed32    flow_packets      = 1;
  fixed64    flow_bytes        = 2;
  fixed32    rexmit_packets    = 3;
}

// SessionStats captures statistics of all its constituent flows
message SessionStats {
  repeated FlowStats    flow_stats = 1;     // stats of all flows in session
}

// SessionGetResponse is response to one SessionGetRequest
message SessionGetResponse {
 types.ApiStatus      api_status = 1;    // API status code
  SessionSpec         spec       = 2;
  SessionStatus       status     = 3;
  SessionStats        stats      = 4;
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
message SessionGetResponseMsg {
  types.ApiStatus                api_status = 1;    // API status code
  repeated SessionGetResponse    response   = 2;    // batched response
}
