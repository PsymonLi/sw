// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sample.proto

/*
Package structs is a generated protocol buffer package.

It is generated from these files:
	sample.proto

It has these top-level messages:
	EndpointSpec
	ObjectMeta
	MacAddress
	IPAddress
*/
package structs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// IP address families
type IPAddressFamily int32

const (
	IPAddressFamily_IP_AF_NONE  IPAddressFamily = 0
	IPAddressFamily_IP_AF_INET  IPAddressFamily = 1
	IPAddressFamily_IP_AF_INET6 IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}
var IPAddressFamily_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// EndpointSpec is used to add or update an endpoint
// Key: l2_segment_handle, mac_address
// Handle: ep_handle
type EndpointSpec struct {
	Meta              *ObjectMeta  `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	L2SegmentHandle   uint64       `protobuf:"fixed64,2,opt,name=l2_segment_handle,json=l2SegmentHandle" json:"l2_segment_handle,omitempty"`
	MacAddress        *MacAddress  `protobuf:"bytes,3,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	InterfaceHandle   uint64       `protobuf:"fixed64,4,opt,name=interface_handle,json=interfaceHandle" json:"interface_handle,omitempty"`
	UsegVlan          uint32       `protobuf:"varint,5,opt,name=useg_vlan,json=usegVlan" json:"useg_vlan,omitempty"`
	IpAddress         []*IPAddress `protobuf:"bytes,6,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	SecurityGroup     []uint32     `protobuf:"varint,7,rep,packed,name=security_group,json=securityGroup" json:"security_group,omitempty"`
	EpHandle          uint64       `protobuf:"fixed64,8,opt,name=ep_handle,json=epHandle" json:"ep_handle,omitempty"`
	LearnSourceConfig bool         `protobuf:"varint,9,opt,name=learn_source_config,json=learnSourceConfig" json:"learn_source_config,omitempty"`
}

func (m *EndpointSpec) Reset()                    { *m = EndpointSpec{} }
func (m *EndpointSpec) String() string            { return proto.CompactTextString(m) }
func (*EndpointSpec) ProtoMessage()               {}
func (*EndpointSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EndpointSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointSpec) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

func (m *EndpointSpec) GetMacAddress() *MacAddress {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *EndpointSpec) GetInterfaceHandle() uint64 {
	if m != nil {
		return m.InterfaceHandle
	}
	return 0
}

func (m *EndpointSpec) GetUsegVlan() uint32 {
	if m != nil {
		return m.UsegVlan
	}
	return 0
}

func (m *EndpointSpec) GetIpAddress() []*IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointSpec) GetSecurityGroup() []uint32 {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

func (m *EndpointSpec) GetEpHandle() uint64 {
	if m != nil {
		return m.EpHandle
	}
	return 0
}

func (m *EndpointSpec) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

// common meta object that is part of all other top level objects
type ObjectMeta struct {
	TenantId uint32 `protobuf:"fixed32,1,opt,name=tenant_id,json=tenantId" json:"tenant_id,omitempty"`
}

func (m *ObjectMeta) Reset()                    { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()               {}
func (*ObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ObjectMeta) GetTenantId() uint32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

// mac address structure
type MacAddress struct {
	Mac uint64 `protobuf:"varint,1,opt,name=mac" json:"mac,omitempty"`
}

func (m *MacAddress) Reset()                    { *m = MacAddress{} }
func (m *MacAddress) String() string            { return proto.CompactTextString(m) }
func (*MacAddress) ProtoMessage()               {}
func (*MacAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MacAddress) GetMac() uint64 {
	if m != nil {
		return m.Mac
	}
	return 0
}

// IP address structure
type IPAddress struct {
	IpAf IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,enum=structs.IPAddressFamily" json:"ip_af,omitempty"`
	// Types that are valid to be assigned to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6 isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
}

type IPAddress_V4Addr struct {
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=v4_addr,json=v4Addr,oneof"`
}
type IPAddress_V6Addr struct {
	V6Addr []byte `protobuf:"bytes,3,opt,name=v6_addr,json=v6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}
func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (m *IPAddress) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPAddress) GetV4Addr() uint32 {
	if x, ok := m.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (m *IPAddress) GetV6Addr() []byte {
	if x, ok := m.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddress_OneofMarshaler, _IPAddress_OneofUnmarshaler, _IPAddress_OneofSizer, []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
}

func _IPAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		b.EncodeVarint(2<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(x.V4Addr))
	case *IPAddress_V6Addr:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.V6Addr)
	case nil:
	default:
		return fmt.Errorf("IPAddress.V4OrV6 has unexpected type %T", x)
	}
	return nil
}

func _IPAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddress)
	switch tag {
	case 2: // v4_or_v6.v4_addr
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.V4OrV6 = &IPAddress_V4Addr{uint32(x)}
		return true, err
	case 3: // v4_or_v6.v6_addr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.V4OrV6 = &IPAddress_V6Addr{x}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case *IPAddress_V6Addr:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.V6Addr)))
		n += len(x.V6Addr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*EndpointSpec)(nil), "structs.EndpointSpec")
	proto.RegisterType((*ObjectMeta)(nil), "structs.ObjectMeta")
	proto.RegisterType((*MacAddress)(nil), "structs.MacAddress")
	proto.RegisterType((*IPAddress)(nil), "structs.IPAddress")
	proto.RegisterEnum("structs.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
}

func init() { proto.RegisterFile("sample.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 439 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x52, 0x5d, 0x6b, 0xdb, 0x30,
	0x14, 0x6d, 0x9a, 0x34, 0x76, 0x6e, 0xbe, 0x5c, 0xf5, 0xc5, 0x63, 0x30, 0x4a, 0x60, 0x6c, 0x2d,
	0x2c, 0xb0, 0x2c, 0xe4, 0xbd, 0x1d, 0xe9, 0x9a, 0x87, 0xa6, 0x45, 0x19, 0x7b, 0x15, 0xaa, 0xac,
	0x64, 0x1e, 0xb6, 0x2c, 0x24, 0x39, 0x50, 0xd8, 0x0f, 0xd8, 0xcf, 0x9e, 0x24, 0xc7, 0x0e, 0xb4,
	0x6f, 0xba, 0xe7, 0x9c, 0x7b, 0xcf, 0xfd, 0x10, 0x0c, 0x34, 0xcd, 0x65, 0xc6, 0xa7, 0x52, 0x15,
	0xa6, 0x40, 0x81, 0x36, 0xaa, 0x64, 0x46, 0x4f, 0xfe, 0xb5, 0x61, 0xb0, 0x14, 0x89, 0x2c, 0x52,
	0x61, 0x36, 0x92, 0x33, 0xf4, 0x09, 0x3a, 0x39, 0x37, 0x34, 0x6e, 0x5d, 0xb6, 0x3e, 0xf7, 0x67,
	0x17, 0xd3, 0x83, 0x70, 0xfa, 0xf8, 0xfc, 0x87, 0x33, 0xf3, 0x60, 0x29, 0xec, 0x05, 0xe8, 0x1a,
	0xce, 0xb3, 0x19, 0xd1, 0x7c, 0x97, 0x73, 0x61, 0xc8, 0x6f, 0x2a, 0x92, 0x8c, 0xc7, 0xa7, 0x36,
	0xab, 0x8b, 0xc7, 0xd9, 0x6c, 0x53, 0xe1, 0xf7, 0x1e, 0x46, 0x73, 0xe8, 0xe7, 0x94, 0x11, 0x9a,
	0x24, 0x8a, 0x6b, 0x1d, 0xb7, 0x5f, 0xd5, 0x7e, 0xa0, 0xec, 0xa6, 0xa2, 0x30, 0xe4, 0xcd, 0x1b,
	0x5d, 0x41, 0x64, 0xbb, 0xe2, 0x6a, 0x4b, 0x19, 0xaf, 0x0d, 0x3a, 0x95, 0x41, 0x83, 0x1f, 0x0c,
	0xde, 0x43, 0xaf, 0xb4, 0xad, 0x90, 0x7d, 0x46, 0x45, 0x7c, 0x66, 0x35, 0x43, 0x1c, 0x3a, 0xe0,
	0x97, 0x8d, 0xd1, 0x57, 0x80, 0x54, 0x36, 0xe6, 0xdd, 0xcb, 0xb6, 0x35, 0x47, 0x8d, 0xf9, 0xea,
	0xa9, 0xf6, 0xee, 0xa5, 0xb2, 0xb6, 0xfe, 0x08, 0x23, 0xcd, 0x59, 0xa9, 0x52, 0xf3, 0x42, 0x76,
	0xaa, 0x28, 0x65, 0x1c, 0xd8, 0xb4, 0x21, 0x1e, 0xd6, 0xe8, 0x0f, 0x07, 0x3a, 0x5b, 0x2e, 0xeb,
	0xd6, 0x42, 0xdf, 0x5a, 0xc8, 0xe5, 0xa1, 0xa7, 0x29, 0x5c, 0x64, 0x9c, 0x2a, 0x41, 0x74, 0x51,
	0x2a, 0x3b, 0x01, 0x2b, 0xc4, 0x36, 0xdd, 0xc5, 0x3d, 0x2b, 0x0b, 0xf1, 0xb9, 0xa7, 0x36, 0x9e,
	0xf9, 0xee, 0x89, 0xc9, 0x15, 0xc0, 0x71, 0xc9, 0xae, 0xb4, 0xe1, 0x82, 0xda, 0xd5, 0xa6, 0x89,
	0x3f, 0x46, 0x80, 0xc3, 0x0a, 0x58, 0x25, 0x93, 0x0f, 0x00, 0xc7, 0x9d, 0xa1, 0x08, 0xda, 0x76,
	0x6b, 0x5e, 0xd4, 0xc1, 0xee, 0x39, 0xf9, 0x0b, 0xbd, 0x66, 0x2c, 0xf4, 0x05, 0xce, 0xdc, 0xf8,
	0x5b, 0x2f, 0x18, 0xcd, 0xe2, 0xb7, 0x93, 0xdf, 0xd1, 0x3c, 0xcd, 0x5e, 0x70, 0xc7, 0xce, 0xbf,
	0x45, 0xef, 0x20, 0xd8, 0xcf, 0xfd, 0xb6, 0xfc, 0x35, 0x83, 0xfb, 0x13, 0xdc, 0xdd, 0xcf, 0x9d,
	0xd2, 0x53, 0x8b, 0x8a, 0x72, 0x27, 0x1c, 0x78, 0x6a, 0xe1, 0xa8, 0x5b, 0x80, 0xd0, 0x66, 0x15,
	0x8a, 0xec, 0x17, 0xd7, 0xb7, 0x30, 0x7e, 0x55, 0x1a, 0x8d, 0x00, 0x56, 0x4f, 0xe4, 0xe6, 0x8e,
	0xac, 0x1f, 0xd7, 0xcb, 0xe8, 0xe4, 0x18, 0xaf, 0xd6, 0xcb, 0x9f, 0x51, 0x0b, 0x8d, 0xa1, 0x7f,
	0x8c, 0x17, 0xd1, 0xe9, 0x73, 0xd7, 0xff, 0xd3, 0x6f, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x1b,
	0xf4, 0x4c, 0xd2, 0xb7, 0x02, 0x00, 0x00,
}
