syntax = "proto3";
package accel_metrics;

import "delphi.proto";

message AccelPfInfo {
    delphi.ObjectMeta   Meta                 = 1;
    uint64              Key                  = 2;
    uint64              hw_lif_id            = 3;
    uint32              num_seq_queues       = 4;
    uint32              crypto_key_idx_base  = 5;
    uint32              num_crypto_keys_max  = 6;
    uint32              intr_base            = 7;
    uint32              intr_count           = 8;
}
    
message AccelSeqQueueKey {
    fixed64             lif_id               = 1;     // Lif id
    uint32              qid                  = 2;     // Queue id
}

enum AccelSeqQGroup {
    QGroupCpdc                               = 0;     // CP/DC sequencer submission queue group
    QGroupCpdcStatus                         = 1;     // CP/DC sequencer status queue group
    QGroupCrypto                             = 2;     // Crypto sequencer submission queue group
    QGroupCryptoStatus                       = 3;     // Crypto sequencer status queue group
}

message AccelSeqQueueInfo {
    delphi.ObjectMeta   Meta                 = 1;
    AccelSeqQueueKey    Key                  = 2;
    uint64              qstate_addr          = 3;
    AccelSeqQGroup      qgroup               = 4;
    uint32              core_id              = 5;
}

message AccelSeqQueueMetrics {
    AccelSeqQueueKey    Key                  = 1;

    delphi.Counter interrupts_raised         = 2;     // Interrupts raised
    delphi.Counter next_dbs_rung             = 3;     // Next doorbells rung
    delphi.Counter seq_descs_processed       = 4;     // SeqSQ descriptors processed
    delphi.Counter seq_descs_aborted         = 5;     // SeqSQ descriptors aborted
    delphi.Counter status_pdma_xfers         = 6;     // Status PDMA transfers
    delphi.Counter hw_desc_xfers             = 7;    // HW descriptor transfers
    delphi.Counter hw_batch_errors           = 8;    // HW batch transfer errors
    delphi.Counter hw_op_errors              = 9;    // HW operation errors
    delphi.Counter aol_pad_reqs              = 10;    // AOL padding requests processed
    delphi.Counter sgl_pad_reqs              = 11;    // SGL padding requests processed
    delphi.Counter sgl_pdma_xfers            = 12;    // SGL PDMA transfers taken
    delphi.Counter sgl_pdma_errors           = 13;    // SGL PDMA errors
    delphi.Counter sgl_pad_only_xfers        = 14;    // SGL PDMA pad-only transfers taken
    delphi.Counter sgl_pad_only_errors       = 15;    // SGL PDMA pad-only errors
    delphi.Counter alt_descs_taken           = 16;    // Times an alternate descriptor were used
    delphi.Counter alt_bufs_taken            = 17;    // Times an alternate source buffer were used
    delphi.Counter len_update_reqs           = 18;    // CP/DC length updates after decrypt
}

enum AccelHwRingId {
    HwRingCp                                 = 0;     // Compression ring
    HwRingCpHot                              = 1;     // Hot compression ring
    HwRingDc                                 = 2;     // Decompression ring
    HwRingDcHot                              = 3;     // Hot decompression ring
    HwRingXtsEncr                            = 4;     // XTS encryption ring
    HwRingXtsDecr                            = 5;     // XTS decryption ring
    HwRingGcmEncr                            = 6;     // GCM encryption ring
    HwRingGcmDecr                            = 7;     // GCM decryption ring
}

message AccelHwRingKey {
    AccelHwRingId       rid                  = 1;     // Ring id
    uint32              sub_rid              = 2;     // Sub-ring id
}

message AccelHwRingInfo {
    delphi.ObjectMeta   Meta                 = 1;
    AccelHwRingKey      Key                  = 2;
    uint32              pindex               = 3;     // Producer index
    uint32              cindex               = 4;     // Consumer index
}

message AccelHwRingMetrics {
    AccelHwRingKey      Key                  = 1;
    delphi.Counter      input_bytes          = 2;     // Total input bytes (not available on some rings)
    delphi.Counter      output_bytes         = 3;     // Total output bytes (not available on some rings)
    delphi.Counter      soft_resets          = 4;     // # soft resets executed
}

