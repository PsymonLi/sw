#!/bin/sh

#
# FIRMWARE UPDATE UTILITY
#

R=""
export LD_LIBRARY_PATH=/platform/lib:/nic/lib:$LD_LIBRARY_PATH
export PATH=/platform/bin:$PATH
if [ `arch` != aarch64 ]; then
    export PATH=`pwd`/bin:$PATH
    R=`pwd`/data
fi

# mmc partition uuids are all uppercase
IMAGE_A_PARTUUID=D4E53BE5-7DC1-4199-914C-48EDFEA92C5E
IMAGE_B_PARTUUID=E2FD6D28-3300-4979-8062-B8AB599F3898

# mtd partition names
# The image partitions are similar to their fwnames, but don't rely on that
MTDPART_UBOOT=boot0
MTDPART_MAINFWA=mainfwa
MTDPART_MAINFWB=mainfwb
MTDPART_GOLDFW=goldfw
MTDPART_DIAGFW=diagfw
MTDPART_FWSEL=fwsel

LOCK_TIMEOUT_SECS=600
LOCK_OPT=nowait

CMDLINE="$*"

usage()
{
cat << EOF >&2
usage: fwupdate [--from-legacy] action [options]
  --from-legacy     - Install to a card with pre-emmc mtd partitions
  --to-legacy       - Install old image back to pre-emmc mode
  --init-emmc       - Setup emmc partitions (from goldfw or diagfw only)

  action:
    -i "fwnames"    - Install package (requires -p and fwnames)
    -v              - Verify package file (required -p)
    -V fwname       - Verify installed image
    -r              - Show running image name
    -s fwname       - Set startup image name
    -S              - Show startup image name
    -l              - List installed images
    -L              - List loaded (running) images
    -C              - Create /var/run/fwupdate.cache

  options:
    -p pkgfile      - Package filename
    -I              - Ignore images missing from package
    -D              - Dry-run
    -x              - Skip installing CPLD bitfiles
    -R              - Force CPLD installation (ignore rev)
    -W (wait|break) - Lock wait operation (default: nowait)
    -T secs         - Lock timeout in second (default 600)

  fwnames:
    altfw           - Alternate (non-running) main firmware (for -i)
    mainfwa         - Main firmware slot A (for -i or -s)
    mainfwb         - Main firmware slot B (for -i or -s)
    goldfw          - Golden recovery image (for -i or -s)
    diagfw          - Diag firmware (for -i or -s)
    uboot           - U-Boot boot loader (for -i)
    cpld            - CPLD bitfile (for -i)
    all             - Synonym for "altfw goldfw diagfw uboot cpld". Implies -I
EOF
exit 1
}

LOGDIR=$R/obfl
LOGFILE=$LOGDIR/fwupdate.log
LOGMAXSZ=1048576
PIDFILE=$R/var/run/fwupdate.pid

do_log_emit()
{
    (
    local dry="" sz
    if [ "$DRY_RUN" != "" ]; then
        dry=" dry-run"
    fi
    if [ ! -f $LOGFILE ]; then
        mkdir -p $LOGDIR
        : > $LOGFILE
    fi
    sz=`stat -c "%s" $LOGFILE`
    if [ $sz -gt $LOGMAXSZ ]; then
        [ -f ${LOGFILE}.1 ] && mv ${LOGFILE}.1 ${LOGFILE}.2
        mv $LOGFILE ${LOGFILE}.1
        : > $LOGFILE
    fi
    echo "$1 [`date "+%Y-%m-%d %H:%M:%S"`] fwupdate[$$]:$dry $2" >> $LOGFILE
    ) 2>/dev/null
}

log_emit()
{
    local pref=$1
    shift
    do_log_emit $pref "$*" || true
}

log_info()
{
    log_emit I "$*"
}

log_debug()
{
    log_emit D "$*"
}

log_error()
{
    local emit=0

    if [ "X-$1" = "X--e" ]; then
        emit=1
        shift
    fi
    log_emit E "$*"
    if [ $emit -ne 0 ]; then
        echo "$*" >&2
    fi
}

fatal()
{
    log_error -e "FATAL: $1"
    exit 1
}

fatal_err()
{
    log_error -e "FATAL: $1: `head -1 $ERR`"
    exit 1
}

log_eval()
{
    local x res
    local want_echo=1

    if [ "X-$1" = "X--n" ]; then
        want_echo=0
        shift
    fi
    set -o pipefail
    eval "$@" 2>&1 |
    while read x; do
        log_info "$x"
        if [ $want_echo -ne 0 ]; then
            echo $x
        fi
    done
    res=$?
    set +o pipefail
    return $res
}

# Globals
PKG=""
DRY_RUN=""
INSTALL_IMAGES=""
IGNORE_MISSING=0
WANT_STARTUP=""
FROM_LEGACY=0
TO_LEGACY=0
IS_CUSTOM_INSTALLER=0
VERIFY_FWNAME=""
SKIP_BITFILES=0
CPLD_IGNORE_REV=0
D=""

# Legacy support
fwobj_to_fwtype=fwobj_to_fwtype
fwtype_to_files=fwtype_to_files
file_to_target=file_to_target

CPLDRESET=$R/tmp/cpldreset
CACHEFILE=$R/var/run/fwupdate.cache

D=$R/tmp/update$$
RESETFLAG=$R/tmp/fwresetflag
MANIFEST=$D/MANIFEST
INSTALLER=$D/installer
ERR=$D/err.out
TMPFILE=$D/tmpfile
FRU=$R/tmp/fru.json

mkdir -p $D

finish() {
    pcie_reset_release
    rm -rf $D
    release_lock
}
trap finish EXIT
trap "" INT QUIT PIPE HUP TSTP

main()
{
    local action need_pkg opt

    set +o pipefail

    action=NONE
    need_pkg=0
    if [ "X-$1" = "X---from-legacy" ]; then
        FROM_LEGACY=1
        MTDPART_MAINFWB=altfw
        MTDPART_UBOOT=uboot
        shift
    elif [ "X-$1" = "X---to-legacy" ]; then
        TO_LEGACY=1
        fwobj_to_fwtype=legacy_fwobj_to_fwtype
        fwtype_to_files=legacy_fwtype_to_files
        file_to_target=legacy_file_to_target
        shift
    elif [ "X-$1" = "X---init-emmc" ]; then
        action=INIT_EMMC
        shift
    elif [ "X-$1" = "X---custom-installer" ]; then
        IS_CUSTOM_INSTALLER=1
        shift
    fi
    while getopts "i:vV:rs:SlLp:DICxRW:T:" opt; do
        case "$opt" in
        i) action=INSTALL; need_pkg=1; INSTALL_IMAGES=$OPTARG; ;;
        v) action=VERIFY_PACKAGE; need_pkg=1; ;;
        V) action=VERIFY_IMAGE; VERIFY_FWNAME=$OPTARG; ;;
        r) action=GET_RUNNING_FW; ;;
        s) action=SET_STARTUP_FW; WANT_STARTUP=$OPTARG; ;;
        S) action=SHOW_STARTUP_FW ;;
        l) action=LIST_FW; ;;
        L) action=LIST_LOADED; ;;
        C) action=WRITE_CACHEFILE; ;;
        p) PKG=$OPTARG; ;;
        D) DRY_RUN=dry_run; ;;
        I) IGNORE_MISSING=1; ;;
        x) SKIP_BITFILES=1 ;;
        R) CPLD_IGNORE_REV=1 ;;
        W) LOCK_OPT=$OPTARG; ;;
        T) LOCK_TIMEOUT_SECS=$OPTARG; ;;
        *) usage; ;;
        esac
    done

    if [ "$LOCK_OPT" != "wait" -a "$LOCK_OPT" != "nowait" -a \
        "$LOCK_OPT" != "break" ]; then
        usage
    fi
    # Check correctness of lock timeout
    printf "%d" "$LOCK_TIMEOUT_SECS" >/dev/null 2>&1 || usage

    if [ $need_pkg -ne 0 ]; then
        [ -z "$PKG" ] && usage
    fi

    if [ $need_pkg -ne 0 ]; then
        tar xfO $PKG MANIFEST > $MANIFEST 2>$ERR
        if [ $? -ne 0 ]; then
            log_info "BEGIN: $CMDLINE"
            fatal_err "Invalid package file"
        fi
        if [ $IS_CUSTOM_INSTALLER -eq 0 ]; then
            s=`mani_opt_value .installer`
            if [ "$s" != "null" ]; then
                log_info "Launching custom package installer"
                echo "===> Found custom package installer; launching..."
                launch_custom_installer "$@"
                if [ $? -ne 0 ]; then
                    fatal "custom installer failed"
                else
                    return 0
                fi
            fi
        fi
        s=`mani_opt_value .installer.resources`
        if [ "$s" != "null" ]; then
            extract_resources
            export PATH=$D/bin:$PATH
            export FWUPDATE_RESOURCES=$D
        fi
    fi

    # Skip cpld operations for systems with missing or incompatible cpldapp
    if which cpldapp >/dev/null 2>&1; then
        r=`printf "%d" \`cpldapp -r 0x0\` 2>/dev/null`
        if [ $? -ne 0 ]; then
            SKIP_BITFILES=1
        fi
    else
        SKIP_BITFILES=1
    fi

    set -e -u

    if [ $action != VERIFY_PACKAGE ]; then
        RUNNING_FW=`get_running_fwname`
        ALT_FW=`alt_fw_of $RUNNING_FW`
    fi

    case "$action" in
    NONE)
        echo "===> Nothing to do"
        ;;

    INIT_EMMC)
        init_emmc
        ;;

    VERIFY_PACKAGE)
        verify_package
        ;;

    VERIFY_IMAGE)
        verify_image
        ;;

    INSTALL)
        log_info "BEGIN $CMDLINE"
        take_lock $LOCK_OPT || fatal "Operation already in progress"
        install_images
        if [ $IS_CUSTOM_INSTALLER -eq 1 -a -x $D/bin/postinstall.sh ]; then
            log_info "Executing post-install script"
            echo "===> Executing post-install script"
            $DRY_RUN run_post_install
        fi
        log_info "END"
        ;;

    GET_RUNNING_FW)
        echo $RUNNING_FW
        ;;

    SET_STARTUP_FW)
        log_info "BEGIN $CMDLINE"
        take_lock $LOCK_OPT || fatal "Operation already in progress"
        set_startup_image
        log_info "END"
        ;;

    SHOW_STARTUP_FW)
        show_startup_image
        ;;

    LIST_FW)
        list_firmware
        ;;

    LIST_LOADED)
        list_loaded_firmware
        ;;

    WRITE_CACHEFILE)
        write_cachefile
        ;;

    *)
        ;;
    esac
}

dry_run()
{
    echo "(no action)"
}

alt_fw_of()
{
    local fwname=$1

    case "$fwname" in
    mainfwa)
        echo mainfwb
        ;;
    mainfwb|goldfw|diagfw)
        echo mainfwa
        ;;
    *)
        fatal "alt_fw_of: Unknown fwname $fwname"
        ;;
    esac
}

uptime_secs()
{
    ( cat $R/proc/uptime 2>/dev/null || echo 0 ) | sed -e 's/\..*//'
}

take_lock()
{
    local wait_op="$1"
    local pid s t_now t_lock t_held log_first

    log_info "Taking lock"
    log_first=0
    while true; do
        t_now=`uptime_secs`
        s=`cat $PIDFILE 2>/dev/null || echo "0 0"`
        set -- $s; pid=$1; t_lock=$2
        if [ $pid -eq 0 -o $pid -eq $$ ]; then
            break
        fi
        if kill -0 $pid 2>/dev/null; then
            t_held=$(( $t_now - $t_lock ))
            if [ "$wait_op" = "break" -o \
                 $t_held -gt $LOCK_TIMEOUT_SECS -o \
                 $t_held -lt 0 ]; then
                log_error "Breaking lock held for $t_held seconds" 
                break
            fi
            if [ "$wait_op" = "nowait" ]; then
                log_info "Lock already held; returning"
                return 1
            else
                if [ $log_first -eq 0 ]; then
                    log_info "Waiting for pid $pid to terminate"
                    log_first=1
                fi
                sleep 1
            fi
        else
            break
        fi
    done
    t_now=`uptime_secs`
    echo "$$ $t_now" > $PIDFILE
    log_info "Lock taken"
}

release_lock()
{
    local pid s t_lock

    s=`cat $PIDFILE 2>/dev/null || echo "0 0"`
    set -- $s; pid=$1; t_lock=$2
    if [ $pid -eq $$ ]; then
        log_info "Releasing lock"
        rm -f $PIDFILE
    fi
}

launch_custom_installer()
{
    name=`mani_opt_value ".installer.name"`
    if [ "$name" = "null" ]; then
        fatal "installer name not found"
    fi
    algo=`mani_opt_value ".installer.verify.algorithm"`
    if [ "$algo" = "null" ]; then
        fatal "installer hash algorithm not found"
    fi
    check_hash_algo "$algo"
    want_hash=`mani_opt_value ".installer.verify.hash"`
    if [ "$want_hash" = "null" ]; then
        fatal "installer hash not found"
    fi
    got_hash=`tar xfO $PKG $name | hash $algo`
    if [ "$got_hash" != "$want_hash" ]; then
        fatal "installer verifcation failed"
    fi
    tar xfO $PKG $name > $INSTALLER
    if [ $? -ne 0 ]; then
        fatal "installer extraction failed"
    fi
    chmod +x $INSTALLER
    $INSTALLER --custom-installer "$@"
}

extract_resources()
{
    name=`mani_opt_value ".installer.resources.name"`
    if [ "$name" = "null" ]; then
        fatal "resources not found"
    fi
    algo=`mani_opt_value ".installer.resources.verify.algorithm"`
    if [ "$algo" = "null" ]; then
        fatal "resources hash algorithm not found"
    fi
    check_hash_algo "$algo"
    want_hash=`mani_opt_value ".installer.resources.verify.hash"`
    if [ "$want_hash" = "null" ]; then
        fatal "resources hash not found"
    fi
    got_hash=`tar xfO $PKG $name | hash $algo`
    if [ "$got_hash" != "$want_hash" ]; then
        fatal "resources verifcation failed"
    fi
    ( tar xfO $PKG $name | ( cd $D && tar xf - ) ) 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "resource extraction failed"
    fi
}

run_post_install()
{
    local res

    set +e
    log_eval $D/bin/postinstall.sh $D $PKG $MANIFEST
    if [ $? -ne 0 ]; then
        fatal "FAILED"
    fi
    set -e
    log_info "OK"
    echo "OK"
}

# find_mmcpart_bypartuuid D4E53BE5-7DC1-4199-914C-48EDFEA92C5E
find_mmcpart_bypartuuid()
{
    local uuid=$1 i partno s

    for i in $R/sys/class/block/mmcblk0p*; do
        partno=`cat $i/partition`
        s=`sgdisk -i $partno /dev/mmcblk0 | grep Partition.unique.GUID | tr '[a-z]' '[A-Z]' | awk '{ print $NF }'`
        if [ "$s" = "$uuid" ]; then
            s=`sgdisk -i $partno /dev/mmcblk0 | grep Partition.size | awk '{ print $3 }'`
            echo $R/dev/mmcblk0p$partno $(($s * 512))
            return
        fi
    done
    fatal "find_mmcpart_bypartuuid: uuid $uuid not found"
}

# find_mtdpart_byname goldfw
find_mtdpart_byname()
{
    local s dev devsz ersz

    s=`grep "\"$1\"" $R/proc/mtd` || true
    if [ -z "$s" ]; then
        fatal "find_mtdpart_byname: $1 not found"
    fi
    dev=`echo $s | awk -F: '{ print $1 }'`
    devsz=`echo $s | awk '{ print $2 }'`
    ersz=`echo $s | awk '{ print $3 }'`
    echo $R/dev/$dev $((0x$devsz)) $((0x$ersz))
}

# get_kernel_fwname
get_kernel_fwname()
{
    local cmd s

    cmd=`cat $R/proc/cmdline`
    s=`expr "$cmd" : '.*FW_NAME=\([a-z]*\)'` || true
    if [ -z "$s" ]; then
        if [ $FROM_LEGACY -eq 0 ]; then
            fatal "get_kernel_fwname: FW_NAME not found in /proc/cmdline"
        else
            s=goldfw
        fi
    fi
    echo $s
}

# get_root_mount_uuid
get_root_mount_uuid()
{
    local c devid partno dev s

    c=`grep '/ro ' $R/proc/1/mountinfo | grep 'squashfs' | wc -l`
    if [ $c -gt 1 ]; then
        log_eval -n "cat $R/proc/1/mountinfo"
        fatal "get_root_mount_uuid: multiple root mounts found"
    fi
    devid=`grep '/ro ' $R/proc/1/mountinfo | grep 'squashfs' | awk '{ print $3 }'`
    if [ -z "$devid" ]; then
        log_eval -n "cat $R/proc/1/mountinfo"
        fatal "get_root_mount_uuid: can't find root mountinfo"
    fi
    partno=`cat $R/sys/dev/block/$devid/partition`
    dev=/dev/mmcblk0p$partno
    s=`sgdisk -i $partno /dev/mmcblk0 | grep Partition.unique.GUID | tr '[a-z]' '[A-Z]' | awk '{ print $NF }'`
    if [ -z "$s" ]; then
        fatal "get_root_mount_uuid: can't find root partition info"
    fi
    echo $s
}

# get_running_fwname
# The running firmware name comes first from the kernel's /proc/cmdline, and
# then, for mainfwa or mainfwb, from the mounted filesystem.
get_running_fwname()
{
    local fwname uuid

    fwname=`get_kernel_fwname`
    case $fwname in
    mainfwa|mainfwb)
        uuid=`get_root_mount_uuid`
        if [ $? -ne 0 ]; then
            return 1
        fi
        fwname=`partuuid_to_fwname $uuid`
        ;;
    *)
        ;;
    esac
    echo $fwname
}

# partuuid_to_image D4E53BE5-7DC1-4199-914C-48EDFEA92C5E
partuuid_to_fwname()
{
    local uuid=$1

    if [ $uuid = $IMAGE_A_PARTUUID ]; then
        echo mainfwa
    elif [ $uuid = $IMAGE_B_PARTUUID ]; then
        echo mainfwb
    else
        fatal "partuuid_to_fwname: unknown uuid $uuid"
    fi
}

to_blocks()
{
    local size=$1 blksz=$2
    echo $((($size + $blksz - 1) / $blksz))
}

mani_keys()
{
    local cmd="$1 | keys | join(\" \") | tostring"

    jq -r "$cmd" $MANIFEST
}

mani_opt_value()
{
    local cmd="$1 | tostring"

    jq -r "$cmd" $MANIFEST
}

mani_value()
{
    local cmd s

    cmd="$1 | tostring"
    s=`jq -r "$cmd" $MANIFEST`
    if [ "$s" = "null" ]; then
        fatal "mani_value: $1 not found"
    fi
    echo $s
}

mani_length()
{
    local cmd="$1 | length"

    jq -r "$cmd" $MANIFEST
}

# Given a fwname and fileobj, returns the device and partition name
file_to_target()
{
    local fwname=$1 fileobj=$2 dev="" part="" offs=0

    case "$fwname" in
    uboot)
        case "$fileobj" in
        image)
            dev=mtd
            part=$MTDPART_UBOOT
            ;;
        *)
            ;;
        esac
        ;;
    mainfwa)
        case "$fileobj" in
        kernel_fit)
            dev=mtd
            part=$MTDPART_MAINFWA
            if [ $FROM_LEGACY -eq 1 ]; then
                fatal "mainfwa not supported"
            fi
            ;;
        system_image)
            dev=mmc
            part=$IMAGE_A_PARTUUID
            ;;
        *)
            ;;
        esac
        ;;
    mainfwb)
        case "$fileobj" in
        kernel_fit)
            dev=mtd
            part=$MTDPART_MAINFWB
            if [ $FROM_LEGACY -eq 1 ]; then
                offs=14680064
            fi
            ;;
        system_image)
            dev=mmc
            part=$IMAGE_B_PARTUUID
            ;;
        *)
            ;;
        esac
        ;;
    goldfw)
        case "$fileobj" in
        kernel_fit)
            dev=mtd
            part=$MTDPART_GOLDFW
            ;;
        *)
            ;;
        esac
        ;;
    diagfw)
        case "$fileobj" in
        kernel_fit)
            dev=mtd
            part=$MTDPART_DIAGFW
            ;;
        *)
            ;;
        esac
        ;;
    *)
        ;;
    esac
    if [ -z "$dev" -o -z "$part" ]; then
        fatal "file_to_target: Unknown file object $fwname $fileobj"
    fi
    echo "$dev $part $offs"
}

# Given a fwname and fileobj, returns the device and partition name
legacy_file_to_target()
{
    local fwname=$1 fileobj=$2 dev="" part="" offs=0

    case "$fwname" in
    uboot)
        case "$fileobj" in
        image)
            dev=mtd
            part=$MTDPART_UBOOT
            ;;
        *)
            ;;
        esac
        ;;
    mainfwa)
        case "$fileobj" in
        kernel)
            dev=mtd
            part=$MTDPART_DIAGFW
            offs=65536
            ;;
        device_tree)
            dev=mtd
            part=$MTDPART_DIAGFW
            ;;
        *)
            ;;
        esac
        ;;
    goldfw)
        case "$fileobj" in
        kernel)
            dev=mtd
            part=$MTDPART_GOLDFW
            ;;
        device_tree)
            dev=mtd
            part=$MTDPART_DIAGFW
            ;;
        *)
            ;;
        esac
        ;;
    *)
        ;;
    esac
    if [ -z "$dev" -o -z "$part" ]; then
        fatal "file_to_target: Unknown file object $fwname $fileobj"
    fi
    echo "$dev $part $offs"
}

check_hash_algo()
{
    local algo=$1
    case "$algo" in
    sha256|sha512|md5) return 0; ;;
    *) fatal "hash_hash_algo: unsupported algo $algo"; ;;
    esac
}

hash()
{
    local algo=$1
    case "$algo" in
    md5)    md5sum | awk '{ print $1 }'; ;;
    sha256) sha256sum | awk '{ print $1 }'; ;;
    sha512) sha512sum | awk '{ print $1 }'; ;;
    *) fatal "hash: invalid algo $algo"; ;;
    esac
}

# Install a file to an mtd device
# install_mtd /dev/mtd1 65536 0 kernel.itb 3210112 sha...
install_mtd()
{
    local dev=$1 ersz=$2 offs=$3 path=$4 size=$5 hash=$6 algo=$7
    local blks got_hash seek

    set +e
    echo "Writing $path to $dev offset $offs ($size bytes)..."
    log_info "Writing $path to $dev offset $offs ($size bytes)"
    seek=`to_blocks $offs $ersz`
    blks=`to_blocks $size $ersz`
    echo "Erasing..."
    flash_erase -q $dev $offs $blks 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "Flash erase failed"
    fi
    echo "OK"
    echo "Writing..."
    ( tar xfO $PKG $path | dd of=$dev bs=$ersz seek=$seek status=none ) 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "Flash write failed"
    fi
    echo "OK"
    echo "Verifying..."
    got_hash=`dd if=$dev bs=$ersz skip=$seek count=$blks status=none | head -c $size | hash $algo` 2>$ERR
    if [ "$got_hash" != "$hash" ]; then
        echo "FAILED"
        fatal_err "Flash verify failed"
    fi
    echo "OK"
    log_info "OK"
    set -e
}

# Install a file to an mmc device
# install_mmc /dev/mmcblk0p3 rootfs.squashfs 80244736 sha...
install_mmc()
{
    local dev=$1 path=$2 size=$3 hash=$4 algo=$5
    local dblks got_hash

    set +e
    echo "Writing $path to $dev ($size bytes)..."
    log_info "Writing $path to $dev ($size bytes)"
    echo "Writing..."
    tar xfO $PKG $path | dd of=$dev status=none 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "MMC write failed"
    fi
    echo "OK"
    echo "Verifying..."
    dblks=`to_blocks $size 512`
    got_hash=`dd if=$dev bs=512 count=$dblks status=none | head -c $size | hash $algo` 2>$ERR
    if [ "$got_hash" != "$hash" ]; then
        echo "FAILED"
        fatal_err "MMC verify failed"
    fi
    echo "OK"
    log_info "OK"
    set -e
}

# Return the component files of a firmware type, in the order they are
# installed (mtd last).  The last object will be the one invalidated before
# the others are installed, and thus validates the whole install.
fwtype_to_files()
{
    fwtype=$1
    case "$fwtype" in
    uboot)      echo "image"; ;;
    syslinux)   echo "system_image kernel_fit"; ;;
    linux)      echo "kernel_fit"; ;;
    *)          fatal "fwtype_to_files: unknown fwtype $fwtype"; ;;
    esac
}

fwobj_to_fwtype()
{
    fwobj=$1
    case "$fwobj" in
    boot)       echo "uboot"; ;;
    main)       echo "syslinux"; ;;
    gold)       echo "linux"; ;;
    diags)      echo "linux"; ;;
    *)          fatal "fwobj_to_fwtype: unknown fwobj $fwobj"
    esac
}

legacy_fwtype_to_files()
{
    fwtype=$1
    case "$fwtype" in
    uboot)      echo "image"; ;;
    linux)      echo "device_tree kernel"; ;;
    *)          fatal "legecy_fwtype_to_files: unknown fwtype $fwtype"; ;;
    esac
}

legacy_fwobj_to_fwtype()
{
    fwobj=$1
    case "$fwobj" in
    boot)       echo "uboot"; ;;
    main)       echo "linux"; ;;
    gold)       echo "linux"; ;;
    diags)      echo "linux"; ;;
    *)          fatal "legacy_fwobj_to_fwtype: unknown fwobj $fwobj"
    esac
}

# Verify the contents of a naples_fw.tar file
verify_package_firmware()
{
    local fwobj want_type want_files remainder found i fileobj
    local fileobj path algo want_hash got_hash

    for fwobj in `mani_keys .firmware`; do
        #
        # File collection verification
        #
        want_type=`$fwobj_to_fwtype $fwobj`
        want_files=`$fwtype_to_files $want_type`
        if [ `mani_value .firmware.$fwobj.type` != $want_type ]; then
            fatal "verify_package_firmware: $fwobj: invalid image type"
        fi
        for fileobj in `mani_keys ".firmware.$fwobj.files"`; do
            remainder=""
            found=0
            for i in $want_files; do
                if [ "$i" = "$fileobj" ]; then
                    found=1
                else
                    remainder="$remainder $i"
                fi
            done
            if [ ! $found ]; then
                fatal "verify_package_firmware: $fwobj: unexpected file type $fileobj"
            fi
            want_files=$remainder
        done
        if [ ! -z "$want_files" ]; then
            fatal "verify_package_firmware: $fwobj: expected file type $want_files not found"
        fi

        #
        # File data verification
        #
        for fileobj in `mani_keys ".firmware.$fwobj.files"`; do
            path=`mani_opt_value ".firmware.$fwobj.files.$fileobj.name"`
            if [ "$path" = "null" ]; then
                fatal "verify_package_firmware: $fwobj: required file data not found"
            fi
            echo "Verifying package file: $path..."
            algo=`mani_opt_value ".firmware.$fwobj.files.$fileobj.verify.algorithm"`
            if [ "$algo" = "null" ]; then
                fatal "verify_package_firmware: $path: required hash algorithm not found"
            fi
            check_hash_algo "$algo"
            want_hash=`mani_opt_value ".firmware.$fwobj.files.$fileobj.verify.hash"`
            if [ "$want_hash" = "null" ]; then
                fatal "verify_package_firmware: $path: required hash value not found"
            fi
            got_hash=`tar xfO $PKG $path | hash $algo`
            if [ "$got_hash" != "$want_hash" ]; then
                echo "FAILED"
                fatal "verify_package_firmware: $path: verifcation failed"
            fi
            echo "OK"
        done
    done
}

verify_package_bitfiles()
{
    local bitfileslength counter path algo want_hash got_hash

    bitfileslength=`mani_length .bitfiles`
    for counter in `seq 1 $bitfileslength`
    do
        #path=`jq -r ".bitfiles[$counter - 1].name" $MANIFEST`
        path=`mani_value ".bitfiles[$counter - 1].name"`
        if [ "$path" = "null" ]; then
            fatal "verify_package_bitfiles: required file data not found"
        fi
        echo "Verifying bitfile file: $path..."
        algo=`mani_value ".bitfiles[$counter - 1].verify.algorithm"`
        if [ "$algo" = "null" ]; then
            fatal "verify_package_bitfiles: $path: required hash algorithm not found"
        fi
        want_hash=`mani_value ".bitfiles[$counter - 1].verify.hash"`
        if [ "$want_hash" = "null" ]; then
            fatal "verify_package_bitfiles: $path: required hash value not found"
        fi
        got_hash=`tar xfO $PKG $path | hash $algo`
        if [ "$got_hash" != "$want_hash" ]; then
            echo "FAILED"
            fatal "verify_package_bitfiles: $path: verifcation failed"
        fi
        echo "OK"
    done
}

# Verify the contents of a naples_fw.tar file
verify_package()
{
    local content=0
    echo "===> Verifying package"
    log_info "Verifying package"
    swver=`mani_opt_value ".software_version"`
    if [ "$swver" != "null" ]; then
        log_info "Software version $swver"
    fi
    if [ `mani_length .firmware` -ne 0 ]; then
        content=1
        verify_package_firmware
    fi
    if [ `mani_length .bitfiles` -ne 0 ]; then
        content=1
        verify_package_bitfiles
    fi
    if [ $content -eq 0 ]; then
        fatal "verify_package: No content"
    fi
    echo "Package file OK"
}

do_install_file()
{
    local fwname=$1 fwobj=$2 fileobj=$3 path=$4 hash=$5 algo=$6
    local size dev part offs devsz ersz s

    size=`tar tvf $PKG $path | awk '{ print $3 }'`
    echo "===> Install $fwname $fileobj $path ($size bytes)"
    s=`$file_to_target $fwname $fileobj`; set -- $s; dev=$1; part=$2; offs=$3
    case "$dev" in
    mtd)
        s=`find_mtdpart_byname $part`; set -- $s; dev=$1; devsz=$2; ersz=$3
        if [ $size -gt $devsz ]; then
            fatal "Image too big for partition"
        fi
        $DRY_RUN install_mtd $dev $ersz $offs $path $size $hash $algo
        ;;
    mmc)
        s=`find_mmcpart_bypartuuid $part`; set -- $s; dev=$1; devsz=$2
        if [ $size -gt $devsz ]; then
            fatal "Image too big for partition"
        fi
        $DRY_RUN install_mmc $dev $path $size $hash $algo
        ;;
    *)
        fatal "do_install_file: Invalid install device $dev"
        ;;
    esac
}

# Verify the integrity of an installed image
do_verify_image()
{
    local fwname=$1
    local fwobj fwtype files fileobj size
    local s dev part offs f path devsz ersz
    local algo hash got_hash blks dblks

    fwobj=`fwname_to_fwobj $fwname`
    fwtype=`$fwobj_to_fwtype $fwobj`
    files=`$fwtype_to_files $fwtype`
    for f in $files; do
        echo "Verifying $f..."
        s=`$file_to_target $fwname $f`; set -- $s; dev=$1; part=$2; offs=$3
        case "$dev" in
        mtd)
            s=`find_mtdpart_byname $part`; set -- $s; path=$1; devsz=$2; ersz=$3
            ;;
        mmc)
            s=`find_mmcpart_bypartuuid $part`; set -- $s; path=$1; devsz=$2
            ;;
        *)
            fatal "verify_image: unexpected dev $dev"
            ;;
        esac
        case "$f" in
        image)
            if [ $fwname != uboot ]; then
                fatal "verify_image: non-uboot image not supported"
            fi
            s=`get_uboot_info $path`; set -- $s; size=$1; algo=$2; hash=$3
            ;;
        system_image)
            s=`get_system_image_info $path`; set -- $s; size=$1; algo=$2; hash=$3
            ;;
        kernel_fit)
            s=`get_kernel_fit_info $path`; set -- $s; size=$1; algo=$2; hash=$3
            ;;
        *)
            fatal "verify_image: unexpected file $f"
            ;;
        esac
        case "$dev" in
        mtd)
            s=`find_mtdpart_byname $part`; set -- $s; path=$1; devsz=$2; ersz=$3
            blks=`to_blocks $size $ersz`
            got_hash=`dd if=$path bs=$ersz count=$blks status=none | head -c $size | hash $algo`
            ;;
        mmc)
            s=`find_mmcpart_bypartuuid $part`; set -- $s; path=$1; devsz=$2
            dblks=`to_blocks $size 512`
            got_hash=`dd if=$path bs=512 count=$dblks status=none | head -c $size | hash $algo`
            ;;
        *)
            fatal "verify_image: unexpected dev $dev"
            ;;
        esac
        if [ "$got_hash" != "$hash" ]; then
            echo "FAILED"
            fatal "verify_image: Verify failed"
        fi
        echo "OK"
    done
}

verify_image()
{
    local fwname=$VERIFY_FWNAME

    case "$fwname" in
    uboot|mainfwa|mainfwb|goldfw|diagfw)
        ;;
    altfw)
        fwname=$ALT_FW
        ;;
    *)
        fatal "verify_image: Unknown image name $fwname"
        ;;
    esac
    echo "===> Verifying target image $fwname"
    do_verify_image $fwname
}

invalidate_mtd()
{
    local dev=$1 offs=$2

    set +e
    echo "Invalidating $dev..."
    log_info "Invalidating $dev"
    flash_erase -q $dev $offs 1 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "Failed to invalidate $dev"
    fi
    echo "OK"
    set -e
}

invalidate_mmc()
{
    local dev=$1

    echo "===> Invalidating $dev..."
    dd if=/dev/zero of=$dev bs=512 count=1 status=none
    echo "OK"
}

# Invalidate the existing fwname
invalidate_fwname()
{
    local fwname=$1 fwtype=$2 files last_fileobj dev ersz part offs s

    files=`$fwtype_to_files $fwtype`
    last_fileobj=`echo $files | awk '{ print $NF }'`
    s=`$file_to_target $fwname $last_fileobj`; set -- $s; dev=$1; part=$2; offs=$3
    case "$dev" in
    mtd)
        s=`find_mtdpart_byname $part`; set -- $s; dev=$1; ersz=$3
        $DRY_RUN invalidate_mtd $dev $offs
        ;;
    mmc)
        s=`find_mmcpart_bypartuuid $part`; set -- $s; dev=$1
        $DRY_RUN invalidate_mmc $dev
        ;;
    *)
        fatal "Invalid install device $dev"
        ;;
    esac
}

# Move /sbin/reset and /nic/tools/sysreset.sh out of the way
pcie_swapin()
{
    local path=$1
    cat << EOF > ${path}.new
#!/bin/sh
echo \$0 "\$@" > $RESETFLAG
echo "Waiting for firmware update to terminate"
while kill -0 $$ 2>/dev/null; do sleep 1; done; exec $path "\$@"
EOF
    if [ $? -eq 0 ]; then
        if chmod +x ${path}.new; then
            if [ ! -f ${path}.real ]; then
                ln $path ${path}.real
            fi
            test -f ${path}.real && mv ${path}.new $path
        fi
    else
        rm -f ${path}.new
    fi
}

pcie_swapout()
{
    local path=$1
    if [ -f ${path}.real ]; then
        mv ${path}.real $path || true
    fi
}

pcie_reset_hold()
{
    rm -f $RESETFLAG
    pcie_swapin $R/sbin/reboot
    pcie_swapin $R/nic/tools/sysreset.sh
}

pcie_reset_release()
{
    local op

    pcie_swapout $R/sbin/reboot
    pcie_swapout $R/nic/tools/sysreset.sh
    if [ -f $RESETFLAG ]; then
        rm -rf $D
        op=`cat $RESETFLAG`
        log_info "Delayed operation will occur: $op"
        rm -f $RESETFLAG
        return 1
    fi
}

# Critical sections
critical_section_begin()
{
    local fwtype=$1
    if [ "$DRY_RUN" != "" ]; then
        return
    fi
    case "$fwtype" in
    uboot|cpld)
        pcie_reset_hold || true
        ;;
    *)
        ;;
    esac
}

critical_section_end()
{
    local fwtype=$1
    if [ "$DRY_RUN" != "" ]; then
        return
    fi
    case "$fwtype" in
    uboot|cpld)
        pcie_reset_release
        ;;
    *)
        ;;
    esac
}

# Install a single fileobj into fwname
install_fwobj()
{
    local fwobj=$1 fwname=$2 fwtype fileobj path algo hash

    fwtype=`mani_opt_value ".firmware.$fwobj.type"`
    if [ "$fwtype" = "null" ]; then
        if [ $IGNORE_MISSING -eq 0 ]; then
            fatal "image $fwobj not found"
        fi
        return
    fi
    echo "===> Installing $fwname"
    critical_section_begin $fwtype
    invalidate_fwname $fwname $fwtype
    for fileobj in `$fwtype_to_files $fwtype`; do
        path=`mani_value ".firmware.$fwobj.files.$fileobj.name"`
        algo=`mani_value ".firmware.$fwobj.files.$fileobj.verify.algorithm"`
        check_hash_algo "$algo"
        hash=`mani_value ".firmware.$fwobj.files.$fileobj.verify.hash"`
        do_install_file $fwname $fwobj $fileobj $path $hash $algo
    done
    critical_section_end $fwtype || fatal "Aborted due to pending reset"
}

# Install a bitfile to the CPLD
install_cpld_bitfile()
{
    local path=$1
    local status

    set +e
    log_info "Writing CPLD bitfile $path"
    rm -f $TMPFILE
    tar xfO $PKG $path > $TMPFILE 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "install_cpld_bitfile: $path failed"
    fi
    if [ ! -s $TMPFILE ]; then
        fatal "install_cpld_bitfile: $path invalid file"
    fi
    log_eval cpldapp -writeflash $TMPFILE
    status=$?
    rm -f $TMPFILE
    if [ $status -eq 0 ]; then
        echo "OK"
        log_info "OK"
        touch $CPLDRESET
    else
        fatal "install_cpld_bitfile: cpld program FAILED"
    fi
    set -e
}

fwname_to_fwobj()
{
    case "$1" in
    mainfwa)    echo main;  ;;
    mainfwb)    echo main;  ;;
    goldfw)     echo gold;  ;;
    diagfw)     echo diags; ;;
    uboot)      echo boot;  ;;
    *)          fatal "fwname_to_fwobj: unknown fwname $1"
    esac
}

check_install_list()
{
    local fwname

    for fwname in $INSTALL_IMAGES; do
        case $fwname in
        mainfwa|mainfwb)
            if [ $RUNNING_FW = $fwname ]; then
                fatal "check_install_list: Cannot install over running firmware"
            fi
            ;;
        altfw|goldfw|diagfw|uboot|cpld)
            ;;
        all)
            INSTALL_IMAGES="altfw goldfw diagfw uboot cpld"
            IGNORE_MISSING=1
            ;;
        *)
            fatal "check_install_list: Unknown firmware name $fwname"
            ;;
        esac
    done
}

do_install_firmware_images()
{
    local fwname fwobj

    # Iterate over the desired images
    for fwname in $INSTALL_IMAGES; do
        if [ $fwname = "altfw" ]; then
            fwname=$ALT_FW
        fi
        fwobj=`fwname_to_fwobj $fwname`
        install_fwobj $fwobj $fwname
    done
}

do_install_bitfile_images()
{
    local running_cpld_rev part_number bitfileslength partnumberlength i
    local bitfile_cpld_rev manipartnumber found mani_cpld_rev path

    # Get current id and revision of CPLD.
    running_cpld_rev=`printf "%d" \`cpldapp -r 0x0\``

    # Get the part number of the system.
    part_number=`jq -r '.["part-number"]' $FRU | awk -F'[ -]' '{print $1"-"$2}'`

    bitfileslength=`mani_length .bitfiles`
    found=0
    for counter in `seq 1 $bitfileslength`
    do
        partnumberlength=`mani_length ".bitfiles[$counter - 1].partnumber"`
        bitfile_cpld_rev=`mani_value ".bitfiles[$counter - 1].version"`
        # Bit 7 of the running and candidate CPLD revisions must match
        if [ $((($running_cpld_rev ^ $bitfile_cpld_rev) & 0x80)) -ne 0 ]; then
            continue
        fi
        for i in `seq 1 $partnumberlength`
        do
            manipartnumber=`mani_value ".bitfiles[$counter - 1].partnumber[$i - 1]"`
            if [ $part_number = $manipartnumber ]; then
                # Break out of the loop since we found the image.
                found=1
                break 2
            fi
        done
    done
    if [ $found -eq 0 ]; then
        # Nothing CPLD image present for this card
        echo "===> No bitfile update required"
        return
    fi

    # Found a CPLD image for this card.  Check the version.
    mani_cpld_rev=`mani_value ".bitfiles[$counter - 1].version"`
    if [ $CPLD_IGNORE_REV -eq 0 -a $running_cpld_rev -ge $mani_cpld_rev ]; then
        return
    fi
    echo "===> Commit install CPLD rev $mani_cpld_rev over rev $running_cpld_rev"
    path=`mani_value ".bitfiles[$counter - 1].name"`
    echo "===> Install bitfile image $path"
    critical_section_begin cpld
    $DRY_RUN install_cpld_bitfile $path
    critical_section_end cpld || fatal "Aborted due to pending reset"
}

do_install_images()
{
    local fwname fwobj

    # Iterate over the desired images
    for fwname in $INSTALL_IMAGES; do
        if [ $fwname = "altfw" ]; then
            fwname=$ALT_FW
        fi
        if [ $fwname = "cpld" ]; then
            if [ $SKIP_BITFILES -eq 0 ]; then
                do_install_bitfile_images
            fi
        else
            fwobj=`fwname_to_fwobj $fwname`
            install_fwobj $fwobj $fwname
        fi
    done
}

install_images()
{
    if [ $FROM_LEGACY -eq 1 ]; then
        INSTALL_IMAGES="mainfwb goldfw uboot"
        IGNORE_MISSING=1
    elif [ $TO_LEGACY -eq 1 ]; then
        INSTALL_IMAGES="mainfwa goldfw uboot"
        IGNORE_MISSING=1
    else
        # Check the install list to make sure its ok
        check_install_list
    fi

    # Verify the package
    verify_package

    # First-time install
    if [ $FROM_LEGACY -eq 1 ]; then
        setup_partitions
    fi

    if [ "$DRY_RUN" = "" ]; then
        # First do a dry-run install
        echo "===> Dry-Run Install"
        DRY_RUN=dry_run
        do_install_images
        ALT_FW=`alt_fw_of $RUNNING_FW`
        DRY_RUN=""
        echo "===> Real Install"
        SKIP_PKGVERIFY=1
    fi
    do_install_images
}

do_set_startup_image()
{
    local fwname=$1 dev devsz s

    echo "===> Verifying target startup image $fwname"
    log_info "Verifying target startup image $fwname"
    do_verify_image $fwname

    echo "===> Setting startup firmware to $fwname"
    s=`find_mtdpart_byname $MTDPART_FWSEL`; set -- $s; dev=$1
    set +e
    flash_erase -q $dev 0 1 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "Flash erase failed"
    fi
    ( echo -n $fwname | dd of=$dev status=none ) 2>$ERR
    if [ $? -ne 0 ]; then
        fatal_err "Flash write failed"
    fi
    s=`jq -r -M ".software_version" $TMPFILE`
    if [ "$s" != "null" ]; then
        log_info "New startup image version $s"
    fi
    echo "OK"
    set -e
}

set_startup_image()
{
    local fwname

    fwname=$WANT_STARTUP
    case "$fwname" in
    mainfwa|mainfwb|goldfw|diagfw)
        ;;
    altfw)
        fwname=$ALT_FW
        ;;
    *)
        fatal "set_startup_image: Unknown image name $fwname"
        ;;
    esac
    $DRY_RUN do_set_startup_image $fwname
}

show_startup_image()
{
    local dev s

    s=`find_mtdpart_byname $MTDPART_FWSEL`; set -- $s; dev=$1
    s=`dd if=$dev bs=8 count=1 status=none | tr -d '\377'`
    case "$s" in
    mainfwa|mainfwb|goldfw|diagfw)
        ;;
    *)
        s=mainfwa
    esac
    echo $s
}

extract_meta()
{
    local infile=$1 offs=$2 outfile=$3
    local FILE_META_MAGIC=0x55ffa330

    set -- `dd if=$infile bs=1 skip=$offs count=8 status=none | od -t x4 | head -1`
    magic=0x$2
    if [ $magic != $FILE_META_MAGIC ]; then
        return 1
    fi
    len=$((0x$3))
    dd if=$infile bs=1 skip=$(($offs + 8)) count=$len status=none > $outfile
}

get_uboot_info()
{
    local UBOOT_SIZE_MAGIC=0xfb89090a
    local dev=$1 u_magic u_len
    set -- `dd if=$dev bs=16 count=1 status=none | od -t x4 | head -1`
    u_magic=0x$3
    if [ $u_magic != $UBOOT_SIZE_MAGIC ]; then
        log_error -e "uboot magic not found"
        return 1
    fi
    u_len=$((0x$4))
    if extract_meta $dev $u_len $TMPFILE; then
        echo $u_len
        jq -r -M ".verify.algorithm, .verify.hash" $TMPFILE
    else
        log_error -e "uboot metadata not found"
        return 1
    fi
}

get_kernel_fit_info()
{
    local KERNEL_ITB_MAGIC=0xd00dfeed
    local dev=$1 v k_magic k_len
    set -- `dd if=$dev bs=4 count=2 status=none | od -t x1 | head -1`
    v=$(((0x$2 << 24) + (0x$3 << 16) + (0x$4 << 8) + 0x$5))
    k_magic=`printf "0x%08x\n" $v`
    if [ $k_magic != $KERNEL_ITB_MAGIC ]; then
        log_error -e "kernel_fit magic not found"
        return 1
    fi
    k_len=$(((0x$6 << 24) + (0x$7 << 16) + (0x$8 << 8) + 0x$9))
    if extract_meta $dev $k_len $TMPFILE; then
        echo $k_len
        jq -r -M ".verify.algorithm, .verify.hash" $TMPFILE
    else
        log_error -e "kernel_fit metadata not found"
        return 1
    fi
}

get_system_image_info()
{
    local SQUASHFS_MAGIC=0x73717368
    local dev=$1 s_magic s_len
    set -- `dd if=$dev bs=4 count=1 status=none | od -t x4 | head -1`
    s_magic=0x$2
    if [ $s_magic != $SQUASHFS_MAGIC ]; then
        log_error -e "system_info magic not found"
        return 1
    fi
    set -- `dd if=$dev bs=8 skip=5 count=1 status=none | od -t x8 | head -1`
    s_len=$(((0x$2 + 4095) & -4096))
    if extract_meta $dev $s_len $TMPFILE; then
        echo $s_len
        jq -r -M ".verify.algorithm, .verify.hash" $TMPFILE
    else
        log_error -e "system_image metadata not found"
        return 1
    fi
}

show_meta()
{
    jq -r "del(.verify)" $TMPFILE | \
    jq -r "del(.metadata_version)" | sed -e '1d' -e '$d'
}

JPREF=""
JFPREF=""
do_list_uboot_image()
{
    local dev=$1
    if get_uboot_info $dev >/dev/null 2>&1; then
        cat << EOF
        $JPREF "image": {
            `show_meta`
        }
EOF
        JPREF=,
    fi
}

do_list_system_image()
{
    local dev=$1
    if get_system_image_info $dev >/dev/null 2>&1; then
        cat << EOF
        $JPREF "system_image": {
            `show_meta`
        }
EOF
    JPREF=,
    fi
}

do_list_kernel_fit()
{
    local dev=$1
    if get_kernel_fit_info $dev >/dev/null 2>&1; then
        cat << EOF
        $JPREF "kernel_fit": {
            `show_meta`
        }
EOF
    JPREF=,
    fi
}

do_list_firmware()
{
    local fwname=$1 fwobj fwtype files dev part f s

    echo "    $JFPREF \"$fwname\": {"
    fwobj=`fwname_to_fwobj $fwname`
    fwtype=`$fwobj_to_fwtype $fwobj`
    files=`$fwtype_to_files $fwtype`
    for f in $files; do
        s=`$file_to_target $fwname $f`; set -- $s; dev=$1; part=$2
        case "$dev" in
        mtd)
            s=`find_mtdpart_byname $part`; set -- $s; dev=$1; devsz=$2; ersz=$3
            ;;
        mmc)
            s=`find_mmcpart_bypartuuid $part`; set -- $s; dev=$1; devsz=$2
            ;;
        *)
            fatal "do_list_firmware: unexpected dev $dev"
            ;;
        esac
        case $f in
        image)
            if [ $fwtype != uboot ]; then
                fatal "do_list_firmware: non-uboot image not supported"
            fi
            do_list_uboot_image $dev
            ;;
        system_image)
            do_list_system_image $dev
            ;;
        kernel_fit)
            do_list_kernel_fit $dev
            ;;
        *)
            fatal "do_list_firmware: unexpected file $f"
            ;;
        esac
    done
    echo "    }"
    JFPREF=","
}

do_list_cpld()
{
    local cpld_rev=`printf "%d" \`cpldapp -r 0x0\``
    cat << EOF
    $JFPREF "cpld": {
        "bitfile": {
        "version": "$cpld_rev"
        }
    }
EOF
    JFPREF=","
}

list_firmware()
{
    local fwname

    (
    echo "{"
    for fwname in uboot mainfwa mainfwb goldfw diagfw; do
        JPREF=""
        do_list_firmware $fwname
    done
    if [ $SKIP_BITFILES -eq 0 ]; then
        do_list_cpld
    fi
    echo "}"
    ) | jq -r -M .
}

write_cachefile()
{
    list_firmware > $CACHEFILE
}

# The list of running firmware comes from /var/run/fwupdate.cache
# which is created at startup.  Firmware update operations can
# proceed to overwrite these images that we booted from, so
# the cache ensures that we always have a record of where we came from
list_loaded_firmware()
{
    if [ ! -f $CACHEFILE ]; then
        fatal "$CACHEFILE not found"
        exit 1
    fi
    local fwname s
    (
        echo "{ \"uboot\":"
        fwname=`get_kernel_fwname`
        jq -r -M .uboot $CACHEFILE
        echo ","
        case "$fwname" in
        mainfwa|mainfwb)
            # Pull the kernel from the fwupdate.cache, but determine
            # the currently mounted filesystem
            echo "\"$RUNNING_FW\":"
            echo '{ "kernel_fit":'
            jq -r -M .$fwname.kernel_fit $CACHEFILE
            echo ', "system_image":'
            (
                echo {
                do_list_firmware $RUNNING_FW
                echo }
            ) | jq -r -M .$RUNNING_FW.system_image
            echo }
            ;;
        *)
            echo "\"$fwname\":"
            jq -r -M  .$fwname $CACHEFILE
            ;;
        esac
        s=`jq -r ".cpld | tostring" $CACHEFILE`
        if [ "$s" != "null" ]; then
            echo ", \"cpld\":"
            jq -r -M .cpld $CACHEFILE
        fi
        echo "}"
    ) | jq -r -M .
}

do_setup_partitions()
{
    set +e
    echo "Writing new partition table"
    sgdisk -Z /dev/mmcblk0 >/dev/null 2>&1
    partprobe >/dev/null 2>&1
    sgdisk -n  1:+0:+32M  -t  1:ef02 -u  1:DDCB67EF-E6CD-4AB8-BF67-C08DBD5A7471 -c  1:"Kernel Image A" \
           -n  2:+0:+32M  -t  2:ef02 -u  2:4703283B-DFA1-4376-B589-08E8FFE84B80 -c  2:"Kernel Image B" \
           -n  3:+0:+1G   -t  3:8300 -u  3:D4E53BE5-7DC1-4199-914C-48EDFEA92C5E -c  3:"System Image A" \
           -n  4:+0:+1G   -t  4:8300 -u  4:E2FD6D28-3300-4979-8062-B8AB599F3898 -c  4:"System Image B" \
           -n  5:+0:+1G   -t  5:8300 -u  5:2167CFC4-39B0-4138-8F30-7A474A50A220 -c  5:"Update Filesystem" \
           -n  6:+0:+16M  -t  6:8300 -u  6:7B1C657D-A19D-49A7-83B7-F75CC9E5567D -c  6:"Config0 Filesystem" \
           -n  7:+0:+16M  -t  7:8300 -u  7:C7289808-0214-4E13-B014-9FFD4D351614 -c  7:"Config1 Filesystem" \
           -n  8:+0:+256M -t  8:8300 -u  8:F593C2F9-B18C-4943-8E3C-11128EE48E5D -c  8:"OBFL Filesystem" \
           -n  9:+0:+128M -t  9:ef02 -u  9:716C78BC-CB0E-48D5-B8CC-2D4AF139DA28 -c  9:"Reserved" \
           -n 10:+0:0     -t 10:8300 -u 10:6ED62003-DD8D-44B8-9538-0A2B7C7E628F -c 10:"Data Filesystem" \
           /dev/mmcblk0 >/dev/null
    while true; do
        partprobe
        if [ -e $R/dev/mmcblk0p8 ]; then
            break
        fi
        sleep 1
    done
    for p in 5 6 7 8 10; do
        d=/dev/mmcblk0p$p
        echo "Creating EXT4 filesystem on $d"
        mkfs.ext4 $d >/dev/null 2>&1
    done
    echo "Done"
    set -e
}

setup_partitions()
{
    echo "===> Setting up /dev/mmcblk0 for the first time"
    $DRY_RUN do_setup_partitions
}

init_emmc()
{
    case "$RUNNING_FW" in
    goldfw|diagfw)
        setup_partitions
        ;;

    *)
        fatal "init_emmc: cannot init emmc while using it"
        ;;
    esac
}

set -o pipefail
main "$@" 2>&1 |
(
    IFS='<newline>'
    while read x; do
        echo "$x" || true
    done
)
