// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sysmgr.proto

/*
Package sysmgr is a generated protocol buffer package.

It is generated from these files:
	sysmgr.proto

It has these top-level messages:
	SysmgrShutdownReq
	SysmgrShutdownStatus
	SysmgrRebootReq
	SysmgrServiceStatus
	SysmgrServiceSpec
	SysmgrProcessStatus
	SysmgrSystemStatus
*/
package sysmgr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ProcessState int32

const (
	ProcessState_Waiting  ProcessState = 0
	ProcessState_Ready    ProcessState = 1
	ProcessState_Launched ProcessState = 2
	ProcessState_Running  ProcessState = 3
	ProcessState_Died     ProcessState = 4
)

var ProcessState_name = map[int32]string{
	0: "Waiting",
	1: "Ready",
	2: "Launched",
	3: "Running",
	4: "Died",
}
var ProcessState_value = map[string]int32{
	"Waiting":  0,
	"Ready":    1,
	"Launched": 2,
	"Running":  3,
	"Died":     4,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}
func (ProcessState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SystemState int32

const (
	SystemState_Normal SystemState = 0
	SystemState_Fault  SystemState = 1
)

var SystemState_name = map[int32]string{
	0: "Normal",
	1: "Fault",
}
var SystemState_value = map[string]int32{
	"Normal": 0,
	"Fault":  1,
}

func (x SystemState) String() string {
	return proto.EnumName(SystemState_name, int32(x))
}
func (SystemState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type SysmgrShutdownReq struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *SysmgrShutdownReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrShutdownReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrShutdownReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrShutdownReq) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrShutdownReq) GetDelphiKind() string {
	return "SysmgrShutdownReq"
}

func (m *SysmgrShutdownReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrShutdownReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrShutdownReq)
	return obj
}

func SysmgrShutdownReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrShutdownReq", mode)
}

func SysmgrShutdownReqMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrShutdownReq", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrShutdownReq(client clientApi.Client, key string) *SysmgrShutdownReq {
	o := client.GetObject("SysmgrShutdownReq", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrShutdownReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrShutdownReq) IsPersistent() bool {
	return false
}
func SysmgrShutdownReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrShutdownReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrShutdownReqWatch(client clientApi.Client, reactor SysmgrShutdownReqReactor) {
	client.WatchKind("SysmgrShutdownReq", reactor)
}
func SysmgrShutdownReqList(client clientApi.Client) []*SysmgrShutdownReq {
	bobjs := client.List("SysmgrShutdownReq")
	objs := make([]*SysmgrShutdownReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrShutdownReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrShutdownReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrShutdownReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrShutdownReqCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrShutdownReq)
				if ok == false {
					panic("Not an SysmgrShutdownReq object")
				}
				rctr.OnSysmgrShutdownReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrShutdownReqDelete(m)
		}
	}
}

type SysmgrShutdownReqReactor interface {
	OnSysmgrShutdownReqCreate(obj *SysmgrShutdownReq)
	OnSysmgrShutdownReqUpdate(old *SysmgrShutdownReq, obj *SysmgrShutdownReq)
	OnSysmgrShutdownReqDelete(obj *SysmgrShutdownReq)
}

func (m *SysmgrShutdownReq) Reset()                    { *m = SysmgrShutdownReq{} }
func (m *SysmgrShutdownReq) String() string            { return proto.CompactTextString(m) }
func (*SysmgrShutdownReq) ProtoMessage()               {}
func (*SysmgrShutdownReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SysmgrShutdownReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrShutdownReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type SysmgrShutdownStatus struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrShutdownStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrShutdownStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrShutdownStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrShutdownStatus) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrShutdownStatus) GetDelphiKind() string {
	return "SysmgrShutdownStatus"
}

func (m *SysmgrShutdownStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrShutdownStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrShutdownStatus)
	return obj
}

func SysmgrShutdownStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrShutdownStatus", mode)
}

func SysmgrShutdownStatusMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrShutdownStatus", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrShutdownStatus(client clientApi.Client, key string) *SysmgrShutdownStatus {
	o := client.GetObject("SysmgrShutdownStatus", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrShutdownStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrShutdownStatus) IsPersistent() bool {
	return false
}
func SysmgrShutdownStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrShutdownStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrShutdownStatusWatch(client clientApi.Client, reactor SysmgrShutdownStatusReactor) {
	client.WatchKind("SysmgrShutdownStatus", reactor)
}
func SysmgrShutdownStatusList(client clientApi.Client) []*SysmgrShutdownStatus {
	bobjs := client.List("SysmgrShutdownStatus")
	objs := make([]*SysmgrShutdownStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrShutdownStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrShutdownStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrShutdownStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrShutdownStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrShutdownStatus)
				if ok == false {
					panic("Not an SysmgrShutdownStatus object")
				}
				rctr.OnSysmgrShutdownStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrShutdownStatusDelete(m)
		}
	}
}

type SysmgrShutdownStatusReactor interface {
	OnSysmgrShutdownStatusCreate(obj *SysmgrShutdownStatus)
	OnSysmgrShutdownStatusUpdate(old *SysmgrShutdownStatus, obj *SysmgrShutdownStatus)
	OnSysmgrShutdownStatusDelete(obj *SysmgrShutdownStatus)
}

func (m *SysmgrShutdownStatus) Reset()                    { *m = SysmgrShutdownStatus{} }
func (m *SysmgrShutdownStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrShutdownStatus) ProtoMessage()               {}
func (*SysmgrShutdownStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SysmgrShutdownStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrShutdownStatus) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrShutdownStatus) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrRebootReq struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrRebootReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrRebootReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrRebootReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrRebootReq) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrRebootReq) GetDelphiKind() string {
	return "SysmgrRebootReq"
}

func (m *SysmgrRebootReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrRebootReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrRebootReq)
	return obj
}

func SysmgrRebootReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrRebootReq", mode)
}

func SysmgrRebootReqMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrRebootReq", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrRebootReq(client clientApi.Client, key string) *SysmgrRebootReq {
	o := client.GetObject("SysmgrRebootReq", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrRebootReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrRebootReq) IsPersistent() bool {
	return false
}
func SysmgrRebootReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrRebootReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrRebootReqWatch(client clientApi.Client, reactor SysmgrRebootReqReactor) {
	client.WatchKind("SysmgrRebootReq", reactor)
}
func SysmgrRebootReqList(client clientApi.Client) []*SysmgrRebootReq {
	bobjs := client.List("SysmgrRebootReq")
	objs := make([]*SysmgrRebootReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrRebootReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrRebootReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrRebootReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrRebootReqCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrRebootReq)
				if ok == false {
					panic("Not an SysmgrRebootReq object")
				}
				rctr.OnSysmgrRebootReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrRebootReqDelete(m)
		}
	}
}

type SysmgrRebootReqReactor interface {
	OnSysmgrRebootReqCreate(obj *SysmgrRebootReq)
	OnSysmgrRebootReqUpdate(old *SysmgrRebootReq, obj *SysmgrRebootReq)
	OnSysmgrRebootReqDelete(obj *SysmgrRebootReq)
}

func (m *SysmgrRebootReq) Reset()                    { *m = SysmgrRebootReq{} }
func (m *SysmgrRebootReq) String() string            { return proto.CompactTextString(m) }
func (*SysmgrRebootReq) ProtoMessage()               {}
func (*SysmgrRebootReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SysmgrRebootReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrRebootReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrRebootReq) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrServiceStatus struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrServiceStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrServiceStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrServiceStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrServiceStatus) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrServiceStatus) GetDelphiKind() string {
	return "SysmgrServiceStatus"
}

func (m *SysmgrServiceStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrServiceStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrServiceStatus)
	return obj
}

func SysmgrServiceStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrServiceStatus", mode)
}

func SysmgrServiceStatusMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrServiceStatus", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrServiceStatus(client clientApi.Client, key string) *SysmgrServiceStatus {
	o := client.GetObject("SysmgrServiceStatus", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrServiceStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrServiceStatus) IsPersistent() bool {
	return false
}
func SysmgrServiceStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrServiceStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrServiceStatusWatch(client clientApi.Client, reactor SysmgrServiceStatusReactor) {
	client.WatchKind("SysmgrServiceStatus", reactor)
}
func SysmgrServiceStatusList(client clientApi.Client) []*SysmgrServiceStatus {
	bobjs := client.List("SysmgrServiceStatus")
	objs := make([]*SysmgrServiceStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrServiceStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrServiceStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrServiceStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrServiceStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrServiceStatus)
				if ok == false {
					panic("Not an SysmgrServiceStatus object")
				}
				rctr.OnSysmgrServiceStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrServiceStatusDelete(m)
		}
	}
}

type SysmgrServiceStatusReactor interface {
	OnSysmgrServiceStatusCreate(obj *SysmgrServiceStatus)
	OnSysmgrServiceStatusUpdate(old *SysmgrServiceStatus, obj *SysmgrServiceStatus)
	OnSysmgrServiceStatusDelete(obj *SysmgrServiceStatus)
}

func (m *SysmgrServiceStatus) Reset()                    { *m = SysmgrServiceStatus{} }
func (m *SysmgrServiceStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrServiceStatus) ProtoMessage()               {}
func (*SysmgrServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SysmgrServiceStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrServiceStatus) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrServiceStatus) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrServiceSpec struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Command       string             `protobuf:"bytes,3,opt,name=Command" json:"Command,omitempty"`
	Dependencies  []string           `protobuf:"bytes,4,rep,name=Dependencies" json:"Dependencies,omitempty"`
	Environment   []string           `protobuf:"bytes,5,rep,name=Environment" json:"Environment,omitempty"`
	DelphiService bool               `protobuf:"varint,7,opt,name=DelphiService" json:"DelphiService,omitempty"`
	Restartable   bool               `protobuf:"varint,8,opt,name=Restartable" json:"Restartable,omitempty"`
}

func (m *SysmgrServiceSpec) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrServiceSpec) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrServiceSpec) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrServiceSpec) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrServiceSpec) GetDelphiKind() string {
	return "SysmgrServiceSpec"
}

func (m *SysmgrServiceSpec) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrServiceSpec) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrServiceSpec)
	return obj
}

func SysmgrServiceSpecMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrServiceSpec", mode)
}

func SysmgrServiceSpecMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrServiceSpec", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrServiceSpec(client clientApi.Client, key string) *SysmgrServiceSpec {
	o := client.GetObject("SysmgrServiceSpec", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrServiceSpec)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrServiceSpec) IsPersistent() bool {
	return false
}
func SysmgrServiceSpecFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrServiceSpec
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrServiceSpecWatch(client clientApi.Client, reactor SysmgrServiceSpecReactor) {
	client.WatchKind("SysmgrServiceSpec", reactor)
}
func SysmgrServiceSpecList(client clientApi.Client) []*SysmgrServiceSpec {
	bobjs := client.List("SysmgrServiceSpec")
	objs := make([]*SysmgrServiceSpec, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrServiceSpec)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrServiceSpec) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrServiceSpecReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrServiceSpecCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrServiceSpec)
				if ok == false {
					panic("Not an SysmgrServiceSpec object")
				}
				rctr.OnSysmgrServiceSpecUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrServiceSpecDelete(m)
		}
	}
}

type SysmgrServiceSpecReactor interface {
	OnSysmgrServiceSpecCreate(obj *SysmgrServiceSpec)
	OnSysmgrServiceSpecUpdate(old *SysmgrServiceSpec, obj *SysmgrServiceSpec)
	OnSysmgrServiceSpecDelete(obj *SysmgrServiceSpec)
}

func (m *SysmgrServiceSpec) Reset()                    { *m = SysmgrServiceSpec{} }
func (m *SysmgrServiceSpec) String() string            { return proto.CompactTextString(m) }
func (*SysmgrServiceSpec) ProtoMessage()               {}
func (*SysmgrServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SysmgrServiceSpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrServiceSpec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrServiceSpec) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *SysmgrServiceSpec) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *SysmgrServiceSpec) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *SysmgrServiceSpec) GetDelphiService() bool {
	if m != nil {
		return m.DelphiService
	}
	return false
}

func (m *SysmgrServiceSpec) GetRestartable() bool {
	if m != nil {
		return m.Restartable
	}
	return false
}

type SysmgrProcessStatus struct {
	Meta       *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key        string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid        int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
	State      ProcessState       `protobuf:"varint,4,opt,name=State,enum=sysmgr.ProcessState" json:"State,omitempty"`
	ExitReason string             `protobuf:"bytes,5,opt,name=ExitReason" json:"ExitReason,omitempty"`
}

func (m *SysmgrProcessStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrProcessStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrProcessStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrProcessStatus) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrProcessStatus) GetDelphiKind() string {
	return "SysmgrProcessStatus"
}

func (m *SysmgrProcessStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrProcessStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrProcessStatus)
	return obj
}

func SysmgrProcessStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrProcessStatus", mode)
}

func SysmgrProcessStatusMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrProcessStatus", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrProcessStatus(client clientApi.Client, key string) *SysmgrProcessStatus {
	o := client.GetObject("SysmgrProcessStatus", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrProcessStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrProcessStatus) IsPersistent() bool {
	return false
}
func SysmgrProcessStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrProcessStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrProcessStatusWatch(client clientApi.Client, reactor SysmgrProcessStatusReactor) {
	client.WatchKind("SysmgrProcessStatus", reactor)
}
func SysmgrProcessStatusList(client clientApi.Client) []*SysmgrProcessStatus {
	bobjs := client.List("SysmgrProcessStatus")
	objs := make([]*SysmgrProcessStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrProcessStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrProcessStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrProcessStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrProcessStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrProcessStatus)
				if ok == false {
					panic("Not an SysmgrProcessStatus object")
				}
				rctr.OnSysmgrProcessStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrProcessStatusDelete(m)
		}
	}
}

type SysmgrProcessStatusReactor interface {
	OnSysmgrProcessStatusCreate(obj *SysmgrProcessStatus)
	OnSysmgrProcessStatusUpdate(old *SysmgrProcessStatus, obj *SysmgrProcessStatus)
	OnSysmgrProcessStatusDelete(obj *SysmgrProcessStatus)
}

func (m *SysmgrProcessStatus) Reset()                    { *m = SysmgrProcessStatus{} }
func (m *SysmgrProcessStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrProcessStatus) ProtoMessage()               {}
func (*SysmgrProcessStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SysmgrProcessStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrProcessStatus) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrProcessStatus) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *SysmgrProcessStatus) GetState() ProcessState {
	if m != nil {
		return m.State
	}
	return ProcessState_Waiting
}

func (m *SysmgrProcessStatus) GetExitReason() string {
	if m != nil {
		return m.ExitReason
	}
	return ""
}

type SysmgrSystemStatus struct {
	Meta   *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	State  SystemState        `protobuf:"varint,2,opt,name=State,enum=sysmgr.SystemState" json:"State,omitempty"`
	Reason string             `protobuf:"bytes,3,opt,name=Reason" json:"Reason,omitempty"`
}

func (m *SysmgrSystemStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrSystemStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrSystemStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrSystemStatus) GetDelphiKey() string {
	return "default"
}

func (m *SysmgrSystemStatus) GetDelphiKind() string {
	return "SysmgrSystemStatus"
}

func (m *SysmgrSystemStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrSystemStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrSystemStatus)
	return obj
}

func SysmgrSystemStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrSystemStatus", mode)
}

func GetSysmgrSystemStatus(client clientApi.Client) *SysmgrSystemStatus {
	o := client.GetObject("SysmgrSystemStatus", "default")
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrSystemStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SysmgrSystemStatus) IsPersistent() bool {
	return false
}
func SysmgrSystemStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrSystemStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrSystemStatusWatch(client clientApi.Client, reactor SysmgrSystemStatusReactor) {
	client.WatchKind("SysmgrSystemStatus", reactor)
}
func SysmgrSystemStatusList(client clientApi.Client) []*SysmgrSystemStatus {
	bobjs := client.List("SysmgrSystemStatus")
	objs := make([]*SysmgrSystemStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrSystemStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrSystemStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrSystemStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrSystemStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrSystemStatus)
				if ok == false {
					panic("Not an SysmgrSystemStatus object")
				}
				rctr.OnSysmgrSystemStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrSystemStatusDelete(m)
		}
	}
}

type SysmgrSystemStatusReactor interface {
	OnSysmgrSystemStatusCreate(obj *SysmgrSystemStatus)
	OnSysmgrSystemStatusUpdate(old *SysmgrSystemStatus, obj *SysmgrSystemStatus)
	OnSysmgrSystemStatusDelete(obj *SysmgrSystemStatus)
}

func (m *SysmgrSystemStatus) Reset()                    { *m = SysmgrSystemStatus{} }
func (m *SysmgrSystemStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrSystemStatus) ProtoMessage()               {}
func (*SysmgrSystemStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SysmgrSystemStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrSystemStatus) GetState() SystemState {
	if m != nil {
		return m.State
	}
	return SystemState_Normal
}

func (m *SysmgrSystemStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func init() {
	clientApi.RegisterFactory("SysmgrShutdownReq", SysmgrShutdownReqFactory)
	proto.RegisterType((*SysmgrShutdownReq)(nil), "sysmgr.SysmgrShutdownReq")
	clientApi.RegisterFactory("SysmgrShutdownStatus", SysmgrShutdownStatusFactory)
	proto.RegisterType((*SysmgrShutdownStatus)(nil), "sysmgr.SysmgrShutdownStatus")
	clientApi.RegisterFactory("SysmgrRebootReq", SysmgrRebootReqFactory)
	proto.RegisterType((*SysmgrRebootReq)(nil), "sysmgr.SysmgrRebootReq")
	clientApi.RegisterFactory("SysmgrServiceStatus", SysmgrServiceStatusFactory)
	proto.RegisterType((*SysmgrServiceStatus)(nil), "sysmgr.SysmgrServiceStatus")
	clientApi.RegisterFactory("SysmgrServiceSpec", SysmgrServiceSpecFactory)
	proto.RegisterType((*SysmgrServiceSpec)(nil), "sysmgr.SysmgrServiceSpec")
	clientApi.RegisterFactory("SysmgrProcessStatus", SysmgrProcessStatusFactory)
	proto.RegisterType((*SysmgrProcessStatus)(nil), "sysmgr.SysmgrProcessStatus")
	clientApi.RegisterFactory("SysmgrSystemStatus", SysmgrSystemStatusFactory)
	proto.RegisterType((*SysmgrSystemStatus)(nil), "sysmgr.SysmgrSystemStatus")
	proto.RegisterEnum("sysmgr.ProcessState", ProcessState_name, ProcessState_value)
	proto.RegisterEnum("sysmgr.SystemState", SystemState_name, SystemState_value)
}

func init() { proto.RegisterFile("sysmgr.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 459 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0xbf, 0x92, 0xd3, 0x30,
	0x10, 0xc6, 0xd1, 0xc5, 0x4e, 0x9c, 0x8d, 0x01, 0xa3, 0xbb, 0x61, 0x34, 0x14, 0x8c, 0xc7, 0x73,
	0xc3, 0x98, 0x14, 0x29, 0x8e, 0xee, 0x5a, 0x72, 0x34, 0xc7, 0x9f, 0x1b, 0xa5, 0xa0, 0x56, 0xec,
	0x9d, 0x44, 0x4c, 0x2c, 0x05, 0x4b, 0x3e, 0x48, 0x47, 0x09, 0x4f, 0x70, 0x0f, 0xc2, 0xe3, 0xd1,
	0x30, 0xb2, 0x95, 0xc3, 0x29, 0x28, 0xe0, 0xa0, 0xd3, 0x7e, 0xda, 0x7c, 0xdf, 0x6f, 0xb5, 0x13,
	0x43, 0x6c, 0x76, 0xa6, 0x5a, 0xd5, 0xb3, 0x6d, 0xad, 0xad, 0xa6, 0xc3, 0xae, 0x7a, 0x12, 0x97,
	0xb8, 0xd9, 0xae, 0x65, 0xa7, 0x66, 0x0b, 0x78, 0xb4, 0x68, 0xf5, 0xc5, 0xba, 0xb1, 0xa5, 0xfe,
	0xa4, 0x38, 0x7e, 0xa4, 0xcf, 0x20, 0x78, 0x83, 0x56, 0x30, 0x92, 0x92, 0x7c, 0x72, 0x46, 0x67,
	0xfe, 0x17, 0xef, 0x96, 0x1f, 0xb0, 0xb0, 0xee, 0x86, 0xb7, 0xf7, 0x34, 0x81, 0xc1, 0x25, 0xee,
	0xd8, 0x51, 0x4a, 0xf2, 0x31, 0x77, 0xc7, 0xf3, 0xe0, 0xcb, 0x4d, 0x46, 0xb2, 0x35, 0x9c, 0x1c,
	0x9a, 0x2e, 0xac, 0xb0, 0x8d, 0xf9, 0x7b, 0x5f, 0xa7, 0x5c, 0xc9, 0x92, 0x0d, 0x52, 0x92, 0x87,
	0xdc, 0x1d, 0x7d, 0x52, 0x01, 0x0f, 0xbb, 0x24, 0x8e, 0x4b, 0xad, 0xed, 0x9d, 0xe0, 0x7f, 0x1b,
	0xb2, 0x82, 0x63, 0x3f, 0x0e, 0xd6, 0xd7, 0xb2, 0xc0, 0xff, 0x36, 0xcd, 0x0f, 0x72, 0xbb, 0x0d,
	0x9f, 0xb4, 0xc5, 0xe2, 0x0e, 0x39, 0x0c, 0x46, 0x2f, 0x75, 0x55, 0x09, 0xd5, 0x65, 0x8d, 0xf9,
	0xbe, 0xa4, 0x19, 0xc4, 0x73, 0xdc, 0xa2, 0x2a, 0x51, 0x15, 0x12, 0x0d, 0x0b, 0xd2, 0x41, 0x3e,
	0xe6, 0x07, 0x1a, 0x4d, 0x61, 0x72, 0xa1, 0xae, 0x65, 0xad, 0x55, 0x85, 0xca, 0xb2, 0xb0, 0x6d,
	0xe9, 0x4b, 0xf4, 0x14, 0xee, 0xcf, 0x5b, 0x18, 0x8f, 0xcb, 0x46, 0x29, 0xc9, 0x23, 0x7e, 0x28,
	0x3a, 0x1f, 0x8e, 0xc6, 0x8a, 0xda, 0x8a, 0xe5, 0x06, 0x59, 0xd4, 0xf6, 0xf4, 0x25, 0x3f, 0xfd,
	0x77, 0xb2, 0x7f, 0xe7, 0xab, 0x5a, 0x17, 0x68, 0xcc, 0xbf, 0x7f, 0x67, 0x3a, 0x85, 0xd0, 0xb9,
	0x22, 0x0b, 0x52, 0x92, 0x3f, 0x38, 0x3b, 0x99, 0xf9, 0xbf, 0x48, 0x2f, 0x11, 0x79, 0xd7, 0x42,
	0x9f, 0x02, 0x5c, 0x7c, 0x96, 0x96, 0xa3, 0x30, 0x5a, 0xb1, 0xb0, 0xb5, 0xed, 0x29, 0x9e, 0xfa,
	0x1b, 0x01, 0xea, 0x77, 0xb6, 0x33, 0x16, 0xab, 0x3f, 0x84, 0x7e, 0xbe, 0x07, 0x3a, 0x6a, 0x81,
	0x8e, 0xf7, 0x40, 0xbf, 0xcc, 0x6e, 0x79, 0x1e, 0xc3, 0xd0, 0xb3, 0x74, 0xcb, 0xf4, 0xd5, 0x79,
	0xe4, 0x38, 0xbe, 0xde, 0x64, 0x64, 0x7a, 0x09, 0x71, 0x7f, 0x10, 0x3a, 0x81, 0xd1, 0x7b, 0x21,
	0xad, 0x54, 0xab, 0xe4, 0x1e, 0x1d, 0x43, 0xc8, 0x51, 0x94, 0xbb, 0x84, 0xd0, 0x18, 0xa2, 0xd7,
	0xa2, 0x51, 0xc5, 0x1a, 0xcb, 0xe4, 0xc8, 0x75, 0xf1, 0x46, 0x29, 0xd7, 0x35, 0xa0, 0x11, 0x04,
	0x73, 0x89, 0x65, 0x12, 0x4c, 0x4f, 0x61, 0xd2, 0x83, 0xa0, 0x00, 0xc3, 0xb7, 0xba, 0xae, 0xc4,
	0xa6, 0xb3, 0x7a, 0x25, 0x9a, 0x8d, 0x4d, 0xc8, 0x72, 0xd8, 0x7e, 0x46, 0x5e, 0xfc, 0x0c, 0x00,
	0x00, 0xff, 0xff, 0x52, 0xdc, 0x83, 0x3c, 0x6c, 0x04, 0x00, 0x00,
}
