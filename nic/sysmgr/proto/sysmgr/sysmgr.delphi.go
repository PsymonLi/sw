// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sysmgr.proto

/*
Package sysmgr is a generated protocol buffer package.

It is generated from these files:
	sysmgr.proto

It has these top-level messages:
	SysmgrShutdownReq
	SysmgrShutdownStatus
	SysmgrRebootReq
	SysmgrServiceStatus
	SysmgrServiceSpec
*/
package sysmgr

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SysmgrShutdownReq struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
}

func (m *SysmgrShutdownReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrShutdownReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrShutdownReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrShutdownReq) GetDelphiKey() string {
	return "default"
}

func (m *SysmgrShutdownReq) GetDelphiKind() string {
	return "SysmgrShutdownReq"
}

func (m *SysmgrShutdownReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrShutdownReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrShutdownReq)
	return obj
}

func SysmgrShutdownReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrShutdownReq", mode)
}

func GetSysmgrShutdownReq(client clientApi.Client) *SysmgrShutdownReq {
	o := client.GetObject("SysmgrShutdownReq", "default")
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrShutdownReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func SysmgrShutdownReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrShutdownReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrShutdownReqWatch(client clientApi.Client, reactor SysmgrShutdownReqReactor) {
	client.WatchKind("SysmgrShutdownReq", reactor)
}
func SysmgrShutdownReqList(client clientApi.Client) []*SysmgrShutdownReq {
	bobjs := client.List("SysmgrShutdownReq")
	objs := make([]*SysmgrShutdownReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrShutdownReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrShutdownReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrShutdownReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrShutdownReqCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrShutdownReq)
				if ok == false {
					panic("Not an SysmgrShutdownReq object")
				}
				rctr.OnSysmgrShutdownReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrShutdownReqDelete(m)
		}
	}
}

type SysmgrShutdownReqReactor interface {
	OnSysmgrShutdownReqCreate(obj *SysmgrShutdownReq)
	OnSysmgrShutdownReqUpdate(old *SysmgrShutdownReq, obj *SysmgrShutdownReq)
	OnSysmgrShutdownReqDelete(obj *SysmgrShutdownReq)
}

func (m *SysmgrShutdownReq) Reset()                    { *m = SysmgrShutdownReq{} }
func (m *SysmgrShutdownReq) String() string            { return proto.CompactTextString(m) }
func (*SysmgrShutdownReq) ProtoMessage()               {}
func (*SysmgrShutdownReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SysmgrShutdownReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type SysmgrShutdownStatus struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrShutdownStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrShutdownStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrShutdownStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrShutdownStatus) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrShutdownStatus) GetDelphiKind() string {
	return "SysmgrShutdownStatus"
}

func (m *SysmgrShutdownStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrShutdownStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrShutdownStatus)
	return obj
}

func SysmgrShutdownStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrShutdownStatus", mode)
}

func SysmgrShutdownStatusMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrShutdownStatus", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrShutdownStatus(client clientApi.Client, key string) *SysmgrShutdownStatus {
	o := client.GetObject("SysmgrShutdownStatus", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrShutdownStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func SysmgrShutdownStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrShutdownStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrShutdownStatusWatch(client clientApi.Client, reactor SysmgrShutdownStatusReactor) {
	client.WatchKind("SysmgrShutdownStatus", reactor)
}
func SysmgrShutdownStatusList(client clientApi.Client) []*SysmgrShutdownStatus {
	bobjs := client.List("SysmgrShutdownStatus")
	objs := make([]*SysmgrShutdownStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrShutdownStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrShutdownStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrShutdownStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrShutdownStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrShutdownStatus)
				if ok == false {
					panic("Not an SysmgrShutdownStatus object")
				}
				rctr.OnSysmgrShutdownStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrShutdownStatusDelete(m)
		}
	}
}

type SysmgrShutdownStatusReactor interface {
	OnSysmgrShutdownStatusCreate(obj *SysmgrShutdownStatus)
	OnSysmgrShutdownStatusUpdate(old *SysmgrShutdownStatus, obj *SysmgrShutdownStatus)
	OnSysmgrShutdownStatusDelete(obj *SysmgrShutdownStatus)
}

func (m *SysmgrShutdownStatus) Reset()                    { *m = SysmgrShutdownStatus{} }
func (m *SysmgrShutdownStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrShutdownStatus) ProtoMessage()               {}
func (*SysmgrShutdownStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SysmgrShutdownStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrShutdownStatus) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrShutdownStatus) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrRebootReq struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrRebootReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrRebootReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrRebootReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrRebootReq) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrRebootReq) GetDelphiKind() string {
	return "SysmgrRebootReq"
}

func (m *SysmgrRebootReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrRebootReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrRebootReq)
	return obj
}

func SysmgrRebootReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrRebootReq", mode)
}

func SysmgrRebootReqMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrRebootReq", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrRebootReq(client clientApi.Client, key string) *SysmgrRebootReq {
	o := client.GetObject("SysmgrRebootReq", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrRebootReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func SysmgrRebootReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrRebootReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrRebootReqWatch(client clientApi.Client, reactor SysmgrRebootReqReactor) {
	client.WatchKind("SysmgrRebootReq", reactor)
}
func SysmgrRebootReqList(client clientApi.Client) []*SysmgrRebootReq {
	bobjs := client.List("SysmgrRebootReq")
	objs := make([]*SysmgrRebootReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrRebootReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrRebootReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrRebootReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrRebootReqCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrRebootReq)
				if ok == false {
					panic("Not an SysmgrRebootReq object")
				}
				rctr.OnSysmgrRebootReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrRebootReqDelete(m)
		}
	}
}

type SysmgrRebootReqReactor interface {
	OnSysmgrRebootReqCreate(obj *SysmgrRebootReq)
	OnSysmgrRebootReqUpdate(old *SysmgrRebootReq, obj *SysmgrRebootReq)
	OnSysmgrRebootReqDelete(obj *SysmgrRebootReq)
}

func (m *SysmgrRebootReq) Reset()                    { *m = SysmgrRebootReq{} }
func (m *SysmgrRebootReq) String() string            { return proto.CompactTextString(m) }
func (*SysmgrRebootReq) ProtoMessage()               {}
func (*SysmgrRebootReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SysmgrRebootReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrRebootReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrRebootReq) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrServiceStatus struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Pid  int32              `protobuf:"varint,3,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *SysmgrServiceStatus) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrServiceStatus) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrServiceStatus) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrServiceStatus) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrServiceStatus) GetDelphiKind() string {
	return "SysmgrServiceStatus"
}

func (m *SysmgrServiceStatus) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrServiceStatus) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrServiceStatus)
	return obj
}

func SysmgrServiceStatusMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrServiceStatus", mode)
}

func SysmgrServiceStatusMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrServiceStatus", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrServiceStatus(client clientApi.Client, key string) *SysmgrServiceStatus {
	o := client.GetObject("SysmgrServiceStatus", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrServiceStatus)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func SysmgrServiceStatusFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrServiceStatus
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrServiceStatusWatch(client clientApi.Client, reactor SysmgrServiceStatusReactor) {
	client.WatchKind("SysmgrServiceStatus", reactor)
}
func SysmgrServiceStatusList(client clientApi.Client) []*SysmgrServiceStatus {
	bobjs := client.List("SysmgrServiceStatus")
	objs := make([]*SysmgrServiceStatus, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrServiceStatus)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrServiceStatus) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrServiceStatusReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrServiceStatusCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrServiceStatus)
				if ok == false {
					panic("Not an SysmgrServiceStatus object")
				}
				rctr.OnSysmgrServiceStatusUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrServiceStatusDelete(m)
		}
	}
}

type SysmgrServiceStatusReactor interface {
	OnSysmgrServiceStatusCreate(obj *SysmgrServiceStatus)
	OnSysmgrServiceStatusUpdate(old *SysmgrServiceStatus, obj *SysmgrServiceStatus)
	OnSysmgrServiceStatusDelete(obj *SysmgrServiceStatus)
}

func (m *SysmgrServiceStatus) Reset()                    { *m = SysmgrServiceStatus{} }
func (m *SysmgrServiceStatus) String() string            { return proto.CompactTextString(m) }
func (*SysmgrServiceStatus) ProtoMessage()               {}
func (*SysmgrServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SysmgrServiceStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrServiceStatus) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrServiceStatus) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type SysmgrServiceSpec struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Command       string             `protobuf:"bytes,3,opt,name=Command" json:"Command,omitempty"`
	Dependencies  []string           `protobuf:"bytes,4,rep,name=Dependencies" json:"Dependencies,omitempty"`
	Environment   []string           `protobuf:"bytes,5,rep,name=Environment" json:"Environment,omitempty"`
	DelphiService bool               `protobuf:"varint,7,opt,name=DelphiService" json:"DelphiService,omitempty"`
	Restartable   bool               `protobuf:"varint,8,opt,name=Restartable" json:"Restartable,omitempty"`
}

func (m *SysmgrServiceSpec) GetDelphiMessage() proto.Message {
	return m
}

func (m *SysmgrServiceSpec) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SysmgrServiceSpec) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SysmgrServiceSpec) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SysmgrServiceSpec) GetDelphiKind() string {
	return "SysmgrServiceSpec"
}

func (m *SysmgrServiceSpec) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SysmgrServiceSpec) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SysmgrServiceSpec)
	return obj
}

func SysmgrServiceSpecMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SysmgrServiceSpec", mode)
}

func SysmgrServiceSpecMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SysmgrServiceSpec", fmt.Sprintf("%v", key), mode)
}

func GetSysmgrServiceSpec(client clientApi.Client, key string) *SysmgrServiceSpec {
	o := client.GetObject("SysmgrServiceSpec", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SysmgrServiceSpec)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func SysmgrServiceSpecFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SysmgrServiceSpec
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SysmgrServiceSpecWatch(client clientApi.Client, reactor SysmgrServiceSpecReactor) {
	client.WatchKind("SysmgrServiceSpec", reactor)
}
func SysmgrServiceSpecList(client clientApi.Client) []*SysmgrServiceSpec {
	bobjs := client.List("SysmgrServiceSpec")
	objs := make([]*SysmgrServiceSpec, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SysmgrServiceSpec)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SysmgrServiceSpec) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SysmgrServiceSpecReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSysmgrServiceSpecCreate(m)
			} else {
				oldObj, ok := old.(*SysmgrServiceSpec)
				if ok == false {
					panic("Not an SysmgrServiceSpec object")
				}
				rctr.OnSysmgrServiceSpecUpdate(oldObj, m)
			}
		} else {
			rctr.OnSysmgrServiceSpecDelete(m)
		}
	}
}

type SysmgrServiceSpecReactor interface {
	OnSysmgrServiceSpecCreate(obj *SysmgrServiceSpec)
	OnSysmgrServiceSpecUpdate(old *SysmgrServiceSpec, obj *SysmgrServiceSpec)
	OnSysmgrServiceSpecDelete(obj *SysmgrServiceSpec)
}

func (m *SysmgrServiceSpec) Reset()                    { *m = SysmgrServiceSpec{} }
func (m *SysmgrServiceSpec) String() string            { return proto.CompactTextString(m) }
func (*SysmgrServiceSpec) ProtoMessage()               {}
func (*SysmgrServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SysmgrServiceSpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SysmgrServiceSpec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SysmgrServiceSpec) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *SysmgrServiceSpec) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *SysmgrServiceSpec) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *SysmgrServiceSpec) GetDelphiService() bool {
	if m != nil {
		return m.DelphiService
	}
	return false
}

func (m *SysmgrServiceSpec) GetRestartable() bool {
	if m != nil {
		return m.Restartable
	}
	return false
}

func init() {
	clientApi.RegisterFactory("SysmgrShutdownReq", SysmgrShutdownReqFactory)
	proto.RegisterType((*SysmgrShutdownReq)(nil), "sysmgr.SysmgrShutdownReq")
	clientApi.RegisterFactory("SysmgrShutdownStatus", SysmgrShutdownStatusFactory)
	proto.RegisterType((*SysmgrShutdownStatus)(nil), "sysmgr.SysmgrShutdownStatus")
	clientApi.RegisterFactory("SysmgrRebootReq", SysmgrRebootReqFactory)
	proto.RegisterType((*SysmgrRebootReq)(nil), "sysmgr.SysmgrRebootReq")
	clientApi.RegisterFactory("SysmgrServiceStatus", SysmgrServiceStatusFactory)
	proto.RegisterType((*SysmgrServiceStatus)(nil), "sysmgr.SysmgrServiceStatus")
	clientApi.RegisterFactory("SysmgrServiceSpec", SysmgrServiceSpecFactory)
	proto.RegisterType((*SysmgrServiceSpec)(nil), "sysmgr.SysmgrServiceSpec")
}

func init() { proto.RegisterFile("sysmgr.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 299 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0x3d, 0x4f, 0xf3, 0x30,
	0x10, 0x80, 0xe5, 0xb7, 0x5f, 0xc9, 0x35, 0xaf, 0x00, 0xc3, 0x60, 0x31, 0x59, 0x16, 0x42, 0x99,
	0x3a, 0xc0, 0xd6, 0x95, 0x76, 0x42, 0x08, 0xe4, 0xfc, 0x82, 0x7c, 0x9c, 0x9a, 0xa0, 0xc6, 0x0e,
	0x89, 0x5b, 0xd4, 0x8d, 0x91, 0x7f, 0xd0, 0x1f, 0xcb, 0x82, 0xec, 0x04, 0xd4, 0x6c, 0x54, 0x88,
	0xed, 0xee, 0xb9, 0xcb, 0x3d, 0x77, 0x91, 0x21, 0x68, 0x76, 0x4d, 0xb9, 0xaa, 0x67, 0x55, 0xad,
	0x8d, 0xa6, 0xe3, 0x36, 0xbb, 0x0c, 0x32, 0x5c, 0x57, 0x79, 0xd1, 0x52, 0xb1, 0x84, 0xb3, 0xc8,
	0xf1, 0x28, 0xdf, 0x98, 0x4c, 0xbf, 0x2a, 0x89, 0x2f, 0xf4, 0x1a, 0x86, 0x0f, 0x68, 0x62, 0x46,
	0x38, 0x09, 0xa7, 0x37, 0x74, 0xd6, 0x7d, 0xf1, 0x98, 0x3c, 0x63, 0x6a, 0x6c, 0x45, 0xba, 0xfa,
	0xdc, 0x7b, 0xdb, 0x0b, 0xf2, 0xbe, 0x17, 0x44, 0xe4, 0x70, 0xd1, 0x1f, 0x13, 0x99, 0xd8, 0x6c,
	0x9a, 0x9f, 0x4e, 0xa2, 0xa7, 0x30, 0xb8, 0xc7, 0x1d, 0xfb, 0xc7, 0x49, 0xe8, 0x4b, 0x1b, 0x5a,
	0xf2, 0x54, 0x64, 0x6c, 0xc0, 0x49, 0x38, 0x92, 0x36, 0x9c, 0x0f, 0xad, 0x4d, 0xa4, 0x70, 0xd2,
	0x9a, 0x24, 0x26, 0x5a, 0x9b, 0x23, 0xd6, 0x3d, 0x42, 0xb2, 0x82, 0xf3, 0xee, 0x1c, 0xac, 0xb7,
	0x45, 0x8a, 0x7f, 0x76, 0xcd, 0x07, 0xf9, 0xfe, 0xff, 0x9d, 0xa9, 0xc2, 0xf4, 0x17, 0x1e, 0x06,
	0x93, 0x3b, 0x5d, 0x96, 0xb1, 0x6a, 0x5d, 0xbe, 0xfc, 0x4a, 0xa9, 0x80, 0x60, 0x81, 0x15, 0xaa,
	0x0c, 0x55, 0x5a, 0x60, 0xc3, 0x86, 0x7c, 0x10, 0xfa, 0xb2, 0xc7, 0x28, 0x87, 0xe9, 0x52, 0x6d,
	0x8b, 0x5a, 0xab, 0x12, 0x95, 0x61, 0x23, 0xd7, 0x72, 0x88, 0xe8, 0x15, 0xfc, 0x5f, 0xb8, 0x65,
	0xba, 0x75, 0xd9, 0x84, 0x93, 0xd0, 0x93, 0x7d, 0x68, 0xe7, 0x48, 0x6c, 0x4c, 0x5c, 0x9b, 0x38,
	0x59, 0x23, 0xf3, 0x5c, 0xcf, 0x21, 0x6a, 0xaf, 0x4f, 0xc6, 0xee, 0x0d, 0xde, 0x7e, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x7d, 0xd5, 0x3a, 0xf4, 0xa9, 0x02, 0x00, 0x00,
}
