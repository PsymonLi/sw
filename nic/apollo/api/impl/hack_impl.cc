/**
 * Copyright (c) 2019 Pensando Systems, Inc.
 *
 * @file    hack_impl.cc
 *
 * @brief   placeholder file for temporary hacks
 */

#include <cmath>
//#include <boost/crc.hpp>
#include "nic/sdk/lib/p4/p4_api.hpp"
#include "nic/sdk/platform/utils/lif_manager_base.hpp"
#include "nic/sdk/platform/utils/qstate_mgr.hpp"
#include "nic/sdk/platform/capri/capri_lif_manager.hpp"
#include "nic/sdk/platform/capri/capri_qstate.hpp"
#include "nic/sdk/p4/loader/loader.hpp"
#include "nic/apollo/api/impl/apollo_impl.hpp"
#include "nic/apollo/core/oci_state.hpp"
#include "nic/apollo/p4/include/defines.h"
// below file is autogenerated for the given platform + pipeline
#include "gen/platform/mem_regions.hpp"

using sdk::platform::capri::LIFManager;
using sdk::platform::utils::program_info;

typedef struct __attribute__((__packed__)) lif_qstate_  {
    uint64_t pc : 8;
    uint64_t rsvd : 8;
    uint64_t cos_a : 4;
    uint64_t coa_b : 4;
    uint64_t cos_sel : 8;
    uint64_t eval_last : 8;
    uint64_t host_rings : 4;
    uint64_t total_rings : 4;
    uint64_t pid : 16;
    uint64_t pindex : 16;
    uint64_t cindex : 16;

    uint64_t arm_pindex : 16;
    uint64_t arm_cindex : 16;
    uint64_t sw_pindex : 16;
    uint16_t sw_cindex;
    uint64_t ring0_base : 64;
    uint64_t ring1_base : 64;
    uint64_t ring0_size : 16;
    uint64_t ring1_size : 16;

    uint8_t  pad[(512-320)/8];
} lif_qstate_t;

typedef struct __attribute__((__packed__)) txdma_qstate_  {
    uint64_t pc : 8;
    uint64_t rsvd : 8;
    uint64_t cos_a : 4;
    uint64_t coa_b : 4;
    uint64_t cos_sel : 8;
    uint64_t eval_last : 8;
    uint64_t host_rings : 4;
    uint64_t total_rings : 4;
    uint64_t pid : 16;
    uint64_t pindex : 16;
    uint64_t cindex : 16;

    uint64_t sw_cindex : 16;
    uint64_t ring_size : 16;
    uint64_t ring_base : 64;
    uint64_t rxdma_cindex_addr : 64;

    uint8_t  pad[(512-256)/8];
} txdma_qstate_t;

/**
 * @brief    init routine to initialize service LIFs
 * @return    SDK_RET_OK on success, failure status code on error
 */
sdk_ret_t
init_service_lif (void)
{

/*
    program_info *pginfo = program_info::factory(LDD_INFO_FILE_NAME);
    SDK_ASSERT(pginfo != NULL);
    api::g_oci_state.set_prog_info(pginfo);
    LIFManager *lm = LIFManager::factory(api::g_oci_state.mempartition(),
                                         api::g_oci_state.prog_info(),
                                         MEM_REGION_LIF2QSTATE_MAP_NAME);
    SDK_ASSERT(lm != NULL);
    api::g_oci_state.set_lif_mgr(lm);
    qstate_mgr *qstate_mgr::factory(const char *qstate_info_file, shmmgr *mmgr)


    lm->LIFRangeMarkAlloced(APOLLO_SERVICE_LIF, 1);
*/

    sdk::platform::utils::LIFQState qstate = { 0 };
    qstate.lif_id = APOLLO_SERVICE_LIF;
    qstate.hbm_address = api::g_oci_state.mempartition()->start_addr(MEM_REGION_LIF2QSTATE_MAP_NAME);
    qstate.params_in.type[0].entries = 1;
    qstate.params_in.type[0].size = 1; // 64B
    sdk::platform::capri::push_qstate_to_capri(&qstate, 0);

    lif_qstate_t lif_qstate = { 0 };
    lif_qstate.ring0_base = api::g_oci_state.mempartition()->start_addr(MEM_REGION_RXDMA_TO_TXDMA_BUF_NAME);
    lif_qstate.ring0_size = log2(api::g_oci_state.mempartition()->size(MEM_REGION_RXDMA_TO_TXDMA_BUF_NAME) / 10);
    lif_qstate.total_rings = 1;
    sdk::platform::capri::write_qstate(qstate.hbm_address, (uint8_t *)&lif_qstate, sizeof(lif_qstate));

    txdma_qstate_t txdma_qstate = { 0 };
    txdma_qstate.rxdma_cindex_addr = qstate.hbm_address + offsetof(lif_qstate_t, sw_cindex);
    txdma_qstate.ring_base = api::g_oci_state.mempartition()->start_addr(MEM_REGION_RXDMA_TO_TXDMA_BUF_NAME);
    txdma_qstate.ring_size = log2(api::g_oci_state.mempartition()->size(MEM_REGION_RXDMA_TO_TXDMA_BUF_NAME) / 10);
    txdma_qstate.total_rings = 1;
    sdk::platform::capri::write_qstate(qstate.hbm_address + sizeof(lif_qstate_t),
                 (uint8_t *)&txdma_qstate, sizeof(txdma_qstate));

    return SDK_RET_OK;
}

#if 0
/**
 * @brief    routine to compute CRC hash
 * @return   hash value
 */
static uint32_t
generate_hash_ (void *key, uint32_t key_len, uint32_t crc_init_val)
{
    boost::crc_basic<32> *crc_hash;
    uint32_t hash_val = 0x0;

    crc_hash = new boost::crc_basic<32>(0x04C11DB7, crc_init_val,
                                        0x00000000, false, false);
    crc_hash->process_bytes(key, key_len);
    hash_val = crc_hash->checksum();
    delete crc_hash;
    return hash_val;
}

/**
 * @brief    routine to write a table entry
 * @return   SDK_RET_OK on success, failure status code on error
 */
sdk_ret_t
entry_write (uint32_t tbl_id, uint32_t index, void *key, void *mask,
             void *data, bool hash_table, uint32_t table_size)
{
    if (key || mask) {
        // prepare entry and write hardware
        uint32_t hwkey_len = 0;
        uint32_t hwmask_len = 0;
        uint32_t hwdata_len = 0;
        uint8_t  *hwkey = NULL;
        uint8_t  *hwmask = NULL;
        p4pd_hwentry_query(tbl_id, &hwkey_len, &hwmask_len, &hwdata_len);
        hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
        hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
        hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
        hwkey = new uint8_t[hwkey_len];
        hwmask = new uint8_t[hwmask_len];
        memset(hwkey, 0, hwkey_len);
        memset(hwmask, 0, hwmask_len);
        p4pd_hwkey_hwmask_build(tbl_id, key, mask, hwkey, hwmask);
        if (hash_table) {
            index = generate_hash_(hwkey, hwkey_len, 0);
            index &= table_size - 1;
        }
        p4pd_entry_write(tbl_id, index, hwkey, hwmask, data);
        delete [] hwkey;
        delete [] hwmask;
    } else {
        p4pd_entry_write(tbl_id, index, NULL, NULL, data);
    }

    return SDK_RET_OK;
}
#endif
