//
// {C} Copyright 2020 Pensando Systems Inc. All rights reserved
//
//----------------------------------------------------------------------------
///
/// \file
/// This file implements pds upgrade
///
//----------------------------------------------------------------------------

#include "nic/sdk/lib/event_thread/event_thread.hpp"
#include "nic/apollo/core/core.hpp"
#include "nic/apollo/core/trace.hpp"
#include "nic/apollo/api/include/pds_upgrade.hpp"
#include "nic/apollo/api/pds_state.hpp"
#include "nic/apollo/api/upgrade_state.hpp"

sdk_ret_t
pds_upgrade (sdk::upg::upg_ev_params_t *params)
{
    if (!params) {
        return SDK_RET_INVALID_ARG;
    }
    // return error if any operation is pending
    // TODO : allow repeal if any operation is pending
    if (api::g_upg_state->ev_in_progress()) {
        PDS_TRACE_ERR("Upgrade, operation in progress, retry later");
        return SDK_RET_RETRY;
    }

    // starting new, clear the status
    api::g_upg_state->clear_ev_status();
    api::g_upg_state->set_ev_more(false);
    // set ongoing spec
    api::g_upg_state->set_ev_params(params);

    api::upg_event_send(params);

    // send back the result if there are no pending reponses
    if (!api::g_upg_state->ev_in_progress()) {
        return api::g_upg_state->ev_status();
    } else {
        // reply in progress. waiting for processing threads to complete
        return SDK_RET_IN_PROGRESS;
    }
}

static sdk_ret_t
upgrade_init_hdlr (sdk::upg::upg_ev_params_t *params)
{
    sdk_ret_t ret;
    uint32_t thr_id = core::PDS_THREAD_ID_UPGRADE;

    // save the params
    api::g_upg_state->set_ev_params(params);

    // can pass params here as the thread goes to ready state after doing
    // the init
    ret = core::spawn_upgrade_thread(params);
    if (ret != SDK_RET_OK) {
        PDS_TRACE_ERR("Upgrade thread spawn failed, ret %u", ret);
    } else {
        // wait for it to be ready
        while((!sdk::lib::thread::find(thr_id)) ||
              (!sdk::lib::thread::find(thr_id)->ready())) {
             pthread_yield();
        }
    }
    // as the event is generated by a broadcast request, this function should
    // always return in-progress which is ignored by the response hanlder.
    // actual return always should be from the upgrade thread
    return SDK_RET_IN_PROGRESS;
}

void
pds_upgrade_teardown (void)
{
    sdk::event_thread::event_thread *thr;

    thr = (sdk::event_thread::event_thread *)
              sdk::lib::thread::find(core::PDS_THREAD_ID_UPGRADE);
    if (!thr) {
        PDS_TRACE_INFO("Upgrade thread already exited");
        return;
    }
    // stop and wait
    PDS_TRACE_DEBUG("Upgrade thread teardown starting..");
    thr->stop();
    thr->wait();
    thr->destroy(thr);
    PDS_TRACE_DEBUG("Upgrade thread teardown done");
}

static void
upgrade_ev_init_hdlr (sdk::ipc::ipc_msg_ptr msg, const void *ctxt)
{
    // thread should not be present
    SDK_ASSERT(!sdk::lib::thread::find(core::PDS_THREAD_ID_UPGRADE));
    // process the event in default path. this would start a new
    // thread and response will be send from that thread context
    sdk::upg::upg_invoke_ev_hdlr(msg, ctxt, upgrade_init_hdlr);
}

static void
upgrade_ev_exit_hdlr (sdk::ipc::ipc_msg_ptr msg, const void *ctxt)
{
    // teardown the existing
    pds_upgrade_teardown();
}

void
pds_upgrade_init (void)
{
    sdk::ipc::subscribe(UPG_EV_COMPAT_CHECK, upgrade_ev_init_hdlr, NULL);
    sdk::ipc::subscribe(UPG_EV_READY, upgrade_ev_init_hdlr, NULL);
    sdk::ipc::subscribe(UPG_EV_EXIT, upgrade_ev_exit_hdlr, NULL);
}
