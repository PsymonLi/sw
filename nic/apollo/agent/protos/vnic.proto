//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for Virtual Network Interface Card (VNIC) object
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service VnicSvc {
  rpc VnicCreate (VnicRequest) returns (VnicResponse) {}
  rpc VnicUpdate (VnicRequest) returns (VnicResponse) {}
  rpc VnicGet (VnicGetRequest) returns (VnicGetResponse) {}
  rpc VnicDelete (VnicDeleteRequest) returns (VnicDeleteResponse) {}
}

// VNIC specification
// NOTE: Vnic ids are not scoped under VPC or subnet, they are globally
//       unique across VPCs
message VnicSpec {
  // unique vnic id
  uint32          VnicId                = 1 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // id of the subnet this vnic belongs to
  uint32          SubnetId              = 2 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // id of the VPC this vnic belongs to
  uint32          VPCId                 = 3 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // vnic encap information to be used while sending packets to this vnic
  types.Encap     VnicEncap             = 4 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // overlay MAC of this VNIC
  uint64          MACAddress            = 5 [(gogoproto.moretags) = "meta:mandatory"];
  // enable or disable reverse path checks while sending traffic to this vnic
  // or while receiving traffic from this vnic
  bool            SourceGuardEnable     = 6;
  // fabric encap information to be used for traffic originated from this vnic
  types.Encap     FabricEncap           = 7 [(gogoproto.moretags) = "meta:immutable"];
  // Tx/egress mirror session id list, if any
  repeated uint32 TxMirrorSessionId     = 8;
  // Rx/ingress mirror session id list, if any
  repeated uint32 RxMirrorSessionId     = 9;
  // switch vnic is router/bridge/appliance sitting behind the VLAN of this VNIC
  // and can have many MACs in the same VLAN, so SMAC check will be disabled
  bool            SwitchVnic            = 10;
  // metering policy to apply for IPv4 traffic coming in and going out of vnic
  uint32          V4MeterId             = 11;
  // metering policy to apply for IPv6 traffic coming in and going out of vnic
  uint32          V6MeterId             = 12;
  // identifier of ingress IPv4 security policy to be enforced
  repeated uint32 IngV4SecurityPolicyId = 13;
  // identifier of ingress IPv6 security policy to be enforced
  repeated uint32 IngV6SecurityPolicyId = 14;
  // identifier of egress IPv4 security policy to be enforced
  repeated uint32 EgV4SecurityPolicyId  = 15;
  // identifier of egress IPv6 security policy to be enforced
  repeated uint32 EgV6SecurityPolicyId  = 16;
  // when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
  // present, vnic needs to be attached to a PF/VF (aka. lif or host interface)
  // HostIfIndex is the interface index of such VF/PF
  uint32          HostIfIndex           = 17;
  // policer to be applied on the traffic coming from vnic
  uint32          TxPolicerId           = 18;
  // policer to be applied on the traffic going to vnic
  uint32          RxPolicerId           = 19;
  // if a vnic is not marked as primary, DHCP offer sent to such vnics
  // will not have gateway IP, hostname options filled in the DHCP offer
  bool            Primary               = 20 [(gogoproto.moretags) = "meta:immutable"];
  // hostname of the vnic to be returned in the DHCP offer when DHCP policy
  // is enabled on the vnic's subnet
  string          HostName              = 21;
  // MaxSessions, if set, is number of active sessions allowed from/to this vnic
  // if MaxSessions is 0, no limit is enforced
  // NOTE: no active sessions will be pruned if the value changes, but once the
  //       session count comes down to a value below this limit, new sessions
  //       won't be installed in h/w (packet will be dropped)
  //       1 session = forward flow + reverse flow
  uint32          MaxSessions           = 22;
}

// operational status of Vnic, if any
message VnicStatus {
    // vnic hw id
    uint32 HwId = 1;
}

// stats of Vnic, if any
message VnicStats {
}

// vnic object
message Vnic {
  meta.TypeMeta TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta  ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  VnicSpec      Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  VnicStatus    Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  VnicStats     Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// vnic create and update request
message VnicRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt   BatchCtxt = 1;
  // batched request
  repeated VnicSpec Request   = 2;
}

// vnic create and update response
message VnicResponse {
  types.ApiStatus     ApiStatus = 1;
  repeated VnicStatus Response  = 2; // batched response
}

// vnic get request
message VnicGetRequest {
  repeated uint32 VnicId = 1; // batched request
}

// vnic get response
message VnicGetResponse {
  types.ApiStatus ApiStatus = 1;
  repeated Vnic   Response  = 2; // batched response
}

// vnic delete request
message VnicDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
  // batched request
  repeated uint32 VnicId    = 2;
}

// vnic delete response
message VnicDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1; // batched response
}
