//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for IP mappings
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service MappingSvc {
  rpc MappingCreate (MappingRequest) returns (MappingResponse) {}
  rpc MappingUpdate (MappingRequest) returns (MappingResponse) {}
  rpc MappingGet (MappingGetRequest) returns (MappingGetResponse) {}
  rpc MappingDump (MappingDumpRequest) returns (types.Empty) {}
  rpc MappingDelete (MappingDeleteRequest) returns (MappingDeleteResponse) {}
}

// MappingKey uniquley identifies the IP in the entire fabric
message MappingKey {
  // virtual private cloud mapping belongs to
  uint32 VPCId           = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // private/overlay IP of the mapping
  types.IPAddress IPAddr = 2;
}

// MappingSpec captures configuration of each mapping
// NOTE: Mapping is either on the local host/TEP or remote TEP
message MappingSpec {
  // key to identify the mapping
  MappingKey          Id             = 1;
  // subnet this mapping is in
  uint32              SubnetId       = 2 [(gogoproto.moretags) = "meta:mandatory"];
  oneof dstinfo {
      // Tunnel ID of the TEP, if the mapping is remote, 0 for local mappings
      uint32          TunnelID       = 3;
      // nexthop identifier for reachability information
      uint32          NexthopId      = 4 [(gogoproto.moretags) = "meta:mandatory"];
      // mappings can point to underlay nexthop group, but not overlay as one
      // mapping can't be behind two TEPs (i.e., multi-homing is not supported
      // for mappings that are configured or learnt from eVPN routes)
      uint32          NexthopGroupId = 5;  // only underlay-type NH-G
  }
  // overlay MAC address of this mapping
  uint64              MACAddr        = 6 [(gogoproto.moretags) = "meta:mandatory"];
  // fabric encap information specific to this mapping, if any
  types.Encap         Encap          = 7 [(gogoproto.moretags) = "meta:mandatory"];
  // if IP is that of local vnic, corresponding vnic id
  uint32              VnicId         = 8;
  // public IP, if overlay IP has corresponding public IP
  types.IPAddress     PublicIP       = 9;
  // provider/substrate IP corresponding to the overlay IP, if any
  types.IPAddress     ProviderIp     = 10;
  // service tag for this IP mapping, if exists. service tag can be used
  // in defining security policies
  // NOTE: service tag 0 is invalid
  uint32              ServiceTag     = 11;
}

// operational status of a mapping
message MappingStatus {
}

// stats of a mapping
message MappingStats {
}

// mapping object
message Mapping {
  meta.TypeMeta  TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta   ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  MappingSpec   Spec      = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  MappingStatus Status    = 4 [(gogoproto.jsontag) = "status,omitempty"];
  MappingStats  Stats     = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// mapping create and update request
message MappingRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt      BatchCtxt = 1;
  repeated MappingSpec Request   = 2;
}

// mapping create and update response
message MappingResponse {
  types.ApiStatus        ApiStatus = 1;
  repeated MappingStatus Response  = 2;
}

// mapping get request
message MappingGetRequest {
  repeated MappingKey Id = 1;
}

// mapping get response
message MappingGetResponse {
  types.ApiStatus  ApiStatus = 1;
  repeated Mapping Response = 2;
}

// mapping dump request
message MappingDumpRequest {
  int64    CId           = 1;
  repeated MappingKey Id = 2;
}

// mapping delete request
message MappingDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt     BatchCtxt = 1;
  repeated MappingKey Id        = 2;
}

// mapping delete response
message MappingDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1;
}
