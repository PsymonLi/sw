//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for policies
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service SecurityPolicySvc {
  // security policy APIs
  rpc SecurityPolicyCreate (SecurityPolicyRequest) returns (SecurityPolicyResponse) {}
  rpc SecurityPolicyUpdate (SecurityPolicyRequest) returns (SecurityPolicyResponse) {}
  rpc SecurityPolicyGet (SecurityPolicyGetRequest) returns (SecurityPolicyGetResponse) {}
  rpc SecurityPolicyDelete (SecurityPolicyDeleteRequest) returns (SecurityPolicyDeleteResponse) {}

  // security policy rule APIs
  rpc SecurityRuleCreate (SecurityRuleRequest) returns (SecurityRuleResponse) {}
  rpc SecurityRuleUpdate (SecurityRuleRequest) returns (SecurityRuleResponse) {}
  rpc SecurityRuleGet (SecurityRuleGetRequest) returns (SecurityRuleGetResponse) {}
  rpc SecurityRuleDelete (SecurityRuleDeleteRequest) returns (SecurityRuleDeleteResponse) {}

  // security profile APIs
  rpc SecurityProfileCreate (SecurityProfileRequest) returns (SecurityProfileResponse) {}
  rpc SecurityProfileUpdate (SecurityProfileRequest) returns (SecurityProfileResponse) {}
  rpc SecurityProfileGet (SecurityProfileGetRequest) returns (SecurityProfileGetResponse) {}
  rpc SecurityProfileDelete (SecurityProfileDeleteRequest) returns (SecurityProfileDeleteResponse) {}
}

// FTP ALG specific options
message FTPOptions {
  // allow FTP data sessions with IP address that is different from
  // control sessions
  bool AllowIPMismatch = 1;
}

// DNS ALG specific options
message DNSOptions {
  // DNS session will be closed if response is not seen for a DNS query within
  // ResponseTimeout seconds
  uint32 ResponseTimeout            = 1 [(gogoproto.moretags) = "meta:default=60"];
  //  when DropMultiQueryMessage is set, drop DNS query messages that contain
  //  more than one DNS query in same packet
  bool   DropMultiQueryMessage      = 2;
  // when DropLargeDomainNameMessage is set, DNS mwessages containing domain
  // name exceeding 255 bytes are dropped
  bool   DropLargeDomainNameMessage = 3;
  // when DropLongLabelMessage is set, DNS messages containing labels
  // exceeding 63 bytes are dropped
  bool   DropLongLabelMessage       = 4;
  // when DropMultiZonePackets is set, DNS messages containing more than one
  // zone are dropped
  bool   DropMultiZonePackets       = 5;
  // MaxMessageLength defines the maximum length of the DNS query/response
  // message the ALG will handle
  uint32 MaxMessageLength           = 6 [(gogoproto.moretags) = "meta:range:512-8192,meta:default=512"];
}

// MSRPC ALG specific options
message MSRPCOptions {
  // RPC program uuids
  repeated bytes ProgramId = 1;
}

// SunRPC ALG specific options
message SunRPCOptions {
  // RPC program uuids
  repeated bytes ProgramId = 1;
}

// ALG specifices with Application Level Gateway (ALG) should be invoked
// when a rule match happens. This ALG will also be reported in the flow
// logs
// NOTE:
// 1. TFTP, DNS ALGs are supported on UDP only
// 2. FTP, RTSP ALGs are supported on TCP only
// 3. SUNRPC and MSRPC ALGs are supported on both TCP and UDP
enum ALG {
  ALG_NONE   = 0;
  // TFTP ALG
  ALG_TFTP   = 1;
  // FTP ALG
  ALG_FTP    = 2;
  // DNS ALG
  ALG_DNS    = 3;
  // SUNRPC ALG
  ALG_SUNRPC = 4;
  // MSRPC ALG
  ALG_MSRPC  = 5;
  // RTSP ALG
  ALG_RTSP   = 6;
}

message ALGSpec {
  // ALG to invoke (if set to ALG_NONE, no ALG is invoked)
  ALG             ALG           = 1;
  // ALG specific options, if any
  oneof alg_options {
    FTPOptions    FTPOptions    = 2;
    DNSOptions    DNSOptions    = 3;
    MSRPCOptions  MSRPCOptions  = 4;
    SunRPCOptions SunRPCOptions = 5;
  }
  // IdleTimeout indicates ALG specific session timeout in seconds
  // if IdleTimeout is not set, timeout from SecurityProfile object
  // is applied on both control and data sessions of the ALG
  uint32          IdleTimeout   = 6;
}

// security rule attributes
message SecurityRuleAttrs {
  // stateful rule results in flow/session creation whereas stateless rule
  // will not result in flow creation
  bool                     Stateful = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // priority of this rule (lower the numeric value, higher the priority is)
  uint32                   Priority = 2 [(gogoproto.moretags) = "meta:range:0-1022"];
  // rule match criteria
  types.RuleMatch          Match    = 3;
  // action to take when this rule is matched
  types.SecurityRuleAction Action   = 4 [(gogoproto.moretags) = "meta:mandatory"];
  // ALGSpec contains optional ALG specific behavior, if ALG is enabled for
  // this rule
  ALGSpec                  ALGSpec  = 5;
}

// SecurityRuleInfo is a single rule in the security policy
message SecurityRuleInfo {
  // optional rule id needed if incremental route ADD/DEL/UPD functionality is needed
  bytes             Id    = 1 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  SecurityRuleAttrs Attrs = 2 [(gogoproto.moretags) = "meta:mandatory"];
}

// security policy configuration
message SecurityPolicySpec {
  // unique identifier of security policy
  bytes                     Id              = 1 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // IPv4 or IPv6 policy
  types.IPAF                AddrFamily      = 2 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // DefaultFWAction is the action taken by the firewall when SG policies are
  // configured on vnic but no rule is hit. Similarly, when NACLs are configured
  // on a subnet and no rule is hit, this action is taken by the firewall.
  // if this attribute is not set, it will inherit from security profile and if
  // that is also not set then  default "deny" action is enforced
  // NOTE: when no policy is configured on subnet and vnic, this knob doesn't
  //       apply and traffic is allowed in that case
  types.SecurityRuleAction  DefaultFWAction = 3 [(gogoproto.moretags) = "meta:default=SECURITY_RULE_ACTION_NONE"];
  // list of security rules
  repeated SecurityRuleInfo Rules           = 4 [(gogoproto.moretags) = "meta:mandatory"];
}

// operational status of security policy, if any
message SecurityPolicyStatus {
}

// stats of security policy, if any
message SecurityPolicyStats {
}

// security policy object
message SecurityPolicy {
  meta.TypeMeta        TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta         ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  SecurityPolicySpec   Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  SecurityPolicyStatus Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  SecurityPolicyStats  Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// security policy create and update request
message SecurityPolicyRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt             BatchCtxt = 1;
  repeated SecurityPolicySpec Request   = 2;
}

// security policy create and update response
message SecurityPolicyResponse {
  types.ApiStatus               ApiStatus = 1;
  repeated SecurityPolicyStatus Response  = 2;
}

// security policy get request
message SecurityPolicyGetRequest {
  repeated bytes Id = 1;
}

// security policy get response
message SecurityPolicyGetResponse {
  types.ApiStatus         ApiStatus = 1;
  repeated SecurityPolicy Response  = 2;
}

// security policy delete request
message SecurityPolicyDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
  repeated bytes  Id        = 2;
}

// security policy delete response
message SecurityPolicyDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1;
}

// unique id to identify a security policy rule
message SecurityPolicyRuleId {
  // unique identifier of security rule
  bytes Id               = 1 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // security policy this rule belongs to
  bytes SecurityPolicyId = 2 [(gogoproto.moretags) = "meta:mandatory,immutable"];
}

// security rule configuration
message SecurityRuleSpec {
  // unique identifier of security rule
  bytes             Id               = 1 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // security policy this rule belongs to
  bytes             SecurityPolicyId = 2 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // rule information
  SecurityRuleAttrs Attrs            = 3 [(gogoproto.moretags) = "meta:mandatory"];
}

// operational status of the security rule, if any
message SecurityRuleStatus {
}

// stats of the security rule, if any
message SecurityRuleStats {
}

// security rule object
message SecurityRule {
  meta.TypeMeta      TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta       ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  SecurityRuleSpec   Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  SecurityRuleStatus Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  SecurityRuleStats  Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// security policy rule create and update request
message SecurityRuleRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt  BatchCtxt = 1;
  // security policy rule configuration
  SecurityRuleSpec Request   = 2;
}

// security policy rule create and update response
message SecurityRuleResponse {
  // success or failure status
  types.ApiStatus    ApiStatus = 1;
  // operational status
  SecurityRuleStatus Response  = 2;
}

// security policy rule get request
message SecurityRuleGetRequest {
  // list of id/key of the security policy rules of interest
  repeated SecurityPolicyRuleId Id = 1 [(gogoproto.moretags) = "meta:mandatory"];
}

// security policy rule get response
message SecurityRuleGetResponse {
  types.ApiStatus       ApiStatus = 1;
  // security policy rule information
  repeated SecurityRule Response  = 2;
}

// security policy rule delete request
message SecurityRuleDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt               BatchCtxt = 1;
  // id/key list of the security policy rule(s) to be deleted
  repeated SecurityPolicyRuleId Id        = 2;
}

// security policy rule delete response
message SecurityRuleDeleteResponse {
  // API status code
  repeated types.ApiStatus ApiStatus = 1;
}

// security profile configuration
// NOTE:
// 1. currently security profile object is global and only a singleton object,
//    any attempt to create multiple objects will be treated as an error
// 2. if no object is created, indicated default values will be used
message SecurityProfileSpec {
  // unique identifier of security profile
  bytes               Id                   = 1 [(gogoproto.moretags) = "meta:mandatory"];

  // ConnTrackEn, if set to true, will enable full connection tracking
  bool                ConnTrackEn          = 2 [(gogoproto.moretags) = "meta:default=false"];

  // DefaultFWAction is the action taken by the smartnic when policies are
  // configured on the subnet or vnic, no rule matches and default action for policy is none
  // this will have effect iff policy is attached on either vnic or subnet.
  // if no action is specified  in security profile, default action is "deny"
  types.SecurityRuleAction DefaultFWAction = 3 [(gogoproto.moretags) = "meta:default=SECURITY_RULE_ACTION_DENY"];

  // timeouts for established sessions per TCP/UDP/ICMP and other protocols
  uint32              TCPIdleTimeout       = 4 [(gogoproto.moretags) = "meta:range:5-86400, meta:default=600"];
  uint32              UDPIdleTimeout       = 5 [(gogoproto.moretags) = "meta:range:5-86400, meta:default=120"];
  uint32              ICMPIdleTimeout      = 6 [(gogoproto.moretags) = "meta:range:5-86400, meta:default=15"];
  uint32              OtherIdleTimeout     = 7 [(gogoproto.moretags) = "meta:range:30-86400, meta:default=90"];

  // TCP specific timeouts
  // TCPCnxnSetupTimeout is the maximum allowed time since first SYN seen to
  // 3-way handshake completion, session gets cleaned up if 3-way handshake is
  // not completed and session moves to ESTABLISHED state by then
  uint32              TCPCnxnSetupTimeout  = 8 [(gogoproto.moretags) = "meta:range:1-60, meta:default=10"];
  // TCPHalfCloseTimeout is the maximum allowed time since first FIN seen to
  // 3/4way close, session gets cleaned up if this timer elapses.
  uint32              TCPHalfCloseTimeout  = 9 [(gogoproto.moretags) = "meta:range:1-172800, meta:default=120"];
  // TCPCloseTimeout is wait time since FIN is seen from *both* sides (or RST)
  // before cleaning up the session
  uint32              TCPCloseTimeout      = 10 [(gogoproto.moretags) = "meta:range:1-300, meta:default=15"];

  // timeouts applicable to sessions installed with drop action
  uint32              TCPDropTimeout       = 11 [(gogoproto.moretags) = "meta:range:1-300, meta:default=90"];
  uint32              UDPDropTimeout       = 12 [(gogoproto.moretags) = "meta:range:1-172800, meta:default=60"];
  uint32              ICMPDropTimeout      = 13 [(gogoproto.moretags) = "meta:range:1-300, meta:default=30"];
  uint32              OtherDropTimeout     = 14 [(gogoproto.moretags) = "meta:range:1-300, meta:default=60"];
}

// operational status of security profile, if any
message SecurityProfileStatus {
}

// stats of security profile, if any
message SecurityProfileStats {
}

// security profile object
message SecurityProfile {
  meta.TypeMeta         TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta          ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  SecurityProfileSpec   Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  SecurityProfileStatus Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  SecurityProfileStats  Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// security profile create and update request
message SecurityProfileRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt              BatchCtxt = 1;
  repeated SecurityProfileSpec Request   = 2;
}

// security profile create and update response
message SecurityProfileResponse {
  types.ApiStatus                ApiStatus = 1;
  repeated SecurityProfileStatus Response  = 2;
}

// security profile get request
message SecurityProfileGetRequest {
  repeated bytes Id = 1;
}

// security profile get response
message SecurityProfileGetResponse {
  types.ApiStatus          ApiStatus = 1;
  repeated SecurityProfile Response  = 2;
}

// security profile delete request
message SecurityProfileDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
  repeated bytes  Id        = 2;
}

// security profile delete response
message SecurityProfileDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1;
}
