//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for subnet object
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service SubnetSvc {
  rpc SubnetCreate (SubnetRequest) returns (SubnetResponse) {}
  rpc SubnetUpdate (SubnetRequest) returns (SubnetResponse) {}
  rpc SubnetGet (SubnetGetRequest) returns (SubnetGetResponse) {}
  rpc SubnetDelete (SubnetDeleteRequest) returns (SubnetDeleteResponse) {}
}

// SubnetSpec captures subnet specific coniguration
message SubnetSpec {
  // unique identifier of the subnet
  uint32         Id                    = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // virtual private cloud this subnet is belongs to
  uint32         VPCId                 = 2 [(gogoproto.moretags) = "meta:mandatory"];
  // IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
  types.IPPrefix V4Prefix              = 3 [(gogoproto.moretags) = "meta:mandatory"];
  // IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
  types.IPPrefix V6Prefix              = 4 [(gogoproto.moretags) = "meta:mandatory"];
  // IPv4 Virtual Router (VR) IP of this subnet, this IP is owned by the device
  // and packets originated by this device carry this IP as source IP
  uint32         IPv4VirtualRouterIP   = 5;
  // Ipv6 Virtual Router (VR) IP of this subnet, this IP is owned by the device
  // and packets originated by this device carry this IP as source IP
  bytes          IPv6VirtualRouterIP   = 6;
  // Virtual Router (VR) MAC address, any packets originated or routed by
  // the device carry this MAC as source MAC
  uint64         VirtualRouterMac      = 7 [(gogoproto.moretags) = "meta:mandatory"];
  // identifier of the IPv4 route table to be used
  uint32         V4RouteTableId        = 8 [(gogoproto.moretags) = "meta:mandatory"];
  // identifier of the IPv6 route table to be used, if any
  uint32         V6RouteTableId        = 9;
  // identifier of ingress IPv4 security policy to be enforced
  uint32         IngV4SecurityPolicyId = 10;
  // identifier of ingress IPv6 security policy to be enforced
  uint32         IngV6SecurityPolicyId = 11;
  // identifier of egress IPv4 security policy to be enforced
  uint32         EgV4SecurityPolicyId  = 12;
  // identifier of egress IPv6 security policy to be enforced
  uint32         EgV6SecurityPolicyId  = 13;
  // encapped traffic coming with the specified encap from fabric side will be
  // mapped to this subnet and traffic from workloads in this subnet will carry
  // this encap towards the fabric side
  types.Encap    FabricEncap           = 14;
}

// operational status of the subnet, if any
message SubnetStatus {
}

// stats of the subnet, if any
message SubnetStats {
}

// subnet object
message Subnet {
  meta.TypeMeta TypeMeta   = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta  ObjectMeta = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  SubnetSpec    Spec       = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  SubnetStatus  Status     = 4 [(gogoproto.jsontag) = "status,omitempty"];
  SubnetStats   Stats      = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// subnet create and update request
message SubnetRequest {
  repeated SubnetSpec Request = 1;
}

// subnet create and update response
message SubnetResponse {
  types.ApiStatus       ApiStatus = 1;
  repeated SubnetStatus Response  = 2;
}

// subnet get request
message SubnetGetRequest {
  repeated uint32 Id = 1;
}

// subnet get response
message SubnetGetResponse {
  types.ApiStatus ApiStatus = 1;
  repeated Subnet Response  = 2;
}

// subnet delete request
message SubnetDeleteRequest {
  repeated uint32 Id = 1;
}

// subnet delete response
message SubnetDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1;
}
