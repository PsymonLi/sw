//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for the top level device object
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service DeviceSvc {
  rpc DeviceCreate (DeviceRequest) returns (DeviceResponse) {}
  rpc DeviceUpdate (DeviceRequest) returns (DeviceResponse) {}
  rpc DeviceGet (DeviceGetRequest) returns (DeviceGetResponse) {}
  rpc DeviceDelete (DeviceDeleteRequest) returns (DeviceDeleteResponse) {}
}

enum MemoryProfile {
  MEMORY_PROFILE_DEFAULT = 0;
  // router profile will support 256K routes per IPv4
  // route table and a total of 32 such route tables
  MEMORY_PROFILE_ROUTER  = 1;
}

enum DeviceProfile {
  DEVICE_PROFILE_DEFAULT = 0;
  DEVICE_PROFILE_2PF     = 1;
  DEVICE_PROFILE_3PF     = 2;
  DEVICE_PROFILE_4PF     = 3;
  DEVICE_PROFILE_5PF     = 4;
  DEVICE_PROFILE_6PF     = 5;
  DEVICE_PROFILE_7PF     = 6;
  DEVICE_PROFILE_8PF     = 7;
  DEVICE_PROFILE_32VF    = 8;
}

// operational mode of the device
// NOTE:
// multiple connectivity models are possible in SMART_SWITCH and SMART_SERVICE
// modes:
//     a. one uplink handles traffic from/to host side and other uplink handles
//        traffic from/to fabric/sdn
//     b. both uplinks can send and receive traffic from/to host and from/to
//        fabric side (i.e., both links are treated the same way and probably
//        ECMP-ed), this connectivity model is useful when DSC is deployed
//        behind/alongside a switch and switch is redirecting traffic to DSCs
//        (aka. sidecar model) and making forwarding decisions
enum DeviceOperMode {
  DEVICE_OPER_MODE_NONE                = 0;
  // HOST mode with workloads on pcie; it is flow based and supports all
  // features (IP services like firewall, NAT etc.) depending on the memory
  // profile configured
  DEVICE_OPER_MODE_HOST                = 1;
  // in SMART_SWITCH mode, DSC acts as bump-in-the-wire device; it is flow
  // based and does forwarding (based on mappings and routes) while
  // supporting all IP (smart) service features (and is flow based) depending
  // on the memory profile configured; the switch connected via the sdn
  // port(s) will do only underlay routing on the encapped (by DSC) traiffc
  DEVICE_OPER_MODE_BITW_SMART_SWITCH   = 2;
  // in SMART_SERVICE mode, DSC is flow based and provides IP service
  // features; it doesn't do forwarding (i.e. L2 or L3 lookups), i.e. no
  // L2/L3 mappings need to be configured and IP routing is not enabled
  DEVICE_OPER_MODE_BITW_SMART_SERVICE  = 3;
  // in CLASSIC_SWITCH mode, DSC performs routing and no IP services are
  // performed; additionally this is not flow based mode and hence every
  // packet is subjected to route table and/or mapping lookups (routes are
  // either programmed via grpc or distributed via control protocol like BGP)
  DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH = 4;
}

// supported learn modes
enum LearnMode {
  LEARN_MODE_NONE   = 0;
  // in LEARN_MODE_NOTIFY mode, when a unknown MAC/IP is seen, notification
  // is generated via operd to the app, learn module will not populate the
  // p4 tables with the MAC or IP; they will be programmed when app comes back
  // and install vnics and/or IP mappings because of these learn notifications
  // NOTE:
  // 1. as learn events are simply notified to app, learn module doesn't need to
  //    perform aging of the MAC/IP entries in this mode.
  // 2. in order to de-dup back-to-back learn events and not bombard the app
  //    listening  to these notifications, some state will be maintained about
  //    the notified MAC/IP entries and will be deleted within short time
  LEARN_MODE_NOTIFY = 1;
  // in LEARN_MODE_AUTO, learn module will learn and automatically program the
  // learnt MAC/IP in the datapath. Additionally, notifications will be
  // generated for the clients of interest via operd
  LEARN_MODE_AUTO   = 2;
}

// supported types of packets for learning
// NOTE: when all learn sources are set to false, LearnMode must be set to
//       LEARN_MODE_NONE
message LearnSource {
  // when ArpLearnEn is set to true, learning will happen from ARP/GARP/RARP
  // traffic
  bool ArpLearnEn     = 1 [(gogoproto.moretags) = "meta:default=true"];
  // when DhcpLearnEn is se to true, learning will happen from DHCP traffic
  bool DhcpLearnEn    = 2 [(gogoproto.moretags) = "meta:default=true"];
  // when DataPktLearnEn is set to true, learning will happen from non-protocol
  // data traffic
  bool DataPktLearnEn = 3 [(gogoproto.moretags) = "meta:default=true"];
}

// MAC/IP learning related configuration knobs
message LearnSpec {
  // NOTE: when LearnMode mode is modified, it will take affect only after
  //       next reboot of NAPLES/DSC
  LearnMode   LearnMode       = 1 [(gogoproto.moretags) = "meta:default=LEARN_MODE_NONE"];
  // LearnAgeTimeout is the aging timeout (in seconds) for learnt MAC or IP
  // addresses if LearningEn is set to true. If this is not set and learning is
  // enabled, default value is assumed for aging
  uint32      LearnAgeTimeout = 2 [(gogoproto.moretags) = "meta:range:30-86400,meta:default=300"];
  // LearnSource captures packet types that can result in MAC/IP learning
  LearnSource LearnSource     = 3 [(gogoproto.moretags) = "LearnMode!=LEARN_MODE_NONE"];
}

message DeviceSpec {
  // local IP address in the underlay (i.e. MyTEP IP or local TEP IP)
  types.IPAddress     IPAddr              = 1;
  // system MAC (NAPLES's system MAC will be used if not provided)
  uint64              MACAddr             = 2;
  // IP address of the gateway in the underlay
  types.IPAddress     GatewayIP           = 3;
  // operational mode of the device
  // NOTE: when operational mode is modified, it will take affect only after
  //       next reboot of NAPLES/DSC
  DeviceOperMode      DevOperMode         = 4 [(gogoproto.moretags) = "meta:mandatory, persisted"];
  // Memory Profile (only MEMORY_PROFILE_DEFAULT is supported)
  // NOTE: when a device profile is changed, it will take affect after next
  // reboot of NAPLES/DSC
  MemoryProfile       MemoryProfile       = 5 [(gogoproto.moretags) = "meta:mandatory, persisted"];
  // Device Profile
  DeviceProfile       DeviceProfile       = 6 [(gogoproto.moretags) = "meta:mandatory, persisted"];
  // if BridgingEn is true, L2 functionality based on MAC addresses kicks in
  // NOTE: when operational mode is modified, it will take affect only after
  //       next reboot of NAPLES/DSC
  bool                BridgingEn          = 7 [(gogoproto.moretags) = "meta:mandatory"];
  // MAC/IP learning controls
  // NOTE: if LearnSpec is not configured learning is disabled by default
  LearnSpec           LearnSpec           = 8;
  // priority of IP mapping entries (this priority, if configured, will be
  // used to break the tie in case both LPM/prefix and a mapping entry are
  // hit in the datapath (i.e., /32 IP mapping entry is also in some LPM
  // prefix)
  // NOTE:
  // 1. by default IP mapping always takes precedence over LPM hit and
  //    default value of this attribute is 0 (lower the numerical value,
  //    the higher the priority, hence 0 is the highest priority)
  // 2. valid priority value range is 0 to 1023
  // 3. if mapping and route are both hit and both have same priority,
  //    mapping result will take precedence over route (even if it is /32 route)
  // 4. if the value of this attribute is updated on the fly, it will not
  //    affect the flows/sessions that are already created, but it will take
  //    affect only on the new sessions/flows created after such an update
  uint32              IPMappingPriority   = 9 [(gogoproto.moretags) = "meta:range:0-1023"];
  // firewall (if enabled) action transposition logic dictates how the policy
  // lookup results are processed when multiple security policies are applied
  // on a packet
  types.FwPolicyXposn FwPolicyXposnScheme = 10 [(gogoproto.moretags) = "meta:default=FW_POLICY_XPOSN_GLOBAL_PRIORITY"];
  // enable the control plane stack for overlay routing
  // NOTE: when OverlayRoutingEn is modified, it will take affect only after
  //       next reboot of NAPLES/DSC
  bool                OverlayRoutingEn    = 11 [(gogoproto.moretags) = "meta:mandatory"];
  // when SymmetricRoutingEn is set to true, outgoing inter-subnet (encapped)
  // traffic carries VPC's VxLAN vnid and incoming inter-subnet (encapped)
  // traffic is expected to come with VPC's VxLAN vnid. If SymmetricRoutingEn is
  // set to false (default behavior), outgoing inter-subnet (encapped) traffic
  // carries egress subnet's VxLAN vnid and incoming inter-subnet (encapped)
  // traffic is expected to come with destination subnet's VxLAN vnid
  // NOTE: if the value of this attribute is updated on the fly, it will not
  //       affect the flows/sessions that are already created, but it will take
  //       affect only on the new sessions/flows created after such an update
  bool                SymmetricRoutingEn  = 12 [(gogoproto.moretags) = "meta:default=false"];
  // TxPolicerId, if configured, will rate limit the Tx bandwidth (bytes per
  // second) or PPS (packets per second) of all host interfaces put together
  // to the configured value
  bytes               TxPolicerId         = 13;
}

// device operational status
enum DeviceState {
  SWITCH_STATE_NONE = 0;
  SWITCH_STATE_UP   = 1;
  SWITCH_STATE_DOWN = 2;
  SWITCH_STATE_ERR  = 3;
}

// device health status, multiple conditions can happen
enum DeviceHealth {
  DEVICE_HEALTH_NONE            = 0;
  DEVICE_HEALTH_OK              = 1;
  DEVICE_HEALTH_SERVICE_DOWN    = 2;
  DEVICE_HEALTH_REBOOT_REQUIRED = 3;
  DEVICE_HEALTH_LOW_MEMORY      = 4;
  DEVICE_HEALTH_HARDWARE_ERROR  = 5;
}

// operational status of the device, if any
message DeviceStatus {
  // operational state of the device
  DeviceState State               = 1;
  // system MAC address (can be used to uniquely identify the device in cluster)
  uint64      SystemMACAddress    = 2;
  // serial number of the device
  string      SerialNumber        = 3;
  // SKU/part numnber
  string      Sku                 = 4;
  // version of the firmware running
  string      FirmwareVersion     = 5;
  // memory capacity
  uint32      Memory              = 6;
  // product name
  string      ProductName         = 7;
  // manufacturing date
  string      ManufacturingDate   = 8;
  // device description
  string      Description         = 9;
  // vendor identifier
  string      VendorID            = 10;
  // chip type
  types.AsicType ChipType         = 11;
  // hardware revision
  string      HardwareRevision    = 12;
  // CPU vendor
  string      CpuVendor           = 13;
  // CPU specification
  string      CpuSpecification    = 14;
  // SoC OS version
  string      SocOSVersion        = 15;
  // SoC disk size
  string      SocDiskSize         = 16;
  // PCIe specification
  string      PCIeSpecification   = 17;
  // PCIe bus information
  string      PCIeBusInfo         = 18;
  // number of PCIe ports
  uint32      NumPCIePorts        = 19;
  // Number of uplink ports
  uint32      NumPorts            = 20;
  // vendor name
  string      VendorName          = 21;
  // PXE version
  float       PXEVersion          = 22;
  // UEFI version
  float       UEFIVersion         = 23;
  // number of host interfaces
  uint32      NumHostIf           = 24;
  // version of the firmware running
  string      FirmwareDescription = 26;
  // version of the firmware running
  string      FirmwareBuildTime   = 27;
}

// stats of the device, if any
message DeviceStatsEntry {
  string Name  = 1;
  uint64 Count = 2;
}

message DeviceStats {
  repeated DeviceStatsEntry Ingress = 1;
  repeated DeviceStatsEntry Egress  = 2;
}

// device object
message Device {
  meta.TypeMeta TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta  ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  DeviceSpec    Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  DeviceStatus  Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  DeviceStats   Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// device create and update request
message DeviceRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
  DeviceSpec      Request   = 2;
}

// device create and update response
message DeviceResponse {
  types.ApiStatus ApiStatus = 1;
  DeviceStatus    Response  = 2;
}

// device get request
message DeviceGetRequest {
}

// device get response
message DeviceGetResponse {
  types.ApiStatus ApiStatus = 1;
  Device          Response  = 2;
}

// device delete request
message DeviceDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
}

// device delete response
message DeviceDeleteResponse {
  types.ApiStatus ApiStatus = 1;
}
