//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for interface related objects
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "meta/meta.proto";
import "types.proto";

service IfSvc {
  rpc InterfaceCreate (InterfaceRequest) returns (InterfaceResponse) {}
  rpc InterfaceUpdate (InterfaceRequest) returns (InterfaceResponse) {}
  rpc InterfaceDelete (InterfaceDeleteRequest) returns (InterfaceDeleteResponse) {}
  rpc InterfaceGet (InterfaceGetRequest) returns (InterfaceGetResponse) {}
  rpc LifGet (LifGetRequest) returns (LifGetResponse) {}
}

// types of interfaces
enum IfType {
  IF_TYPE_NONE      = 0;
  // uplink interface
  IF_TYPE_UPLINK    = 1;
  // uplink port-channel interface
  IF_TYPE_UPLINK_PC = 2;
  // L3 interface
  IF_TYPE_L3        = 3;
  // loopback interface
  IF_TYPE_LOOPBACK  = 4;
  // inband management/control interface
  IF_TYPE_VENDOR_L3 = 5;
}

// IfStatus status reflects the operational status of Interface
enum IfStatus {
  IF_STATUS_NONE = 0;
  IF_STATUS_UP   = 1;
  IF_STATUS_DOWN = 2;
}

// Uplink configuration (if interface type is IF_TYPE_UPLINK)
message UplinkSpec {
  // physical port id corresponding to this interface
  bytes  PortId       = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // Untagged ingress packets are considered as coming with this VLAN id
  // Egress packet tagged with this VLAN id are sent untagge
  uint32 NativeVlanId = 2;
}

// Uplink port-channel configuration (i.e., if interface type is
// IF_TYPE_UPLINK_PC)
message UplinkPCSpec {
  // member interfaces of this port-channel in the form of bitmap
  // (e.g. if uplink interfaces 1 and 2 part of this port channel
  // this is set to 0x11
  uint64 MemberIfBitmap = 1;
  // Untagged ingress packets are considered as coming with this VLAN id
  // Egress packet tagged with this VLAN id are sent untagge
  uint32 NativeVlanId   = 2;
}

// L3 interface configuration
message L3IfSpec {
  // vpc/vrf this L3 interface belongs to
  bytes          VpcId      = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // IP address, prefix of this L3 interface
  types.IPPrefix Prefix     = 2 [(gogoproto.moretags) = "meta:mandatory"];
  // Physical port of this L3 interface
  bytes          PortId     = 3 [(gogoproto.moretags) = "meta:mandatory"];
  // (optional) encap used for packet rewrites if this is a L3 sub interface
  types.Encap    Encap      = 4;
  // MAC address of this L3 interface
  uint64         MACAddress = 5;
}

// Loopback interface configuration
message LoopbackIfSpec {
  // IP address hosted on the loopback interface
  // NOTE: This IP address is in underlay VPC
  types.IPPrefix Prefix = 1 [(gogoproto.moretags) = "meta:mandatory"];
}

// Inband management/control interface configuration
message VendorL3IfSpec {
  // IP address hosted on the inband control interface
  types.IPPrefix Prefix     = 1 [(gogoproto.moretags) = "meta:mandatory"];
  uint64         MACAddress = 2;
}

// InterfaceSpec is used to add or update of an interface
message InterfaceSpec {
  // unique interface id
  // NOTE: interface ids start from 1, for IF_TYPE_UPLINK this id is in the
  //       range [1...max-ports#] and same for IF_TYPE_UPLINK_PC
  bytes              Id            = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // type of the interface
  IfType             Type          = 2 [(gogoproto.moretags) = "meta:mandatory,immutable"];
  // port up|down adminstratively
  IfStatus           AdminStatus   = 3;
  // interface type specific configuration
  oneof ifinfo {
    // uplink specific configuration
    UplinkSpec     UplinkSpec      = 4 [(gogoproto.moretags) = "meta:constraints={InterfaceSpec.Type==IF_TYPE_UPLINK}"];
    UplinkPCSpec   UplinkPCSpec    = 5 [(gogoproto.moretags) = "meta:constraints={InterfaceSpec.Type==IF_TYPE_UPLINK_PC}"];
    L3IfSpec       L3IfSpec        = 6 [(gogoproto.moretags) = "meta:constraints={InterfaceSpec.Type==IF_TYPE_L3}"];
    LoopbackIfSpec LoopbackIfSpec  = 7 [(gogoproto.moretags) = "meta:constraints={InterfaceSpec.Type==IF_TYPE_LOOPBACK"];
    VendorL3IfSpec VendorL3IfSpec  = 8 [(gogoproto.moretags) = "meta:constraints={InterfaceSpec.Type==IF_TYPE_VENDOR_L3"];
  }
  // Tx/egress mirror session id list, if any
  repeated bytes TxMirrorSessionId = 9;
  // Rx/ingress mirror session id list, if any
  repeated bytes RxMirrorSessionId = 10;
}

// operational status of uplink interface
message UplinkIfStatus {
  // lif id associated with this uplink
  uint32 LifId = 1;
}

// operational status of loopback interface
message LoopbackIfStatus {
  // loopback interface name in linux
  string name = 1;
}

// operational status of an interface, if any
message InterfaceStatus {
  // encoded interface index of this interface
  uint32             IfIndex          = 1;
  // operational status of the interface
  IfStatus           OperStatus       = 2;
  oneof ifstatus {
    // uplink specific status
    UplinkIfStatus   UplinkIfStatus   = 3;
    // loopback interface specific status
    LoopbackIfStatus LoopbackIfStatus = 4;
  }
}

// stats for an interface, if any
message InterfaceStats {
}

// interface Object
message Interface {
  meta.TypeMeta   TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta    ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  InterfaceSpec   Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  InterfaceStatus Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  InterfaceStats  Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

// interface create and update request
message InterfaceRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt        BatchCtxt = 1;
  // batched requests
  repeated InterfaceSpec Request   = 2;
}

// interface create and update response
message InterfaceResponse {
  types.ApiStatus          ApiStatus = 1;
  repeated InterfaceStatus Response  = 2; // batched response
}

// interface get request
message InterfaceGetRequest {
  repeated bytes Id = 1;
}

// interface get response
message InterfaceGetResponse {
  types.ApiStatus    ApiStatus = 1; // API status code
  repeated Interface Response  = 2;
}

// interface delete request
message InterfaceDeleteRequest {
  // optional batch context, if this request is part of batch of API calls
  types.BatchCtxt BatchCtxt = 1;
  repeated bytes  Id        = 2;
}

// interface delete response
message InterfaceDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1; // API status code
}

/// Lif (Logical interface) object represents a device (eth/storage etc.)
message LifSpec {
  // unique key of the lif
  bytes         Id                 = 1;
  // type of the lif device
  types.LifType Type               = 2;
  // MAC address of the lif, if any
  uint64        MacAddress         = 3;
  // pinned uplink interface, if applicable for this device
  bytes         PinnedInterface    = 4;
  // Tx/egress mirror session id list, if any
  repeated bytes TxMirrorSessionId = 5;
  // Rx/ingress mirror session id list, if any
  repeated bytes RxMirrorSessionId = 6;
}

message LifStatus {
  // encoded ifindex of this lif
  uint32   IfIndex = 1;
  // name of this lif (as seen on the host)
  string   Name    = 2;
  // operational status of this lif
  IfStatus Status  = 3;
}

message LifStats {
}

message Lif {
  meta.TypeMeta TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta  ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  LifSpec       Spec     = 3 [(gogoproto.jsontag) = "spec,omitempty"];
  LifStatus     Status   = 4 [(gogoproto.jsontag) = "status,omitempty"];
  LifStats      Stats    = 5 [(gogoproto.jsontag) = "stats,omitempty"];
}

message LifGetRequest {
  repeated bytes Id = 1;
}

message LifGetResponse {
  types.ApiStatus ApiStatus = 1; // API status code
  repeated Lif    Response  = 2;
}
