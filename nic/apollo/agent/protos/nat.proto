//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for Network Address Translation (NAT)
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import public "gogo.proto";
import "meta/meta.proto";
import "types.proto";

service NatSvc {
  rpc NatPolicyCreate (NatPolicyRequest) returns (NatPolicyResponse) {}
  rpc NatPolicyGet (NatPolicyGetRequest) returns (NatPolicyGetResponse) {}
  rpc NatPolicyDelete (NatPolicyDeleteRequest) returns (NatPolicyDeleteResponse) {}
}

message NatPool {
  repeated types.Address Addresses = 1 [(gogoproto.nullable) = false, (gogoproto.moretags) = "meta:mandatory"];
  types.PortRange        Ports     = 2;
}

// types of NAT actions supported
enum NatAction {
  NAT_TYPE_NONE                 = 0;
  // Address only static NAT
  NAT_TYPE_STATIC_ADDRESS       = 1;
  // NAPT - Address and Port Translation
  NAT_TYPE_DYNAMIC_ADDRESS_PORT = 2;
}

message NatRuleAction {
  // source NAT action
  NatAction SrcNatAction = 1;
  // NAT pool to use
  NatPool   NatPool      = 2;
}

message NatRule {
  // unique NAT rule id
  uint32          Id     = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // rule match criteria
  types.RuleMatch Match  = 2;
  // NAT rule action
  NatRuleAction   Action = 3 [(gogoproto.nullable) = false, (gogoproto.moretags) = "meta:mandatory"];
}

message NatPolicySpec {
  // unique identifier of NAT policy
  uint32                Id         = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // IPv4 or IPv6 policy
  types.IPAF            AddrFamily = 2 [(gogoproto.moretags) = "meta:mandatory"];
  // direction in which the policy should be enforced
  types.RuleDir         Direction  = 3 [(gogoproto.moretags) = "meta:mandatory"];
  // list of NAT rules
  repeated NatRule      Rules      = 4 [(gogoproto.moretags) = "meta:mandatory"];
}

// operational status of NAT policy, if any
message NatPolicyStatus {
}

// stats of NAT policy, if any
message NatPolicyStats {
}

// NAT policy object
message NatPolicy {
  meta.TypeMeta   TypeMeta = 1 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta    ObjMeta  = 2 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (gogoproto.jsontag) = "meta,omitempty"];
  NatPolicySpec   Spec     = 3 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "spec,omitempty"];
  NatPolicyStatus Status   = 4 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "status,omitempty"];
  NatPolicyStats  Stats    = 5 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "stats,omitempty"];
}

// NAT policy create and update request
message NatPolicyRequest {
  repeated NatPolicySpec Request = 1;
}

// NAT policy create and update response
message NatPolicyResponse {
  types.ApiStatus               ApiStatus = 1;
  repeated NatPolicyStatus Response  = 2;
}

// NAT policy get request
message NatPolicyGetRequest {
  repeated uint32 Id = 1;
}

// NAT policy get response
message NatPolicyGetResponse {
  types.ApiStatus    ApiStatus = 1;
  repeated NatPolicy Response  = 2;
}

// NAT policy delete request
message NatPolicyDeleteRequest {
  repeated uint32 Id = 1;
}

// NAT policy delete response
message NatPolicyDeleteResponse {
  repeated types.ApiStatus ApiStatus = 1;
}
