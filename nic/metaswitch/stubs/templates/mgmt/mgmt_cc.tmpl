// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.
 /*
 * Package cmd is a auto generated package.
 * Input file: {{.Name}}
 */

#include <string>       // std::string
#include <iostream>     // std::cout
#include <sstream>      // std::stringstream

{{$cam := getMetaswitchMibTablesInfo}}

{{$file := .}}
{{$fileName := .GetName}}
{{$pkgName := .Package}}
{{$extPkgName := "pds"}}
{{$pkg := addStr "." $pkgName}}
{{$pkg := addStr $pkg "."}}
#include "nic/metaswitch/stubs/mgmt/gen/mgmt/pds_ms_{{TrimSuffix $fileName ".proto"}}_utils_gen.hpp"
#include "nic/metaswitch/stubs/mgmt/pds_ms_mgmt_utils.hpp"
#include "nic/metaswitch/stubs/mgmt/pds_ms_get_utils.hpp"
#include "nic/metaswitch/stubs/mgmt/pds_ms_mgmt_state.hpp"
#include <google/protobuf/util/json_util.h>

#define SHARED_DATA_TYPE SMS_SHARED_LOCAL

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
    /*===== Dump Spec: {{$msgName}} =====*/
    NBB_VOID pds_ms_dump_{{$msgName | ToLower}}({{$pkgName}}::{{$msgName}} &req) {
        std::string cfg;
        google::protobuf::util::JsonPrintOptions options;
        options.add_whitespace = true;
        options.always_print_primitive_fields = true;
        options.preserve_proto_field_names = true;
        google::protobuf::util::MessageToJsonString(req, &cfg, options);
        PDS_TRACE_DEBUG("{{$msgName}} configuration:");
        PDS_TRACE_DEBUG("%s", cfg.c_str());
  {{$fields := .Fields}}
  {{range $fields}}
    {{$castFn := getPdsaCastPrintFunc .Type}}
    {{if (eq $castFn "pds_ms_print_byte_array")}}
      {{if (isRepeatedField .)}}
      for (int i=0; i<req.{{.Name | ToLower}}_size(); i++) {
          {{$castFn}}(req.{{.Name | ToLower}}(i), "{{$msgName}}", "{{.Name}}");
      }
      {{else}}
      {{$castFn}}(req.{{.Name | ToLower}}(), "{{$msgName}}", "{{.Name}}");
      {{end}}
    {{end}}
  {{end}}
    }
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if and (hasExtension "venice.pdsaSetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key") (Contains .GetName "Clear")))}}
    {{$param  := (getPdsaSetGlobalOpts . $cam)}}
    {{$oidLen := $param.OidLen}}
    {{$oidFam := $param.OidFam}}
    {{$struct := $param.Struct}}
    {{$mib    := $param.Mib}}
    {{$fillFn := $param.FillFn}}
    {{if not (eq $oidLen "")}}
    /*===== Validate {{$msgName}} =====*/
    NBB_VOID pds_ms_validate_{{$msgName | ToLower}}({{$pkgName}}::{{$msgName}} &req) {
    {{$fields := .Fields}}
    {{range $fields}}
      {{if hasExtension "venice.pdsaFields" .}}
        {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
        {{if (eq $isFldInTbl true)}}
          {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
          {{$castFn := getPdsaCastValidateFunc .Type}}
          {{if (eq $castFn "pds_ms_validate_byte_array")}}
        {{$castFn}}(req.{{.Name | ToLower}}(), "{{$msgName}}", "{{.Name}}", {{$fieldOpt.FieldMinLen}}, {{$fieldOpt.FieldLen}});
          {{end}}
        {{end}}
      {{end}}
    {{end}}
    }
    /*===== Set MS Table: {{$struct}} =====*/
    NBB_VOID pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid({{$pkgName}}::{{$msgName}} &req,
                                       NBB_ULONG *oid) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};

      {{$fields := .Fields}}
      {{range $fields}}
        {{if hasExtension "venice.pdsaFields" .}}
          {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} !!!
          {{else}}
            {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
            {{if (eq $fieldOpt.IsKey true) }}
        // ProtoFieldType: {{.Type}} ProtoFieldName: {{$fieldOpt.Name}}
        // MSFieldType: {{$fieldOpt.CppDataType}} ProtoFieldTypeName: {{.GetTypeName}}
              {{if (eq $fieldOpt.SetKeyOidFn "")}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
        NBB_LONG        ambAddrType_{{$fieldOpt.Name | ToLower}};
        NBB_ULONG       ambAddrLen_{{$fieldOpt.Name | ToLower}};
        NBB_BYTE        ambAddr_{{$fieldOpt.Name | ToLower}}[AMB_BGP_MAX_IP_PREFIX_LEN];
        ip_addr_t       outAddr_{{$fieldOpt.Name | ToLower}};
        NBB_ULONG       ii_{{$fieldOpt.Name | ToLower}} = 0;

        ip_addr_spec_to_ip_addr(req.{{$fieldOpt.Name | ToLower}}(), &outAddr_{{$fieldOpt.Name | ToLower}});
        pds_ms_convert_ip_addr_to_amb_ip_addr(outAddr_{{$fieldOpt.Name | ToLower}}, &ambAddrType_{{$fieldOpt.Name | ToLower}},
                                          &ambAddrLen_{{$fieldOpt.Name | ToLower}}, ambAddr_{{$fieldOpt.Name | ToLower}},
                                          {{$fieldOpt.IsZeroIPValid}});
        // Fill oid now
        oid[{{$fieldOpt.SetKeyOidAddrTypeIndex}}]   = ambAddrType_{{$fieldOpt.Name | ToLower}};
        oid[{{$fieldOpt.SetKeyOidAddrIndex}}]       = ambAddrLen_{{$fieldOpt.Name | ToLower}};
        for (ii_{{$fieldOpt.Name | ToLower}} = 0; ii_{{$fieldOpt.Name | ToLower}} < ambAddrLen_{{$fieldOpt.Name | ToLower}}; ii_{{$fieldOpt.Name | ToLower}}++)
        {
            oid[{{$fieldOpt.SetKeyOidAddrIndex}} + 1 + ii_{{$fieldOpt.Name | ToLower}}] = (NBB_ULONG) ambAddr_{{$fieldOpt.Name | ToLower}}[ii_{{$fieldOpt.Name | ToLower}}];
        }
                {{else}}
                  {{$castFn := getPdsaCastSetFunc .Type $fieldOpt.CppDataType $fieldOpt}}
                  {{if (eq $castFn "")}}
        oid[{{$fieldOpt.SetKeyOidIndex}}] = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                  {{else}}
                    {{if (eq $fieldOpt.FieldHasLen false)}}
        {{$castFn}}_oid(oid, req.{{$fieldOpt.Name | ToLower}}(), {{$fieldOpt.SetKeyOidIndex}});
                    {{else}}
        {{$castFn}}_oid(oid, req.{{$fieldOpt.Name | ToLower}}(), {{$fieldOpt.SetKeyOidIndex}}, {{$fieldOpt.SetKeyOidLenIndex}});
                    {{end}}
                  {{end}}
                {{end}}
              {{else}}
        {{$fieldOpt.SetKeyOidFn}}(req, oid);
              {{end}}
            {{end}}
          {{end}}
        {{end}}
      {{end}}
        NBB_TRC_EXIT();
    } /* pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid */

    NBB_VOID pds_ms_fill_{{$msgName | ToLower}}_{{$struct | ToLower}}_fields({{$pkgName}}::{{$msgName}} &req,
                                             AMB_GEN_IPS *mib_msg,
                                             {{$struct}} *v_{{$struct | ToLower}},
                                             NBB_LONG row_status) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        NBB_TRC_ENTRY("pds_ms_fill_{{$msgName | ToLower}}_{{$struct | ToLower}}_fields");

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(mib_msg);

      {{$rowStOid := (getRowStatusOid $cam $struct)}}
      {{if not (eq $rowStOid "") }}
        /***************************************************************************/
        /* We always want to set the row status.                                   */
        /***************************************************************************/
        v_{{$struct | ToLower}}->row_status = row_status;
        AMB_SET_FIELD_PRESENT(mib_msg, {{$rowStOid}});
      {{end}}

      {{$fields := .Fields}}
      {{range $fields}}
        {{if hasExtension "venice.pdsaFields" .}}
          {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
          {{if (eq $fieldOpt.IsReadOnly true)}}
            // {{$fieldOpt.Name}} is read-only. So not setting it.
          {{else}}
            {{if (eq $fieldOpt.IsKey false) }}
        if (row_status != AMB_ROW_DESTROY) {
            NBB_TRC_FLOW ((NBB_FORMAT "Not destroying RM: fill in field {{$fieldOpt.Field}} in {{$struct}}"));
            {{end}}
            {{if (eq $fieldOpt.IgnoreIfEmpty true) }}
            if (req.{{$fieldOpt.Name | ToLower}}() != "") {
            {{end}}
            {{if not (eq $fieldOpt.Field "")}}
                // {{.Type}} {{$fieldOpt.Name}} {{$fieldOpt.CppDataType}}
              {{if (eq $fieldOpt.SetFieldFn "")}}
                {{$castFn := getPdsaCastSetFunc .Type $fieldOpt.CppDataType $fieldOpt}}
                {{if (eq $castFn "")}}
                  {{if (eq .GetTypeName ".types.IPAddress")}}
                ip_addr_t       outAddr_{{$fieldOpt.Field}};

                ip_addr_spec_to_ip_addr(req.{{$fieldOpt.Name | ToLower}}(), &outAddr_{{$fieldOpt.Field}});
                    {{if or (eq $fieldOpt.AddrTypeFieldName "") (eq $fieldOpt.AddrLenFieldName "")}}
                pds_ms_convert_ip_addr_to_amb_ip_addr(outAddr_{{$fieldOpt.Field}},
                                                      &(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_type),
                                                      &(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_len),
                                                      v_{{$struct | ToLower}}->{{$fieldOpt.Field}},
                                                      {{$fieldOpt.IsZeroIPValid}});
                    {{else}}
                pds_ms_convert_ip_addr_to_amb_ip_addr(outAddr_{{$fieldOpt.Field}},
                                                      &(v_{{$struct | ToLower}}->{{$fieldOpt.AddrTypeFieldName}}),
                                                      &(v_{{$struct | ToLower}}->{{$fieldOpt.AddrLenFieldName}}),
                                                      v_{{$struct | ToLower}}->{{$fieldOpt.Field}},
                                                      {{$fieldOpt.IsZeroIPValid}});
                    {{end}}
                AMB_SET_FIELD_PRESENT (mib_msg, {{$fieldOpt.SetFieldIdx}}-1);
                  {{else}} 
                    {{if (eq .GetTypeName ".pds_ms.EvpnCfg")}}
                pds_ms_set_evpn_cfg((NBB_LONG*)&v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$fieldOpt.Name | ToLower}}());
                    {{else}}
                      {{if (eq .GetTypeName ".pds_ms.EvpnRtType")}}
                pds_ms_set_evpn_rttype((NBB_LONG*)&v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$fieldOpt.Name | ToLower}}());
                      {{else}}
                v_{{$struct | ToLower}}->{{$fieldOpt.Field}} = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                      {{end}}
                    {{end}}
                  {{end}}
                {{else}}
                  {{if (eq $castFn "pds_ms_set_amb_bool")}}
                  {{$castFn}}((NBB_LONG*)&v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
                    {{if (eq $fieldOpt.FieldHasLen false)}}
                  {{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$fieldOpt.Name | ToLower}}());
                    {{else}}
                  {{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, (NBB_ULONG*)&(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_len), req.{{$fieldOpt.Name | ToLower}}());
                    {{end}}
                  {{end}}
                {{end}}
                AMB_SET_FIELD_PRESENT(mib_msg, {{$fieldOpt.SetFieldIdx}});
              {{else}}
                {{$fieldOpt.SetFieldFn}}(req, mib_msg);
              {{end}}
            {{else}}
              {{if TypeIsMessage .}}
                {{if (eq $fieldOpt.Field "")}}
                  {{$myvar := (joinFields $pkgName "." ".")}}
                  {{$parentFieldName := .GetName}}
                  {{$parentFieldTypeName := (TrimPrefix .GetTypeName $myvar)}}
                  {{$parentFieldName := $fieldOpt.Name}}
                  {{range $msgs}}
                    {{$myMsgName := .GetName}}
                    {{if (eq $myMsgName $parentFieldTypeName)}}
                      {{$fields := .Fields}}
                      {{range $fields}}
                        {{if hasExtension "venice.pdsaFields" .}}
                          {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
        // {{$fieldOpt.Name}}
                          {{if (eq $fieldOpt.SetFieldFn "")}}
        v_{{$struct | ToLower}}->{{$fieldOpt.Field}} = ({{$fieldOpt.CppDataType}})req.{{$parentFieldName}}().{{$fieldOpt.Name | ToLower}}();
                          {{else}}
        {{$fieldOpt.SetFieldFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$parentFieldName}}().{{$fieldOpt.Name | ToLower}}());
                          {{end}}
        AMB_SET_FIELD_PRESENT(mib_msg, {{$fieldOpt.SetFieldIdx}});
                        {{end}}
                      {{end}}
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
            {{if (eq $fieldOpt.IgnoreIfEmpty true) }}
            }
            {{end}}
            {{if (eq $fieldOpt.IsKey false) }}
        }
            {{end}}
          {{end}}
        {{end}}
      {{end}}
        NBB_TRC_EXIT();
    } /* pds_ms_fill_{{$msgName | ToLower}}_{{$struct | ToLower}}_fields */

    NBB_VOID pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator,
                                            bool skip_fill,
                                            bool op_update) {
        ATG_CPI_ROW_UPDATE  *row_update = NULL;
        AMB_GEN_IPS         *mib_msg = NULL;

        NBB_TRC_ENTRY("pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}");

        // Build row update
        row_update = pds_ms_ctm_bld_row_update_common (&mib_msg,
                                                     sizeof({{$struct}}),
                                                     {{$oidLen}},
                                                     row_status,
                                                     test_correlator);

        NBB_ASSERT_PTR_NE (row_update, NULL);
        NBB_ASSERT_PTR_NE (mib_msg, NULL);

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        NBB_ULONG *oid = (NBB_ULONG *)((NBB_BYTE *)mib_msg + mib_msg->oid_offset);
        pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid(req, oid);

        /***************************************************************************/
        /* Build {{$struct}}.                                                     */
        /***************************************************************************/
        {{$struct}} *data = ({{$struct}}*)((NBB_BYTE *)mib_msg + mib_msg->data_offset);
        if (!skip_fill) {
            pds_ms_fill_{{$msgName | ToLower}}_{{$struct | ToLower}}_fields(req, mib_msg, data, row_status);
        } else {
            AMB_SET_ALL_FIELDS_NOT_PRESENT(mib_msg);
        }
      {{if not (eq $fillFn "")}}
        {{$fillFn}}(req, mib_msg, data, row_status);
      {{end}}

        // Send the Row Update request to CSS
        NBB_SEND_IPS (SHARED.css_pid, USER_TO_CPI_Q, row_update);

        NBB_TRC_EXIT();
        return;
    } /* pds_ms_set_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}(pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator,
                                            NBB_VOID* kh,
                                            bool op_update) {
        if (pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(req, row_status, test_correlator, kh, op_update);
        }
        return;
    } /* pds_ms_pre_set_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}(post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_post_set_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator,
                                            NBB_VOID* kh,
                                            bool op_update) {
        if (post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            post_set_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(req, row_status, test_correlator, kh, op_update);
        }
        return;
    } /* pds_ms_post_set_{{$msgName | ToLower}}_{{$struct | ToLower}} */
    {{end}}
  {{end}}
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if and (hasExtension "venice.pdsaGetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key") (Contains .GetName "Clear") (HasSuffix .GetName "Filter")))}}
    {{$param := (getPdsaGetGlobalOpts . $cam)}}
    {{$oidLen := $param.OidLen}}
    {{$oidFam := $param.OidFam}}
    {{$struct := $param.Struct}}
    {{$mib    := $param.Mib}}
    {{$fillFn := $param.FillFn}}
    {{$specMsgName := $param.SpecMsg}}
    {{if (eq $specMsgName "")}}
      {{$specMsgName = (TrimPrefix .GetName $pkg)}}
    {{end}}
    {{if not (eq $oidLen "")}}
    /*===== Get MS Table: {{$struct}} =====*/
      {{$rootMsg := getResponseRootMsg $file $pkgName $msg}}
      {{if or (HasSuffix $msg.GetName "Spec") (HasSuffix $msg.GetName "spec")}}
    NBB_LONG pds_ms_check_get_{{$msgName | ToLower}}_spec_response_count;
      {{end}}
      {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
    NBB_LONG pds_ms_check_get_{{$msgName | ToLower}}_status_response_count;
      {{end}}
    NBB_VOID pds_ms_check_get_{{$msgName | ToLower}}_{{$struct | ToLower}}(NBB_CXT_T NBB_CXT)
    {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get;
        NBB_LONG bulk_row;
        NBB_ULONG num_entries=0;
        bool specific_get = false;
        {{$struct}} *v_{{$struct | ToLower}};

        NBB_TRC_ENTRY("pds_ms_check_get_{{$msgName | ToLower}}_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Check assumptions.                                                      */
        /***************************************************************************/
        NBB_ASSERT_PTR_NE(SHARED.saved_ips, NULL);
        NBB_ASSERT_NUM_EQ(SHARED.saved_ips->ips_type, IPS_AMB_GET);

        v_amb_get = (AMB_GET *)SHARED.saved_ips;
        {{$pkgName}}::{{$rootMsg.GetName}} *resp = ({{$pkgName}}::{{$rootMsg.GetName}}*)v_amb_get->correlator.pds_ms_resp_ctx;
        SHARED.saved_ips = NULL;

        if (({{$struct}} *)NTL_OFF_GET_POINTER(v_amb_get, &v_amb_get->bulk_data_offset) == NULL) {
            specific_get = true;
        }
        if (v_amb_get->ret_code == AMB_RC_NO_ERROR)
        {
            /*************************************************************************/
            /* This GET response contains entry from {{$struct}}                     */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "Got a valid {{$struct}} entry"));
            v_{{$struct | ToLower}} = ({{$struct}} *)NTL_OFF_GET_POINTER(v_amb_get,
                                                        &v_amb_get->bulk_data_offset);
            if (v_{{$struct | ToLower}} == NULL) {
                v_{{$struct | ToLower}} = ({{$struct}} *)((NBB_BYTE *)v_amb_get +
                                                       v_amb_get->data_offset);
            }

      {{$reqfields := $rootMsg.Fields}}
      {{range $reqfields}}
        {{if (eq .GetName "Response")}}
          {{if HasSuffix $msg.GetName "Status"}}
            {{$specPresent := false}}
            {{$fieldMsg := ($file.Reg.LookupMsg "" .GetTypeName)}}
            {{$fields := $fieldMsg.Fields}}
            {{range $fields}}
              {{if or (HasSuffix .GetName "Spec") (HasSuffix .GetName "spec")}}
                {{$specMsgName := .GetName}}
                {{$specPresent = true}}
              {{end}}
            {{end}}
            {{if $specPresent}}
              {{if (isRepeatedField .)}}
            if ((pds_ms_check_get_{{$msgName | ToLower}}_status_response_count + v_amb_get->bulk_returned) >
                 pds_ms_check_get_{{$specMsgName | ToLower}}_spec_response_count) {
                /*************************************************************************/
                /* number of status entries retrieved are more than spec entries         */
                /*************************************************************************/
                NBB_TRC_FLOW((NBB_FORMAT "GET failure"));
                PDS_TRACE_ERR ("Get failure, {{$msgName}} entries %d are more than {{$specMsgName}} %d",
                    (pds_ms_check_get_{{$msgName | ToLower}}_status_response_count + v_amb_get->bulk_returned),
                    pds_ms_check_get_{{$specMsgName | ToLower}}_spec_response_count);
                v_amb_get->correlator.pds_ms_resp_ctx = NULL;
                NBB_FREE_BUFFER(v_amb_get);
                v_amb_get = NULL;

                /*************************************************************************/
                /* We are no longer responsible for incoming GETs.                       */
                /*************************************************************************/
                SHARED.wait_check_get = NULL;
                pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;

                /*************************************************************************/
                /* Send response back to the caller.                                     */
                /*************************************************************************/
                pds_ms::mgmt_state_t::ms_response_ready(types::ApiStatus::API_STATUS_ERR);
                return;
            }
              {{end}}
            {{end}}
          {{end}}
        {{end}}
      {{end}}

            for (bulk_row = 0; bulk_row < v_amb_get->bulk_returned; bulk_row++)
            {
                if (pds_ms_pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}(v_{{$struct | ToLower}})) {
                    num_entries++;

      {{$reqfields := $rootMsg.Fields}}
      {{range $reqfields}}
        {{if (eq .GetName "Response")}}
          {{if HasSuffix $msg.GetName "Status"}}
            {{$specPresent := false}}
            {{$fieldMsg := ($file.Reg.LookupMsg "" .GetTypeName)}}
            {{$fields := $fieldMsg.Fields}}
            {{range $fields}}
              {{if or (HasSuffix .GetName "Spec") (HasSuffix .GetName "spec")}}
                {{$specPresent = true}}
              {{end}}
            {{end}}
            {{if $specPresent}}
              {{if (isRepeatedField .)}}
                    auto res = resp->mutable_response(pds_ms_check_get_{{$msgName | ToLower}}_status_response_count + bulk_row);
                    auto ent = res->mutable_status();
              {{else}}
                    auto res = resp->mutable_response();
                    auto ent = res->mutable_status();
              {{end}}
            {{else}}
              {{if (isRepeatedField .)}}
                    auto res = resp->add_response();
              {{else}}
                    auto res = resp->mutable_response();
              {{end}}
                    auto ent = res->mutable_status();
            {{end}}
          {{end}}
          {{if HasSuffix $msg.GetName "Spec"}}
            {{if (isRepeatedField .)}}
                    auto res = resp->add_response();
            {{else}}
                    auto res = resp->mutable_response();
            {{end}}
                    auto ent = res->mutable_spec();
          {{end}}
        {{end}}
      {{end}}
                    /*************************************************************************/
                    /* TODO: Extract the fields.                                             */
                    /*************************************************************************/
      {{$fields := .Fields}}
      {{range $fields}}
        {{if hasExtension "venice.pdsaFields" .}}
          {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
                    // !!! {{.Name}} field is not in table {{$mib}} !!!
          {{else}}
            {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
            {{if and (not (eq $fieldOpt.Name "")) }}
                    // {{.Type}} {{.GetTypeName}} {{$fieldOpt.Name}} {{$fieldOpt.CppDataType}} {{.GetLabel}}
              {{if (eq $fieldOpt.GetFieldFn "")}}
                {{$castFn := getPdsaCastGetFunc .Type $fieldOpt.CppDataType $fieldOpt}}
                  {{if (eq $castFn "")}}
                    {{if (eq .GetTypeName ".types.IPAddress")}}
                    auto {{$fieldOpt.Name | ToLower}}_addr = ent->mutable_{{$fieldOpt.Name | ToLower}}();
                    types::IPAddress   res_{{$fieldOpt.Field}};
                    ip_addr_t          pds_ms_ip_addr_{{$fieldOpt.Field}} = {0};
                      {{if or (eq $fieldOpt.AddrTypeFieldName "") (eq $fieldOpt.AddrLenFieldName "")}}
                    pds_ms_convert_amb_ip_addr_to_ip_addr(v_{{$struct | ToLower}}->{{$fieldOpt.Field}},
                                                          v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_type,
                                                          v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_len,
                                                          &pds_ms_ip_addr_{{$fieldOpt.Field}});
                      {{else}}
                    pds_ms_convert_amb_ip_addr_to_ip_addr(v_{{$struct | ToLower}}->{{$fieldOpt.Field}},
                                                          v_{{$struct | ToLower}}->{{$fieldOpt.AddrTypeFieldName}},
                                                          v_{{$struct | ToLower}}->{{$fieldOpt.AddrLenFieldName}},
                                                          &pds_ms_ip_addr_{{$fieldOpt.Field}});
                      {{end}}
                    ip_addr_to_spec(&pds_ms_ip_addr_{{$fieldOpt.Field}}, &res_{{$fieldOpt.Field}});
                    {{$fieldOpt.Name | ToLower}}_addr->set_af(res_{{$fieldOpt.Field}}.af());
                    {{$fieldOpt.Name | ToLower}}_addr->set_v4addr(res_{{$fieldOpt.Field}}.v4addr());
                    {{else}}
                      {{if (eq .GetTypeName ".pds_ms.EvpnCfg")}}
                    ent->set_{{$fieldOpt.Name | ToLower}}(pds_ms_get_evpn_cfg(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}));
                      {{else}}
                        {{if (eq .GetTypeName ".pds_ms.EvpnRtType")}}
                    ent->set_{{$fieldOpt.Name | ToLower}}(pds_ms_get_evpn_rttype(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}));
                        {{else}}
                        {{$typeCastFn := (getCppTypeFieldFromProto .Type .GetTypeName)}}
                          {{if (eq $typeCastFn "")}}
                    ent->set_{{$fieldOpt.Name | ToLower}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}});
                          {{else}}
                    ent->set_{{$fieldOpt.Name | ToLower}}(({{$typeCastFn}})v_{{$struct | ToLower}}->{{$fieldOpt.Field}});
                          {{end}}
                        {{end}}
                      {{end}}
                    {{end}}
                  {{else}}
                    {{if or (eq $castFn "pds_ms_nbb_get_long") (eq $castFn "pds_ms_get_amb_bool")}}
                    ent->set_{{$fieldOpt.Name | ToLower}}({{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}));
                    {{else}}
                      {{if (eq $fieldOpt.FieldHasLen false)}}
                    ent->set_{{$fieldOpt.Name | ToLower}}({{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, {{$fieldOpt.FieldLen}}));
                      {{else}}
                        {{if not (eq $fieldOpt.PackedElemSize "")}} 
                          {{if (isRepeatedField .)}}
                    for (int i=0; i<v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_len/{{$fieldOpt.PackedElemSize}}; i++) {
                        ent->add_{{$fieldOpt.Name | ToLower}}({{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}+(i*{{$fieldOpt.PackedElemSize}}), {{$fieldOpt.PackedElemSize}}));
                    }
                          {{else}}
                    //Field {{$fieldOpt.Name}} has PackedElemSize set to {{$fieldOpt.PackedElemSize}} but is not set to repeated!
                          {{end}}
                        {{else}}
                    ent->set_{{$fieldOpt.Name | ToLower}}({{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, v_{{$struct | ToLower}}->{{$fieldOpt.Field}}_len));
                        {{end}}
                      {{end}}
                    {{end}}
                  {{end}}
                {{else}}
                    {{$fieldOpt.GetFieldFn}}(ent, v_{{$struct | ToLower}});
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
              }

                /***********************************************************************/
                /* Go to the next MIB row returned.                                    */
                /***********************************************************************/
                v_{{$struct | ToLower}} = ({{$struct}} *)(((NBB_BYTE *)v_{{$struct | ToLower}}) +
                                        NBB_ALIGN_OFFSET(v_amb_get->data_len));
            }

        {{if HasSuffix $msg.GetName "Status"}}
            pds_ms_check_get_{{$msgName | ToLower}}_status_response_count += num_entries;
        {{else}}
            pds_ms_check_get_{{$msgName | ToLower}}_spec_response_count += num_entries;
        {{end}}

            if (specific_get) {
                /*************************************************************************/
                /* Free the buffer.                                                      */
                /*************************************************************************/
                NBB_FREE_BUFFER(v_amb_get);
                v_amb_get = NULL;

                /*************************************************************************/
                /* The wait_check_get callback determines which procedure is responsible */
                /* for incoming GET response signals.  The last GET response has been    */
                /* received, and we are no longer responsible for incoming GETs.  Clear  */
                /* the callback.                                                         */
                /*************************************************************************/
                SHARED.wait_check_get = NULL;
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
                pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}
                /*************************************************************************/
                /* Send response back to the caller.                                     */
                /*************************************************************************/
                pds_ms::mgmt_state_t::ms_response_ready(types::ApiStatus::API_STATUS_OK);
            } else {
                /*************************************************************************/
                /* Send back the GET response as a GET request.  Because the             */
                /* get_next_object flag is set, it will return the next {{$struct}} entry*/
                /*************************************************************************/
                NBB_SEND_IPS(SHARED.sm_pid, AMB_MIB_Q, v_amb_get);
                SMS_GET_INC();
                v_amb_get = NULL;
            }
        }
        else if (v_amb_get->ret_code == AMB_RC_GET_RESCHEDULE)
        {
            /*************************************************************************/
            /* The product has bounded the amount of processing it does in a single  */
            /* schedule.  The information in the GET does not represent a valid      */
            /* entry, just the last entry the product got to before deciding to      */
            /* reschedule.  Hence do not print the entry out.                        */
            /*                                                                       */
            /* Instead, send the GET response back as a GET-NEXT request (i.e.       */
            /* exact = ATG_NO and get_next_object = ATG_YES) in order to restart the */
            /* GET processing from where the product left off.  Because the          */
            /* get_next_object flag is set, the product will return the next BGP     */
            /* route.                                                                */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "Reschedule GET"));
            v_amb_get->exact = ATG_NO;
            v_amb_get->get_next_object = ATG_YES;
            NBB_SEND_IPS(SHARED.sm_pid, AMB_MIB_Q, v_amb_get);
            SMS_GET_INC();
            v_amb_get = NULL;
        }
        else if (v_amb_get->ret_code == AMB_RC_RESOURCE_UNAVAILABLE)
        {
            /*************************************************************************/
            /* The product failed to process the GET due to a resource failure.      */
            /*                                                                       */
            /* A MIB stub could decide to take action here, for example try again or */
            /* report the error.  However we just free the buffer and continue with  */
            /* the next FSM action.                                                  */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "GET failure"));
            v_amb_get->correlator.pds_ms_resp_ctx = NULL;
            NBB_FREE_BUFFER(v_amb_get);
            v_amb_get = NULL;

            /*************************************************************************/
            /* We are no longer responsible for incoming GETs.                       */
            /*************************************************************************/
            SHARED.wait_check_get = NULL;
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
            pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}

            /*************************************************************************/
            /* Send response back to the caller.                                     */
            /*************************************************************************/
            pds_ms::mgmt_state_t::ms_response_ready(types::ApiStatus::API_STATUS_OUT_OF_RESOURCE);
        }
        else if (v_amb_get->ret_code == AMB_RC_NO_SUCH_OBJECT)
        {
            /*************************************************************************/
            /* The product failed to process either GET with specific key or         */ 
            /* object doesn't exist yet                                              */
            /*                                                                       */
            /* A MIB stub could decide to take action here, for example try again or */
            /* report the error.  However we just free the buffer and continue with  */
            /* the next FSM action.                                                  */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "GET failure"));
            PDS_TRACE_ERR ("Get failure, no such entry/object exists");
            v_amb_get->correlator.pds_ms_resp_ctx = NULL;
            NBB_FREE_BUFFER(v_amb_get);
            v_amb_get = NULL;

            /*************************************************************************/
            /* We are no longer responsible for incoming GETs.                       */
            /*************************************************************************/
            SHARED.wait_check_get = NULL;
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
            pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}

            /*************************************************************************/
            /* Send response back to the caller.                                     */
            /*************************************************************************/
            pds_ms::mgmt_state_t::ms_response_ready(types::ApiStatus::API_STATUS_NOT_FOUND);
        }
        else
        {
            /*************************************************************************/
            /* No more routes.  Free the buffer and move on to the next action.      */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "End of table"));
            NBB_ASSERT_NUM_EQ(v_amb_get->ret_code, AMB_RC_END_OF_TABLE);

            /*************************************************************************/
            /* Free the buffer.                                                      */
            /*************************************************************************/
            v_amb_get->correlator.pds_ms_resp_ctx = NULL;
            NBB_FREE_BUFFER(v_amb_get);
            v_amb_get = NULL;

            /*************************************************************************/
            /* The wait_check_get callback determines which procedure is responsible */
            /* for incoming GET response signals.  The last GET response has been    */
            /* received, and we are no longer responsible for incoming GETs.  Clear  */
            /* the callback.                                                         */
            /*************************************************************************/
            SHARED.wait_check_get = NULL;
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
            pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}
            /*************************************************************************/
            /* Send response back to the caller.                                     */
            /*************************************************************************/
            pds_ms::mgmt_state_t::ms_response_ready(types::ApiStatus::API_STATUS_OK);
        }

        NBB_TRC_EXIT();

        return;

    } /* pds_ms_check_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid({{$pkgName}}::{{$specMsgName}} &req,
                                       NBB_ULONG *oid  NBB_CCXT_T NBB_CXT) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};
        {{if not (eq $specMsgName "")}}
        {{$specMsg := (getMsg $file $pkg $specMsgName)}}
        {{$fields := $specMsg.Fields}}
        {{range $fields}}
          {{if hasExtension "venice.pdsaFields" .}}
            {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
            {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} !!!
            {{else}}
              {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{if (eq $fieldOpt.IsKey true) }}
        // ProtoFieldType: {{.Type}} ProtoFieldName: {{$fieldOpt.Name}}
        // MSFieldType: {{$fieldOpt.CppDataType}} ProtoFieldTypeName: {{.GetTypeName}}
                {{if (eq $fieldOpt.GetKeyOidFn "")}}
                  {{if (eq .GetTypeName ".types.IPAddress")}}
        NBB_LONG        ambAddrType_{{$fieldOpt.Name | ToLower}};
        NBB_ULONG       ambAddrLen_{{$fieldOpt.Name | ToLower}};
        NBB_BYTE        ambAddr_{{$fieldOpt.Name | ToLower}}[AMB_BGP_MAX_IP_PREFIX_LEN];
        ip_addr_t       outAddr_{{$fieldOpt.Name | ToLower}};
        NBB_ULONG       ii_{{$fieldOpt.Name | ToLower}} = 0;

        ip_addr_spec_to_ip_addr(req.{{$fieldOpt.Name | ToLower}}(), &outAddr_{{$fieldOpt.Name | ToLower}});
        pds_ms_convert_ip_addr_to_amb_ip_addr(outAddr_{{$fieldOpt.Name | ToLower}}, &ambAddrType_{{$fieldOpt.Name | ToLower}},
                                          &ambAddrLen_{{$fieldOpt.Name | ToLower}}, ambAddr_{{$fieldOpt.Name | ToLower}},
                                          {{$fieldOpt.IsZeroIPValid}});
        // Fill oid now
        oid[{{$fieldOpt.GetKeyOidAddrTypeIndex}}]   = ambAddrType_{{$fieldOpt.Name | ToLower}};
        oid[{{$fieldOpt.GetKeyOidAddrIndex}}]       = ambAddrLen_{{$fieldOpt.Name | ToLower}};
        for (ii_{{$fieldOpt.Name | ToLower}} = 0; ii_{{$fieldOpt.Name | ToLower}} < ambAddrLen_{{$fieldOpt.Name | ToLower}}; ii_{{$fieldOpt.Name | ToLower}}++)
        {
            oid[{{$fieldOpt.GetKeyOidAddrIndex}} + 1 + ii_{{$fieldOpt.Name | ToLower}}] = (NBB_ULONG) ambAddr_{{$fieldOpt.Name | ToLower}}[ii_{{$fieldOpt.Name | ToLower}}];
        }
                  {{else}}
                    {{$castFn := getPdsaCastGetFunc .Type $fieldOpt.CppDataType $fieldOpt}}
                    {{if (eq $castFn "")}}
        oid[{{$fieldOpt.GetKeyOidIndex}}] = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                    {{else}}
                      {{if (eq $fieldOpt.FieldHasLen false)}}
        {{$castFn}}_oid(oid, req.{{$fieldOpt.Name | ToLower}}(), {{$fieldOpt.GetKeyOidIndex}});
                      {{else}}
        {{$castFn}}_oid(oid, req.{{$fieldOpt.Name | ToLower}}(), {{$fieldOpt.GetKeyOidIndex}}, {{$fieldOpt.GetKeyOidLenIndex}});
                      {{end}}
                    {{end}}
                  {{end}}
                {{else}}
        {{$fieldOpt.GetKeyOidFn}}(req, oid);
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{end}}
        NBB_TRC_EXIT();
    } /* pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid */

    NBB_VOID pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$specMsgName}} &req, {{$pkgName}}::{{$rootMsg.GetName}}* resp) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get = NULL;
        NBB_ULONG oid[{{$oidLen}}];
        NBB_BUF_SIZE data_len = sizeof({{$struct}});

        NBB_TRC_ENTRY("pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Define the routine to be used on receipt of a GET response.             */
        /***************************************************************************/
        {{if or (HasSuffix $msg.GetName "Spec") (HasSuffix $msg.GetName "spec")}}
        pds_ms_check_get_{{$msgName | ToLower}}_spec_response_count = 0;
        {{end}}
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
        pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}
        SHARED.wait_check_get = pds_ms_check_get_{{$msgName | ToLower}}_{{$struct | ToLower}};

        /***************************************************************************/
        /* Build and send the first GET.                                           */
        /***************************************************************************/

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid(req, oid);

        /***************************************************************************/
        /* Invoke custom fill function registered by the user                      */
        /***************************************************************************/
        {{if not (eq $fillFn "")}}
        {{$fillFn}}(req, oid);
        {{end}}

        /***************************************************************************/
        /* Build the common part of the AMB_GET message.                           */
        /***************************************************************************/
        v_amb_get = pds_ms_amb_get_common(data_len, oid[0], oid);

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(v_amb_get);

        /***************************************************************************/
        /* We're trying to get an exact match.                */
        /***************************************************************************/
        v_amb_get->exact = ATG_YES;
        v_amb_get->get_next_object = ATG_NO;

        v_amb_get->correlator.pds_ms_resp_ctx = (NBB_VOID*)resp;

        /***************************************************************************/
        /* Send AMB_GET.                                                           */
        /***************************************************************************/
        NBB_TRC_FLOW((NBB_FORMAT "Send a {{$struct}} GET MIB."));
        NBB_SEND_IPS (SHARED.sm_pid, AMB_MIB_Q, v_amb_get);

        NBB_TRC_EXIT();
        return;
    } /* pds_ms_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid(NBB_ULONG *oid  NBB_CCXT_T NBB_CXT) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};

        NBB_TRC_EXIT();
    } /* pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid */

        {{$msgnamepfx := TrimSuffix $rootMsg.GetName "Response"}}
        {{$reqRootMsgName := addStr $msgnamepfx "Request"}}
        {{$reqRootMsg := (getMsg $file $pkg $reqRootMsgName)}}
    NBB_VOID pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}(const {{$pkgName}}::{{$reqRootMsg.GetName}}* req, {{$pkgName}}::{{$rootMsg.GetName}}* resp) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get = NULL;
        NBB_ULONG oid[{{$oidLen}}];
        NBB_BUF_SIZE data_len = sizeof({{$struct}});

        NBB_TRC_ENTRY("pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Define the routine to be used on receipt of a GET response.             */
        /***************************************************************************/
        {{if or (HasSuffix $msg.GetName "Spec") (HasSuffix $msg.GetName "spec")}}
        pds_ms_check_get_{{$msgName | ToLower}}_spec_response_count = 0;
        {{end}}
        {{if or (HasSuffix $msg.GetName "Status") (HasSuffix $msg.GetName "status")}}
        pds_ms_check_get_{{$msgName | ToLower}}_status_response_count = 0;
        {{end}}
        SHARED.wait_check_get = pds_ms_check_get_{{$msgName | ToLower}}_{{$struct | ToLower}};

        /***************************************************************************/
        /* Build and send the first GET.                                           */
        /***************************************************************************/

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_oid(oid);

        /***************************************************************************/
        /* Invoke custom fill function registered by the user                      */
        /***************************************************************************/
        {{if not (eq $fillFn "")}}
        //{{$fillFn}}(oid);
        {{end}}

        {{$fields := $reqRootMsg.Fields}}
        {{$hasFilter := false}}
        {{range $fields}}
          {{if (eq .GetName "Filter")}}
            {{$hasFilter = true}}
        if (req->has_filter()) {
            bool setFlag;
            {{$filterMsg := (getMsg $file $pkg (TrimPrefix .GetTypeName $pkg))}}
            {{$filterParam := (getPdsaGetGlobalOpts $filterMsg $cam)}}
            {{$filterMib := $filterParam.FilterMib}}
            NBB_ULONG filter_len = sizeof({{$filterMib}});
            {{$filterMib}} filter_data = {0};
            {{$filterFields := $filterMsg.Fields}}
            {{range $filterFields}}
              {{$filterFieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{$castFn := getPdsaCastSetFilterFunc .Type $filterFieldOpt}}
            setFlag = true;
              {{if (eq $castFn "")}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
            if (req->filter().has_{{.GetName | ToLower}}()) {
                ip_addr_t       outAddr_{{$filterFieldOpt.Field}};

                setFlag = ip_addr_spec_to_ip_addr(req->filter().{{.GetName | ToLower}}(), &outAddr_{{$filterFieldOpt.Field}});
                pds_ms_convert_ip_addr_to_amb_ip_addr(outAddr_{{$filterFieldOpt.Field}},
                                                      &(filter_data.{{$filterFieldOpt.AddrTypeFieldName}}),
                                                      &(filter_data.{{$filterFieldOpt.AddrLenFieldName}}),
                                                      filter_data.{{$filterFieldOpt.Field}},
                                                      {{$filterFieldOpt.IsZeroIPValid}});
                {{else}}
            if (req->filter().{{.GetName | ToLower}}() != 0) {
                filter_data.{{$filterFieldOpt.Field}} = req->filter().{{.GetName | ToLower}}();
                {{end}}
              {{else}}
                {{if (eq $castFn "pds_ms_set_amb_bool")}}
            if (req->filter().{{.GetName | ToLower}}() != false) {
                {{$castFn}}((NBB_LONG*)&filter_data.{{$filterFieldOpt.Field}}, req->filter().{{.GetName | ToLower}}());
                {{else}}
            if (req->filter().{{.GetName | ToLower}}().length() != 0) {
                  {{if (eq $filterFieldOpt.FilterFieldLen "")}} 
                {{$castFn}}((NBB_BYTE*)filter_data.{{$filterFieldOpt.Field}}, req->filter().{{.GetName | ToLower}}());
                  {{else}}
                {{$castFn}}((NBB_BYTE*)filter_data.{{$filterFieldOpt.Field}}, (NBB_ULONG*)&(filter_data.{{$filterFieldOpt.FilterFieldLen}}), req->filter().{{.GetName | ToLower}}());
                  {{end}}
                {{end}}
              {{end}}
                if (setFlag) {
                    filter_data.{{$filterParam.FilterTypeField}} |= {{$filterFieldOpt.FilterType}};
                }
            }
            {{end}}
            /***************************************************************************/
            /* Build the common part of the AMB_GET message.                           */
            /***************************************************************************/
            v_amb_get = pds_ms_amb_get_bulk_common(1000, data_len, oid[0], oid, filter_len, (NBB_BYTE*)&filter_data);
        } else {
            /***************************************************************************/
            /* Build the common part of the AMB_GET message.                           */
            /***************************************************************************/
            // {{$reqRootMsg.GetName}} does not have filter
            NBB_BYTE dummy;

            v_amb_get = pds_ms_amb_get_bulk_common(1000, data_len, oid[0], oid, 0, &dummy);
        }
          {{end}}
        {{end}}
        {{if (eq $hasFilter false)}}
        /***************************************************************************/
        /* Build the common part of the AMB_GET message.                           */
        /***************************************************************************/
        // {{$reqRootMsg.GetName}} does not have filter
        NBB_BYTE dummy;

        v_amb_get = pds_ms_amb_get_bulk_common(1000, data_len, oid[0], oid, 0, &dummy);
        {{end}}

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(v_amb_get);

        /***************************************************************************/
        /* We're trying to get the next object, not an exact match.                */
        /***************************************************************************/
        v_amb_get->exact = ATG_NO;
        v_amb_get->get_next_object = ATG_YES;

        v_amb_get->correlator.pds_ms_resp_ctx = (NBB_VOID*)resp;

        /***************************************************************************/
        /* Send AMB_GET.                                                           */
        /***************************************************************************/
        NBB_TRC_FLOW((NBB_FORMAT "Send a {{$struct}} GET MIB."));
        NBB_SEND_IPS (SHARED.sm_pid, AMB_MIB_Q, v_amb_get);

        NBB_TRC_EXIT();
        return;
    } /* pds_ms_getall_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}(pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    bool pds_ms_pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$struct | ToLower}} *v_{{$struct | ToLower}}) {
        if (pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            return pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(v_{{$struct | ToLower}});
        }
        return true;
    } /* pds_ms_pre_fill_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}(pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$specMsgName}} &req, {{$pkgName}}::{{$rootMsg.GetName}}* resp, NBB_VOID* kh) {
        if (pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(req, resp, kh);
        }
        return;
    } /* pds_ms_pre_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}(post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_post_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$specMsgName}} &req, {{$pkgName}}::{{$rootMsg.GetName}}* resp, NBB_VOID* kh) {
        if (post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            post_get_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(req, resp, kh);
        }
        return;
    } /* pds_ms_post_get_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}(pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}({{$pkgName}}::{{$rootMsg.GetName}}* resp) {
        if (pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(resp);
        }
        return;
    } /* pds_ms_pre_getall_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pds_ms_reg_post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}(post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func_type func) {
        post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func = func;
    } /* pds_ms_reg_post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    NBB_VOID pds_ms_post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}(const {{$pkgName}}::{{$reqRootMsg.GetName}}* req, {{$pkgName}}::{{$rootMsg.GetName}}* resp) {
        if (post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func != NULL) {
            post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}}_func(req, resp);
        }
        return;
    } /* pds_ms_post_getall_{{$msgName | ToLower}}_{{$struct | ToLower}} */

    {{end}}
  {{end}}
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if (HasSuffix .GetName "KeyHandle")}} 
    {{if (hasExtension "venice.pdsaSetGlobOpts" . )}}
      {{$param := (getPdsaSetGlobalOpts . $cam)}}
      {{$struct := $param.Struct}}
      {{$specMsgName := $param.SpecMsg}}
      {{$mib    := $param.Mib}}
      {{if (eq $param.SkipExtToInt true)}}
        {{$extPkgName = "pds_ms"}}
      {{end}}
    // Helper to convert {{.GetName}} to {{$specMsgName}}
    NBB_VOID pds_ms_get_{{$specMsgName | ToLower}}_from_{{.GetName | ToLower}}({{$extPkgName}}::{{.GetName}} in, {{$pkgName}}::{{$specMsgName}} &out) {
      {{$fields := .Fields}}
      {{range $fields}}
        {{if and (eq .GetName "Key") (not (eq $specMsgName ""))}}
        if (in.has_key()) {
          {{$specMsg := (getMsg $file $pkg $specMsgName)}}
          {{$keyMsg := (getMsg $file $pkg (TrimPrefix .GetTypeName $pkg))}}
          {{$fields := $keyMsg.Fields}}
          {{range $fields}}
            {{$keyField := .}}
            {{$fieldProcessed := false}}
            {{range $specMsg.Fields}}
              {{if (eq .GetName $keyField.GetName)}}
                {{if hasExtension "venice.pdsaFields" .}}
                  {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
                  {{if not (eq $isFldInTbl true)}}
            // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
                  {{else}}
                    {{if hasExtension "venice.pdsaFields" .}}
                      {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
                      {{if (eq $fieldOpt.IsKey true) }}
                        {{$fieldProcessed = true}}
                        {{if (eq .GetTypeName ".types.IPAddress")}}
            out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.key().{{$fieldOpt.Name | ToLower}}()));
                        {{else}}
                          {{ if HasPrefix .GetTypeName ".pds_ms."}}
            out.set_{{$fieldOpt.Name | ToLower}}((pds_ms::{{TrimPrefix .GetTypeName ".pds_ms."}})in.key().{{$fieldOpt.Name | ToLower}}());
                          {{else}}
            out.set_{{$fieldOpt.Name | ToLower}}(in.key().{{$fieldOpt.Name | ToLower}}());
                          {{end}}
                        {{end}}
                      {{end}}
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
            {{if not $fieldProcessed}}
            out.set_{{.GetName | ToLower}}(in.key().{{.GetName | ToLower}}());
            {{end}}
          {{end}}
        }
        {{end}}
      {{end}}
    } /* pds_ms_get_{{$specMsgName | ToLower}}_from_{{.GetName | ToLower}} */
    {{else}}
      {{if (hasExtension "venice.pdsaGetGlobOpts" . )}}
        {{$param := (getPdsaGetGlobalOpts . $cam)}}
        {{$struct := $param.Struct}}
        {{$specMsgName := $param.SpecMsg}}
        {{$mib    := $param.Mib}}
        {{if (eq $param.SkipExtToInt true)}}
          {{$extPkgName = "pds_ms"}}
        {{end}}
    // Helper to convert {{.GetName}} to {{$specMsgName}}
    NBB_VOID pds_ms_get_{{$specMsgName | ToLower}}_from_{{.GetName | ToLower}}({{$extPkgName}}::{{.GetName}} in, {{$pkgName}}::{{$specMsgName}} &out) {
        {{$fields := .Fields}}
        {{range $fields}}
          {{if and (eq .GetName "Key") (not (eq $specMsgName ""))}}
        if (in.has_key()) {
            {{$specMsg := (getMsg $file $pkg $specMsgName)}}
            {{$keyMsg := (getMsg $file $pkg (TrimPrefix .GetTypeName $pkg))}}
            {{$fields := $keyMsg.Fields}}
            {{range $fields}}
              {{$keyField := .}}
              {{$fieldProcessed := false}}
              {{range $specMsg.Fields}}
                {{if (eq .GetName $keyField.GetName)}}
                  {{if hasExtension "venice.pdsaFields" .}}
                    {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
                    {{if not (eq $isFldInTbl true)}}
            // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
                    {{else}}
                      {{if hasExtension "venice.pdsaFields" .}}
                        {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
                        {{if (eq $fieldOpt.IsKey true) }}
                          {{$fieldProcessed = true}}
                          {{if (eq .GetTypeName ".types.IPAddress")}}
            out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.key().{{$fieldOpt.Name | ToLower}}()));
                          {{else}}
                            {{ if HasPrefix .GetTypeName ".pds_ms."}}
            out.set_{{$fieldOpt.Name | ToLower}}((pds_ms::{{TrimPrefix .GetTypeName ".pds_ms."}})in.key().{{$fieldOpt.Name | ToLower}}());
                            {{else}}
            out.set_{{$fieldOpt.Name | ToLower}}(in.key().{{$fieldOpt.Name | ToLower}}());
                            {{end}}
                          {{end}}
                        {{end}}
                      {{end}}
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
              {{if not $fieldProcessed}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
            out.set_allocated_{{.GetName | ToLower}}(new types::IPAddress(in.key().{{.GetName | ToLower}}()));
                {{else}}
                  {{ if HasPrefix .GetTypeName ".pds_ms."}}
            out.set_{{.GetName | ToLower}}((pds_ms::{{TrimPrefix .GetTypeName ".pds_ms."}})in.key().{{.GetName | ToLower}}());
                  {{else}}
            out.set_{{.GetName | ToLower}}(in.key().{{.GetName | ToLower}}());
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
        }
          {{end}}
        {{end}}
    } /* pds_ms_get_{{$specMsgName | ToLower}}_from_{{.GetName | ToLower}} */
      {{end}}
    {{end}}
  {{end}}
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if and (hasExtension "venice.pdsaSetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key") (Contains .GetName "Clear"))) (HasPrefix $fileName "internal_")}}
    {{$param := (getPdsaSetGlobalOpts . $cam)}}
    {{$struct := $param.Struct}}
    {{$specMsgName := $param.SpecMsg}}
    {{$mib    := $param.Mib}}
    /*===== Helper to convert external {{$msgName}} to internal =====*/
    NBB_VOID pds_ms_ext_to_int_{{$msgName | ToLower}}({{$extPkgName}}::{{$msgName}} in, {{$pkgName}}::{{$msgName}}& out) {
        PDS_TRACE_VERBOSE ("convert {{$extPkgName}}::{{$msgName}} to {{$pkgName}}::{{$msgName}}");
      {{$fields := .Fields}}
      {{range $fields}}
        {{$fieldProcessed := false}}
        {{if hasExtension "venice.pdsaFields" .}}
        {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
          {{else}}
            {{if hasExtension "venice.pdsaFields" .}}
              {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{$fieldProcessed = true}}
              {{if and (not (eq $fieldOpt.Name "")) (not $fieldOpt.IsInternalField)}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.{{$fieldOpt.Name | ToLower}}()));
                {{else}}
                  {{ if HasPrefix .GetTypeName ".pds_ms."}}
        out.set_{{$fieldOpt.Name | ToLower}}((pds_ms::{{TrimPrefix .GetTypeName ".pds_ms."}})in.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
                    {{if (isRepeatedField .)}}
        for (int i=0; i<in.{{$fieldOpt.Name | ToLower}}_size(); i++) {
            out.add_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}(i));
        }
                    {{else}}
        out.set_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}());
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{if not $fieldProcessed}}
          {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{.GetName | ToLower}}(new types::IPAddress(in.{{.GetName | ToLower}}()));
          {{else}}
        out.set_{{.GetName | ToLower}}(in.{{.GetName | ToLower}}());
          {{end}}
        {{end}}
      {{end}}
    } /* pds_ms_ext_to_int_{{$msgName | ToLower}} */
  {{else}}
    {{if and (hasExtension "venice.pdsaGetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key") (Contains .GetName "Clear"))) (HasPrefix $fileName "internal_")}}
      {{$param := (getPdsaGetGlobalOpts . $cam)}}
      {{$struct := $param.Struct}}
      {{$specMsgName := $param.SpecMsg}}
      {{$mib    := $param.Mib}}
    /*===== Helper to convert external {{$msgName}} to internal =====*/
    NBB_VOID pds_ms_ext_to_int_{{$msgName | ToLower}}({{$extPkgName}}::{{$msgName}}& in, {{$pkgName}}::{{$msgName}}& out) {
        PDS_TRACE_VERBOSE ("convert {{$extPkgName}}::{{$msgName}} to {{$pkgName}}::{{$msgName}}");
      {{$fields := .Fields}}
      {{range $fields}}
        {{$fieldProcessed := false}}
        {{if hasExtension "venice.pdsaFields" .}}
        {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
          {{else}}
            {{if hasExtension "venice.pdsaFields" .}}
            {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{$fieldProcessed = true}}
              {{if and (not (eq $fieldOpt.Name "")) (not $fieldOpt.IsInternalField)}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.{{$fieldOpt.Name | ToLower}}()));
                {{else}}
                  {{ if HasPrefix .GetTypeName ".pds_ms."}}
        out.set_{{$fieldOpt.Name | ToLower}}((pds_ms::{{TrimPrefix .GetTypeName ".pds_ms."}})in.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
                    {{if (isRepeatedField .)}}
        for (int i=0; i<in.{{$fieldOpt.Name | ToLower}}_size(); i++) {
            out.add_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}(i));
        }
                    {{else}}
        out.set_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}());
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{if not $fieldProcessed}}
          {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{.GetName | ToLower}}(new types::IPAddress(in.{{.GetName | ToLower}}()));
          {{else}}
        out.set_{{.GetName | ToLower}}(in.{{.GetName | ToLower}}());
          {{end}}
        {{end}}
      {{end}}
    } /* pds_ms_ext_to_int_{{$msgName | ToLower}} */
    {{end}}
  {{end}}
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if and (hasExtension "venice.pdsaSetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key") (Contains .GetName "Clear"))) (HasPrefix $fileName "internal_")}}
    {{$param := (getPdsaSetGlobalOpts . $cam)}}
    {{$struct := $param.Struct}}
    {{$specMsgName := $param.SpecMsg}}
    {{$mib    := $param.Mib}}
    /*===== Helper to convert external {{$msgName}} to internal =====*/
    NBB_VOID pds_ms_int_to_ext_{{$msgName | ToLower}}(const {{$pkgName}}::{{$msgName}}& in, {{$extPkgName}}::{{$msgName}}& out) {
        PDS_TRACE_VERBOSE ("convert {{$pkgName}}::{{$msgName}} to {{$extPkgName}}::{{$msgName}}");
      {{$fields := .Fields}}
      {{range $fields}}
        {{$fieldProcessed := false}}
        {{if hasExtension "venice.pdsaFields" .}}
        {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
          {{else}}
            {{if hasExtension "venice.pdsaFields" .}}
              {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{$fieldProcessed = true}}
              {{if and (not (eq $fieldOpt.Name "")) (not $fieldOpt.IsInternalField)}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.{{$fieldOpt.Name | ToLower}}()));
                {{else}}
                  {{ if HasPrefix .GetTypeName ".pds_ms."}}
        out.set_{{$fieldOpt.Name | ToLower}}((pds::{{TrimPrefix .GetTypeName ".pds_ms."}})in.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
                    {{if (isRepeatedField .)}}
        for (int i=0; i<in.{{$fieldOpt.Name | ToLower}}_size(); i++) {
            out.add_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}(i));
        }
                    {{else}}
        out.set_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}());
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{if not $fieldProcessed}}
          {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{.GetName | ToLower}}(new types::IPAddress(in.{{.GetName | ToLower}}()));
          {{else}}
        out.set_{{.GetName | ToLower}}(in.{{.GetName | ToLower}}());
          {{end}}
        {{end}}
      {{end}}
    } /* pds_ms_int_to_ext_{{$msgName | ToLower}} */
  {{else}}
    {{if and (hasExtension "venice.pdsaGetGlobOpts" . ) (not (or (HasSuffix .GetName "KeyHandle") (HasSuffix .GetName "Key")))}}
      {{$param := (getPdsaGetGlobalOpts . $cam)}}
      {{$struct := $param.Struct}}
      {{$specMsgName := $param.SpecMsg}}
      {{$mib    := $param.Mib}}
    /*===== Helper to convert external {{$msgName}} to internal =====*/
    NBB_VOID pds_ms_int_to_ext_{{$msgName | ToLower}}(const {{$pkgName}}::{{$msgName}}& in, {{$extPkgName}}::{{$msgName}}& out) {
        PDS_TRACE_VERBOSE ("convert {{$pkgName}}::{{$msgName}} to {{$extPkgName}}::{{$msgName}}");
      {{$fields := .Fields}}
      {{range $fields}}
        {{$fieldProcessed := false}}
        {{if hasExtension "venice.pdsaFields" .}}
        {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
          {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} {{$struct}}!!!
          {{else}}
            {{if hasExtension "venice.pdsaFields" .}}
            {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{$fieldProcessed = true}}
              {{if and (not (eq $fieldOpt.Name "")) (not $fieldOpt.IsInternalField)}}
                {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{$fieldOpt.Name | ToLower}}(new types::IPAddress(in.{{$fieldOpt.Name | ToLower}}()));
                {{else}}
                  {{ if HasPrefix .GetTypeName ".pds_ms."}}
        out.set_{{$fieldOpt.Name | ToLower}}((pds::{{TrimPrefix .GetTypeName ".pds_ms."}})in.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
                    {{if (isRepeatedField .)}}
        for (int i=0; i<in.{{$fieldOpt.Name | ToLower}}_size(); i++) {
            out.add_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}(i));
        }
                    {{else}}
        out.set_{{$fieldOpt.Name | ToLower}}(in.{{$fieldOpt.Name | ToLower}}());
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{if not $fieldProcessed}}
          {{if (eq .GetTypeName ".types.IPAddress")}}
        out.set_allocated_{{.GetName | ToLower}}(new types::IPAddress(in.{{.GetName | ToLower}}()));
          {{else}}
        out.set_{{.GetName | ToLower}}(in.{{.GetName | ToLower}}());
          {{end}}
        {{end}}
      {{end}}
    } /* pds_ms_int_to_ext_{{$msgName | ToLower}} */
    {{end}}
  {{end}}
{{end}}


{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if and (HasSuffix .GetName "GetResponse") (HasPrefix $fileName "internal_")}}
    /*===== Helper to convert GetResponse to external =====*/
    NBB_VOID pds_ms_convert_{{$msgName | ToLower}}_ext_response({{$pkgName}}::{{$msgName}}& in, {{$extPkgName}}::{{$msgName}} *out) {
        PDS_TRACE_VERBOSE ("GetResponse conversion: {{$pkgName}}::{{$msgName}} to {{$extPkgName}}::{{$msgName}}");
    {{$respFields := .Fields}}
    {{range $respFields}}
    {{$respField := .}}
      {{if or (eq "response" .GetName) (eq "Response" .GetName)}}
        {{$repeated := false}}
        {{if (isRepeatedField .)}}
        {{$repeated = true}}
        for (int i=0; i<in.response_size(); i++) {
            auto res = out->add_response();
        {{else}}
            auto res = out->mutable_response();
        {{end}}
        {{if TypeIsMessage .}}
          {{$innerRespMsg := ($file.Reg.LookupMsg "" .GetTypeName)}}
          {{$innerRespFields := $innerRespMsg.Fields}}
          {{$specPresent := false}}
          {{range $innerRespFields}}
          {{$innerRespField := .}}
            {{if or (eq "spec" .GetName) (eq "Spec" .GetName)}}
              {{$specPresent := true}}
              {{$specMsg := ($file.Reg.LookupMsg "" .GetTypeName)}}
              {{if hasExtension "venice.pdsaGetGlobOpts" $specMsg}}
                {{$param := (getPdsaGetGlobalOpts $specMsg $cam)}}
                {{$struct := $param.Struct}}
                {{$specMsgName := (TrimPrefix .GetTypeName $pkg)}}
            auto spec = res->mutable_spec();
                {{if $repeated}}
            pds_ms_int_to_ext_{{$specMsgName | ToLower}}(in.response(i).spec(), *spec);
                {{else}}
            pds_ms_int_to_ext_{{$specMsgName | ToLower}}(in.response().spec(), *spec);
                {{end}}
              {{end}}
            {{end}}
            {{if or (eq "status" .GetName) (eq "Status" .GetName)}}
              {{$specMsg := ($file.Reg.LookupMsg "" .GetTypeName)}}
              {{if hasExtension "venice.pdsaGetGlobOpts" $specMsg}}
                {{$param := (getPdsaGetGlobalOpts $specMsg $cam)}}
                {{$struct := $param.Struct}}
                {{$specMsgName := (TrimPrefix .GetTypeName $pkg)}}
            auto status = res->mutable_status();
                {{if $repeated}}
            pds_ms_int_to_ext_{{$specMsgName | ToLower}}(in.response(i).status(), *status);
                {{else}}
            pds_ms_int_to_ext_{{$specMsgName | ToLower}}(in.response().status(), *status);
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        {{if isRepeatedField .}}
        }
        {{end}}
      {{end}}
    {{end}}
    } /* pds_ms_convert_{{$msgName | ToLower}}_ext_response */
  {{end}}
{{end}}
