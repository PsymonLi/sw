// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.
 /*
 * Package cmd is a auto generated package.
 * Input file: {{.Name}}
 */

#include <string>       // std::string
#include <iostream>     // std::cout
#include <sstream>      // std::stringstream

{{$cam := getMetaswitchMibTablesInfo}}

{{$fileName := .GetName}}
{{$pkgName := .Package}}
#include "nic/metaswitch/stubs/mgmt/gen/mgmt/pdsa_{{TrimSuffix $fileName ".proto"}}_utils_gen.hpp"
#include "nic/metaswitch/stubs/mgmt/pdsa_mgmt_utils.hpp"
#include "nic/metaswitch/stubs/mgmt/pdsa_get_utils.hpp"

#define SHARED_DATA_TYPE SMS_SHARED_LOCAL

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if hasExtension "venice.pdsaSetGlobOpts" . }}
    {{$param  := (getPdsaSetGlobalOpts . $cam)}}
    {{$oidLen := $param.OidLen}}
    {{$oidFam := $param.OidFam}}
    {{$struct := $param.Struct}}
    {{$mib    := $param.Mib}}
    {{$fillFn := $param.FillFn}}
    {{if not (eq $oidLen "")}}
    /*===== Set MS Table: {{$struct}} =====*/
    NBB_VOID pdsa_set_{{$struct | ToLower}}_oid(pds::{{$msgName}} &req,
                                       NBB_ULONG *oid) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pdsa_set_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};

        {{$fields := .Fields}}
        {{range $fields}}
          {{if hasExtension "venice.pdsaFields" .}}
            {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
            {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} !!!
            {{else}}
              {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{if (eq $fieldOpt.IsKey true) }}
        // ProtoFieldType: {{.Type}} ProtoFieldName: {{$fieldOpt.Name}}
        // MSFieldType: {{$fieldOpt.CppDataType}} ProtoFieldTypeName: {{.GetTypeName}}
                {{if (eq $fieldOpt.SetKeyOidFn "")}}
                  {{if (eq .GetTypeName ".types.IPAddress")}}
        pdsa_set_address_oid(oid, "{{$mib}}", "{{$fieldOpt.Field}}", req.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
        oid[{{$fieldOpt.SetKeyOidIndex}}] = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                  {{end}}
                {{else}}
        {{$fieldOpt.SetKeyOidFn}}(req, oid);
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        NBB_TRC_EXIT();
    } /* pdsa_set_{{$struct | ToLower}}_oid */

    NBB_VOID pdsa_fill_{{$struct | ToLower}}_fields(pds::{{$msgName}} &req,
                                             AMB_GEN_IPS *mib_msg,
                                             {{$struct}} *v_{{$struct | ToLower}},
                                             NBB_LONG row_status) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        NBB_TRC_ENTRY("pdsa_fill_{{$struct | ToLower}}_fields");

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(mib_msg);

        {{$fields := .Fields}}
        {{range $fields}}
          {{if hasExtension "venice.pdsaFields" .}}
          {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
            {{if (eq $fieldOpt.IsKey false) }}
        if (row_status != AMB_ROW_DESTROY) {
            NBB_TRC_FLOW ((NBB_FORMAT "Not destroying RM: fill in field {{$fieldOpt.Field}} in {{$struct}}"));
            {{end}}
            {{if not (eq $fieldOpt.Field "")}}
            // {{.Type}} {{$fieldOpt.Name}} {{$fieldOpt.CppDataType}}
              {{if (eq $fieldOpt.SetFieldFn "")}}
                {{$castFn := getPdsaCastSetFunc .Type $fieldOpt.CppDataType}}
                {{if (eq $castFn "")}}
                  {{if (eq .GetTypeName ".types.IPAddress")}}
            pdsa_set_address_field(mib_msg, "{{$mib}}", "{{$fieldOpt.Field}}", (void*)v_{{$struct | ToLower}}, req.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
            v_{{$struct | ToLower}}->{{$fieldOpt.Field}} = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                  {{end}}
                {{else}}
            {{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$fieldOpt.Name | ToLower}}());
                {{end}}
            AMB_SET_FIELD_PRESENT(mib_msg, {{$fieldOpt.SetFieldIdx}});
              {{else}}
            {{$fieldOpt.SetFieldFn}}(req, mib_msg);
              {{end}}
            {{else}}
              {{if TypeIsMessage .}}
                {{if (eq $fieldOpt.Field "")}}
                  {{$myvar := (joinFields $pkgName "." ".")}}
                  {{$parentFieldName := .GetName}}
                  {{$parentFieldTypeName := (TrimPrefix .GetTypeName $myvar)}}
                  {{$parentFieldName := $fieldOpt.Name}}
                  {{range $msgs}}
                    {{$myMsgName := .GetName}}
                    {{if (eq $myMsgName $parentFieldTypeName)}}
                      {{$fields := .Fields}}
                      {{range $fields}}
                        {{if hasExtension "venice.pdsaFields" .}}
                          {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
        // {{$fieldOpt.Name}}
                          {{if (eq $fieldOpt.SetFieldFn "")}}
        v_{{$struct | ToLower}}->{{$fieldOpt.Field}} = ({{$fieldOpt.CppDataType}})req.{{$parentFieldName}}().{{$fieldOpt.Name | ToLower}}();
                          {{else}}
        {{$fieldOpt.SetFieldFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}, req.{{$parentFieldName}}().{{$fieldOpt.Name | ToLower}}());
                          {{end}}
        AMB_SET_FIELD_PRESENT(mib_msg, {{$fieldOpt.SetFieldIdx}});
                        {{end}}
                      {{end}}
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}
            {{end}}
            {{if (eq $fieldOpt.IsKey false) }}
        }
            {{end}}
          {{end}}
        {{end}}
        NBB_TRC_EXIT();
    } /* pdsa_fill_{{$struct | ToLower}}_fields */

    NBB_VOID pdsa_set_{{$struct | ToLower}}(pds::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator) {
        ATG_CPI_ROW_UPDATE  *row_update = NULL;
        AMB_GEN_IPS         *mib_msg = NULL;

        NBB_TRC_ENTRY("pdsa_set_{{$struct | ToLower}}");

        // Build row update
        row_update = pdsa_ctm_bld_row_update_common (&mib_msg,
                                                     sizeof({{$struct}}),
                                                     {{$oidLen}},
                                                     row_status,
                                                     test_correlator);

        NBB_ASSERT_PTR_NE (row_update, NULL);
        NBB_ASSERT_PTR_NE (mib_msg, NULL);

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        NBB_ULONG *oid = (NBB_ULONG *)((NBB_BYTE *)mib_msg + mib_msg->oid_offset);
        pdsa_set_{{$struct | ToLower}}_oid(req, oid);

        /***************************************************************************/
        /* Build {{$struct}}.                                                     */
        /***************************************************************************/
        {{$struct}} *data = ({{$struct}}*)((NBB_BYTE *)mib_msg + mib_msg->data_offset);
        pdsa_fill_{{$struct | ToLower}}_fields(req, mib_msg, data, row_status);
        {{if not (eq $fillFn "")}}
        {{$fillFn}}(req, mib_msg, data, row_status);
        {{end}}

        // Send the Row Update request to CSS
        NBB_SEND_IPS (SHARED.css_pid, USER_TO_CPI_Q, row_update);

        NBB_TRC_EXIT();
        return;
    } /* pdsa_set_{{$struct | ToLower}} */

    pre_set_{{$struct | ToLower}}_func_type pre_set_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pdsa_reg_pre_set_{{$struct | ToLower}}(pre_set_{{$struct | ToLower}}_func_type func) {
        pre_set_{{$struct | ToLower}}_func = func;
    } /* pdsa_reg_pre_set_{{$struct | ToLower}} */

    NBB_VOID pdsa_pre_set_{{$struct | ToLower}}(pds::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator) {
        if (pre_set_{{$struct | ToLower}}_func != NULL) {
            pre_set_{{$struct | ToLower}}_func(req, row_status, test_correlator);
        }
        return;
    } /* pdsa_pre_set_{{$struct | ToLower}} */

    post_set_{{$struct | ToLower}}_func_type post_set_{{$struct | ToLower}}_func = NULL;

    NBB_VOID pdsa_reg_post_set_{{$struct | ToLower}}(post_set_{{$struct | ToLower}}_func_type func) {
        post_set_{{$struct | ToLower}}_func = func;
    } /* pdsa_reg_post_set_{{$struct | ToLower}} */

    NBB_VOID pdsa_post_set_{{$struct | ToLower}}(pds::{{$msgName}} &req,
                                            NBB_LONG row_status,
                                            NBB_ULONG test_correlator) {
        if (post_set_{{$struct | ToLower}}_func != NULL) {
            post_set_{{$struct | ToLower}}_func(req, row_status, test_correlator);
        }
        return;
    } /* pdsa_post_set_{{$struct | ToLower}} */
    {{end}}
  {{end}}
{{end}}

{{$msgs := .Messages}}
{{range $msgs}}
  {{$msgName := .GetName}}
  {{$msg := .}}
  {{if hasExtension "venice.pdsaGetGlobOpts" . }}
    {{$param := (getPdsaGetGlobalOpts . $cam)}}
    {{$oidLen := $param.OidLen}}
    {{$oidFam := $param.OidFam}}
    {{$struct := $param.Struct}}
    {{$mib    := $param.Mib}}
    {{if not (eq $oidLen "")}}
    /*===== Get MS Table: {{$struct}} =====*/
    NBB_VOID pdsa_check_get_{{$struct | ToLower}}(NBB_CXT_T NBB_CXT)
    {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get;
        pds::{{$msgName}}Response resp;
        NBB_LONG bulk_row;
        {{$struct}} *v_{{$struct | ToLower}};

        NBB_TRC_ENTRY("pdsa_check_get_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Check assumptions.                                                      */
        /***************************************************************************/
        NBB_ASSERT_PTR_NE(SHARED.saved_ips, NULL);
        NBB_ASSERT_NUM_EQ(SHARED.saved_ips->ips_type, IPS_AMB_GET);

        v_amb_get = (AMB_GET *)SHARED.saved_ips;
        SHARED.saved_ips = NULL;

        if (v_amb_get->ret_code == AMB_RC_NO_ERROR)
        {
            auto ent = resp.add_response();
            /*************************************************************************/
            /* This GET response contains entry from {{$struct}}                     */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "Got a valid {{$struct}} entry"));

            v_{{$struct | ToLower}} = ({{$struct}} *)NTL_OFF_GET_POINTER(v_amb_get,
                                                        &v_amb_get->bulk_data_offset);

            for (bulk_row = 0; bulk_row < v_amb_get->bulk_returned; bulk_row++)
            {
                /*************************************************************************/
                /* TODO: Extract the fields.                                             */
                /*************************************************************************/
            {{$fields := .Fields}}
            {{range $fields}}
              {{if hasExtension "venice.pdsaFields" .}}
                {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
                {{if not (eq $isFldInTbl true)}}
                // !!! {{.Name}} field is not in table {{$mib}} !!!
                {{else}}
                  {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
                    {{if not (eq $fieldOpt.Name "")}}
                // {{.Type}} {{.GetTypeName}} {{$fieldOpt.Name}} {{$fieldOpt.CppDataType}} {{.GetLabel}}
                      {{if (eq $fieldOpt.GetFieldFn "")}}
                        {{$castFn := getPdsaCastGetFunc .Type $fieldOpt.CppDataType}}
                        {{if (eq $castFn "")}}
                          {{if (eq .GetTypeName ".types.IPAddress")}}
                auto {{$fieldOpt.Name | ToLower}}_addr = ent->mutable_{{$fieldOpt.Name | ToLower}}();
                //*{{$fieldOpt.Name | ToLower}}_addr = *pdsa_get_address("{{$mib}}", "{{$fieldOpt.Field}}", (void*)v_{{$struct | ToLower}})->v4addr();
		{{$fieldOpt.Name | ToLower}}_addr->set_af(pdsa_get_address("{{$mib}}", "{{$fieldOpt.Field}}", (void*)v_{{$struct | ToLower}})->af());
		{{$fieldOpt.Name | ToLower}}_addr->set_v4addr(pdsa_get_address("{{$mib}}", "{{$fieldOpt.Field}}", (void*)v_{{$struct | ToLower}})->v4addr());
                          {{else}}
                            {{$castFn = (getCppTypeFieldFromProto .Type .GetTypeName)}}
                            {{if (eq $castFn "")}}
                ent->set_{{$fieldOpt.Name | ToLower}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}});
                            {{else}}
                ent->set_{{$fieldOpt.Name | ToLower}}(({{$castFn}})v_{{$struct | ToLower}}->{{$fieldOpt.Field}});
                            {{end}}
                          {{end}}
                        {{else}}
                ent->set_{{$fieldOpt.Name | ToLower}}({{$castFn}}(v_{{$struct | ToLower}}->{{$fieldOpt.Field}}));
                        {{end}}
                      {{else}}
                {{$fieldOpt.GetFieldFn}}(ent->{{$fieldOpt.Name | ToLower}}(), v_{{$struct | ToLower}}->{{$fieldOpt.Field}});
                      {{end}}
                    {{end}}
                  {{end}}
                {{end}}
              {{end}}

                /***********************************************************************/
                /* Go to the next MIB row returned.                                    */
                /***********************************************************************/
                v_{{$struct | ToLower}} = ({{$struct}} *)(((NBB_BYTE *)v_{{$struct | ToLower}}) +
                                        NBB_ALIGN_OFFSET(v_amb_get->data_len));
            }

            /*************************************************************************/
            /* Send back the GET response as a GET request.  Because the             */
            /* get_next_object flag is set, it will return the next {{$struct}} entry*/
            /*************************************************************************/
            NBB_SEND_IPS(SHARED.sm_pid, AMB_MIB_Q, v_amb_get);
            SMS_GET_INC();
            v_amb_get = NULL;
        }
        else if (v_amb_get->ret_code == AMB_RC_GET_RESCHEDULE)
        {
            /*************************************************************************/
            /* The product has bounded the amount of processing it does in a single  */
            /* schedule.  The information in the GET does not represent a valid      */
            /* entry, just the last entry the product got to before deciding to      */
            /* reschedule.  Hence do not print the entry out.                        */
            /*                                                                       */
            /* Instead, send the GET response back as a GET-NEXT request (i.e.       */
            /* exact = ATG_NO and get_next_object = ATG_YES) in order to restart the */
            /* GET processing from where the product left off.  Because the          */
            /* get_next_object flag is set, the product will return the next BGP     */
            /* route.                                                                */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "Reschedule GET"));
            v_amb_get->exact = ATG_NO;
            v_amb_get->get_next_object = ATG_YES;
            NBB_SEND_IPS(SHARED.sm_pid, AMB_MIB_Q, v_amb_get);
            SMS_GET_INC();
            v_amb_get = NULL;
        }
        else if (v_amb_get->ret_code == AMB_RC_RESOURCE_UNAVAILABLE)
        {
            /*************************************************************************/
            /* The product failed to process the GET due to a resource failure.      */
            /*                                                                       */
            /* A MIB stub could decide to take action here, for example try again or */
            /* report the error.  However we just free the buffer and continue with  */
            /* the next FSM action.                                                  */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "GET failure"));
            NBB_FREE_BUFFER(v_amb_get);
            v_amb_get = NULL;

            /*************************************************************************/
            /* We are no longer responsible for incoming GETs.                       */
            /*************************************************************************/
            SHARED.wait_check_get = NULL;
        }
        else
        {
            /*************************************************************************/
            /* No more routes.  Free the buffer and move on to the next action.      */
            /*************************************************************************/
            NBB_TRC_FLOW((NBB_FORMAT "End of table"));
            NBB_ASSERT_NUM_EQ(v_amb_get->ret_code, AMB_RC_END_OF_TABLE);

            /*************************************************************************/
            /* Free the buffer.                                                      */
            /*************************************************************************/
            NBB_FREE_BUFFER(v_amb_get);
            v_amb_get = NULL;

            /*************************************************************************/
            /* The wait_check_get callback determines which procedure is responsible */
            /* for incoming GET response signals.  The last GET response has been    */
            /* received, and we are no longer responsible for incoming GETs.  Clear  */
            /* the callback.                                                         */
            /*************************************************************************/
            SHARED.wait_check_get = NULL;
        }

        NBB_TRC_EXIT();

        return;

    } /* pdsa_check_get_{{$struct | ToLower}} */

    NBB_VOID pdsa_get_{{$struct | ToLower}}_oid(pds::{{$msgName}} &req,
                                       NBB_ULONG *oid  NBB_CCXT_T NBB_CXT) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pdsa_get_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};

        {{$fields := .Fields}}
        {{range $fields}}
          {{if hasExtension "venice.pdsaFields" .}}
            {{$isFldInTbl := (isPdsaFieldInTable . $cam $struct)}}
            {{if not (eq $isFldInTbl true)}}
        // !!! {{.Name}} field is not in table {{$mib}} !!!
            {{else}}
              {{$fieldOpt := (getPdsaFieldOpt . $cam $struct)}}
              {{if (eq $fieldOpt.IsKey true) }}
        // ProtoFieldType: {{.Type}} ProtoFieldName: {{$fieldOpt.Name}}
        // MSFieldType: {{$fieldOpt.CppDataType}} ProtoFieldTypeName: {{.GetTypeName}}
                {{if (eq $fieldOpt.GetKeyOidFn "")}}
                  {{if (eq .GetTypeName ".types.IPAddress")}}
        pdsa_set_address_oid(oid, "{{$mib}}", "{{$fieldOpt.Field}}", req.{{$fieldOpt.Name | ToLower}}());
                  {{else}}
        oid[{{$fieldOpt.GetKeyOidIndex}}] = ({{$fieldOpt.CppDataType}})req.{{$fieldOpt.Name | ToLower}}();
                  {{end}}
                {{else}}
        {{$fieldOpt.GetKeyOidFn}}(oid, "{{$mib}}", "{{$fieldOpt.Field}}", req.{{$fieldOpt.Name | ToLower}}());
                {{end}}
              {{end}}
            {{end}}
          {{end}}
        {{end}}
        NBB_TRC_EXIT();
    } /* pdsa_get_{{$struct | ToLower}}_oid */

    NBB_VOID pdsa_get_{{$struct | ToLower}}(pds::{{$msgName}} &req) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get = NULL;
        NBB_ULONG oid[{{$oidLen}}];
        NBB_BUF_SIZE data_len = sizeof({{$struct}});

        NBB_TRC_ENTRY("pdsa_get_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Define the routine to be used on receipt of a GET response.             */
        /***************************************************************************/
        SHARED.wait_check_get = pdsa_check_get_{{$struct | ToLower}};

        /***************************************************************************/
        /* Build and send the first GET.                                           */
        /***************************************************************************/

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        pdsa_get_{{$struct | ToLower}}_oid(req, oid);

        /***************************************************************************/
        /* Build the common part of the AMB_GET message.                           */
        /***************************************************************************/
        v_amb_get = pdsa_amb_get_bulk_common(1000, data_len, oid[0], oid);

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(v_amb_get);

        /***************************************************************************/
        /* We're trying to get an exact match.                */
        /***************************************************************************/
        v_amb_get->exact = ATG_YES;
        v_amb_get->get_next_object = ATG_NO;

        /***************************************************************************/
        /* Send AMB_GET.                                                           */
        /***************************************************************************/
        NBB_TRC_FLOW((NBB_FORMAT "Send a {{$struct}} GET MIB."));
        NBB_SEND_IPS (SHARED.sm_pid, AMB_MIB_Q, v_amb_get);

        NBB_TRC_EXIT();
        return;
    } /* pdsa_get_{{$struct | ToLower}} */

    NBB_VOID pdsa_getall_{{$struct | ToLower}}_oid(pds::{{$msgName}} &req,
                                       NBB_ULONG *oid  NBB_CCXT_T NBB_CXT) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/

        NBB_TRC_ENTRY("pdsa_getall_{{$struct | ToLower}}_oid");
        /***************************************************************************/
        /* Zero the OID, then fill in the length, family and entity index.         */
        /***************************************************************************/
        NBB_MEMSET(oid, 0, sizeof(NBB_ULONG) * {{$oidLen}});
        oid[0] = {{$oidLen}};
        oid[1] = {{$oidFam}};

        NBB_TRC_EXIT();
    } /* pdsa_getall_{{$struct | ToLower}}_oid */

    NBB_VOID pdsa_getall_{{$struct | ToLower}}(pds::{{$msgName}} &req) {
        /***************************************************************************/
        /* Local Variables                                                         */
        /***************************************************************************/
        AMB_GET *v_amb_get = NULL;
        NBB_ULONG oid[{{$oidLen}}];
        NBB_BUF_SIZE data_len = sizeof({{$struct}});

        NBB_TRC_ENTRY("pdsa_getall_{{$struct | ToLower}}");

        /***************************************************************************/
        /* Define the routine to be used on receipt of a GET response.             */
        /***************************************************************************/
        SHARED.wait_check_get = pdsa_check_get_{{$struct | ToLower}};

        /***************************************************************************/
        /* Build and send the first GET.                                           */
        /***************************************************************************/

        /***************************************************************************/
        /* Set up the OID to pass in on the AMB_TEST                               */
        /***************************************************************************/
        pdsa_getall_{{$struct | ToLower}}_oid(req, oid);

        /***************************************************************************/
        /* Build the common part of the AMB_GET message.                           */
        /***************************************************************************/
        v_amb_get = pdsa_amb_get_bulk_common(1000, data_len, oid[0], oid);

        /***************************************************************************/
        /* Set all fields absent.                                                  */
        /***************************************************************************/
        AMB_SET_ALL_FIELDS_NOT_PRESENT(v_amb_get);

        /***************************************************************************/
        /* We're trying to get the next object, not an exact match.                */
        /***************************************************************************/
        v_amb_get->exact = ATG_NO;
        v_amb_get->get_next_object = ATG_YES;

        /***************************************************************************/
        /* Send AMB_GET.                                                           */
        /***************************************************************************/
        NBB_TRC_FLOW((NBB_FORMAT "Send a {{$struct}} GET MIB."));
        NBB_SEND_IPS (SHARED.sm_pid, AMB_MIB_Q, v_amb_get);

        NBB_TRC_EXIT();
        return;
    } /* pdsa_getall_{{$struct | ToLower}} */
    {{end}}
  {{end}}
{{end}}
