//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
// protobuf specification for EVPN EVI/IP VRF and associated RT configurations
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "pdsa.proto";
import "meta/meta.proto";
import "types.proto";

// Evpn service definition
service EvpnSvc
{
  rpc EvpnEviSpecCreate (EvpnEviRequest) returns (EvpnResponse) {}
  rpc EvpnEviSpecUpdate (EvpnEviRequest) returns (EvpnResponse) {}
  rpc EvpnEviSpecDelete (EvpnEviRequest) returns (EvpnResponse) {}
  rpc EvpnEviSpecGet (EvpnEviRequest) returns (EvpnEviSpecResponse) {}
  rpc EvpnEviSpecGetAll (EvpnEviRequest) returns (EvpnEviSpecResponse) {}
  rpc EvpnEviRtSpecCreate (EvpnEviRtRequest) returns (EvpnResponse) {}
  rpc EvpnEviRtSpecUpdate (EvpnEviRtRequest) returns (EvpnResponse) {}
  rpc EvpnEviRtSpecDelete (EvpnEviRtRequest) returns (EvpnResponse) {}
  rpc EvpnEviRtSpecGet (EvpnEviRtRequest) returns (EvpnEviRtSpecResponse) {}
  rpc EvpnEviRtSpecGetAll (EvpnEviRtRequest) returns (EvpnEviRtSpecResponse) {}
  rpc EvpnIpVrfSpecCreate (EvpnIpVrfRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfSpecUpdate (EvpnIpVrfRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfSpecDelete (EvpnIpVrfRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfSpecGet (EvpnIpVrfRequest) returns (EvpnIpVrfSpecResponse) {}
  rpc EvpnIpvrfSpecGetAll (EvpnIpVrfRequest) returns (EvpnIpVrfSpecResponse) {}
  rpc EvpnIpVrfRtSpecCreate (EvpnIpVrfRtRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfRtSpecUpdate (EvpnIpVrfRtRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfRtSpecDelete (EvpnIpVrfRtRequest) returns (EvpnResponse) {}
  rpc EvpnIpVrfRtSpecGet (EvpnIpVrfRtRequest) returns (EvpnIpVrfRtSpecResponse) {}
  rpc EvpnIpvrfRtSpecGetAll (EvpnIpVrfRtRequest) returns (EvpnIpVrfRtSpecResponse) {}
  rpc EvpnMacIpSpecGet  (EvpnMacIpSpecRequest) returns (EvpnMacIpSpecResponse) {}
  rpc EvpnMacIpSpecGetAll  (EvpnMacIpSpecRequest) returns (EvpnMacIpSpecResponse) {}
}

// EVPN Configured or Auto Values
enum EvpnCfg {
  EVPN_CFG_INVALID = 0;
  EVPN_CFG_MANUAL  = 2;
  EVPN_CFG_AUTO    = 3;
}

enum EvpnEncaps {
  EVPN_ENCAP_INVALID = 0;
  EVPN_ENCAP_MPLS    = 1;
  EVPN_ENCAP_VXLAN   = 2;
}

enum EvpnRtType {
  EVPN_RT_INVALID         = 0;
  EVPN_RT_IMPORT          = 1;
  EVPN_RT_EXPORT          = 2;
  EVPN_RT_IMPORT_EXPORT   = 3;
  EVPN_RT_NONE            = 4;
}

// EVPN EVI configuration
message EvpnEviSpec {
  option (venice.pdsaSetGlobOpts) = {
    OidLen: "AMB_EVPN_EVI_OID_LEN",
    Mib:    "evpnEviTable"
    FillFn: "evpn_evi_fill_func"
  };
  option (venice.pdsaGetGlobOpts) = {
    OidLen: "AMB_EVPN_EVI_OID_LEN",
    Mib:    "evpnEviTable"
  };

  bytes       Id       = 1; // spec key 
  bytes       SubnetId = 2; // reference to subnet spec. FillFn to retrieve EVI Id from subnet spec
  EvpnCfg     AutoRD   = 3 [(venice.pdsaFields) = {Field:"rd_cfg_or_auto"}];
  bytes       RD       = 4 [(venice.pdsaFields) = {Field:"cfg_rd"}]; // Not mandatory when AutoRD is set to EVPN_CFG_AUTO 
  EvpnCfg     AutoRT   = 5 [(venice.pdsaFields) = {Field:"rt_cfg_or_auto"}];
  EvpnRtType  RTType   = 6 [(venice.pdsaFields) = {Field:"auto_rt_type"}];
  EvpnEncaps  Encap    = 7 [(venice.pdsaFields) = {Field:"encapsulation"}];

  // Internal only
  uint32      EVIId    = 8 [(venice.pdsaFields) = {Field:"index", SetKeyOidIndex: "AMB_EVPN_EVI_INDEX_INDEX", GetKeyOidIndex: "AMB_EVPN_EVI_INDEX_INDEX"}];
}

// EVPN IP VRF configuration
message EvpnIpVrfSpec {
  option (venice.pdsaSetGlobOpts) = {
    OidLen: "AMB_EVPN_IP_VRF_OID_LEN",
    Mib:    "evpnIpVrfTable"
    FillFn: "evpn_ip_vrf_fill_func"
  };
  option (venice.pdsaGetGlobOpts) = {
    OidLen: "AMB_EVPN_IP_VRF_OID_LEN",
    Mib:    "evpnIpVrfTable"
  };

  bytes  Id    = 1; // spec key 
  bytes  VPCId = 2; // reference to VPC spec. FillFn to convert to VRF Name
  uint32 VNI   = 3 [(venice.pdsaFields) = {Field:"vni"}];
  bytes  RD    = 4 [(venice.pdsaFields) = {Field:"route_distinguisher"}];

  // Internal only
  uint32 VRFId = 5 [(venice.pdsaFields) = {Field:"vrf_name", SetFieldFn: "evpn_ip_vrf_fill_name_field", SetKeyOidFn: "evpn_ip_vrf_fill_name_oid", GetFieldFn: "evpn_ip_vrf_get_name_field", GetKeyOidFn: "evpn_ip_vrf_fill_name_oid"}]; // cannot be auto-gen, ID to name conversion and viceversa should be populated from the Field/KeyOidFns
}

// EVPN EVI RT Configuration
message EvpnEviRtSpec {
  option (venice.pdsaSetGlobOpts) = {
    OidLen: "AMB_EVPN_EVI_RT_OID_LEN",
    Mib:    "evpnEviRtTable"
    FillFn: "evpn_evi_rt_fill_func"
  };
  option (venice.pdsaGetGlobOpts) = {
    OidLen: "AMB_EVPN_EVI_RT_OID_LEN",
    Mib:    "evpnEviRtTable"
  };

  bytes      Id       = 1; // spec key
  bytes      SubnetId = 2; // reference to subnet spec. FillFn to retrieve EVI Id from subnet spec
  bytes      RT       = 3 [(venice.pdsaFields) = {Field:"route_target", SetKeyOidIndex: "AMB_EVPN_EVI_RT_RTE_TARGET", GetKeyOidIndex: "AMB_EVPN_EVI_RT_RTE_TARGET"}];
  EvpnRtType RTType   = 4 [(venice.pdsaFields) = {Field:"type"}];

  // Internal only
  uint32    EVIId     = 5 [(venice.pdsaFields) = {Field:"index", SetKeyOidIndex: "AMB_EVPN_EVI_RT_EVI_INDEX", GetKeyOidIndex: "AMB_EVPN_EVI_RT_EVI_INDEX"}];
}

// EVPN IP VRF RT Configuration
message EvpnIpVrfRtSpec {
  option (venice.pdsaSetGlobOpts) = {
    OidLen: "AMB_EVPN_IP_VRF_RT_OID_LEN",
    Mib:    "evpnIpVrfRtTable"
    FillFn: "evpn_ip_vrf_rt_fill_func"
  };
  option (venice.pdsaGetGlobOpts) = {
    OidLen: "AMB_EVPN_IP_VRF_RT_OID_LEN",
    Mib:    "evpnIpVrfRtTable"
  };

  bytes      Id     = 1; // spec key [(venice.pdsaFields) = {Field:"vrf_name", SetFieldFn: "evpn_ip_vrf_rt_fill_name_field", SetKeyOidFn: "evpn_ip_vrf_rt_fill_name_oid", GetFieldFn: "evpn_ip_vrf_rt_get_name_field", GetKeyOidFn: "evpn_ip_vrf_rt_fill_name_oid"}]; // cannot be auto-gen, ID to name conversion and viceversa should be populated from the Field/KeyOidFns
  bytes      VPCId  = 2; // reference to VPS spec. FillFn to convert to VRF Name
  bytes      RT     = 3 [(venice.pdsaFields) = {Field:"route_target", SetKeyOidIndex: "AMB_EVPN_IP_VRF_RT_TARGET_INDEX", GetKeyOidIndex: "AMB_EVPN_IP_VRF_RT_TARGET_INDEX"}];
  EvpnRtType RTType = 4 [(venice.pdsaFields) = {Field:"type"}];

  // Internal only
  uint32     VRFId  = 5 [(venice.pdsaFields) = {Field:"vrf_name", SetFieldFn: "evpn_ip_vrf_rt_fill_name_field", SetKeyOidFn: "evpn_ip_vrf_rt_fill_name_oid", GetFieldFn: "evpn_ip_vrf_rt_get_name_field", GetKeyOidFn: "evpn_ip_vrf_rt_fill_name_oid"}]; // cannot be auto-gen, ID to name conversion and viceversa should be populated from the Field/KeyOidFns
}

// EvpnEvi create and update request
message EvpnEviRequest {
  option (venice.pdsaSetGlobOpts) = {
      Mib: "evpnEviTable"
  };
  option (venice.pdsaGetGlobOpts) = {
      Mib: "evpnEviTable"
  };
  // requests
  repeated EvpnEviSpec  Request = 1;
}

// EvpnIPVrf create and update request
message EvpnIpVrfRequest {
  option (venice.pdsaSetGlobOpts) = {
      Mib: "evpnIpVrfTable"
  };
  option (venice.pdsaGetGlobOpts) = {
      Mib: "evpnIpVrfTable"
  };
  // requests
  repeated EvpnIpVrfSpec Request = 1;
}

//EvpnEviRtSpec create and update request
message EvpnEviRtRequest {
  option (venice.pdsaSetGlobOpts) = {
      Mib: "evpnEviRtTable"
  };
  option (venice.pdsaGetGlobOpts) = {
      Mib: "evpnEviRtTable"
  };
  // requests
  repeated EvpnEviRtSpec  Request = 1;
}

message EvpnIpVrfRtRequest {
  option (venice.pdsaSetGlobOpts) = {
      Mib: "evpnIpVrfRtTable"
  };
  option (venice.pdsaGetGlobOpts) = {
      Mib: "evpnIpVrfRtTable"
  };
  // requests
  repeated EvpnIpVrfRtSpec Request = 1;
}

// operational status of EVPN, if any
message EvpnStatus {
}

// EVPN specs create and update response
message EvpnResponse {
  types.ApiStatus ApiStatus = 1;
  EvpnStatus Response       = 2;
}

// EvpnEviSpec get response
message EvpnEviSpecResponse {
  types.ApiStatus        ApiStatus = 1;
  repeated EvpnEviSpec   Response  = 2;
}

// EvpnIpVrfSpec get response
message EvpnIpVrfSpecResponse {
  types.ApiStatus           ApiStatus   = 1;
  repeated EvpnIpVrfSpec    Response    = 2;
}

// EvpnEviRtSpec get response
message EvpnEviRtSpecResponse {
  types.ApiStatus           ApiStatus   = 1;
  repeated EvpnEviRtSpec    Response    = 2;
}

// EvpnIpVrfRtSpec get response
message EvpnIpVrfRtSpecResponse {
  types.ApiStatus           ApiStatus   = 1;
  repeated EvpnIpVrfRtSpec  Response    = 2;
}
enum EvpnSource {
    EVPN_SOURCE_NONE    = 0;
    EVPN_SOURCE_LOCAL   = 1;
    EVPN_SOURCE_REMOTE  = 2;
}

// EVPN MAC IP Table Get
message EvpnMacIpSpec {
  option (venice.pdsaGetGlobOpts) = {
    OidLen: "AMB_EVPN_MAC_IP_OID_LEN",
    Mib:    "evpnMacIpTable"
    FillFn: "evpn_mac_ip_get_fill_func"
  };

  uint32            EVIId           = 1 [(venice.pdsaFields) = {Field:"evi_index", GetKeyOidIndex: "AMB_EVPN_MAC_IP_EVI_INDEX_INDEX"}];
  uint32            EthTagID        = 2 [(venice.pdsaFields) = {Field:"ethernet_tag_id", GetKeyOidIndex: "AMB_EVPN_MAC_IP_EVI_INDEX_INDEX"}];
  bytes             MACAddress      = 3 [(venice.pdsaFields) = {Field:"mac_address", GetKeyOidIndex: "AMB_EVPN_MAC_IP_MAC_ADDR_INDEX"}];
  types.IPAddress   IPAddress       = 4 [(venice.pdsaFields) = {Field:"ip_address"}];
  uint32            PathID          = 5 [(venice.pdsaFields) = {Field:"path_index", GetKeyOidIndex: "AMB_EVPN_MAC_IP_PATH_IX_INDEX"}];
  EvpnSource        Source          = 6 [(venice.pdsaFields) = {Field:"source"}];
  types.IPAddress   NHAddress       = 7 [(venice.pdsaFields) = {Field:"bgp_nh_addr"}];
  uint32            LocalIfId       = 8 [(venice.pdsaFields) = {Field:"local_interface"}];
}

message EvpnMacIpSpecRequest {
  option (venice.pdsaGetGlobOpts) = {
      Mib: "evpnMacIpTable"
  };
  // requests
  repeated EvpnMacIpSpec Request = 1;
}

// EVPN MAC IP get response
message EvpnMacIpSpecResponse {
  types.ApiStatus           ApiStatus = 1;
  repeated EvpnMacIpSpec    Response  = 2;
}
