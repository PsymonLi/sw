diff -uprN VirtualBox-5.1.14-old/Config.kmk VirtualBox-5.1.14-dev/Config.kmk
--- VirtualBox-5.1.14-old/Config.kmk	2017-01-16 23:21:58.000000000 -0800
+++ VirtualBox-5.1.14-dev/Config.kmk	2017-02-16 16:19:46.000000000 -0800
@@ -2584,7 +2584,7 @@ $(PATH_OUT)/DynamicConfig.kmk: \
 	$(QUIET)$(APPEND) '$@' ' endif'
 	$(QUIET)$(APPEND) '$@' 'endif'
 	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-address           ?= $(call VBOX_GCC_CHECK_CXX,-Wno-address,)'
-	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-delete-non-virtual-dtor    ?= $(call VBOX_GCC_CHECK_CXX,-Wno-delete-non-virtual-dtor,)'
+#	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-delete-non-virtual-dtor    ?= $(call VBOX_GCC_CHECK_CXX,-Wno-delete-non-virtual-dtor,)'
 	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-int-to-pointer-cast        ?= $(call VBOX_GCC_CHECK_CC,-Wno-int-to-pointer-cast,)'
 	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-invalid-offsetof           ?= $(call VBOX_GCC_CHECK_CXX,-Wno-invalid-offsetof,)'
 	$(QUIET)$(APPEND) '$@' 'VBOX_GCC_Wno-literal-suffix             ?= $(call VBOX_GCC_CHECK_CXX,-Wno-literal-suffix,)'
diff -uprN VirtualBox-5.1.14-old/LocalConfig.kmk VirtualBox-5.1.14-dev/LocalConfig.kmk
--- VirtualBox-5.1.14-old/LocalConfig.kmk	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/LocalConfig.kmk	2017-02-23 12:17:17.000000000 -0800
@@ -0,0 +1,10 @@
+VBOX_WITH_TESTCASES :=
+VBOX_WITH_TESTSUITE :=
+VBOX_XCODE_VERSION := 4.1
+VBOX_DEF_MACOSX_VERSION_MIN := 10.7
+PATH_TOOL_VBoxXcode62 := /Users/brads/src/vbox/Xcode_4.1/xcode41-partial/Developer
+PATH_TOOL_VBoxXcode62_TOOLCHAIN_BIN_SLASH := 
+override TOOL_StandardDTrace_DTRACE := dtrace "-xcpppath=$(TOOL_GCC4MACHO_PREFIX)cpp-4.2"
+VBOX_WITH_EXTPACK_VBOXDTRACE :=
+VBOX_WITH_EXTPACK_BUSMOUSESAMPLE = 1
+VBOX_WITH_EXTPACK_SIMBRIDGE = 1
diff -uprN VirtualBox-5.1.14-old/configure VirtualBox-5.1.14-dev/configure
--- VirtualBox-5.1.14-old/configure	2017-01-16 23:21:58.000000000 -0800
+++ VirtualBox-5.1.14-dev/configure	2017-02-06 18:41:10.000000000 -0800
@@ -2323,6 +2323,14 @@ check_darwinversion()
   test_header "Darwin version"
   darwin_ver=`uname -r`
   case "$darwin_ver" in
+    16\.*)
+      check_xcode_sdk_path "$WITH_XCODE_DIR"
+      [ $? -eq 1 ] || fail
+      darwin_ver="10.12" # Sierra
+      sdk=$WITH_XCODE_DIR/Developer/SDKs/MacOSX10.6.sdk
+      cnf_append "VBOX_WITH_MACOSX_COMPILERS_FROM_DEVEL" "1"
+      cnf_append "VBOX_PATH_MACOSX_DEVEL_ROOT" "$WITH_XCODE_DIR/Developer"
+      ;;
     15\.*)
       check_xcode_sdk_path "$WITH_XCODE_DIR"
       [ $? -eq 1 ] || fail
diff -uprN VirtualBox-5.1.14-old/env.csh VirtualBox-5.1.14-dev/env.csh
--- VirtualBox-5.1.14-old/env.csh	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/env.csh	2017-03-20 11:44:13.000000000 -0700
@@ -0,0 +1,23 @@
+#!/bin/bash
+#
+# automatically generated by
+#
+#   './configure --disable-hardening --target-arch=amd64 --disable-docs --disable-kmods --disable-qt --build-headless --with-xcode-dir=/Users/brads/src/vbox/Xcode_4.1/xcode41-partial --with-openssl-dir=/usr/local/opt/openssl --with-gcc=gcc-4.2 --with-g++=g++-4.2'
+#
+# It will be completely overwritten if configure is executed again.
+# Make sure you source this file once before you start to build VBox.
+#
+
+setenv BUILD_PLATFORM "darwin"
+setenv BUILD_PLATFORM_ARCH "amd64"
+setenv BUILD_TARGET "darwin"
+setenv BUILD_TARGET_ARCH "amd64"
+setenv BUILD_TARGET_CPU "k8"
+setenv BUILD_TYPE "release"
+setenv PATH_KBUILD "/Users/brads/src/vbox/VirtualBox-5.1.14-new/kBuild"
+setenv PATH_DEVTOOLS "/Users/brads/src/vbox/VirtualBox-5.1.14-new/tools"
+set path_kbuild_bin="$PATH_KBUILD/bin/$BUILD_TARGET.$BUILD_PLATFORM_ARCH"
+set path_dev_bin="$PATH_DEVTOOLS/$BUILD_TARGET.$BUILD_PLATFORM_ARCH"/bin
+echo "$PATH" | grep -q "$path_kbuild_bin" || setenv PATH "${path_kbuild_bin}:$PATH"
+echo "$PATH" | grep -q "$path_dev_bin" || setenv PATH "${path_dev_bin}:$PATH"
+unset path_kbuild_bin path_dev_bin
diff -uprN VirtualBox-5.1.14-old/env.sh VirtualBox-5.1.14-dev/env.sh
--- VirtualBox-5.1.14-old/env.sh	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/env.sh	2017-02-28 23:19:59.000000000 -0800
@@ -0,0 +1,33 @@
+#!/bin/bash
+#
+# automatically generated by
+#
+#   './configure --disable-hardening --target-arch=amd64 --disable-docs --disable-kmods --disable-qt --build-headless --with-xcode-dir=/Users/brads/src/vbox/Xcode_4.1/xcode41-partial --with-openssl-dir=/usr/local/opt/openssl --with-gcc=gcc-4.2 --with-g++=g++-4.2'
+#
+# It will be completely overwritten if configure is executed again.
+# Make sure you source this file once before you start to build VBox.
+#
+
+BUILD_PLATFORM="darwin"
+export BUILD_PLATFORM
+BUILD_PLATFORM_ARCH="amd64"
+export BUILD_PLATFORM_ARCH
+BUILD_TARGET="darwin"
+export BUILD_TARGET
+BUILD_TARGET_ARCH="amd64"
+export BUILD_TARGET_ARCH
+BUILD_TARGET_CPU="k8"
+export BUILD_TARGET_CPU
+BUILD_TYPE="release"
+export BUILD_TYPE
+PATH_KBUILD="/Users/brads/src/vbox/VirtualBox-5.1.14-new/kBuild"
+export PATH_KBUILD
+PATH_DEVTOOLS="/Users/brads/src/vbox/VirtualBox-5.1.14-new/tools"
+export PATH_DEVTOOLS
+path_kbuild_bin="$PATH_KBUILD/bin/$BUILD_TARGET.$BUILD_PLATFORM_ARCH"
+export PATH_KBUILD_BIN
+path_dev_bin="$PATH_DEVTOOLS/$BUILD_TARGET.$BUILD_PLATFORM_ARCH"/bin
+echo "$PATH" | grep -q "$path_kbuild_bin" || PATH="$path_kbuild_bin:$PATH"
+echo "$PATH" | grep -q "$path_dev_bin" || PATH="$path_dev_bin:$PATH"
+export PATH
+unset path_kbuild_bin path_dev_bin
diff -uprN VirtualBox-5.1.14-old/include/iprt/assert.h VirtualBox-5.1.14-dev/include/iprt/assert.h
--- VirtualBox-5.1.14-old/include/iprt/assert.h	2017-01-16 23:22:03.000000000 -0800
+++ VirtualBox-5.1.14-dev/include/iprt/assert.h	2017-02-09 17:00:56.000000000 -0800
@@ -314,7 +314,7 @@ RT_C_DECLS_END
  * @param   expr    Expression which should be true.
  */
 #ifdef RTASSERT_HAVE_STATIC_ASSERT
-# define AssertCompile(expr)    static_assert(!!(expr), #expr)
+# define AssertCompile(expr)    _Static_assert(!!(expr), #expr)
 #else
 # define AssertCompile(expr)    AssertCompileNS(expr)
 #endif
diff -uprN VirtualBox-5.1.14-old/include/make.out VirtualBox-5.1.14-dev/include/make.out
--- VirtualBox-5.1.14-old/include/make.out	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/include/make.out	2017-03-20 11:59:24.000000000 -0700
@@ -0,0 +1,2 @@
+build debug: VBOX_WITH_NO_GCC_WARNING_POLICY is enabled
+kmk: Nothing to be done for `packing'.
diff -uprN VirtualBox-5.1.14-old/src/VBox/Devices/Makefile.kmk VirtualBox-5.1.14-dev/src/VBox/Devices/Makefile.kmk
--- VirtualBox-5.1.14-old/src/VBox/Devices/Makefile.kmk	2017-01-16 23:25:46.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/Devices/Makefile.kmk	2017-02-22 18:59:39.000000000 -0800
@@ -31,7 +31,7 @@ ifdef VBOX_WITH_TESTCASES
  include $(PATH_SUB_CURRENT)/Samples/Makefile.kmk
 endif
 if defined(VBOX_WITH_INTEL_PXE) || defined(VBOX_ONLY_EXTPACKS)
- include $(PATH_SUB_CURRENT)/PC/PXE/Makefile.kmk
+ # include $(PATH_SUB_CURRENT)/PC/PXE/Makefile.kmk
 else if defined(VBOX_WITH_PXE_ROM)
  if !defined(VBOX_WITHOUT_IPXE)
   include $(PATH_SUB_CURRENT)/PC/ipxe/Makefile.kmk
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/BusMouseSample/BusMouse.cpp VirtualBox-5.1.14-dev/src/VBox/ExtPacks/BusMouseSample/BusMouse.cpp
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/BusMouseSample/BusMouse.cpp	2017-01-16 23:26:06.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/BusMouseSample/BusMouse.cpp	2017-02-28 20:52:47.000000000 -0800
@@ -182,8 +182,8 @@ typedef struct MouState
 
 #ifndef VBOX_DEVICE_STRUCT_TESTCASE
 
-# ifdef IN_RING3
 
+# ifdef IN_RING3
 /**
  * Report a change in status down the driver chain.
  *
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/Makefile.kmk VirtualBox-5.1.14-dev/src/VBox/ExtPacks/Makefile.kmk
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/Makefile.kmk	2017-01-16 23:26:06.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/Makefile.kmk	2017-02-23 12:16:58.000000000 -0800
@@ -30,6 +30,9 @@ endif
 ifdef VBOX_WITH_EXTPACK_BUSMOUSESAMPLE
  include $(PATH_SUB_CURRENT)/BusMouseSample/Makefile.kmk
 endif
+ifdef VBOX_WITH_EXTPACK_SIMBRIDGE
+ include $(PATH_SUB_CURRENT)/SimBridge/Makefile.kmk
+endif
 
 include $(FILE_KBUILD_SUB_FOOTER)
 
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/ExtPack.xml VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/ExtPack.xml
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/ExtPack.xml	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/ExtPack.xml	2017-02-23 12:25:46.000000000 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<VirtualBoxExtensionPack xmlns="http://www.virtualbox.org/VirtualBoxExtensionPack" version="1.0">
+    <Name>SimBridge</Name>
+    <Description>The simulation bridge extension pack.</Description>
+    <Version revision="@VBOX_SVN_REV@">@VBOX_VERSION_STRING@</Version>
+    <MainModule>VBoxSimBridgeMain</MainModule>
+    <ShowLicense/>
+</VirtualBoxExtensionPack>
+
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/Makefile.kmk VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/Makefile.kmk
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/Makefile.kmk	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/Makefile.kmk	2017-02-23 12:24:17.000000000 -0800
@@ -0,0 +1,187 @@
+# $Id: Makefile.kmk $
+## @file
+# Sub-Makefile for the Sim Bridge Extension Pack.
+#
+
+#
+# Copyright (C) 2010-2016 Oracle Corporation
+#
+# Permission is hereby granted, free of charge, to any person
+# obtaining a copy of this software and associated documentation
+# files (the "Software"), to deal in the Software without
+# restriction, including without limitation the rights to use,
+# copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following
+# conditions:
+#
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+
+SUB_DEPTH = ../../../..
+include $(KBUILD_PATH)/subheader.kmk
+
+#
+# Extend the extension pack templates.
+#
+TEMPLATE_VBoxR3ExtPackSimBridge          = For the ring-3 context modules in the Sim Bridge extension pack.
+TEMPLATE_VBoxR3ExtPackSimBridge_EXTENDS  = VBoxR3ExtPack
+TEMPLATE_VBoxR3ExtPackSimBridge_INST     = $(INST_EXTPACK)SimBridge/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
+
+TEMPLATE_VBoxR0ExtPackSimBridge          = For the ring-0 context modules in the Sim Bridge extension pack.
+TEMPLATE_VBoxR0ExtPackSimBridge_EXTENDS  = VBoxR0ExtPack
+TEMPLATE_VBoxR0ExtPackSimBridge_INST     = $(INST_EXTPACK)SimBridge/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
+
+TEMPLATE_VBoxRcExtPackSimBridge          = For the raw-mode context modules in the Sim Bridge extension pack.
+TEMPLATE_VBoxRcExtPackSimBridge_EXTENDS  = VBoxRcExtPack
+TEMPLATE_VBoxRcExtPackSimBridge_INST     = $(INST_EXTPACK)SimBridge/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
+
+TEMPLATE_VBoxInsExtPackSimBridge         = For the install targets of an extension pack.
+TEMPLATE_VBoxInsExtPackSimBridge_EXTENDS = VBoxR0ExtPack
+TEMPLATE_VBoxInsExtPackSimBridge_INST    = $(INST_EXTPACK)SimBridge/
+
+#
+# Globals.
+#
+VBOX_SIMBRIDGE_NAME         = SimBridge
+VBOX_SIMBRIDGE_MANGLED_NAME = SimBridge
+VBOX_PATH_EXTPACK_SIMBRIDGE = $(PATH_STAGE)/$(INST_EXTPACK)SimBridge
+
+
+#
+# VBoxSimBridgeMain - The module which the VirtualBox Main API talks to.
+#
+DLLS += VBoxSimBridgeMain
+VBoxSimBridgeMain_TEMPLATE = VBoxR3ExtPackSimBridge
+VBoxSimBridgeMain_SOURCES = VBoxSimBridgeMain.cpp
+VBoxSimBridgeMain_DEFS =
+
+
+#
+# The device code.
+#
+DLLS += VBoxSimBridgeR3
+VBoxSimBridgeR3_TEMPLATE = VBoxR3ExtPackSimBridge
+VBoxSimBridgeR3_SOURCES  = SimBridge.cpp
+
+SYSMODS += VBoxSimBridgeR0
+VBoxSimBridgeR0_TEMPLATE = VBoxR0ExtPackSimBridge
+VBoxSimBridgeR0_SOURCES  = SimBridge.cpp
+
+ifdef VBOX_WITH_RAW_MODE
+ SYSMODS += VBoxSimBridgeRC
+ VBoxSimBridgeRC_TEMPLATE = VBoxRcExtPackSimBridge
+ VBoxSimBridgeRC_SOURCES  = SimBridge.cpp
+endif
+
+
+#
+# Install the description.
+#
+INSTALLS += VBoxSimBridgeIns
+VBoxSimBridgeIns_TEMPLATE = VBoxInsExtPackSimBridge
+VBoxSimBridgeIns_SOURCES = \
+	$(VBoxSimBridgeIns_0_OUTDIR)/ExtPack.xml
+$(call VBOX_EDIT_VERSION_RULE_FN,VBoxSimBridgeIns,ExtPack.xml)
+
+
+#
+# Packing.
+#
+ifndef VBOX_WITHOUT_EXTPACK_SIMBRIDGE_PACKING
+ PACKING += $(VBOX_PATH_PACKAGES)/$(VBOX_SIMBRIDGE_MANGLED_NAME)-$(VBOX_VERSION_STRING)r$(VBOX_SVN_REV).vbox-extpack
+endif
+
+ifndef VBOX_WITH_EXTPACK_OS_ARCHS
+ ifeq ($(USER),bird) # for now
+  VBOX_WITH_EXTPACK_OS_ARCHS = $(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)
+ endif
+endif
+
+# Build the file list.  The macro takes 1=darwin.x86, 2=dist/VirtualBox.app/Contents/MacOS, 3=dylib
+VBOX_SIMBRIDGE_FILES_MACRO = \
+	$(PATH_OUT_BASE)/$(1)/$(KBUILD_TYPE)/$(2)/ExtensionPacks/$(VBOX_SIMBRIDGE_MANGLED_NAME)/$(1)/VBoxSimBridgeMain.$(3)=>$(1)/VBoxSimBridgeMain.$(3) \
+	$(PATH_OUT_BASE)/$(1)/$(KBUILD_TYPE)/$(2)/ExtensionPacks/$(VBOX_SIMBRIDGE_MANGLED_NAME)/$(1)/VBoxSimBridgeR3.$(3)=>$(1)/VBoxSimBridgeR3.$(3) \
+	$(PATH_OUT_BASE)/$(1)/$(KBUILD_TYPE)/$(2)/ExtensionPacks/$(VBOX_SIMBRIDGE_MANGLED_NAME)/$(1)/VBoxSimBridgeR0.r0=>$(1)/VBoxSimBridgeR0.r0
+ifdef VBOX_WITH_RAW_MODE
+ VBOX_SIMBRIDGE_FILES_MACRO += \
+ 	$(PATH_OUT_BASE)/$(1)/$(KBUILD_TYPE)/$(2)/ExtensionPacks/$(VBOX_SIMBRIDGE_MANGLED_NAME)/$(1)/VBoxSimBridgeRC.rc=>$(1)/VBoxSimBridgeRC.rc
+endif
+
+VBOX_SIMBRIDGE_FILES := \
+	$(VBOX_PATH_EXTPACK_SIMBRIDGE)/ExtPack.xml=>ExtPack.xml
+
+if1of (darwin.amd64, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,darwin.amd64,dist/VirtualBox.app/Contents/MacOS,dylib)
+endif
+if1of (darwin.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,darwin.x86,dist/VirtualBox.app/Contents/MacOS,dylib)
+endif
+if1of (freebsd.amd64, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,freebsd.amd64,bin,so)
+endif
+if1of (freebsd.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,freebsd.x86,bin,so)
+endif
+if1of (linux.amd64, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,linux.amd64,bin,so)
+endif
+if1of (linux.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,linux.x86,bin,so)
+endif
+if1of (os2.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,os2.x86,bin,so)
+endif
+if1of (solaris.amd64, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,solaris.amd64,bin,so)
+endif
+if1of (solaris.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,solaris.x86,bin,so)
+endif
+if1of (win.amd64, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,win.amd64,bin,dll)
+endif
+if1of (win.x86, $(VBOX_WITH_EXTPACK_OS_ARCHS))
+ VBOX_SIMBRIDGE_FILES += $(call VBOX_SIMBRIDGE_FILES_MACRO,win.x86,bin,dll)
+endif
+
+# Pack it all up using a temporary staging directory.
+$(VBOX_PATH_PACKAGES)/$(VBOX_SIMBRIDGE_MANGLED_NAME)-$(VBOX_VERSION_STRING)r$(VBOX_SVN_REV).vbox-extpack: \
+		$$(foreach file, $$(VBOX_SIMBRIDGE_FILES), $$(firstword $$(subst =>,$$(SP),$$(file)))) \
+		| $(VBOX_PATH_PACKAGES)/
+	$(RM) -f $(wildcard $(VBOX_PATH_PACKAGES)/$(VBOX_SIMBRIDGE_MANGLED_NAME)-*.vbox-extpack) \
+		$(VBoxSimBridgeIns_0_OUTDIR)/ExtPack.manifest \
+		$(VBoxSimBridgeIns_0_OUTDIR)/ExtPack.signature
+# Stage all the files
+	$(RM) -Rf $(VBoxSimBridgeIns_0_OUTDIR)/Stage/
+	$(foreach file, $(VBOX_SIMBRIDGE_FILES),\
+		$(NLTAB)$(MKDIR) -p $(dir $(lastword $(subst =>,$(SP)$(VBoxSimBridgeIns_0_OUTDIR)/Stage/,$(file)))) \
+		$(NLTAB)$(CP) $(subst =>,$(SP)$(VBoxSimBridgeIns_0_OUTDIR)/Stage/,$(file)) )
+# Create the manifest
+	$(VBOX_RTMANIFEST) \
+		--manifest $(VBoxSimBridgeIns_0_OUTDIR)/Stage/ExtPack.manifest \
+		--chdir $(VBoxSimBridgeIns_0_OUTDIR)/Stage/ \
+		$(foreach file, $(VBOX_SIMBRIDGE_FILES), $(lastword $(subst =>,$(SP),$(file))))
+	$(APPEND) $(VBoxSimBridgeIns_0_OUTDIR)/Stage/ExtPack.signature "todo"
+	$(CHMOD) a+r \
+		$(VBoxSimBridgeIns_0_OUTDIR)/Stage/ExtPack.manifest \
+		$(VBoxSimBridgeIns_0_OUTDIR)/Stage/ExtPack.signature
+# Tar it up.
+	tar -cvf - -C $(VBoxSimBridgeIns_0_OUTDIR)/Stage/ . | gzip -9c > $@
+# Clean up
+	$(RM) -Rf $(VBoxSimBridgeIns_0_OUTDIR)/Stage/
+
+BLDDIRS += $(VBOX_PATH_PACKAGES)/
+
+include $(FILE_KBUILD_SUB_FOOTER)
+
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/SimBridge.cpp VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/SimBridge.cpp
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/SimBridge.cpp	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/SimBridge.cpp	2017-04-26 23:46:30.000000000 -0700
@@ -0,0 +1,555 @@
+/* $Id: BusMouse.cpp $ */
+/** @file
+ * SimBridge - Pensando simulation bridge.
+ */
+
+/*
+ * Copyright (C) 2006-2016 Oracle Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*********************************************************************************************************************************
+*   Header Files                                                                                                                 *
+*********************************************************************************************************************************/
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/version.h>
+#include <iprt/assert.h>
+#include <iprt/uuid.h>
+
+/** @page pg_simbridge DevSimBridge - Pensando simulation bridge
+ */
+
+
+/*********************************************************************************************************************************
+*   Defined Constants And Macros                                                                                                 *
+*********************************************************************************************************************************/
+
+/*********************************************************************************************************************************
+*   Structures and Typedefs                                                                                                      *
+*********************************************************************************************************************************/
+/**
+ * The device state.
+ */
+typedef struct simbridge_s {
+    int simfd;
+    PPDMDEVINS pDevIns;
+    PDMPCIDEV pciDevice;
+    RTGCPHYS regbase[VBOX_PCI_NUM_REGIONS];
+    R3PTRTYPE(PFNPCICONFIGREAD) pfnConfigRead;
+    R3PTRTYPE(PFNPCICONFIGWRITE) pfnConfigWrite;
+} simbridge_t;
+
+#ifndef VBOX_DEVICE_STRUCT_TESTCASE
+
+# ifdef IN_RING3
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <sys/types.h>
+
+#include "siminf.h"
+#include "bdf.h"
+
+#include "simlib.c"
+
+static void
+dprintf(const char *fmt, ...) __attribute__((format (printf, 1, 2)));
+static void
+dprintf(const char *fmt, ...)
+{
+    static int dprintf_init;
+    static FILE *fp;
+    va_list arg;
+
+    if (!dprintf_init) {
+        dprintf_init = 1;
+        if (getenv("VBOX_SIMBRIDGE_LOG") != NULL) {
+            fp = fopen("/tmp/vbox_simbridge.log", "w+");
+            setlinebuf(fp);
+        }
+    }
+    if (fp) {
+        va_start(arg, fmt);
+        vfprintf(fp, fmt, arg);
+        va_end(arg);
+    }
+}
+
+static DECLCALLBACK(uint32_t)
+simbridge_cfgrd(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev,
+                uint32_t addr, unsigned size)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    u_int64_t val;
+    u_int16_t bdf;
+    int r;
+
+    bdf = pPciDev->Alignment0; /* XXX */
+    r = sim_cfgrd(simb->simfd, bdf, addr, size, &val);
+    if (r != 0) {
+        dprintf("sim_cfgrd bdf %s addr 0x%x size %d failed %d\n",
+                bdf_to_str(bdf), addr, size, r);
+        val = 0xffffffff;
+    }
+    dprintf("sim_cfgrd bdf %s addr 0x%x size %d val 0x%0*llx\n",
+            bdf_to_str(bdf), addr, size, size * 2, val);
+    return val;
+}
+
+/**
+ * @callback_method_impl{FNPCICONFIGWRITE}
+ */
+static DECLCALLBACK(void)
+simbridge_cfgwr(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev,
+                uint32_t addr, uint32_t val, unsigned size)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    u_int16_t bdf;
+    int r;
+
+    bdf = pPciDev->Alignment0; /* XXX */
+    dprintf("sim_cfgwr bdf %s addr 0x%x size %d val 0x%0*x\n",
+            bdf_to_str(bdf), addr, size, size * 2, val);
+    r = sim_cfgwr(simb->simfd, bdf, addr, size, val);
+    if (r != 0) {
+        dprintf("sim_cfgwr bdf %s addr 0x%x size %d val 0x%x failed %d\n",
+                bdf_to_str(bdf), addr, size, val, r);
+    }
+    simb->pfnConfigWrite(pDevIns, pPciDev, addr, val, size);
+}
+
+PDMBOTHCBDECL(int)
+simbridge_memrd(PPDMDEVINS pDevIns, void *pvUser,
+                RTGCPHYS GCPhysAddr, void *pv, unsigned cb)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    uint64_t addr = GCPhysAddr;
+    size_t size = cb;
+    uint64_t val;
+    int r;
+
+    r = sim_memrd(simb->simfd, addr, size, &val);
+    if (r != 0) {
+        dprintf("sim_memrd addr 0x%llx size %lu failed %d\n",
+                addr, size, r);
+        val = (uint64_t)-1;
+    }
+    dprintf("sim_memrd addr 0x%llx size %lu val 0x%0*llx\n",
+            addr, size, (int)size * 2, val);
+
+    switch (size) {
+    case 1: *(u_int8_t  *)pv = val; break;
+    case 2: *(u_int16_t *)pv = val; break;
+    case 4: *(u_int32_t *)pv = val; break;
+    case 8: *(u_int64_t *)pv = val; break;
+    default: break;
+    }
+    return 0;
+}
+
+PDMBOTHCBDECL(int)
+simbridge_memwr(PPDMDEVINS pDevIns, void *pvUser,
+                RTGCPHYS GCPhysAddr, void const *pv, unsigned cb)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    u_int64_t addr = GCPhysAddr;
+    size_t size = cb;
+    u_int64_t val;
+    int r;
+
+    switch (size) {
+    case 1: val = *(const u_int8_t  *)pv; break;
+    case 2: val = *(const u_int16_t *)pv; break;
+    case 4: val = *(const u_int32_t *)pv; break;
+    case 8: val = *(const u_int64_t *)pv; break;
+    default: val = 0; break;
+    }
+
+    r = sim_memwr(simb->simfd, addr, size, val);
+    if (r != 0) {
+        dprintf("sim_memwr addr 0x%llx size %lu val 0x%llx failed %d\n",
+                addr, size, val, r);
+    } else {
+        dprintf("sim_memwr addr 0x%llx size %lu val 0x%0*llx\n",
+                addr, size, (int)size * 2, val);
+    }
+    return 0;
+}
+
+PDMBOTHCBDECL(int)
+simbridge_iord(PPDMDEVINS pDevIns, void *pvUser,
+               RTIOPORT uPort, uint32_t *pu32, unsigned cb)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    uint64_t val;
+    int r;
+
+    r = sim_iord(simb->simfd, uPort, cb, &val);
+    if (r != 0) {
+        dprintf("sim_iord addr 0x%x size %d failed %d\n",
+                uPort, cb, r);
+        val = (uint64_t)-1;
+    }
+    dprintf("sim_iord addr 0x%x size %d val 0x%0*llx\n",
+            uPort, cb, (int)cb * 2, val);
+    *pu32 = val;
+    return 0;
+}
+
+PDMBOTHCBDECL(int)
+simbridge_iowr(PPDMDEVINS pDevIns, void *pvUser,
+               RTIOPORT uPort, uint32_t u32, unsigned cb)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    u_int64_t addr = uPort;
+    size_t size = cb;
+    int r;
+
+    r = sim_iowr(simb->simfd, addr, size, u32);
+    if (r != 0) {
+        dprintf("sim_iowr addr 0x%llx size %lu val 0x%ux failed %d\n",
+                addr, size, u32, r);
+    } else {
+        dprintf("sim_iowr addr 0x%llx size %lu val 0x%0*ux\n",
+                addr, size, (int)size * 2, u32);
+    }
+    return 0;
+}
+
+static DECLCALLBACK(int)
+simbridge_regmap(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, uint32_t iRegion,
+                 RTGCPHYS GCPhysAddress, RTGCPHYS cb, PCIADDRESSSPACE enmType)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    int r;
+
+    dprintf("regmap: iregion %d base 0x%llx size 0x%llx type 0x%x\n",
+            iRegion, GCPhysAddress, cb, enmType);
+    simb->regbase[iRegion] = GCPhysAddress;
+    if (enmType == PCI_ADDRESS_SPACE_IO) {
+        r = PDMDevHlpIOPortRegister(pDevIns, GCPhysAddress, cb, NULL/*pvUser*/,
+                                    simbridge_iowr, simbridge_iord,
+                                    NULL, NULL, "SimBridge");
+    } else {
+        r = PDMDevHlpMMIORegister(pDevIns, GCPhysAddress, cb, NULL/*pvUser*/,
+                                  (IOMMMIO_FLAGS_READ_PASSTHRU |
+                                   IOMMMIO_FLAGS_WRITE_PASSTHRU),
+                                  simbridge_memwr, simbridge_memrd,
+                                  "SimBridge");
+    }
+    return r;
+}
+
+static int
+simbridge_register_bar(simbridge_t *simb, int bdf, PPDMPCIDEV pPciDev,
+                       int baridx)
+{
+    const uint16_t addr = 0x10 + baridx * 4;
+    const uint8_t size = 4;
+    PCIADDRESSSPACE regtype;
+    uint64_t v0, v1, regsize;
+    uint32_t v;
+    int r, n;
+
+    v0 = v1 = 0;
+    sim_cfgwr(simb->simfd, bdf, addr, size, 0xffffffff);
+    r = sim_cfgrd(simb->simfd, bdf, addr, size, &v0);
+    if (r != 0) {
+        dprintf("sim_cfgrd addr 0x%x size %d failed\n", addr, size);
+        return 0;
+    }
+    sim_cfgwr(simb->simfd, bdf, addr, size, 0);
+
+    /* no bits set?  no bar here. */
+    if (v0 == 0) {
+        return 0;
+    }
+
+    n = 0;
+    if ((v0 & 0x1) == 0) {
+        /* Memory space */
+        if ((v0 & 0x7) == 0x0) {
+            /* 32-bit */
+            regtype = (PCIADDRESSSPACE)(PCI_ADDRESS_SPACE_BAR32 |
+                                        PCI_ADDRESS_SPACE_MEM);
+            v = v0;
+            regsize = ~(v & ~0xf) + 1;
+            n = 1;
+        } else if ((v0 & 0x7) == 0x4 && baridx < 5) {
+            /* 64-bit */
+            regtype = (PCIADDRESSSPACE)(PCI_ADDRESS_SPACE_BAR64 |
+                                        PCI_ADDRESS_SPACE_MEM);
+            /*
+             * DevPCI.cpp:pciR3CommonIORegionRegister doesn't
+             * deal with _BAR64 properly.  Treat this case as _BAR32.
+             * BAR sizing could still work if the upper word is
+             * left at all 0's.
+             */
+            regtype = (PCIADDRESSSPACE)(PCI_ADDRESS_SPACE_BAR32 |
+                                        PCI_ADDRESS_SPACE_MEM);
+            sim_cfgwr(simb->simfd, bdf, addr + 4, size, 0xffffffff);
+            sim_cfgrd(simb->simfd, bdf, addr + 4, size, &v1);
+            sim_cfgwr(simb->simfd, bdf, addr + 4, size, 0);
+            regsize = ~((v1 << 32) | (v0 & ~0xf)) + 1;
+            n = 2;
+        } else {
+            dprintf("register_bar: bad mem bar type: baridx %d v0 0x%llx\n",
+                    baridx, v0);
+        }
+    } else {
+        /* I/O space */
+        regtype = (PCIADDRESSSPACE)(PCI_ADDRESS_SPACE_BAR32 |
+                                    PCI_ADDRESS_SPACE_IO);
+        v = v0;
+        regsize = ~(v & ~0x3) + 1;
+        n = 1;
+    }
+
+    if (n) {
+        r = PDMDevHlpPCIIORegionRegisterEx(simb->pDevIns, pPciDev,
+                                           baridx, regsize, regtype,
+                                           simbridge_regmap);
+        dprintf("register_bar: baridx %d n %d\n"
+                "    v0 0x%llx v1 0x%llx\n"
+                "    regsize 0x%llx regtype %d %d\n",
+                baridx, n,
+                v0, v1,
+                regsize, regtype, r);
+    }
+    return n;
+}
+
+static int
+simbridge_register_bars(simbridge_t *simb, int bdf, PPDMPCIDEV pPciDev)
+{
+    for (int i = 0; i < 6; i++) {
+        const int nslots = simbridge_register_bar(simb, bdf, pPciDev, i);
+        /* skip a slot if this one consumed 2 */
+        if (nslots == 2) {
+            i++;
+        }
+    }
+    return 0;
+}
+
+static int
+simbridge_register_device(simbridge_t *simb, int bdf)
+{
+    PPDMPCIDEV pPciDev;
+    int rc;
+
+    pPciDev = (PPDMPCIDEV)PDMDevHlpMMHeapAllocZ(simb->pDevIns,
+                                                sizeof(PDMPCIDEV));
+    /* read the "pci" config space offset range 0-255 */
+    for (int i = 0; i < 256; i += 4) {
+        u_int64_t v;
+        int r = sim_cfgrd(simb->simfd, bdf, i, 4, &v);
+        if (r != 0) {
+            dprintf("sim_cfgrd bdf %s addr 0x%x size %d failed %d\n",
+                    bdf_to_str(bdf), i, 4, r);
+            return -1;
+        }
+        PCIDevSetDWord(pPciDev, i, v);
+    }
+
+    /* XXX stash bdf here for now */
+    pPciDev->Alignment0 = bdf;
+
+    rc = PDMDevHlpPCIRegister(simb->pDevIns, pPciDev);
+    AssertRCReturn(rc, rc);
+
+    PDMDevHlpPCISetConfigCallbacks(simb->pDevIns, pPciDev,
+                                   simbridge_cfgrd,
+                                   &simb->pfnConfigRead,
+                                   simbridge_cfgwr,
+                                   &simb->pfnConfigWrite);
+    dprintf("simbridge_register_device: added bdf %s\n", bdf_to_str(bdf));
+
+    simbridge_register_bars(simb, bdf, pPciDev);
+    return 0;
+}
+
+static int
+simbridge_scan_devices(simbridge_t *simb, int bus)
+{
+    int dev, bdf, ht;
+    u_int64_t val;
+
+    dprintf("simbridge_scan_devices: bus 0x%02x\n", bus);
+
+    for (dev = 0; dev < 32; dev++) {
+        bdf = bdf_make(bus, dev, 0);
+
+        /* read vendor/device id to check if a device exists at bdf */
+        if (sim_cfgrd(simb->simfd, bdf, 0, 4, &val) != 0) {
+            continue;
+        }
+        if (val == 0 || val == 0xffffffff) {
+            continue;
+        }
+
+        /* read header type register */
+        if (sim_cfgrd(simb->simfd, bdf, 0xe, 1, &val) != 0) {
+            continue;
+        }
+        /* bridge header type? */
+        if (val == 1) {
+            /* read secondary bus number */
+            if (sim_cfgrd(simb->simfd, bdf, 0x19, 1, &val) == 0) {
+                int secbus = val;
+                if (secbus != 0) { /* avoid loops if not set */
+                    /* scan secondary bus */
+                    simbridge_scan_devices(simb, secbus);
+                }
+            }
+        } else {
+            /* add endpoint */
+            simbridge_register_device(simb, bdf);
+        }
+    }
+    return 0;
+}
+
+/**
+ * @interface_method_impl{PDMDEVREG,pfnConstruct}
+ */
+static DECLCALLBACK(int)
+simbridge_construct(PPDMDEVINS pDevIns, int iInstance, PCFGMNODE pCfg)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+    int rc;
+
+    dprintf("SimBridge: simbridge_construct[%d] called\n", iInstance);
+    Log(("SimBridge: simbridge_construct[%d] called\n", iInstance));
+
+    PDMDEV_CHECK_VERSIONS_RETURN(pDevIns);
+
+    simb->pDevIns = pDevIns;
+    simb->simfd = sim_open("vbox");
+    if (simb->simfd == -1) {
+        dprintf("sim_open failed\n");
+        // quietly run without registering any device
+        return VINF_SUCCESS;
+    }
+
+    if (simbridge_scan_devices(simb, 0) < 0) {
+        dprintf("simbridge_scan_devices failed\n");
+        sim_close(simb->simfd);
+        // quietly run without registering any device(s)
+        return VINF_SUCCESS;
+    }
+
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) simbridge_destruct(PPDMDEVINS pDevIns)
+{
+    simbridge_t *simb = PDMINS_2_DATA(pDevIns, simbridge_t *);
+
+    dprintf("SimBridge: simbridge_destruct called\n");
+    Log(("SimBridge: simbridge_destruct called\n"));
+    sim_close(simb->simfd);
+    return VINF_SUCCESS;
+}
+
+
+/**
+ * The device registration structure.
+ */
+const PDMDEVREG g_DeviceSimBridge = {
+    /* u32Version */
+    PDM_DEVREG_VERSION,
+    /* szName */
+    "VBoxSimBridge",
+    /* szRCMod */
+    "VBoxSimBridgeRC.rc",
+    /* szR0Mod */
+    "VBoxSimBridgeR0.r0",
+    /* pszDescription */
+    "Pensando simulation bridge device.",
+    /* fFlags */
+    (PDM_DEVREG_FLAGS_HOST_BITS_DEFAULT |
+     PDM_DEVREG_FLAGS_GUEST_BITS_DEFAULT),
+    /* fClass */
+    PDM_DEVREG_CLASS_MISC,
+    /* cMaxInstances */
+    1,
+    /* cbInstance */
+    sizeof(simbridge_t),
+    /* pfnConstruct */
+    simbridge_construct,
+    /* pfnDestruct */
+    simbridge_destruct,
+    /* pfnRelocate */
+    NULL,
+    /* pfnMemSetup */
+    NULL,
+    /* pfnPowerOn */
+    NULL,
+    /* pfnReset */
+    NULL,
+    /* pfnSuspend */
+    NULL,
+    /* pfnResume */
+    NULL,
+    /* pfnAttach */
+    NULL,
+    /* pfnDetach */
+    NULL,
+    /* pfnQueryInterface. */
+    NULL,
+    /* pfnInitComplete */
+    NULL,
+    /* pfnPowerOff */
+    NULL,
+    /* pfnSoftReset */
+    NULL,
+    /* u32VersionEnd */
+    PDM_DEVREG_VERSION
+};
+
+#ifdef VBOX_IN_EXTPACK_R3
+/**
+ * @callback_method_impl{FNPDMVBOXDEVICESREGISTER}
+ */
+extern "C" DECLEXPORT(int) VBoxDevicesRegister(PPDMDEVREGCB pCallbacks,
+                                               uint32_t u32Version)
+{
+    dprintf("SimBridge: VBoxDevicesRegister called\n");
+    Log(("SimBridge: VBoxDevicesRegister called\n"));
+
+    AssertLogRelMsgReturn(u32Version >= VBOX_VERSION,
+                          ("u32Version=%#x VBOX_VERSION=%#x\n", u32Version, VBOX_VERSION),
+                          VERR_EXTPACK_VBOX_VERSION_MISMATCH);
+    AssertLogRelMsgReturn(pCallbacks->u32Version == PDM_DEVREG_CB_VERSION,
+                          ("pCallbacks->u32Version=%#x PDM_DEVREG_CB_VERSION=%#x\n", pCallbacks->u32Version, PDM_DEVREG_CB_VERSION),
+                          VERR_VERSION_MISMATCH);
+
+    return pCallbacks->pfnRegister(pCallbacks, &g_DeviceSimBridge);
+}
+#endif /* VBOX_IN_EXTPACK_R3 */
+
+# endif /* IN_RING3 */
+#endif /* !VBOX_DEVICE_STRUCT_TESTCASE */
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/VBoxSimBridgeMain.cpp VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/VBoxSimBridgeMain.cpp
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/VBoxSimBridgeMain.cpp	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/VBoxSimBridgeMain.cpp	2017-02-28 08:51:03.000000000 -0800
@@ -0,0 +1,202 @@
+/* $Id: VBoxBusMouseMain.cpp $ */
+/** @file
+ * SimBridge main module.
+ */
+
+/*
+ * Copyright (C) 2010-2016 Oracle Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*********************************************************************************************************************************
+*   Header Files                                                                                                                 *
+*********************************************************************************************************************************/
+#include <VBox/ExtPack/ExtPack.h>
+
+#include <VBox/err.h>
+#include <VBox/version.h>
+#include <VBox/vmm/cfgm.h>
+#include <iprt/string.h>
+#include <iprt/param.h>
+#include <iprt/path.h>
+
+
+/*********************************************************************************************************************************
+*   Global Variables                                                                                                             *
+*********************************************************************************************************************************/
+/** Pointer to the extension pack helpers. */
+static PCVBOXEXTPACKHLP g_pHlp;
+
+
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnInstalled}
+//  */
+// static DECLCALLBACK(void) vboxSkeletonExtPack_Installed(PCVBOXEXTPACKREG pThis, VBOXEXTPACK_IF_CS(IVirtualBox) *pVirtualBox);
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnUninstall}
+//  */
+// static DECLCALLBACK(int)  vboxSkeletonExtPack_Uninstall(PCVBOXEXTPACKREG pThis, VBOXEXTPACK_IF_CS(IVirtualBox) *pVirtualBox);
+//
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnVirtualBoxReady}
+//  */
+// static DECLCALLBACK(void)  vboxSkeletonExtPack_VirtualBoxReady(PCVBOXEXTPACKREG pThis, VBOXEXTPACK_IF_CS(IVirtualBox) *pVirtualBox);
+//
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnUnload}
+//  */
+// static DECLCALLBACK(void) vboxSkeletonExtPack_Unload(PCVBOXEXTPACKREG pThis);
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnVMCreated}
+//  */
+// static DECLCALLBACK(int)  vboxSkeletonExtPack_VMCreated(PCVBOXEXTPACKREG pThis, VBOXEXTPACK_IF_CS(IVirtualBox) *pVirtualBox, IMachine *pMachine);
+//
+
+/**
+ * @interface_method_impl{VBOXEXTPACKREG,pfnVMConfigureVMM
+ */
+static DECLCALLBACK(int) vboxSimBridgeExtPack_VMConfigureVMM(PCVBOXEXTPACKREG pThis, IConsole *pConsole, PVM pVM)
+{
+    RT_NOREF(pThis, pConsole);
+
+    /*
+     * Find the sim bridge module and tell PDM to load it.
+     * ASSUME /PDM/Devices exists.
+     */
+    char szPath[RTPATH_MAX];
+    int rc = g_pHlp->pfnFindModule(g_pHlp, "VBoxSimBridgeR3", NULL, VBOXEXTPACKMODKIND_R3, szPath, sizeof(szPath), NULL);
+    if (RT_FAILURE(rc))
+        return rc;
+
+    PCFGMNODE pCfgRoot = CFGMR3GetRoot(pVM);
+    AssertReturn(pCfgRoot, VERR_INTERNAL_ERROR_3);
+
+    PCFGMNODE pCfgDevices = CFGMR3GetChild(pCfgRoot, "PDM/Devices");
+    AssertReturn(pCfgDevices, VERR_INTERNAL_ERROR_3);
+
+    PCFGMNODE pCfgMine;
+    rc = CFGMR3InsertNode(pCfgDevices, "VBoxSimBridge", &pCfgMine);
+    AssertRCReturn(rc, rc);
+    rc = CFGMR3InsertString(pCfgMine, "Path", szPath);
+    AssertRCReturn(rc, rc);
+
+    /*
+     * Tell PDM where to find the R0 and RC modules for the sim bridge.
+     */
+#ifdef VBOX_WITH_RAW_MODE
+    rc = g_pHlp->pfnFindModule(g_pHlp, "VBoxSimBridgeRC", NULL, VBOXEXTPACKMODKIND_RC, szPath, sizeof(szPath), NULL);
+    AssertRCReturn(rc, rc);
+    RTPathStripFilename(szPath);
+    rc = CFGMR3InsertString(pCfgMine, "RCSearchPath", szPath);
+    AssertRCReturn(rc, rc);
+#endif
+
+    rc = g_pHlp->pfnFindModule(g_pHlp, "VBoxSimBridgeR0", NULL, VBOXEXTPACKMODKIND_R0, szPath, sizeof(szPath), NULL);
+    AssertRCReturn(rc, rc);
+    RTPathStripFilename(szPath);
+    rc = CFGMR3InsertString(pCfgMine, "R0SearchPath", szPath);
+    AssertRCReturn(rc, rc);
+
+    /*
+     * Insert /Device node for this VM.
+     */
+    pCfgDevices = CFGMR3GetChild(pCfgRoot, "Devices");
+    AssertReturn(pCfgDevices, VERR_INTERNAL_ERROR_3);
+
+    /* /Devices/VBoxSimBridge */
+    rc = CFGMR3InsertNode(pCfgDevices, "VBoxSimBridge", &pCfgMine);
+    AssertRCReturn(rc, rc);
+
+    /* /Devices/VBoxSimBridge/0 */
+    rc = CFGMR3InsertNode(pCfgMine, "0", &pCfgMine);
+    AssertRCReturn(rc, rc);
+
+    return VINF_SUCCESS;
+}
+
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnVMPowerOn}
+//  */
+// static DECLCALLBACK(int)  vboxSkeletonExtPack_VMPowerOn(PCVBOXEXTPACKREG pThis, IConsole *pConsole, PVM pVM);
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnVMPowerOff}
+//  */
+// static DECLCALLBACK(void) vboxSkeletonExtPack_VMPowerOff(PCVBOXEXTPACKREG pThis, IConsole *pConsole, PVM pVM);
+// /**
+//  * @interface_method_impl{VBOXEXTPACKREG,pfnVMPowerOff}
+//  */
+// static DECLCALLBACK(void) vboxSkeletonExtPack_QueryObject(PCVBOXEXTPACKREG pThis, PCRTUUID pObjectId);
+
+
+static const VBOXEXTPACKREG g_vboxSimBridgeExtPackReg =
+{
+    VBOXEXTPACKREG_VERSION,
+    /* .uVBoxFullVersion =  */  VBOX_FULL_VERSION,
+    /* .pfnInstalled =      */  NULL,
+    /* .pfnUninstall =      */  NULL,
+    /* .pfnVirtualBoxReady =*/  NULL,
+    /* .pfnConsoleReady =   */  NULL,
+    /* .pfnUnload =         */  NULL,
+    /* .pfnVMCreated =      */  NULL,
+    /* .pfnVMConfigureVMM = */  vboxSimBridgeExtPack_VMConfigureVMM,
+    /* .pfnVMPowerOn =      */  NULL,
+    /* .pfnVMPowerOff =     */  NULL,
+    /* .pfnQueryObject =    */  NULL,
+    /* .pfnReserved1 =      */  NULL,
+    /* .pfnReserved2 =      */  NULL,
+    /* .pfnReserved3 =      */  NULL,
+    /* .pfnReserved4 =      */  NULL,
+    /* .pfnReserved5 =      */  NULL,
+    /* .pfnReserved6 =      */  NULL,
+    /* .u32Reserved7 =      */  0,
+    VBOXEXTPACKREG_VERSION
+};
+
+
+/** @callback_method_impl{FNVBOXEXTPACKREGISTER}  */
+extern "C" DECLEXPORT(int) VBoxExtPackRegister(PCVBOXEXTPACKHLP pHlp, PCVBOXEXTPACKREG *ppReg, PRTERRINFO pErrInfo)
+{
+    /*
+     * Check the VirtualBox version.
+     */
+    if (!VBOXEXTPACK_IS_VER_COMPAT(pHlp->u32Version, VBOXEXTPACKHLP_VERSION))
+        return RTErrInfoSetF(pErrInfo, VERR_VERSION_MISMATCH,
+                             "Helper version mismatch - expected %#x got %#x",
+                             VBOXEXTPACKHLP_VERSION, pHlp->u32Version);
+    if (   VBOX_FULL_VERSION_GET_MAJOR(pHlp->uVBoxFullVersion) != VBOX_VERSION_MAJOR
+        || VBOX_FULL_VERSION_GET_MINOR(pHlp->uVBoxFullVersion) != VBOX_VERSION_MINOR)
+        return RTErrInfoSetF(pErrInfo, VERR_VERSION_MISMATCH,
+                             "VirtualBox version mismatch - expected %u.%u got %u.%u",
+                             VBOX_VERSION_MAJOR, VBOX_VERSION_MINOR,
+                             VBOX_FULL_VERSION_GET_MAJOR(pHlp->uVBoxFullVersion),
+                             VBOX_FULL_VERSION_GET_MINOR(pHlp->uVBoxFullVersion));
+
+    /*
+     * We're good, save input and return the registration structure.
+     */
+    g_pHlp = pHlp;
+    *ppReg = &g_vboxSimBridgeExtPackReg;
+
+    return VINF_SUCCESS;
+}
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/bdf.h VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/bdf.h
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/bdf.h	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/bdf.h	2017-04-22 01:10:30.000000000 -0700
@@ -0,0 +1,60 @@
+#ifndef __BDF_H__
+#define __BDF_H__
+
+static inline int
+bdf_to_bus(const int bdf)
+{
+    return (bdf >> 8) & 0xff;
+}
+
+static inline int
+bdf_to_dev(const int bdf)
+{
+    return (bdf >> 3) & 0x1f;
+}
+
+static inline int
+bdf_to_fnc(const int bdf)
+{
+    return bdf & 0x7;
+}
+
+static inline int
+bdf_make(const int b, const int d, const int f)
+{
+    return ((b & 0xff) << 8) | ((d & 0x1f) << 3) | (f & 0x7);
+}
+
+static inline int
+bdf_ari_make(const int b, const int f)
+{
+    return ((b & 0xff) << 8) | (f & 0xff);
+}
+
+static inline char *
+bdf_to_buf(const int bdf, char *buf, size_t bufsz)
+{
+    const int b = bdf_to_bus(bdf);
+    const int d = bdf_to_dev(bdf);
+    const int f = bdf_to_fnc(bdf);
+    snprintf(buf, bufsz, "%02x:%02x.%d", b, d, f);
+    return buf;
+}
+
+static inline char *
+bdf_to_str(const int bdf)
+{
+    static char buf[8];
+    return bdf_to_buf(bdf, buf, sizeof(buf));
+}
+
+static inline int
+bdf_from_str(const char *bdfstr)
+{
+    int b, d, f;
+    int n = sscanf(bdfstr, "%02x:%02x.%d", &b, &d, &f);
+    if (n != 3) return -1;
+    return bdf_make(b, d, f);
+}
+
+#endif /* __BDF_H__ */
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/siminf.h VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/siminf.h
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/siminf.h	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/siminf.h	2017-04-22 01:10:30.000000000 -0700
@@ -0,0 +1,20 @@
+#ifndef __SIMINF_H__
+#define __SIMINF_H__
+
+#define SIM_DEFAULT_PORT        50000
+
+int sim_open(const char *myname);
+void sim_close(int s);
+
+int sim_cfgrd(int s, u_int16_t bdf,
+              u_int16_t addr, u_int8_t size, u_int64_t *val);
+int sim_cfgwr(int s, u_int16_t bdf,
+              u_int16_t addr, u_int8_t size, u_int64_t val);
+
+int sim_memrd(int s, u_int64_t addr, u_int8_t size, u_int64_t *val);
+int sim_memwr(int s, u_int64_t addr, u_int8_t size, u_int64_t val);
+
+int sim_iord(int s, u_int16_t addr, u_int8_t size, u_int64_t *val);
+int sim_iowr(int s, u_int16_t addr, u_int8_t size, u_int64_t val);
+
+#endif /* __SIMINF_H__ */
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/simlib.c VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/simlib.c
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/simlib.c	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/simlib.c	2017-04-22 22:59:46.000000000 -0700
@@ -0,0 +1,269 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netdb.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "siminf.h"
+#include "simmsg.h"
+
+/*
+ * Read n bytes from file descriptor
+ * @fd: file descriptor
+ * @buf: buffer to read into
+ * @n: how many bytes to read into buffer
+ *
+ * Returns 0 if EOF (client closed), < 0 if error, otherwise
+ * returns the number of bytes read.
+ *
+ * Pretty much right-out-of Stevens UNIX Network Programming,
+ * but don't block/unblock signals, just retry on EINTR.
+ */
+static ssize_t
+readn(int fd, void *bufarg, size_t n)
+{
+    char *buf = (char *)bufarg;
+    size_t nleft = n;
+    ssize_t nread;
+
+    do {
+        nread = read(fd, buf, nleft);
+        if (nread < 0) {
+            if (errno == EINTR) {
+                continue;       /* ignore EINTRs */
+            }
+            break;              /* real error */
+        } else if (nread == 0) {
+            break;              /* EOF */
+        }
+        nleft -= nread;
+        buf += nread;
+    } while (nleft);
+
+    if (nread < 0) {
+        return (nread);         /* error, return < 0 */
+    } else {
+        return (n - nleft);
+    }
+}
+/*
+ * Write n bytes to file descriptor
+ * @fd: file descriptor
+ * @buf: buffer to read into
+ * @n: how many bytes to read into buffer
+ *
+ * Returns < 0 if error, otherwise
+ * returns the number of bytes read.
+ */
+static ssize_t
+writen(int fd, const void *bufarg, size_t n)
+{
+    const char *buf = (const char *)bufarg;
+    size_t nleft = n;
+    ssize_t nwritten;
+
+    do {
+        nwritten = write(fd, buf, nleft);
+        if (nwritten < 0) {
+            if (errno == EINTR) {
+                continue;       /* ignore EINTRs */
+            }
+            break;              /* real error */
+        }
+        nleft -= nwritten;
+        buf += nwritten;
+    } while (nleft);
+
+    if (nwritten < 0) {
+        return (nwritten);      /* error, return < 0 */
+    } else {
+        return (n - nleft);
+    }
+}
+
+static int
+sim_wait_for_resp(int s, simmsgtype_t msgtype, simmsg_t *m)
+{
+    while (readn(s, m, sizeof(simmsg_t)) > 0) {
+        if (m->msgtype == msgtype)
+            return 0;
+    }
+    return -1;
+}
+
+static int
+sim_do_read(int s, simmsgtype_t msgtype,
+            u_int16_t bdf, u_int64_t addr, u_int8_t size, u_int64_t *val)
+{
+    int r;
+    simmsg_t m = {
+        .msgtype = msgtype,
+        .u.read.bdf = bdf,
+        .u.read.addr = addr,
+        .u.read.size = size,
+    };
+
+    r = writen(s, &m, sizeof(m));
+    if (r < 0) return r;
+
+    r = sim_wait_for_resp(s, SIMMSG_RDRESP, &m);
+    if (r < 0) return r;
+
+    if (m.u.readres.error == 0) {
+        *val = m.u.readres.val;
+    }
+    return -m.u.readres.error;
+}
+
+static int
+sim_do_write(int s, simmsgtype_t msgtype,
+             u_int16_t bdf, u_int64_t addr, u_int8_t size, u_int64_t val)
+{
+    int r;
+    simmsg_t m = {
+        .msgtype = msgtype,
+        .u.write.bdf = bdf,
+        .u.write.addr = addr,
+        .u.write.size = size,
+        .u.write.val = val,
+    };
+
+    r = writen(s, &m, sizeof(m));
+    if (r < 0) return r;
+    r = 0;
+
+#ifdef SIM_SYNC_WRITES
+    r = sim_wait_for_resp(s, SIMMSG_WRRESP, &m);
+    if (r < 0) return r;
+    r = -m.u.writeres.error;
+#endif
+
+    return r;
+}
+
+static int
+sim_make_addr(char *host, int port, struct sockaddr_in *addr)
+{
+    struct hostent *he;
+
+    he = gethostbyname(host);
+    if (he == NULL) {
+        fprintf(stderr, "gethostbyname failed for host %s\n", host);
+        return -1;
+    }
+
+    memset(addr, 0, sizeof(*addr));
+    addr->sin_family = he->h_addrtype;
+    addr->sin_port = htons(port);
+    memcpy(&addr->sin_addr, he->h_addr, he->h_length);
+    return 0;
+}
+
+static int
+sim_get_addr(struct sockaddr_in *addr)
+{
+    char host[64], *env;
+    int port;
+
+    env = getenv("SIM_HOST");
+    if (env != NULL) {
+        char *colon = strchr(env, ':');
+        if (colon) {
+            *colon = '\0';
+            port = strtoul(colon + 1, NULL, 0);
+        } else {
+            port = SIM_DEFAULT_PORT;
+        }
+        strncpy(host, env, sizeof(host));
+    } else {
+        strncpy(host, "localhost", sizeof(host));
+        port = SIM_DEFAULT_PORT;
+    }
+
+    return sim_make_addr(host, port, addr);
+}
+
+static int
+sim_connect(void)
+{
+    struct sockaddr_in addr;
+    int s = -1;
+
+    if (sim_get_addr(&addr) < 0) return -1;
+
+    s = socket(AF_INET, SOCK_STREAM, 0);
+    if (s < 0) {
+        perror("socket");
+        return -1;
+    }
+
+    while (connect(s, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&
+           errno != EISCONN) {
+        if (errno != EINTR) {
+            perror("connect");
+            close(s);
+            return -1;
+        }
+    }
+
+    return s;
+}
+
+int
+sim_open(const char *myname)
+{
+    simmsg_t m = {
+        .msgtype = SIMMSG_INIT,
+    };
+    int s = sim_connect();
+    strncpy(m.u.init.name, myname, sizeof(m.u.init.name) - 1);
+    writen(s, &m, sizeof(m));
+    return s;
+}
+
+void
+sim_close(int s)
+{
+    close(s);
+}
+
+int
+sim_cfgrd(int s, u_int16_t bdf, u_int16_t addr, u_int8_t size, u_int64_t *val)
+{
+    return sim_do_read(s, SIMMSG_CFGRD, bdf, addr, size, val);
+}
+
+int
+sim_cfgwr(int s, u_int16_t bdf, u_int16_t addr, u_int8_t size, u_int64_t val)
+{
+    return sim_do_write(s, SIMMSG_CFGWR, bdf, addr, size, val);
+}
+
+int
+sim_memrd(int s, u_int64_t addr, u_int8_t size, u_int64_t *val)
+{
+    return sim_do_read(s, SIMMSG_MEMRD, 0, addr, size, val);
+}
+
+int
+sim_memwr(int s, u_int64_t addr, u_int8_t size, u_int64_t val)
+{
+    return sim_do_write(s, SIMMSG_MEMWR, 0, addr, size, val);
+}
+
+int
+sim_iord(int s, u_int16_t addr, u_int8_t size, u_int64_t *val)
+{
+    return sim_do_read(s, SIMMSG_IORD, 0, addr, size, val);
+}
+
+int
+sim_iowr(int s, u_int16_t addr, u_int8_t size, u_int64_t val)
+{
+    return sim_do_write(s, SIMMSG_IOWR, 0, addr, size, val);
+}
diff -uprN VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/simmsg.h VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/simmsg.h
--- VirtualBox-5.1.14-old/src/VBox/ExtPacks/SimBridge/simmsg.h	1969-12-31 16:00:00.000000000 -0800
+++ VirtualBox-5.1.14-dev/src/VBox/ExtPacks/SimBridge/simmsg.h	2017-04-22 01:10:30.000000000 -0700
@@ -0,0 +1,56 @@
+#ifndef __SIMMSG_H__
+#define __SIMMSG_H__
+
+typedef enum simmsgtype_e {
+    SIMMSG_INIT,
+    SIMMSG_CFGRD,
+    SIMMSG_CFGWR,
+    SIMMSG_MEMRD,
+    SIMMSG_MEMWR,
+    SIMMSG_IORD,
+    SIMMSG_IOWR,
+    SIMMSG_RDRESP,
+    SIMMSG_WRRESP,
+} simmsgtype_t;
+
+typedef struct simmsg_s {
+    u_int16_t magic;
+    u_int16_t msgtype;
+    u_int32_t _pad;
+    union {
+        struct {
+            char name[32];
+        } init;
+        struct {
+            u_int16_t bdf;
+            u_int64_t addr;
+            u_int8_t size;
+        } read;
+        struct {
+            u_int16_t bdf;
+            u_int64_t addr;
+            u_int64_t val;
+            u_int8_t size;
+            u_int8_t error;
+        } readres;
+        struct {
+            u_int16_t bdf;
+            u_int64_t addr;
+            u_int64_t val;
+            u_int8_t size;
+        } write;
+        struct {
+            u_int16_t bdf;
+            u_int64_t addr;
+            u_int64_t val;
+            u_int8_t size;
+            u_int8_t error;
+        } writeres;
+        struct {
+            /* room to grow without breaking existing clients */
+            u_int8_t pad[64];
+        } pad;
+    } u;
+} simmsg_t;
+
+#endif /* __SIMMSG_H__ */
Binary files VirtualBox-5.1.14-old/src/VBox/GuestHost/OpenGL/glapi_parser/apiutil.pyc and VirtualBox-5.1.14-dev/src/VBox/GuestHost/OpenGL/glapi_parser/apiutil.pyc differ
Binary files VirtualBox-5.1.14-old/src/VBox/GuestHost/OpenGL/packer/pack_currenttypes.pyc and VirtualBox-5.1.14-dev/src/VBox/GuestHost/OpenGL/packer/pack_currenttypes.pyc differ
Binary files VirtualBox-5.1.14-old/src/VBox/GuestHost/OpenGL/state_tracker/convert.pyc and VirtualBox-5.1.14-dev/src/VBox/GuestHost/OpenGL/state_tracker/convert.pyc differ
Binary files VirtualBox-5.1.14-old/src/VBox/GuestHost/OpenGL/state_tracker/get_components.pyc and VirtualBox-5.1.14-dev/src/VBox/GuestHost/OpenGL/state_tracker/get_components.pyc differ
Binary files VirtualBox-5.1.14-old/src/VBox/HostServices/SharedOpenGL/crserverlib/get_sizes.pyc and VirtualBox-5.1.14-dev/src/VBox/HostServices/SharedOpenGL/crserverlib/get_sizes.pyc differ
