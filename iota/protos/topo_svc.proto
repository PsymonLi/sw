//------------------------------------------------------------------------------
// {C} Copyright 2018 Pensando Systems Inc. All rights reserved
//
// protobuf specification for IO Test Automation Topology Abstraction Service
//------------------------------------------------------------------------------

syntax = "proto3";
package iotamodel;

import "types.proto";

// ---------------------------- Topology API ----------------------------

// Topology Service Methods
service TopologyApi {
    // InstantiateTopology is called by harness which assigns a personality to the node based on the topology.
    // This is a blocking call to the harness, The parallel instantiation across the nodes is handled internally.

    // InitTestBed Allocate Data VLANs, copy over built artifacts and starts IOTA Agent on all the nodes
    rpc InitTestBed (TestBedMsg) returns (TestBedMsg) {};

    // CleanUpTestBed will ensure that any state left behind from the previous run is appropriately cleaned up.
    rpc CleanUpTestBed(TestBedMsg) returns (TestBedMsg) {};

    // AddNodes brings up the nodes with their corresponding personalities
    rpc AddNodes (NodeMsg) returns (NodeMsg) {};

    // DeleteNodes removes a node from the e2e cluster
    rpc DeleteNodes (NodeMsg) returns (NodeMsg) {};

    // GetNodes returns the topology information of all the nodes.
    rpc GetNodes (NodeMsg) returns (NodeMsg) {};

    // AddWorkloads brings up a workload type on a given node
    rpc AddWorkloads (WorkloadMsg) returns (WorkloadMsg) {};

    // DeleteWorkloads deletes a given workload
    rpc DeleteWorkloads (WorkloadMsg) returns (WorkloadMsg) {};

    // Trigger invokes the workload's trigger. It could be ping, start client/server etc..
    rpc Trigger(TriggerMsg) returns (TriggerMsg) {};

    // CheckClusterHealth returns the cluster health
    rpc CheckClusterHealth(NodeMsg) returns  (ClusterHealthMsg) {};
}

// Op defines topology operation
enum Op {
        NONE    = 0;
        ADD     = 1;
        DELETE  = 2;
        GET     = 3;
}

// NodeInfo encapsulates all topology information for a given iota-server invocation
message NodeMsg{
    // API Response for the node
    IotaAPIResponse api_response    = 1;

    // Node operation
    Op node_op                      = 2;

    // List of nodes in the e2e cluster
    repeated Node nodes             = 3;

    // Set this to true during init time. This will essentially brings up the e2e cluster
    bool make_cluster               = 4;
}

enum PersonalityType {
    PERSONALITY_NONE                = 0;
    PERSONALITY_NAPLES              = 1;
    PERSONALITY_VENICE              = 2;
    PERSONALITY_NAPLES_WITH_QEMU    = 3;
}

// Node captures personality details of an E2E node
message Node {
    // PersonalityType captures the node personality. naples node, venice node or qemu
    PersonalityType     type            = 1;

    // Image captures the the built artifacts that need to be loaded on the node depending on the personality type
    string              image           = 2;

    // IP Address of the node
    string              ip_address      = 3;

    // Node identifier
    string              name            = 4;

    // Node specific configs
    oneof node_info {
        // naples
        NaplesConfig    naples_config  = 5;

        VeniceConfig    venice_config  = 6;
    }

    // NodeStatus captures the details of the node action
    IotaAPIResponse node_status         = 7;
}


message NaplesConfig {

    // Control interface to use
    string control_intf          = 1;

    // Control ip to use
    string control_ip            = 2;

    // Data interfaces to use
    repeated string data_intfs   = 3;

    // Venice IPs to use, if specified agent will come up im managed mode.
    repeated string venice_ips   = 4;

}

message VenicePeer {

    // hostname of peer node
    string  host_name   = 1;

    // ip of the peer node
    string  ip_address  = 2;
}

message VeniceConfig {

    // Control interface to use
    string control_intf               = 1;

    // Control ip to use
    string control_ip                 = 2;

    // Peers to add host name entries.
    repeated VenicePeer venice_peers  = 3;

}


message WorkloadMsg{
    // API Response
    IotaAPIResponse api_response        = 1;

    // Workload Operation Type
    Op workload_op                      = 2;

    // List of workloads
    repeated Workload workloads         = 3;

}

enum WorkloadType {
    WORKLOAD_TYPE_NONE    = 0;
    WORKLOAD_TYPE_VSWITCH = 1;
    WORKLOAD_TYPE_SRIOV   = 2; 
}

message Workload {
    WorkloadType    type                    = 1;
    // Workload Identifier
    string workload_name                    = 2;

    // Node on which this needs to be spun up
    string node_name                        = 3;

    // Data VLAN for the workload
    uint32 encap_vlan                       = 4;

    // IPAddress of the workload. Represent this as a CIDR block. 10.0.0.1/16 will be
    // interpreted as 10.0.0.1 is the IP of the workload container and it belongs to a /16 subnet.
    string ip_address                       = 5;

    // MAC Address of the workload
    string mac_address                      = 6;

    // Interface to which workload needs to be attached.
    string interface                        = 7;

    // Workload Status
    IotaAPIResponse workload_status         = 8;
}

enum TriggerOp {
    TYPE_NONE           = 0;
    TX_PKT              = 1;
    RX_PKT              = 2;
    EXEC_CMDS           = 3;
    TERMINATE_ALL_CMDS  = 4;
}

message TriggerMsg {
    //API Status
    IotaAPIResponse api_response            = 1;

    // Type of the trigger operation
    TriggerOp trigger_op                    = 2;


    // Node on which trigger needs to be executed
    string node_name                        = 3;

    // Command Request params
    repeated Command    commands            = 4;
}

enum CommandMode {
    COMMAND_NONE        = 0;
    COMMAND_FOREGROUND  = 1;
    COMMAND_BACKGROUND  = 2;
}
message Command {
    // Whether to run the command in foreground or background
    CommandMode     mode                = 1;

    // Fully qualified command line that needs to be called
    oneof command_or_pkt {
        string          command     = 2;
        string          packet      = 3;
    }

    // Workload name of the command
    string          workload_name   = 4;

    // ================ Output Parameters ===================
    // StdOut of the comamnd
    string          stdout          = 5;

    // StdErr of the command
    string          stderr          = 6;

    // Exit code of the command
    int32          exit_code        = 7;

    // command handle. Useful only for background commands
    string          handle          = 8;

    // received packet for the command
    string          rx_pkt          = 9;
}

// Captures the overall health of the e2e cluster
message ClusterHealthMsg {
    IotaAPIResponse api_response    = 1;
    // Individual node health statuses
    repeated NodeHealth health      = 2;
}


message NodeHealth {
    enum HealthCode {
        HEALTH_OK      = 0;
        NAPLES_DOWN    = 1;
        NODE_DOWN      = 2;
        APP_DOWN       = 3;
    }
    // Name of the node
    string  node_name        = 1;

    // Health code of the node
    HealthCode health_code   = 2;
}

message TestBedMsg {
    // API Response
    IotaAPIResponse api_response        = 1;

    // Switch port id for the current test bed
    uint32 switch_port_id               = 2;

    // NAPLES tarball to copy on the remote nodes
    string naples_image                 = 3;

    // Venice tarball to copy on the remote nodes
    string venice_image                 = 4;

    // Driver sources to copy on the remote nodes
    string driver_sources               = 6;

    // Allocated vlans based off of the port id
    repeated uint32 allocated_vlans     = 7;

    // List of node IP addresses
    repeated string ip_address          = 8;

    // Control Interface to use
    string control_intf                 = 9;

    // Username for logging into the nodes
    string user                         = 10;

    // Password for logging into the nodes
    string passwd                         = 11;
}
