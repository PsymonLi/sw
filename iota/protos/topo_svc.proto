//------------------------------------------------------------------------------
// {C} Copyright 2018 Pensando Systems Inc. All rights reserved
//
// protobuf specification for IO Test Automation Topology Abstraction Service
//------------------------------------------------------------------------------

syntax = "proto3";
package iotamodel;

import "types.proto";

// ---------------------------- Topology API ----------------------------

// Topology Service Methods
service TopologyApi {
    // InstantiateTopology is called by harness which assigns a personality to the node based on the topology.
    // This is a blocking call to the harness, The parallel instantiation across the nodes is handled internally.

    // InitTestBed Allocate Data VLANs, copy over built artifacts and starts IOTA Agent on all the nodes
    rpc InitTestBed (TestBedMsg) returns (TestBedMsg) {};

    // CleanUpTestBed will ensure that any state left behind from the previous run is appropriately cleaned up.
    rpc CleanUpTestBed(TestBedMsg) returns (TestBedMsg) {};

    // AddNodes brings up the nodes with their corresponding personalities
    rpc AddNodes (NodeMsg) returns (NodeMsg) {};

    // DeleteNodes removes a node from the e2e cluster
    rpc DeleteNodes (NodeMsg) returns (NodeMsg) {};

    // GetNodes returns the topology information of all the nodes.
    rpc GetNodes (NodeMsg) returns (NodeMsg) {};

    // AddWorkloads brings up a workload type on a given node
    rpc AddWorkloads (WorkloadMsg) returns (WorkloadMsg) {};

    // DeleteWorkloads deletes a given workload
    rpc DeleteWorkloads (WorkloadMsg) returns (WorkloadMsg) {};

    // Trigger invokes the workload's trigger. It could be ping, start client/server etc..
    rpc Trigger(TriggerMsg) returns (TriggerMsg) {};

    // CheckClusterHealth returns the cluster health
    rpc CheckClusterHealth(NodeMsg) returns  (ClusterHealthMsg) {};

    // WorkloadCopy copies files in/out from workload
    rpc WorkloadCopy(WorkloadCopyMsg) returns  (WorkloadCopyMsg) {};
}

// Op defines topology operation
enum Op {
        NONE    = 0;
        ADD     = 1;
        DELETE  = 2;
        GET     = 3;
}

// NodeInfo encapsulates all topology information for a given iota-server invocation
message NodeMsg {
    // API Response for the node
    IotaAPIResponse api_response    = 1;

    // Node operation
    Op node_op                      = 2;

    // List of nodes in the e2e cluster
    repeated Node nodes             = 3;

    // Set this to true during init time. This will essentially brings up the e2e cluster
    bool make_cluster               = 4;
}

enum PersonalityType {
    PERSONALITY_NONE                    = 0;
    PERSONALITY_NAPLES_SIM              = 1;
    PERSONALITY_VENICE                  = 2;
    PERSONALITY_NAPLES_SIM_WITH_QEMU    = 3;
    // Naples Hardware
    PERSONALITY_NAPLES                  = 4;
    PERSONALITY_MELLANOX                = 5;
}

// Node captures personality details of an E2E node
message Node {
    // PersonalityType captures the node personality. naples node, venice node or qemu
    PersonalityType     type            = 1;

    // Image captures the the built artifacts that need to be loaded on the node depending on the personality type
    string              image           = 2;

    // IP Address of the node
    string              ip_address      = 3;

    // Node identifier
    string              name            = 4;

    // Node specific configs
    oneof node_info {
        // naples
        NaplesConfig    naples_config  = 5;

        VeniceConfig    venice_config  = 6;
    }

    // NodeStatus captures the details of the node action
    IotaAPIResponse     node_status    = 7;

    string              node_uuid      = 8;
}


message NaplesConfig {

    // Control interface to use
    string control_intf          = 1;

    // Control ip to use
    string control_ip            = 2;

    // Data interfaces to use
    repeated string data_intfs   = 3;

    // Venice IPs to use, if specified agent will come up im managed mode.
    repeated string venice_ips   = 4;

    // host intfs , returned as part of add node
    repeated string host_intfs   = 5;
}

message VenicePeer {

    // hostname of peer node
    string  host_name   = 1;

    // ip of the peer node
    string  ip_address  = 2;
}

message VeniceConfig {

    // Control interface to use
    string control_intf               = 1;

    // Control ip to use
    string control_ip                 = 2;

    // Peers to add host name entries.
    repeated VenicePeer venice_peers  = 3;

}


message WorkloadMsg{
    // API Response
    IotaAPIResponse api_response        = 1;

    // Workload Operation Type
    Op workload_op                      = 2;

    // List of workloads
    repeated Workload workloads         = 3;

}


enum InterfaceType {
    INTERFACE_TYPE_NONE  = 0;
    INTERFACE_TYPE_VSS   = 1;
    INTERFACE_TYPE_SRIOV = 2;
}

message Workload {
    // Workload Identifier
    string workload_name                    = 1;

    // Node on which this needs to be spun up
    string node_name                        = 2;

    // Data VLAN for the workload
    uint32 encap_vlan                       = 3;

    // IPAddress of the workload. Represent this as a CIDR block. 10.0.0.1/16 will be
    // interpreted as 10.0.0.1 is the IP of the workload container and it belongs to a /16 subnet.
    string ip_address                       = 4;

    // MAC Address of the workload
    string mac_address                      = 5;

    // Interface to which workload needs to be attached.
    string interface                        = 6;

    InterfaceType interface_type            = 7;

    // Interface to which workload needs to be attached.
    uint32 pinned_port                      = 8;

    // uplink vlan for the traffic going outside node.
    uint32 uplink_vlan                      = 9;

    // Workload Status
    IotaAPIResponse workload_status         = 10;
}

enum TriggerOp {
    TYPE_NONE           = 0;
    EXEC_CMDS           = 3;
    TERMINATE_ALL_CMDS  = 4;
}

enum TriggerMode {
    MODE_NONE           = 0;
    TRIGGER_SERIAL      = 1;
    TRIGGER_PARALLEL    = 2;
}


message TriggerMsg {
    //API Status
    IotaAPIResponse api_response            = 1;

    // Type of the trigger operation
    TriggerOp trigger_op                    = 2;

    // Trigger mode specifies whether commands have to be
    // executed serially or in parallel
    TriggerMode trigger_mode                = 3;

    // Command Request params
    repeated Command    commands            = 4;
}

enum CommandMode {
    COMMAND_NONE        = 0;
    COMMAND_FOREGROUND  = 1;
    COMMAND_BACKGROUND  = 2;
}
message Command {
    // Whether to run the command in foreground or background
    CommandMode     mode            = 1;

    // Fully qualified command line that needs to be called
    string          command         = 2;

    // Node on which trigger needs to be executed
    string          node_name       = 3;

    // Workload name of the command
    string          workload_name   = 4;

    // ================ Output Parameters ===================
    // StdOut of the comamnd
    string          stdout          = 5;

    // StdErr of the command
    string          stderr          = 6;

    // Exit code of the command
    int32          exit_code        = 7;

    // command handle. Useful only for background commands
    string          handle          = 8;

}

// Captures the overall health of the e2e cluster
message ClusterHealthMsg {
    IotaAPIResponse api_response    = 1;
    // Individual node health statuses
    repeated NodeHealth health      = 2;
}


message NodeHealth {
    enum HealthCode {
        HEALTH_OK       = 0;
        NAPLES_DOWN     = 1;
        NODE_DOWN       = 2;
        APP_DOWN        = 3;
        NOT_PROVISIONED = 4;
    }
    // Name of the node
    string  node_name        = 1;

    // Health code of the node
    HealthCode health_code   = 2;
}

message TestBedMsg {
    // API Response
    IotaAPIResponse api_response        = 1;

    // NAPLES tarball to copy on the remote nodes
    string naples_image                 = 2;

    // Venice tarball to copy on the remote nodes
    string venice_image                 = 3;

    // Driver sources to copy on the remote nodes
    string driver_sources               = 4;

    // Allocated vlans based off of the port id
    repeated uint32 allocated_vlans     = 5;

    // List of node IP addresses
    repeated TestBedNode nodes          = 6;

    // Node username
    string username                     = 7;

    // Node password
    string password                     = 8;

    // Testbed ID
    uint32 testbed_id                   = 9;
}

enum TestBedNodeType {
    TESTBED_NODE_TYPE_NONE  = 0;
    TESTBED_NODE_TYPE_SIM   = 1;
    TESTBED_NODE_TYPE_HW    = 2;
}

message TestBedNode {
    TestBedNodeType type            = 1;
    // Node Management IP Address
    string ip_address               = 2;
    // Node CIMC IP Address
    string cimc_ip_address          = 3;
    // Node CIMC username
    string cimc_username            = 4;
    // Node CIMC password
    string cimc_password            = 5;
    // NIC Management IP Address
    string nic_ip_address           = 6;
    // NIC Console ip address
    string nic_console_ip_address   = 7;
    // NIC Console port
    string nic_console_port         = 8;
    // NIC Console username
    string nic_console_username     = 9;
    // NIC Console password
    string nic_console_password     = 10;
    // NIC username
    string nic_username             = 11;
    // NIC password
    string nic_password             = 12;
    // Initialization script - used for HW
    string init_script              = 13;
    // Control interface for this node.
    string control_intf             = 14;
    // Switch ports for this node.
    repeated uint32 switch_port_ids = 15;
}

// WorkloadCopyDirection defines direction whether to copy in or copy out
enum WorkloadCopyDirection {
        DIR_NONE    = 0;
        DIR_IN      = 1;
        DIR_OUT     = 2;
}

// WorkloadCopyMsg takes care of copying to workload.
// If copy in to workload, destination will be prefixed with workload directory on iota node.
// if copy out from workload, files will be prefixed with workload directory on iota node.
message WorkloadCopyMsg {
    // API Response for the copy operation
    IotaAPIResponse api_response    = 1;

    // Copy Direction.
    WorkloadCopyDirection direction = 2;

    // Node to do copy operation
    string node_name                = 3;

    // workload context to do copy operation
    string workload                 = 4;

    // list of files that needs to be copied
    repeated string files           = 5;

    // destination directory
    string dest_dir                 = 6;
}
