// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: req_types.proto

package iotamodel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ConfigTopologyInfo_EntrypointType int32

const (
	ConfigTopologyInfo_ENTRYPOINT_NONE ConfigTopologyInfo_EntrypointType = 0
	ConfigTopologyInfo_NAPLES_REST     ConfigTopologyInfo_EntrypointType = 1
	ConfigTopologyInfo_VENICE_REST     ConfigTopologyInfo_EntrypointType = 2
)

var ConfigTopologyInfo_EntrypointType_name = map[int32]string{
	0: "ENTRYPOINT_NONE",
	1: "NAPLES_REST",
	2: "VENICE_REST",
}
var ConfigTopologyInfo_EntrypointType_value = map[string]int32{
	"ENTRYPOINT_NONE": 0,
	"NAPLES_REST":     1,
	"VENICE_REST":     2,
}

func (x ConfigTopologyInfo_EntrypointType) String() string {
	return proto.EnumName(ConfigTopologyInfo_EntrypointType_name, int32(x))
}
func (ConfigTopologyInfo_EntrypointType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorReqTypes, []int{0, 0}
}

type App_Type int32

const (
	App_APP_NONE App_Type = 0
	App_RAW_PKT  App_Type = 1
	App_CMD_APP  App_Type = 2
)

var App_Type_name = map[int32]string{
	0: "APP_NONE",
	1: "RAW_PKT",
	2: "CMD_APP",
}
var App_Type_value = map[string]int32{
	"APP_NONE": 0,
	"RAW_PKT":  1,
	"CMD_APP":  2,
}

func (x App_Type) String() string {
	return proto.EnumName(App_Type_name, int32(x))
}
func (App_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{1, 0} }

type Command_CmdType int32

const (
	Command_COMMAND_NONE       Command_CmdType = 0
	Command_COMMAND_FOREGROUND Command_CmdType = 1
	Command_COMMAND_BACKGROUND Command_CmdType = 2
)

var Command_CmdType_name = map[int32]string{
	0: "COMMAND_NONE",
	1: "COMMAND_FOREGROUND",
	2: "COMMAND_BACKGROUND",
}
var Command_CmdType_value = map[string]int32{
	"COMMAND_NONE":       0,
	"COMMAND_FOREGROUND": 1,
	"COMMAND_BACKGROUND": 2,
}

func (x Command_CmdType) String() string {
	return proto.EnumName(Command_CmdType_name, int32(x))
}
func (Command_CmdType) EnumDescriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{2, 0} }

type Node_Type int32

const (
	Node_PERSONALITY_NONE             Node_Type = 0
	Node_PERSONALITY_NAPLES           Node_Type = 1
	Node_PERSONALITY_VENICE           Node_Type = 2
	Node_PERSONALITY_NAPLES_WITH_QEMU Node_Type = 3
)

var Node_Type_name = map[int32]string{
	0: "PERSONALITY_NONE",
	1: "PERSONALITY_NAPLES",
	2: "PERSONALITY_VENICE",
	3: "PERSONALITY_NAPLES_WITH_QEMU",
}
var Node_Type_value = map[string]int32{
	"PERSONALITY_NONE":             0,
	"PERSONALITY_NAPLES":           1,
	"PERSONALITY_VENICE":           2,
	"PERSONALITY_NAPLES_WITH_QEMU": 3,
}

func (x Node_Type) String() string {
	return proto.EnumName(Node_Type_name, int32(x))
}
func (Node_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{3, 0} }

// ConfigTopologyInfo encapsulates all topology information for a given iota invocation
type ConfigTopologyInfo struct {
	// ConfigEntrypoint captures what object model configs to generate for a given testbed.
	// Could either be venice object model or Agent object model
	ConfigEntrypoint string `protobuf:"bytes,1,opt,name=ConfigEntrypoint,proto3" json:"config-entrypoint,omitempty"`
	// RESTEndpoint to push the generated configs to
	RestEndpoint string `protobuf:"bytes,2,opt,name=RestEndpoint,proto3" json:"naples-rest-endpoint, omitempty"`
	// Nodes in the topology
	Nodes []*Node `protobuf:"bytes,3,rep,name=Nodes" json:"nodes,omitempty"`
	// VLANs for the testbed
	VLANs []uint32 `protobuf:"varint,4,rep,packed,name=VLANs" json:"vlans,omitempty"`
}

func (m *ConfigTopologyInfo) Reset()                    { *m = ConfigTopologyInfo{} }
func (m *ConfigTopologyInfo) String() string            { return proto.CompactTextString(m) }
func (*ConfigTopologyInfo) ProtoMessage()               {}
func (*ConfigTopologyInfo) Descriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{0} }

func (m *ConfigTopologyInfo) GetConfigEntrypoint() string {
	if m != nil {
		return m.ConfigEntrypoint
	}
	return ""
}

func (m *ConfigTopologyInfo) GetRestEndpoint() string {
	if m != nil {
		return m.RestEndpoint
	}
	return ""
}

func (m *ConfigTopologyInfo) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ConfigTopologyInfo) GetVLANs() []uint32 {
	if m != nil {
		return m.VLANs
	}
	return nil
}

type App struct {
	// AppType captures the workload type. Currently two categories are supported RAW_PKT which supports packet tx and rx
	// and CommandType which can run a command natively on the node. iPerf and the like
	AppType string `protobuf:"bytes,1,opt,name=AppType,proto3" json:"app-type,omitempty"`
	// AppConfig is arguments to the app
	AppConfig string `protobuf:"bytes,2,opt,name=AppConfig,proto3" json:"app-config,omitempty"`
	// Command that needs to be run on an app
	AppCommand *Command `protobuf:"bytes,3,opt,name=AppCommand" json:"app-command,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{1} }

func (m *App) GetAppType() string {
	if m != nil {
		return m.AppType
	}
	return ""
}

func (m *App) GetAppConfig() string {
	if m != nil {
		return m.AppConfig
	}
	return ""
}

func (m *App) GetAppCommand() *Command {
	if m != nil {
		return m.AppCommand
	}
	return nil
}

type Command struct {
	// CommandType captures the App command type. Whether it should be run in foreground or in background
	CommandType string `protobuf:"bytes,1,opt,name=CommandType,proto3" json:"command-type,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{2} }

func (m *Command) GetCommandType() string {
	if m != nil {
		return m.CommandType
	}
	return ""
}

type Node struct {
	// PersonalityType captures the node personality. naples node, venice node or qemu
	PersonalityType string `protobuf:"bytes,1,opt,name=PersonalityType,proto3" json:"personality-type,omitempty"`
	// Image captures the the built artifacts that need to be loaded on the node depending on the personality type
	Image string `protobuf:"bytes,2,opt,name=Image,proto3" json:"image,omitempty"`
	// IP Address of the node
	IPAddress string `protobuf:"bytes,3,opt,name=IPAddress,proto3" json:"ip-address,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorReqTypes, []int{3} }

func (m *Node) GetPersonalityType() string {
	if m != nil {
		return m.PersonalityType
	}
	return ""
}

func (m *Node) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Node) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*ConfigTopologyInfo)(nil), "iotamodel.ConfigTopologyInfo")
	proto.RegisterType((*App)(nil), "iotamodel.App")
	proto.RegisterType((*Command)(nil), "iotamodel.Command")
	proto.RegisterType((*Node)(nil), "iotamodel.Node")
	proto.RegisterEnum("iotamodel.ConfigTopologyInfo_EntrypointType", ConfigTopologyInfo_EntrypointType_name, ConfigTopologyInfo_EntrypointType_value)
	proto.RegisterEnum("iotamodel.App_Type", App_Type_name, App_Type_value)
	proto.RegisterEnum("iotamodel.Command_CmdType", Command_CmdType_name, Command_CmdType_value)
	proto.RegisterEnum("iotamodel.Node_Type", Node_Type_name, Node_Type_value)
}
func (m *ConfigTopologyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigTopologyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConfigEntrypoint) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.ConfigEntrypoint)))
		i += copy(dAtA[i:], m.ConfigEntrypoint)
	}
	if len(m.RestEndpoint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.RestEndpoint)))
		i += copy(dAtA[i:], m.RestEndpoint)
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintReqTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VLANs) > 0 {
		dAtA2 := make([]byte, len(m.VLANs)*10)
		var j1 int
		for _, num := range m.VLANs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.AppType)))
		i += copy(dAtA[i:], m.AppType)
	}
	if len(m.AppConfig) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.AppConfig)))
		i += copy(dAtA[i:], m.AppConfig)
	}
	if m.AppCommand != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(m.AppCommand.Size()))
		n3, err := m.AppCommand.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommandType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.CommandType)))
		i += copy(dAtA[i:], m.CommandType)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PersonalityType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.PersonalityType)))
		i += copy(dAtA[i:], m.PersonalityType)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReqTypes(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	return i, nil
}

func encodeVarintReqTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConfigTopologyInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConfigEntrypoint)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	l = len(m.RestEndpoint)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovReqTypes(uint64(l))
		}
	}
	if len(m.VLANs) > 0 {
		l = 0
		for _, e := range m.VLANs {
			l += sovReqTypes(uint64(e))
		}
		n += 1 + sovReqTypes(uint64(l)) + l
	}
	return n
}

func (m *App) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppType)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	l = len(m.AppConfig)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	if m.AppCommand != nil {
		l = m.AppCommand.Size()
		n += 1 + l + sovReqTypes(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommandType)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.PersonalityType)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovReqTypes(uint64(l))
	}
	return n
}

func sovReqTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozReqTypes(x uint64) (n int) {
	return sovReqTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConfigTopologyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReqTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigTopologyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigTopologyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigEntrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigEntrypoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReqTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VLANs = append(m.VLANs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReqTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReqTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReqTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VLANs = append(m.VLANs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReqTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReqTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReqTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppCommand == nil {
				m.AppCommand = &Command{}
			}
			if err := m.AppCommand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReqTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReqTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReqTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReqTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReqTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReqTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalityType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalityType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReqTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReqTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReqTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReqTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReqTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReqTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthReqTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReqTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReqTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReqTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReqTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("req_types.proto", fileDescriptorReqTypes) }

var fileDescriptorReqTypes = []byte{
	// 751 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x54, 0x4f, 0x6f, 0xda, 0x48,
	0x1c, 0x8d, 0x4d, 0xb2, 0x6c, 0x06, 0x76, 0xf1, 0x4e, 0xb2, 0x11, 0xb0, 0x11, 0x20, 0xef, 0x1e,
	0x88, 0x36, 0xd8, 0x52, 0x5a, 0xe5, 0xd0, 0x9b, 0x21, 0x2e, 0x45, 0x09, 0xc6, 0x35, 0x24, 0x69,
	0x2e, 0x45, 0x0e, 0x9e, 0xb8, 0x96, 0xec, 0x99, 0x29, 0x36, 0xa9, 0xb8, 0xb6, 0x12, 0x9f, 0xa1,
	0x9f, 0x81, 0x53, 0xaf, 0xfd, 0x06, 0x3d, 0xf6, 0x13, 0xa0, 0x2a, 0xbd, 0xf1, 0x29, 0x2a, 0xff,
	0x83, 0x21, 0xb9, 0x79, 0xde, 0xbc, 0xf7, 0x9b, 0xc7, 0x7b, 0x3f, 0x01, 0x0a, 0x63, 0xf4, 0x7e,
	0x18, 0x4c, 0x29, 0xf2, 0x25, 0x3a, 0x26, 0x01, 0x81, 0xbb, 0x0e, 0x09, 0x4c, 0x8f, 0x58, 0xc8,
	0x2d, 0x1f, 0xda, 0x84, 0xd8, 0x2e, 0x92, 0x4d, 0xea, 0xc8, 0x26, 0xc6, 0x24, 0x30, 0x03, 0x87,
	0xe0, 0x84, 0x58, 0x6e, 0xd8, 0x4e, 0xf0, 0x6e, 0x72, 0x2b, 0x8d, 0x88, 0x27, 0xdb, 0xc4, 0x26,
	0x72, 0x04, 0xdf, 0x4e, 0xee, 0xa2, 0x53, 0x74, 0x88, 0xbe, 0x12, 0xba, 0xca, 0xd0, 0x29, 0xc2,
	0xbe, 0x89, 0x2d, 0x22, 0xfb, 0x1f, 0xe4, 0x7b, 0x84, 0x9d, 0x11, 0x92, 0x27, 0x81, 0xe3, 0xfa,
	0xe1, 0x4b, 0x36, 0xc2, 0xec, 0x63, 0xb2, 0x83, 0x47, 0xee, 0xc4, 0x4a, 0xed, 0x95, 0xf3, 0x23,
	0xe2, 0x79, 0x04, 0xc7, 0x27, 0xf1, 0x63, 0x06, 0xc0, 0x16, 0xc1, 0x77, 0x8e, 0x3d, 0x20, 0x94,
	0xb8, 0xc4, 0x9e, 0x76, 0xf0, 0x1d, 0x81, 0x3e, 0x10, 0x62, 0x54, 0xc5, 0xc1, 0x78, 0x4a, 0x89,
	0x83, 0x83, 0x22, 0x57, 0xe3, 0xea, 0xbb, 0xcd, 0xf6, 0x7c, 0x56, 0xfa, 0xaf, 0x1f, 0x8c, 0x55,
	0x3c, 0xf1, 0xea, 0xac, 0x46, 0x5a, 0x53, 0x07, 0x53, 0x8a, 0x8e, 0x96, 0x8b, 0xea, 0x3f, 0xa3,
	0x68, 0x46, 0x03, 0xad, 0x6e, 0x8e, 0x89, 0xe7, 0x04, 0xc8, 0xa3, 0xc1, 0xd4, 0x78, 0xf2, 0x00,
	0x6c, 0x83, 0xbc, 0x81, 0xfc, 0x40, 0xc5, 0x56, 0xfc, 0x20, 0x1f, 0x3d, 0xf8, 0xef, 0x72, 0x51,
	0xad, 0x62, 0x93, 0xba, 0xc8, 0x6f, 0x8c, 0x91, 0x1f, 0x34, 0x50, 0x72, 0x7f, 0x5c, 0x5b, 0x0f,
	0xdb, 0x10, 0xc2, 0x17, 0x60, 0x47, 0x23, 0x16, 0xf2, 0x8b, 0x99, 0x5a, 0xa6, 0x9e, 0x3b, 0x29,
	0x48, 0xab, 0x46, 0xa4, 0x10, 0x6f, 0xee, 0x2d, 0x17, 0xd5, 0x02, 0x0e, 0x19, 0x8c, 0x9f, 0x58,
	0x02, 0x8f, 0xc0, 0xce, 0xd5, 0x85, 0xa2, 0xf9, 0xc5, 0xed, 0x5a, 0xa6, 0xfe, 0x47, 0x4c, 0xbd,
	0x77, 0x4d, 0xbc, 0x41, 0x8d, 0x18, 0x62, 0x1b, 0xfc, 0xb9, 0xf9, 0x9b, 0xe1, 0x1e, 0x28, 0xa8,
	0xda, 0xc0, 0xb8, 0xd1, 0x7b, 0x1d, 0x6d, 0x30, 0xd4, 0x7a, 0x9a, 0x2a, 0x6c, 0xc1, 0x02, 0xc8,
	0x69, 0x8a, 0x7e, 0xa1, 0xf6, 0x87, 0x86, 0xda, 0x1f, 0x08, 0x5c, 0x08, 0x5c, 0xa9, 0x5a, 0xa7,
	0xa5, 0xc6, 0x00, 0x2f, 0x7e, 0xe2, 0x41, 0x46, 0xa1, 0x14, 0xaa, 0x20, 0xab, 0x50, 0x1a, 0x4e,
	0x4a, 0xc2, 0xfe, 0x7f, 0x3e, 0x2b, 0xfd, 0x95, 0x86, 0xad, 0x50, 0x2a, 0xa5, 0xc9, 0x42, 0x93,
	0xd2, 0x46, 0xb8, 0x74, 0x8c, 0xab, 0x54, 0x0b, 0x4f, 0xc1, 0xae, 0x42, 0x69, 0x1c, 0x6f, 0x12,
	0x62, 0x71, 0xb9, 0xa8, 0xee, 0x87, 0x9a, 0xb8, 0x11, 0x46, 0xb5, 0xa6, 0xc2, 0x2e, 0x00, 0xd1,
	0xc1, 0xf3, 0x4c, 0x6c, 0x15, 0x33, 0x35, 0xae, 0x9e, 0x3b, 0x81, 0x4c, 0x76, 0xc9, 0x4d, 0xb3,
	0xb4, 0x5c, 0x54, 0xff, 0x8e, 0x87, 0x45, 0x00, 0x33, 0x8d, 0x19, 0x20, 0x4a, 0x60, 0x3b, 0xb2,
	0x93, 0x07, 0xbf, 0x2b, 0xba, 0x9e, 0xa6, 0x91, 0x03, 0x59, 0x43, 0xb9, 0x1e, 0xea, 0xe7, 0x61,
	0x12, 0x39, 0x90, 0x6d, 0x75, 0xcf, 0x86, 0x8a, 0xae, 0x0b, 0xbc, 0xf8, 0x85, 0x03, 0xd9, 0x44,
	0x0b, 0xdf, 0x80, 0x5c, 0xf2, 0xc9, 0xa4, 0x71, 0x3a, 0x9f, 0x95, 0x8a, 0x69, 0x1a, 0xc9, 0xb5,
	0xd4, 0xf2, 0xac, 0x34, 0x94, 0x83, 0xc4, 0xcf, 0xe3, 0x60, 0xd8, 0x51, 0xe2, 0x39, 0xc8, 0x26,
	0x12, 0x28, 0x80, 0x7c, 0xab, 0xd7, 0xed, 0x2a, 0xda, 0x59, 0x6a, 0xee, 0x00, 0xc0, 0x14, 0x79,
	0xd9, 0x33, 0xd4, 0xb6, 0xd1, 0xbb, 0xd4, 0xce, 0x04, 0x8e, 0xc5, 0x9b, 0x4a, 0xeb, 0x3c, 0xc1,
	0x79, 0xf1, 0x2b, 0x0f, 0xb6, 0xc3, 0xb5, 0x81, 0x6f, 0x41, 0x41, 0x47, 0x63, 0x9f, 0x60, 0xd3,
	0x75, 0x82, 0x29, 0xe3, 0xf9, 0xf9, 0x7c, 0x56, 0x82, 0xa9, 0xe7, 0x90, 0xba, 0xaa, 0xb0, 0x4c,
	0xd7, 0x82, 0xc7, 0x8e, 0x1f, 0x0f, 0x0b, 0xb7, 0xb2, 0xe3, 0x99, 0x36, 0x4a, 0xea, 0x8c, 0xb6,
	0xd2, 0x09, 0x01, 0x76, 0x2b, 0x23, 0x46, 0xd8, 0x7e, 0x47, 0x57, 0x2c, 0x6b, 0x8c, 0x7c, 0x3f,
	0x2a, 0x31, 0x69, 0xdf, 0xa1, 0x0d, 0x33, 0x46, 0xd9, 0xf6, 0x57, 0x54, 0x11, 0x27, 0x75, 0xed,
	0x03, 0x41, 0x57, 0x8d, 0x7e, 0x4f, 0x53, 0x2e, 0x3a, 0x83, 0x1b, 0x26, 0x99, 0x0d, 0x34, 0x5a,
	0xe8, 0x38, 0x19, 0x16, 0x8f, 0xf7, 0x5a, 0xe0, 0x61, 0x0d, 0x1c, 0x3e, 0xe5, 0x0f, 0xaf, 0x3b,
	0x83, 0x57, 0xc3, 0xd7, 0x6a, 0xf7, 0x52, 0xc8, 0x34, 0x85, 0x6f, 0x0f, 0x15, 0xee, 0xfb, 0x43,
	0x85, 0xfb, 0xf1, 0x50, 0xe1, 0x3e, 0xff, 0xac, 0x6c, 0xe9, 0xfc, 0xed, 0x6f, 0xd1, 0x9f, 0xd2,
	0xb3, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x62, 0x2c, 0x8c, 0x54, 0x05, 0x00, 0x00,
}
