// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: topo_svc.proto

package iotamodel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of ConfigTopologyInfo from req_types.proto

// Ignoring public import of App from req_types.proto

// Ignoring public import of Command from req_types.proto

// Ignoring public import of Node from req_types.proto

// Ignoring public import of EntrypointType from req_types.proto

// Ignoring public import of Type from req_types.proto

// Ignoring public import of CmdType from req_types.proto

// Ignoring public import of Type from req_types.proto

// Ignoring public import of IotaAPIResponse from resp_types.proto

// Ignoring public import of ClusterHealthResponse from resp_types.proto

// Ignoring public import of NodeStatus from resp_types.proto

// Ignoring public import of InstantiateAppResponse from resp_types.proto

// Ignoring public import of InstantiateTopoResponse from resp_types.proto

// Ignoring public import of AddNodeResponse from resp_types.proto

// Ignoring public import of GeneratedConfigResponse from resp_types.proto

// Ignoring public import of ConfigPushResponse from resp_types.proto

// Ignoring public import of TriggerAppResponse from resp_types.proto

// Ignoring public import of APIResponseType from resp_types.proto

// Ignoring public import of HealthCodeType from resp_types.proto

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TopologyApi service

type TopologyApiClient interface {
	// InstantiateTopology is called by harness which assigns a personality to the node based on the topology.
	// This is a blocking call to the harness, The parallel instantiation across the nodes is handled internally.
	InstantiateTopology(ctx context.Context, in *ConfigTopologyInfo, opts ...grpc.CallOption) (*InstantiateTopoResponse, error)
	// InstantiateApps creates a app on the specified node.
	InstantiateApps(ctx context.Context, in *App, opts ...grpc.CallOption) (*InstantiateAppResponse, error)
	// AddNode adds a node to the current topology
	AddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*AddNodeResponse, error)
	// Trigger calls the trigger function of the app.
	TriggerApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*TriggerAppResponse, error)
	// Harness queries cluster health prior to running a test case
	CheckClusterHealth(ctx context.Context, in *ConfigTopologyInfo, opts ...grpc.CallOption) (*ClusterHealthResponse, error)
}

type topologyApiClient struct {
	cc *grpc.ClientConn
}

func NewTopologyApiClient(cc *grpc.ClientConn) TopologyApiClient {
	return &topologyApiClient{cc}
}

func (c *topologyApiClient) InstantiateTopology(ctx context.Context, in *ConfigTopologyInfo, opts ...grpc.CallOption) (*InstantiateTopoResponse, error) {
	out := new(InstantiateTopoResponse)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/InstantiateTopology", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) InstantiateApps(ctx context.Context, in *App, opts ...grpc.CallOption) (*InstantiateAppResponse, error) {
	out := new(InstantiateAppResponse)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/InstantiateApps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) AddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*AddNodeResponse, error) {
	out := new(AddNodeResponse)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/AddNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) TriggerApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*TriggerAppResponse, error) {
	out := new(TriggerAppResponse)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/TriggerApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) CheckClusterHealth(ctx context.Context, in *ConfigTopologyInfo, opts ...grpc.CallOption) (*ClusterHealthResponse, error) {
	out := new(ClusterHealthResponse)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/CheckClusterHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TopologyApi service

type TopologyApiServer interface {
	// InstantiateTopology is called by harness which assigns a personality to the node based on the topology.
	// This is a blocking call to the harness, The parallel instantiation across the nodes is handled internally.
	InstantiateTopology(context.Context, *ConfigTopologyInfo) (*InstantiateTopoResponse, error)
	// InstantiateApps creates a app on the specified node.
	InstantiateApps(context.Context, *App) (*InstantiateAppResponse, error)
	// AddNode adds a node to the current topology
	AddNode(context.Context, *Node) (*AddNodeResponse, error)
	// Trigger calls the trigger function of the app.
	TriggerApp(context.Context, *App) (*TriggerAppResponse, error)
	// Harness queries cluster health prior to running a test case
	CheckClusterHealth(context.Context, *ConfigTopologyInfo) (*ClusterHealthResponse, error)
}

func RegisterTopologyApiServer(s *grpc.Server, srv TopologyApiServer) {
	s.RegisterService(&_TopologyApi_serviceDesc, srv)
}

func _TopologyApi_InstantiateTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigTopologyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).InstantiateTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/InstantiateTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).InstantiateTopology(ctx, req.(*ConfigTopologyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_InstantiateApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).InstantiateApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/InstantiateApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).InstantiateApps(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_AddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).AddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/AddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).AddNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_TriggerApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).TriggerApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/TriggerApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).TriggerApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_CheckClusterHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigTopologyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).CheckClusterHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/CheckClusterHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).CheckClusterHealth(ctx, req.(*ConfigTopologyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _TopologyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "iotamodel.TopologyApi",
	HandlerType: (*TopologyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InstantiateTopology",
			Handler:    _TopologyApi_InstantiateTopology_Handler,
		},
		{
			MethodName: "InstantiateApps",
			Handler:    _TopologyApi_InstantiateApps_Handler,
		},
		{
			MethodName: "AddNode",
			Handler:    _TopologyApi_AddNode_Handler,
		},
		{
			MethodName: "TriggerApp",
			Handler:    _TopologyApi_TriggerApp_Handler,
		},
		{
			MethodName: "CheckClusterHealth",
			Handler:    _TopologyApi_CheckClusterHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "topo_svc.proto",
}

func init() { proto.RegisterFile("topo_svc.proto", fileDescriptorTopoSvc) }

var fileDescriptorTopoSvc = []byte{
	// 311 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xbf, 0x4a, 0x33, 0x41,
	0x14, 0xc5, 0x93, 0x2f, 0xf0, 0x89, 0x23, 0x24, 0x61, 0xec, 0x16, 0x5d, 0x34, 0xbd, 0xbb, 0xa0,
	0x8d, 0x8d, 0xc5, 0x1a, 0x10, 0xd3, 0x48, 0x90, 0x80, 0x60, 0x13, 0x26, 0xd9, 0x9b, 0xc9, 0xe0,
	0x66, 0xee, 0x75, 0xe7, 0x46, 0x48, 0xed, 0x4b, 0xf8, 0x48, 0x96, 0x3e, 0x82, 0xc4, 0x17, 0x11,
	0x37, 0xc6, 0x5c, 0x54, 0xb0, 0x9b, 0x7b, 0xce, 0xf9, 0x9d, 0xf9, 0xa7, 0x9a, 0x8c, 0x84, 0xc3,
	0xf0, 0x30, 0x4e, 0xa8, 0x44, 0x46, 0xbd, 0xed, 0x90, 0xcd, 0x0c, 0x73, 0x28, 0xa2, 0x3d, 0x8b,
	0x68, 0x0b, 0x48, 0x0d, 0xb9, 0xd4, 0x78, 0x8f, 0x6c, 0xd8, 0xa1, 0x0f, 0xab, 0x60, 0x74, 0x64,
	0x1d, 0x4f, 0xe7, 0xa3, 0x64, 0x8c, 0xb3, 0xd4, 0xa2, 0xc5, 0xb4, 0x92, 0x47, 0xf3, 0x49, 0x35,
	0x55, 0x43, 0xb5, 0xfa, 0x8c, 0xb7, 0x4a, 0xb8, 0x1f, 0xf2, 0x82, 0x60, 0xcd, 0xb7, 0x4b, 0x08,
	0x24, 0x95, 0xe3, 0xc7, 0x86, 0xda, 0x19, 0x20, 0x61, 0x81, 0x76, 0x91, 0x91, 0xd3, 0xb7, 0x6a,
	0xb7, 0xe7, 0x03, 0x1b, 0xcf, 0xce, 0x30, 0xac, 0x1d, 0xbd, 0x9f, 0x7c, 0x1d, 0x31, 0xe9, 0xa2,
	0x9f, 0x38, 0xbb, 0xb6, 0x7a, 0x7e, 0x82, 0x51, 0x47, 0xd8, 0xdf, 0xf0, 0x6b, 0x08, 0x84, 0x3e,
	0x40, 0xa7, 0xa6, 0x2f, 0x54, 0x4b, 0x98, 0x19, 0x51, 0xd0, 0x4d, 0x01, 0x66, 0x44, 0xd1, 0xe1,
	0xef, 0x45, 0x19, 0x91, 0xe8, 0x39, 0x55, 0x5b, 0x59, 0x9e, 0x5f, 0x61, 0x0e, 0xba, 0x25, 0xf2,
	0x1f, 0x42, 0x14, 0xc9, 0xc2, 0x55, 0x48, 0x90, 0x67, 0x4a, 0x0d, 0x4a, 0x67, 0x2d, 0x94, 0x19,
	0xd1, 0x8f, 0xcd, 0xe5, 0x25, 0x37, 0x31, 0x81, 0xdf, 0x28, 0xdd, 0x9d, 0xc2, 0xf8, 0xae, 0x5b,
	0xcc, 0x03, 0x43, 0x79, 0x09, 0xa6, 0xe0, 0xe9, 0x5f, 0x6f, 0x73, 0x20, 0x6d, 0x09, 0x6e, 0x8a,
	0xcf, 0xdb, 0xcf, 0xcb, 0xb8, 0xfe, 0xb2, 0x8c, 0xeb, 0xaf, 0xcb, 0xb8, 0xfe, 0xf4, 0x16, 0xd7,
	0xfa, 0xff, 0xfa, 0x8d, 0xd1, 0xff, 0xea, 0x8b, 0x4e, 0xde, 0x03, 0x00, 0x00, 0xff, 0xff, 0xfc,
	0x90, 0x31, 0x27, 0x2f, 0x02, 0x00, 0x00,
}
