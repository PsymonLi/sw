// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: topo_svc.proto

package iotamodel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Op defines topology operation
type Op int32

const (
	Op_NONE   Op = 0
	Op_ADD    Op = 1
	Op_DELETE Op = 2
	Op_GET    Op = 3
)

var Op_name = map[int32]string{
	0: "NONE",
	1: "ADD",
	2: "DELETE",
	3: "GET",
}
var Op_value = map[string]int32{
	"NONE":   0,
	"ADD":    1,
	"DELETE": 2,
	"GET":    3,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}
func (Op) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{0} }

type PersonalityType int32

const (
	PersonalityType_PERSONALITY_NONE       PersonalityType = 0
	PersonalityType_PERSONALITY_NAPLES_SIM PersonalityType = 1
	// No datapath, just spin up multiple naples-sim for scale.
	PersonalityType_PERSONALITY_NAPLES_MULTI_SIM     PersonalityType = 2
	PersonalityType_PERSONALITY_VENICE               PersonalityType = 3
	PersonalityType_PERSONALITY_NAPLES_SIM_WITH_QEMU PersonalityType = 4
	// Naples Hardware
	PersonalityType_PERSONALITY_NAPLES      PersonalityType = 5
	PersonalityType_PERSONALITY_NAPLES_BITW PersonalityType = 6
	// Naples BITW model to run on one host for performance
	PersonalityType_PERSONALITY_NAPLES_BITW_PERF PersonalityType = 7
	PersonalityType_PERSONALITY_THIRD_PARTY_NIC  PersonalityType = 8
	PersonalityType_PERSONALITY_MELLANOX         PersonalityType = 9
	PersonalityType_PERSONALITY_BROADCOM         PersonalityType = 10
	PersonalityType_PERSONALITY_INTEL            PersonalityType = 11
	// Node just run commands
	PersonalityType_PERSONALITY_COMMAND_NODE PersonalityType = 12
)

var PersonalityType_name = map[int32]string{
	0:  "PERSONALITY_NONE",
	1:  "PERSONALITY_NAPLES_SIM",
	2:  "PERSONALITY_NAPLES_MULTI_SIM",
	3:  "PERSONALITY_VENICE",
	4:  "PERSONALITY_NAPLES_SIM_WITH_QEMU",
	5:  "PERSONALITY_NAPLES",
	6:  "PERSONALITY_NAPLES_BITW",
	7:  "PERSONALITY_NAPLES_BITW_PERF",
	8:  "PERSONALITY_THIRD_PARTY_NIC",
	9:  "PERSONALITY_MELLANOX",
	10: "PERSONALITY_BROADCOM",
	11: "PERSONALITY_INTEL",
	12: "PERSONALITY_COMMAND_NODE",
}
var PersonalityType_value = map[string]int32{
	"PERSONALITY_NONE":                 0,
	"PERSONALITY_NAPLES_SIM":           1,
	"PERSONALITY_NAPLES_MULTI_SIM":     2,
	"PERSONALITY_VENICE":               3,
	"PERSONALITY_NAPLES_SIM_WITH_QEMU": 4,
	"PERSONALITY_NAPLES":               5,
	"PERSONALITY_NAPLES_BITW":          6,
	"PERSONALITY_NAPLES_BITW_PERF":     7,
	"PERSONALITY_THIRD_PARTY_NIC":      8,
	"PERSONALITY_MELLANOX":             9,
	"PERSONALITY_BROADCOM":             10,
	"PERSONALITY_INTEL":                11,
	"PERSONALITY_COMMAND_NODE":         12,
}

func (x PersonalityType) String() string {
	return proto.EnumName(PersonalityType_name, int32(x))
}
func (PersonalityType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{1} }

type EntityType int32

const (
	EntityType_ENTITY_TYPE_NONE   EntityType = 0
	EntityType_ENTITY_TYPE_HOST   EntityType = 1
	EntityType_ENTITY_TYPE_NAPLES EntityType = 2
)

var EntityType_name = map[int32]string{
	0: "ENTITY_TYPE_NONE",
	1: "ENTITY_TYPE_HOST",
	2: "ENTITY_TYPE_NAPLES",
}
var EntityType_value = map[string]int32{
	"ENTITY_TYPE_NONE":   0,
	"ENTITY_TYPE_HOST":   1,
	"ENTITY_TYPE_NAPLES": 2,
}

func (x EntityType) String() string {
	return proto.EnumName(EntityType_name, int32(x))
}
func (EntityType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{2} }

type InterfaceType int32

const (
	InterfaceType_INTERFACE_TYPE_NONE  InterfaceType = 0
	InterfaceType_INTERFACE_TYPE_VSS   InterfaceType = 1
	InterfaceType_INTERFACE_TYPE_SRIOV InterfaceType = 2
)

var InterfaceType_name = map[int32]string{
	0: "INTERFACE_TYPE_NONE",
	1: "INTERFACE_TYPE_VSS",
	2: "INTERFACE_TYPE_SRIOV",
}
var InterfaceType_value = map[string]int32{
	"INTERFACE_TYPE_NONE":  0,
	"INTERFACE_TYPE_VSS":   1,
	"INTERFACE_TYPE_SRIOV": 2,
}

func (x InterfaceType) String() string {
	return proto.EnumName(InterfaceType_name, int32(x))
}
func (InterfaceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{3} }

type WorkloadType int32

const (
	WorkloadType_WORKLOAD_TYPE_NONE                      WorkloadType = 0
	WorkloadType_WORKLOAD_TYPE_CONTAINER                 WorkloadType = 1
	WorkloadType_WORKLOAD_TYPE_VM                        WorkloadType = 2
	WorkloadType_WORKLOAD_TYPE_BARE_METAL                WorkloadType = 3
	WorkloadType_WORKLOAD_TYPE_BARE_METAL_MAC_VLAN       WorkloadType = 4
	WorkloadType_WORKLOAD_TYPE_BARE_METAL_MAC_VLAN_ENCAP WorkloadType = 5
)

var WorkloadType_name = map[int32]string{
	0: "WORKLOAD_TYPE_NONE",
	1: "WORKLOAD_TYPE_CONTAINER",
	2: "WORKLOAD_TYPE_VM",
	3: "WORKLOAD_TYPE_BARE_METAL",
	4: "WORKLOAD_TYPE_BARE_METAL_MAC_VLAN",
	5: "WORKLOAD_TYPE_BARE_METAL_MAC_VLAN_ENCAP",
}
var WorkloadType_value = map[string]int32{
	"WORKLOAD_TYPE_NONE":                      0,
	"WORKLOAD_TYPE_CONTAINER":                 1,
	"WORKLOAD_TYPE_VM":                        2,
	"WORKLOAD_TYPE_BARE_METAL":                3,
	"WORKLOAD_TYPE_BARE_METAL_MAC_VLAN":       4,
	"WORKLOAD_TYPE_BARE_METAL_MAC_VLAN_ENCAP": 5,
}

func (x WorkloadType) String() string {
	return proto.EnumName(WorkloadType_name, int32(x))
}
func (WorkloadType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{4} }

type TriggerOp int32

const (
	TriggerOp_TYPE_NONE          TriggerOp = 0
	TriggerOp_EXEC_CMDS          TriggerOp = 3
	TriggerOp_TERMINATE_ALL_CMDS TriggerOp = 4
)

var TriggerOp_name = map[int32]string{
	0: "TYPE_NONE",
	3: "EXEC_CMDS",
	4: "TERMINATE_ALL_CMDS",
}
var TriggerOp_value = map[string]int32{
	"TYPE_NONE":          0,
	"EXEC_CMDS":          3,
	"TERMINATE_ALL_CMDS": 4,
}

func (x TriggerOp) String() string {
	return proto.EnumName(TriggerOp_name, int32(x))
}
func (TriggerOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{5} }

type TriggerMode int32

const (
	TriggerMode_MODE_NONE        TriggerMode = 0
	TriggerMode_TRIGGER_SERIAL   TriggerMode = 1
	TriggerMode_TRIGGER_PARALLEL TriggerMode = 2
	// Run commands on node in parallel.
	TriggerMode_TRIGGER_NODE_PARALLEL TriggerMode = 3
)

var TriggerMode_name = map[int32]string{
	0: "MODE_NONE",
	1: "TRIGGER_SERIAL",
	2: "TRIGGER_PARALLEL",
	3: "TRIGGER_NODE_PARALLEL",
}
var TriggerMode_value = map[string]int32{
	"MODE_NONE":             0,
	"TRIGGER_SERIAL":        1,
	"TRIGGER_PARALLEL":      2,
	"TRIGGER_NODE_PARALLEL": 3,
}

func (x TriggerMode) String() string {
	return proto.EnumName(TriggerMode_name, int32(x))
}
func (TriggerMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{6} }

type CommandMode int32

const (
	CommandMode_COMMAND_NONE       CommandMode = 0
	CommandMode_COMMAND_FOREGROUND CommandMode = 1
	CommandMode_COMMAND_BACKGROUND CommandMode = 2
)

var CommandMode_name = map[int32]string{
	0: "COMMAND_NONE",
	1: "COMMAND_FOREGROUND",
	2: "COMMAND_BACKGROUND",
}
var CommandMode_value = map[string]int32{
	"COMMAND_NONE":       0,
	"COMMAND_FOREGROUND": 1,
	"COMMAND_BACKGROUND": 2,
}

func (x CommandMode) String() string {
	return proto.EnumName(CommandMode_name, int32(x))
}
func (CommandMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{7} }

type SwitchOp int32

const (
	SwitchOp_OP_NONE       SwitchOp = 0
	SwitchOp_SHUT_PORTS    SwitchOp = 1
	SwitchOp_NO_SHUT_PORTS SwitchOp = 2
)

var SwitchOp_name = map[int32]string{
	0: "OP_NONE",
	1: "SHUT_PORTS",
	2: "NO_SHUT_PORTS",
}
var SwitchOp_value = map[string]int32{
	"OP_NONE":       0,
	"SHUT_PORTS":    1,
	"NO_SHUT_PORTS": 2,
}

func (x SwitchOp) String() string {
	return proto.EnumName(SwitchOp_name, int32(x))
}
func (SwitchOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{8} }

type TestBedNodeType int32

const (
	TestBedNodeType_TESTBED_NODE_TYPE_NONE TestBedNodeType = 0
	TestBedNodeType_TESTBED_NODE_TYPE_SIM  TestBedNodeType = 1
	TestBedNodeType_TESTBED_NODE_TYPE_HW   TestBedNodeType = 2
	// Run multiple sim on HW
	TestBedNodeType_TESTBED_NODE_TYPE_MULTI_SIM TestBedNodeType = 3
)

var TestBedNodeType_name = map[int32]string{
	0: "TESTBED_NODE_TYPE_NONE",
	1: "TESTBED_NODE_TYPE_SIM",
	2: "TESTBED_NODE_TYPE_HW",
	3: "TESTBED_NODE_TYPE_MULTI_SIM",
}
var TestBedNodeType_value = map[string]int32{
	"TESTBED_NODE_TYPE_NONE":      0,
	"TESTBED_NODE_TYPE_SIM":       1,
	"TESTBED_NODE_TYPE_HW":        2,
	"TESTBED_NODE_TYPE_MULTI_SIM": 3,
}

func (x TestBedNodeType) String() string {
	return proto.EnumName(TestBedNodeType_name, int32(x))
}
func (TestBedNodeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{9} }

type TestBedNodeOs int32

const (
	TestBedNodeOs_TESTBED_NODE_OS_LINUX   TestBedNodeOs = 0
	TestBedNodeOs_TESTBED_NODE_OS_FREEBSD TestBedNodeOs = 1
	TestBedNodeOs_TESTBED_NODE_OS_ESX     TestBedNodeOs = 2
)

var TestBedNodeOs_name = map[int32]string{
	0: "TESTBED_NODE_OS_LINUX",
	1: "TESTBED_NODE_OS_FREEBSD",
	2: "TESTBED_NODE_OS_ESX",
}
var TestBedNodeOs_value = map[string]int32{
	"TESTBED_NODE_OS_LINUX":   0,
	"TESTBED_NODE_OS_FREEBSD": 1,
	"TESTBED_NODE_OS_ESX":     2,
}

func (x TestBedNodeOs) String() string {
	return proto.EnumName(TestBedNodeOs_name, int32(x))
}
func (TestBedNodeOs) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{10} }

// CopyDirection defines direction whether to copy in or copy out
type CopyDirection int32

const (
	CopyDirection_DIR_NONE CopyDirection = 0
	CopyDirection_DIR_IN   CopyDirection = 1
	CopyDirection_DIR_OUT  CopyDirection = 2
)

var CopyDirection_name = map[int32]string{
	0: "DIR_NONE",
	1: "DIR_IN",
	2: "DIR_OUT",
}
var CopyDirection_value = map[string]int32{
	"DIR_NONE": 0,
	"DIR_IN":   1,
	"DIR_OUT":  2,
}

func (x CopyDirection) String() string {
	return proto.EnumName(CopyDirection_name, int32(x))
}
func (CopyDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{11} }

type NodeHealth_HealthCode int32

const (
	NodeHealth_HEALTH_OK       NodeHealth_HealthCode = 0
	NodeHealth_NAPLES_DOWN     NodeHealth_HealthCode = 1
	NodeHealth_NODE_DOWN       NodeHealth_HealthCode = 2
	NodeHealth_APP_DOWN        NodeHealth_HealthCode = 3
	NodeHealth_NOT_PROVISIONED NodeHealth_HealthCode = 4
)

var NodeHealth_HealthCode_name = map[int32]string{
	0: "HEALTH_OK",
	1: "NAPLES_DOWN",
	2: "NODE_DOWN",
	3: "APP_DOWN",
	4: "NOT_PROVISIONED",
}
var NodeHealth_HealthCode_value = map[string]int32{
	"HEALTH_OK":       0,
	"NAPLES_DOWN":     1,
	"NODE_DOWN":       2,
	"APP_DOWN":        3,
	"NOT_PROVISIONED": 4,
}

func (x NodeHealth_HealthCode) String() string {
	return proto.EnumName(NodeHealth_HealthCode_name, int32(x))
}
func (NodeHealth_HealthCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTopoSvc, []int{17, 0}
}

type DataSwitch_Speed int32

const (
	DataSwitch_Speed_100G DataSwitch_Speed = 0
	DataSwitch_Speed_10G  DataSwitch_Speed = 1
	DataSwitch_Speed_auto DataSwitch_Speed = 2
)

var DataSwitch_Speed_name = map[int32]string{
	0: "Speed_100G",
	1: "Speed_10G",
	2: "Speed_auto",
}
var DataSwitch_Speed_value = map[string]int32{
	"Speed_100G": 0,
	"Speed_10G":  1,
	"Speed_auto": 2,
}

func (x DataSwitch_Speed) String() string {
	return proto.EnumName(DataSwitch_Speed_name, int32(x))
}
func (DataSwitch_Speed) EnumDescriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{18, 0} }

// NodeInfo encapsulates all topology information for a given iota-server invocation
type NodeMsg struct {
	// API Response for the node
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// Node operation
	NodeOp Op `protobuf:"varint,2,opt,name=node_op,json=nodeOp,proto3,enum=iotamodel.Op" json:"node_op,omitempty"`
	// List of nodes in the e2e cluster
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes" json:"nodes,omitempty"`
	// Set this to true during init time. This will essentially brings up the e2e cluster
	MakeCluster bool `protobuf:"varint,4,opt,name=make_cluster,json=makeCluster,proto3" json:"make_cluster,omitempty"`
	// Cluster is complete or not (Could by used by other nodes to check their admission status for health check)
	ClusterDone bool `protobuf:"varint,5,opt,name=cluster_done,json=clusterDone,proto3" json:"cluster_done,omitempty"`
}

func (m *NodeMsg) Reset()                    { *m = NodeMsg{} }
func (m *NodeMsg) String() string            { return proto.CompactTextString(m) }
func (*NodeMsg) ProtoMessage()               {}
func (*NodeMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{0} }

func (m *NodeMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *NodeMsg) GetNodeOp() Op {
	if m != nil {
		return m.NodeOp
	}
	return Op_NONE
}

func (m *NodeMsg) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *NodeMsg) GetMakeCluster() bool {
	if m != nil {
		return m.MakeCluster
	}
	return false
}

func (m *NodeMsg) GetClusterDone() bool {
	if m != nil {
		return m.ClusterDone
	}
	return false
}

type Entity struct {
	// Entity type
	Type EntityType `protobuf:"varint,1,opt,name=type,proto3,enum=iotamodel.EntityType" json:"type,omitempty"`
	// Entity name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{1} }

func (m *Entity) GetType() EntityType {
	if m != nil {
		return m.Type
	}
	return EntityType_ENTITY_TYPE_NONE
}

func (m *Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type VmwareESXConfig struct {
	// User name of ESX
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Password of ESX
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// IP address of esx
	IpAddress string `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *VmwareESXConfig) Reset()                    { *m = VmwareESXConfig{} }
func (m *VmwareESXConfig) String() string            { return proto.CompactTextString(m) }
func (*VmwareESXConfig) ProtoMessage()               {}
func (*VmwareESXConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{2} }

func (m *VmwareESXConfig) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *VmwareESXConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *VmwareESXConfig) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

// Node captures personality details of an E2E node
type Node struct {
	// PersonalityType captures the node personality. naples node, venice node or qemu
	Type PersonalityType `protobuf:"varint,1,opt,name=type,proto3,enum=iotamodel.PersonalityType" json:"type,omitempty"`
	// Image captures the the built artifacts that need to be loaded on the node depending on the personality type
	Image string `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	// IP Address of the node
	IpAddress string `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Node identifier
	Name     string    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Entities []*Entity `protobuf:"bytes,5,rep,name=entities" json:"entities,omitempty"`
	// Node specific configs
	//
	// Types that are valid to be assigned to NodeInfo:
	//	*Node_NaplesConfig
	//	*Node_VeniceConfig
	//	*Node_ThirdPartyNicConfig
	//	*Node_NaplesMultiSimConfig
	NodeInfo isNode_NodeInfo `protobuf_oneof:"node_info"`
	// NodeStatus captures the details of the node action
	NodeStatus *IotaAPIResponse `protobuf:"bytes,12,opt,name=node_status,json=nodeStatus" json:"node_status,omitempty"`
	NodeUuid   string           `protobuf:"bytes,13,opt,name=node_uuid,json=nodeUuid,proto3" json:"node_uuid,omitempty"`
	// Optionally run a start up script during add or reload.
	StartupScript string `protobuf:"bytes,14,opt,name=startup_script,json=startupScript,proto3" json:"startup_script,omitempty"`
	// ESX configuration if node type is esx
	EsxConfig *VmwareESXConfig `protobuf:"bytes,15,opt,name=esx_config,json=esxConfig" json:"esx_config,omitempty"`
	// Node OS
	Os TestBedNodeOs `protobuf:"varint,16,opt,name=os,proto3,enum=iotamodel.TestBedNodeOs" json:"os,omitempty"`
	// Flag to indicate that node is being reload from saved config
	Reload bool `protobuf:"varint,17,opt,name=reload,proto3" json:"reload,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{3} }

type isNode_NodeInfo interface {
	isNode_NodeInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_NaplesConfig struct {
	NaplesConfig *NaplesConfig `protobuf:"bytes,6,opt,name=naples_config,json=naplesConfig,oneof"`
}
type Node_VeniceConfig struct {
	VeniceConfig *VeniceConfig `protobuf:"bytes,7,opt,name=venice_config,json=veniceConfig,oneof"`
}
type Node_ThirdPartyNicConfig struct {
	ThirdPartyNicConfig *ThirdPartyNicConfig `protobuf:"bytes,8,opt,name=third_party_nic_config,json=thirdPartyNicConfig,oneof"`
}
type Node_NaplesMultiSimConfig struct {
	NaplesMultiSimConfig *NaplesMultiSimConfig `protobuf:"bytes,9,opt,name=naples_multi_sim_config,json=naplesMultiSimConfig,oneof"`
}

func (*Node_NaplesConfig) isNode_NodeInfo()         {}
func (*Node_VeniceConfig) isNode_NodeInfo()         {}
func (*Node_ThirdPartyNicConfig) isNode_NodeInfo()  {}
func (*Node_NaplesMultiSimConfig) isNode_NodeInfo() {}

func (m *Node) GetNodeInfo() isNode_NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *Node) GetType() PersonalityType {
	if m != nil {
		return m.Type
	}
	return PersonalityType_PERSONALITY_NONE
}

func (m *Node) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Node) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetEntities() []*Entity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Node) GetNaplesConfig() *NaplesConfig {
	if x, ok := m.GetNodeInfo().(*Node_NaplesConfig); ok {
		return x.NaplesConfig
	}
	return nil
}

func (m *Node) GetVeniceConfig() *VeniceConfig {
	if x, ok := m.GetNodeInfo().(*Node_VeniceConfig); ok {
		return x.VeniceConfig
	}
	return nil
}

func (m *Node) GetThirdPartyNicConfig() *ThirdPartyNicConfig {
	if x, ok := m.GetNodeInfo().(*Node_ThirdPartyNicConfig); ok {
		return x.ThirdPartyNicConfig
	}
	return nil
}

func (m *Node) GetNaplesMultiSimConfig() *NaplesMultiSimConfig {
	if x, ok := m.GetNodeInfo().(*Node_NaplesMultiSimConfig); ok {
		return x.NaplesMultiSimConfig
	}
	return nil
}

func (m *Node) GetNodeStatus() *IotaAPIResponse {
	if m != nil {
		return m.NodeStatus
	}
	return nil
}

func (m *Node) GetNodeUuid() string {
	if m != nil {
		return m.NodeUuid
	}
	return ""
}

func (m *Node) GetStartupScript() string {
	if m != nil {
		return m.StartupScript
	}
	return ""
}

func (m *Node) GetEsxConfig() *VmwareESXConfig {
	if m != nil {
		return m.EsxConfig
	}
	return nil
}

func (m *Node) GetOs() TestBedNodeOs {
	if m != nil {
		return m.Os
	}
	return TestBedNodeOs_TESTBED_NODE_OS_LINUX
}

func (m *Node) GetReload() bool {
	if m != nil {
		return m.Reload
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Node) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Node_OneofMarshaler, _Node_OneofUnmarshaler, _Node_OneofSizer, []interface{}{
		(*Node_NaplesConfig)(nil),
		(*Node_VeniceConfig)(nil),
		(*Node_ThirdPartyNicConfig)(nil),
		(*Node_NaplesMultiSimConfig)(nil),
	}
}

func _Node_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Node)
	// node_info
	switch x := m.NodeInfo.(type) {
	case *Node_NaplesConfig:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NaplesConfig); err != nil {
			return err
		}
	case *Node_VeniceConfig:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VeniceConfig); err != nil {
			return err
		}
	case *Node_ThirdPartyNicConfig:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ThirdPartyNicConfig); err != nil {
			return err
		}
	case *Node_NaplesMultiSimConfig:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NaplesMultiSimConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Node.NodeInfo has unexpected type %T", x)
	}
	return nil
}

func _Node_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Node)
	switch tag {
	case 6: // node_info.naples_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NaplesConfig)
		err := b.DecodeMessage(msg)
		m.NodeInfo = &Node_NaplesConfig{msg}
		return true, err
	case 7: // node_info.venice_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VeniceConfig)
		err := b.DecodeMessage(msg)
		m.NodeInfo = &Node_VeniceConfig{msg}
		return true, err
	case 8: // node_info.third_party_nic_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ThirdPartyNicConfig)
		err := b.DecodeMessage(msg)
		m.NodeInfo = &Node_ThirdPartyNicConfig{msg}
		return true, err
	case 9: // node_info.naples_multi_sim_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NaplesMultiSimConfig)
		err := b.DecodeMessage(msg)
		m.NodeInfo = &Node_NaplesMultiSimConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Node_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Node)
	// node_info
	switch x := m.NodeInfo.(type) {
	case *Node_NaplesConfig:
		s := proto.Size(x.NaplesConfig)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_VeniceConfig:
		s := proto.Size(x.VeniceConfig)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_ThirdPartyNicConfig:
		s := proto.Size(x.ThirdPartyNicConfig)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_NaplesMultiSimConfig:
		s := proto.Size(x.NaplesMultiSimConfig)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NaplesMultiSimConfig struct {
	// Number of sim instances
	NumInstances uint32 `protobuf:"varint,1,opt,name=num_instances,json=numInstances,proto3" json:"num_instances,omitempty"`
	// Subnet to be used for naples Instances
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	// gateway to be used for naples Instances
	Gateway string `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// x
	IpAddrRange string `protobuf:"bytes,4,opt,name=ip_addr_range,json=ipAddrRange,proto3" json:"ip_addr_range,omitempty"`
	// parent network to be used.
	Parent string `protobuf:"bytes,5,opt,name=parent,proto3" json:"parent,omitempty"`
	// either nic type or parent interface
	NicType string `protobuf:"bytes,6,opt,name=nic_type,json=nicType,proto3" json:"nic_type,omitempty"`
	// Venice IPs to use, if specified agent will come up im managed mode.
	VeniceIps []string `protobuf:"bytes,7,rep,name=venice_ips,json=veniceIps" json:"venice_ips,omitempty"`
}

func (m *NaplesMultiSimConfig) Reset()                    { *m = NaplesMultiSimConfig{} }
func (m *NaplesMultiSimConfig) String() string            { return proto.CompactTextString(m) }
func (*NaplesMultiSimConfig) ProtoMessage()               {}
func (*NaplesMultiSimConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{4} }

func (m *NaplesMultiSimConfig) GetNumInstances() uint32 {
	if m != nil {
		return m.NumInstances
	}
	return 0
}

func (m *NaplesMultiSimConfig) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NaplesMultiSimConfig) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *NaplesMultiSimConfig) GetIpAddrRange() string {
	if m != nil {
		return m.IpAddrRange
	}
	return ""
}

func (m *NaplesMultiSimConfig) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *NaplesMultiSimConfig) GetNicType() string {
	if m != nil {
		return m.NicType
	}
	return ""
}

func (m *NaplesMultiSimConfig) GetVeniceIps() []string {
	if m != nil {
		return m.VeniceIps
	}
	return nil
}

type NaplesConfig struct {
	// Control interface to use
	ControlIntf string `protobuf:"bytes,1,opt,name=control_intf,json=controlIntf,proto3" json:"control_intf,omitempty"`
	// Control ip to use
	ControlIp string `protobuf:"bytes,2,opt,name=control_ip,json=controlIp,proto3" json:"control_ip,omitempty"`
	// Data interfaces to use
	DataIntfs []string `protobuf:"bytes,3,rep,name=data_intfs,json=dataIntfs" json:"data_intfs,omitempty"`
	// Venice IPs to use, if specified agent will come up im managed mode.
	VeniceIps []string `protobuf:"bytes,4,rep,name=venice_ips,json=veniceIps" json:"venice_ips,omitempty"`
	// host intfs , returned as part of add node
	HostIntfs []string `protobuf:"bytes,5,rep,name=host_intfs,json=hostIntfs" json:"host_intfs,omitempty"`
	// Naples IP in hw mode.
	NaplesIpAddress string `protobuf:"bytes,6,opt,name=naples_ip_address,json=naplesIpAddress,proto3" json:"naples_ip_address,omitempty"`
	// Naples username in hw mode.
	NaplesUsername string `protobuf:"bytes,7,opt,name=naples_username,json=naplesUsername,proto3" json:"naples_username,omitempty"`
	// Naples username in hw mode.
	NaplesPassword string `protobuf:"bytes,8,opt,name=naples_password,json=naplesPassword,proto3" json:"naples_password,omitempty"`
	// Nic type
	NicType string `protobuf:"bytes,9,opt,name=nic_type,json=nicType,proto3" json:"nic_type,omitempty"`
}

func (m *NaplesConfig) Reset()                    { *m = NaplesConfig{} }
func (m *NaplesConfig) String() string            { return proto.CompactTextString(m) }
func (*NaplesConfig) ProtoMessage()               {}
func (*NaplesConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{5} }

func (m *NaplesConfig) GetControlIntf() string {
	if m != nil {
		return m.ControlIntf
	}
	return ""
}

func (m *NaplesConfig) GetControlIp() string {
	if m != nil {
		return m.ControlIp
	}
	return ""
}

func (m *NaplesConfig) GetDataIntfs() []string {
	if m != nil {
		return m.DataIntfs
	}
	return nil
}

func (m *NaplesConfig) GetVeniceIps() []string {
	if m != nil {
		return m.VeniceIps
	}
	return nil
}

func (m *NaplesConfig) GetHostIntfs() []string {
	if m != nil {
		return m.HostIntfs
	}
	return nil
}

func (m *NaplesConfig) GetNaplesIpAddress() string {
	if m != nil {
		return m.NaplesIpAddress
	}
	return ""
}

func (m *NaplesConfig) GetNaplesUsername() string {
	if m != nil {
		return m.NaplesUsername
	}
	return ""
}

func (m *NaplesConfig) GetNaplesPassword() string {
	if m != nil {
		return m.NaplesPassword
	}
	return ""
}

func (m *NaplesConfig) GetNicType() string {
	if m != nil {
		return m.NicType
	}
	return ""
}

type ThirdPartyNicConfig struct {
	// nic type
	NicType string `protobuf:"bytes,1,opt,name=nic_type,json=nicType,proto3" json:"nic_type,omitempty"`
	// host intfs , returned as part of add node
	HostIntfs []string `protobuf:"bytes,2,rep,name=host_intfs,json=hostIntfs" json:"host_intfs,omitempty"`
}

func (m *ThirdPartyNicConfig) Reset()                    { *m = ThirdPartyNicConfig{} }
func (m *ThirdPartyNicConfig) String() string            { return proto.CompactTextString(m) }
func (*ThirdPartyNicConfig) ProtoMessage()               {}
func (*ThirdPartyNicConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{6} }

func (m *ThirdPartyNicConfig) GetNicType() string {
	if m != nil {
		return m.NicType
	}
	return ""
}

func (m *ThirdPartyNicConfig) GetHostIntfs() []string {
	if m != nil {
		return m.HostIntfs
	}
	return nil
}

type MellanoxConfig struct {
	// host intfs , returned as part of add node
	HostIntfs []string `protobuf:"bytes,5,rep,name=host_intfs,json=hostIntfs" json:"host_intfs,omitempty"`
}

func (m *MellanoxConfig) Reset()                    { *m = MellanoxConfig{} }
func (m *MellanoxConfig) String() string            { return proto.CompactTextString(m) }
func (*MellanoxConfig) ProtoMessage()               {}
func (*MellanoxConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{7} }

func (m *MellanoxConfig) GetHostIntfs() []string {
	if m != nil {
		return m.HostIntfs
	}
	return nil
}

type BroadcomConfig struct {
	// host intfs , returned as part of add node
	HostIntfs []string `protobuf:"bytes,5,rep,name=host_intfs,json=hostIntfs" json:"host_intfs,omitempty"`
}

func (m *BroadcomConfig) Reset()                    { *m = BroadcomConfig{} }
func (m *BroadcomConfig) String() string            { return proto.CompactTextString(m) }
func (*BroadcomConfig) ProtoMessage()               {}
func (*BroadcomConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{8} }

func (m *BroadcomConfig) GetHostIntfs() []string {
	if m != nil {
		return m.HostIntfs
	}
	return nil
}

type IntelConfig struct {
	// host intfs , returned as part of add node
	HostIntfs []string `protobuf:"bytes,5,rep,name=host_intfs,json=hostIntfs" json:"host_intfs,omitempty"`
}

func (m *IntelConfig) Reset()                    { *m = IntelConfig{} }
func (m *IntelConfig) String() string            { return proto.CompactTextString(m) }
func (*IntelConfig) ProtoMessage()               {}
func (*IntelConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{9} }

func (m *IntelConfig) GetHostIntfs() []string {
	if m != nil {
		return m.HostIntfs
	}
	return nil
}

type VenicePeer struct {
	// hostname of peer node
	HostName string `protobuf:"bytes,1,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// ip of the peer node
	IpAddress string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *VenicePeer) Reset()                    { *m = VenicePeer{} }
func (m *VenicePeer) String() string            { return proto.CompactTextString(m) }
func (*VenicePeer) ProtoMessage()               {}
func (*VenicePeer) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{10} }

func (m *VenicePeer) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *VenicePeer) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

type VeniceConfig struct {
	// Control interface to use
	ControlIntf string `protobuf:"bytes,1,opt,name=control_intf,json=controlIntf,proto3" json:"control_intf,omitempty"`
	// Control ip to use
	ControlIp string `protobuf:"bytes,2,opt,name=control_ip,json=controlIp,proto3" json:"control_ip,omitempty"`
	// Peers to add host name entries.
	VenicePeers []*VenicePeer `protobuf:"bytes,3,rep,name=venice_peers,json=venicePeers" json:"venice_peers,omitempty"`
}

func (m *VeniceConfig) Reset()                    { *m = VeniceConfig{} }
func (m *VeniceConfig) String() string            { return proto.CompactTextString(m) }
func (*VeniceConfig) ProtoMessage()               {}
func (*VeniceConfig) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{11} }

func (m *VeniceConfig) GetControlIntf() string {
	if m != nil {
		return m.ControlIntf
	}
	return ""
}

func (m *VeniceConfig) GetControlIp() string {
	if m != nil {
		return m.ControlIp
	}
	return ""
}

func (m *VeniceConfig) GetVenicePeers() []*VenicePeer {
	if m != nil {
		return m.VenicePeers
	}
	return nil
}

type WorkloadMsg struct {
	// API Response
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// Workload Operation Type
	WorkloadOp Op `protobuf:"varint,2,opt,name=workload_op,json=workloadOp,proto3,enum=iotamodel.Op" json:"workload_op,omitempty"`
	// List of workloads
	Workloads []*Workload `protobuf:"bytes,3,rep,name=workloads" json:"workloads,omitempty"`
}

func (m *WorkloadMsg) Reset()                    { *m = WorkloadMsg{} }
func (m *WorkloadMsg) String() string            { return proto.CompactTextString(m) }
func (*WorkloadMsg) ProtoMessage()               {}
func (*WorkloadMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{12} }

func (m *WorkloadMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *WorkloadMsg) GetWorkloadOp() Op {
	if m != nil {
		return m.WorkloadOp
	}
	return Op_NONE
}

func (m *WorkloadMsg) GetWorkloads() []*Workload {
	if m != nil {
		return m.Workloads
	}
	return nil
}

type Workload struct {
	// Workload Identifier
	WorkloadName string `protobuf:"bytes,1,opt,name=workload_name,json=workloadName,proto3" json:"workload_name,omitempty"`
	// Workload Type
	WorkloadType WorkloadType `protobuf:"varint,2,opt,name=workload_type,json=workloadType,proto3,enum=iotamodel.WorkloadType" json:"workload_type,omitempty"`
	// Workload image
	WorkloadImage string `protobuf:"bytes,3,opt,name=workload_image,json=workloadImage,proto3" json:"workload_image,omitempty"`
	// Node on which this needs to be spun up
	NodeName string `protobuf:"bytes,4,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Data VLAN for the workload
	EncapVlan uint32 `protobuf:"varint,5,opt,name=encap_vlan,json=encapVlan,proto3" json:"encap_vlan,omitempty"`
	// IPAddress of the workload. Represent this as a CIDR block. 10.0.0.1/16 will be
	// interpreted as 10.0.0.1 is the IP of the workload container and it belongs to a /16 subnet.
	IpPrefix   string `protobuf:"bytes,6,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	Ipv6Prefix string `protobuf:"bytes,7,opt,name=ipv6_prefix,json=ipv6Prefix,proto3" json:"ipv6_prefix,omitempty"`
	// MAC Address of the workload
	MacAddress string `protobuf:"bytes,8,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// Interface to which workload needs to be attached.
	Interface string `protobuf:"bytes,9,opt,name=interface,proto3" json:"interface,omitempty"`
	// Parent Interface for classic workload
	ParentInterface string        `protobuf:"bytes,10,opt,name=parent_interface,json=parentInterface,proto3" json:"parent_interface,omitempty"`
	InterfaceType   InterfaceType `protobuf:"varint,11,opt,name=interface_type,json=interfaceType,proto3,enum=iotamodel.InterfaceType" json:"interface_type,omitempty"`
	// Interface to which workload needs to be attached.
	PinnedPort uint32 `protobuf:"varint,12,opt,name=pinned_port,json=pinnedPort,proto3" json:"pinned_port,omitempty"`
	// uplink vlan for the traffic going outside node.
	UplinkVlan uint32 `protobuf:"varint,13,opt,name=uplink_vlan,json=uplinkVlan,proto3" json:"uplink_vlan,omitempty"`
	// Workload Status
	WorkloadStatus *IotaAPIResponse `protobuf:"bytes,14,opt,name=workload_status,json=workloadStatus" json:"workload_status,omitempty"`
	// Secondary IPv4 addresses
	SecIpPrefix []string `protobuf:"bytes,15,rep,name=sec_ip_prefix,json=secIpPrefix" json:"sec_ip_prefix,omitempty"`
	// Secondary IPv6 addresses
	SecIpv6Prefix []string `protobuf:"bytes,16,rep,name=sec_ipv6_prefix,json=secIpv6Prefix" json:"sec_ipv6_prefix,omitempty"`
	// number of CPUs to be dedicated.
	Cpus uint32 `protobuf:"varint,17,opt,name=cpus,proto3" json:"cpus,omitempty"`
	// Memory allocated
	Memory uint32 `protobuf:"varint,18,opt,name=memory,proto3" json:"memory,omitempty"`
	// Management IP of the workload if VM
	MgmtIp string `protobuf:"bytes,19,opt,name=mgmt_ip,json=mgmtIp,proto3" json:"mgmt_ip,omitempty"`
}

func (m *Workload) Reset()                    { *m = Workload{} }
func (m *Workload) String() string            { return proto.CompactTextString(m) }
func (*Workload) ProtoMessage()               {}
func (*Workload) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{13} }

func (m *Workload) GetWorkloadName() string {
	if m != nil {
		return m.WorkloadName
	}
	return ""
}

func (m *Workload) GetWorkloadType() WorkloadType {
	if m != nil {
		return m.WorkloadType
	}
	return WorkloadType_WORKLOAD_TYPE_NONE
}

func (m *Workload) GetWorkloadImage() string {
	if m != nil {
		return m.WorkloadImage
	}
	return ""
}

func (m *Workload) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Workload) GetEncapVlan() uint32 {
	if m != nil {
		return m.EncapVlan
	}
	return 0
}

func (m *Workload) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *Workload) GetIpv6Prefix() string {
	if m != nil {
		return m.Ipv6Prefix
	}
	return ""
}

func (m *Workload) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Workload) GetInterface() string {
	if m != nil {
		return m.Interface
	}
	return ""
}

func (m *Workload) GetParentInterface() string {
	if m != nil {
		return m.ParentInterface
	}
	return ""
}

func (m *Workload) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return InterfaceType_INTERFACE_TYPE_NONE
}

func (m *Workload) GetPinnedPort() uint32 {
	if m != nil {
		return m.PinnedPort
	}
	return 0
}

func (m *Workload) GetUplinkVlan() uint32 {
	if m != nil {
		return m.UplinkVlan
	}
	return 0
}

func (m *Workload) GetWorkloadStatus() *IotaAPIResponse {
	if m != nil {
		return m.WorkloadStatus
	}
	return nil
}

func (m *Workload) GetSecIpPrefix() []string {
	if m != nil {
		return m.SecIpPrefix
	}
	return nil
}

func (m *Workload) GetSecIpv6Prefix() []string {
	if m != nil {
		return m.SecIpv6Prefix
	}
	return nil
}

func (m *Workload) GetCpus() uint32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *Workload) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Workload) GetMgmtIp() string {
	if m != nil {
		return m.MgmtIp
	}
	return ""
}

type TriggerMsg struct {
	// API Status
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// Type of the trigger operation
	TriggerOp TriggerOp `protobuf:"varint,2,opt,name=trigger_op,json=triggerOp,proto3,enum=iotamodel.TriggerOp" json:"trigger_op,omitempty"`
	// Trigger mode specifies whether commands have to be
	// executed serially or in parallel
	TriggerMode TriggerMode `protobuf:"varint,3,opt,name=trigger_mode,json=triggerMode,proto3,enum=iotamodel.TriggerMode" json:"trigger_mode,omitempty"`
	// Command Request params
	Commands []*Command `protobuf:"bytes,4,rep,name=commands" json:"commands,omitempty"`
}

func (m *TriggerMsg) Reset()                    { *m = TriggerMsg{} }
func (m *TriggerMsg) String() string            { return proto.CompactTextString(m) }
func (*TriggerMsg) ProtoMessage()               {}
func (*TriggerMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{14} }

func (m *TriggerMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *TriggerMsg) GetTriggerOp() TriggerOp {
	if m != nil {
		return m.TriggerOp
	}
	return TriggerOp_TYPE_NONE
}

func (m *TriggerMsg) GetTriggerMode() TriggerMode {
	if m != nil {
		return m.TriggerMode
	}
	return TriggerMode_MODE_NONE
}

func (m *TriggerMsg) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type Command struct {
	// Whether to run the command in foreground or background
	Mode CommandMode `protobuf:"varint,1,opt,name=mode,proto3,enum=iotamodel.CommandMode" json:"mode,omitempty"`
	// Fully qualified command line that needs to be called
	Command string `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
	// Node on which trigger needs to be executed
	NodeName string `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// entity name to run command on
	EntityName string `protobuf:"bytes,4,opt,name=entity_name,json=entityName,proto3" json:"entity_name,omitempty"`
	// foreground command timeout
	ForegroundTimeout uint32 `protobuf:"varint,5,opt,name=foreground_timeout,json=foregroundTimeout,proto3" json:"foreground_timeout,omitempty"`
	// running directory relative to entity dir to run command
	RunningDir string `protobuf:"bytes,6,opt,name=running_dir,json=runningDir,proto3" json:"running_dir,omitempty"`
	// ================ Output Parameters ===================
	// StdOut of the comamnd
	Stdout string `protobuf:"bytes,7,opt,name=stdout,proto3" json:"stdout,omitempty"`
	// StdErr of the command
	Stderr string `protobuf:"bytes,8,opt,name=stderr,proto3" json:"stderr,omitempty"`
	// Exit code of the command
	ExitCode int32 `protobuf:"varint,9,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// command handle. Useful only for background commands
	Handle string `protobuf:"bytes,10,opt,name=handle,proto3" json:"handle,omitempty"`
	// Whehther command timed out
	TimedOut bool `protobuf:"varint,11,opt,name=timed_out,json=timedOut,proto3" json:"timed_out,omitempty"`
	// Copy Stderr on error only
	StdoutOnErr bool `protobuf:"varint,12,opt,name=stdout_on_err,json=stdoutOnErr,proto3" json:"stdout_on_err,omitempty"`
	// Copy Stderr on error only
	StderrOnErr bool `protobuf:"varint,13,opt,name=stderr_on_err,json=stderrOnErr,proto3" json:"stderr_on_err,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{15} }

func (m *Command) GetMode() CommandMode {
	if m != nil {
		return m.Mode
	}
	return CommandMode_COMMAND_NONE
}

func (m *Command) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Command) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Command) GetEntityName() string {
	if m != nil {
		return m.EntityName
	}
	return ""
}

func (m *Command) GetForegroundTimeout() uint32 {
	if m != nil {
		return m.ForegroundTimeout
	}
	return 0
}

func (m *Command) GetRunningDir() string {
	if m != nil {
		return m.RunningDir
	}
	return ""
}

func (m *Command) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *Command) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *Command) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *Command) GetHandle() string {
	if m != nil {
		return m.Handle
	}
	return ""
}

func (m *Command) GetTimedOut() bool {
	if m != nil {
		return m.TimedOut
	}
	return false
}

func (m *Command) GetStdoutOnErr() bool {
	if m != nil {
		return m.StdoutOnErr
	}
	return false
}

func (m *Command) GetStderrOnErr() bool {
	if m != nil {
		return m.StderrOnErr
	}
	return false
}

// Captures the overall health of the e2e cluster
type ClusterHealthMsg struct {
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// Individual node health statuses
	Health []*NodeHealth `protobuf:"bytes,2,rep,name=health" json:"health,omitempty"`
}

func (m *ClusterHealthMsg) Reset()                    { *m = ClusterHealthMsg{} }
func (m *ClusterHealthMsg) String() string            { return proto.CompactTextString(m) }
func (*ClusterHealthMsg) ProtoMessage()               {}
func (*ClusterHealthMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{16} }

func (m *ClusterHealthMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *ClusterHealthMsg) GetHealth() []*NodeHealth {
	if m != nil {
		return m.Health
	}
	return nil
}

type NodeHealth struct {
	// Name of the node
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// Cluster is complete or not (Could by used by other nodes to check their admission status for health check)
	ClusterDone bool `protobuf:"varint,2,opt,name=cluster_done,json=clusterDone,proto3" json:"cluster_done,omitempty"`
	// Health code of the node
	HealthCode NodeHealth_HealthCode `protobuf:"varint,3,opt,name=health_code,json=healthCode,proto3,enum=iotamodel.NodeHealth_HealthCode" json:"health_code,omitempty"`
}

func (m *NodeHealth) Reset()                    { *m = NodeHealth{} }
func (m *NodeHealth) String() string            { return proto.CompactTextString(m) }
func (*NodeHealth) ProtoMessage()               {}
func (*NodeHealth) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{17} }

func (m *NodeHealth) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *NodeHealth) GetClusterDone() bool {
	if m != nil {
		return m.ClusterDone
	}
	return false
}

func (m *NodeHealth) GetHealthCode() NodeHealth_HealthCode {
	if m != nil {
		return m.HealthCode
	}
	return NodeHealth_HEALTH_OK
}

type DataSwitch struct {
	// IP address of the switch
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	// Username of the switch
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Password of the switch
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// switch ports used
	Ports []string `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
	// Speed of each port
	Speed DataSwitch_Speed `protobuf:"varint,5,opt,name=speed,proto3,enum=iotamodel.DataSwitch_Speed" json:"speed,omitempty"`
}

func (m *DataSwitch) Reset()                    { *m = DataSwitch{} }
func (m *DataSwitch) String() string            { return proto.CompactTextString(m) }
func (*DataSwitch) ProtoMessage()               {}
func (*DataSwitch) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{18} }

func (m *DataSwitch) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *DataSwitch) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DataSwitch) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *DataSwitch) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DataSwitch) GetSpeed() DataSwitch_Speed {
	if m != nil {
		return m.Speed
	}
	return DataSwitch_Speed_100G
}

type TestBedMsg struct {
	// API Response
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// NAPLES tarball to copy on the remote nodes
	NaplesSimImage string `protobuf:"bytes,2,opt,name=naples_sim_image,json=naplesSimImage,proto3" json:"naples_sim_image,omitempty"`
	// NAPLES tarball to copy on the remote nodes
	NaplesImage string `protobuf:"bytes,3,opt,name=naples_image,json=naplesImage,proto3" json:"naples_image,omitempty"`
	// Venice tarball to copy on the remote nodes
	VeniceImage string `protobuf:"bytes,4,opt,name=venice_image,json=veniceImage,proto3" json:"venice_image,omitempty"`
	// Driver sources to copy on the remote nodes
	DriverSources string `protobuf:"bytes,5,opt,name=driver_sources,json=driverSources,proto3" json:"driver_sources,omitempty"`
	// Allocated vlans based off of the port id
	AllocatedVlans []uint32 `protobuf:"varint,6,rep,packed,name=allocated_vlans,json=allocatedVlans" json:"allocated_vlans,omitempty"`
	// List of node IP addresses
	Nodes []*TestBedNode `protobuf:"bytes,7,rep,name=nodes" json:"nodes,omitempty"`
	// Node username
	Username string `protobuf:"bytes,8,opt,name=username,proto3" json:"username,omitempty"`
	// Node password
	Password string `protobuf:"bytes,9,opt,name=password,proto3" json:"password,omitempty"`
	// Testbed ID
	TestbedId uint32 `protobuf:"varint,10,opt,name=testbed_id,json=testbedId,proto3" json:"testbed_id,omitempty"`
	// DataSwitch
	DataSwitches []*DataSwitch `protobuf:"bytes,11,rep,name=data_switches,json=dataSwitches" json:"data_switches,omitempty"`
	// Reboot Nodes
	RebootNodes bool `protobuf:"varint,12,opt,name=reboot_nodes,json=rebootNodes,proto3" json:"reboot_nodes,omitempty"`
}

func (m *TestBedMsg) Reset()                    { *m = TestBedMsg{} }
func (m *TestBedMsg) String() string            { return proto.CompactTextString(m) }
func (*TestBedMsg) ProtoMessage()               {}
func (*TestBedMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{19} }

func (m *TestBedMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *TestBedMsg) GetNaplesSimImage() string {
	if m != nil {
		return m.NaplesSimImage
	}
	return ""
}

func (m *TestBedMsg) GetNaplesImage() string {
	if m != nil {
		return m.NaplesImage
	}
	return ""
}

func (m *TestBedMsg) GetVeniceImage() string {
	if m != nil {
		return m.VeniceImage
	}
	return ""
}

func (m *TestBedMsg) GetDriverSources() string {
	if m != nil {
		return m.DriverSources
	}
	return ""
}

func (m *TestBedMsg) GetAllocatedVlans() []uint32 {
	if m != nil {
		return m.AllocatedVlans
	}
	return nil
}

func (m *TestBedMsg) GetNodes() []*TestBedNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *TestBedMsg) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *TestBedMsg) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *TestBedMsg) GetTestbedId() uint32 {
	if m != nil {
		return m.TestbedId
	}
	return 0
}

func (m *TestBedMsg) GetDataSwitches() []*DataSwitch {
	if m != nil {
		return m.DataSwitches
	}
	return nil
}

func (m *TestBedMsg) GetRebootNodes() bool {
	if m != nil {
		return m.RebootNodes
	}
	return false
}

type TestNodesMsg struct {
	// API Response
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// List of node IP addresses
	Nodes []*TestBedNode `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	// Node username
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// Node password
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// Reboot Nodes
	RebootNodes bool `protobuf:"varint,5,opt,name=reboot_nodes,json=rebootNodes,proto3" json:"reboot_nodes,omitempty"`
}

func (m *TestNodesMsg) Reset()                    { *m = TestNodesMsg{} }
func (m *TestNodesMsg) String() string            { return proto.CompactTextString(m) }
func (*TestNodesMsg) ProtoMessage()               {}
func (*TestNodesMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{20} }

func (m *TestNodesMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *TestNodesMsg) GetNodes() []*TestBedNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *TestNodesMsg) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *TestNodesMsg) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *TestNodesMsg) GetRebootNodes() bool {
	if m != nil {
		return m.RebootNodes
	}
	return false
}

type SwitchMsg struct {
	// API Response
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	Op          SwitchOp         `protobuf:"varint,2,opt,name=op,proto3,enum=iotamodel.SwitchOp" json:"op,omitempty"`
	// DataSwitch
	DataSwitches []*DataSwitch `protobuf:"bytes,3,rep,name=data_switches,json=dataSwitches" json:"data_switches,omitempty"`
}

func (m *SwitchMsg) Reset()                    { *m = SwitchMsg{} }
func (m *SwitchMsg) String() string            { return proto.CompactTextString(m) }
func (*SwitchMsg) ProtoMessage()               {}
func (*SwitchMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{21} }

func (m *SwitchMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *SwitchMsg) GetOp() SwitchOp {
	if m != nil {
		return m.Op
	}
	return SwitchOp_OP_NONE
}

func (m *SwitchMsg) GetDataSwitches() []*DataSwitch {
	if m != nil {
		return m.DataSwitches
	}
	return nil
}

type TestBedNode struct {
	Type TestBedNodeType `protobuf:"varint,1,opt,name=type,proto3,enum=iotamodel.TestBedNodeType" json:"type,omitempty"`
	// Node Management IP Address
	IpAddress     string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	CimcIpAddress string `protobuf:"bytes,3,opt,name=cimc_ip_address,json=cimcIpAddress,proto3" json:"cimc_ip_address,omitempty"`
	// Node CIMC username
	CimcUsername string `protobuf:"bytes,4,opt,name=cimc_username,json=cimcUsername,proto3" json:"cimc_username,omitempty"`
	// Node CIMC password
	CimcPassword string `protobuf:"bytes,5,opt,name=cimc_password,json=cimcPassword,proto3" json:"cimc_password,omitempty"`
	// Node CIMC username
	EsxUsername string `protobuf:"bytes,6,opt,name=esx_username,json=esxUsername,proto3" json:"esx_username,omitempty"`
	// Node CIMC password
	EsxPassword  string `protobuf:"bytes,7,opt,name=esx_password,json=esxPassword,proto3" json:"esx_password,omitempty"`
	NicIpAddress string `protobuf:"bytes,8,opt,name=nic_ip_address,json=nicIpAddress,proto3" json:"nic_ip_address,omitempty"`
	// NIC Console ip address
	NicConsoleIpAddress string `protobuf:"bytes,9,opt,name=nic_console_ip_address,json=nicConsoleIpAddress,proto3" json:"nic_console_ip_address,omitempty"`
	// NIC Console port
	NicConsolePort string `protobuf:"bytes,10,opt,name=nic_console_port,json=nicConsolePort,proto3" json:"nic_console_port,omitempty"`
	// NIC Console username
	NicConsoleUsername string `protobuf:"bytes,11,opt,name=nic_console_username,json=nicConsoleUsername,proto3" json:"nic_console_username,omitempty"`
	// NIC Console password
	NicConsolePassword string `protobuf:"bytes,12,opt,name=nic_console_password,json=nicConsolePassword,proto3" json:"nic_console_password,omitempty"`
	// NIC username
	NicUsername string `protobuf:"bytes,13,opt,name=nic_username,json=nicUsername,proto3" json:"nic_username,omitempty"`
	// NIC password
	NicPassword string `protobuf:"bytes,14,opt,name=nic_password,json=nicPassword,proto3" json:"nic_password,omitempty"`
	// Initialization script - used for HW
	InitScript string `protobuf:"bytes,15,opt,name=init_script,json=initScript,proto3" json:"init_script,omitempty"`
	// Control interface for this node.
	ControlIntf string `protobuf:"bytes,16,opt,name=control_intf,json=controlIntf,proto3" json:"control_intf,omitempty"`
	// Switch ports for this node.
	SwitchPortIds []uint32 `protobuf:"varint,17,rep,packed,name=switch_port_ids,json=switchPortIds" json:"switch_port_ids,omitempty"`
	// Node OS
	Os TestBedNodeOs `protobuf:"varint,18,opt,name=os,proto3,enum=iotamodel.TestBedNodeOs" json:"os,omitempty"`
	// IP address of ESX control vm
	EsxCtrlNodeIpAddress string `protobuf:"bytes,19,opt,name=esx_ctrl_node_ip_address,json=esxCtrlNodeIpAddress,proto3" json:"esx_ctrl_node_ip_address,omitempty"`
	// NIC uuid
	NicUuid string `protobuf:"bytes,20,opt,name=nic_uuid,json=nicUuid,proto3" json:"nic_uuid,omitempty"`
	// node name
	NodeName string `protobuf:"bytes,21,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
}

func (m *TestBedNode) Reset()                    { *m = TestBedNode{} }
func (m *TestBedNode) String() string            { return proto.CompactTextString(m) }
func (*TestBedNode) ProtoMessage()               {}
func (*TestBedNode) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{22} }

func (m *TestBedNode) GetType() TestBedNodeType {
	if m != nil {
		return m.Type
	}
	return TestBedNodeType_TESTBED_NODE_TYPE_NONE
}

func (m *TestBedNode) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *TestBedNode) GetCimcIpAddress() string {
	if m != nil {
		return m.CimcIpAddress
	}
	return ""
}

func (m *TestBedNode) GetCimcUsername() string {
	if m != nil {
		return m.CimcUsername
	}
	return ""
}

func (m *TestBedNode) GetCimcPassword() string {
	if m != nil {
		return m.CimcPassword
	}
	return ""
}

func (m *TestBedNode) GetEsxUsername() string {
	if m != nil {
		return m.EsxUsername
	}
	return ""
}

func (m *TestBedNode) GetEsxPassword() string {
	if m != nil {
		return m.EsxPassword
	}
	return ""
}

func (m *TestBedNode) GetNicIpAddress() string {
	if m != nil {
		return m.NicIpAddress
	}
	return ""
}

func (m *TestBedNode) GetNicConsoleIpAddress() string {
	if m != nil {
		return m.NicConsoleIpAddress
	}
	return ""
}

func (m *TestBedNode) GetNicConsolePort() string {
	if m != nil {
		return m.NicConsolePort
	}
	return ""
}

func (m *TestBedNode) GetNicConsoleUsername() string {
	if m != nil {
		return m.NicConsoleUsername
	}
	return ""
}

func (m *TestBedNode) GetNicConsolePassword() string {
	if m != nil {
		return m.NicConsolePassword
	}
	return ""
}

func (m *TestBedNode) GetNicUsername() string {
	if m != nil {
		return m.NicUsername
	}
	return ""
}

func (m *TestBedNode) GetNicPassword() string {
	if m != nil {
		return m.NicPassword
	}
	return ""
}

func (m *TestBedNode) GetInitScript() string {
	if m != nil {
		return m.InitScript
	}
	return ""
}

func (m *TestBedNode) GetControlIntf() string {
	if m != nil {
		return m.ControlIntf
	}
	return ""
}

func (m *TestBedNode) GetSwitchPortIds() []uint32 {
	if m != nil {
		return m.SwitchPortIds
	}
	return nil
}

func (m *TestBedNode) GetOs() TestBedNodeOs {
	if m != nil {
		return m.Os
	}
	return TestBedNodeOs_TESTBED_NODE_OS_LINUX
}

func (m *TestBedNode) GetEsxCtrlNodeIpAddress() string {
	if m != nil {
		return m.EsxCtrlNodeIpAddress
	}
	return ""
}

func (m *TestBedNode) GetNicUuid() string {
	if m != nil {
		return m.NicUuid
	}
	return ""
}

func (m *TestBedNode) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

// EntityCopyMsg takes care of copying to entity.
// If copy in to entity, destination will be prefixed with entity directory on iota node.
// if copy out from entity, files will be prefixed with entity directory on iota node.
type EntityCopyMsg struct {
	// API Response for the copy operation
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// Copy Direction.
	Direction CopyDirection `protobuf:"varint,2,opt,name=direction,proto3,enum=iotamodel.CopyDirection" json:"direction,omitempty"`
	// Node to do copy operation
	NodeName string `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// workload context to do copy operation
	EntityName string `protobuf:"bytes,4,opt,name=entity_name,json=entityName,proto3" json:"entity_name,omitempty"`
	// list of files that needs to be copied
	Files []string `protobuf:"bytes,5,rep,name=files" json:"files,omitempty"`
	// destination directory
	DestDir string `protobuf:"bytes,6,opt,name=dest_dir,json=destDir,proto3" json:"dest_dir,omitempty"`
}

func (m *EntityCopyMsg) Reset()                    { *m = EntityCopyMsg{} }
func (m *EntityCopyMsg) String() string            { return proto.CompactTextString(m) }
func (*EntityCopyMsg) ProtoMessage()               {}
func (*EntityCopyMsg) Descriptor() ([]byte, []int) { return fileDescriptorTopoSvc, []int{23} }

func (m *EntityCopyMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *EntityCopyMsg) GetDirection() CopyDirection {
	if m != nil {
		return m.Direction
	}
	return CopyDirection_DIR_NONE
}

func (m *EntityCopyMsg) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *EntityCopyMsg) GetEntityName() string {
	if m != nil {
		return m.EntityName
	}
	return ""
}

func (m *EntityCopyMsg) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *EntityCopyMsg) GetDestDir() string {
	if m != nil {
		return m.DestDir
	}
	return ""
}

func init() {
	proto.RegisterType((*NodeMsg)(nil), "iotamodel.NodeMsg")
	proto.RegisterType((*Entity)(nil), "iotamodel.Entity")
	proto.RegisterType((*VmwareESXConfig)(nil), "iotamodel.VmwareESXConfig")
	proto.RegisterType((*Node)(nil), "iotamodel.Node")
	proto.RegisterType((*NaplesMultiSimConfig)(nil), "iotamodel.NaplesMultiSimConfig")
	proto.RegisterType((*NaplesConfig)(nil), "iotamodel.NaplesConfig")
	proto.RegisterType((*ThirdPartyNicConfig)(nil), "iotamodel.ThirdPartyNicConfig")
	proto.RegisterType((*MellanoxConfig)(nil), "iotamodel.MellanoxConfig")
	proto.RegisterType((*BroadcomConfig)(nil), "iotamodel.BroadcomConfig")
	proto.RegisterType((*IntelConfig)(nil), "iotamodel.IntelConfig")
	proto.RegisterType((*VenicePeer)(nil), "iotamodel.VenicePeer")
	proto.RegisterType((*VeniceConfig)(nil), "iotamodel.VeniceConfig")
	proto.RegisterType((*WorkloadMsg)(nil), "iotamodel.WorkloadMsg")
	proto.RegisterType((*Workload)(nil), "iotamodel.Workload")
	proto.RegisterType((*TriggerMsg)(nil), "iotamodel.TriggerMsg")
	proto.RegisterType((*Command)(nil), "iotamodel.Command")
	proto.RegisterType((*ClusterHealthMsg)(nil), "iotamodel.ClusterHealthMsg")
	proto.RegisterType((*NodeHealth)(nil), "iotamodel.NodeHealth")
	proto.RegisterType((*DataSwitch)(nil), "iotamodel.DataSwitch")
	proto.RegisterType((*TestBedMsg)(nil), "iotamodel.TestBedMsg")
	proto.RegisterType((*TestNodesMsg)(nil), "iotamodel.TestNodesMsg")
	proto.RegisterType((*SwitchMsg)(nil), "iotamodel.SwitchMsg")
	proto.RegisterType((*TestBedNode)(nil), "iotamodel.TestBedNode")
	proto.RegisterType((*EntityCopyMsg)(nil), "iotamodel.EntityCopyMsg")
	proto.RegisterEnum("iotamodel.Op", Op_name, Op_value)
	proto.RegisterEnum("iotamodel.PersonalityType", PersonalityType_name, PersonalityType_value)
	proto.RegisterEnum("iotamodel.EntityType", EntityType_name, EntityType_value)
	proto.RegisterEnum("iotamodel.InterfaceType", InterfaceType_name, InterfaceType_value)
	proto.RegisterEnum("iotamodel.WorkloadType", WorkloadType_name, WorkloadType_value)
	proto.RegisterEnum("iotamodel.TriggerOp", TriggerOp_name, TriggerOp_value)
	proto.RegisterEnum("iotamodel.TriggerMode", TriggerMode_name, TriggerMode_value)
	proto.RegisterEnum("iotamodel.CommandMode", CommandMode_name, CommandMode_value)
	proto.RegisterEnum("iotamodel.SwitchOp", SwitchOp_name, SwitchOp_value)
	proto.RegisterEnum("iotamodel.TestBedNodeType", TestBedNodeType_name, TestBedNodeType_value)
	proto.RegisterEnum("iotamodel.TestBedNodeOs", TestBedNodeOs_name, TestBedNodeOs_value)
	proto.RegisterEnum("iotamodel.CopyDirection", CopyDirection_name, CopyDirection_value)
	proto.RegisterEnum("iotamodel.NodeHealth_HealthCode", NodeHealth_HealthCode_name, NodeHealth_HealthCode_value)
	proto.RegisterEnum("iotamodel.DataSwitch_Speed", DataSwitch_Speed_name, DataSwitch_Speed_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TopologyApi service

type TopologyApiClient interface {
	// InstallImage installs the image on testbed nodes
	InstallImage(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error)
	// InitTestBed Allocate Data VLANs, copy over built artifacts and starts IOTA Agent on all the nodes
	InitTestBed(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error)
	// CleanUpTestBed will ensure that any state left behind from the previous run is appropriately cleaned up.
	CleanUpTestBed(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error)
	// InitNodes initialize the list of nodes specified which might be added on the fly
	InitNodes(ctx context.Context, in *TestNodesMsg, opts ...grpc.CallOption) (*TestNodesMsg, error)
	// CleanNodes removes the nodes from the topology on the fly
	CleanNodes(ctx context.Context, in *TestNodesMsg, opts ...grpc.CallOption) (*TestNodesMsg, error)
	// DoSwitchOperation do switch operation
	DoSwitchOperation(ctx context.Context, in *SwitchMsg, opts ...grpc.CallOption) (*SwitchMsg, error)
	// AddNodes brings up the nodes with their corresponding personalities
	AddNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error)
	// Load Node will save, reboot and load context
	ReloadNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error)
	// DeleteNodes removes a node from the e2e cluster
	DeleteNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error)
	// GetNodes returns the topology information of all the nodes.
	GetNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error)
	// AddWorkloads brings up a workload type on a given node
	AddWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error)
	// GetWorkloads gets current list of workloads from iota server
	GetWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error)
	// DeleteWorkloads deletes a given workload
	DeleteWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error)
	// Trigger invokes the workload's trigger. It could be ping, start client/server etc..
	Trigger(ctx context.Context, in *TriggerMsg, opts ...grpc.CallOption) (*TriggerMsg, error)
	// CheckClusterHealth returns the cluster health
	CheckClusterHealth(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*ClusterHealthMsg, error)
	// EntityCopy copies files in/out from entities
	EntityCopy(ctx context.Context, in *EntityCopyMsg, opts ...grpc.CallOption) (*EntityCopyMsg, error)
}

type topologyApiClient struct {
	cc *grpc.ClientConn
}

func NewTopologyApiClient(cc *grpc.ClientConn) TopologyApiClient {
	return &topologyApiClient{cc}
}

func (c *topologyApiClient) InstallImage(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error) {
	out := new(TestBedMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/InstallImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) InitTestBed(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error) {
	out := new(TestBedMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/InitTestBed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) CleanUpTestBed(ctx context.Context, in *TestBedMsg, opts ...grpc.CallOption) (*TestBedMsg, error) {
	out := new(TestBedMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/CleanUpTestBed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) InitNodes(ctx context.Context, in *TestNodesMsg, opts ...grpc.CallOption) (*TestNodesMsg, error) {
	out := new(TestNodesMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/InitNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) CleanNodes(ctx context.Context, in *TestNodesMsg, opts ...grpc.CallOption) (*TestNodesMsg, error) {
	out := new(TestNodesMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/CleanNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) DoSwitchOperation(ctx context.Context, in *SwitchMsg, opts ...grpc.CallOption) (*SwitchMsg, error) {
	out := new(SwitchMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/DoSwitchOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) AddNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error) {
	out := new(NodeMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/AddNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) ReloadNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error) {
	out := new(NodeMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/ReloadNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) DeleteNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error) {
	out := new(NodeMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/DeleteNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) GetNodes(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*NodeMsg, error) {
	out := new(NodeMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/GetNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) AddWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error) {
	out := new(WorkloadMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/AddWorkloads", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) GetWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error) {
	out := new(WorkloadMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/GetWorkloads", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) DeleteWorkloads(ctx context.Context, in *WorkloadMsg, opts ...grpc.CallOption) (*WorkloadMsg, error) {
	out := new(WorkloadMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/DeleteWorkloads", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) Trigger(ctx context.Context, in *TriggerMsg, opts ...grpc.CallOption) (*TriggerMsg, error) {
	out := new(TriggerMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/Trigger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) CheckClusterHealth(ctx context.Context, in *NodeMsg, opts ...grpc.CallOption) (*ClusterHealthMsg, error) {
	out := new(ClusterHealthMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/CheckClusterHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topologyApiClient) EntityCopy(ctx context.Context, in *EntityCopyMsg, opts ...grpc.CallOption) (*EntityCopyMsg, error) {
	out := new(EntityCopyMsg)
	err := grpc.Invoke(ctx, "/iotamodel.TopologyApi/EntityCopy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TopologyApi service

type TopologyApiServer interface {
	// InstallImage installs the image on testbed nodes
	InstallImage(context.Context, *TestBedMsg) (*TestBedMsg, error)
	// InitTestBed Allocate Data VLANs, copy over built artifacts and starts IOTA Agent on all the nodes
	InitTestBed(context.Context, *TestBedMsg) (*TestBedMsg, error)
	// CleanUpTestBed will ensure that any state left behind from the previous run is appropriately cleaned up.
	CleanUpTestBed(context.Context, *TestBedMsg) (*TestBedMsg, error)
	// InitNodes initialize the list of nodes specified which might be added on the fly
	InitNodes(context.Context, *TestNodesMsg) (*TestNodesMsg, error)
	// CleanNodes removes the nodes from the topology on the fly
	CleanNodes(context.Context, *TestNodesMsg) (*TestNodesMsg, error)
	// DoSwitchOperation do switch operation
	DoSwitchOperation(context.Context, *SwitchMsg) (*SwitchMsg, error)
	// AddNodes brings up the nodes with their corresponding personalities
	AddNodes(context.Context, *NodeMsg) (*NodeMsg, error)
	// Load Node will save, reboot and load context
	ReloadNodes(context.Context, *NodeMsg) (*NodeMsg, error)
	// DeleteNodes removes a node from the e2e cluster
	DeleteNodes(context.Context, *NodeMsg) (*NodeMsg, error)
	// GetNodes returns the topology information of all the nodes.
	GetNodes(context.Context, *NodeMsg) (*NodeMsg, error)
	// AddWorkloads brings up a workload type on a given node
	AddWorkloads(context.Context, *WorkloadMsg) (*WorkloadMsg, error)
	// GetWorkloads gets current list of workloads from iota server
	GetWorkloads(context.Context, *WorkloadMsg) (*WorkloadMsg, error)
	// DeleteWorkloads deletes a given workload
	DeleteWorkloads(context.Context, *WorkloadMsg) (*WorkloadMsg, error)
	// Trigger invokes the workload's trigger. It could be ping, start client/server etc..
	Trigger(context.Context, *TriggerMsg) (*TriggerMsg, error)
	// CheckClusterHealth returns the cluster health
	CheckClusterHealth(context.Context, *NodeMsg) (*ClusterHealthMsg, error)
	// EntityCopy copies files in/out from entities
	EntityCopy(context.Context, *EntityCopyMsg) (*EntityCopyMsg, error)
}

func RegisterTopologyApiServer(s *grpc.Server, srv TopologyApiServer) {
	s.RegisterService(&_TopologyApi_serviceDesc, srv)
}

func _TopologyApi_InstallImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestBedMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).InstallImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/InstallImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).InstallImage(ctx, req.(*TestBedMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_InitTestBed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestBedMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).InitTestBed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/InitTestBed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).InitTestBed(ctx, req.(*TestBedMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_CleanUpTestBed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestBedMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).CleanUpTestBed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/CleanUpTestBed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).CleanUpTestBed(ctx, req.(*TestBedMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_InitNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestNodesMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).InitNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/InitNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).InitNodes(ctx, req.(*TestNodesMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_CleanNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestNodesMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).CleanNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/CleanNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).CleanNodes(ctx, req.(*TestNodesMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_DoSwitchOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).DoSwitchOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/DoSwitchOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).DoSwitchOperation(ctx, req.(*SwitchMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_AddNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).AddNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/AddNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).AddNodes(ctx, req.(*NodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_ReloadNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).ReloadNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/ReloadNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).ReloadNodes(ctx, req.(*NodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_DeleteNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).DeleteNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/DeleteNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).DeleteNodes(ctx, req.(*NodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).GetNodes(ctx, req.(*NodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_AddWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).AddWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/AddWorkloads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).AddWorkloads(ctx, req.(*WorkloadMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_GetWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).GetWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/GetWorkloads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).GetWorkloads(ctx, req.(*WorkloadMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_DeleteWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).DeleteWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/DeleteWorkloads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).DeleteWorkloads(ctx, req.(*WorkloadMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_Trigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).Trigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/Trigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).Trigger(ctx, req.(*TriggerMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_CheckClusterHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).CheckClusterHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/CheckClusterHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).CheckClusterHealth(ctx, req.(*NodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopologyApi_EntityCopy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntityCopyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopologyApiServer).EntityCopy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.TopologyApi/EntityCopy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopologyApiServer).EntityCopy(ctx, req.(*EntityCopyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _TopologyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "iotamodel.TopologyApi",
	HandlerType: (*TopologyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InstallImage",
			Handler:    _TopologyApi_InstallImage_Handler,
		},
		{
			MethodName: "InitTestBed",
			Handler:    _TopologyApi_InitTestBed_Handler,
		},
		{
			MethodName: "CleanUpTestBed",
			Handler:    _TopologyApi_CleanUpTestBed_Handler,
		},
		{
			MethodName: "InitNodes",
			Handler:    _TopologyApi_InitNodes_Handler,
		},
		{
			MethodName: "CleanNodes",
			Handler:    _TopologyApi_CleanNodes_Handler,
		},
		{
			MethodName: "DoSwitchOperation",
			Handler:    _TopologyApi_DoSwitchOperation_Handler,
		},
		{
			MethodName: "AddNodes",
			Handler:    _TopologyApi_AddNodes_Handler,
		},
		{
			MethodName: "ReloadNodes",
			Handler:    _TopologyApi_ReloadNodes_Handler,
		},
		{
			MethodName: "DeleteNodes",
			Handler:    _TopologyApi_DeleteNodes_Handler,
		},
		{
			MethodName: "GetNodes",
			Handler:    _TopologyApi_GetNodes_Handler,
		},
		{
			MethodName: "AddWorkloads",
			Handler:    _TopologyApi_AddWorkloads_Handler,
		},
		{
			MethodName: "GetWorkloads",
			Handler:    _TopologyApi_GetWorkloads_Handler,
		},
		{
			MethodName: "DeleteWorkloads",
			Handler:    _TopologyApi_DeleteWorkloads_Handler,
		},
		{
			MethodName: "Trigger",
			Handler:    _TopologyApi_Trigger_Handler,
		},
		{
			MethodName: "CheckClusterHealth",
			Handler:    _TopologyApi_CheckClusterHealth_Handler,
		},
		{
			MethodName: "EntityCopy",
			Handler:    _TopologyApi_EntityCopy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "topo_svc.proto",
}

func (m *NodeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n1, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.NodeOp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.NodeOp))
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MakeCluster {
		dAtA[i] = 0x20
		i++
		if m.MakeCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClusterDone {
		dAtA[i] = 0x28
		i++
		if m.ClusterDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *VmwareESXConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VmwareESXConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Type))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NodeInfo != nil {
		nn2, err := m.NodeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.NodeStatus != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.NodeStatus.Size()))
		n3, err := m.NodeStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.NodeUuid) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeUuid)))
		i += copy(dAtA[i:], m.NodeUuid)
	}
	if len(m.StartupScript) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.StartupScript)))
		i += copy(dAtA[i:], m.StartupScript)
	}
	if m.EsxConfig != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.EsxConfig.Size()))
		n4, err := m.EsxConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Os != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Os))
	}
	if m.Reload {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.Reload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Node_NaplesConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NaplesConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.NaplesConfig.Size()))
		n5, err := m.NaplesConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Node_VeniceConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VeniceConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.VeniceConfig.Size()))
		n6, err := m.VeniceConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Node_ThirdPartyNicConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ThirdPartyNicConfig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ThirdPartyNicConfig.Size()))
		n7, err := m.ThirdPartyNicConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Node_NaplesMultiSimConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NaplesMultiSimConfig != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.NaplesMultiSimConfig.Size()))
		n8, err := m.NaplesMultiSimConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *NaplesMultiSimConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesMultiSimConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumInstances != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.NumInstances))
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.IpAddrRange) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpAddrRange)))
		i += copy(dAtA[i:], m.IpAddrRange)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.NicType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicType)))
		i += copy(dAtA[i:], m.NicType)
	}
	if len(m.VeniceIps) > 0 {
		for _, s := range m.VeniceIps {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NaplesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ControlIntf) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ControlIntf)))
		i += copy(dAtA[i:], m.ControlIntf)
	}
	if len(m.ControlIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ControlIp)))
		i += copy(dAtA[i:], m.ControlIp)
	}
	if len(m.DataIntfs) > 0 {
		for _, s := range m.DataIntfs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VeniceIps) > 0 {
		for _, s := range m.VeniceIps {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.NaplesIpAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NaplesIpAddress)))
		i += copy(dAtA[i:], m.NaplesIpAddress)
	}
	if len(m.NaplesUsername) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NaplesUsername)))
		i += copy(dAtA[i:], m.NaplesUsername)
	}
	if len(m.NaplesPassword) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NaplesPassword)))
		i += copy(dAtA[i:], m.NaplesPassword)
	}
	if len(m.NicType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicType)))
		i += copy(dAtA[i:], m.NicType)
	}
	return i, nil
}

func (m *ThirdPartyNicConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThirdPartyNicConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NicType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicType)))
		i += copy(dAtA[i:], m.NicType)
	}
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MellanoxConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MellanoxConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BroadcomConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcomConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *IntelConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntelConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *VenicePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VenicePeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *VeniceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ControlIntf) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ControlIntf)))
		i += copy(dAtA[i:], m.ControlIntf)
	}
	if len(m.ControlIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ControlIp)))
		i += copy(dAtA[i:], m.ControlIp)
	}
	if len(m.VenicePeers) > 0 {
		for _, msg := range m.VenicePeers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WorkloadMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n9, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.WorkloadOp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.WorkloadOp))
	}
	if len(m.Workloads) > 0 {
		for _, msg := range m.Workloads {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Workload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkloadName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.WorkloadName)))
		i += copy(dAtA[i:], m.WorkloadName)
	}
	if m.WorkloadType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.WorkloadType))
	}
	if len(m.WorkloadImage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.WorkloadImage)))
		i += copy(dAtA[i:], m.WorkloadImage)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.EncapVlan != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.EncapVlan))
	}
	if len(m.IpPrefix) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpPrefix)))
		i += copy(dAtA[i:], m.IpPrefix)
	}
	if len(m.Ipv6Prefix) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Ipv6Prefix)))
		i += copy(dAtA[i:], m.Ipv6Prefix)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Interface) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Interface)))
		i += copy(dAtA[i:], m.Interface)
	}
	if len(m.ParentInterface) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ParentInterface)))
		i += copy(dAtA[i:], m.ParentInterface)
	}
	if m.InterfaceType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.InterfaceType))
	}
	if m.PinnedPort != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.PinnedPort))
	}
	if m.UplinkVlan != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.UplinkVlan))
	}
	if m.WorkloadStatus != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.WorkloadStatus.Size()))
		n10, err := m.WorkloadStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.SecIpPrefix) > 0 {
		for _, s := range m.SecIpPrefix {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SecIpv6Prefix) > 0 {
		for _, s := range m.SecIpv6Prefix {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Cpus != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Cpus))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Memory))
	}
	if len(m.MgmtIp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.MgmtIp)))
		i += copy(dAtA[i:], m.MgmtIp)
	}
	return i, nil
}

func (m *TriggerMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n11, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.TriggerOp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.TriggerOp))
	}
	if m.TriggerMode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.TriggerMode))
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Mode))
	}
	if len(m.Command) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.EntityName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.EntityName)))
		i += copy(dAtA[i:], m.EntityName)
	}
	if m.ForegroundTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ForegroundTimeout))
	}
	if len(m.RunningDir) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.RunningDir)))
		i += copy(dAtA[i:], m.RunningDir)
	}
	if len(m.Stdout) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Stdout)))
		i += copy(dAtA[i:], m.Stdout)
	}
	if len(m.Stderr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Stderr)))
		i += copy(dAtA[i:], m.Stderr)
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ExitCode))
	}
	if len(m.Handle) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Handle)))
		i += copy(dAtA[i:], m.Handle)
	}
	if m.TimedOut {
		dAtA[i] = 0x58
		i++
		if m.TimedOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StdoutOnErr {
		dAtA[i] = 0x60
		i++
		if m.StdoutOnErr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StderrOnErr {
		dAtA[i] = 0x68
		i++
		if m.StderrOnErr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterHealthMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterHealthMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n12, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Health) > 0 {
		for _, msg := range m.Health {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHealth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.ClusterDone {
		dAtA[i] = 0x10
		i++
		if m.ClusterDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HealthCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.HealthCode))
	}
	return i, nil
}

func (m *DataSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSwitch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Speed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Speed))
	}
	return i, nil
}

func (m *TestBedMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestBedMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n13, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.NaplesSimImage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NaplesSimImage)))
		i += copy(dAtA[i:], m.NaplesSimImage)
	}
	if len(m.NaplesImage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NaplesImage)))
		i += copy(dAtA[i:], m.NaplesImage)
	}
	if len(m.VeniceImage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.VeniceImage)))
		i += copy(dAtA[i:], m.VeniceImage)
	}
	if len(m.DriverSources) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.DriverSources)))
		i += copy(dAtA[i:], m.DriverSources)
	}
	if len(m.AllocatedVlans) > 0 {
		dAtA15 := make([]byte, len(m.AllocatedVlans)*10)
		var j14 int
		for _, num := range m.AllocatedVlans {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.TestbedId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.TestbedId))
	}
	if len(m.DataSwitches) > 0 {
		for _, msg := range m.DataSwitches {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RebootNodes {
		dAtA[i] = 0x60
		i++
		if m.RebootNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TestNodesMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestNodesMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n16, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.RebootNodes {
		dAtA[i] = 0x28
		i++
		if m.RebootNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SwitchMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n17, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Op))
	}
	if len(m.DataSwitches) > 0 {
		for _, msg := range m.DataSwitches {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTopoSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestBedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestBedNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Type))
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.CimcIpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.CimcIpAddress)))
		i += copy(dAtA[i:], m.CimcIpAddress)
	}
	if len(m.CimcUsername) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.CimcUsername)))
		i += copy(dAtA[i:], m.CimcUsername)
	}
	if len(m.CimcPassword) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.CimcPassword)))
		i += copy(dAtA[i:], m.CimcPassword)
	}
	if len(m.EsxUsername) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.EsxUsername)))
		i += copy(dAtA[i:], m.EsxUsername)
	}
	if len(m.EsxPassword) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.EsxPassword)))
		i += copy(dAtA[i:], m.EsxPassword)
	}
	if len(m.NicIpAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicIpAddress)))
		i += copy(dAtA[i:], m.NicIpAddress)
	}
	if len(m.NicConsoleIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicConsoleIpAddress)))
		i += copy(dAtA[i:], m.NicConsoleIpAddress)
	}
	if len(m.NicConsolePort) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicConsolePort)))
		i += copy(dAtA[i:], m.NicConsolePort)
	}
	if len(m.NicConsoleUsername) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicConsoleUsername)))
		i += copy(dAtA[i:], m.NicConsoleUsername)
	}
	if len(m.NicConsolePassword) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicConsolePassword)))
		i += copy(dAtA[i:], m.NicConsolePassword)
	}
	if len(m.NicUsername) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicUsername)))
		i += copy(dAtA[i:], m.NicUsername)
	}
	if len(m.NicPassword) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicPassword)))
		i += copy(dAtA[i:], m.NicPassword)
	}
	if len(m.InitScript) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.InitScript)))
		i += copy(dAtA[i:], m.InitScript)
	}
	if len(m.ControlIntf) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.ControlIntf)))
		i += copy(dAtA[i:], m.ControlIntf)
	}
	if len(m.SwitchPortIds) > 0 {
		dAtA19 := make([]byte, len(m.SwitchPortIds)*10)
		var j18 int
		for _, num := range m.SwitchPortIds {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.Os != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Os))
	}
	if len(m.EsxCtrlNodeIpAddress) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.EsxCtrlNodeIpAddress)))
		i += copy(dAtA[i:], m.EsxCtrlNodeIpAddress)
	}
	if len(m.NicUuid) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NicUuid)))
		i += copy(dAtA[i:], m.NicUuid)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *EntityCopyMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityCopyMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n20, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Direction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(m.Direction))
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.EntityName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.EntityName)))
		i += copy(dAtA[i:], m.EntityName)
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DestDir) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTopoSvc(dAtA, i, uint64(len(m.DestDir)))
		i += copy(dAtA[i:], m.DestDir)
	}
	return i, nil
}

func encodeVarintTopoSvc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.NodeOp != 0 {
		n += 1 + sovTopoSvc(uint64(m.NodeOp))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if m.MakeCluster {
		n += 2
	}
	if m.ClusterDone {
		n += 2
	}
	return n
}

func (m *Entity) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTopoSvc(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *VmwareESXConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTopoSvc(uint64(m.Type))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if m.NodeInfo != nil {
		n += m.NodeInfo.Size()
	}
	if m.NodeStatus != nil {
		l = m.NodeStatus.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NodeUuid)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.StartupScript)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.EsxConfig != nil {
		l = m.EsxConfig.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.Os != 0 {
		n += 2 + sovTopoSvc(uint64(m.Os))
	}
	if m.Reload {
		n += 3
	}
	return n
}

func (m *Node_NaplesConfig) Size() (n int) {
	var l int
	_ = l
	if m.NaplesConfig != nil {
		l = m.NaplesConfig.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}
func (m *Node_VeniceConfig) Size() (n int) {
	var l int
	_ = l
	if m.VeniceConfig != nil {
		l = m.VeniceConfig.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}
func (m *Node_ThirdPartyNicConfig) Size() (n int) {
	var l int
	_ = l
	if m.ThirdPartyNicConfig != nil {
		l = m.ThirdPartyNicConfig.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}
func (m *Node_NaplesMultiSimConfig) Size() (n int) {
	var l int
	_ = l
	if m.NaplesMultiSimConfig != nil {
		l = m.NaplesMultiSimConfig.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}
func (m *NaplesMultiSimConfig) Size() (n int) {
	var l int
	_ = l
	if m.NumInstances != 0 {
		n += 1 + sovTopoSvc(uint64(m.NumInstances))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.IpAddrRange)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicType)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.VeniceIps) > 0 {
		for _, s := range m.VeniceIps {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *NaplesConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ControlIntf)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.ControlIp)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.DataIntfs) > 0 {
		for _, s := range m.DataIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if len(m.VeniceIps) > 0 {
		for _, s := range m.VeniceIps {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	l = len(m.NaplesIpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NaplesUsername)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NaplesPassword)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicType)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *ThirdPartyNicConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.NicType)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *MellanoxConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *BroadcomConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *IntelConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.HostIntfs) > 0 {
		for _, s := range m.HostIntfs {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *VenicePeer) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *VeniceConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ControlIntf)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.ControlIp)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.VenicePeers) > 0 {
		for _, e := range m.VenicePeers {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *WorkloadMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.WorkloadOp != 0 {
		n += 1 + sovTopoSvc(uint64(m.WorkloadOp))
	}
	if len(m.Workloads) > 0 {
		for _, e := range m.Workloads {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *Workload) Size() (n int) {
	var l int
	_ = l
	l = len(m.WorkloadName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.WorkloadType != 0 {
		n += 1 + sovTopoSvc(uint64(m.WorkloadType))
	}
	l = len(m.WorkloadImage)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.EncapVlan != 0 {
		n += 1 + sovTopoSvc(uint64(m.EncapVlan))
	}
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Ipv6Prefix)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Interface)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.ParentInterface)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovTopoSvc(uint64(m.InterfaceType))
	}
	if m.PinnedPort != 0 {
		n += 1 + sovTopoSvc(uint64(m.PinnedPort))
	}
	if m.UplinkVlan != 0 {
		n += 1 + sovTopoSvc(uint64(m.UplinkVlan))
	}
	if m.WorkloadStatus != nil {
		l = m.WorkloadStatus.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.SecIpPrefix) > 0 {
		for _, s := range m.SecIpPrefix {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if len(m.SecIpv6Prefix) > 0 {
		for _, s := range m.SecIpv6Prefix {
			l = len(s)
			n += 2 + l + sovTopoSvc(uint64(l))
		}
	}
	if m.Cpus != 0 {
		n += 2 + sovTopoSvc(uint64(m.Cpus))
	}
	if m.Memory != 0 {
		n += 2 + sovTopoSvc(uint64(m.Memory))
	}
	l = len(m.MgmtIp)
	if l > 0 {
		n += 2 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *TriggerMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.TriggerOp != 0 {
		n += 1 + sovTopoSvc(uint64(m.TriggerOp))
	}
	if m.TriggerMode != 0 {
		n += 1 + sovTopoSvc(uint64(m.TriggerMode))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTopoSvc(uint64(m.Mode))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.EntityName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.ForegroundTimeout != 0 {
		n += 1 + sovTopoSvc(uint64(m.ForegroundTimeout))
	}
	l = len(m.RunningDir)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Stdout)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Stderr)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovTopoSvc(uint64(m.ExitCode))
	}
	l = len(m.Handle)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.TimedOut {
		n += 2
	}
	if m.StdoutOnErr {
		n += 2
	}
	if m.StderrOnErr {
		n += 2
	}
	return n
}

func (m *ClusterHealthMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.Health) > 0 {
		for _, e := range m.Health {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *NodeHealth) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.ClusterDone {
		n += 2
	}
	if m.HealthCode != 0 {
		n += 1 + sovTopoSvc(uint64(m.HealthCode))
	}
	return n
}

func (m *DataSwitch) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if m.Speed != 0 {
		n += 1 + sovTopoSvc(uint64(m.Speed))
	}
	return n
}

func (m *TestBedMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NaplesSimImage)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NaplesImage)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.VeniceImage)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.DriverSources)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.AllocatedVlans) > 0 {
		l = 0
		for _, e := range m.AllocatedVlans {
			l += sovTopoSvc(uint64(e))
		}
		n += 1 + sovTopoSvc(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.TestbedId != 0 {
		n += 1 + sovTopoSvc(uint64(m.TestbedId))
	}
	if len(m.DataSwitches) > 0 {
		for _, e := range m.DataSwitches {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	if m.RebootNodes {
		n += 2
	}
	return n
}

func (m *TestNodesMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.RebootNodes {
		n += 2
	}
	return n
}

func (m *SwitchMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovTopoSvc(uint64(m.Op))
	}
	if len(m.DataSwitches) > 0 {
		for _, e := range m.DataSwitches {
			l = e.Size()
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	return n
}

func (m *TestBedNode) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTopoSvc(uint64(m.Type))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.CimcIpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.CimcUsername)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.CimcPassword)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.EsxUsername)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.EsxPassword)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicIpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicConsoleIpAddress)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicConsolePort)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicConsoleUsername)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicConsolePassword)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicUsername)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicPassword)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.InitScript)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.ControlIntf)
	if l > 0 {
		n += 2 + l + sovTopoSvc(uint64(l))
	}
	if len(m.SwitchPortIds) > 0 {
		l = 0
		for _, e := range m.SwitchPortIds {
			l += sovTopoSvc(uint64(e))
		}
		n += 2 + sovTopoSvc(uint64(l)) + l
	}
	if m.Os != 0 {
		n += 2 + sovTopoSvc(uint64(m.Os))
	}
	l = len(m.EsxCtrlNodeIpAddress)
	if l > 0 {
		n += 2 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NicUuid)
	if l > 0 {
		n += 2 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 2 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func (m *EntityCopyMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovTopoSvc(uint64(m.Direction))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	l = len(m.EntityName)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovTopoSvc(uint64(l))
		}
	}
	l = len(m.DestDir)
	if l > 0 {
		n += 1 + l + sovTopoSvc(uint64(l))
	}
	return n
}

func sovTopoSvc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTopoSvc(x uint64) (n int) {
	return sovTopoSvc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOp", wireType)
			}
			m.NodeOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeOp |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakeCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MakeCluster = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterDone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EntityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VmwareESXConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VmwareESXConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VmwareESXConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PersonalityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &Entity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaplesConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeInfo = &Node_NaplesConfig{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VeniceConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeInfo = &Node_VeniceConfig{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThirdPartyNicConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThirdPartyNicConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeInfo = &Node_ThirdPartyNicConfig{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesMultiSimConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaplesMultiSimConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeInfo = &Node_NaplesMultiSimConfig{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeStatus == nil {
				m.NodeStatus = &IotaAPIResponse{}
			}
			if err := m.NodeStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartupScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsxConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EsxConfig == nil {
				m.EsxConfig = &VmwareESXConfig{}
			}
			if err := m.EsxConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			m.Os = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Os |= (TestBedNodeOs(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reload = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesMultiSimConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesMultiSimConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesMultiSimConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInstances", wireType)
			}
			m.NumInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInstances |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddrRange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddrRange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VeniceIps = append(m.VeniceIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIntf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlIntf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataIntfs = append(m.DataIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VeniceIps = append(m.VeniceIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIntfs = append(m.HostIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NaplesIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NaplesUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NaplesPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThirdPartyNicConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThirdPartyNicConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThirdPartyNicConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIntfs = append(m.HostIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MellanoxConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MellanoxConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MellanoxConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIntfs = append(m.HostIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcomConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcomConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcomConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIntfs = append(m.HostIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntelConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIntfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIntfs = append(m.HostIntfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VenicePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VenicePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VenicePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIntf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlIntf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VenicePeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VenicePeers = append(m.VenicePeers, &VenicePeer{})
			if err := m.VenicePeers[len(m.VenicePeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadOp", wireType)
			}
			m.WorkloadOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkloadOp |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workloads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workloads = append(m.Workloads, &Workload{})
			if err := m.Workloads[len(m.Workloads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Workload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkloadName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadType", wireType)
			}
			m.WorkloadType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkloadType |= (WorkloadType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkloadImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapVlan", wireType)
			}
			m.EncapVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncapVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentInterface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentInterface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= (InterfaceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedPort", wireType)
			}
			m.PinnedPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinnedPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkVlan", wireType)
			}
			m.UplinkVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadStatus == nil {
				m.WorkloadStatus = &IotaAPIResponse{}
			}
			if err := m.WorkloadStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecIpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecIpPrefix = append(m.SecIpPrefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecIpv6Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecIpv6Prefix = append(m.SecIpv6Prefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerOp", wireType)
			}
			m.TriggerOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerOp |= (TriggerOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerMode", wireType)
			}
			m.TriggerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerMode |= (TriggerMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (CommandMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForegroundTimeout", wireType)
			}
			m.ForegroundTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForegroundTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stderr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimedOut = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdoutOnErr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdoutOnErr = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StderrOnErr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StderrOnErr = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterHealthMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterHealthMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterHealthMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = append(m.Health, &NodeHealth{})
			if err := m.Health[len(m.Health)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterDone = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCode", wireType)
			}
			m.HealthCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCode |= (NodeHealth_HealthCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (DataSwitch_Speed(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestBedMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestBedMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestBedMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesSimImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NaplesSimImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NaplesImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NaplesImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VeniceImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverSources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverSources = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTopoSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllocatedVlans = append(m.AllocatedVlans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTopoSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTopoSvc
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTopoSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllocatedVlans = append(m.AllocatedVlans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedVlans", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &TestBedNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestbedId", wireType)
			}
			m.TestbedId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestbedId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSwitches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSwitches = append(m.DataSwitches, &DataSwitch{})
			if err := m.DataSwitches[len(m.DataSwitches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebootNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RebootNodes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestNodesMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestNodesMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestNodesMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &TestBedNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebootNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RebootNodes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (SwitchOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSwitches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSwitches = append(m.DataSwitches, &DataSwitch{})
			if err := m.DataSwitches[len(m.DataSwitches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestBedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestBedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestBedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TestBedNodeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CimcIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CimcIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CimcUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CimcUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CimcPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CimcPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsxUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EsxUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsxPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EsxPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConsoleIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicConsoleIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConsolePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicConsolePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConsoleUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicConsoleUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConsolePassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicConsolePassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIntf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlIntf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTopoSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchPortIds = append(m.SwitchPortIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTopoSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTopoSvc
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTopoSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchPortIds = append(m.SwitchPortIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchPortIds", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			m.Os = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Os |= (TestBedNodeOs(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsxCtrlNodeIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EsxCtrlNodeIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityCopyMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityCopyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityCopyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (CopyDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopoSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopoSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopoSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTopoSvc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTopoSvc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopoSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTopoSvc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTopoSvc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTopoSvc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTopoSvc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTopoSvc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("topo_svc.proto", fileDescriptorTopoSvc) }

var fileDescriptorTopoSvc = []byte{
	// 3172 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x4f, 0x73, 0xe3, 0xc6,
	0xb1, 0x17, 0x48, 0x51, 0x24, 0x1b, 0x24, 0x85, 0x1d, 0x69, 0x25, 0x5a, 0xbb, 0x6f, 0x57, 0xa6,
	0xbd, 0xf6, 0x5a, 0xcf, 0xd6, 0xb3, 0x65, 0xd7, 0xbe, 0x67, 0xbf, 0xe7, 0x3f, 0x10, 0x89, 0x95,
	0x50, 0x26, 0x09, 0x3e, 0x90, 0xd2, 0xae, 0x73, 0x08, 0x02, 0x13, 0x23, 0x09, 0xb5, 0x24, 0x80,
	0x02, 0xc0, 0xdd, 0xd5, 0x2d, 0x55, 0xce, 0x29, 0x9f, 0x20, 0xdf, 0x20, 0x87, 0x1c, 0xf2, 0x2d,
	0x52, 0x49, 0xe5, 0x92, 0x1c, 0x92, 0x5b, 0xaa, 0x52, 0x4e, 0xe5, 0x92, 0x1c, 0x7c, 0xca, 0x3d,
	0xd5, 0x33, 0x03, 0x10, 0xfc, 0xb3, 0xff, 0x6c, 0x9d, 0x96, 0xd3, 0xfd, 0xeb, 0xc6, 0x74, 0x4f,
	0x77, 0x4f, 0xf7, 0x68, 0xa1, 0x16, 0xfb, 0x81, 0x6f, 0x45, 0x8f, 0x87, 0xfb, 0x41, 0xe8, 0xc7,
	0x3e, 0x29, 0xbb, 0x7e, 0x6c, 0x8f, 0x7d, 0x87, 0x8e, 0x76, 0x14, 0xfc, 0x69, 0xc5, 0x97, 0x01,
	0x8d, 0x38, 0xb3, 0xf1, 0x17, 0x09, 0x8a, 0x5d, 0xdf, 0xa1, 0x9d, 0xe8, 0x9c, 0x7c, 0x0a, 0x15,
	0x3b, 0x70, 0xad, 0x90, 0x46, 0x81, 0xef, 0x45, 0xb4, 0x2e, 0xed, 0x4a, 0x77, 0xe5, 0x83, 0x9d,
	0xfd, 0x54, 0x7e, 0x5f, 0xf7, 0x63, 0x5b, 0xed, 0xe9, 0xa6, 0x40, 0x98, 0xb2, 0x1d, 0xb8, 0xc9,
	0x82, 0xbc, 0x05, 0x45, 0xcf, 0x77, 0xa8, 0xe5, 0x07, 0xf5, 0xdc, 0xae, 0x74, 0xb7, 0x76, 0x50,
	0xcd, 0x48, 0x1a, 0x81, 0xb9, 0x86, 0x5c, 0x23, 0x20, 0x77, 0xa0, 0x80, 0xbf, 0xa2, 0x7a, 0x7e,
	0x37, 0x7f, 0x57, 0x3e, 0x58, 0xcf, 0xa0, 0x70, 0x27, 0x26, 0xe7, 0x92, 0xd7, 0xa1, 0x32, 0xb6,
	0x1f, 0x51, 0x6b, 0x38, 0x9a, 0x44, 0x31, 0x0d, 0xeb, 0xab, 0xbb, 0xd2, 0xdd, 0x92, 0x29, 0x23,
	0xad, 0xc9, 0x49, 0x08, 0x11, 0x5c, 0xcb, 0xf1, 0x3d, 0x5a, 0x2f, 0x70, 0x88, 0xa0, 0xb5, 0x7c,
	0x8f, 0x36, 0x8e, 0x60, 0x4d, 0xf3, 0x62, 0x37, 0xbe, 0x24, 0xef, 0xc0, 0x2a, 0x1a, 0xce, 0xac,
	0xaa, 0x1d, 0x5c, 0xcf, 0x7c, 0x95, 0x03, 0x06, 0x97, 0x01, 0x35, 0x19, 0x84, 0x10, 0x58, 0xf5,
	0xec, 0x31, 0x65, 0x66, 0x94, 0x4d, 0xf6, 0xbb, 0x71, 0x01, 0xeb, 0xa7, 0xe3, 0x27, 0x76, 0x48,
	0xb5, 0xfe, 0xc3, 0xa6, 0xef, 0x9d, 0xb9, 0xe7, 0x64, 0x07, 0x4a, 0x93, 0x88, 0x86, 0x0c, 0x2a,
	0x31, 0x68, 0xba, 0x46, 0x5e, 0x60, 0x47, 0xd1, 0x13, 0x3f, 0x74, 0x84, 0x9a, 0x74, 0x4d, 0xfe,
	0x03, 0xc0, 0x0d, 0x2c, 0xdb, 0x71, 0x42, 0x1a, 0xa1, 0x17, 0x90, 0x5b, 0x76, 0x03, 0x95, 0x13,
	0x1a, 0xff, 0x28, 0xc0, 0x2a, 0x3a, 0x82, 0xec, 0xcf, 0xec, 0x38, 0x7b, 0x0e, 0x3d, 0x1a, 0x46,
	0xbe, 0x67, 0x8f, 0x66, 0xb7, 0xbd, 0x09, 0x05, 0x77, 0x6c, 0x9f, 0x27, 0xfb, 0xe6, 0x8b, 0x17,
	0x7c, 0x2d, 0xb5, 0x75, 0x75, 0x6a, 0x2b, 0x79, 0x0f, 0x4a, 0x14, 0x7d, 0xe2, 0xd2, 0xa8, 0x5e,
	0x60, 0x87, 0x74, 0x6d, 0xc1, 0x5d, 0x66, 0x0a, 0x21, 0x9f, 0x41, 0xd5, 0xb3, 0x83, 0x11, 0x8d,
	0xac, 0x21, 0x73, 0x4c, 0x7d, 0x8d, 0x05, 0xce, 0x76, 0xf6, 0x60, 0x19, 0x9f, 0xfb, 0xed, 0x78,
	0xc5, 0xac, 0x78, 0x99, 0x35, 0xca, 0x3f, 0xa6, 0x9e, 0x3b, 0xa4, 0x89, 0x7c, 0x71, 0x41, 0xfe,
	0x94, 0xf1, 0xa7, 0xf2, 0x8f, 0x33, 0x6b, 0x72, 0x02, 0x5b, 0xf1, 0x85, 0x1b, 0x3a, 0x56, 0x60,
	0x87, 0xf1, 0xa5, 0xe5, 0xb9, 0xc3, 0x44, 0x51, 0x89, 0x29, 0xba, 0x95, 0x51, 0x34, 0x40, 0x60,
	0x0f, 0x71, 0x5d, 0x77, 0x98, 0xea, 0xdb, 0x88, 0x17, 0xc9, 0xe4, 0x21, 0x6c, 0x0b, 0xb3, 0xc6,
	0x93, 0x51, 0xec, 0x5a, 0x91, 0x3b, 0x4e, 0xf4, 0x96, 0x99, 0xde, 0xdb, 0x0b, 0x06, 0x76, 0x10,
	0xd8, 0x77, 0xc7, 0xa9, 0xe2, 0x4d, 0x6f, 0x09, 0x9d, 0xfc, 0x2f, 0xc8, 0x2c, 0x53, 0xa2, 0xd8,
	0x8e, 0x27, 0x51, 0xbd, 0xf2, 0xc2, 0x3c, 0x03, 0x84, 0xf7, 0x19, 0x9a, 0xdc, 0x80, 0x32, 0x13,
	0x9e, 0x4c, 0x5c, 0xa7, 0x5e, 0xe5, 0xa1, 0x85, 0x84, 0x93, 0x89, 0xeb, 0x90, 0x3b, 0x50, 0x8b,
	0x62, 0x3b, 0x8c, 0x27, 0x81, 0x15, 0x0d, 0x43, 0x37, 0x88, 0xeb, 0x35, 0x86, 0xa8, 0x0a, 0x6a,
	0x9f, 0x11, 0xc9, 0xc7, 0x00, 0x34, 0x7a, 0x9a, 0x58, 0xb3, 0xbe, 0xf0, 0xfd, 0xb9, 0x48, 0x37,
	0xcb, 0x34, 0x7a, 0x2a, 0xf6, 0x7e, 0x17, 0x72, 0x7e, 0x54, 0x57, 0x58, 0x48, 0xd6, 0xb3, 0x8e,
	0xa5, 0x51, 0x7c, 0x48, 0x1d, 0x0c, 0x5c, 0x23, 0x32, 0x73, 0x7e, 0x44, 0xb6, 0x60, 0x2d, 0xa4,
	0x23, 0xdf, 0x76, 0xea, 0xd7, 0x58, 0x5e, 0x8a, 0xd5, 0xa1, 0x2c, 0x0c, 0x70, 0xbd, 0x33, 0xbf,
	0xf1, 0x77, 0x09, 0x36, 0x97, 0xf9, 0x8e, 0xbc, 0x01, 0x55, 0x6f, 0x32, 0xb6, 0x5c, 0x2f, 0x8a,
	0x6d, 0x6f, 0x48, 0x23, 0x96, 0x05, 0x55, 0xb3, 0xe2, 0x4d, 0xc6, 0x7a, 0x42, 0x23, 0x75, 0x28,
	0x7a, 0x34, 0x7e, 0xe2, 0x87, 0x8f, 0x44, 0xcc, 0x27, 0x4b, 0xe4, 0x9c, 0xdb, 0x31, 0x7d, 0x62,
	0x5f, 0x8a, 0x90, 0x4f, 0x96, 0xa4, 0x01, 0x55, 0x91, 0x0f, 0x56, 0x68, 0x7b, 0xe7, 0x49, 0xe4,
	0xcb, 0x3c, 0x25, 0x4c, 0x24, 0xe1, 0xd6, 0x03, 0x3b, 0xa4, 0x5e, 0xcc, 0x4a, 0x4a, 0xd9, 0x14,
	0x2b, 0xf2, 0x1a, 0x94, 0x30, 0xba, 0x58, 0x56, 0xae, 0x89, 0x0f, 0xba, 0x43, 0x4c, 0x41, 0x4c,
	0x33, 0x11, 0xc4, 0x6e, 0x10, 0xd5, 0x8b, 0xbb, 0x79, 0x4c, 0x33, 0x4e, 0xd1, 0x83, 0xa8, 0xf1,
	0x9b, 0x1c, 0x54, 0xb2, 0x49, 0xc0, 0x6a, 0x97, 0xef, 0xc5, 0xa1, 0x3f, 0xb2, 0x5c, 0x2f, 0x3e,
	0x13, 0x05, 0x44, 0x16, 0x34, 0xdd, 0x8b, 0xcf, 0x50, 0x65, 0x0a, 0x09, 0x84, 0x81, 0xe5, 0x04,
	0x10, 0x20, 0xdb, 0xb1, 0x63, 0x9b, 0x89, 0xf3, 0x62, 0x5a, 0x36, 0xcb, 0x48, 0x41, 0xe1, 0x68,
	0x6e, 0x43, 0xab, 0x73, 0x1b, 0x42, 0xf6, 0x85, 0x1f, 0xc5, 0x42, 0xba, 0xc0, 0xd9, 0x48, 0xe1,
	0xd2, 0x7b, 0x70, 0x4d, 0x04, 0x7f, 0xa6, 0x78, 0x70, 0x93, 0xd7, 0x39, 0x43, 0x4f, 0x4b, 0xc8,
	0xdb, 0x20, 0x48, 0x56, 0x5a, 0x0e, 0x8b, 0x0c, 0x59, 0xe3, 0xe4, 0x93, 0xa4, 0x28, 0x4e, 0x81,
	0x69, 0x6d, 0x2c, 0x65, 0x81, 0xbd, 0xa4, 0x42, 0x66, 0xfd, 0x5c, 0x9e, 0xf1, 0x73, 0xc3, 0x80,
	0x8d, 0x25, 0x39, 0x3c, 0x23, 0x21, 0x2d, 0x9c, 0x4c, 0xc6, 0xd2, 0xdc, 0x9c, 0xa5, 0x8d, 0xff,
	0x82, 0x5a, 0x87, 0x8e, 0x46, 0xb6, 0xe7, 0x27, 0x21, 0xfe, 0x7c, 0xd7, 0xa0, 0xc0, 0x61, 0xe8,
	0xdb, 0xce, 0xd0, 0x1f, 0xbf, 0x9c, 0xc0, 0xbb, 0x20, 0xeb, 0x5e, 0x4c, 0x47, 0x2f, 0x87, 0x3e,
	0x06, 0xe0, 0xd5, 0xae, 0x47, 0x69, 0x88, 0xd9, 0xce, 0xc0, 0xd9, 0x4b, 0x06, 0x09, 0x5d, 0xf4,
	0xe7, 0x6c, 0x69, 0xcf, 0xcd, 0x5f, 0x24, 0x3f, 0x97, 0xa0, 0x92, 0x2d, 0x9c, 0x57, 0x10, 0x73,
	0xff, 0x03, 0xa2, 0xf4, 0x5a, 0x01, 0xa5, 0x61, 0x72, 0x85, 0x5f, 0x5f, 0xa8, 0xd4, 0xb8, 0x77,
	0x53, 0x7e, 0x9c, 0xfe, 0x8e, 0x1a, 0xbf, 0x96, 0x40, 0x7e, 0xe0, 0x87, 0x8f, 0xb0, 0x04, 0x5c,
	0x41, 0xb3, 0xb1, 0x0f, 0xf2, 0x13, 0xa1, 0xed, 0x99, 0x0d, 0x07, 0x24, 0x08, 0x23, 0x20, 0x1f,
	0x40, 0x39, 0x59, 0x25, 0xbb, 0xde, 0xc8, 0xa0, 0x93, 0x9d, 0x99, 0x53, 0x54, 0xe3, 0x8f, 0x05,
	0x28, 0x25, 0x74, 0x2c, 0x47, 0xe9, 0xf7, 0x32, 0x67, 0x51, 0x49, 0x88, 0xec, 0x3c, 0xfe, 0x2f,
	0x03, 0x62, 0x91, 0xc8, 0xb7, 0xb5, 0xbd, 0xe4, 0x43, 0xec, 0xda, 0x4e, 0xa5, 0x59, 0x9c, 0xde,
	0x81, 0x5a, 0x2a, 0xcd, 0xef, 0x71, 0x5e, 0xb9, 0x52, 0x9d, 0x3a, 0xbb, 0xcf, 0x93, 0xfa, 0x9f,
	0xb9, 0xb5, 0x59, 0xfd, 0x4f, 0x22, 0x82, 0x7a, 0x43, 0x3b, 0xb0, 0x1e, 0x8f, 0x6c, 0x8f, 0x15,
	0xaf, 0xaa, 0x59, 0x66, 0x94, 0xd3, 0x91, 0xed, 0xa1, 0xac, 0x1b, 0x58, 0x41, 0x48, 0xcf, 0xdc,
	0xa7, 0x22, 0x9b, 0x4b, 0x6e, 0xd0, 0x63, 0x6b, 0x72, 0x1b, 0x64, 0x37, 0x78, 0x7c, 0x2f, 0x61,
	0xf3, 0x14, 0x06, 0x24, 0x4d, 0x01, 0x63, 0x7b, 0x98, 0xc6, 0x1b, 0x4f, 0x5d, 0x18, 0xdb, 0xc3,
	0xa4, 0x10, 0xdc, 0x84, 0xb2, 0xeb, 0xc5, 0x34, 0x3c, 0xb3, 0x87, 0x49, 0xde, 0x4e, 0x09, 0xe4,
	0x1d, 0x50, 0x78, 0x19, 0xb5, 0xa6, 0x20, 0xe0, 0x15, 0x85, 0xd3, 0xf5, 0x14, 0xfa, 0x39, 0xd4,
	0x52, 0x0c, 0xf7, 0xa4, 0xbc, 0x70, 0xe1, 0xa4, 0x68, 0xe6, 0xca, 0xaa, 0x9b, 0x5d, 0xe2, 0x56,
	0x03, 0xd7, 0xf3, 0xa8, 0x63, 0x05, 0x7e, 0x18, 0xb3, 0x1b, 0xb6, 0x6a, 0x02, 0x27, 0xf5, 0xfc,
	0x30, 0x46, 0xc0, 0x24, 0x18, 0xb9, 0xde, 0x23, 0xee, 0xa9, 0x2a, 0x07, 0x70, 0x12, 0x73, 0x55,
	0x13, 0xd6, 0xd3, 0xd3, 0x10, 0xf7, 0x74, 0xed, 0x85, 0x21, 0x9a, 0x1e, 0xa0, 0xb8, 0xab, 0x1b,
	0x50, 0x8d, 0xe8, 0xd0, 0x9a, 0xfa, 0x7c, 0x9d, 0x65, 0xbb, 0x1c, 0xd1, 0xa1, 0x9e, 0xb8, 0xfd,
	0x2d, 0x58, 0xe7, 0x98, 0xa9, 0xeb, 0x15, 0x86, 0xaa, 0x32, 0x54, 0xea, 0x7d, 0x02, 0xab, 0xc3,
	0x60, 0x12, 0xb1, 0xcb, 0xb4, 0x6a, 0xb2, 0xdf, 0x78, 0x4f, 0x8d, 0xe9, 0xd8, 0x0f, 0x2f, 0xeb,
	0x84, 0x51, 0xc5, 0x8a, 0x6c, 0x43, 0x71, 0x7c, 0x3e, 0x8e, 0x31, 0x85, 0x37, 0xf8, 0x05, 0x86,
	0x4b, 0x3d, 0x68, 0xfc, 0x53, 0x02, 0x18, 0x84, 0xee, 0xf9, 0x39, 0x0d, 0xaf, 0x20, 0x09, 0x3f,
	0x04, 0x88, 0xb9, 0xb2, 0x69, 0x0e, 0x6e, 0x66, 0x7b, 0x02, 0xce, 0x34, 0x02, 0xb3, 0x1c, 0x27,
	0x3f, 0xc9, 0xc7, 0x50, 0x49, 0x84, 0x10, 0xc5, 0x82, 0xbc, 0x76, 0xb0, 0xb5, 0x28, 0xd6, 0xc1,
	0x61, 0x40, 0x8e, 0xa7, 0x0b, 0xb2, 0x0f, 0xa5, 0xa1, 0x3f, 0x1e, 0xdb, 0x9e, 0xc3, 0x2f, 0x34,
	0xf9, 0x80, 0x64, 0xc4, 0x9a, 0x9c, 0x65, 0xa6, 0x98, 0xc6, 0x2f, 0xf3, 0x50, 0x14, 0x54, 0xb2,
	0x07, 0xab, 0xec, 0x73, 0xd2, 0xc2, 0xe7, 0x04, 0x82, 0x7d, 0x8e, 0x61, 0xb0, 0x79, 0x10, 0x3a,
	0x92, 0xb6, 0x42, 0x2c, 0x67, 0x93, 0x2f, 0x3f, 0x97, 0x7c, 0xb7, 0x41, 0x66, 0x3d, 0xf1, 0x65,
	0x36, 0x37, 0x81, 0x93, 0xba, 0xbc, 0xaf, 0x26, 0x67, 0x7e, 0x48, 0xcf, 0x43, 0x7f, 0xe2, 0x39,
	0x56, 0xec, 0x8e, 0xa9, 0x3f, 0x89, 0x45, 0x96, 0x5e, 0x9b, 0x72, 0x06, 0x9c, 0x81, 0xfa, 0xc2,
	0x89, 0xe7, 0xb9, 0xde, 0xb9, 0xe5, 0xb8, 0xa1, 0xc8, 0x57, 0x10, 0xa4, 0x96, 0x1b, 0xe2, 0xf1,
	0x47, 0xb1, 0x83, 0x3a, 0x78, 0xb2, 0x8a, 0x95, 0xa0, 0xd3, 0x30, 0x14, 0x39, 0x2a, 0x56, 0xb8,
	0x7b, 0xfa, 0xd4, 0x8d, 0xad, 0x21, 0x3a, 0x02, 0xf3, 0xb3, 0x60, 0x96, 0x90, 0xd0, 0x44, 0xa3,
	0xb7, 0x60, 0xed, 0xc2, 0xf6, 0x9c, 0x51, 0x92, 0x94, 0x62, 0x85, 0x42, 0xb8, 0x53, 0xc7, 0xc2,
	0xef, 0xc8, 0xac, 0x93, 0x2b, 0x31, 0x82, 0x31, 0x89, 0x59, 0x80, 0xb3, 0x6f, 0x5a, 0xbe, 0x67,
	0xe1, 0x07, 0x2b, 0x7c, 0x04, 0xe3, 0x44, 0xc3, 0xd3, 0xc2, 0x50, 0x60, 0x68, 0x18, 0x26, 0x98,
	0x6a, 0x8a, 0xa1, 0x61, 0xc8, 0x30, 0x8d, 0x9f, 0x4a, 0xa0, 0x88, 0xa9, 0xee, 0x98, 0xda, 0xa3,
	0xf8, 0xe2, 0x0a, 0xa2, 0xf3, 0x3d, 0x58, 0xbb, 0x60, 0xba, 0xd8, 0x9d, 0x3f, 0x7b, 0x4b, 0x61,
	0x9b, 0xca, 0x3f, 0x64, 0x0a, 0x50, 0xe3, 0x3b, 0x09, 0x60, 0x4a, 0x9e, 0x3d, 0x69, 0x69, 0xee,
	0xa4, 0xe7, 0x07, 0xcf, 0xdc, 0xc2, 0xe0, 0x49, 0x54, 0x90, 0xb9, 0x62, 0xee, 0x6d, 0x1e, 0xe5,
	0xbb, 0x4b, 0xb7, 0xb0, 0xcf, 0xff, 0xc1, 0x53, 0x30, 0xe1, 0x22, 0xfd, 0xdd, 0xf8, 0x31, 0xc0,
	0x94, 0x43, 0xaa, 0x50, 0x3e, 0xd6, 0xd4, 0xf6, 0xe0, 0xd8, 0x32, 0xbe, 0x54, 0x56, 0xc8, 0x3a,
	0xc8, 0x5d, 0xb5, 0xd7, 0xd6, 0xfa, 0x56, 0xcb, 0x78, 0xd0, 0x55, 0x24, 0xe4, 0x77, 0x8d, 0x96,
	0xc6, 0x97, 0x39, 0x52, 0x81, 0x92, 0xda, 0xeb, 0xf1, 0x55, 0x9e, 0x6c, 0xc0, 0x7a, 0xd7, 0x18,
	0x58, 0x3d, 0xd3, 0x38, 0xd5, 0xfb, 0xba, 0xd1, 0xd5, 0x5a, 0xca, 0x6a, 0xe3, 0x4f, 0x12, 0x40,
	0xcb, 0x8e, 0xed, 0xfe, 0x13, 0x37, 0x1e, 0x5e, 0x90, 0x1a, 0xe4, 0xdc, 0x40, 0x98, 0x9a, 0x73,
	0x83, 0x99, 0xf1, 0x36, 0xf7, 0x9c, 0xf1, 0x36, 0x3f, 0x37, 0xde, 0x6e, 0x42, 0x01, 0x8b, 0x6e,
	0xd2, 0x73, 0xf2, 0x05, 0xf9, 0x00, 0x0a, 0x51, 0x40, 0xa9, 0xc3, 0xc2, 0xbd, 0x76, 0x70, 0x23,
	0xe3, 0x89, 0xe9, 0x1e, 0xf6, 0xfb, 0x08, 0x31, 0x39, 0xb2, 0x71, 0x0f, 0x0a, 0x6c, 0x4d, 0x6a,
	0x00, 0xec, 0x87, 0xf5, 0xc1, 0xfb, 0xef, 0x1f, 0x29, 0x2b, 0x68, 0x6a, 0xb2, 0x3e, 0x52, 0xa4,
	0x29, 0xdb, 0x9e, 0xc4, 0xbe, 0x92, 0x6b, 0x7c, 0x97, 0x07, 0x10, 0xe3, 0xc8, 0x15, 0x84, 0xd1,
	0x5d, 0x50, 0x44, 0xd3, 0x8a, 0x03, 0x60, 0x76, 0xc0, 0x16, 0x5d, 0x6b, 0xdf, 0x1d, 0xf3, 0x9b,
	0xf9, 0x75, 0xa8, 0x24, 0x3d, 0x73, 0xe6, 0xfa, 0x96, 0x45, 0xbb, 0x9c, 0x40, 0x92, 0xa6, 0x9c,
	0x41, 0xc4, 0xec, 0x21, 0xda, 0x72, 0x06, 0xb9, 0x03, 0x35, 0x27, 0x74, 0x1f, 0xd3, 0xd0, 0x8a,
	0xfc, 0x49, 0x38, 0x64, 0x23, 0x38, 0x6b, 0x03, 0x38, 0xb5, 0xcf, 0x89, 0xd8, 0x4b, 0xdb, 0xa3,
	0x91, 0x3f, 0xb4, 0x63, 0xea, 0xb0, 0x3b, 0x0c, 0xdb, 0xf3, 0xfc, 0xdd, 0xaa, 0x59, 0x4b, 0xc9,
	0x78, 0x8f, 0x45, 0xe4, 0xdd, 0xe4, 0xb9, 0xa5, 0xc8, 0xb2, 0x60, 0x6b, 0xf9, 0xcc, 0x96, 0xbc,
	0xba, 0x64, 0x0f, 0xbd, 0xf4, 0x9c, 0x43, 0x2f, 0x2f, 0xbe, 0x69, 0xc4, 0x34, 0x8a, 0xbf, 0xa6,
	0x8e, 0xe5, 0x3a, 0xac, 0x82, 0x54, 0xcd, 0xb2, 0xa0, 0xe8, 0x0e, 0xf9, 0x04, 0xaa, 0x6c, 0x56,
	0x89, 0xd8, 0x31, 0xd3, 0xa8, 0x2e, 0x2f, 0xa4, 0xe4, 0x34, 0x0a, 0xcc, 0x8a, 0x93, 0xfe, 0xe6,
	0x0f, 0x41, 0x21, 0xfd, 0xda, 0xf7, 0x63, 0x8b, 0xdb, 0x21, 0x4a, 0x0c, 0xa7, 0xe1, 0xde, 0xa3,
	0xc6, 0x9f, 0x25, 0xa8, 0xa0, 0x31, 0x6c, 0x75, 0x05, 0x67, 0x9e, 0xfa, 0x2c, 0xf7, 0xaa, 0x3e,
	0xcb, 0x3f, 0xc7, 0x67, 0xab, 0x73, 0x3e, 0x9b, 0x37, 0xac, 0xb0, 0x68, 0xd8, 0xaf, 0x24, 0x28,
	0x73, 0x47, 0x5c, 0x81, 0x55, 0x6f, 0x40, 0x2e, 0xbd, 0xa6, 0xb3, 0xcd, 0x2f, 0xff, 0x80, 0x11,
	0x98, 0x39, 0x3f, 0x58, 0x3c, 0xa9, 0xfc, 0x4b, 0x9f, 0x54, 0xe3, 0x77, 0x6b, 0x20, 0x67, 0xfc,
	0xf3, 0x9c, 0x07, 0xac, 0x0c, 0x2a, 0xf3, 0x80, 0xf5, 0xfc, 0x79, 0x06, 0x3b, 0xa5, 0xa1, 0x3b,
	0x1e, 0x5a, 0x0b, 0xcf, 0x59, 0x55, 0x24, 0x4f, 0xe7, 0xd1, 0x37, 0x80, 0x11, 0xa6, 0xd3, 0x28,
	0x77, 0x7c, 0x05, 0x89, 0xe9, 0x2c, 0x9a, 0x80, 0xd2, 0xd3, 0x29, 0x4c, 0x41, 0xbd, 0xcc, 0x09,
	0xd1, 0xe8, 0xe9, 0x54, 0x11, 0xbf, 0x82, 0x65, 0x1a, 0x3d, 0x4d, 0xf5, 0x08, 0x48, 0xaa, 0xa6,
	0x98, 0x42, 0x52, 0x2d, 0x6f, 0x42, 0x0d, 0x67, 0xd3, 0xcc, 0xb6, 0x79, 0x66, 0x55, 0x3c, 0x37,
	0xb3, 0xeb, 0x0f, 0x61, 0x4b, 0xbc, 0x5c, 0x45, 0xfe, 0x88, 0x66, 0xd1, 0x3c, 0xd7, 0x36, 0x3c,
	0x36, 0xec, 0x22, 0x73, 0x2a, 0x84, 0xc5, 0x29, 0x23, 0xc4, 0x9a, 0x5d, 0x10, 0xc5, 0x29, 0x85,
	0xb3, 0x86, 0xf7, 0x7d, 0xd8, 0xcc, 0x22, 0x53, 0x93, 0x64, 0x86, 0x26, 0x53, 0x74, 0x6a, 0xd9,
	0x9c, 0x44, 0x6a, 0x61, 0x65, 0x5e, 0x22, 0xeb, 0x2e, 0x94, 0x48, 0x75, 0x57, 0x45, 0x01, 0x74,
	0x87, 0x59, 0x77, 0x21, 0x24, 0x55, 0x56, 0x4b, 0x21, 0xa9, 0x16, 0x9c, 0x43, 0x3c, 0x37, 0x4e,
	0x1e, 0xb0, 0xd6, 0xc5, 0x1c, 0xe2, 0xb9, 0xb1, 0x78, 0xbd, 0x9a, 0x1f, 0x63, 0x95, 0xc5, 0x31,
	0x16, 0x9b, 0x6a, 0x16, 0x95, 0xcc, 0x25, 0x96, 0xeb, 0x60, 0xdf, 0x8c, 0xd5, 0xb1, 0xca, 0xc9,
	0xe8, 0x12, 0xdd, 0x89, 0xc4, 0x6b, 0x16, 0x79, 0x89, 0xd7, 0xac, 0x7b, 0x50, 0x67, 0x4f, 0x66,
	0x71, 0x38, 0xb2, 0xf8, 0xf3, 0xd5, 0xf4, 0x80, 0x78, 0x8f, 0xbd, 0x49, 0xa3, 0xa7, 0xcd, 0x38,
	0x1c, 0xa1, 0xd0, 0xf4, 0x84, 0xc4, 0xc3, 0x04, 0x7b, 0xad, 0xdb, 0x4c, 0x1f, 0x26, 0xd8, 0x63,
	0xdd, 0x4c, 0x8b, 0x71, 0x7d, 0xb6, 0xc5, 0x68, 0xfc, 0x4b, 0x82, 0x2a, 0x7f, 0x69, 0x6d, 0xfa,
	0xc1, 0xe5, 0x15, 0x64, 0xff, 0x3d, 0x28, 0x3b, 0x6e, 0x48, 0x87, 0xb1, 0xeb, 0x7b, 0xa2, 0x08,
	0xd4, 0x67, 0xba, 0xe0, 0xe0, 0xb2, 0x95, 0xf0, 0xcd, 0x29, 0xf4, 0x07, 0xb6, 0xbc, 0x9b, 0x50,
	0x38, 0x73, 0x47, 0x34, 0x79, 0xe7, 0xe0, 0x0b, 0x74, 0x8a, 0x43, 0xa3, 0x38, 0xd3, 0xd6, 0x16,
	0x71, 0xdd, 0x72, 0xc3, 0xbd, 0x77, 0x21, 0x67, 0x04, 0xa4, 0x04, 0xab, 0x5d, 0xa3, 0xab, 0x29,
	0x2b, 0xa4, 0x08, 0x79, 0xb5, 0xd5, 0x52, 0x24, 0x02, 0xb0, 0xd6, 0xd2, 0xda, 0xda, 0x40, 0x53,
	0x72, 0x48, 0x3c, 0xd2, 0x06, 0x4a, 0x7e, 0xef, 0x67, 0x79, 0x58, 0x9f, 0x7b, 0x0c, 0x27, 0x9b,
	0xa0, 0xf4, 0x34, 0xb3, 0x6f, 0x74, 0xd5, 0xb6, 0x3e, 0xf8, 0xca, 0x12, 0x7a, 0x76, 0x60, 0x6b,
	0x86, 0xca, 0x7b, 0xa7, 0xbe, 0xde, 0x51, 0x24, 0xb2, 0x0b, 0x37, 0x97, 0xf0, 0x3a, 0x27, 0xed,
	0x81, 0xce, 0x10, 0x39, 0xb2, 0x05, 0x24, 0x8b, 0x38, 0xd5, 0xba, 0x7a, 0x53, 0x53, 0xf2, 0xe4,
	0x4d, 0xd8, 0x5d, 0xae, 0xd5, 0x7a, 0xa0, 0x0f, 0x8e, 0xad, 0xff, 0xd7, 0x3a, 0x27, 0xca, 0xea,
	0xbc, 0x34, 0x47, 0x29, 0x05, 0x72, 0x03, 0xb6, 0x97, 0x48, 0x1f, 0xea, 0x83, 0x07, 0xca, 0xda,
	0x33, 0x36, 0x85, 0x4c, 0xab, 0xa7, 0x99, 0xf7, 0x95, 0x22, 0xb9, 0x0d, 0x37, 0xb2, 0x88, 0xc1,
	0xb1, 0x6e, 0xb6, 0xac, 0x9e, 0x6a, 0x22, 0x5a, 0x6f, 0x2a, 0x25, 0x52, 0x87, 0xcd, 0x2c, 0xa0,
	0xa3, 0xb5, 0xdb, 0x6a, 0xd7, 0x78, 0xa8, 0x94, 0xe7, 0x39, 0x87, 0xa6, 0xa1, 0xb6, 0x9a, 0x46,
	0x47, 0x01, 0x72, 0x1d, 0xae, 0x65, 0x39, 0x7a, 0x77, 0xa0, 0xb5, 0x15, 0x99, 0xdc, 0x84, 0x7a,
	0x96, 0xdc, 0x34, 0x3a, 0x1d, 0xb5, 0xdb, 0xb2, 0xb0, 0xe3, 0x54, 0x2a, 0x7b, 0x3d, 0x80, 0xe9,
	0x1f, 0x51, 0xf0, 0x00, 0xb4, 0xee, 0x80, 0x6d, 0xe9, 0xab, 0x9e, 0x96, 0x1c, 0xc0, 0x1c, 0xf5,
	0xd8, 0xe8, 0x0f, 0x14, 0x09, 0x5d, 0x33, 0x83, 0xe5, 0xae, 0xc9, 0xed, 0xfd, 0x08, 0xaa, 0x33,
	0x03, 0x3e, 0xd9, 0x86, 0x0d, 0xdc, 0x8b, 0x79, 0x5f, 0x6d, 0x6a, 0x33, 0x7a, 0xb7, 0x80, 0xcc,
	0x31, 0x4e, 0xfb, 0x7d, 0x45, 0x42, 0x13, 0xe7, 0xe8, 0x7d, 0x53, 0x37, 0x4e, 0x95, 0xdc, 0xde,
	0xef, 0x25, 0xa8, 0x64, 0xdf, 0x61, 0x50, 0xc5, 0x03, 0xc3, 0xfc, 0xb2, 0x6d, 0xa8, 0xad, 0x19,
	0xd5, 0x37, 0x60, 0x7b, 0x96, 0xde, 0x34, 0xba, 0x03, 0x55, 0xef, 0x6a, 0xa6, 0x22, 0xa1, 0x3d,
	0xb3, 0xcc, 0x53, 0x0c, 0x94, 0x9b, 0x50, 0x9f, 0xa5, 0x1e, 0xaa, 0xa6, 0x66, 0x75, 0xb4, 0x81,
	0xda, 0x56, 0xf2, 0xe4, 0x0e, 0xbc, 0xfe, 0x2c, 0xae, 0xd5, 0x51, 0x9b, 0xd6, 0x69, 0x5b, 0xed,
	0x2a, 0xab, 0xe4, 0x3f, 0xe1, 0xed, 0x17, 0xc2, 0x2c, 0xad, 0xdb, 0x54, 0x7b, 0x4a, 0x61, 0x4f,
	0x85, 0x72, 0x3a, 0x67, 0x63, 0x67, 0x9c, 0x35, 0xa0, 0x0a, 0x65, 0xed, 0xa1, 0xd6, 0xb4, 0x9a,
	0x9d, 0x56, 0x5f, 0xc9, 0xa3, 0x9d, 0x03, 0xcd, 0xec, 0xe8, 0x5d, 0x75, 0xa0, 0x59, 0x6a, 0xbb,
	0xcd, 0xe9, 0xab, 0x7b, 0x36, 0xc8, 0x99, 0x99, 0x1b, 0xa5, 0x3a, 0x38, 0x49, 0x08, 0x25, 0x04,
	0x6a, 0x03, 0x53, 0x3f, 0x3a, 0xd2, 0x4c, 0xab, 0xaf, 0x99, 0xba, 0xda, 0xe6, 0xc6, 0x27, 0xb4,
	0x9e, 0x6a, 0xaa, 0xed, 0xb6, 0xd6, 0x56, 0x72, 0xe4, 0x35, 0xb8, 0x9e, 0x50, 0xd9, 0x28, 0x92,
	0xb2, 0xf2, 0x7b, 0x06, 0xc8, 0x99, 0x39, 0x9b, 0x28, 0x50, 0x99, 0x86, 0x50, 0x72, 0x8c, 0x09,
	0xe5, 0xbe, 0x61, 0x6a, 0x47, 0xa6, 0x71, 0xd2, 0x6d, 0xf1, 0x00, 0x49, 0xe8, 0x87, 0x6a, 0xf3,
	0x4b, 0x41, 0xcf, 0xed, 0x7d, 0x02, 0xa5, 0xa4, 0x6f, 0x21, 0x32, 0x14, 0x8d, 0x5e, 0xa2, 0x08,
	0xa7, 0x81, 0xe3, 0x93, 0x81, 0xd5, 0x33, 0xcc, 0x01, 0xc6, 0xc1, 0x35, 0xa8, 0x76, 0x0d, 0x2b,
	0x43, 0xca, 0xed, 0x7d, 0x23, 0xc1, 0xfa, 0x5c, 0x07, 0x82, 0xf5, 0x61, 0xa0, 0xf5, 0x07, 0x87,
	0x1a, 0x0f, 0xea, 0x99, 0x38, 0x40, 0xbb, 0x16, 0x78, 0xbc, 0x74, 0xd4, 0x61, 0x73, 0x91, 0x75,
	0xfc, 0x40, 0xc9, 0x61, 0x76, 0x2e, 0x72, 0xa6, 0x35, 0x25, 0xbf, 0xf7, 0x13, 0xa8, 0xce, 0x5c,
	0x33, 0x0b, 0x9f, 0x31, 0xfa, 0x56, 0x5b, 0xef, 0x9e, 0x3c, 0xe4, 0x91, 0x38, 0xcf, 0xba, 0x6f,
	0x6a, 0xda, 0x61, 0x1f, 0x5d, 0xb4, 0x0d, 0x1b, 0xf3, 0x4c, 0xad, 0xff, 0x50, 0xc9, 0xed, 0xdd,
	0x83, 0xea, 0x4c, 0x59, 0xc7, 0xa1, 0xb0, 0xa5, 0x9b, 0x89, 0x59, 0x58, 0x51, 0x75, 0xd3, 0xd2,
	0x71, 0x7a, 0x94, 0xa1, 0x88, 0xbf, 0x8d, 0x93, 0x81, 0x92, 0x3b, 0xf8, 0xa6, 0x04, 0xf2, 0xc0,
	0x0f, 0xfc, 0x91, 0x7f, 0x7e, 0xa9, 0x06, 0x2e, 0xf9, 0x0c, 0x2a, 0xec, 0x6f, 0x2e, 0xa3, 0x11,
	0x1f, 0x51, 0xae, 0x2f, 0xde, 0x94, 0x9d, 0xe8, 0x7c, 0x67, 0x39, 0xb9, 0xb1, 0x42, 0x3e, 0x05,
	0x59, 0xf7, 0xdc, 0x58, 0xd0, 0x5e, 0x59, 0xfc, 0x0b, 0xa8, 0x35, 0x47, 0xd4, 0xf6, 0x4e, 0x82,
	0xef, 0xab, 0xe1, 0x73, 0x28, 0xe3, 0x06, 0x58, 0x4f, 0x4d, 0xb6, 0xe7, 0x50, 0xc9, 0xd0, 0xb0,
	0xf3, 0x2c, 0x06, 0xdb, 0x02, 0xb0, 0x2d, 0x7c, 0x7f, 0x0d, 0x2a, 0x5c, 0x6b, 0xf9, 0x49, 0xc4,
	0xd2, 0xd0, 0x66, 0xe7, 0xb1, 0xb9, 0xd0, 0x85, 0xa3, 0x96, 0xa5, 0xd4, 0xc6, 0x0a, 0xf9, 0x08,
	0x4a, 0xaa, 0xe3, 0xf0, 0x2d, 0x90, 0xb9, 0x97, 0x04, 0x94, 0x5b, 0x42, 0x6b, 0xac, 0x90, 0xff,
	0x06, 0xd9, 0x64, 0x7f, 0x78, 0xfb, 0x1e, 0x82, 0x2d, 0x3a, 0xa2, 0x31, 0x7d, 0x55, 0xc1, 0x8f,
	0xa0, 0x74, 0x44, 0xe3, 0x57, 0x95, 0xfa, 0x02, 0x2a, 0xaa, 0xe3, 0x24, 0x75, 0x39, 0x22, 0x5b,
	0x4b, 0x5e, 0xcd, 0x51, 0xfa, 0x19, 0x74, 0xae, 0xe1, 0x88, 0xc6, 0x3f, 0x44, 0x43, 0x13, 0xd6,
	0xb9, 0xc9, 0x3f, 0x44, 0xc9, 0xc7, 0x50, 0x14, 0xd5, 0x74, 0x36, 0x4e, 0xd3, 0x67, 0xd7, 0x9d,
	0xe5, 0xe4, 0xc6, 0x0a, 0x39, 0x02, 0xd2, 0xbc, 0xa0, 0xc3, 0x47, 0x33, 0x4f, 0x61, 0x4b, 0x7d,
	0x98, 0x7d, 0x3f, 0x99, 0x7f, 0x38, 0x6b, 0xac, 0x90, 0xc3, 0xe4, 0x42, 0xc6, 0xfc, 0x27, 0xf5,
	0x85, 0xbf, 0xde, 0x8b, 0x9e, 0x72, 0xe7, 0x99, 0x9c, 0xc6, 0xca, 0xa1, 0xf2, 0xdb, 0x6f, 0x6f,
	0x49, 0x7f, 0xf8, 0xf6, 0x96, 0xf4, 0xd7, 0x6f, 0x6f, 0x49, 0xbf, 0xf8, 0xdb, 0xad, 0x95, 0xaf,
	0xd7, 0xd8, 0xff, 0x19, 0xf9, 0xf0, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x98, 0x46, 0x92, 0x78,
	0x62, 0x22, 0x00, 0x00,
}
