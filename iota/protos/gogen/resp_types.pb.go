// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: resp_types.proto

package iotamodel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type IotaAPIResponse_APIResponseType int32

const (
	IotaAPIResponse_API_STATUS_OK    IotaAPIResponse_APIResponseType = 0
	IotaAPIResponse_API_BAD_REQUEST  IotaAPIResponse_APIResponseType = 1
	IotaAPIResponse_API_SERVER_ERROR IotaAPIResponse_APIResponseType = 2
	IotaAPIResponse_API_AUTH_FAILURE IotaAPIResponse_APIResponseType = 3
)

var IotaAPIResponse_APIResponseType_name = map[int32]string{
	0: "API_STATUS_OK",
	1: "API_BAD_REQUEST",
	2: "API_SERVER_ERROR",
	3: "API_AUTH_FAILURE",
}
var IotaAPIResponse_APIResponseType_value = map[string]int32{
	"API_STATUS_OK":    0,
	"API_BAD_REQUEST":  1,
	"API_SERVER_ERROR": 2,
	"API_AUTH_FAILURE": 3,
}

func (x IotaAPIResponse_APIResponseType) String() string {
	return proto.EnumName(IotaAPIResponse_APIResponseType_name, int32(x))
}
func (IotaAPIResponse_APIResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRespTypes, []int{0, 0}
}

type NodeStatus_HealthCodeType int32

const (
	NodeStatus_HEALTH_OK   NodeStatus_HealthCodeType = 0
	NodeStatus_NAPLES_DOWN NodeStatus_HealthCodeType = 1
	NodeStatus_NODE_DOWN   NodeStatus_HealthCodeType = 2
	NodeStatus_APP_DOWN    NodeStatus_HealthCodeType = 3
)

var NodeStatus_HealthCodeType_name = map[int32]string{
	0: "HEALTH_OK",
	1: "NAPLES_DOWN",
	2: "NODE_DOWN",
	3: "APP_DOWN",
}
var NodeStatus_HealthCodeType_value = map[string]int32{
	"HEALTH_OK":   0,
	"NAPLES_DOWN": 1,
	"NODE_DOWN":   2,
	"APP_DOWN":    3,
}

func (x NodeStatus_HealthCodeType) String() string {
	return proto.EnumName(NodeStatus_HealthCodeType_name, int32(x))
}
func (NodeStatus_HealthCodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRespTypes, []int{2, 0}
}

type IotaAPIResponse struct {
	// APIStatus captures call status
	APIStatus string `protobuf:"bytes,1,opt,name=APIStatus,proto3" json:"api-status,omitempty"`
}

func (m *IotaAPIResponse) Reset()                    { *m = IotaAPIResponse{} }
func (m *IotaAPIResponse) String() string            { return proto.CompactTextString(m) }
func (*IotaAPIResponse) ProtoMessage()               {}
func (*IotaAPIResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{0} }

func (m *IotaAPIResponse) GetAPIStatus() string {
	if m != nil {
		return m.APIStatus
	}
	return ""
}

// ClusterHealthResponse captures the health of the cluster
type ClusterHealthResponse struct {
	// Status captures the health of the cluster on a per node basis
	Status []*NodeStatus `protobuf:"bytes,1,rep,name=Status" json:"status,omitempty"`
}

func (m *ClusterHealthResponse) Reset()                    { *m = ClusterHealthResponse{} }
func (m *ClusterHealthResponse) String() string            { return proto.CompactTextString(m) }
func (*ClusterHealthResponse) ProtoMessage()               {}
func (*ClusterHealthResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{1} }

func (m *ClusterHealthResponse) GetStatus() []*NodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Node status captures the health of an individual node
type NodeStatus struct {
	// API Response
	HealthCheckResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=HealthCheckResponse" json:"api-status,omitempty"`
	// Health captures individual node health
	Health string `protobuf:"bytes,2,opt,name=Health,proto3" json:"health,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{2} }

func (m *NodeStatus) GetHealthCheckResponse() *IotaAPIResponse {
	if m != nil {
		return m.HealthCheckResponse
	}
	return nil
}

func (m *NodeStatus) GetHealth() string {
	if m != nil {
		return m.Health
	}
	return ""
}

// InstantiateApp API Response
type InstantiateAppResponse struct {
	// API Response
	InstantiateAppResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=InstantiateAppResponse" json:"instantiate-app-response,omitempty"`
}

func (m *InstantiateAppResponse) Reset()                    { *m = InstantiateAppResponse{} }
func (m *InstantiateAppResponse) String() string            { return proto.CompactTextString(m) }
func (*InstantiateAppResponse) ProtoMessage()               {}
func (*InstantiateAppResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{3} }

func (m *InstantiateAppResponse) GetInstantiateAppResponse() *IotaAPIResponse {
	if m != nil {
		return m.InstantiateAppResponse
	}
	return nil
}

// Instantiate Topology API Reponse
type InstantiateTopoResponse struct {
	// API Response
	InstantiateTopoReponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=InstantiateTopoReponse" json:"instantiate-topo-response,omitempty"`
}

func (m *InstantiateTopoResponse) Reset()                    { *m = InstantiateTopoResponse{} }
func (m *InstantiateTopoResponse) String() string            { return proto.CompactTextString(m) }
func (*InstantiateTopoResponse) ProtoMessage()               {}
func (*InstantiateTopoResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{4} }

func (m *InstantiateTopoResponse) GetInstantiateTopoReponse() *IotaAPIResponse {
	if m != nil {
		return m.InstantiateTopoReponse
	}
	return nil
}

// AddNode API Response
type AddNodeResponse struct {
	// API Response
	AddNodeReponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=AddNodeReponse" json:"add-node-response,omitempty"`
}

func (m *AddNodeResponse) Reset()                    { *m = AddNodeResponse{} }
func (m *AddNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*AddNodeResponse) ProtoMessage()               {}
func (*AddNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{5} }

func (m *AddNodeResponse) GetAddNodeReponse() *IotaAPIResponse {
	if m != nil {
		return m.AddNodeReponse
	}
	return nil
}

// Generate Configs API Response
type GeneratedConfigResponse struct {
	GeneratedConfigResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=GeneratedConfigResponse" json:"api-status,omitemtpy"`
	// Generated Configs
	ConfigInfo *ConfigInfo `protobuf:"bytes,2,opt,name=ConfigInfo" json:"configs,omitemtpy"`
}

func (m *GeneratedConfigResponse) Reset()                    { *m = GeneratedConfigResponse{} }
func (m *GeneratedConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*GeneratedConfigResponse) ProtoMessage()               {}
func (*GeneratedConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{6} }

func (m *GeneratedConfigResponse) GetGeneratedConfigResponse() *IotaAPIResponse {
	if m != nil {
		return m.GeneratedConfigResponse
	}
	return nil
}

func (m *GeneratedConfigResponse) GetConfigInfo() *ConfigInfo {
	if m != nil {
		return m.ConfigInfo
	}
	return nil
}

// Config Push API Response
type ConfigPushResponse struct {
	ConfigPushResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=ConfigPushResponse" json:"api-status,omitemtpy"`
}

func (m *ConfigPushResponse) Reset()                    { *m = ConfigPushResponse{} }
func (m *ConfigPushResponse) String() string            { return proto.CompactTextString(m) }
func (*ConfigPushResponse) ProtoMessage()               {}
func (*ConfigPushResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{7} }

func (m *ConfigPushResponse) GetConfigPushResponse() *IotaAPIResponse {
	if m != nil {
		return m.ConfigPushResponse
	}
	return nil
}

// App Trigger API Response
type TriggerAppResponse struct {
	APIStatus *IotaAPIResponse `protobuf:"bytes,1,opt,name=APIStatus" json:"api-status,omitemtpy"`
	AppHandle string           `protobuf:"bytes,2,opt,name=AppHandle,proto3" json:"app-handle,omitemtpy"`
	AppStdOut string           `protobuf:"bytes,3,opt,name=AppStdOut,proto3" json:"app-stdout,omitemtpy"`
	ExitCode  uint32           `protobuf:"varint,4,opt,name=ExitCode,proto3" json:"exit-code,omitemtpy"`
}

func (m *TriggerAppResponse) Reset()                    { *m = TriggerAppResponse{} }
func (m *TriggerAppResponse) String() string            { return proto.CompactTextString(m) }
func (*TriggerAppResponse) ProtoMessage()               {}
func (*TriggerAppResponse) Descriptor() ([]byte, []int) { return fileDescriptorRespTypes, []int{8} }

func (m *TriggerAppResponse) GetAPIStatus() *IotaAPIResponse {
	if m != nil {
		return m.APIStatus
	}
	return nil
}

func (m *TriggerAppResponse) GetAppHandle() string {
	if m != nil {
		return m.AppHandle
	}
	return ""
}

func (m *TriggerAppResponse) GetAppStdOut() string {
	if m != nil {
		return m.AppStdOut
	}
	return ""
}

func (m *TriggerAppResponse) GetExitCode() uint32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func init() {
	proto.RegisterType((*IotaAPIResponse)(nil), "iotamodel.IotaAPIResponse")
	proto.RegisterType((*ClusterHealthResponse)(nil), "iotamodel.ClusterHealthResponse")
	proto.RegisterType((*NodeStatus)(nil), "iotamodel.NodeStatus")
	proto.RegisterType((*InstantiateAppResponse)(nil), "iotamodel.InstantiateAppResponse")
	proto.RegisterType((*InstantiateTopoResponse)(nil), "iotamodel.InstantiateTopoResponse")
	proto.RegisterType((*AddNodeResponse)(nil), "iotamodel.AddNodeResponse")
	proto.RegisterType((*GeneratedConfigResponse)(nil), "iotamodel.GeneratedConfigResponse")
	proto.RegisterType((*ConfigPushResponse)(nil), "iotamodel.ConfigPushResponse")
	proto.RegisterType((*TriggerAppResponse)(nil), "iotamodel.TriggerAppResponse")
	proto.RegisterEnum("iotamodel.IotaAPIResponse_APIResponseType", IotaAPIResponse_APIResponseType_name, IotaAPIResponse_APIResponseType_value)
	proto.RegisterEnum("iotamodel.NodeStatus_HealthCodeType", NodeStatus_HealthCodeType_name, NodeStatus_HealthCodeType_value)
}
func (m *IotaAPIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IotaAPIResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.APIStatus) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(len(m.APIStatus)))
		i += copy(dAtA[i:], m.APIStatus)
	}
	return i, nil
}

func (m *ClusterHealthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterHealthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, msg := range m.Status {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRespTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HealthCheckResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.HealthCheckResponse.Size()))
		n1, err := m.HealthCheckResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Health) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(len(m.Health)))
		i += copy(dAtA[i:], m.Health)
	}
	return i, nil
}

func (m *InstantiateAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstantiateAppResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstantiateAppResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.InstantiateAppResponse.Size()))
		n2, err := m.InstantiateAppResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *InstantiateTopoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstantiateTopoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstantiateTopoReponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.InstantiateTopoReponse.Size()))
		n3, err := m.InstantiateTopoReponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *AddNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddNodeReponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.AddNodeReponse.Size()))
		n4, err := m.AddNodeReponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GeneratedConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GeneratedConfigResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.GeneratedConfigResponse.Size()))
		n5, err := m.GeneratedConfigResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ConfigInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.ConfigInfo.Size()))
		n6, err := m.ConfigInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ConfigPushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigPushResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigPushResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.ConfigPushResponse.Size()))
		n7, err := m.ConfigPushResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TriggerAppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerAppResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.APIStatus != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.APIStatus.Size()))
		n8, err := m.APIStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.AppHandle) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(len(m.AppHandle)))
		i += copy(dAtA[i:], m.AppHandle)
	}
	if len(m.AppStdOut) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(len(m.AppStdOut)))
		i += copy(dAtA[i:], m.AppStdOut)
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRespTypes(dAtA, i, uint64(m.ExitCode))
	}
	return i, nil
}

func encodeVarintRespTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IotaAPIResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.APIStatus)
	if l > 0 {
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *ClusterHealthResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovRespTypes(uint64(l))
		}
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	if m.HealthCheckResponse != nil {
		l = m.HealthCheckResponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *InstantiateAppResponse) Size() (n int) {
	var l int
	_ = l
	if m.InstantiateAppResponse != nil {
		l = m.InstantiateAppResponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *InstantiateTopoResponse) Size() (n int) {
	var l int
	_ = l
	if m.InstantiateTopoReponse != nil {
		l = m.InstantiateTopoReponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *AddNodeResponse) Size() (n int) {
	var l int
	_ = l
	if m.AddNodeReponse != nil {
		l = m.AddNodeReponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *GeneratedConfigResponse) Size() (n int) {
	var l int
	_ = l
	if m.GeneratedConfigResponse != nil {
		l = m.GeneratedConfigResponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	if m.ConfigInfo != nil {
		l = m.ConfigInfo.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *ConfigPushResponse) Size() (n int) {
	var l int
	_ = l
	if m.ConfigPushResponse != nil {
		l = m.ConfigPushResponse.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	return n
}

func (m *TriggerAppResponse) Size() (n int) {
	var l int
	_ = l
	if m.APIStatus != nil {
		l = m.APIStatus.Size()
		n += 1 + l + sovRespTypes(uint64(l))
	}
	l = len(m.AppHandle)
	if l > 0 {
		n += 1 + l + sovRespTypes(uint64(l))
	}
	l = len(m.AppStdOut)
	if l > 0 {
		n += 1 + l + sovRespTypes(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovRespTypes(uint64(m.ExitCode))
	}
	return n
}

func sovRespTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRespTypes(x uint64) (n int) {
	return sovRespTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IotaAPIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IotaAPIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IotaAPIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterHealthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterHealthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterHealthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &NodeStatus{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheckResponse == nil {
				m.HealthCheckResponse = &IotaAPIResponse{}
			}
			if err := m.HealthCheckResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstantiateAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstantiateAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstantiateAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantiateAppResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstantiateAppResponse == nil {
				m.InstantiateAppResponse = &IotaAPIResponse{}
			}
			if err := m.InstantiateAppResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstantiateTopoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstantiateTopoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstantiateTopoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantiateTopoReponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstantiateTopoReponse == nil {
				m.InstantiateTopoReponse = &IotaAPIResponse{}
			}
			if err := m.InstantiateTopoReponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddNodeReponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddNodeReponse == nil {
				m.AddNodeReponse = &IotaAPIResponse{}
			}
			if err := m.AddNodeReponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedConfigResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeneratedConfigResponse == nil {
				m.GeneratedConfigResponse = &IotaAPIResponse{}
			}
			if err := m.GeneratedConfigResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigInfo == nil {
				m.ConfigInfo = &ConfigInfo{}
			}
			if err := m.ConfigInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigPushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigPushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigPushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPushResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigPushResponse == nil {
				m.ConfigPushResponse = &IotaAPIResponse{}
			}
			if err := m.ConfigPushResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerAppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerAppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerAppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.APIStatus == nil {
				m.APIStatus = &IotaAPIResponse{}
			}
			if err := m.APIStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppStdOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRespTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppStdOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRespTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRespTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRespTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRespTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRespTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRespTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRespTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRespTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRespTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRespTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("resp_types.proto", fileDescriptorRespTypes) }

var fileDescriptorRespTypes = []byte{
	// 786 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4f, 0x6f, 0xe2, 0x46,
	0x14, 0x8f, 0xa1, 0x8a, 0xc2, 0xe4, 0x0f, 0x8e, 0x93, 0x34, 0x84, 0x56, 0x38, 0x72, 0xa5, 0x96,
	0x48, 0x05, 0x4b, 0x89, 0xd4, 0x43, 0x6f, 0x86, 0xb8, 0x05, 0x95, 0x82, 0x6b, 0x4c, 0x7b, 0xa9,
	0x64, 0x39, 0x9e, 0xc1, 0x58, 0x85, 0x99, 0x91, 0x3d, 0x4e, 0x43, 0x7a, 0xcf, 0xad, 0xb7, 0xaa,
	0xed, 0x67, 0xc8, 0x27, 0xe9, 0xb1, 0xb7, 0x3d, 0x2d, 0x5a, 0x65, 0x6f, 0x7c, 0x8a, 0x15, 0xb6,
	0x31, 0x86, 0x05, 0x6d, 0x94, 0xbd, 0xf9, 0xbd, 0xf7, 0x7b, 0xef, 0xf7, 0x7b, 0xef, 0xcd, 0x8c,
	0x01, 0xef, 0x21, 0x9f, 0x9a, 0x6c, 0x4c, 0x91, 0x5f, 0xa5, 0x1e, 0x61, 0x44, 0xc8, 0xb9, 0x84,
	0x59, 0x23, 0x02, 0xd1, 0xb0, 0xf8, 0xb9, 0x43, 0x88, 0x33, 0x44, 0xb2, 0x45, 0x5d, 0xd9, 0xc2,
	0x98, 0x30, 0x8b, 0xb9, 0x04, 0xc7, 0xc0, 0x62, 0xc5, 0x71, 0xd9, 0x20, 0xb8, 0xa9, 0xda, 0x64,
	0x24, 0x3b, 0xc4, 0x21, 0x72, 0xe8, 0xbe, 0x09, 0xfa, 0xa1, 0x15, 0x1a, 0xe1, 0x57, 0x0c, 0x57,
	0x53, 0x70, 0x8a, 0xb0, 0x6f, 0x61, 0x48, 0x64, 0xff, 0x77, 0xf9, 0x16, 0x61, 0xd7, 0x46, 0x72,
	0xc0, 0xdc, 0xa1, 0x3f, 0x63, 0x72, 0x10, 0x4e, 0x93, 0xc9, 0x2e, 0xb6, 0x87, 0x01, 0x9c, 0xcb,
	0x2b, 0xee, 0xd9, 0x64, 0x34, 0x22, 0x38, 0xb2, 0xa4, 0xd7, 0x1c, 0xc8, 0x37, 0x09, 0xb3, 0x14,
	0xad, 0xa9, 0x23, 0x9f, 0x12, 0xec, 0x23, 0xc1, 0x06, 0x39, 0x45, 0x6b, 0x76, 0x99, 0xc5, 0x02,
	0xbf, 0xc0, 0x9d, 0x73, 0xe5, 0x5c, 0x4d, 0x7d, 0x7c, 0x38, 0xbb, 0xe8, 0x32, 0x4f, 0xc5, 0xc1,
	0xa8, 0xbc, 0x82, 0xaf, 0xa6, 0xbe, 0x8d, 0x31, 0x45, 0xe8, 0x62, 0x3a, 0x11, 0x8f, 0x2d, 0xea,
	0x56, 0xfc, 0xb0, 0xc4, 0xd7, 0x64, 0xe4, 0x32, 0x34, 0xa2, 0x6c, 0xac, 0x2f, 0xea, 0x4a, 0x08,
	0xe4, 0x57, 0xf2, 0x84, 0x43, 0xb0, 0xaf, 0x68, 0x4d, 0xb3, 0x6b, 0x28, 0x46, 0xaf, 0x6b, 0x76,
	0x7e, 0xe0, 0xb7, 0x84, 0xa3, 0x10, 0x65, 0xd6, 0x94, 0x6b, 0x53, 0x57, 0x7f, 0xea, 0xa9, 0x5d,
	0x83, 0xe7, 0x84, 0x63, 0xc0, 0x87, 0x38, 0x55, 0xff, 0x59, 0xd5, 0x4d, 0x55, 0xd7, 0x3b, 0x3a,
	0x9f, 0x99, 0x7b, 0x95, 0x9e, 0xd1, 0x30, 0xbf, 0x53, 0x9a, 0xad, 0x9e, 0xae, 0xf2, 0x59, 0xe9,
	0x57, 0x70, 0x52, 0x1f, 0x06, 0x3e, 0x43, 0x5e, 0x03, 0x59, 0x43, 0x36, 0x48, 0x9a, 0xac, 0x83,
	0xed, 0xa4, 0xc3, 0x6c, 0x79, 0xf7, 0xf2, 0xa4, 0x9a, 0xac, 0xad, 0xda, 0x26, 0x10, 0x45, 0xc1,
	0xda, 0xf1, 0x74, 0x22, 0xf2, 0xef, 0xf5, 0x11, 0xa7, 0x4a, 0xff, 0x64, 0x00, 0x58, 0x80, 0x85,
	0x3e, 0x38, 0x8a, 0x58, 0xea, 0x03, 0x64, 0xff, 0x36, 0xa7, 0x0a, 0x47, 0xb8, 0x7b, 0x59, 0x4c,
	0x11, 0xac, 0x4c, 0xb0, 0x56, 0xd8, 0x38, 0xb1, 0x75, 0x05, 0x05, 0x1d, 0x6c, 0x47, 0xee, 0x42,
	0x26, 0xdc, 0xce, 0xb7, 0x8f, 0x0f, 0x67, 0xd2, 0x7c, 0x3b, 0x0b, 0x3d, 0xd5, 0x38, 0x97, 0xc0,
	0x70, 0xbe, 0xb3, 0xb5, 0xf0, 0x83, 0xd0, 0x95, 0x6e, 0x25, 0x02, 0x49, 0x3f, 0x82, 0x83, 0x65,
	0xb8, 0xb0, 0x0f, 0x72, 0x0d, 0x55, 0x69, 0x19, 0x8d, 0x68, 0x15, 0x79, 0xb0, 0xdb, 0x56, 0xb4,
	0x96, 0xda, 0x35, 0xaf, 0x3b, 0xbf, 0xb4, 0x79, 0x6e, 0x16, 0x6f, 0x77, 0xae, 0xd5, 0xc8, 0xcc,
	0x08, 0x7b, 0x60, 0x47, 0xd1, 0xb4, 0xc8, 0xca, 0x4a, 0x7f, 0x71, 0xe0, 0xd3, 0x26, 0xf6, 0x99,
	0x85, 0x99, 0x6b, 0x31, 0xa4, 0x50, 0x9a, 0xa8, 0xbf, 0xdf, 0x14, 0x79, 0xc6, 0xa0, 0xbe, 0x9c,
	0x4e, 0x44, 0xc9, 0x5d, 0x64, 0x57, 0x2c, 0x4a, 0x2b, 0x5e, 0x1c, 0x4d, 0x75, 0xb5, 0x81, 0x41,
	0xfa, 0x9b, 0x03, 0xa7, 0xa9, 0x90, 0x41, 0x28, 0x49, 0x74, 0xfd, 0xb1, 0xa4, 0x2b, 0x0a, 0x3d,
	0x57, 0xd7, 0x57, 0xd3, 0x89, 0xf8, 0x45, 0x5a, 0x17, 0x23, 0x94, 0x7c, 0x48, 0x58, 0x8a, 0x42,
	0xba, 0x05, 0x79, 0x05, 0xc2, 0xd9, 0xee, 0x52, 0xd7, 0xf0, 0x20, 0x71, 0x3d, 0x57, 0x87, 0x38,
	0x9d, 0x88, 0x9f, 0x59, 0x10, 0x56, 0x30, 0x81, 0x68, 0x1d, 0xff, 0x4a, 0x49, 0xe9, 0x15, 0x07,
	0x4e, 0xbf, 0x47, 0x18, 0x79, 0x16, 0x43, 0xb0, 0x4e, 0x70, 0xdf, 0x75, 0x12, 0x01, 0x78, 0x63,
	0xe8, 0xc5, 0x47, 0x9a, 0xd1, 0xb1, 0xbe, 0x91, 0xaf, 0x05, 0x40, 0xe4, 0x69, 0xe2, 0x3e, 0x09,
	0x8f, 0xf6, 0xf2, 0xb5, 0x5c, 0x04, 0x6b, 0x27, 0xd3, 0x89, 0x78, 0x68, 0x87, 0x76, 0xba, 0x74,
	0x2a, 0x5f, 0xba, 0x07, 0x42, 0x64, 0x69, 0x81, 0xbf, 0xb8, 0xf6, 0x70, 0x9d, 0xf7, 0xa3, 0xda,
	0x59, 0x53, 0x4f, 0xfa, 0x33, 0x03, 0x04, 0xc3, 0x73, 0x1d, 0x07, 0x79, 0xe9, 0x93, 0xaf, 0xaf,
	0x3e, 0xac, 0x2f, 0xe5, 0x5c, 0x94, 0x11, 0xbe, 0x01, 0x39, 0x85, 0xd2, 0x86, 0x85, 0xe1, 0x10,
	0xc5, 0xcf, 0x41, 0x9c, 0x47, 0x2b, 0x83, 0xd0, 0xbb, 0x94, 0x37, 0x87, 0xc6, 0x79, 0x5d, 0x06,
	0x3b, 0x01, 0x2b, 0x64, 0x97, 0xf3, 0x7c, 0x06, 0x49, 0xc0, 0x56, 0xf2, 0x22, 0xa8, 0x70, 0x05,
	0x76, 0xd4, 0x3b, 0x97, 0xcd, 0x5e, 0x89, 0xc2, 0x27, 0xe7, 0x5c, 0x79, 0xbf, 0x76, 0x3a, 0x9d,
	0x88, 0x47, 0xe8, 0xce, 0x65, 0x15, 0x9b, 0xc0, 0x34, 0x5b, 0x02, 0xac, 0xf1, 0xff, 0x3d, 0x95,
	0xb8, 0xff, 0x9f, 0x4a, 0xdc, 0x9b, 0xa7, 0x12, 0xf7, 0xef, 0xdb, 0xd2, 0x96, 0x96, 0xb9, 0xd9,
	0x0e, 0x7f, 0x40, 0x57, 0xef, 0x02, 0x00, 0x00, 0xff, 0xff, 0x85, 0x30, 0xa1, 0x9d, 0x41, 0x07,
	0x00, 0x00,
}
