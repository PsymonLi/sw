// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cfg_svc.proto

/*
	Package iotamodel is a generated protocol buffer package.

	It is generated from these files:
		cfg_svc.proto
		iota_types.proto
		topo_svc.proto
		agent.proto

	It has these top-level messages:
		AuthMsg
		MakeClusterMsg
		InitConfigMsg
		NaplesHost
		GenerateConfigMsg
		ConfigMsg
		ConfigObject
		ConfigQueryMsg
		MatchSelector
		IotaAPIResponse
		NodeMsg
		ReloadMsg
		Entity
		VmwareESXConfig
		VcenterConfig
		NaplesSimInfo
		Node
		ApcInfo
		NaplesMultiSimConfig
		NaplesConfig
		NaplesConfigs
		ThirdPartyNicConfig
		MellanoxConfig
		BroadcomConfig
		IntelConfig
		VenicePeer
		VeniceConfig
		WorkloadMsg
		DvsInfo
		ExposedPorts
		Workload
		TriggerMsg
		Command
		WorkloadMove
		WorkloadMoveMsg
		Network
		NetworksMsg
		ClusterHealthMsg
		NodeHealth
		NetworkQosClass
		NetworkPolicyQos
		NetworkDscpClass
		NetworkDscpPolicy
		NetworkQueueClass
		NetworkQueuePolicy
		DataSwitch
		License
		TestBedMsg
		TestNodesMsg
		VlanConfig
		SwitchFlapInfo
		PortPauseConfig
		PortPfcConfig
		PortQosConfig
		PortQueuingConfig
		SwitchMsg
		TestBedNode
		EntityCopyMsg
		DownloadAssetsMsg
		PrepareWorkspaceMsg
*/
package iotamodel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EntrypointType int32

const (
	EntrypointType_ENTRYPOINT_NONE EntrypointType = 0
	EntrypointType_NAPLES_REST     EntrypointType = 1
	EntrypointType_VENICE_REST     EntrypointType = 2
)

var EntrypointType_name = map[int32]string{
	0: "ENTRYPOINT_NONE",
	1: "NAPLES_REST",
	2: "VENICE_REST",
}
var EntrypointType_value = map[string]int32{
	"ENTRYPOINT_NONE": 0,
	"NAPLES_REST":     1,
	"VENICE_REST":     2,
}

func (x EntrypointType) String() string {
	return proto.EnumName(EntrypointType_name, int32(x))
}
func (EntrypointType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{0} }

type CfgMethodType int32

const (
	CfgMethodType_CFG_METHOD_NONE   CfgMethodType = 0
	CfgMethodType_CFG_METHOD_CREATE CfgMethodType = 1
	CfgMethodType_CFG_METHOD_UPDATE CfgMethodType = 2
	CfgMethodType_CFG_METHOD_DELETE CfgMethodType = 3
)

var CfgMethodType_name = map[int32]string{
	0: "CFG_METHOD_NONE",
	1: "CFG_METHOD_CREATE",
	2: "CFG_METHOD_UPDATE",
	3: "CFG_METHOD_DELETE",
}
var CfgMethodType_value = map[string]int32{
	"CFG_METHOD_NONE":   0,
	"CFG_METHOD_CREATE": 1,
	"CFG_METHOD_UPDATE": 2,
	"CFG_METHOD_DELETE": 3,
}

func (x CfgMethodType) String() string {
	return proto.EnumName(CfgMethodType_name, int32(x))
}
func (CfgMethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{1} }

type CfgDbView int32

const (
	CfgDbView_CFG_DB_VIEW_NONE    CfgDbView = 0
	CfgDbView_CFG_DB_VIEW_CFG_SVC CfgDbView = 1
	CfgDbView_CFG_DB_VIEW_TESTBED CfgDbView = 2
)

var CfgDbView_name = map[int32]string{
	0: "CFG_DB_VIEW_NONE",
	1: "CFG_DB_VIEW_CFG_SVC",
	2: "CFG_DB_VIEW_TESTBED",
}
var CfgDbView_value = map[string]int32{
	"CFG_DB_VIEW_NONE":    0,
	"CFG_DB_VIEW_CFG_SVC": 1,
	"CFG_DB_VIEW_TESTBED": 2,
}

func (x CfgDbView) String() string {
	return proto.EnumName(CfgDbView_name, int32(x))
}
func (CfgDbView) EnumDescriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{2} }

type AuthMsg struct {
	AuthToken   string           `protobuf:"bytes,1,opt,name=AuthToken,proto3" json:"AuthToken,omitempty"`
	ApiResponse *IotaAPIResponse `protobuf:"bytes,2,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
}

func (m *AuthMsg) Reset()                    { *m = AuthMsg{} }
func (m *AuthMsg) String() string            { return proto.CompactTextString(m) }
func (*AuthMsg) ProtoMessage()               {}
func (*AuthMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{0} }

func (m *AuthMsg) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

func (m *AuthMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

type MakeClusterMsg struct {
	Endpoint       string           `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	HealthEndpoint string           `protobuf:"bytes,2,opt,name=health_endpoint,json=healthEndpoint,proto3" json:"health_endpoint,omitempty"`
	Config         string           `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	ApiResponse    *IotaAPIResponse `protobuf:"bytes,4,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
}

func (m *MakeClusterMsg) Reset()                    { *m = MakeClusterMsg{} }
func (m *MakeClusterMsg) String() string            { return proto.CompactTextString(m) }
func (*MakeClusterMsg) ProtoMessage()               {}
func (*MakeClusterMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{1} }

func (m *MakeClusterMsg) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *MakeClusterMsg) GetHealthEndpoint() string {
	if m != nil {
		return m.HealthEndpoint
	}
	return ""
}

func (m *MakeClusterMsg) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *MakeClusterMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

type InitConfigMsg struct {
	// ConfigEntrypoint captures what object model configs to generate for a given testbed.
	// Could either be venice object model or Agent object model
	ApiResponse    *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	EntryPointType EntrypointType   `protobuf:"varint,2,opt,name=entry_point_type,json=entryPointType,proto3,enum=iotamodel.EntrypointType" json:"entry_point_type,omitempty"`
	Endpoints      []string         `protobuf:"bytes,3,rep,name=endpoints" json:"endpoints,omitempty"`
	Vlans          []uint32         `protobuf:"varint,4,rep,packed,name=vlans" json:"vlans,omitempty"`
	EndpointStatus []string         `protobuf:"bytes,5,rep,name=endpoint_status,json=endpointStatus" json:"endpoint_status,omitempty"`
}

func (m *InitConfigMsg) Reset()                    { *m = InitConfigMsg{} }
func (m *InitConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*InitConfigMsg) ProtoMessage()               {}
func (*InitConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{2} }

func (m *InitConfigMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *InitConfigMsg) GetEntryPointType() EntrypointType {
	if m != nil {
		return m.EntryPointType
	}
	return EntrypointType_ENTRYPOINT_NONE
}

func (m *InitConfigMsg) GetEndpoints() []string {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *InitConfigMsg) GetVlans() []uint32 {
	if m != nil {
		return m.Vlans
	}
	return nil
}

func (m *InitConfigMsg) GetEndpointStatus() []string {
	if m != nil {
		return m.EndpointStatus
	}
	return nil
}

type NaplesHost struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uuid string `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *NaplesHost) Reset()                    { *m = NaplesHost{} }
func (m *NaplesHost) String() string            { return proto.CompactTextString(m) }
func (*NaplesHost) ProtoMessage()               {}
func (*NaplesHost) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{3} }

func (m *NaplesHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NaplesHost) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type GenerateConfigMsg struct {
	Hosts       []*NaplesHost    `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	ApiResponse *IotaAPIResponse `protobuf:"bytes,2,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
}

func (m *GenerateConfigMsg) Reset()                    { *m = GenerateConfigMsg{} }
func (m *GenerateConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*GenerateConfigMsg) ProtoMessage()               {}
func (*GenerateConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{4} }

func (m *GenerateConfigMsg) GetHosts() []*NaplesHost {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *GenerateConfigMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

type ConfigMsg struct {
	Configs     []*ConfigObject  `protobuf:"bytes,1,rep,name=configs" json:"configs,omitempty"`
	AuthToken   string           `protobuf:"bytes,2,opt,name=AuthToken,proto3" json:"AuthToken,omitempty"`
	ApiResponse *IotaAPIResponse `protobuf:"bytes,3,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
}

func (m *ConfigMsg) Reset()                    { *m = ConfigMsg{} }
func (m *ConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*ConfigMsg) ProtoMessage()               {}
func (*ConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{5} }

func (m *ConfigMsg) GetConfigs() []*ConfigObject {
	if m != nil {
		return m.Configs
	}
	return nil
}

func (m *ConfigMsg) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

func (m *ConfigMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

type ConfigObject struct {
	// Method indicates the REST method to call on the object.
	Method CfgMethodType `protobuf:"varint,1,opt,name=method,proto3,enum=iotamodel.CfgMethodType" json:"method,omitempty"`
	// Config captures the Marshaled JSON object
	Config string `protobuf:"bytes,2,opt,name=Config,proto3" json:"Config,omitempty"`
}

func (m *ConfigObject) Reset()                    { *m = ConfigObject{} }
func (m *ConfigObject) String() string            { return proto.CompactTextString(m) }
func (*ConfigObject) ProtoMessage()               {}
func (*ConfigObject) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{6} }

func (m *ConfigObject) GetMethod() CfgMethodType {
	if m != nil {
		return m.Method
	}
	return CfgMethodType_CFG_METHOD_NONE
}

func (m *ConfigObject) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type ConfigQueryMsg struct {
	ApiResponse *IotaAPIResponse `protobuf:"bytes,1,opt,name=api_response,json=apiResponse" json:"api_response,omitempty"`
	// View on which this query should operate
	View CfgDbView `protobuf:"varint,2,opt,name=view,proto3,enum=iotamodel.CfgDbView" json:"view,omitempty"`
	// Object Kind
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// MatchSelector accepts a multiple key value pair, with a default AND between them
	Selectors []*MatchSelector `protobuf:"bytes,4,rep,name=selectors" json:"selectors,omitempty"`
}

func (m *ConfigQueryMsg) Reset()                    { *m = ConfigQueryMsg{} }
func (m *ConfigQueryMsg) String() string            { return proto.CompactTextString(m) }
func (*ConfigQueryMsg) ProtoMessage()               {}
func (*ConfigQueryMsg) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{7} }

func (m *ConfigQueryMsg) GetApiResponse() *IotaAPIResponse {
	if m != nil {
		return m.ApiResponse
	}
	return nil
}

func (m *ConfigQueryMsg) GetView() CfgDbView {
	if m != nil {
		return m.View
	}
	return CfgDbView_CFG_DB_VIEW_NONE
}

func (m *ConfigQueryMsg) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ConfigQueryMsg) GetSelectors() []*MatchSelector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

// Key Value pairs.
type MatchSelector struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MatchSelector) Reset()                    { *m = MatchSelector{} }
func (m *MatchSelector) String() string            { return proto.CompactTextString(m) }
func (*MatchSelector) ProtoMessage()               {}
func (*MatchSelector) Descriptor() ([]byte, []int) { return fileDescriptorCfgSvc, []int{8} }

func (m *MatchSelector) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *MatchSelector) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*AuthMsg)(nil), "iotamodel.AuthMsg")
	proto.RegisterType((*MakeClusterMsg)(nil), "iotamodel.MakeClusterMsg")
	proto.RegisterType((*InitConfigMsg)(nil), "iotamodel.InitConfigMsg")
	proto.RegisterType((*NaplesHost)(nil), "iotamodel.NaplesHost")
	proto.RegisterType((*GenerateConfigMsg)(nil), "iotamodel.GenerateConfigMsg")
	proto.RegisterType((*ConfigMsg)(nil), "iotamodel.ConfigMsg")
	proto.RegisterType((*ConfigObject)(nil), "iotamodel.ConfigObject")
	proto.RegisterType((*ConfigQueryMsg)(nil), "iotamodel.ConfigQueryMsg")
	proto.RegisterType((*MatchSelector)(nil), "iotamodel.MatchSelector")
	proto.RegisterEnum("iotamodel.EntrypointType", EntrypointType_name, EntrypointType_value)
	proto.RegisterEnum("iotamodel.CfgMethodType", CfgMethodType_name, CfgMethodType_value)
	proto.RegisterEnum("iotamodel.CfgDbView", CfgDbView_name, CfgDbView_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ConfigMgmtApi service

type ConfigMgmtApiClient interface {
	// MakeCluster brings up a Venice Cluster
	MakeCluster(ctx context.Context, in *MakeClusterMsg, opts ...grpc.CallOption) (*MakeClusterMsg, error)
	// ConfigureAuth will perform the following actions:
	// Create an admin role, assign super admin privileges, log in and return the JWT Token back
	ConfigureAuth(ctx context.Context, in *AuthMsg, opts ...grpc.CallOption) (*AuthMsg, error)
	InitCfgService(ctx context.Context, in *InitConfigMsg, opts ...grpc.CallOption) (*InitConfigMsg, error)
	// GenerateConfigs accepts the topology information and config information and auto generates the config that needs
	// to be pushed. The intent is to support only the user facing objects at NAPLES REST or Venice REST Level.
	// It also pushes the base config either to Venice/NAPLES REST Endpoint
	GenerateConfigs(ctx context.Context, in *GenerateConfigMsg, opts ...grpc.CallOption) (*ConfigMsg, error)
	PushConfig(ctx context.Context, in *ConfigMsg, opts ...grpc.CallOption) (*ConfigMsg, error)
	// Query API queries the base config to match any parameters
	QueryConfig(ctx context.Context, in *ConfigQueryMsg, opts ...grpc.CallOption) (*ConfigMsg, error)
}

type configMgmtApiClient struct {
	cc *grpc.ClientConn
}

func NewConfigMgmtApiClient(cc *grpc.ClientConn) ConfigMgmtApiClient {
	return &configMgmtApiClient{cc}
}

func (c *configMgmtApiClient) MakeCluster(ctx context.Context, in *MakeClusterMsg, opts ...grpc.CallOption) (*MakeClusterMsg, error) {
	out := new(MakeClusterMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/MakeCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMgmtApiClient) ConfigureAuth(ctx context.Context, in *AuthMsg, opts ...grpc.CallOption) (*AuthMsg, error) {
	out := new(AuthMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/ConfigureAuth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMgmtApiClient) InitCfgService(ctx context.Context, in *InitConfigMsg, opts ...grpc.CallOption) (*InitConfigMsg, error) {
	out := new(InitConfigMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/InitCfgService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMgmtApiClient) GenerateConfigs(ctx context.Context, in *GenerateConfigMsg, opts ...grpc.CallOption) (*ConfigMsg, error) {
	out := new(ConfigMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/GenerateConfigs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMgmtApiClient) PushConfig(ctx context.Context, in *ConfigMsg, opts ...grpc.CallOption) (*ConfigMsg, error) {
	out := new(ConfigMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/PushConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMgmtApiClient) QueryConfig(ctx context.Context, in *ConfigQueryMsg, opts ...grpc.CallOption) (*ConfigMsg, error) {
	out := new(ConfigMsg)
	err := grpc.Invoke(ctx, "/iotamodel.ConfigMgmtApi/QueryConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ConfigMgmtApi service

type ConfigMgmtApiServer interface {
	// MakeCluster brings up a Venice Cluster
	MakeCluster(context.Context, *MakeClusterMsg) (*MakeClusterMsg, error)
	// ConfigureAuth will perform the following actions:
	// Create an admin role, assign super admin privileges, log in and return the JWT Token back
	ConfigureAuth(context.Context, *AuthMsg) (*AuthMsg, error)
	InitCfgService(context.Context, *InitConfigMsg) (*InitConfigMsg, error)
	// GenerateConfigs accepts the topology information and config information and auto generates the config that needs
	// to be pushed. The intent is to support only the user facing objects at NAPLES REST or Venice REST Level.
	// It also pushes the base config either to Venice/NAPLES REST Endpoint
	GenerateConfigs(context.Context, *GenerateConfigMsg) (*ConfigMsg, error)
	PushConfig(context.Context, *ConfigMsg) (*ConfigMsg, error)
	// Query API queries the base config to match any parameters
	QueryConfig(context.Context, *ConfigQueryMsg) (*ConfigMsg, error)
}

func RegisterConfigMgmtApiServer(s *grpc.Server, srv ConfigMgmtApiServer) {
	s.RegisterService(&_ConfigMgmtApi_serviceDesc, srv)
}

func _ConfigMgmtApi_MakeCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakeClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).MakeCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/MakeCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).MakeCluster(ctx, req.(*MakeClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMgmtApi_ConfigureAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).ConfigureAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/ConfigureAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).ConfigureAuth(ctx, req.(*AuthMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMgmtApi_InitCfgService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).InitCfgService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/InitCfgService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).InitCfgService(ctx, req.(*InitConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMgmtApi_GenerateConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).GenerateConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/GenerateConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).GenerateConfigs(ctx, req.(*GenerateConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMgmtApi_PushConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).PushConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/PushConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).PushConfig(ctx, req.(*ConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMgmtApi_QueryConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigQueryMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMgmtApiServer).QueryConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iotamodel.ConfigMgmtApi/QueryConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMgmtApiServer).QueryConfig(ctx, req.(*ConfigQueryMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigMgmtApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "iotamodel.ConfigMgmtApi",
	HandlerType: (*ConfigMgmtApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MakeCluster",
			Handler:    _ConfigMgmtApi_MakeCluster_Handler,
		},
		{
			MethodName: "ConfigureAuth",
			Handler:    _ConfigMgmtApi_ConfigureAuth_Handler,
		},
		{
			MethodName: "InitCfgService",
			Handler:    _ConfigMgmtApi_InitCfgService_Handler,
		},
		{
			MethodName: "GenerateConfigs",
			Handler:    _ConfigMgmtApi_GenerateConfigs_Handler,
		},
		{
			MethodName: "PushConfig",
			Handler:    _ConfigMgmtApi_PushConfig_Handler,
		},
		{
			MethodName: "QueryConfig",
			Handler:    _ConfigMgmtApi_QueryConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cfg_svc.proto",
}

func (m *AuthMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	if m.ApiResponse != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n1, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MakeClusterMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MakeClusterMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if len(m.HealthEndpoint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.HealthEndpoint)))
		i += copy(dAtA[i:], m.HealthEndpoint)
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	if m.ApiResponse != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n2, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *InitConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n3, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.EntryPointType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.EntryPointType))
	}
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Vlans) > 0 {
		dAtA5 := make([]byte, len(m.Vlans)*10)
		var j4 int
		for _, num := range m.Vlans {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.EndpointStatus) > 0 {
		for _, s := range m.EndpointStatus {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NaplesHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaplesHost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	return i, nil
}

func (m *GenerateConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, msg := range m.Hosts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCfgSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiResponse != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n6, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Configs) > 0 {
		for _, msg := range m.Configs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCfgSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	if m.ApiResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n7, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ConfigObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Method != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.Method))
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	return i, nil
}

func (m *ConfigQueryMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigQueryMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.ApiResponse.Size()))
		n8, err := m.ApiResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(m.View))
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCfgSvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MatchSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCfgSvc(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func encodeVarintCfgSvc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *MakeClusterMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	l = len(m.HealthEndpoint)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *InitConfigMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if m.EntryPointType != 0 {
		n += 1 + sovCfgSvc(uint64(m.EntryPointType))
	}
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			l = len(s)
			n += 1 + l + sovCfgSvc(uint64(l))
		}
	}
	if len(m.Vlans) > 0 {
		l = 0
		for _, e := range m.Vlans {
			l += sovCfgSvc(uint64(e))
		}
		n += 1 + sovCfgSvc(uint64(l)) + l
	}
	if len(m.EndpointStatus) > 0 {
		for _, s := range m.EndpointStatus {
			l = len(s)
			n += 1 + l + sovCfgSvc(uint64(l))
		}
	}
	return n
}

func (m *NaplesHost) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *GenerateConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, e := range m.Hosts {
			l = e.Size()
			n += 1 + l + sovCfgSvc(uint64(l))
		}
	}
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *ConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 1 + l + sovCfgSvc(uint64(l))
		}
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *ConfigObject) Size() (n int) {
	var l int
	_ = l
	if m.Method != 0 {
		n += 1 + sovCfgSvc(uint64(m.Method))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func (m *ConfigQueryMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiResponse != nil {
		l = m.ApiResponse.Size()
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovCfgSvc(uint64(m.View))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovCfgSvc(uint64(l))
		}
	}
	return n
}

func (m *MatchSelector) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCfgSvc(uint64(l))
	}
	return n
}

func sovCfgSvc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCfgSvc(x uint64) (n int) {
	return sovCfgSvc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MakeClusterMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MakeClusterMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MakeClusterMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryPointType", wireType)
			}
			m.EntryPointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryPointType |= (EntrypointType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfgSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vlans = append(m.Vlans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfgSvc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCfgSvc
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfgSvc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vlans = append(m.Vlans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlans", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointStatus = append(m.EndpointStatus, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaplesHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaplesHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaplesHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, &NaplesHost{})
			if err := m.Hosts[len(m.Hosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &ConfigObject{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (CfgMethodType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigQueryMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigQueryMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigQueryMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiResponse == nil {
				m.ApiResponse = &IotaAPIResponse{}
			}
			if err := m.ApiResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (CfgDbView(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &MatchSelector{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfgSvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfgSvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfgSvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCfgSvc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCfgSvc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfgSvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCfgSvc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCfgSvc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCfgSvc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCfgSvc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCfgSvc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cfg_svc.proto", fileDescriptorCfgSvc) }

var fileDescriptorCfgSvc = []byte{
	// 827 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0xe3, 0xb6, 0x4b, 0x4e, 0x36, 0xae, 0x77, 0xb6, 0xcb, 0xba, 0xd1, 0xaa, 0x8a, 0x7c,
	0x43, 0x54, 0xa4, 0x0a, 0x02, 0x02, 0x81, 0x84, 0x44, 0x9a, 0xcc, 0x76, 0x23, 0x6d, 0xd2, 0x60,
	0x9b, 0x02, 0x57, 0x96, 0x9b, 0x4c, 0x12, 0xd3, 0xc4, 0xb6, 0x3c, 0xe3, 0xac, 0x72, 0xc5, 0x6b,
	0x20, 0x71, 0xc3, 0x03, 0xf0, 0x1a, 0x48, 0x5c, 0xf2, 0x08, 0xa8, 0xbc, 0x00, 0x8f, 0x80, 0x66,
	0x3c, 0x4e, 0xec, 0x64, 0x23, 0x54, 0xb1, 0x77, 0xe7, 0x7c, 0xe7, 0x9b, 0x73, 0x8e, 0xcf, 0x9f,
	0xa1, 0x36, 0x9a, 0x4c, 0x5d, 0xba, 0x1c, 0x5d, 0x44, 0x71, 0xc8, 0x42, 0x54, 0xf1, 0x43, 0xe6,
	0x2d, 0xc2, 0x31, 0x99, 0xd7, 0x75, 0x2e, 0xba, 0x6c, 0x15, 0x11, 0x9a, 0x1a, 0xcd, 0x09, 0x3c,
	0x6a, 0x27, 0x6c, 0xd6, 0xa7, 0x53, 0xf4, 0x02, 0x2a, 0x5c, 0x74, 0xc2, 0x3b, 0x12, 0x18, 0x4a,
	0x43, 0x69, 0x56, 0xac, 0x0d, 0x80, 0xbe, 0x82, 0xc7, 0x5e, 0xe4, 0xbb, 0x31, 0xa1, 0x51, 0x18,
	0x50, 0x62, 0x94, 0x1b, 0x4a, 0xb3, 0xda, 0xaa, 0x5f, 0xac, 0x9d, 0x5f, 0xf4, 0x42, 0xe6, 0xb5,
	0x87, 0x3d, 0x4b, 0x32, 0xac, 0xaa, 0x17, 0xf9, 0x99, 0x62, 0xfe, 0xa6, 0x80, 0xd6, 0xf7, 0xee,
	0x48, 0x67, 0x9e, 0x50, 0x46, 0x62, 0x1e, 0xaf, 0x0e, 0xef, 0x91, 0x60, 0x1c, 0x85, 0x7e, 0xc0,
	0x64, 0xb8, 0xb5, 0x8e, 0x3e, 0x80, 0xe3, 0x19, 0xf1, 0xe6, 0x6c, 0xe6, 0xae, 0x29, 0x65, 0x41,
	0xd1, 0x52, 0x18, 0x67, 0xc4, 0xf7, 0xe1, 0x68, 0x14, 0x06, 0x13, 0x7f, 0x6a, 0xa8, 0xc2, 0x2e,
	0xb5, 0x9d, 0x74, 0x0f, 0x1e, 0x96, 0xee, 0x3f, 0x0a, 0xd4, 0x7a, 0x81, 0xcf, 0x3a, 0xc2, 0x1b,
	0xcf, 0x76, 0xdb, 0xa1, 0xf2, 0x20, 0x87, 0xa8, 0x03, 0x3a, 0x09, 0x58, 0xbc, 0x72, 0x45, 0xda,
	0xa2, 0x05, 0xe2, 0x8b, 0xb4, 0xd6, 0x69, 0xce, 0x05, 0xe6, 0x14, 0xc1, 0x70, 0x56, 0x11, 0xb1,
	0x34, 0xf1, 0x64, 0x98, 0xe9, 0xbc, 0x43, 0x59, 0x39, 0xa8, 0xa1, 0x36, 0x54, 0xde, 0xa1, 0x35,
	0x80, 0x4e, 0xe0, 0x70, 0x39, 0xf7, 0x02, 0x6a, 0x1c, 0x34, 0xd4, 0x66, 0xcd, 0x4a, 0x15, 0x5e,
	0xc9, 0x8c, 0xe2, 0x52, 0xe6, 0xb1, 0x84, 0x1a, 0x87, 0xe2, 0xa5, 0x96, 0xc1, 0xb6, 0x40, 0xcd,
	0x4f, 0x01, 0x06, 0x5e, 0x34, 0x27, 0xf4, 0x55, 0x48, 0x19, 0x42, 0x70, 0x10, 0x78, 0x0b, 0x22,
	0x1b, 0x23, 0x64, 0x8e, 0x25, 0x89, 0x3f, 0x96, 0x9d, 0x10, 0xb2, 0xf9, 0x13, 0x3c, 0xb9, 0x22,
	0x01, 0x89, 0x3d, 0x46, 0x36, 0xb5, 0xfa, 0x10, 0x0e, 0x67, 0x21, 0x65, 0xd4, 0x50, 0x1a, 0x6a,
	0xb3, 0xda, 0x7a, 0x96, 0xfb, 0xc2, 0x4d, 0x08, 0x2b, 0xe5, 0xfc, 0xdf, 0xc1, 0xfa, 0x45, 0x81,
	0xca, 0x26, 0xf2, 0xc7, 0xf0, 0x28, 0x1d, 0x80, 0x2c, 0xf6, 0xf3, 0x9c, 0x9f, 0x94, 0x76, 0x7d,
	0xfb, 0x23, 0x19, 0x31, 0x2b, 0xe3, 0x15, 0xc7, 0xbe, 0xfc, 0x5f, 0x63, 0xaf, 0x3e, 0x2c, 0xbb,
	0xef, 0xe1, 0x71, 0x3e, 0x2a, 0xfa, 0x08, 0x8e, 0x16, 0x84, 0xcd, 0xc2, 0xb1, 0x28, 0xac, 0xd6,
	0x32, 0xf2, 0xe9, 0x4d, 0xa6, 0x7d, 0x61, 0x13, 0xbd, 0x97, 0x3c, 0x3e, 0xe0, 0xa9, 0x07, 0x99,
	0x9b, 0xd4, 0xcc, 0xdf, 0x15, 0xd0, 0x52, 0xf1, 0x9b, 0x84, 0xc4, 0xab, 0x77, 0x30, 0xa2, 0x4d,
	0x38, 0x58, 0xfa, 0xe4, 0x8d, 0x1c, 0xcb, 0x93, 0x62, 0x66, 0xdd, 0xdb, 0x1b, 0x9f, 0xbc, 0xb1,
	0x04, 0x83, 0x0f, 0xc2, 0x9d, 0x1f, 0x8c, 0xe5, 0xca, 0x09, 0x19, 0x7d, 0x06, 0x15, 0x4a, 0xe6,
	0x64, 0xc4, 0xc2, 0x38, 0x9d, 0xc0, 0x6a, 0xe1, 0xe3, 0xfa, 0x1e, 0x1b, 0xcd, 0x6c, 0x49, 0xb0,
	0x36, 0x54, 0xf3, 0x73, 0xa8, 0x15, 0x6c, 0x48, 0x07, 0xf5, 0x8e, 0xac, 0xe4, 0xe0, 0x71, 0x51,
	0x0c, 0xb6, 0x37, 0x4f, 0x88, 0xac, 0x40, 0xaa, 0x9c, 0x5f, 0x81, 0x56, 0x5c, 0x17, 0xf4, 0x14,
	0x8e, 0xf1, 0xc0, 0xb1, 0x7e, 0x18, 0x5e, 0xf7, 0x06, 0x8e, 0x3b, 0xb8, 0x1e, 0x60, 0xbd, 0x84,
	0x8e, 0xa1, 0x3a, 0x68, 0x0f, 0x5f, 0x63, 0xdb, 0xb5, 0xb0, 0xed, 0xe8, 0x0a, 0x07, 0x6e, 0xf0,
	0xa0, 0xd7, 0xc1, 0x29, 0x50, 0x3e, 0xf7, 0xa1, 0x56, 0x28, 0x3d, 0xf7, 0xd3, 0x79, 0x79, 0xe5,
	0xf6, 0xb1, 0xf3, 0xea, 0xba, 0x9b, 0xf9, 0x79, 0x06, 0x4f, 0x72, 0x60, 0xc7, 0xc2, 0x6d, 0x07,
	0xeb, 0xca, 0x16, 0xfc, 0xed, 0xb0, 0xcb, 0xe1, 0xf2, 0x16, 0xdc, 0xc5, 0xaf, 0xb1, 0x83, 0x75,
	0xf5, 0xdc, 0x86, 0xca, 0xba, 0x96, 0xe8, 0x04, 0x74, 0xce, 0xe9, 0x5e, 0xba, 0x37, 0x3d, 0xfc,
	0x5d, 0x16, 0xe7, 0x39, 0x3c, 0xcd, 0xa3, 0x5c, 0xb6, 0x6f, 0x3a, 0xba, 0xb2, 0x6d, 0x70, 0xb0,
	0xed, 0x5c, 0xe2, 0xae, 0x5e, 0x6e, 0xfd, 0xaa, 0x42, 0x4d, 0x6e, 0xc0, 0x74, 0xc1, 0xda, 0x91,
	0x8f, 0x30, 0x54, 0x73, 0xb7, 0x16, 0x9d, 0x16, 0xfa, 0x90, 0xbf, 0xc1, 0xf5, 0xfd, 0x26, 0xb3,
	0x84, 0xbe, 0xc8, 0xfc, 0x26, 0x31, 0xe1, 0x1b, 0x81, 0x50, 0x8e, 0x2d, 0xff, 0x1a, 0xf5, 0xb7,
	0x60, 0x66, 0x09, 0xbd, 0x04, 0x4d, 0x9c, 0xcf, 0xc9, 0xd4, 0x26, 0xf1, 0xd2, 0x1f, 0x11, 0x94,
	0x1f, 0x86, 0xc2, 0x65, 0xad, 0xef, 0xb5, 0x98, 0x25, 0x74, 0x05, 0xc7, 0xc5, 0xf3, 0x42, 0xd1,
	0x8b, 0x1c, 0x7d, 0xe7, 0xf4, 0xd4, 0x4f, 0x76, 0xf6, 0x3d, 0x75, 0xf4, 0x25, 0xc0, 0x30, 0xa1,
	0xb3, 0x14, 0x42, 0x6f, 0x65, 0xed, 0x7d, 0xfb, 0x35, 0x54, 0xc5, 0x8e, 0xc9, 0xc7, 0xa7, 0x3b,
	0xb4, 0x6c, 0x03, 0xf7, 0x79, 0xb8, 0xd4, 0xff, 0xb8, 0x3f, 0x53, 0xfe, 0xbc, 0x3f, 0x53, 0xfe,
	0xba, 0x3f, 0x53, 0x7e, 0xfe, 0xfb, 0xac, 0x74, 0x7b, 0x24, 0x7e, 0xbf, 0x9f, 0xfc, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0xcc, 0x3e, 0xaa, 0x07, 0xac, 0x07, 0x00, 0x00,
}
