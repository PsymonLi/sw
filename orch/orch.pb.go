// Code generated by protoc-gen-go. DO NOT EDIT.
// source: orch.proto

/*
Package orch is a generated protocol buffer package.

It is generated from these files:
	orch.proto

It has these top-level messages:
	Spec
	Filter
	WatchSpec
	WatchEvent
	SmartNIC
	SmartNICList
	SmartNICEvent
	NwIF
	NwIFList
	NwIFEvent
	NwIFMigrationStart
	Empty
	Stats
*/
package orch

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WatchEvent_EventType int32

const (
	WatchEvent_List   WatchEvent_EventType = 0
	WatchEvent_Create WatchEvent_EventType = 1
	WatchEvent_Update WatchEvent_EventType = 2
	WatchEvent_Delete WatchEvent_EventType = 3
)

var WatchEvent_EventType_name = map[int32]string{
	0: "List",
	1: "Create",
	2: "Update",
	3: "Delete",
}
var WatchEvent_EventType_value = map[string]int32{
	"List":   0,
	"Create": 1,
	"Update": 2,
	"Delete": 3,
}

func (x WatchEvent_EventType) String() string {
	return proto.EnumName(WatchEvent_EventType_name, int32(x))
}
func (WatchEvent_EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// Elements of a filter spec
// TODO: migrate to common definition
type Spec struct {
	Key      string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Operator string   `protobuf:"bytes,2,opt,name=operator" json:"operator,omitempty"`
	Values   []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Spec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Spec) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Spec) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// The filter selecting a subset of objects to list
type Filter struct {
	Specs []*Spec `protobuf:"bytes,1,rep,name=specs" json:"specs,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Filter) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Specification for a watch
type WatchSpec struct {
	Refversion string  `protobuf:"bytes,1,opt,name=refversion" json:"refversion,omitempty"`
	Specs      []*Spec `protobuf:"bytes,2,rep,name=specs" json:"specs,omitempty"`
}

func (m *WatchSpec) Reset()                    { *m = WatchSpec{} }
func (m *WatchSpec) String() string            { return proto.CompactTextString(m) }
func (*WatchSpec) ProtoMessage()               {}
func (*WatchSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *WatchSpec) GetRefversion() string {
	if m != nil {
		return m.Refversion
	}
	return ""
}

func (m *WatchSpec) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Response event types for watch
// If the specified resource version is outside the incremental sync window,
// watch will respond with a list.
type WatchEvent struct {
	Event WatchEvent_EventType `protobuf:"varint,1,opt,name=event,enum=orch.WatchEvent_EventType" json:"event,omitempty"`
}

func (m *WatchEvent) Reset()                    { *m = WatchEvent{} }
func (m *WatchEvent) String() string            { return proto.CompactTextString(m) }
func (*WatchEvent) ProtoMessage()               {}
func (*WatchEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WatchEvent) GetEvent() WatchEvent_EventType {
	if m != nil {
		return m.Event
	}
	return WatchEvent_List
}

// A HW NIC aka PNIC, VMNIC in vSphere terminology
type SmartNIC struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string           `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api.ObjectMeta  `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Status           *SmartNIC_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SmartNIC) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNIC) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNIC) GetObjectMeta() *api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *SmartNIC) GetStatus() *SmartNIC_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type SmartNIC_Status struct {
	HostIP     string `protobuf:"bytes,1,opt,name=hostIP" json:"hostIP,omitempty"`
	MacAddress string `protobuf:"bytes,2,opt,name=macAddress" json:"macAddress,omitempty"`
	Switch     string `protobuf:"bytes,3,opt,name=switch" json:"switch,omitempty"`
}

func (m *SmartNIC_Status) Reset()                    { *m = SmartNIC_Status{} }
func (m *SmartNIC_Status) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC_Status) ProtoMessage()               {}
func (*SmartNIC_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *SmartNIC_Status) GetHostIP() string {
	if m != nil {
		return m.HostIP
	}
	return ""
}

func (m *SmartNIC_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *SmartNIC_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

// List of SmartNICs
type SmartNICList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string        `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*SmartNIC   `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *SmartNICList) Reset()                    { *m = SmartNICList{} }
func (m *SmartNICList) String() string            { return proto.CompactTextString(m) }
func (*SmartNICList) ProtoMessage()               {}
func (*SmartNICList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SmartNICList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNICList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNICList) GetListMeta() *api.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *SmartNICList) GetItems() []*SmartNIC {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to SmartNIC watch
type SmartNICEvent struct {
	E         *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Smartnics []*SmartNIC `protobuf:"bytes,2,rep,name=smartnics" json:"smartnics,omitempty"`
}

func (m *SmartNICEvent) Reset()                    { *m = SmartNICEvent{} }
func (m *SmartNICEvent) String() string            { return proto.CompactTextString(m) }
func (*SmartNICEvent) ProtoMessage()               {}
func (*SmartNICEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SmartNICEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *SmartNICEvent) GetSmartnics() []*SmartNIC {
	if m != nil {
		return m.Smartnics
	}
	return nil
}

// A network interface (aka virtual NIC)
type NwIF struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string            `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api.ObjectMeta   `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Config           *NwIF_Config      `protobuf:"bytes,4,opt,name=config" json:"config,omitempty"`
	Status           *NwIF_Status      `protobuf:"bytes,5,opt,name=status" json:"status,omitempty"`
	Attributes       map[string]string `protobuf:"bytes,6,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NwIF) Reset()                    { *m = NwIF{} }
func (m *NwIF) String() string            { return proto.CompactTextString(m) }
func (*NwIF) ProtoMessage()               {}
func (*NwIF) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NwIF) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIF) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIF) GetObjectMeta() *api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *NwIF) GetConfig() *NwIF_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *NwIF) GetStatus() *NwIF_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NwIF) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type NwIF_Config struct {
	LocalVLAN int32 `protobuf:"varint,1,opt,name=localVLAN" json:"localVLAN,omitempty"`
}

func (m *NwIF_Config) Reset()                    { *m = NwIF_Config{} }
func (m *NwIF_Config) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Config) ProtoMessage()               {}
func (*NwIF_Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *NwIF_Config) GetLocalVLAN() int32 {
	if m != nil {
		return m.LocalVLAN
	}
	return 0
}

type NwIF_Status struct {
	MacAddress  string `protobuf:"bytes,1,opt,name=macAddress" json:"macAddress,omitempty"`
	PortGroup   string `protobuf:"bytes,2,opt,name=portGroup" json:"portGroup,omitempty"`
	Switch      string `protobuf:"bytes,3,opt,name=switch" json:"switch,omitempty"`
	SmartNIC_ID string `protobuf:"bytes,4,opt,name=smartNIC_ID,json=smartNICID" json:"smartNIC_ID,omitempty"`
}

func (m *NwIF_Status) Reset()                    { *m = NwIF_Status{} }
func (m *NwIF_Status) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Status) ProtoMessage()               {}
func (*NwIF_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *NwIF_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NwIF_Status) GetPortGroup() string {
	if m != nil {
		return m.PortGroup
	}
	return ""
}

func (m *NwIF_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

func (m *NwIF_Status) GetSmartNIC_ID() string {
	if m != nil {
		return m.SmartNIC_ID
	}
	return ""
}

// List of NwIFs
type NwIFList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string        `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*NwIF       `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *NwIFList) Reset()                    { *m = NwIFList{} }
func (m *NwIFList) String() string            { return proto.CompactTextString(m) }
func (*NwIFList) ProtoMessage()               {}
func (*NwIFList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *NwIFList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIFList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIFList) GetListMeta() *api.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *NwIFList) GetItems() []*NwIF {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to NwIF watch
type NwIFEvent struct {
	E     *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Nwifs []*NwIF     `protobuf:"bytes,2,rep,name=nwifs" json:"nwifs,omitempty"`
}

func (m *NwIFEvent) Reset()                    { *m = NwIFEvent{} }
func (m *NwIFEvent) String() string            { return proto.CompactTextString(m) }
func (*NwIFEvent) ProtoMessage()               {}
func (*NwIFEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *NwIFEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *NwIFEvent) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

// Migration start for network interfaces belonging to a VM
type NwIFMigrationStart struct {
	Nwifs  []*NwIF   `protobuf:"bytes,1,rep,name=nwifs" json:"nwifs,omitempty"`
	Source *SmartNIC `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Dest   *SmartNIC `protobuf:"bytes,3,opt,name=dest" json:"dest,omitempty"`
}

func (m *NwIFMigrationStart) Reset()                    { *m = NwIFMigrationStart{} }
func (m *NwIFMigrationStart) String() string            { return proto.CompactTextString(m) }
func (*NwIFMigrationStart) ProtoMessage()               {}
func (*NwIFMigrationStart) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *NwIFMigrationStart) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

func (m *NwIFMigrationStart) GetSource() *SmartNIC {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *NwIFMigrationStart) GetDest() *SmartNIC {
	if m != nil {
		return m.Dest
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type Stats struct {
	StoreWatchFailCount     int64 `protobuf:"varint,1,opt,name=storeWatchFailCount" json:"storeWatchFailCount,omitempty"`
	StoreWatchErrCount      int64 `protobuf:"varint,2,opt,name=storeWatchErrCount" json:"storeWatchErrCount,omitempty"`
	StoreWatchBadEventCount int64 `protobuf:"varint,3,opt,name=storeWatchBadEventCount" json:"storeWatchBadEventCount,omitempty"`
	StoreWatchBadObjCount   int64 `protobuf:"varint,4,opt,name=storeWatchBadObjCount" json:"storeWatchBadObjCount,omitempty"`
	WatchCloseCount         int64 `protobuf:"varint,5,opt,name=watchCloseCount" json:"watchCloseCount,omitempty"`
	GrpcSendErrCount        int64 `protobuf:"varint,6,opt,name=grpcSendErrCount" json:"grpcSendErrCount,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Stats) GetStoreWatchFailCount() int64 {
	if m != nil {
		return m.StoreWatchFailCount
	}
	return 0
}

func (m *Stats) GetStoreWatchErrCount() int64 {
	if m != nil {
		return m.StoreWatchErrCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadEventCount() int64 {
	if m != nil {
		return m.StoreWatchBadEventCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadObjCount() int64 {
	if m != nil {
		return m.StoreWatchBadObjCount
	}
	return 0
}

func (m *Stats) GetWatchCloseCount() int64 {
	if m != nil {
		return m.WatchCloseCount
	}
	return 0
}

func (m *Stats) GetGrpcSendErrCount() int64 {
	if m != nil {
		return m.GrpcSendErrCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Spec)(nil), "orch.Spec")
	proto.RegisterType((*Filter)(nil), "orch.Filter")
	proto.RegisterType((*WatchSpec)(nil), "orch.WatchSpec")
	proto.RegisterType((*WatchEvent)(nil), "orch.WatchEvent")
	proto.RegisterType((*SmartNIC)(nil), "orch.SmartNIC")
	proto.RegisterType((*SmartNIC_Status)(nil), "orch.SmartNIC.Status")
	proto.RegisterType((*SmartNICList)(nil), "orch.SmartNICList")
	proto.RegisterType((*SmartNICEvent)(nil), "orch.SmartNICEvent")
	proto.RegisterType((*NwIF)(nil), "orch.NwIF")
	proto.RegisterType((*NwIF_Config)(nil), "orch.NwIF.Config")
	proto.RegisterType((*NwIF_Status)(nil), "orch.NwIF.Status")
	proto.RegisterType((*NwIFList)(nil), "orch.NwIFList")
	proto.RegisterType((*NwIFEvent)(nil), "orch.NwIFEvent")
	proto.RegisterType((*NwIFMigrationStart)(nil), "orch.NwIFMigrationStart")
	proto.RegisterType((*Empty)(nil), "orch.Empty")
	proto.RegisterType((*Stats)(nil), "orch.Stats")
	proto.RegisterEnum("orch.WatchEvent_EventType", WatchEvent_EventType_name, WatchEvent_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OrchApi service

type OrchApiClient interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchSmartNICsClient, error)
	// List all NwIF objects that match the filter spec
	ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchNwIFsClient, error)
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (OrchApi_WatchNwIFMigrationClient, error)
	// Get server statistics
	Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error)
}

type orchApiClient struct {
	cc *grpc.ClientConn
}

func NewOrchApiClient(cc *grpc.ClientConn) OrchApiClient {
	return &orchApiClient{cc}
}

func (c *orchApiClient) ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error) {
	out := new(SmartNICList)
	err := grpc.Invoke(ctx, "/orch.OrchApi/ListSmartNICs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchApiClient) WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchSmartNICsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[0], c.cc, "/orch.OrchApi/WatchSmartNICs", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchSmartNICsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchSmartNICsClient interface {
	Recv() (*SmartNICEvent, error)
	grpc.ClientStream
}

type orchApiWatchSmartNICsClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchSmartNICsClient) Recv() (*SmartNICEvent, error) {
	m := new(SmartNICEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error) {
	out := new(NwIFList)
	err := grpc.Invoke(ctx, "/orch.OrchApi/ListNwIFs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchApiClient) WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchNwIFsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[1], c.cc, "/orch.OrchApi/WatchNwIFs", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchNwIFsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchNwIFsClient interface {
	Recv() (*NwIFEvent, error)
	grpc.ClientStream
}

type orchApiWatchNwIFsClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchNwIFsClient) Recv() (*NwIFEvent, error) {
	m := new(NwIFEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (OrchApi_WatchNwIFMigrationClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[2], c.cc, "/orch.OrchApi/WatchNwIFMigration", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchNwIFMigrationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchNwIFMigrationClient interface {
	Recv() (*NwIFMigrationStart, error)
	grpc.ClientStream
}

type orchApiWatchNwIFMigrationClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchNwIFMigrationClient) Recv() (*NwIFMigrationStart, error) {
	m := new(NwIFMigrationStart)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error) {
	out := new(Stats)
	err := grpc.Invoke(ctx, "/orch.OrchApi/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for OrchApi service

type OrchApiServer interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(context.Context, *Filter) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(*WatchSpec, OrchApi_WatchSmartNICsServer) error
	// List all NwIF objects that match the filter spec
	ListNwIFs(context.Context, *Filter) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(*WatchSpec, OrchApi_WatchNwIFsServer) error
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(*Filter, OrchApi_WatchNwIFMigrationServer) error
	// Get server statistics
	Inspect(context.Context, *Empty) (*Stats, error)
}

func RegisterOrchApiServer(s *grpc.Server, srv OrchApiServer) {
	s.RegisterService(&_OrchApi_serviceDesc, srv)
}

func _OrchApi_ListSmartNICs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).ListSmartNICs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/ListSmartNICs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).ListSmartNICs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchApi_WatchSmartNICs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchSmartNICs(m, &orchApiWatchSmartNICsServer{stream})
}

type OrchApi_WatchSmartNICsServer interface {
	Send(*SmartNICEvent) error
	grpc.ServerStream
}

type orchApiWatchSmartNICsServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchSmartNICsServer) Send(m *SmartNICEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_ListNwIFs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).ListNwIFs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/ListNwIFs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).ListNwIFs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchApi_WatchNwIFs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchNwIFs(m, &orchApiWatchNwIFsServer{stream})
}

type OrchApi_WatchNwIFsServer interface {
	Send(*NwIFEvent) error
	grpc.ServerStream
}

type orchApiWatchNwIFsServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchNwIFsServer) Send(m *NwIFEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_WatchNwIFMigration_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchNwIFMigration(m, &orchApiWatchNwIFMigrationServer{stream})
}

type OrchApi_WatchNwIFMigrationServer interface {
	Send(*NwIFMigrationStart) error
	grpc.ServerStream
}

type orchApiWatchNwIFMigrationServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchNwIFMigrationServer) Send(m *NwIFMigrationStart) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).Inspect(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrchApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orch.OrchApi",
	HandlerType: (*OrchApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSmartNICs",
			Handler:    _OrchApi_ListSmartNICs_Handler,
		},
		{
			MethodName: "ListNwIFs",
			Handler:    _OrchApi_ListNwIFs_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _OrchApi_Inspect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSmartNICs",
			Handler:       _OrchApi_WatchSmartNICs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFs",
			Handler:       _OrchApi_WatchNwIFs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFMigration",
			Handler:       _OrchApi_WatchNwIFMigration_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "orch.proto",
}

func init() { proto.RegisterFile("orch.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xdb, 0x8e, 0xdb, 0x44,
	0x18, 0x5e, 0x27, 0xb1, 0x37, 0xfe, 0xd3, 0xdd, 0x84, 0x29, 0x85, 0xc8, 0xaa, 0x4a, 0x64, 0xd1,
	0x2a, 0x2d, 0xe0, 0xac, 0x52, 0x2e, 0xca, 0x4a, 0x48, 0x84, 0xec, 0x2e, 0x8a, 0xd8, 0x43, 0xe5,
	0x40, 0xe1, 0x06, 0xa1, 0x89, 0x33, 0xbb, 0x99, 0x92, 0x78, 0xac, 0x99, 0xc9, 0x46, 0xb9, 0x42,
	0xe2, 0x09, 0x78, 0x07, 0x2e, 0xb9, 0xe0, 0x25, 0x78, 0x2d, 0x24, 0x34, 0x87, 0xd8, 0x39, 0xec,
	0x4a, 0x5c, 0x20, 0xf5, 0x26, 0x9a, 0xf9, 0xfe, 0xef, 0x3f, 0xcc, 0xe7, 0xcf, 0x9e, 0x00, 0x30,
	0x9e, 0x4c, 0xa2, 0x8c, 0x33, 0xc9, 0x50, 0x45, 0xad, 0x83, 0xa7, 0x37, 0x54, 0x4e, 0xe6, 0xa3,
	0x28, 0x61, 0xb3, 0x4e, 0x46, 0x52, 0x81, 0xd3, 0x31, 0xeb, 0x88, 0x45, 0x07, 0x67, 0xb4, 0x33,
	0x23, 0x12, 0x1b, 0x72, 0x78, 0x0e, 0x95, 0x61, 0x46, 0x12, 0xd4, 0x80, 0xf2, 0x2f, 0x64, 0xd9,
	0x74, 0x5a, 0x4e, 0xdb, 0x8f, 0xd5, 0x12, 0x05, 0x50, 0x65, 0x19, 0xe1, 0x58, 0x32, 0xde, 0x2c,
	0x69, 0x38, 0xdf, 0xa3, 0x0f, 0xc0, 0xbb, 0xc5, 0xd3, 0x39, 0x11, 0xcd, 0x72, 0xab, 0xdc, 0xf6,
	0x63, 0xbb, 0x0b, 0x5f, 0x80, 0x77, 0x46, 0xa7, 0x92, 0x70, 0xd4, 0x02, 0x57, 0x64, 0x24, 0x11,
	0x4d, 0xa7, 0x55, 0x6e, 0xd7, 0xba, 0x10, 0xe9, 0x01, 0x55, 0xab, 0xd8, 0x04, 0xc2, 0x0b, 0xf0,
	0x7f, 0xc0, 0x32, 0x99, 0xe8, 0xf6, 0x4f, 0x00, 0x38, 0xb9, 0xbe, 0x25, 0x5c, 0x50, 0x96, 0xda,
	0x29, 0xd6, 0x90, 0xa2, 0x5c, 0xe9, 0xbe, 0x72, 0x4b, 0x00, 0x5d, 0xee, 0xf4, 0x96, 0xa4, 0x12,
	0x1d, 0x81, 0x4b, 0xd4, 0x42, 0x97, 0x3a, 0xec, 0x06, 0x86, 0x5f, 0x10, 0x22, 0xfd, 0xfb, 0xdd,
	0x32, 0x23, 0xb1, 0x21, 0x86, 0x5f, 0x80, 0x9f, 0x63, 0xa8, 0x0a, 0x95, 0x73, 0x2a, 0x64, 0x63,
	0x0f, 0x01, 0x78, 0x7d, 0x4e, 0xb0, 0x24, 0x0d, 0x47, 0xad, 0xbf, 0xcf, 0xc6, 0x6a, 0x5d, 0x52,
	0xeb, 0x13, 0x32, 0x25, 0x92, 0x34, 0xca, 0xe1, 0xef, 0x25, 0xa8, 0x0e, 0x67, 0x98, 0xcb, 0xcb,
	0x41, 0x5f, 0x9d, 0xe4, 0x6a, 0xf4, 0x96, 0x24, 0xf2, 0x5b, 0x9a, 0x8e, 0x57, 0x27, 0x29, 0x10,
	0xf4, 0x02, 0x1a, 0x66, 0xd7, 0x7b, 0x3d, 0x78, 0x63, 0xcf, 0x6b, 0xe4, 0xdd, 0xc1, 0x51, 0x67,
	0x55, 0xeb, 0x82, 0x48, 0xdc, 0x2c, 0xb7, 0x9c, 0x76, 0xad, 0x5b, 0x8f, 0x70, 0x46, 0xa3, 0x02,
	0x8e, 0xd7, 0x28, 0xe8, 0x33, 0xf0, 0x84, 0xc4, 0x72, 0x2e, 0x9a, 0x15, 0x4d, 0x7e, 0x64, 0x75,
	0xb2, 0xc3, 0x45, 0x43, 0x1d, 0x8c, 0x2d, 0x29, 0xf8, 0x11, 0x3c, 0x83, 0xa8, 0x07, 0x3a, 0x61,
	0x42, 0x0e, 0x5e, 0xdb, 0x89, 0xed, 0x4e, 0x9d, 0x66, 0x86, 0x93, 0xde, 0x78, 0xcc, 0x89, 0x10,
	0x76, 0xce, 0x35, 0x44, 0xe5, 0x89, 0x05, 0x95, 0xc9, 0x44, 0x4f, 0xe7, 0xc7, 0x76, 0x17, 0xfe,
	0xe9, 0xc0, 0x83, 0x55, 0x57, 0xa5, 0xe4, 0xff, 0x2a, 0xcb, 0x73, 0xa8, 0xaa, 0x9a, 0x6b, 0xa2,
	0x1c, 0x68, 0x51, 0x56, 0x60, 0x9c, 0x87, 0xd1, 0xc7, 0xe0, 0x52, 0x49, 0x66, 0x4a, 0x0f, 0xe5,
	0x9b, 0xc3, 0x4d, 0x3d, 0x62, 0x13, 0x0c, 0x7f, 0x82, 0x83, 0x15, 0x64, 0xec, 0xf3, 0x04, 0x1c,
	0xa2, 0x87, 0xac, 0x75, 0x1b, 0xdb, 0xd6, 0x89, 0x1d, 0x82, 0x3e, 0x05, 0x5f, 0xa8, 0x84, 0x94,
	0xe6, 0x96, 0xdc, 0x2e, 0x5d, 0x10, 0xc2, 0x7f, 0xca, 0x50, 0xb9, 0x5c, 0x0c, 0xce, 0xde, 0xad,
	0x37, 0x9e, 0x83, 0x97, 0xb0, 0xf4, 0x9a, 0xde, 0x58, 0x6f, 0xbc, 0x67, 0x06, 0x56, 0x83, 0x45,
	0x7d, 0x1d, 0x88, 0x2d, 0x41, 0x51, 0xad, 0x8d, 0xdc, 0x1d, 0xea, 0xa6, 0x85, 0xd0, 0x31, 0x00,
	0x96, 0x92, 0xd3, 0xd1, 0x5c, 0x12, 0xd1, 0xf4, 0xb4, 0x14, 0xc1, 0x1a, 0xbd, 0x97, 0x07, 0x4f,
	0x53, 0xc9, 0x97, 0xf1, 0x1a, 0x3b, 0x78, 0x06, 0x9e, 0x69, 0x8c, 0x1e, 0x83, 0x3f, 0x65, 0x09,
	0x9e, 0xbe, 0x39, 0xef, 0x5d, 0x6a, 0x5d, 0xdc, 0xb8, 0x00, 0x82, 0x5f, 0x73, 0x9b, 0x6e, 0xda,
	0xd1, 0xd9, 0xb1, 0xe3, 0x63, 0xf0, 0x33, 0xc6, 0xe5, 0x37, 0x9c, 0xcd, 0x33, 0xab, 0x5c, 0x01,
	0xdc, 0x67, 0x56, 0xf4, 0x11, 0xd4, 0x84, 0x7d, 0x6c, 0x3f, 0x0f, 0x4e, 0xb4, 0x3c, 0x7e, 0x0c,
	0x2b, 0x68, 0x70, 0x12, 0x7c, 0x09, 0xf5, 0xad, 0x73, 0xdc, 0xf1, 0xbd, 0x7c, 0x1f, 0x5c, 0xfd,
	0x15, 0xb4, 0x7d, 0xcd, 0xe6, 0xb8, 0xf4, 0xca, 0x09, 0xff, 0x70, 0xa0, 0xaa, 0xc4, 0x78, 0x97,
	0x2f, 0x42, 0x6b, 0xf3, 0x45, 0x80, 0xe2, 0x11, 0xad, 0x5e, 0x82, 0x0b, 0xf0, 0xd5, 0xf6, 0xbf,
	0xbd, 0x00, 0x2d, 0x70, 0xd3, 0x05, 0xbd, 0xde, 0xfa, 0x1e, 0x9b, 0x72, 0x3a, 0x10, 0xfe, 0xe6,
	0x00, 0x52, 0xfb, 0x0b, 0x7a, 0xc3, 0xb1, 0xa4, 0x2c, 0x1d, 0x4a, 0xcc, 0x65, 0x91, 0xe8, 0xdc,
	0x93, 0x88, 0x9e, 0x81, 0x27, 0xd8, 0x9c, 0x27, 0x46, 0xc8, 0xdd, 0x17, 0xcb, 0x46, 0x51, 0x08,
	0x95, 0x31, 0x11, 0xd2, 0x1e, 0x7c, 0x9b, 0xa5, 0x63, 0xe1, 0x3e, 0xb8, 0xa7, 0xb3, 0x4c, 0x2e,
	0xc3, 0xbf, 0x4a, 0xe0, 0x2a, 0x0f, 0x09, 0x74, 0x04, 0x0f, 0x85, 0x64, 0x9c, 0xe8, 0xf3, 0x9c,
	0x61, 0x3a, 0xed, 0xb3, 0xb9, 0xbd, 0x27, 0xca, 0xf1, 0x5d, 0x21, 0x14, 0x01, 0x2a, 0xe0, 0x53,
	0xce, 0x4d, 0x42, 0x49, 0x27, 0xdc, 0x11, 0x41, 0xaf, 0xe0, 0xc3, 0x02, 0xfd, 0x1a, 0x8f, 0xb5,
	0x68, 0x26, 0xa9, 0xac, 0x93, 0xee, 0x0b, 0xa3, 0xcf, 0xe1, 0xd1, 0x46, 0xe8, 0x6a, 0xf4, 0xd6,
	0xe4, 0x55, 0x74, 0xde, 0xdd, 0x41, 0xd4, 0x86, 0xfa, 0x42, 0x61, 0xfd, 0x29, 0x13, 0xc4, 0xf0,
	0x5d, 0xcd, 0xdf, 0x86, 0x95, 0xb7, 0x6e, 0x78, 0x96, 0x0c, 0x49, 0x3a, 0xce, 0xcf, 0xe1, 0x69,
	0xea, 0x0e, 0xde, 0xfd, 0xbb, 0x04, 0xfb, 0x57, 0x3c, 0x99, 0xf4, 0x32, 0x8a, 0x5e, 0xc2, 0x81,
	0x32, 0xd2, 0x4a, 0x5c, 0x81, 0x1e, 0x18, 0xb5, 0xcd, 0x5d, 0x1f, 0xa0, 0x4d, 0xed, 0x15, 0x35,
	0xdc, 0x43, 0xc7, 0x70, 0x68, 0xee, 0xf7, 0x3c, 0xab, 0xbe, 0xe6, 0x24, 0x75, 0x75, 0x07, 0x0f,
	0x37, 0x13, 0xb5, 0x12, 0xe1, 0xde, 0x91, 0x83, 0x3e, 0x01, 0x5f, 0x55, 0x51, 0xb6, 0xd8, 0x6e,
	0x76, 0x58, 0x38, 0xc6, 0x36, 0xea, 0xda, 0x9b, 0xdf, 0xb0, 0x77, 0x9a, 0xd4, 0x8b, 0x84, 0xa2,
	0xc1, 0x57, 0x80, 0xf2, 0x9c, 0xdc, 0xa1, 0x5b, 0x9d, 0x9a, 0x45, 0xe2, 0xa6, 0x89, 0x75, 0x85,
	0xa7, 0xb0, 0x3f, 0x48, 0xd5, 0x5f, 0x0f, 0x89, 0x6a, 0x86, 0xa8, 0x9d, 0x16, 0xd8, 0x8d, 0x36,
	0x5b, 0xb8, 0x37, 0xf2, 0xf4, 0xdf, 0xac, 0x97, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xc3,
	0x5f, 0x91, 0xa1, 0x09, 0x00, 0x00,
}
