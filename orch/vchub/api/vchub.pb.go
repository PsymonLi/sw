// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vchub.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	vchub.proto

It has these top-level messages:
	Spec
	Filter
	WatchSpec
	WatchEvent
	SmartNIC
	SmartNICList
	SmartNICEvent
	NwIF
	NwIFList
	NwIFEvent
	NwIFMigrationStart
	Empty
	Stats
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import api1 "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WatchEvent_EventType int32

const (
	WatchEvent_List   WatchEvent_EventType = 0
	WatchEvent_Create WatchEvent_EventType = 1
	WatchEvent_Update WatchEvent_EventType = 2
	WatchEvent_Delete WatchEvent_EventType = 3
)

var WatchEvent_EventType_name = map[int32]string{
	0: "List",
	1: "Create",
	2: "Update",
	3: "Delete",
}
var WatchEvent_EventType_value = map[string]int32{
	"List":   0,
	"Create": 1,
	"Update": 2,
	"Delete": 3,
}

func (x WatchEvent_EventType) String() string {
	return proto.EnumName(WatchEvent_EventType_name, int32(x))
}
func (WatchEvent_EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// Elements of a filter spec
type Spec struct {
	Key      string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Operator string   `protobuf:"bytes,2,opt,name=operator" json:"operator,omitempty"`
	Values   []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Spec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Spec) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Spec) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// The filter selecting a subset of objects to list
type Filter struct {
	Specs []*Spec `protobuf:"bytes,1,rep,name=specs" json:"specs,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Filter) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Specification for a watch
type WatchSpec struct {
	Refversion string  `protobuf:"bytes,1,opt,name=refversion" json:"refversion,omitempty"`
	Specs      []*Spec `protobuf:"bytes,2,rep,name=specs" json:"specs,omitempty"`
}

func (m *WatchSpec) Reset()                    { *m = WatchSpec{} }
func (m *WatchSpec) String() string            { return proto.CompactTextString(m) }
func (*WatchSpec) ProtoMessage()               {}
func (*WatchSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *WatchSpec) GetRefversion() string {
	if m != nil {
		return m.Refversion
	}
	return ""
}

func (m *WatchSpec) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Response event types for watch
// If the specified resource version is outside the incremental sync window,
// watch will respond with a list.
type WatchEvent struct {
	Event WatchEvent_EventType `protobuf:"varint,1,opt,name=event,enum=api.WatchEvent_EventType" json:"event,omitempty"`
}

func (m *WatchEvent) Reset()                    { *m = WatchEvent{} }
func (m *WatchEvent) String() string            { return proto.CompactTextString(m) }
func (*WatchEvent) ProtoMessage()               {}
func (*WatchEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WatchEvent) GetEvent() WatchEvent_EventType {
	if m != nil {
		return m.Event
	}
	return WatchEvent_List
}

// A HW NIC aka PNIC, VMNIC in vSphere terminology
type SmartNIC struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string           `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api1.ObjectMeta `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Status           *SmartNIC_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SmartNIC) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNIC) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNIC) GetObjectMeta() *api1.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *SmartNIC) GetStatus() *SmartNIC_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type SmartNIC_Status struct {
	HostIP     string `protobuf:"bytes,1,opt,name=hostIP" json:"hostIP,omitempty"`
	MacAddress string `protobuf:"bytes,2,opt,name=macAddress" json:"macAddress,omitempty"`
	Switch     string `protobuf:"bytes,3,opt,name=switch" json:"switch,omitempty"`
}

func (m *SmartNIC_Status) Reset()                    { *m = SmartNIC_Status{} }
func (m *SmartNIC_Status) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC_Status) ProtoMessage()               {}
func (*SmartNIC_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *SmartNIC_Status) GetHostIP() string {
	if m != nil {
		return m.HostIP
	}
	return ""
}

func (m *SmartNIC_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *SmartNIC_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

// List of SmartNICs
type SmartNICList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string         `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api1.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*SmartNIC    `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *SmartNICList) Reset()                    { *m = SmartNICList{} }
func (m *SmartNICList) String() string            { return proto.CompactTextString(m) }
func (*SmartNICList) ProtoMessage()               {}
func (*SmartNICList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SmartNICList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNICList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNICList) GetListMeta() *api1.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *SmartNICList) GetItems() []*SmartNIC {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to SmartNIC watch
type SmartNICEvent struct {
	E         *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Smartnics []*SmartNIC `protobuf:"bytes,2,rep,name=smartnics" json:"smartnics,omitempty"`
}

func (m *SmartNICEvent) Reset()                    { *m = SmartNICEvent{} }
func (m *SmartNICEvent) String() string            { return proto.CompactTextString(m) }
func (*SmartNICEvent) ProtoMessage()               {}
func (*SmartNICEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SmartNICEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *SmartNICEvent) GetSmartnics() []*SmartNIC {
	if m != nil {
		return m.Smartnics
	}
	return nil
}

// A network interface (aka virtual NIC)
type NwIF struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string            `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api1.ObjectMeta  `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Config           *NwIF_Config      `protobuf:"bytes,4,opt,name=config" json:"config,omitempty"`
	Status           *NwIF_Status      `protobuf:"bytes,5,opt,name=status" json:"status,omitempty"`
	Attributes       map[string]string `protobuf:"bytes,6,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NwIF) Reset()                    { *m = NwIF{} }
func (m *NwIF) String() string            { return proto.CompactTextString(m) }
func (*NwIF) ProtoMessage()               {}
func (*NwIF) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NwIF) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIF) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIF) GetObjectMeta() *api1.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *NwIF) GetConfig() *NwIF_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *NwIF) GetStatus() *NwIF_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NwIF) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type NwIF_Config struct {
	LocalVLAN int32 `protobuf:"varint,1,opt,name=localVLAN" json:"localVLAN,omitempty"`
}

func (m *NwIF_Config) Reset()                    { *m = NwIF_Config{} }
func (m *NwIF_Config) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Config) ProtoMessage()               {}
func (*NwIF_Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *NwIF_Config) GetLocalVLAN() int32 {
	if m != nil {
		return m.LocalVLAN
	}
	return 0
}

type NwIF_Status struct {
	MacAddress  string `protobuf:"bytes,1,opt,name=macAddress" json:"macAddress,omitempty"`
	PortGroup   string `protobuf:"bytes,2,opt,name=portGroup" json:"portGroup,omitempty"`
	Switch      string `protobuf:"bytes,3,opt,name=switch" json:"switch,omitempty"`
	SmartNIC_ID string `protobuf:"bytes,4,opt,name=smartNIC_ID,json=smartNICID" json:"smartNIC_ID,omitempty"`
}

func (m *NwIF_Status) Reset()                    { *m = NwIF_Status{} }
func (m *NwIF_Status) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Status) ProtoMessage()               {}
func (*NwIF_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *NwIF_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NwIF_Status) GetPortGroup() string {
	if m != nil {
		return m.PortGroup
	}
	return ""
}

func (m *NwIF_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

func (m *NwIF_Status) GetSmartNIC_ID() string {
	if m != nil {
		return m.SmartNIC_ID
	}
	return ""
}

// List of NwIFs
type NwIFList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string         `protobuf:"bytes,2,opt,name=ObjectAPIVersion" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api1.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*NwIF        `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *NwIFList) Reset()                    { *m = NwIFList{} }
func (m *NwIFList) String() string            { return proto.CompactTextString(m) }
func (*NwIFList) ProtoMessage()               {}
func (*NwIFList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *NwIFList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIFList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIFList) GetListMeta() *api1.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *NwIFList) GetItems() []*NwIF {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to NwIF watch
type NwIFEvent struct {
	E     *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Nwifs []*NwIF     `protobuf:"bytes,2,rep,name=nwifs" json:"nwifs,omitempty"`
}

func (m *NwIFEvent) Reset()                    { *m = NwIFEvent{} }
func (m *NwIFEvent) String() string            { return proto.CompactTextString(m) }
func (*NwIFEvent) ProtoMessage()               {}
func (*NwIFEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *NwIFEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *NwIFEvent) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

// Migration start for network interfaces belonging to a VM
type NwIFMigrationStart struct {
	Nwifs  []*NwIF   `protobuf:"bytes,1,rep,name=nwifs" json:"nwifs,omitempty"`
	Source *SmartNIC `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Dest   *SmartNIC `protobuf:"bytes,3,opt,name=dest" json:"dest,omitempty"`
}

func (m *NwIFMigrationStart) Reset()                    { *m = NwIFMigrationStart{} }
func (m *NwIFMigrationStart) String() string            { return proto.CompactTextString(m) }
func (*NwIFMigrationStart) ProtoMessage()               {}
func (*NwIFMigrationStart) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *NwIFMigrationStart) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

func (m *NwIFMigrationStart) GetSource() *SmartNIC {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *NwIFMigrationStart) GetDest() *SmartNIC {
	if m != nil {
		return m.Dest
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type Stats struct {
	StoreWatchFailCount     int64 `protobuf:"varint,1,opt,name=storeWatchFailCount" json:"storeWatchFailCount,omitempty"`
	StoreWatchErrCount      int64 `protobuf:"varint,2,opt,name=storeWatchErrCount" json:"storeWatchErrCount,omitempty"`
	StoreWatchBadEventCount int64 `protobuf:"varint,3,opt,name=storeWatchBadEventCount" json:"storeWatchBadEventCount,omitempty"`
	StoreWatchBadObjCount   int64 `protobuf:"varint,4,opt,name=storeWatchBadObjCount" json:"storeWatchBadObjCount,omitempty"`
	WatchCloseCount         int64 `protobuf:"varint,5,opt,name=watchCloseCount" json:"watchCloseCount,omitempty"`
	GrpcSendErrCount        int64 `protobuf:"varint,6,opt,name=grpcSendErrCount" json:"grpcSendErrCount,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Stats) GetStoreWatchFailCount() int64 {
	if m != nil {
		return m.StoreWatchFailCount
	}
	return 0
}

func (m *Stats) GetStoreWatchErrCount() int64 {
	if m != nil {
		return m.StoreWatchErrCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadEventCount() int64 {
	if m != nil {
		return m.StoreWatchBadEventCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadObjCount() int64 {
	if m != nil {
		return m.StoreWatchBadObjCount
	}
	return 0
}

func (m *Stats) GetWatchCloseCount() int64 {
	if m != nil {
		return m.WatchCloseCount
	}
	return 0
}

func (m *Stats) GetGrpcSendErrCount() int64 {
	if m != nil {
		return m.GrpcSendErrCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Spec)(nil), "api.Spec")
	proto.RegisterType((*Filter)(nil), "api.Filter")
	proto.RegisterType((*WatchSpec)(nil), "api.WatchSpec")
	proto.RegisterType((*WatchEvent)(nil), "api.WatchEvent")
	proto.RegisterType((*SmartNIC)(nil), "api.SmartNIC")
	proto.RegisterType((*SmartNIC_Status)(nil), "api.SmartNIC.Status")
	proto.RegisterType((*SmartNICList)(nil), "api.SmartNICList")
	proto.RegisterType((*SmartNICEvent)(nil), "api.SmartNICEvent")
	proto.RegisterType((*NwIF)(nil), "api.NwIF")
	proto.RegisterType((*NwIF_Config)(nil), "api.NwIF.Config")
	proto.RegisterType((*NwIF_Status)(nil), "api.NwIF.Status")
	proto.RegisterType((*NwIFList)(nil), "api.NwIFList")
	proto.RegisterType((*NwIFEvent)(nil), "api.NwIFEvent")
	proto.RegisterType((*NwIFMigrationStart)(nil), "api.NwIFMigrationStart")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*Stats)(nil), "api.Stats")
	proto.RegisterEnum("api.WatchEvent_EventType", WatchEvent_EventType_name, WatchEvent_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VCHubApi service

type VCHubApiClient interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (VCHubApi_WatchSmartNICsClient, error)
	// List all NwIF objects that match the filter spec
	ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (VCHubApi_WatchNwIFsClient, error)
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (VCHubApi_WatchNwIFMigrationClient, error)
	// Get server statistics
	Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error)
}

type vCHubApiClient struct {
	cc *grpc.ClientConn
}

func NewVCHubApiClient(cc *grpc.ClientConn) VCHubApiClient {
	return &vCHubApiClient{cc}
}

func (c *vCHubApiClient) ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error) {
	out := new(SmartNICList)
	err := grpc.Invoke(ctx, "/api.VCHubApi/ListSmartNICs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCHubApiClient) WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (VCHubApi_WatchSmartNICsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VCHubApi_serviceDesc.Streams[0], c.cc, "/api.VCHubApi/WatchSmartNICs", opts...)
	if err != nil {
		return nil, err
	}
	x := &vCHubApiWatchSmartNICsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VCHubApi_WatchSmartNICsClient interface {
	Recv() (*SmartNICEvent, error)
	grpc.ClientStream
}

type vCHubApiWatchSmartNICsClient struct {
	grpc.ClientStream
}

func (x *vCHubApiWatchSmartNICsClient) Recv() (*SmartNICEvent, error) {
	m := new(SmartNICEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vCHubApiClient) ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error) {
	out := new(NwIFList)
	err := grpc.Invoke(ctx, "/api.VCHubApi/ListNwIFs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCHubApiClient) WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (VCHubApi_WatchNwIFsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VCHubApi_serviceDesc.Streams[1], c.cc, "/api.VCHubApi/WatchNwIFs", opts...)
	if err != nil {
		return nil, err
	}
	x := &vCHubApiWatchNwIFsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VCHubApi_WatchNwIFsClient interface {
	Recv() (*NwIFEvent, error)
	grpc.ClientStream
}

type vCHubApiWatchNwIFsClient struct {
	grpc.ClientStream
}

func (x *vCHubApiWatchNwIFsClient) Recv() (*NwIFEvent, error) {
	m := new(NwIFEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vCHubApiClient) WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (VCHubApi_WatchNwIFMigrationClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VCHubApi_serviceDesc.Streams[2], c.cc, "/api.VCHubApi/WatchNwIFMigration", opts...)
	if err != nil {
		return nil, err
	}
	x := &vCHubApiWatchNwIFMigrationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VCHubApi_WatchNwIFMigrationClient interface {
	Recv() (*NwIFMigrationStart, error)
	grpc.ClientStream
}

type vCHubApiWatchNwIFMigrationClient struct {
	grpc.ClientStream
}

func (x *vCHubApiWatchNwIFMigrationClient) Recv() (*NwIFMigrationStart, error) {
	m := new(NwIFMigrationStart)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vCHubApiClient) Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error) {
	out := new(Stats)
	err := grpc.Invoke(ctx, "/api.VCHubApi/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VCHubApi service

type VCHubApiServer interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(context.Context, *Filter) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(*WatchSpec, VCHubApi_WatchSmartNICsServer) error
	// List all NwIF objects that match the filter spec
	ListNwIFs(context.Context, *Filter) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(*WatchSpec, VCHubApi_WatchNwIFsServer) error
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(*Filter, VCHubApi_WatchNwIFMigrationServer) error
	// Get server statistics
	Inspect(context.Context, *Empty) (*Stats, error)
}

func RegisterVCHubApiServer(s *grpc.Server, srv VCHubApiServer) {
	s.RegisterService(&_VCHubApi_serviceDesc, srv)
}

func _VCHubApi_ListSmartNICs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCHubApiServer).ListSmartNICs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCHubApi/ListSmartNICs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCHubApiServer).ListSmartNICs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCHubApi_WatchSmartNICs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VCHubApiServer).WatchSmartNICs(m, &vCHubApiWatchSmartNICsServer{stream})
}

type VCHubApi_WatchSmartNICsServer interface {
	Send(*SmartNICEvent) error
	grpc.ServerStream
}

type vCHubApiWatchSmartNICsServer struct {
	grpc.ServerStream
}

func (x *vCHubApiWatchSmartNICsServer) Send(m *SmartNICEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _VCHubApi_ListNwIFs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCHubApiServer).ListNwIFs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCHubApi/ListNwIFs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCHubApiServer).ListNwIFs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCHubApi_WatchNwIFs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VCHubApiServer).WatchNwIFs(m, &vCHubApiWatchNwIFsServer{stream})
}

type VCHubApi_WatchNwIFsServer interface {
	Send(*NwIFEvent) error
	grpc.ServerStream
}

type vCHubApiWatchNwIFsServer struct {
	grpc.ServerStream
}

func (x *vCHubApiWatchNwIFsServer) Send(m *NwIFEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _VCHubApi_WatchNwIFMigration_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VCHubApiServer).WatchNwIFMigration(m, &vCHubApiWatchNwIFMigrationServer{stream})
}

type VCHubApi_WatchNwIFMigrationServer interface {
	Send(*NwIFMigrationStart) error
	grpc.ServerStream
}

type vCHubApiWatchNwIFMigrationServer struct {
	grpc.ServerStream
}

func (x *vCHubApiWatchNwIFMigrationServer) Send(m *NwIFMigrationStart) error {
	return x.ServerStream.SendMsg(m)
}

func _VCHubApi_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCHubApiServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCHubApi/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCHubApiServer).Inspect(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _VCHubApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.VCHubApi",
	HandlerType: (*VCHubApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSmartNICs",
			Handler:    _VCHubApi_ListSmartNICs_Handler,
		},
		{
			MethodName: "ListNwIFs",
			Handler:    _VCHubApi_ListNwIFs_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _VCHubApi_Inspect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSmartNICs",
			Handler:       _VCHubApi_WatchSmartNICs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFs",
			Handler:       _VCHubApi_WatchNwIFs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFMigration",
			Handler:       _VCHubApi_WatchNwIFMigration_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vchub.proto",
}

func init() { proto.RegisterFile("vchub.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 948 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0xe3, 0xd8, 0x1b, 0xbf, 0xd0, 0x36, 0x0c, 0x0b, 0x9b, 0xb5, 0x16, 0x5a, 0xbc, 0x5a,
	0x94, 0x02, 0x4a, 0x4a, 0xe1, 0xd0, 0x45, 0x02, 0x29, 0xa4, 0x2d, 0x44, 0xdb, 0xed, 0xae, 0x1c,
	0x28, 0x48, 0x1c, 0xd0, 0xc4, 0x99, 0xb6, 0xb3, 0x24, 0x1e, 0x6b, 0x66, 0xd2, 0xd0, 0xd3, 0xfe,
	0x09, 0xfc, 0x0f, 0x1c, 0xb9, 0x70, 0xe6, 0x5f, 0xe3, 0x84, 0xe6, 0x87, 0xed, 0x38, 0x4d, 0x25,
	0x0e, 0x48, 0x7b, 0x89, 0x66, 0xbe, 0xf7, 0xbd, 0xf7, 0xe6, 0x7d, 0xfe, 0xec, 0x09, 0x34, 0xaf,
	0x93, 0xab, 0xf9, 0xb8, 0x9b, 0x71, 0x26, 0x19, 0x72, 0x71, 0x46, 0xc3, 0x27, 0x97, 0x54, 0x2a,
	0x28, 0x61, 0xb3, 0x5e, 0x46, 0x52, 0x81, 0xd3, 0x09, 0xeb, 0x89, 0x45, 0x0f, 0x67, 0xb4, 0x37,
	0x23, 0x12, 0x1b, 0x6e, 0x74, 0x0a, 0xf5, 0x51, 0x46, 0x12, 0xd4, 0x02, 0xf7, 0x57, 0x72, 0xd3,
	0x76, 0x76, 0x9d, 0x4e, 0x10, 0xab, 0x25, 0x0a, 0xa1, 0xc1, 0x32, 0xc2, 0xb1, 0x64, 0xbc, 0x5d,
	0xd3, 0x70, 0xb1, 0x47, 0xef, 0x81, 0x7f, 0x8d, 0xa7, 0x73, 0x22, 0xda, 0xee, 0xae, 0xdb, 0x09,
	0x62, 0xbb, 0x8b, 0xf6, 0xc0, 0x3f, 0xa1, 0x53, 0x49, 0x38, 0xda, 0x01, 0x4f, 0x64, 0x24, 0x11,
	0x6d, 0x67, 0xd7, 0xed, 0x34, 0x0f, 0x82, 0x2e, 0xce, 0x68, 0x57, 0x75, 0x8a, 0x0d, 0x1e, 0x9d,
	0x42, 0xf0, 0x23, 0x96, 0xc9, 0x95, 0xee, 0xfe, 0x01, 0x00, 0x27, 0x17, 0xd7, 0x84, 0x0b, 0xca,
	0x52, 0x7b, 0x88, 0x25, 0xa4, 0xac, 0x56, 0xbb, 0xa3, 0xda, 0x6f, 0x00, 0xba, 0xda, 0xf1, 0x35,
	0x49, 0x25, 0xea, 0x81, 0x47, 0xd4, 0x42, 0x57, 0xda, 0x3a, 0x78, 0xa8, 0xe9, 0x65, 0xbc, 0xab,
	0x7f, 0xbf, 0xbf, 0xc9, 0x48, 0x6c, 0x78, 0xd1, 0x53, 0x08, 0x0a, 0x0c, 0x35, 0xa0, 0x7e, 0x4a,
	0x85, 0x6c, 0x6d, 0x20, 0x00, 0x7f, 0xc0, 0x09, 0x96, 0xa4, 0xe5, 0xa8, 0xf5, 0x0f, 0xd9, 0x44,
	0xad, 0x6b, 0x6a, 0x7d, 0x44, 0xa6, 0x44, 0x92, 0x96, 0x1b, 0xfd, 0x5e, 0x83, 0xc6, 0x68, 0x86,
	0xb9, 0x3c, 0x1b, 0x0e, 0xd4, 0x1c, 0x2f, 0xc6, 0xaf, 0x48, 0x22, 0x9f, 0xd1, 0x74, 0x92, 0xcf,
	0x51, 0x22, 0xe8, 0x63, 0x68, 0x99, 0x5d, 0xff, 0xe5, 0xf0, 0xdc, 0x4e, 0x6b, 0xb4, 0xbd, 0x85,
	0xa3, 0x5e, 0x5e, 0xeb, 0x39, 0x91, 0xb8, 0xed, 0xee, 0x3a, 0x9d, 0xe6, 0xc1, 0xb6, 0x9e, 0xa4,
	0x84, 0xe3, 0x25, 0x0a, 0xfa, 0x14, 0x7c, 0x21, 0xb1, 0x9c, 0x8b, 0x76, 0x5d, 0x93, 0xef, 0x1b,
	0x95, 0xec, 0xd9, 0xba, 0x23, 0x1d, 0x8b, 0x2d, 0x27, 0xfc, 0x09, 0x7c, 0x83, 0xa8, 0x87, 0x79,
	0xc5, 0x84, 0x1c, 0xbe, 0xb4, 0x07, 0xb6, 0x3b, 0x35, 0xcc, 0x0c, 0x27, 0xfd, 0xc9, 0x84, 0x13,
	0x21, 0xec, 0x31, 0x97, 0x10, 0x95, 0x27, 0x16, 0x54, 0x26, 0x57, 0xfa, 0x70, 0x41, 0x6c, 0x77,
	0xd1, 0x9f, 0x0e, 0xbc, 0x95, 0x77, 0x55, 0x42, 0xfe, 0xaf, 0xaa, 0xec, 0x41, 0x43, 0xd5, 0x5c,
	0xd2, 0x64, 0x53, 0x8f, 0x99, 0x83, 0x71, 0x11, 0x46, 0x8f, 0xc1, 0xa3, 0x92, 0xcc, 0x94, 0x1c,
	0x6e, 0xc1, 0xcb, 0x0f, 0x16, 0x9b, 0x58, 0xf4, 0x33, 0x6c, 0xe6, 0x90, 0xf1, 0xce, 0xfb, 0xe0,
	0x10, 0x7d, 0xc6, 0x5c, 0xed, 0xd2, 0x37, 0xb1, 0x43, 0xd0, 0x27, 0x10, 0x08, 0xc5, 0x4f, 0x69,
	0xe1, 0xc6, 0x95, 0xc2, 0x65, 0x3c, 0xfa, 0xc7, 0x85, 0xfa, 0xd9, 0x62, 0x78, 0xf2, 0x66, 0x7d,
	0xd1, 0x01, 0x3f, 0x61, 0xe9, 0x05, 0xbd, 0xb4, 0xbe, 0x68, 0x69, 0xb2, 0x3a, 0x57, 0x77, 0xa0,
	0xf1, 0xd8, 0xc6, 0x15, 0xd3, 0x3a, 0xc8, 0x5b, 0x65, 0x56, 0xdd, 0x83, 0x9e, 0x02, 0x60, 0x29,
	0x39, 0x1d, 0xcf, 0x25, 0x11, 0x6d, 0x5f, 0xeb, 0xf0, 0xb0, 0x64, 0xf7, 0x8b, 0xd8, 0x71, 0x2a,
	0xf9, 0x4d, 0xbc, 0x44, 0x0e, 0x3f, 0x02, 0xdf, 0xb4, 0x45, 0x8f, 0x20, 0x98, 0xb2, 0x04, 0x4f,
	0xcf, 0x4f, 0xfb, 0x67, 0x5a, 0x14, 0x2f, 0x2e, 0x81, 0xf0, 0x75, 0x61, 0xd0, 0xaa, 0x11, 0x9d,
	0x5b, 0x46, 0x7c, 0x04, 0x41, 0xc6, 0xb8, 0xfc, 0x96, 0xb3, 0x79, 0x66, 0x65, 0x2b, 0x81, 0xbb,
	0x6c, 0x8a, 0x76, 0xa0, 0x29, 0xec, 0x33, 0xfb, 0x65, 0x78, 0xa4, 0xb5, 0x09, 0x62, 0xc8, 0xa1,
	0xe1, 0x51, 0xf8, 0x15, 0x6c, 0xaf, 0xcc, 0xb1, 0xe6, 0x2b, 0x79, 0x1f, 0x3c, 0xfd, 0xed, 0xb3,
	0x7d, 0xcd, 0xe6, 0xcb, 0xda, 0xa1, 0x13, 0xfd, 0xe1, 0x40, 0x43, 0x89, 0xf1, 0x26, 0x5f, 0x81,
	0x9d, 0xea, 0x2b, 0x10, 0x14, 0x4f, 0x28, 0xb7, 0xff, 0x33, 0x08, 0xd4, 0xf6, 0x3f, 0x59, 0x7f,
	0x07, 0xbc, 0x74, 0x41, 0x2f, 0xaa, 0x1f, 0x61, 0x53, 0x4c, 0xe3, 0xd1, 0x6b, 0x40, 0x6a, 0xfb,
	0x9c, 0x5e, 0x72, 0x2c, 0x29, 0x4b, 0x47, 0x12, 0x73, 0x59, 0xa6, 0x39, 0xeb, 0xd3, 0xd0, 0x13,
	0xf0, 0x05, 0x9b, 0xf3, 0xc4, 0x68, 0x78, 0xeb, 0x7d, 0xb2, 0x41, 0xf4, 0x21, 0xd4, 0x27, 0x44,
	0xc8, 0xca, 0xc8, 0x05, 0x49, 0x87, 0xa2, 0x7b, 0xe0, 0x1d, 0xcf, 0x32, 0x79, 0x13, 0xfd, 0x55,
	0x03, 0x4f, 0x99, 0x47, 0xa0, 0x7d, 0x78, 0x47, 0x48, 0xc6, 0x89, 0x1e, 0xe5, 0x04, 0xd3, 0xe9,
	0x80, 0xcd, 0xed, 0xc5, 0xe0, 0xc6, 0xeb, 0x42, 0xa8, 0x0b, 0xa8, 0x84, 0x8f, 0x39, 0x37, 0x09,
	0x35, 0x9d, 0xb0, 0x26, 0x82, 0x0e, 0xe1, 0x41, 0x89, 0x7e, 0x83, 0x27, 0x5a, 0x2f, 0x93, 0xe4,
	0xea, 0xa4, 0xbb, 0xc2, 0xe8, 0x0b, 0x78, 0xb7, 0x12, 0x7a, 0x31, 0x7e, 0x65, 0xf2, 0xea, 0x3a,
	0x6f, 0x7d, 0x10, 0x75, 0x60, 0x7b, 0xa1, 0xb0, 0xc1, 0x94, 0x09, 0x62, 0xf8, 0x9e, 0xe6, 0xaf,
	0xc2, 0xca, 0x54, 0x97, 0x3c, 0x4b, 0x46, 0x24, 0x9d, 0x14, 0x73, 0xf8, 0x9a, 0x7a, 0x0b, 0x3f,
	0xf8, 0xbb, 0x06, 0x8d, 0xf3, 0xc1, 0x77, 0xf3, 0x71, 0x3f, 0xa3, 0xe8, 0x33, 0xd8, 0x54, 0x16,
	0xca, 0xd5, 0x15, 0xa8, 0xa9, 0xd5, 0x36, 0x57, 0x7b, 0xf8, 0x76, 0x45, 0x7a, 0x45, 0x8c, 0x36,
	0xd0, 0x21, 0x6c, 0x99, 0xeb, 0xbc, 0xc8, 0xd9, 0x2a, 0x2d, 0xa4, 0x6e, 0xea, 0x10, 0x55, 0xd2,
	0xb4, 0x0c, 0xd1, 0xc6, 0xbe, 0x83, 0xf6, 0x20, 0x50, 0x35, 0x94, 0x23, 0x56, 0x1a, 0x6d, 0x16,
	0x56, 0xb1, 0x4d, 0xf6, 0xed, 0x2d, 0x6f, 0xb8, 0xab, 0x0d, 0xb6, 0x0a, 0x7a, 0x59, 0xfc, 0x6b,
	0x40, 0x45, 0x46, 0xe1, 0xcb, 0x6a, 0x97, 0x07, 0x45, 0x5a, 0xd5, 0xb8, 0x3a, 0xff, 0x31, 0xdc,
	0x1b, 0xa6, 0xea, 0x2f, 0x86, 0x44, 0xa0, 0x79, 0xda, 0x5f, 0xa1, 0x59, 0x6b, 0x87, 0x45, 0x1b,
	0x63, 0x5f, 0xff, 0x95, 0xfa, 0xfc, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x71, 0xa2, 0x22, 0xcb,
	0x85, 0x09, 0x00, 0x00,
}
