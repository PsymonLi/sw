/**
 * This file is generated by the SwaggerTSGenerator.
 * Do not edit.
*/
/* tslint:disable */
import { Validators, FormControl, FormGroup, FormArray, ValidatorFn } from '@angular/forms';
import { minValueValidator, maxValueValidator, minLengthValidator, maxLengthValidator, required, enumValidator, patternValidator, CustomFormControl, CustomFormGroup } from '../../../utils/validators';
import { BaseModel, PropInfoItem } from '../basemodel/base-model';

import { NetworkTLSServerPolicySpec_client_authentication,  } from './enums';

export interface INetworkTLSServerPolicySpec {
    'tls-server-certificates'?: Array<string>;
    'client-authentication': NetworkTLSServerPolicySpec_client_authentication;
    'tls-server-trust-roots'?: Array<string>;
    'tls-server-allowed-peer-id'?: Array<string>;
    '_ui'?: any;
}


export class NetworkTLSServerPolicySpec extends BaseModel implements INetworkTLSServerPolicySpec {
    /** Field for holding arbitrary ui state */
    '_ui': any = {};
    /** List of names of certificates to present to clients. The certificates "usage" field must contain "server". If multiple certificates names are provided, system tries to choose the correct one using SNI, otherwise it picks the first one in the list. */
    'tls-server-certificates': Array<string> = null;
    /** Client authentication "None" means that server does not request and will not validate a client certificate. "Mandatory" means that server requests and validates client certificate. "Optional" means that server requests client certificate but proceeds even if client does not present it. Default is "Mandatory". */
    'client-authentication': NetworkTLSServerPolicySpec_client_authentication = null;
    /** The list of root certificates used to validate a trust chain presented by client. If the list is empty, all roots certificates in the tenant scope are considered. */
    'tls-server-trust-roots': Array<string> = null;
    /** Valid DNS names or IP addresses that must appear in the client certificate SubjAltName or Common Name (if SAN is not specified). If client auth is enabled and AllowedPeerId is not specified, server accepts any client certificate as long as it is valid  (not expired and with a valid trust chain). */
    'tls-server-allowed-peer-id': Array<string> = null;
    public static propInfo: { [prop in keyof INetworkTLSServerPolicySpec]: PropInfoItem } = {
        'tls-server-certificates': {
            description:  `List of names of certificates to present to clients. The certificates "usage" field must contain "server". If multiple certificates names are provided, system tries to choose the correct one using SNI, otherwise it picks the first one in the list.`,
            required: false,
            type: 'Array<string>'
        },
        'client-authentication': {
            enum: NetworkTLSServerPolicySpec_client_authentication,
            default: 'mandatory',
            description:  `Client authentication "None" means that server does not request and will not validate a client certificate. "Mandatory" means that server requests and validates client certificate. "Optional" means that server requests client certificate but proceeds even if client does not present it. Default is "Mandatory".`,
            required: true,
            type: 'string'
        },
        'tls-server-trust-roots': {
            description:  `The list of root certificates used to validate a trust chain presented by client. If the list is empty, all roots certificates in the tenant scope are considered.`,
            required: false,
            type: 'Array<string>'
        },
        'tls-server-allowed-peer-id': {
            description:  `Valid DNS names or IP addresses that must appear in the client certificate SubjAltName or Common Name (if SAN is not specified). If client auth is enabled and AllowedPeerId is not specified, server accepts any client certificate as long as it is valid  (not expired and with a valid trust chain).`,
            required: false,
            type: 'Array<string>'
        },
    }

    public getPropInfo(propName: string): PropInfoItem {
        return NetworkTLSServerPolicySpec.propInfo[propName];
    }

    public getPropInfoConfig(): { [key:string]:PropInfoItem } {
        return NetworkTLSServerPolicySpec.propInfo;
    }

    /**
     * Returns whether or not there is an enum property with a default value
    */
    public static hasDefaultValue(prop) {
        return (NetworkTLSServerPolicySpec.propInfo[prop] != null &&
                        NetworkTLSServerPolicySpec.propInfo[prop].default != null);
    }

    /**
     * constructor
     * @param values Can be used to set a webapi response to this newly constructed model
    */
    constructor(values?: any, setDefaults:boolean = true) {
        super();
        this['tls-server-certificates'] = new Array<string>();
        this['tls-server-trust-roots'] = new Array<string>();
        this['tls-server-allowed-peer-id'] = new Array<string>();
        this._inputValue = values;
        this.setValues(values, setDefaults);
    }

    /**
     * set the values for both the Model and the Form Group. If a value isn't provided and we have a default, we use that.
     * @param values Can be used to set a webapi response to this newly constructed model
    */
    setValues(values: any, fillDefaults = true): void {
        if (values && values['_ui']) {
            this['_ui'] = values['_ui']
        }
        if (values && values['tls-server-certificates'] != null) {
            this['tls-server-certificates'] = values['tls-server-certificates'];
        } else if (fillDefaults && NetworkTLSServerPolicySpec.hasDefaultValue('tls-server-certificates')) {
            this['tls-server-certificates'] = [ NetworkTLSServerPolicySpec.propInfo['tls-server-certificates'].default];
        } else {
            this['tls-server-certificates'] = [];
        }
        if (values && values['client-authentication'] != null) {
            this['client-authentication'] = values['client-authentication'];
        } else if (fillDefaults && NetworkTLSServerPolicySpec.hasDefaultValue('client-authentication')) {
            this['client-authentication'] = <NetworkTLSServerPolicySpec_client_authentication>  NetworkTLSServerPolicySpec.propInfo['client-authentication'].default;
        } else {
            this['client-authentication'] = null
        }
        if (values && values['tls-server-trust-roots'] != null) {
            this['tls-server-trust-roots'] = values['tls-server-trust-roots'];
        } else if (fillDefaults && NetworkTLSServerPolicySpec.hasDefaultValue('tls-server-trust-roots')) {
            this['tls-server-trust-roots'] = [ NetworkTLSServerPolicySpec.propInfo['tls-server-trust-roots'].default];
        } else {
            this['tls-server-trust-roots'] = [];
        }
        if (values && values['tls-server-allowed-peer-id'] != null) {
            this['tls-server-allowed-peer-id'] = values['tls-server-allowed-peer-id'];
        } else if (fillDefaults && NetworkTLSServerPolicySpec.hasDefaultValue('tls-server-allowed-peer-id')) {
            this['tls-server-allowed-peer-id'] = [ NetworkTLSServerPolicySpec.propInfo['tls-server-allowed-peer-id'].default];
        } else {
            this['tls-server-allowed-peer-id'] = [];
        }
        this.setFormGroupValuesToBeModelValues();
    }


    protected getFormGroup(): FormGroup {
        if (!this._formGroup) {
            this._formGroup = new FormGroup({
                'tls-server-certificates': CustomFormControl(new FormControl(this['tls-server-certificates']), NetworkTLSServerPolicySpec.propInfo['tls-server-certificates']),
                'client-authentication': CustomFormControl(new FormControl(this['client-authentication'], [required, enumValidator(NetworkTLSServerPolicySpec_client_authentication), ]), NetworkTLSServerPolicySpec.propInfo['client-authentication']),
                'tls-server-trust-roots': CustomFormControl(new FormControl(this['tls-server-trust-roots']), NetworkTLSServerPolicySpec.propInfo['tls-server-trust-roots']),
                'tls-server-allowed-peer-id': CustomFormControl(new FormControl(this['tls-server-allowed-peer-id']), NetworkTLSServerPolicySpec.propInfo['tls-server-allowed-peer-id']),
            });
        }
        return this._formGroup;
    }

    setModelToBeFormGroupValues() {
        this.setValues(this.$formGroup.value, false);
    }

    setFormGroupValuesToBeModelValues() {
        if (this._formGroup) {
            this._formGroup.controls['tls-server-certificates'].setValue(this['tls-server-certificates']);
            this._formGroup.controls['client-authentication'].setValue(this['client-authentication']);
            this._formGroup.controls['tls-server-trust-roots'].setValue(this['tls-server-trust-roots']);
            this._formGroup.controls['tls-server-allowed-peer-id'].setValue(this['tls-server-allowed-peer-id']);
        }
    }
}

