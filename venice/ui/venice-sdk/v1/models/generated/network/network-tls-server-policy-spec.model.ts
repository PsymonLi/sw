/**
 * This file is generated by the SwaggerTSGenerator.
 * Do not edit.
*/
/* tslint:disable */
import { Validators, FormControl, FormGroup, FormArray, ValidatorFn } from '@angular/forms';
import { minValueValidator, maxValueValidator, enumValidator } from './validators';
import { BaseModel, EnumDef } from './base-model';

import { NetworkTLSServerPolicySpec_client_authentication,  } from './enums';

export interface INetworkTLSServerPolicySpec {
    'tls-server-certificates'?: Array<string>;
    'client-authentication'?: NetworkTLSServerPolicySpec_client_authentication;
    'tls-server-trust-roots'?: Array<string>;
    'tls-server-allowed-peer-id'?: Array<string>;
}


export class NetworkTLSServerPolicySpec extends BaseModel implements INetworkTLSServerPolicySpec {
    /** List of names of certificates to present to clients.
The certificates "usage" field must contain "server".
If multiple certificates names are provided, system tries to choose the
correct one using SNI, otherwise it picks the first one in the list. */
    'tls-server-certificates': Array<string>;
    /** Client authentication
"None" means that server does not request and will not validate a client certificate.
"Mandatory" means that server requests and validates client certificate.
"Optional" means that server requests client certificate but proceeds even
if client does not present it.
Default is "Mandatory". */
    'client-authentication': NetworkTLSServerPolicySpec_client_authentication;
    /** The list of root certificates used to validate a trust chain presented by client.
If the list is empty, all roots certificates in the tenant scope are considered. */
    'tls-server-trust-roots': Array<string>;
    /** Valid DNS names or IP addresses that must appear in the client certificate
SubjAltName or Common Name (if SAN is not specified).
If client auth is enabled and AllowedPeerId is not specified, server accepts any
client certificate as long as it is valid  (not expired and with a valid trust chain). */
    'tls-server-allowed-peer-id': Array<string>;
    public static enumProperties: { [key: string] : EnumDef } = {
        'client-authentication': {
            enum: NetworkTLSServerPolicySpec_client_authentication,
            default: 'Mandatory',
        },
    }

    /**
     * Returns whether or not there is an enum property with a default value
    */
    public static hasDefaultEnumValue(prop) {
        return (NetworkTLSServerPolicySpec.enumProperties[prop] != null &&
                        NetworkTLSServerPolicySpec.enumProperties[prop].default != null &&
                        NetworkTLSServerPolicySpec.enumProperties[prop].default != '');
    }

    /**
     * constructor
     * @param values Can be used to set a webapi response to this newly constructed model
    */
    constructor(values?: any) {
        super();
        this['tls-server-certificates'] = new Array<string>();
        this['tls-server-trust-roots'] = new Array<string>();
        this['tls-server-allowed-peer-id'] = new Array<string>();
        this.setValues(values);
    }

    /**
     * set the values. If a value isn't provided and we have a default, we use that.
     * @param values Can be used to set a webapi response to this newly constructed model
    */
    setValues(values: any): void {
        if (values) {
            this.fillModelArray<string>(this, 'tls-server-certificates', values['tls-server-certificates']);
        }
        if (values && values['client-authentication'] != null) {
            this['client-authentication'] = values['client-authentication'];
        } else if (NetworkTLSServerPolicySpec.hasDefaultEnumValue('client-authentication')) {
            this['client-authentication'] = <NetworkTLSServerPolicySpec_client_authentication> NetworkTLSServerPolicySpec.enumProperties['client-authentication'].default;
        }
        if (values) {
            this.fillModelArray<string>(this, 'tls-server-trust-roots', values['tls-server-trust-roots']);
        }
        if (values) {
            this.fillModelArray<string>(this, 'tls-server-allowed-peer-id', values['tls-server-allowed-peer-id']);
        }
    }




    protected getFormGroup(): FormGroup {
        if (!this._formGroup) {
            this._formGroup = new FormGroup({
                'tls-server-certificates': new FormArray([]),
                'client-authentication': new FormControl(this['client-authentication'], [enumValidator(NetworkTLSServerPolicySpec_client_authentication), ]),
                'tls-server-trust-roots': new FormArray([]),
                'tls-server-allowed-peer-id': new FormArray([]),
            });
            // generate FormArray control elements
            this.fillFormArray<string>('tls-server-certificates', this['tls-server-certificates']);
            // generate FormArray control elements
            this.fillFormArray<string>('tls-server-trust-roots', this['tls-server-trust-roots']);
            // generate FormArray control elements
            this.fillFormArray<string>('tls-server-allowed-peer-id', this['tls-server-allowed-peer-id']);
        }
        return this._formGroup;
    }

    setFormGroupValues() {
        if (this._formGroup) {
            this.fillModelArray<string>(this, 'tls-server-certificates', this['tls-server-certificates']);
            this._formGroup.controls['client-authentication'].setValue(this['client-authentication']);
            this.fillModelArray<string>(this, 'tls-server-trust-roots', this['tls-server-trust-roots']);
            this.fillModelArray<string>(this, 'tls-server-allowed-peer-id', this['tls-server-allowed-peer-id']);
        }
    }
}

