// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: values_test.go.tmpl

package cachedb

import (
	"fmt"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func makeValues(count int, min, max int64) Values {
	vals := make(IntegerValues, count)
	ret := make(Values, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeValuesFromSlice(t []int64) Values {
	iv := make(IntegerValues, len(t))
	ret := make(Values, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestValues_FindRangeNoValues(t *testing.T) {
	var vals Values
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestValues_FindRange(t *testing.T) {
	vals := makeValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(IntegerValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(IntegerValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestValues_Merge(t *testing.T) {
	valsA := makeValues(5, 10, 20)
	valsB := makeValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestValues_Deduplicate(t *testing.T) {
	vals := makeValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}

func makeFloatValues(count int, min, max int64) FloatValues {
	vals := make(FloatValues, count)
	ret := make(FloatValues, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeFloatValuesFromSlice(t []int64) FloatValues {
	iv := make(FloatValues, len(t))
	ret := make(FloatValues, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestFloatValues_FindRangeNoValues(t *testing.T) {
	var vals FloatValues
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestFloatValues_FindRange(t *testing.T) {
	vals := makeFloatValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestFloatValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeFloatValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(FloatValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestFloatValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeFloatValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(FloatValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestFloatValues_Merge(t *testing.T) {
	valsA := makeFloatValues(5, 10, 20)
	valsB := makeFloatValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestFloatValues_Deduplicate(t *testing.T) {
	vals := makeFloatValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}

func makeIntegerValues(count int, min, max int64) IntegerValues {
	vals := make(IntegerValues, count)
	ret := make(IntegerValues, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeIntegerValuesFromSlice(t []int64) IntegerValues {
	iv := make(IntegerValues, len(t))
	ret := make(IntegerValues, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestIntegerValues_FindRangeNoValues(t *testing.T) {
	var vals IntegerValues
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestIntegerValues_FindRange(t *testing.T) {
	vals := makeIntegerValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestIntegerValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeIntegerValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(IntegerValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestIntegerValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeIntegerValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(IntegerValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestIntegerValues_Merge(t *testing.T) {
	valsA := makeIntegerValues(5, 10, 20)
	valsB := makeIntegerValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestIntegerValues_Deduplicate(t *testing.T) {
	vals := makeIntegerValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}

func makeUnsignedValues(count int, min, max int64) UnsignedValues {
	vals := make(UnsignedValues, count)
	ret := make(UnsignedValues, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeUnsignedValuesFromSlice(t []int64) UnsignedValues {
	iv := make(UnsignedValues, len(t))
	ret := make(UnsignedValues, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestUnsignedValues_FindRangeNoValues(t *testing.T) {
	var vals UnsignedValues
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestUnsignedValues_FindRange(t *testing.T) {
	vals := makeUnsignedValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestUnsignedValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeUnsignedValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(UnsignedValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestUnsignedValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeUnsignedValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(UnsignedValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestUnsignedValues_Merge(t *testing.T) {
	valsA := makeUnsignedValues(5, 10, 20)
	valsB := makeUnsignedValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestUnsignedValues_Deduplicate(t *testing.T) {
	vals := makeUnsignedValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}

func makeStringValues(count int, min, max int64) StringValues {
	vals := make(StringValues, count)
	ret := make(StringValues, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeStringValuesFromSlice(t []int64) StringValues {
	iv := make(StringValues, len(t))
	ret := make(StringValues, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestStringValues_FindRangeNoValues(t *testing.T) {
	var vals StringValues
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestStringValues_FindRange(t *testing.T) {
	vals := makeStringValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestStringValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeStringValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(StringValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestStringValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeStringValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(StringValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestStringValues_Merge(t *testing.T) {
	valsA := makeStringValues(5, 10, 20)
	valsB := makeStringValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestStringValues_Deduplicate(t *testing.T) {
	vals := makeStringValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}

func makeBooleanValues(count int, min, max int64) BooleanValues {
	vals := make(BooleanValues, count)
	ret := make(BooleanValues, count)

	ts := min
	inc := (max - min) / int64(count)

	for i := 0; i < count; i++ {
		vals[i].unixnano = ts
		ret[i] = vals[i]
		ts += inc
	}

	return ret

}

func makeBooleanValuesFromSlice(t []int64) BooleanValues {
	iv := make(BooleanValues, len(t))
	ret := make(BooleanValues, len(t))
	for i, v := range t {
		iv[i].unixnano = v
		ret[i] = iv[i]
	}
	return ret
}
func TestBooleanValues_FindRangeNoValues(t *testing.T) {
	var vals BooleanValues
	l, r := vals.FindRange(0, 100)
	if exp := -1; l != exp {
		t.Errorf("invalid l; exp=%d, got=%d", exp, l)
	}
	if exp := -1; r != exp {
		t.Errorf("invalid r; exp=%d, got=%d", exp, r)
	}

	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}
}

func TestBooleanValues_FindRange(t *testing.T) {
	vals := makeBooleanValuesFromSlice([]int64{10, 11, 13, 15, 17, 20, 21})
	if !vals.ordered() {
		t.Errorf("expected ordered. got false")
	}

	cases := []struct {
		min, max int64
		l, r     int
	}{
		{12, 20, 2, 5},
		{22, 40, -1, -1},
		{1, 9, -1, -1},
		{1, 10, 0, 0},
		{1, 11, 0, 1},
		{15, 15, 3, 3},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%d→%d", tc.min, tc.max), func(t *testing.T) {
			l, r := vals.FindRange(tc.min, tc.max)
			if l != tc.l {
				t.Errorf("left: got %d, exp %d", l, tc.l)
			}
			if r != tc.r {
				t.Errorf("right: got %d, exp %d", r, tc.r)
			}
		})
	}
}

func TestBooleanValues_Exclude(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"excl none-lo", 0, 9, []int64{10, 12, 14, 16, 18}},
		{"excl none-hi", 19, 30, []int64{10, 12, 14, 16, 18}},
		{"excl first", 0, 10, []int64{12, 14, 16, 18}},
		{"excl last", 18, 20, []int64{10, 12, 14, 16}},
		{"excl all but first and last", 12, 16, []int64{10, 18}},
		{"excl none in middle", 13, 13, []int64{10, 12, 14, 16, 18}},
		{"excl middle", 14, 14, []int64{10, 12, 16, 18}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeBooleanValues(5, 10, 20)
			vals = vals.Exclude(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(BooleanValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestBooleanValues_Include(t *testing.T) {
	cases := []struct {
		n        string
		min, max int64
		exp      []int64
	}{
		{"incl none-lo", 0, 9, nil},
		{"incl none-hi", 19, 30, nil},
		{"incl first", 0, 10, []int64{10}},
		{"incl last", 18, 20, []int64{18}},
		{"incl all but first and last", 12, 16, []int64{12, 14, 16}},
		{"incl none in middle", 13, 13, nil},
		{"incl middle", 14, 14, []int64{14}},
	}

	for _, tc := range cases {
		t.Run(fmt.Sprintf("%s[%d,%d]", tc.n, tc.min, tc.max), func(t *testing.T) {
			vals := makeBooleanValues(5, 10, 20)
			vals = vals.Include(tc.min, tc.max)
			var got []int64
			for _, v := range vals {
				got = append(got, v.UnixNano())
			}
			opt := cmp.AllowUnexported(BooleanValue{})
			if !cmp.Equal(tc.exp, got, opt) {
				t.Error(cmp.Diff(tc.exp, got, opt))
			}
		})
	}
}

func TestBooleanValues_Merge(t *testing.T) {
	valsA := makeBooleanValues(5, 10, 20)
	valsB := makeBooleanValues(5, 16, 26)
	vals := valsA.Merge(valsB)
	if vals.Len() != 8 {
		t.Errorf("Expected 8, got %d", vals.Len())
	}

	if vals.Size() >= valsA.Size()+valsB.Size() {
		t.Errorf("Bad size for merged values")
	}

	vals.assertOrdered()
}

func TestBooleanValues_Deduplicate(t *testing.T) {
	vals := makeBooleanValuesFromSlice([]int64{10, 11, 7, 15, 9, 11, 81, 15})
	vals = vals.Deduplicate()
	vals.assertOrdered()
	if vals.MinTime() != 7 {
		t.Errorf("Expected 7, got %d", vals.MinTime())
	}
	if vals.MaxTime() != 81 {
		t.Errorf("Expected 81, got %d", vals.MaxTime())
	}
}
