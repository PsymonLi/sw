package cachedb

import (
	"github.com/influxdata/influxdb/query"
	"github.com/influxdata/influxdb/pkg/metrics"
        "github.com/influxdata/influxdb/pkg/tracing"
	"testing"
)

var (
        testGroup = metrics.MustRegisterGroup("testg")
        testCounter = metrics.MustRegisterCounter("cursors_ref", metrics.WithGroup(testGroup))
)

{{range .}}

func get{{.Name}}ValuesFromSlice(t []int64) Values {
        iv := make({{.Name}}Values, len(t))
        ret := make(Values, len(t))
        for i, v := range t {
                iv[i].unixnano = v
                ret[i] = iv[i]
        }
        return ret
}

func Test{{.Name}}Iterator_Next(t *testing.T) {
	vals := []int64{10, 7, 45, 66, 31, 2, 77}
	cv := get{{.Name}}ValuesFromSlice(vals)
	// seek to last item
	curs := new{{.Name}}Cursor(int64(77), false, cv, nil)
	opt := query.IteratorOptions{
	}
	aux := []cursorAt{}
	it := new{{.Name}}Iterator("blah", query.Tags{}, opt, curs, aux, nil, nil)
	count := 0
	for {
                p, err := it.Next()
                if err != nil {
                        t.Fatal(err)
                }
                if p == nil {
                        break
                }
                count++
        }

	if count != len(vals) {
		t.Errorf("Exp %d, got %d", len(vals), count)
	}

	it.Close()
}

func TestInstr{{.Name}}Iterator_Next(t *testing.T) {
	group := metrics.NewGroup(testGroup)
	_, span := tracing.NewTrace("foo")

	vals := []int64{10, 7, 45, 66, 31, 2, 77}
	cv := get{{.Name}}ValuesFromSlice(vals)
	// seek to last item
	curs := new{{.Name}}Cursor(int64(77), false, cv, nil)
	opt := query.IteratorOptions{
	}
	aux := []cursorAt{}
	iit := new{{.Name}}Iterator("blah", query.Tags{}, opt, curs, aux, nil, nil)
	it := new{{.Name}}InstrumentedIterator(iit, span, group)

//	count := 0
//	for {
//                p, err := it.Next()
//                if err != nil {
//                        t.Fatal(err)
//                }
//                if p == nil {
//                        break
//                }
//                count++
//        }
//
//	if count != len(vals) {
//		t.Errorf("Exp %d, got %d", len(vals), count)
//	}

	it.Close()
}
{{ end }}
