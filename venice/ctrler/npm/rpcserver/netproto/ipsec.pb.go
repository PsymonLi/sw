// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipsec.proto

package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type IPSecRule_Type int32

const (
	IPSecRule_NONE    IPSecRule_Type = 0
	IPSecRule_ENCRYPT IPSecRule_Type = 1
	IPSecRule_DECRYPT IPSecRule_Type = 2
)

var IPSecRule_Type_name = map[int32]string{
	0: "NONE",
	1: "ENCRYPT",
	2: "DECRYPT",
}
var IPSecRule_Type_value = map[string]int32{
	"NONE":    0,
	"ENCRYPT": 1,
	"DECRYPT": 2,
}

func (x IPSecRule_Type) String() string {
	return proto.EnumName(IPSecRule_Type_name, int32(x))
}
func (IPSecRule_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{2, 0} }

type Protocol_Type int32

const (
	Protocol_NONE Protocol_Type = 0
	Protocol_AH   Protocol_Type = 1
	Protocol_ESP  Protocol_Type = 2
)

var Protocol_Type_name = map[int32]string{
	0: "NONE",
	1: "AH",
	2: "ESP",
}
var Protocol_Type_value = map[string]int32{
	"NONE": 0,
	"AH":   1,
	"ESP":  2,
}

func (x Protocol_Type) String() string {
	return proto.EnumName(Protocol_Type_name, int32(x))
}
func (Protocol_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{8, 0} }

type AuthAlgorithm_Type int32

const (
	AuthAlgorithm_NONE        AuthAlgorithm_Type = 0
	AuthAlgorithm_AES_GCM     AuthAlgorithm_Type = 1
	AuthAlgorithm_AES_CCM     AuthAlgorithm_Type = 2
	AuthAlgorithm_HMAC        AuthAlgorithm_Type = 3
	AuthAlgorithm_AES_CBC_SHA AuthAlgorithm_Type = 4
)

var AuthAlgorithm_Type_name = map[int32]string{
	0: "NONE",
	1: "AES_GCM",
	2: "AES_CCM",
	3: "HMAC",
	4: "AES_CBC_SHA",
}
var AuthAlgorithm_Type_value = map[string]int32{
	"NONE":        0,
	"AES_GCM":     1,
	"AES_CCM":     2,
	"HMAC":        3,
	"AES_CBC_SHA": 4,
}

func (x AuthAlgorithm_Type) String() string {
	return proto.EnumName(AuthAlgorithm_Type_name, int32(x))
}
func (AuthAlgorithm_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{9, 0} }

type EncryptionAlgorithm_Type int32

const (
	EncryptionAlgorithm_NONE        EncryptionAlgorithm_Type = 0
	EncryptionAlgorithm_AES_GCM_128 EncryptionAlgorithm_Type = 1
	EncryptionAlgorithm_AES_GCM_256 EncryptionAlgorithm_Type = 2
	EncryptionAlgorithm_AES_CCM_128 EncryptionAlgorithm_Type = 3
	EncryptionAlgorithm_AES_CCM_192 EncryptionAlgorithm_Type = 4
	EncryptionAlgorithm_AES_CCM_256 EncryptionAlgorithm_Type = 5
	EncryptionAlgorithm_AES_CBC_128 EncryptionAlgorithm_Type = 6
	EncryptionAlgorithm_AES_CBC_192 EncryptionAlgorithm_Type = 7
	EncryptionAlgorithm_AES_CBC_256 EncryptionAlgorithm_Type = 8
	EncryptionAlgorithm_DES3        EncryptionAlgorithm_Type = 9
	EncryptionAlgorithm_CHA_CHA     EncryptionAlgorithm_Type = 10
)

var EncryptionAlgorithm_Type_name = map[int32]string{
	0:  "NONE",
	1:  "AES_GCM_128",
	2:  "AES_GCM_256",
	3:  "AES_CCM_128",
	4:  "AES_CCM_192",
	5:  "AES_CCM_256",
	6:  "AES_CBC_128",
	7:  "AES_CBC_192",
	8:  "AES_CBC_256",
	9:  "DES3",
	10: "CHA_CHA",
}
var EncryptionAlgorithm_Type_value = map[string]int32{
	"NONE":        0,
	"AES_GCM_128": 1,
	"AES_GCM_256": 2,
	"AES_CCM_128": 3,
	"AES_CCM_192": 4,
	"AES_CCM_256": 5,
	"AES_CBC_128": 6,
	"AES_CBC_192": 7,
	"AES_CBC_256": 8,
	"DES3":        9,
	"CHA_CHA":     10,
}

func (x EncryptionAlgorithm_Type) String() string {
	return proto.EnumName(EncryptionAlgorithm_Type_name, int32(x))
}
func (EncryptionAlgorithm_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorIpsec, []int{10, 0}
}

// IPSec Policy object
type IPSecPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           IPSecPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         IPSecPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *IPSecPolicy) Reset()                    { *m = IPSecPolicy{} }
func (m *IPSecPolicy) String() string            { return proto.CompactTextString(m) }
func (*IPSecPolicy) ProtoMessage()               {}
func (*IPSecPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{0} }

func (m *IPSecPolicy) GetSpec() IPSecPolicySpec {
	if m != nil {
		return m.Spec
	}
	return IPSecPolicySpec{}
}

func (m *IPSecPolicy) GetStatus() IPSecPolicyStatus {
	if m != nil {
		return m.Status
	}
	return IPSecPolicyStatus{}
}

// IPSecPolicySpec
type IPSecPolicySpec struct {
	// IPSecRules in a given policy
	Rules []IPSecRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *IPSecPolicySpec) Reset()                    { *m = IPSecPolicySpec{} }
func (m *IPSecPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*IPSecPolicySpec) ProtoMessage()               {}
func (*IPSecPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{1} }

func (m *IPSecPolicySpec) GetRules() []IPSecRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type IPSecRule struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"id,omitempty"`
	// IPSec Rule From match selector.
	Src *MatchSelector `protobuf:"bytes,2,opt,name=Src" json:"source,omitempty"`
	// IPSec Rule To match selector.
	Dst *MatchSelector `protobuf:"bytes,3,opt,name=Dst" json:"destination,omitempty"`
	// Security Association Name
	SAName string `protobuf:"bytes,4,opt,name=SAName,proto3" json:"sa-name,omitempty"`
	// Security Association type
	SAType string `protobuf:"bytes,5,opt,name=SAType,proto3" json:"sa-type,omitempty"`
}

func (m *IPSecRule) Reset()                    { *m = IPSecRule{} }
func (m *IPSecRule) String() string            { return proto.CompactTextString(m) }
func (*IPSecRule) ProtoMessage()               {}
func (*IPSecRule) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{2} }

func (m *IPSecRule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *IPSecRule) GetSrc() *MatchSelector {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *IPSecRule) GetDst() *MatchSelector {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *IPSecRule) GetSAName() string {
	if m != nil {
		return m.SAName
	}
	return ""
}

func (m *IPSecRule) GetSAType() string {
	if m != nil {
		return m.SAType
	}
	return ""
}

// IPSecPolicy Status
type IPSecPolicyStatus struct {
	IPSecPolicyID uint64 `protobuf:"varint,1,opt,name=IPSecPolicyID,proto3" json:"id,omitempty"`
}

func (m *IPSecPolicyStatus) Reset()                    { *m = IPSecPolicyStatus{} }
func (m *IPSecPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*IPSecPolicyStatus) ProtoMessage()               {}
func (*IPSecPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{3} }

func (m *IPSecPolicyStatus) GetIPSecPolicyID() uint64 {
	if m != nil {
		return m.IPSecPolicyID
	}
	return 0
}

// list of IPSecPolicies
type IPSecPolicyList struct {
	IPSecRules []*IPSecRule `protobuf:"bytes,1,rep,name=IPSecRules" json:"IPSecRules,omitempty"`
}

func (m *IPSecPolicyList) Reset()                    { *m = IPSecPolicyList{} }
func (m *IPSecPolicyList) String() string            { return proto.CompactTextString(m) }
func (*IPSecPolicyList) ProtoMessage()               {}
func (*IPSecPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{4} }

func (m *IPSecPolicyList) GetIPSecRules() []*IPSecRule {
	if m != nil {
		return m.IPSecRules
	}
	return nil
}

// IPSecPolicy watch event
type IPSecPolicyEvent struct {
	EventType   api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	IPSecPolicy IPSecPolicy   `protobuf:"bytes,2,opt,name=IPSecPolicy" json:"ipsec-policy,omitempty"`
}

func (m *IPSecPolicyEvent) Reset()                    { *m = IPSecPolicyEvent{} }
func (m *IPSecPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*IPSecPolicyEvent) ProtoMessage()               {}
func (*IPSecPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{5} }

func (m *IPSecPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *IPSecPolicyEvent) GetIPSecPolicy() IPSecPolicy {
	if m != nil {
		return m.IPSecPolicy
	}
	return IPSecPolicy{}
}

// IPSecSAEncrypt object
type IPSecSAEncrypt struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           IPSecSAEncryptSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         IPSecSAEncryptStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *IPSecSAEncrypt) Reset()                    { *m = IPSecSAEncrypt{} }
func (m *IPSecSAEncrypt) String() string            { return proto.CompactTextString(m) }
func (*IPSecSAEncrypt) ProtoMessage()               {}
func (*IPSecSAEncrypt) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{6} }

func (m *IPSecSAEncrypt) GetSpec() IPSecSAEncryptSpec {
	if m != nil {
		return m.Spec
	}
	return IPSecSAEncryptSpec{}
}

func (m *IPSecSAEncrypt) GetStatus() IPSecSAEncryptStatus {
	if m != nil {
		return m.Status
	}
	return IPSecSAEncryptStatus{}
}

// IPSecSAEncryptSpec
type IPSecSAEncryptSpec struct {
	// SA Encrypt protocol
	Protocol string `protobuf:"bytes,1,opt,name=Protocol,proto3" json:"protocol,omitempty"`
	// SA Encrypt Auth Algorithm
	AuthAlgo string `protobuf:"bytes,2,opt,name=AuthAlgo,proto3" json:"authentication-algorithm,omitempty"`
	// Authentication Key
	AuthKey string `protobuf:"bytes,3,opt,name=AuthKey,proto3" json:"authentication-key, omitempty"`
	// SA Encrypt Algorithm
	EncryptAlgo string `protobuf:"bytes,4,opt,name=EncryptAlgo,proto3" json:"encryption-algorithm,omitempty"`
	// Encryption Key
	EncryptionKey string `protobuf:"bytes,5,opt,name=EncryptionKey,proto3" json:"encryption-key,omitempty"`
	// Local Gateway IP
	LocalGwIP string `protobuf:"bytes,6,opt,name=LocalGwIP,proto3" json:"local-gateway-ip,omitempty"`
	// Remote Gateway IP
	RemoteGwIP string `protobuf:"bytes,7,opt,name=RemoteGwIP,proto3" json:"remote-gateway-ip,omitempty"`
}

func (m *IPSecSAEncryptSpec) Reset()                    { *m = IPSecSAEncryptSpec{} }
func (m *IPSecSAEncryptSpec) String() string            { return proto.CompactTextString(m) }
func (*IPSecSAEncryptSpec) ProtoMessage()               {}
func (*IPSecSAEncryptSpec) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{7} }

func (m *IPSecSAEncryptSpec) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetAuthAlgo() string {
	if m != nil {
		return m.AuthAlgo
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetAuthKey() string {
	if m != nil {
		return m.AuthKey
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetEncryptAlgo() string {
	if m != nil {
		return m.EncryptAlgo
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetEncryptionKey() string {
	if m != nil {
		return m.EncryptionKey
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetLocalGwIP() string {
	if m != nil {
		return m.LocalGwIP
	}
	return ""
}

func (m *IPSecSAEncryptSpec) GetRemoteGwIP() string {
	if m != nil {
		return m.RemoteGwIP
	}
	return ""
}

type Protocol struct {
}

func (m *Protocol) Reset()                    { *m = Protocol{} }
func (m *Protocol) String() string            { return proto.CompactTextString(m) }
func (*Protocol) ProtoMessage()               {}
func (*Protocol) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{8} }

type AuthAlgorithm struct {
}

func (m *AuthAlgorithm) Reset()                    { *m = AuthAlgorithm{} }
func (m *AuthAlgorithm) String() string            { return proto.CompactTextString(m) }
func (*AuthAlgorithm) ProtoMessage()               {}
func (*AuthAlgorithm) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{9} }

type EncryptionAlgorithm struct {
}

func (m *EncryptionAlgorithm) Reset()                    { *m = EncryptionAlgorithm{} }
func (m *EncryptionAlgorithm) String() string            { return proto.CompactTextString(m) }
func (*EncryptionAlgorithm) ProtoMessage()               {}
func (*EncryptionAlgorithm) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{10} }

// IPSecSAEncrypt Status
type IPSecSAEncryptStatus struct {
	IPSecSAEncryptID uint64 `protobuf:"varint,1,opt,name=IPSecSAEncryptID,proto3" json:"id,omitempty"`
}

func (m *IPSecSAEncryptStatus) Reset()                    { *m = IPSecSAEncryptStatus{} }
func (m *IPSecSAEncryptStatus) String() string            { return proto.CompactTextString(m) }
func (*IPSecSAEncryptStatus) ProtoMessage()               {}
func (*IPSecSAEncryptStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{11} }

func (m *IPSecSAEncryptStatus) GetIPSecSAEncryptID() uint64 {
	if m != nil {
		return m.IPSecSAEncryptID
	}
	return 0
}

// list of IPSecSAEncrypt
type IPSecSAEncryptList struct {
	IPSecRules []*IPSecRule `protobuf:"bytes,1,rep,name=IPSecRules" json:"IPSecRules,omitempty"`
}

func (m *IPSecSAEncryptList) Reset()                    { *m = IPSecSAEncryptList{} }
func (m *IPSecSAEncryptList) String() string            { return proto.CompactTextString(m) }
func (*IPSecSAEncryptList) ProtoMessage()               {}
func (*IPSecSAEncryptList) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{12} }

func (m *IPSecSAEncryptList) GetIPSecRules() []*IPSecRule {
	if m != nil {
		return m.IPSecRules
	}
	return nil
}

// IPSecSAEncrypt watch event
type IPSecSAEncryptEvent struct {
	EventType      api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	IPSecSAEncrypt IPSecSAEncrypt `protobuf:"bytes,2,opt,name=IPSecSAEncrypt" json:"ipsec-sa-encrypt,omitempty"`
}

func (m *IPSecSAEncryptEvent) Reset()                    { *m = IPSecSAEncryptEvent{} }
func (m *IPSecSAEncryptEvent) String() string            { return proto.CompactTextString(m) }
func (*IPSecSAEncryptEvent) ProtoMessage()               {}
func (*IPSecSAEncryptEvent) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{13} }

func (m *IPSecSAEncryptEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *IPSecSAEncryptEvent) GetIPSecSAEncrypt() IPSecSAEncrypt {
	if m != nil {
		return m.IPSecSAEncrypt
	}
	return IPSecSAEncrypt{}
}

// IPSecSADecrypt object
type IPSecSADecrypt struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           IPSecSADecryptSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         IPSecSADecryptStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *IPSecSADecrypt) Reset()                    { *m = IPSecSADecrypt{} }
func (m *IPSecSADecrypt) String() string            { return proto.CompactTextString(m) }
func (*IPSecSADecrypt) ProtoMessage()               {}
func (*IPSecSADecrypt) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{14} }

func (m *IPSecSADecrypt) GetSpec() IPSecSADecryptSpec {
	if m != nil {
		return m.Spec
	}
	return IPSecSADecryptSpec{}
}

func (m *IPSecSADecrypt) GetStatus() IPSecSADecryptStatus {
	if m != nil {
		return m.Status
	}
	return IPSecSADecryptStatus{}
}

// IPSecSADecryptSpec
type IPSecSADecryptSpec struct {
	// SA Decrypt protocol
	Protocol string `protobuf:"bytes,1,opt,name=Protocol,proto3" json:"protocol,omitempty"`
	// SA Decrypt Auth Algorithm
	AuthAlgo string `protobuf:"bytes,2,opt,name=AuthAlgo,proto3" json:"authentication-algorithm,omitempty"`
	// Authentication Key
	AuthKey string `protobuf:"bytes,3,opt,name=AuthKey,proto3" json:"authentication-key, omitempty"`
	// SA Decrypt Algorithm
	DecryptAlgo string `protobuf:"bytes,4,opt,name=DecryptAlgo,proto3" json:"decryption-algorithm,omitempty"`
	// Rekey Decrypt Algorithm
	RekeyDecryptAlgo string `protobuf:"bytes,5,opt,name=RekeyDecryptAlgo,proto3" json:"rekey-decryption-algorithm,omitempty"`
	// Decryption Key
	DecryptionKey string `protobuf:"bytes,6,opt,name=DecryptionKey,proto3" json:"decryption-key,omitempty"`
	// Rekey Auth Key
	RekeyAuthKey string `protobuf:"bytes,7,opt,name=RekeyAuthKey,proto3" json:"rekey-auth-key,omitempty"`
	// Rekey Decryption Key
	RekeyDecryptionKey string `protobuf:"bytes,8,opt,name=RekeyDecryptionKey,proto3" json:"rekey-decryption-key,omitempty"`
	// Local Gateway IP
	LocalGwIP string `protobuf:"bytes,9,opt,name=LocalGwIP,proto3" json:"local-gateway-ip,omitempty"`
	// Remote Gateway IP
	RemoteGwIP string `protobuf:"bytes,10,opt,name=RemoteGwIP,proto3" json:"remote-gateway-ip,omitempty"`
}

func (m *IPSecSADecryptSpec) Reset()                    { *m = IPSecSADecryptSpec{} }
func (m *IPSecSADecryptSpec) String() string            { return proto.CompactTextString(m) }
func (*IPSecSADecryptSpec) ProtoMessage()               {}
func (*IPSecSADecryptSpec) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{15} }

func (m *IPSecSADecryptSpec) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetAuthAlgo() string {
	if m != nil {
		return m.AuthAlgo
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetAuthKey() string {
	if m != nil {
		return m.AuthKey
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetDecryptAlgo() string {
	if m != nil {
		return m.DecryptAlgo
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetRekeyDecryptAlgo() string {
	if m != nil {
		return m.RekeyDecryptAlgo
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetDecryptionKey() string {
	if m != nil {
		return m.DecryptionKey
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetRekeyAuthKey() string {
	if m != nil {
		return m.RekeyAuthKey
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetRekeyDecryptionKey() string {
	if m != nil {
		return m.RekeyDecryptionKey
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetLocalGwIP() string {
	if m != nil {
		return m.LocalGwIP
	}
	return ""
}

func (m *IPSecSADecryptSpec) GetRemoteGwIP() string {
	if m != nil {
		return m.RemoteGwIP
	}
	return ""
}

// IPSecSADecrypt Status
type IPSecSADecryptStatus struct {
	IPSecSADecryptID uint64 `protobuf:"varint,1,opt,name=IPSecSADecryptID,proto3" json:"id,omitempty"`
}

func (m *IPSecSADecryptStatus) Reset()                    { *m = IPSecSADecryptStatus{} }
func (m *IPSecSADecryptStatus) String() string            { return proto.CompactTextString(m) }
func (*IPSecSADecryptStatus) ProtoMessage()               {}
func (*IPSecSADecryptStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{16} }

func (m *IPSecSADecryptStatus) GetIPSecSADecryptID() uint64 {
	if m != nil {
		return m.IPSecSADecryptID
	}
	return 0
}

// list of IPSecSADecrypt
type IPSecSADecryptList struct {
	IPSecRules []*IPSecRule `protobuf:"bytes,1,rep,name=IPSecRules" json:"IPSecRules,omitempty"`
}

func (m *IPSecSADecryptList) Reset()                    { *m = IPSecSADecryptList{} }
func (m *IPSecSADecryptList) String() string            { return proto.CompactTextString(m) }
func (*IPSecSADecryptList) ProtoMessage()               {}
func (*IPSecSADecryptList) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{17} }

func (m *IPSecSADecryptList) GetIPSecRules() []*IPSecRule {
	if m != nil {
		return m.IPSecRules
	}
	return nil
}

// IPSecSADecrypt watch event
type IPSecSADecryptEvent struct {
	EventType      api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	IPSecSADecrypt IPSecSADecrypt `protobuf:"bytes,2,opt,name=IPSecSADecrypt" json:"ipsec-sa-encrypt,omitempty"`
}

func (m *IPSecSADecryptEvent) Reset()                    { *m = IPSecSADecryptEvent{} }
func (m *IPSecSADecryptEvent) String() string            { return proto.CompactTextString(m) }
func (*IPSecSADecryptEvent) ProtoMessage()               {}
func (*IPSecSADecryptEvent) Descriptor() ([]byte, []int) { return fileDescriptorIpsec, []int{18} }

func (m *IPSecSADecryptEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *IPSecSADecryptEvent) GetIPSecSADecrypt() IPSecSADecrypt {
	if m != nil {
		return m.IPSecSADecrypt
	}
	return IPSecSADecrypt{}
}

func init() {
	proto.RegisterType((*IPSecPolicy)(nil), "netproto.IPSecPolicy")
	proto.RegisterType((*IPSecPolicySpec)(nil), "netproto.IPSecPolicySpec")
	proto.RegisterType((*IPSecRule)(nil), "netproto.IPSecRule")
	proto.RegisterType((*IPSecPolicyStatus)(nil), "netproto.IPSecPolicyStatus")
	proto.RegisterType((*IPSecPolicyList)(nil), "netproto.IPSecPolicyList")
	proto.RegisterType((*IPSecPolicyEvent)(nil), "netproto.IPSecPolicyEvent")
	proto.RegisterType((*IPSecSAEncrypt)(nil), "netproto.IPSecSAEncrypt")
	proto.RegisterType((*IPSecSAEncryptSpec)(nil), "netproto.IPSecSAEncryptSpec")
	proto.RegisterType((*Protocol)(nil), "netproto.Protocol")
	proto.RegisterType((*AuthAlgorithm)(nil), "netproto.AuthAlgorithm")
	proto.RegisterType((*EncryptionAlgorithm)(nil), "netproto.EncryptionAlgorithm")
	proto.RegisterType((*IPSecSAEncryptStatus)(nil), "netproto.IPSecSAEncryptStatus")
	proto.RegisterType((*IPSecSAEncryptList)(nil), "netproto.IPSecSAEncryptList")
	proto.RegisterType((*IPSecSAEncryptEvent)(nil), "netproto.IPSecSAEncryptEvent")
	proto.RegisterType((*IPSecSADecrypt)(nil), "netproto.IPSecSADecrypt")
	proto.RegisterType((*IPSecSADecryptSpec)(nil), "netproto.IPSecSADecryptSpec")
	proto.RegisterType((*IPSecSADecryptStatus)(nil), "netproto.IPSecSADecryptStatus")
	proto.RegisterType((*IPSecSADecryptList)(nil), "netproto.IPSecSADecryptList")
	proto.RegisterType((*IPSecSADecryptEvent)(nil), "netproto.IPSecSADecryptEvent")
	proto.RegisterEnum("netproto.IPSecRule_Type", IPSecRule_Type_name, IPSecRule_Type_value)
	proto.RegisterEnum("netproto.Protocol_Type", Protocol_Type_name, Protocol_Type_value)
	proto.RegisterEnum("netproto.AuthAlgorithm_Type", AuthAlgorithm_Type_name, AuthAlgorithm_Type_value)
	proto.RegisterEnum("netproto.EncryptionAlgorithm_Type", EncryptionAlgorithm_Type_name, EncryptionAlgorithm_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IPSecPolicyApi service

type IPSecPolicyApiClient interface {
	GetIPSecPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecPolicy, error)
	ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecPolicyList, error)
	WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecPolicyApi_WatchIPSecPoliciesClient, error)
}

type iPSecPolicyApiClient struct {
	cc *grpc.ClientConn
}

func NewIPSecPolicyApiClient(cc *grpc.ClientConn) IPSecPolicyApiClient {
	return &iPSecPolicyApiClient{cc}
}

func (c *iPSecPolicyApiClient) GetIPSecPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecPolicy, error) {
	out := new(IPSecPolicy)
	err := grpc.Invoke(ctx, "/netproto.IPSecPolicyApi/GetIPSecPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecPolicyApiClient) ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecPolicyList, error) {
	out := new(IPSecPolicyList)
	err := grpc.Invoke(ctx, "/netproto.IPSecPolicyApi/ListIPSecPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecPolicyApiClient) WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecPolicyApi_WatchIPSecPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPSecPolicyApi_serviceDesc.Streams[0], c.cc, "/netproto.IPSecPolicyApi/WatchIPSecPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPSecPolicyApiWatchIPSecPoliciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPSecPolicyApi_WatchIPSecPoliciesClient interface {
	Recv() (*IPSecPolicyEvent, error)
	grpc.ClientStream
}

type iPSecPolicyApiWatchIPSecPoliciesClient struct {
	grpc.ClientStream
}

func (x *iPSecPolicyApiWatchIPSecPoliciesClient) Recv() (*IPSecPolicyEvent, error) {
	m := new(IPSecPolicyEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for IPSecPolicyApi service

type IPSecPolicyApiServer interface {
	GetIPSecPolicy(context.Context, *api.ObjectMeta) (*IPSecPolicy, error)
	ListIPSecPolicies(context.Context, *api.ObjectMeta) (*IPSecPolicyList, error)
	WatchIPSecPolicies(*api.ObjectMeta, IPSecPolicyApi_WatchIPSecPoliciesServer) error
}

func RegisterIPSecPolicyApiServer(s *grpc.Server, srv IPSecPolicyApiServer) {
	s.RegisterService(&_IPSecPolicyApi_serviceDesc, srv)
}

func _IPSecPolicyApi_GetIPSecPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecPolicyApiServer).GetIPSecPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecPolicyApi/GetIPSecPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecPolicyApiServer).GetIPSecPolicy(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecPolicyApi_ListIPSecPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecPolicyApiServer).ListIPSecPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecPolicyApi/ListIPSecPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecPolicyApiServer).ListIPSecPolicies(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecPolicyApi_WatchIPSecPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPSecPolicyApiServer).WatchIPSecPolicies(m, &iPSecPolicyApiWatchIPSecPoliciesServer{stream})
}

type IPSecPolicyApi_WatchIPSecPoliciesServer interface {
	Send(*IPSecPolicyEvent) error
	grpc.ServerStream
}

type iPSecPolicyApiWatchIPSecPoliciesServer struct {
	grpc.ServerStream
}

func (x *iPSecPolicyApiWatchIPSecPoliciesServer) Send(m *IPSecPolicyEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _IPSecPolicyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.IPSecPolicyApi",
	HandlerType: (*IPSecPolicyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIPSecPolicy",
			Handler:    _IPSecPolicyApi_GetIPSecPolicy_Handler,
		},
		{
			MethodName: "ListIPSecPolicies",
			Handler:    _IPSecPolicyApi_ListIPSecPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchIPSecPolicies",
			Handler:       _IPSecPolicyApi_WatchIPSecPolicies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ipsec.proto",
}

// Client API for IPSecSAEncryptApi service

type IPSecSAEncryptApiClient interface {
	GetIPSecSAEncrypt(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSAEncrypt, error)
	ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSAEncryptList, error)
	WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecSAEncryptApi_WatchIPSecPoliciesClient, error)
}

type iPSecSAEncryptApiClient struct {
	cc *grpc.ClientConn
}

func NewIPSecSAEncryptApiClient(cc *grpc.ClientConn) IPSecSAEncryptApiClient {
	return &iPSecSAEncryptApiClient{cc}
}

func (c *iPSecSAEncryptApiClient) GetIPSecSAEncrypt(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSAEncrypt, error) {
	out := new(IPSecSAEncrypt)
	err := grpc.Invoke(ctx, "/netproto.IPSecSAEncryptApi/GetIPSecSAEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecSAEncryptApiClient) ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSAEncryptList, error) {
	out := new(IPSecSAEncryptList)
	err := grpc.Invoke(ctx, "/netproto.IPSecSAEncryptApi/ListIPSecPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecSAEncryptApiClient) WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecSAEncryptApi_WatchIPSecPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPSecSAEncryptApi_serviceDesc.Streams[0], c.cc, "/netproto.IPSecSAEncryptApi/WatchIPSecPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPSecSAEncryptApiWatchIPSecPoliciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPSecSAEncryptApi_WatchIPSecPoliciesClient interface {
	Recv() (*IPSecSAEncryptEvent, error)
	grpc.ClientStream
}

type iPSecSAEncryptApiWatchIPSecPoliciesClient struct {
	grpc.ClientStream
}

func (x *iPSecSAEncryptApiWatchIPSecPoliciesClient) Recv() (*IPSecSAEncryptEvent, error) {
	m := new(IPSecSAEncryptEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for IPSecSAEncryptApi service

type IPSecSAEncryptApiServer interface {
	GetIPSecSAEncrypt(context.Context, *api.ObjectMeta) (*IPSecSAEncrypt, error)
	ListIPSecPolicies(context.Context, *api.ObjectMeta) (*IPSecSAEncryptList, error)
	WatchIPSecPolicies(*api.ObjectMeta, IPSecSAEncryptApi_WatchIPSecPoliciesServer) error
}

func RegisterIPSecSAEncryptApiServer(s *grpc.Server, srv IPSecSAEncryptApiServer) {
	s.RegisterService(&_IPSecSAEncryptApi_serviceDesc, srv)
}

func _IPSecSAEncryptApi_GetIPSecSAEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecSAEncryptApiServer).GetIPSecSAEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecSAEncryptApi/GetIPSecSAEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecSAEncryptApiServer).GetIPSecSAEncrypt(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecSAEncryptApi_ListIPSecPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecSAEncryptApiServer).ListIPSecPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecSAEncryptApi/ListIPSecPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecSAEncryptApiServer).ListIPSecPolicies(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecSAEncryptApi_WatchIPSecPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPSecSAEncryptApiServer).WatchIPSecPolicies(m, &iPSecSAEncryptApiWatchIPSecPoliciesServer{stream})
}

type IPSecSAEncryptApi_WatchIPSecPoliciesServer interface {
	Send(*IPSecSAEncryptEvent) error
	grpc.ServerStream
}

type iPSecSAEncryptApiWatchIPSecPoliciesServer struct {
	grpc.ServerStream
}

func (x *iPSecSAEncryptApiWatchIPSecPoliciesServer) Send(m *IPSecSAEncryptEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _IPSecSAEncryptApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.IPSecSAEncryptApi",
	HandlerType: (*IPSecSAEncryptApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIPSecSAEncrypt",
			Handler:    _IPSecSAEncryptApi_GetIPSecSAEncrypt_Handler,
		},
		{
			MethodName: "ListIPSecPolicies",
			Handler:    _IPSecSAEncryptApi_ListIPSecPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchIPSecPolicies",
			Handler:       _IPSecSAEncryptApi_WatchIPSecPolicies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ipsec.proto",
}

// Client API for IPSecSADecryptApi service

type IPSecSADecryptApiClient interface {
	GetIPSecSADecrypt(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSADecrypt, error)
	ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSADecryptList, error)
	WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecSADecryptApi_WatchIPSecPoliciesClient, error)
}

type iPSecSADecryptApiClient struct {
	cc *grpc.ClientConn
}

func NewIPSecSADecryptApiClient(cc *grpc.ClientConn) IPSecSADecryptApiClient {
	return &iPSecSADecryptApiClient{cc}
}

func (c *iPSecSADecryptApiClient) GetIPSecSADecrypt(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSADecrypt, error) {
	out := new(IPSecSADecrypt)
	err := grpc.Invoke(ctx, "/netproto.IPSecSADecryptApi/GetIPSecSADecrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecSADecryptApiClient) ListIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPSecSADecryptList, error) {
	out := new(IPSecSADecryptList)
	err := grpc.Invoke(ctx, "/netproto.IPSecSADecryptApi/ListIPSecPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecSADecryptApiClient) WatchIPSecPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPSecSADecryptApi_WatchIPSecPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPSecSADecryptApi_serviceDesc.Streams[0], c.cc, "/netproto.IPSecSADecryptApi/WatchIPSecPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPSecSADecryptApiWatchIPSecPoliciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPSecSADecryptApi_WatchIPSecPoliciesClient interface {
	Recv() (*IPSecSADecryptEvent, error)
	grpc.ClientStream
}

type iPSecSADecryptApiWatchIPSecPoliciesClient struct {
	grpc.ClientStream
}

func (x *iPSecSADecryptApiWatchIPSecPoliciesClient) Recv() (*IPSecSADecryptEvent, error) {
	m := new(IPSecSADecryptEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for IPSecSADecryptApi service

type IPSecSADecryptApiServer interface {
	GetIPSecSADecrypt(context.Context, *api.ObjectMeta) (*IPSecSADecrypt, error)
	ListIPSecPolicies(context.Context, *api.ObjectMeta) (*IPSecSADecryptList, error)
	WatchIPSecPolicies(*api.ObjectMeta, IPSecSADecryptApi_WatchIPSecPoliciesServer) error
}

func RegisterIPSecSADecryptApiServer(s *grpc.Server, srv IPSecSADecryptApiServer) {
	s.RegisterService(&_IPSecSADecryptApi_serviceDesc, srv)
}

func _IPSecSADecryptApi_GetIPSecSADecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecSADecryptApiServer).GetIPSecSADecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecSADecryptApi/GetIPSecSADecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecSADecryptApiServer).GetIPSecSADecrypt(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecSADecryptApi_ListIPSecPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecSADecryptApiServer).ListIPSecPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPSecSADecryptApi/ListIPSecPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecSADecryptApiServer).ListIPSecPolicies(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSecSADecryptApi_WatchIPSecPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPSecSADecryptApiServer).WatchIPSecPolicies(m, &iPSecSADecryptApiWatchIPSecPoliciesServer{stream})
}

type IPSecSADecryptApi_WatchIPSecPoliciesServer interface {
	Send(*IPSecSADecryptEvent) error
	grpc.ServerStream
}

type iPSecSADecryptApiWatchIPSecPoliciesServer struct {
	grpc.ServerStream
}

func (x *iPSecSADecryptApiWatchIPSecPoliciesServer) Send(m *IPSecSADecryptEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _IPSecSADecryptApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.IPSecSADecryptApi",
	HandlerType: (*IPSecSADecryptApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIPSecSADecrypt",
			Handler:    _IPSecSADecryptApi_GetIPSecSADecrypt_Handler,
		},
		{
			MethodName: "ListIPSecPolicies",
			Handler:    _IPSecSADecryptApi_ListIPSecPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchIPSecPolicies",
			Handler:       _IPSecSADecryptApi_WatchIPSecPolicies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ipsec.proto",
}

func (m *IPSecPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *IPSecPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPSecRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.ID))
	}
	if m.Src != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.Src.Size()))
		n5, err := m.Src.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Dst != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.Dst.Size()))
		n6, err := m.Dst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.SAName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.SAName)))
		i += copy(dAtA[i:], m.SAName)
	}
	if len(m.SAType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.SAType)))
		i += copy(dAtA[i:], m.SAType)
	}
	return i, nil
}

func (m *IPSecPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPSecPolicyID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecPolicyID))
	}
	return i, nil
}

func (m *IPSecPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, msg := range m.IPSecRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPSecPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecPolicy.Size()))
	n7, err := m.IPSecPolicy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *IPSecSAEncrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSAEncrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.ObjectMeta.Size()))
	n9, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Spec.Size()))
	n10, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *IPSecSAEncryptSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSAEncryptSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.AuthAlgo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.AuthAlgo)))
		i += copy(dAtA[i:], m.AuthAlgo)
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if len(m.EncryptAlgo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.EncryptAlgo)))
		i += copy(dAtA[i:], m.EncryptAlgo)
	}
	if len(m.EncryptionKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.EncryptionKey)))
		i += copy(dAtA[i:], m.EncryptionKey)
	}
	if len(m.LocalGwIP) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.LocalGwIP)))
		i += copy(dAtA[i:], m.LocalGwIP)
	}
	if len(m.RemoteGwIP) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.RemoteGwIP)))
		i += copy(dAtA[i:], m.RemoteGwIP)
	}
	return i, nil
}

func (m *Protocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Protocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AuthAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EncryptionAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptionAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IPSecSAEncryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSAEncryptStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPSecSAEncryptID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecSAEncryptID))
	}
	return i, nil
}

func (m *IPSecSAEncryptList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSAEncryptList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, msg := range m.IPSecRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPSecSAEncryptEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSAEncryptEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecSAEncrypt.Size()))
	n12, err := m.IPSecSAEncrypt.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *IPSecSADecrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSADecrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.Status.Size()))
	n16, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *IPSecSADecryptSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSADecryptSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.AuthAlgo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.AuthAlgo)))
		i += copy(dAtA[i:], m.AuthAlgo)
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if len(m.DecryptAlgo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.DecryptAlgo)))
		i += copy(dAtA[i:], m.DecryptAlgo)
	}
	if len(m.RekeyDecryptAlgo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.RekeyDecryptAlgo)))
		i += copy(dAtA[i:], m.RekeyDecryptAlgo)
	}
	if len(m.DecryptionKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.DecryptionKey)))
		i += copy(dAtA[i:], m.DecryptionKey)
	}
	if len(m.RekeyAuthKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.RekeyAuthKey)))
		i += copy(dAtA[i:], m.RekeyAuthKey)
	}
	if len(m.RekeyDecryptionKey) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.RekeyDecryptionKey)))
		i += copy(dAtA[i:], m.RekeyDecryptionKey)
	}
	if len(m.LocalGwIP) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.LocalGwIP)))
		i += copy(dAtA[i:], m.LocalGwIP)
	}
	if len(m.RemoteGwIP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.RemoteGwIP)))
		i += copy(dAtA[i:], m.RemoteGwIP)
	}
	return i, nil
}

func (m *IPSecSADecryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSADecryptStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPSecSADecryptID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecSADecryptID))
	}
	return i, nil
}

func (m *IPSecSADecryptList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSADecryptList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, msg := range m.IPSecRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpsec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPSecSADecryptEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecSADecryptEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpsec(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpsec(dAtA, i, uint64(m.IPSecSADecrypt.Size()))
	n17, err := m.IPSecSADecrypt.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	return i, nil
}

func encodeVarintIpsec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IPSecPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func (m *IPSecPolicySpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	return n
}

func (m *IPSecRule) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovIpsec(uint64(m.ID))
	}
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.SAName)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.SAType)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	return n
}

func (m *IPSecPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.IPSecPolicyID != 0 {
		n += 1 + sovIpsec(uint64(m.IPSecPolicyID))
	}
	return n
}

func (m *IPSecPolicyList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, e := range m.IPSecRules {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	return n
}

func (m *IPSecPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovIpsec(uint64(m.EventType))
	}
	l = m.IPSecPolicy.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func (m *IPSecSAEncrypt) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func (m *IPSecSAEncryptSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.AuthAlgo)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.EncryptAlgo)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.LocalGwIP)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.RemoteGwIP)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	return n
}

func (m *Protocol) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AuthAlgorithm) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EncryptionAlgorithm) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IPSecSAEncryptStatus) Size() (n int) {
	var l int
	_ = l
	if m.IPSecSAEncryptID != 0 {
		n += 1 + sovIpsec(uint64(m.IPSecSAEncryptID))
	}
	return n
}

func (m *IPSecSAEncryptList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, e := range m.IPSecRules {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	return n
}

func (m *IPSecSAEncryptEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovIpsec(uint64(m.EventType))
	}
	l = m.IPSecSAEncrypt.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func (m *IPSecSADecrypt) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpsec(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func (m *IPSecSADecryptSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.AuthAlgo)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.DecryptAlgo)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.RekeyDecryptAlgo)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.DecryptionKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.RekeyAuthKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.RekeyDecryptionKey)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.LocalGwIP)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	l = len(m.RemoteGwIP)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	return n
}

func (m *IPSecSADecryptStatus) Size() (n int) {
	var l int
	_ = l
	if m.IPSecSADecryptID != 0 {
		n += 1 + sovIpsec(uint64(m.IPSecSADecryptID))
	}
	return n
}

func (m *IPSecSADecryptList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPSecRules) > 0 {
		for _, e := range m.IPSecRules {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	return n
}

func (m *IPSecSADecryptEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovIpsec(uint64(m.EventType))
	}
	l = m.IPSecSADecrypt.Size()
	n += 1 + l + sovIpsec(uint64(l))
	return n
}

func sovIpsec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIpsec(x uint64) (n int) {
	return sovIpsec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IPSecPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, IPSecRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &MatchSelector{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &MatchSelector{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecPolicyID", wireType)
			}
			m.IPSecPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPSecPolicyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPSecRules = append(m.IPSecRules, &IPSecRule{})
			if err := m.IPSecRules[len(m.IPSecRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IPSecPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSAEncrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSAEncrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSAEncrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSAEncryptSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSAEncryptSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSAEncryptSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalGwIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalGwIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteGwIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteGwIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Protocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Protocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Protocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptionAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptionAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptionAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSAEncryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSAEncryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSAEncryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecSAEncryptID", wireType)
			}
			m.IPSecSAEncryptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPSecSAEncryptID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSAEncryptList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSAEncryptList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSAEncryptList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPSecRules = append(m.IPSecRules, &IPSecRule{})
			if err := m.IPSecRules[len(m.IPSecRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSAEncryptEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSAEncryptEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSAEncryptEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecSAEncrypt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IPSecSAEncrypt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSADecrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSADecrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSADecrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSADecryptSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSADecryptSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSADecryptSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecryptAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RekeyDecryptAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyAuthKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RekeyAuthKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecryptionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RekeyDecryptionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalGwIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalGwIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteGwIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteGwIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSADecryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSADecryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSADecryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecSADecryptID", wireType)
			}
			m.IPSecSADecryptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPSecSADecryptID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSADecryptList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSADecryptList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSADecryptList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPSecRules = append(m.IPSecRules, &IPSecRule{})
			if err := m.IPSecRules[len(m.IPSecRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecSADecryptEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecSADecryptEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecSADecryptEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSecSADecrypt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IPSecSADecrypt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpsec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIpsec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpsec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpsec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpsec   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ipsec.proto", fileDescriptorIpsec) }

var fileDescriptorIpsec = []byte{
	// 1494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4d, 0x8f, 0xd3, 0x46,
	0x18, 0x8e, 0x93, 0x90, 0x8f, 0x09, 0xbb, 0xeb, 0x9d, 0xe5, 0x23, 0x09, 0x90, 0x2c, 0x56, 0x2b,
	0xd1, 0x8a, 0x24, 0x34, 0xa8, 0xa8, 0xb4, 0xb4, 0x10, 0x27, 0x66, 0xb3, 0x82, 0x2c, 0x51, 0xb2,
	0x2d, 0xea, 0x69, 0xe5, 0x75, 0xa6, 0x59, 0x17, 0xc7, 0xb6, 0xe2, 0x09, 0x28, 0xaa, 0x38, 0x21,
	0xf1, 0x1b, 0xfa, 0x1b, 0xb8, 0x14, 0xd1, 0x53, 0x8f, 0xa8, 0x87, 0x72, 0x44, 0xea, 0xa9, 0x97,
	0xa8, 0xa2, 0xb7, 0xfc, 0x8a, 0x6a, 0x26, 0x63, 0x67, 0xec, 0x24, 0x4b, 0x80, 0xa5, 0x6a, 0xd5,
	0xd3, 0x7a, 0x5e, 0xbf, 0xcf, 0x33, 0xef, 0x3c, 0x9e, 0x79, 0xde, 0x9d, 0x80, 0x94, 0x6e, 0x3b,
	0x48, 0x2b, 0xda, 0x7d, 0x0b, 0x5b, 0x30, 0x61, 0x22, 0x4c, 0x9f, 0xb2, 0x67, 0xbb, 0x96, 0xd5,
	0x35, 0x50, 0x49, 0xb5, 0xf5, 0x92, 0x6a, 0x9a, 0x16, 0x56, 0xb1, 0x6e, 0x99, 0xce, 0x24, 0x2f,
	0xab, 0x74, 0x75, 0x7c, 0x30, 0xd8, 0x2f, 0x6a, 0x56, 0xaf, 0x64, 0x23, 0xd3, 0x51, 0xcd, 0x8e,
	0x55, 0x72, 0x1e, 0x94, 0xee, 0x23, 0x53, 0xd7, 0x50, 0x69, 0x80, 0x75, 0xc3, 0x21, 0xd0, 0x2e,
	0x32, 0x79, 0x74, 0x49, 0x37, 0x35, 0x63, 0xd0, 0x41, 0x2e, 0x4d, 0x81, 0xa3, 0xe9, 0x5a, 0x5d,
	0xab, 0x44, 0xc3, 0xfb, 0x83, 0xef, 0xe8, 0x88, 0x0e, 0xe8, 0x13, 0x4b, 0xff, 0x70, 0xc1, 0xac,
	0xa4, 0xc6, 0x1e, 0xc2, 0x2a, 0x4b, 0x4b, 0xf5, 0x54, 0xac, 0x1d, 0x4c, 0x06, 0xd2, 0xd3, 0x30,
	0x48, 0x6d, 0x37, 0xdb, 0x48, 0x6b, 0x5a, 0x86, 0xae, 0x0d, 0xe1, 0x57, 0x20, 0xb1, 0x3b, 0xb4,
	0x51, 0x03, 0x61, 0x35, 0x2d, 0x6c, 0x0a, 0x17, 0x52, 0xe5, 0x95, 0xa2, 0x6a, 0xeb, 0x45, 0x37,
	0x28, 0x6f, 0xbc, 0x18, 0xe5, 0x43, 0x2f, 0x47, 0x79, 0x61, 0x3c, 0xca, 0xc7, 0x2f, 0xea, 0xa6,
	0xa1, 0x9b, 0xa8, 0xe5, 0x61, 0xe0, 0x2d, 0x00, 0xee, 0xec, 0x7f, 0x8f, 0x34, 0x4c, 0x19, 0xc2,
	0x94, 0x61, 0x8d, 0x32, 0x4c, 0xc3, 0x72, 0x96, 0xe3, 0x58, 0x25, 0x95, 0x5d, 0xb4, 0x7a, 0x3a,
	0x46, 0x3d, 0x1b, 0x0f, 0x5b, 0x1c, 0x1c, 0x2a, 0x20, 0xda, 0xb6, 0x91, 0x96, 0x8e, 0x50, 0x9a,
	0x4c, 0xd1, 0x55, 0xbf, 0xc8, 0x55, 0x4c, 0x12, 0xe4, 0x53, 0x84, 0x90, 0x90, 0x39, 0x36, 0xd2,
	0x38, 0x32, 0x0a, 0x87, 0x0d, 0x10, 0x6b, 0x63, 0x15, 0x0f, 0x9c, 0x74, 0x94, 0x12, 0x9d, 0x99,
	0x4f, 0x44, 0x53, 0xe4, 0x34, 0xa3, 0x12, 0x1d, 0x3a, 0xe6, 0xc8, 0x18, 0x89, 0xf4, 0x35, 0x58,
	0x0b, 0xcc, 0x0f, 0x65, 0x70, 0xac, 0x3f, 0x30, 0x90, 0x93, 0x16, 0x36, 0x23, 0x17, 0x52, 0xe5,
	0x8d, 0xc0, 0x04, 0xad, 0x81, 0x81, 0xe4, 0xd3, 0x8c, 0x78, 0x8d, 0x66, 0x72, 0xbc, 0x13, 0xa8,
	0xf4, 0x47, 0x18, 0x24, 0xbd, 0x6c, 0xb8, 0x09, 0xc2, 0xdb, 0x35, 0xfa, 0x05, 0xa2, 0xb2, 0x38,
	0x1e, 0xe5, 0x8f, 0xeb, 0x1d, 0x0e, 0x12, 0xde, 0xae, 0xc1, 0xeb, 0x20, 0xd2, 0xee, 0x6b, 0x4c,
	0xe2, 0xd3, 0xd3, 0x19, 0x1b, 0xe4, 0xeb, 0xb6, 0x91, 0x81, 0x34, 0x6c, 0xf5, 0xe5, 0x13, 0x74,
	0x29, 0xd6, 0xa0, 0xaf, 0x21, 0x0e, 0x4f, 0x90, 0xb0, 0x06, 0x22, 0x35, 0x07, 0x33, 0x71, 0x17,
	0x12, 0x64, 0xc6, 0xa3, 0xfc, 0xc9, 0x0e, 0x72, 0xb0, 0x6e, 0xd2, 0x4d, 0xca, 0xb3, 0xd4, 0x1c,
	0x0c, 0x0b, 0x20, 0xd6, 0xae, 0xec, 0xa8, 0x3d, 0x44, 0xc5, 0x4d, 0xca, 0x27, 0xc7, 0xa3, 0xfc,
	0xba, 0xa3, 0x16, 0x4c, 0xb5, 0x87, 0x7c, 0xe2, 0xd1, 0x24, 0x58, 0x27, 0xe9, 0x64, 0xb7, 0xa4,
	0x8f, 0xd1, 0xf4, 0x4b, 0x4f, 0x1e, 0x67, 0x4e, 0xb7, 0x71, 0x5f, 0x31, 0x07, 0xbd, 0x0b, 0xde,
	0xf2, 0xe9, 0x76, 0xfb, 0x88, 0x31, 0xe1, 0xa1, 0x1d, 0x60, 0x22, 0x6f, 0xa5, 0x8f, 0x41, 0x94,
	0xfc, 0x85, 0x09, 0x10, 0xdd, 0xb9, 0xb3, 0xa3, 0x88, 0x21, 0x98, 0x02, 0x71, 0x65, 0xa7, 0xda,
	0xfa, 0xb6, 0xb9, 0x2b, 0x0a, 0x64, 0x50, 0x53, 0x26, 0x83, 0xb0, 0x74, 0x0b, 0xac, 0xcf, 0x7c,
	0x69, 0x78, 0x05, 0xac, 0x70, 0xc1, 0x43, 0xd4, 0xf6, 0xa7, 0x49, 0x37, 0x7d, 0xdf, 0xff, 0xb6,
	0xee, 0x60, 0x78, 0x19, 0x00, 0xaf, 0xf6, 0xc3, 0x36, 0x41, 0x8b, 0x4b, 0x93, 0x7e, 0x16, 0x80,
	0xc8, 0x11, 0x29, 0xf7, 0x91, 0x89, 0xe1, 0x4d, 0x90, 0xa4, 0x0f, 0x54, 0x22, 0x52, 0xd0, 0x6a,
	0x79, 0x95, 0x1e, 0x1f, 0x2f, 0x2a, 0xa7, 0xc7, 0xa3, 0xfc, 0x09, 0x44, 0x86, 0x41, 0x69, 0xa6,
	0x50, 0x78, 0xd7, 0x77, 0xac, 0xd9, 0x2e, 0x39, 0x39, 0x77, 0xe3, 0xcb, 0x39, 0xb6, 0x33, 0x4f,
	0x51, 0xab, 0x2b, 0xd8, 0x34, 0xca, 0xd1, 0xf2, 0x4c, 0xd2, 0x2f, 0x61, 0xb0, 0x4a, 0xc7, 0xed,
	0x8a, 0x62, 0x6a, 0xfd, 0xa1, 0x8d, 0xff, 0x5d, 0x9e, 0x51, 0xf7, 0x79, 0xc6, 0xd9, 0xc0, 0x8a,
	0xbd, 0xa2, 0x97, 0xb0, 0x8d, 0x66, 0xc0, 0x36, 0x72, 0x0b, 0xb9, 0x96, 0x75, 0x8e, 0xa7, 0x51,
	0x00, 0x67, 0xcb, 0x80, 0xb7, 0x41, 0xa2, 0x49, 0x68, 0x35, 0xcb, 0xa0, 0xfa, 0x4d, 0x4e, 0xc5,
	0x29, 0xf7, 0x54, 0xb8, 0xef, 0xbc, 0x43, 0x01, 0x6d, 0x16, 0xe1, 0xa6, 0xf0, 0x18, 0xa0, 0x0a,
	0x12, 0x95, 0x01, 0x3e, 0xa8, 0x18, 0x5d, 0x8b, 0x6a, 0x99, 0x94, 0x95, 0x27, 0x8f, 0x33, 0x67,
	0x5c, 0x36, 0xf7, 0x5d, 0x5f, 0xc7, 0x07, 0x3d, 0x8f, 0x52, 0x52, 0x07, 0xf8, 0x00, 0x99, 0x58,
	0xd7, 0xe8, 0x21, 0x2f, 0xa8, 0x6e, 0x06, 0x3f, 0x85, 0x0b, 0x85, 0x5f, 0x80, 0x38, 0x79, 0xbe,
	0x85, 0x86, 0x54, 0xe6, 0xa4, 0x7c, 0x7e, 0x3c, 0xca, 0x9f, 0x0b, 0x50, 0xdc, 0x43, 0xc3, 0x8b,
	0x9b, 0x53, 0xb4, 0x8b, 0x80, 0x3a, 0x48, 0xb1, 0xc5, 0xd3, 0x12, 0x27, 0xae, 0xb1, 0xf5, 0xe4,
	0x71, 0xe6, 0xbc, 0x5b, 0x22, 0x7b, 0xad, 0x5b, 0xe6, 0x6c, 0xa1, 0x39, 0xe4, 0xbd, 0x9c, 0x5b,
	0x24, 0xcf, 0x0d, 0x65, 0xb0, 0x32, 0xe5, 0x22, 0xd5, 0x4e, 0x3c, 0xe7, 0xec, 0x78, 0x94, 0x4f,
	0x73, 0x3c, 0xa4, 0x52, 0xee, 0xb4, 0xfb, 0x20, 0xf0, 0x1a, 0x48, 0xde, 0xb6, 0x34, 0xd5, 0xd8,
	0x7a, 0xb0, 0xdd, 0x4c, 0xc7, 0x28, 0x3e, 0x37, 0x1e, 0xe5, 0xb3, 0x06, 0x09, 0x16, 0xba, 0x2a,
	0x46, 0x0f, 0xd4, 0x61, 0x41, 0xb7, 0xf9, 0x63, 0xe8, 0x01, 0xe0, 0x75, 0x00, 0x5a, 0xa8, 0x67,
	0x61, 0x44, 0xe1, 0x71, 0x0a, 0xcf, 0x8f, 0x47, 0xf9, 0x33, 0x7d, 0x1a, 0x9d, 0x8f, 0xe7, 0x20,
	0x52, 0x61, 0xba, 0x37, 0xa4, 0xf3, 0x33, 0x8e, 0x17, 0x03, 0xe1, 0x4a, 0x5d, 0x14, 0x60, 0x1c,
	0x44, 0x94, 0x76, 0x53, 0x0c, 0x4b, 0xdf, 0x80, 0x15, 0xdf, 0x07, 0x96, 0x94, 0x79, 0x2e, 0x59,
	0x51, 0xda, 0x7b, 0x5b, 0xd5, 0xc6, 0xc4, 0x25, 0xc9, 0xa0, 0x5a, 0x6d, 0x88, 0x61, 0x92, 0x53,
	0x6f, 0x54, 0xaa, 0x62, 0x04, 0xae, 0x81, 0x14, 0x0d, 0xcb, 0xd5, 0xbd, 0x76, 0xbd, 0x22, 0x46,
	0xa5, 0xdf, 0x04, 0xb0, 0x31, 0xe7, 0xb3, 0x48, 0x3f, 0x09, 0x33, 0xfc, 0x0c, 0xbb, 0x55, 0x6d,
	0xec, 0x7d, 0x52, 0xfe, 0x4c, 0x14, 0xf8, 0x40, 0xf9, 0xd3, 0x2b, 0x62, 0xd8, 0x63, 0x67, 0x19,
	0x11, 0x5f, 0xe0, 0x6a, 0x59, 0x8c, 0xf2, 0x01, 0x02, 0x39, 0xc6, 0x17, 0x44, 0x20, 0x31, 0x5f,
	0xe0, 0x6a, 0x59, 0x8c, 0xf3, 0x01, 0x02, 0x49, 0x90, 0x8a, 0x6a, 0x4a, 0xfb, 0xb2, 0x98, 0x24,
	0x8b, 0xac, 0xd6, 0x2b, 0x7b, 0xd5, 0x7a, 0x45, 0x04, 0xd2, 0x2e, 0x38, 0x31, 0xef, 0xf4, 0xc2,
	0x6b, 0xcc, 0x8c, 0xbd, 0xf8, 0x21, 0x0d, 0x61, 0x26, 0x53, 0xda, 0x0e, 0x1e, 0xec, 0xb7, 0x6f,
	0x0b, 0xbf, 0x0a, 0x60, 0xc3, 0xcf, 0x75, 0xb4, 0x9d, 0xa1, 0x13, 0xf4, 0x6f, 0xe6, 0xb8, 0xe9,
	0x45, 0xf6, 0x26, 0x4b, 0xcc, 0xd8, 0xb2, 0x93, 0xfe, 0xe0, 0xa8, 0x05, 0x76, 0x78, 0xb8, 0x09,
	0x02, 0x9c, 0x7c, 0x9b, 0xa8, 0xa1, 0xff, 0x60, 0x9b, 0x60, 0x45, 0x1f, 0x49, 0x9b, 0x70, 0xb9,
	0x96, 0x6d, 0x13, 0xcf, 0x63, 0xde, 0x6e, 0xe2, 0xca, 0xf8, 0xff, 0xb5, 0x09, 0xb6, 0xf8, 0xb7,
	0x6a, 0x13, 0x1d, 0x74, 0x78, 0x9b, 0xe0, 0xb8, 0xe1, 0x10, 0x88, 0x2d, 0x74, 0x0f, 0x0d, 0xf9,
	0xf9, 0x26, 0x9d, 0xa2, 0xb1, 0xec, 0x7c, 0x1f, 0xf4, 0x09, 0x41, 0xe1, 0x35, 0xb3, 0xce, 0x4c,
	0x43, 0x3a, 0x54, 0x0d, 0xf1, 0x1d, 0x2a, 0x36, 0xed, 0x50, 0x1c, 0x59, 0xa0, 0x43, 0xf9, 0x20,
	0xf0, 0x06, 0x38, 0x4e, 0x79, 0x5d, 0xad, 0xe3, 0x53, 0x8a, 0x49, 0x55, 0x44, 0xf1, 0x00, 0x85,
	0x0f, 0x01, 0x5b, 0x00, 0xf2, 0x95, 0xb1, 0x52, 0x12, 0x94, 0x47, 0x22, 0x6a, 0xce, 0xac, 0xce,
	0xcf, 0x36, 0x07, 0xed, 0xef, 0x9b, 0xc9, 0x77, 0xeb, 0x9b, 0xe0, 0xcd, 0xfb, 0xe6, 0xd4, 0xe6,
	0x7d, 0xa7, 0x8f, 0xb3, 0x79, 0x16, 0x5f, 0xc2, 0xe6, 0xbd, 0x4c, 0xce, 0xe6, 0x59, 0xec, 0x48,
	0x6c, 0x9e, 0x71, 0xbd, 0x2f, 0x9b, 0x67, 0xf4, 0x0b, 0x6d, 0x9e, 0xbd, 0x7f, 0x23, 0x9b, 0x67,
	0x98, 0xf2, 0x73, 0xd7, 0xe6, 0x27, 0xb7, 0x83, 0x8a, 0xad, 0xc3, 0xcf, 0xc1, 0xea, 0x16, 0xc2,
	0xfc, 0x6f, 0x0a, 0x41, 0x93, 0xce, 0xce, 0xbf, 0x87, 0x48, 0x21, 0x58, 0x01, 0xeb, 0x44, 0xd1,
	0x69, 0x50, 0x47, 0xce, 0x2c, 0x7c, 0xfe, 0x0f, 0x01, 0x04, 0x28, 0x85, 0xa0, 0x02, 0xe0, 0x5d,
	0x72, 0x81, 0x7d, 0x0d, 0x47, 0x76, 0x2e, 0x07, 0x95, 0x4f, 0x0a, 0x5d, 0x12, 0xb2, 0xfa, 0xb3,
	0x47, 0x19, 0xe4, 0xff, 0x69, 0x24, 0x6a, 0x90, 0x8f, 0x1d, 0xb5, 0x2d, 0x07, 0xc3, 0x88, 0x3d,
	0xc0, 0x30, 0xd6, 0x41, 0x06, 0xc2, 0x28, 0xfb, 0x65, 0xe9, 0x87, 0x29, 0x73, 0x71, 0x17, 0x99,
	0xaa, 0x89, 0x1f, 0xfa, 0x62, 0xe4, 0xea, 0xdb, 0xb6, 0x55, 0x0d, 0xcd, 0x86, 0x1f, 0x96, 0x7f,
	0x0f, 0xb3, 0xdb, 0xa9, 0xd7, 0x3d, 0x89, 0x8c, 0x37, 0xc0, 0xba, 0x2b, 0xe3, 0xf4, 0xa6, 0x35,
	0xb3, 0x8c, 0x85, 0x4d, 0x5b, 0x0a, 0xc1, 0xda, 0x52, 0x62, 0x2e, 0xbc, 0x21, 0x31, 0x3d, 0xeb,
	0xcb, 0xe9, 0x79, 0x6e, 0x11, 0xcd, 0x54, 0x52, 0xe3, 0xd9, 0xa3, 0xcc, 0xc1, 0xcc, 0xe5, 0xf1,
	0x1f, 0x50, 0xd5, 0x35, 0xdc, 0xa0, 0xaa, 0xee, 0x3f, 0x26, 0x4b, 0xa8, 0xca, 0x52, 0xdf, 0x41,
	0x55, 0xce, 0x30, 0xde, 0x45, 0x55, 0xde, 0x2b, 0xe6, 0xa8, 0xea, 0x2e, 0xe9, 0x3d, 0xa9, 0x2a,
	0x8b, 0x2f, 0x5e, 0xe5, 0x84, 0x97, 0xaf, 0x72, 0xc2, 0x9f, 0xaf, 0x72, 0xc2, 0x8f, 0x7f, 0xe5,
	0x42, 0x4d, 0x61, 0x3f, 0x46, 0x0b, 0xbc, 0xfc, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x55, 0x83,
	0xc3, 0x00, 0x2a, 0x15, 0x00, 0x00,
}
