// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route.proto

package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Route object
type Route struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           RouteSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         RouteStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

func (m *Route) GetSpec() RouteSpec {
	if m != nil {
		return m.Spec
	}
	return RouteSpec{}
}

func (m *Route) GetStatus() RouteStatus {
	if m != nil {
		return m.Status
	}
	return RouteStatus{}
}

// RouteSpec captures all the route configuration
type RouteSpec struct {
	// CIDR based ip prefix
	IPPrefix string `protobuf:"bytes,1,opt,name=IPPrefix,proto3" json:"ip-prefix,omitempty"`
	// Next Hop interface
	Interface string `protobuf:"bytes,2,opt,name=Interface,proto3" json:"interface,omitempty"`
	// Next Hop gateway IP
	GatewayIP string `protobuf:"bytes,3,opt,name=GatewayIP,proto3" json:"gateway-ip,omitempty"`
}

func (m *RouteSpec) Reset()                    { *m = RouteSpec{} }
func (m *RouteSpec) String() string            { return proto.CompactTextString(m) }
func (*RouteSpec) ProtoMessage()               {}
func (*RouteSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{1} }

func (m *RouteSpec) GetIPPrefix() string {
	if m != nil {
		return m.IPPrefix
	}
	return ""
}

func (m *RouteSpec) GetInterface() string {
	if m != nil {
		return m.Interface
	}
	return ""
}

func (m *RouteSpec) GetGatewayIP() string {
	if m != nil {
		return m.GatewayIP
	}
	return ""
}

// RouteStatus captures the route status
type RouteStatus struct {
	RouteID uint64 `protobuf:"varint,1,opt,name=RouteID,proto3" json:"id,omitempty"`
}

func (m *RouteStatus) Reset()                    { *m = RouteStatus{} }
func (m *RouteStatus) String() string            { return proto.CompactTextString(m) }
func (*RouteStatus) ProtoMessage()               {}
func (*RouteStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{2} }

func (m *RouteStatus) GetRouteID() uint64 {
	if m != nil {
		return m.RouteID
	}
	return 0
}

type RouteList struct {
	Routes []*Route `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *RouteList) Reset()                    { *m = RouteList{} }
func (m *RouteList) String() string            { return proto.CompactTextString(m) }
func (*RouteList) ProtoMessage()               {}
func (*RouteList) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{3} }

func (m *RouteList) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

// route watch event
type RouteEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	Route     Route         `protobuf:"bytes,2,opt,name=Route" json:"route,omitempty"`
}

func (m *RouteEvent) Reset()                    { *m = RouteEvent{} }
func (m *RouteEvent) String() string            { return proto.CompactTextString(m) }
func (*RouteEvent) ProtoMessage()               {}
func (*RouteEvent) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{4} }

func (m *RouteEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *RouteEvent) GetRoute() Route {
	if m != nil {
		return m.Route
	}
	return Route{}
}

func init() {
	proto.RegisterType((*Route)(nil), "netproto.Route")
	proto.RegisterType((*RouteSpec)(nil), "netproto.RouteSpec")
	proto.RegisterType((*RouteStatus)(nil), "netproto.RouteStatus")
	proto.RegisterType((*RouteList)(nil), "netproto.RouteList")
	proto.RegisterType((*RouteEvent)(nil), "netproto.RouteEvent")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RouteApi service

type RouteApiClient interface {
	GetRoute(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Route, error)
	ListRoutes(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*RouteList, error)
	WatchRoutes(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (RouteApi_WatchRoutesClient, error)
}

type routeApiClient struct {
	cc *grpc.ClientConn
}

func NewRouteApiClient(cc *grpc.ClientConn) RouteApiClient {
	return &routeApiClient{cc}
}

func (c *routeApiClient) GetRoute(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Route, error) {
	out := new(Route)
	err := grpc.Invoke(ctx, "/netproto.RouteApi/GetRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeApiClient) ListRoutes(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/netproto.RouteApi/ListRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeApiClient) WatchRoutes(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (RouteApi_WatchRoutesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RouteApi_serviceDesc.Streams[0], c.cc, "/netproto.RouteApi/WatchRoutes", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeApiWatchRoutesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouteApi_WatchRoutesClient interface {
	Recv() (*RouteEvent, error)
	grpc.ClientStream
}

type routeApiWatchRoutesClient struct {
	grpc.ClientStream
}

func (x *routeApiWatchRoutesClient) Recv() (*RouteEvent, error) {
	m := new(RouteEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RouteApi service

type RouteApiServer interface {
	GetRoute(context.Context, *api.ObjectMeta) (*Route, error)
	ListRoutes(context.Context, *api.ObjectMeta) (*RouteList, error)
	WatchRoutes(*api.ObjectMeta, RouteApi_WatchRoutesServer) error
}

func RegisterRouteApiServer(s *grpc.Server, srv RouteApiServer) {
	s.RegisterService(&_RouteApi_serviceDesc, srv)
}

func _RouteApi_GetRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteApiServer).GetRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.RouteApi/GetRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteApiServer).GetRoute(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteApi_ListRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteApiServer).ListRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.RouteApi/ListRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteApiServer).ListRoutes(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteApi_WatchRoutes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteApiServer).WatchRoutes(m, &routeApiWatchRoutesServer{stream})
}

type RouteApi_WatchRoutesServer interface {
	Send(*RouteEvent) error
	grpc.ServerStream
}

type routeApiWatchRoutesServer struct {
	grpc.ServerStream
}

func (x *routeApiWatchRoutesServer) Send(m *RouteEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _RouteApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.RouteApi",
	HandlerType: (*RouteApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoute",
			Handler:    _RouteApi_GetRoute_Handler,
		},
		{
			MethodName: "ListRoutes",
			Handler:    _RouteApi_ListRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRoutes",
			Handler:       _RouteApi_WatchRoutes_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "route.proto",
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *RouteSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.IPPrefix)))
		i += copy(dAtA[i:], m.IPPrefix)
	}
	if len(m.Interface) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Interface)))
		i += copy(dAtA[i:], m.Interface)
	}
	if len(m.GatewayIP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.GatewayIP)))
		i += copy(dAtA[i:], m.GatewayIP)
	}
	return i, nil
}

func (m *RouteStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RouteID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RouteID))
	}
	return i, nil
}

func (m *RouteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouteEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Route.Size()))
	n5, err := m.Route.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Route) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RouteSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPPrefix)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.Interface)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.GatewayIP)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RouteStatus) Size() (n int) {
	var l int
	_ = l
	if m.RouteID != 0 {
		n += 1 + sovRoute(uint64(m.RouteID))
	}
	return n
}

func (m *RouteList) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RouteEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRoute(uint64(m.EventType))
	}
	l = m.Route.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func sovRoute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteID", wireType)
			}
			m.RouteID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("route.proto", fileDescriptorRoute) }

var fileDescriptorRoute = []byte{
	// 643 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xc7, 0xe3, 0x36, 0xbf, 0x34, 0xd9, 0xfc, 0x68, 0xab, 0x6d, 0xa1, 0x21, 0x42, 0x49, 0x65,
	0x09, 0x81, 0x50, 0x63, 0xa3, 0xb6, 0x20, 0x38, 0x50, 0x84, 0x45, 0xa9, 0x22, 0xfe, 0x45, 0x69,
	0x25, 0x8e, 0x68, 0xe3, 0x4c, 0xdd, 0x45, 0xc9, 0x7a, 0x15, 0x8f, 0x5b, 0x22, 0xd4, 0x13, 0x0f,
	0xc0, 0x85, 0x03, 0x27, 0x5e, 0x01, 0x89, 0xa7, 0xe8, 0xb1, 0x4f, 0x10, 0xa1, 0x72, 0xcb, 0x53,
	0x20, 0x4f, 0x6c, 0xd7, 0x49, 0xd5, 0xdb, 0xce, 0x77, 0xe7, 0xfb, 0xd9, 0x99, 0xf1, 0x98, 0x95,
	0x07, 0x7e, 0x88, 0x60, 0xe9, 0x81, 0x8f, 0x3e, 0x2f, 0x2a, 0x40, 0x3a, 0x55, 0xef, 0x78, 0xbe,
	0xef, 0xf5, 0xc0, 0x16, 0x5a, 0xda, 0x42, 0x29, 0x1f, 0x05, 0x4a, 0x5f, 0x05, 0x93, 0xbc, 0xea,
	0xae, 0x27, 0xf1, 0x28, 0xec, 0x58, 0xae, 0xdf, 0xb7, 0x35, 0xa8, 0x40, 0xa8, 0xae, 0x6f, 0x07,
	0x27, 0xf6, 0x31, 0x28, 0xe9, 0x82, 0x1d, 0xa2, 0xec, 0x05, 0x91, 0xd5, 0x03, 0x95, 0x75, 0xdb,
	0x52, 0xb9, 0xbd, 0xb0, 0x0b, 0x09, 0xa6, 0x91, 0xc1, 0x78, 0xbe, 0xe7, 0xdb, 0x24, 0x77, 0xc2,
	0x43, 0x8a, 0x28, 0xa0, 0x53, 0x9c, 0x7e, 0xf7, 0x9a, 0x57, 0xa3, 0x1a, 0xfb, 0x80, 0x62, 0x92,
	0x66, 0xfe, 0x9c, 0x63, 0xff, 0xb5, 0xa3, 0xa6, 0xf8, 0x0e, 0x2b, 0x1e, 0x0c, 0x35, 0xbc, 0x05,
	0x14, 0x15, 0x63, 0xdd, 0xb8, 0x5f, 0xde, 0xbc, 0x61, 0x09, 0x2d, 0xad, 0x44, 0x74, 0x56, 0xce,
	0x46, 0xf5, 0xdc, 0xf9, 0xa8, 0x6e, 0x8c, 0x47, 0xf5, 0x85, 0x0d, 0xa9, 0x7a, 0x52, 0x41, 0x3b,
	0xf5, 0xf0, 0xd7, 0x8c, 0xbd, 0xef, 0x7c, 0x02, 0x17, 0x89, 0x30, 0x47, 0x84, 0x25, 0x22, 0x5c,
	0xca, 0x4e, 0x35, 0xc3, 0x58, 0x8c, 0xca, 0xd8, 0xf0, 0xfb, 0x12, 0xa1, 0xaf, 0x71, 0xd8, 0xce,
	0xd8, 0xf9, 0x73, 0x96, 0xdf, 0xd7, 0xe0, 0x56, 0xe6, 0x09, 0xb3, 0x62, 0x25, 0xa3, 0xb6, 0xa8,
	0xd6, 0xe8, 0xca, 0xb9, 0x15, 0xa1, 0x22, 0x4c, 0xa0, 0xc1, 0xcd, 0x60, 0xc8, 0xc8, 0xf7, 0x58,
	0x61, 0x1f, 0x05, 0x86, 0x41, 0x25, 0x4f, 0x88, 0x9b, 0xb3, 0x08, 0xba, 0x74, 0x2a, 0x31, 0x64,
	0x39, 0xa0, 0x38, 0x83, 0x89, 0xed, 0xe6, 0x2f, 0x83, 0x95, 0xd2, 0x47, 0xf9, 0x16, 0x2b, 0x36,
	0x5b, 0xad, 0x01, 0x1c, 0xca, 0xcf, 0x34, 0xa4, 0x92, 0xb3, 0x36, 0x1e, 0xd5, 0x57, 0xa4, 0x6e,
	0x68, 0x12, 0x33, 0x80, 0x34, 0x91, 0x3f, 0x62, 0xa5, 0xa6, 0x42, 0x18, 0x1c, 0x0a, 0x17, 0x68,
	0x30, 0x89, 0x2b, 0x11, 0x33, 0xae, 0xcb, 0x4c, 0xfe, 0x98, 0x95, 0xf6, 0x04, 0xc2, 0x89, 0x18,
	0x36, 0x5b, 0x34, 0x88, 0x92, 0x53, 0x19, 0x8f, 0xea, 0xab, 0xde, 0x44, 0x6c, 0x48, 0x9d, 0xf5,
	0xa5, 0xa9, 0xe6, 0x53, 0x56, 0xce, 0xb4, 0xc8, 0x1f, 0xb0, 0x05, 0x0a, 0x9b, 0x2f, 0xa9, 0xe2,
	0xbc, 0xb3, 0x3c, 0x1e, 0xd5, 0xff, 0x97, 0xdd, 0x8c, 0x39, 0x49, 0x30, 0xb7, 0xe3, 0x5e, 0xdf,
	0xc8, 0x00, 0xf9, 0x3d, 0x56, 0xa0, 0x75, 0x0f, 0x2a, 0xc6, 0xfa, 0x3c, 0x7d, 0xcc, 0xe9, 0x11,
	0xb6, 0xe3, 0x6b, 0xf3, 0xbb, 0xc1, 0x18, 0x29, 0xbb, 0xc7, 0xa0, 0x90, 0xbf, 0x62, 0x25, 0x3a,
	0x44, 0x9b, 0x41, 0x4f, 0x2e, 0x6e, 0x2e, 0xd2, 0x1e, 0xa4, 0xea, 0xa4, 0x0f, 0x88, 0xc2, 0x06,
	0x0e, 0xf5, 0x54, 0xff, 0x69, 0x12, 0xdf, 0x89, 0x37, 0x33, 0xdd, 0xa5, 0xe9, 0xe7, 0x9d, 0xb5,
	0xf8, 0xdb, 0x2d, 0x51, 0x19, 0x19, 0xc6, 0xc4, 0xb6, 0xf9, 0x6d, 0x8e, 0x15, 0xe9, 0xf4, 0x42,
	0x4b, 0x6e, 0xb1, 0xe2, 0x1e, 0xe0, 0x64, 0xd3, 0x67, 0xb7, 0xb2, 0x3a, 0x8b, 0x36, 0x73, 0x7c,
	0x9b, 0xb1, 0x68, 0x08, 0x14, 0x06, 0x57, 0x1d, 0xb3, 0x1b, 0x19, 0xe5, 0x9a, 0x39, 0xfe, 0x84,
	0x95, 0x3f, 0x08, 0x74, 0x8f, 0xae, 0xb3, 0xad, 0xce, 0xd8, 0xa8, 0x59, 0x33, 0xf7, 0xd0, 0xa8,
	0xba, 0xbf, 0xbf, 0xde, 0xfe, 0x98, 0xfc, 0x8a, 0xf9, 0x5e, 0x34, 0xff, 0xbc, 0xf6, 0x03, 0xe4,
	0x85, 0x2e, 0xf4, 0x00, 0x81, 0xcf, 0xeb, 0x10, 0xab, 0xcf, 0xec, 0x2f, 0x97, 0x34, 0xeb, 0x00,
	0x94, 0x50, 0x78, 0x3a, 0xa5, 0xbd, 0x13, 0x7d, 0x08, 0xb4, 0x70, 0xe1, 0xaa, 0x7c, 0xea, 0x2c,
	0x9f, 0x5d, 0xd4, 0x8c, 0xf3, 0x8b, 0x9a, 0xf1, 0xe7, 0xa2, 0x66, 0xfc, 0xf8, 0x5b, 0xcb, 0xb5,
	0x8c, 0x4e, 0x81, 0xca, 0xd9, 0xfa, 0x17, 0x00, 0x00, 0xff, 0xff, 0x72, 0xbd, 0xf8, 0x4f, 0xdb,
	0x04, 0x00, 0x00,
}
