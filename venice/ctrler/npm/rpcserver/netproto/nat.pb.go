// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto

package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MatchSelector_Type int32

const (
	MatchSelector_NONE          MatchSelector_Type = 0
	MatchSelector_IP            MatchSelector_Type = 1
	MatchSelector_IPPrefix      MatchSelector_Type = 2
	MatchSelector_IPRange       MatchSelector_Type = 3
	MatchSelector_SecurityGroup MatchSelector_Type = 4
)

var MatchSelector_Type_name = map[int32]string{
	0: "NONE",
	1: "IP",
	2: "IPPrefix",
	3: "IPRange",
	4: "SecurityGroup",
}
var MatchSelector_Type_value = map[string]int32{
	"NONE":          0,
	"IP":            1,
	"IPPrefix":      2,
	"IPRange":       3,
	"SecurityGroup": 4,
}

func (x MatchSelector_Type) String() string {
	return proto.EnumName(MatchSelector_Type_name, int32(x))
}
func (MatchSelector_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorNat, []int{10, 0} }

type NatRule_NatAction int32

const (
	NatRule_SNAT NatRule_NatAction = 0
	NatRule_DNAT NatRule_NatAction = 1
	NatRule_SPAT NatRule_NatAction = 2
	NatRule_DPAT NatRule_NatAction = 3
)

var NatRule_NatAction_name = map[int32]string{
	0: "SNAT",
	1: "DNAT",
	2: "SPAT",
	3: "DPAT",
}
var NatRule_NatAction_value = map[string]int32{
	"SNAT": 0,
	"DNAT": 1,
	"SPAT": 2,
	"DPAT": 3,
}

func (x NatRule_NatAction) String() string {
	return proto.EnumName(NatRule_NatAction_name, int32(x))
}
func (NatRule_NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNat, []int{11, 0} }

// nat pool
type NatPoolSpec struct {
	// Range of IP Addresses for the nat pool
	IPRange string `protobuf:"bytes,1,opt,name=IPRange,proto3" json:"ip-range"`
}

func (m *NatPoolSpec) Reset()                    { *m = NatPoolSpec{} }
func (m *NatPoolSpec) String() string            { return proto.CompactTextString(m) }
func (*NatPoolSpec) ProtoMessage()               {}
func (*NatPoolSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{0} }

func (m *NatPoolSpec) GetIPRange() string {
	if m != nil {
		return m.IPRange
	}
	return ""
}

// nat pool status
type NatPoolStatus struct {
	NatPoolID   uint64                      `protobuf:"varint,1,opt,name=NatPoolID,proto3" json:"id,omitempty"`
	NatBindings []*NatPoolStatus_NatBinding `protobuf:"bytes,2,rep,name=NatBindings" json:"NatBindings,omitempty"`
}

func (m *NatPoolStatus) Reset()                    { *m = NatPoolStatus{} }
func (m *NatPoolStatus) String() string            { return proto.CompactTextString(m) }
func (*NatPoolStatus) ProtoMessage()               {}
func (*NatPoolStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{1} }

func (m *NatPoolStatus) GetNatPoolID() uint64 {
	if m != nil {
		return m.NatPoolID
	}
	return 0
}

func (m *NatPoolStatus) GetNatBindings() []*NatPoolStatus_NatBinding {
	if m != nil {
		return m.NatBindings
	}
	return nil
}

type NatPoolStatus_NatBinding struct {
	LocalAddress  string `protobuf:"bytes,1,opt,name=LocalAddress,proto3" json:"LocalAddress,omitempty"`
	LocalPort     uint32 `protobuf:"varint,2,opt,name=LocalPort,proto3" json:"LocalPort,omitempty"`
	GlobalAddress string `protobuf:"bytes,3,opt,name=GlobalAddress,proto3" json:"GlobalAddress,omitempty"`
	GlobalPort    uint32 `protobuf:"varint,4,opt,name=GlobalPort,proto3" json:"GlobalPort,omitempty"`
	Protocol      uint32 `protobuf:"varint,5,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
}

func (m *NatPoolStatus_NatBinding) Reset()                    { *m = NatPoolStatus_NatBinding{} }
func (m *NatPoolStatus_NatBinding) String() string            { return proto.CompactTextString(m) }
func (*NatPoolStatus_NatBinding) ProtoMessage()               {}
func (*NatPoolStatus_NatBinding) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{1, 0} }

func (m *NatPoolStatus_NatBinding) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *NatPoolStatus_NatBinding) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *NatPoolStatus_NatBinding) GetGlobalAddress() string {
	if m != nil {
		return m.GlobalAddress
	}
	return ""
}

func (m *NatPoolStatus_NatBinding) GetGlobalPort() uint32 {
	if m != nil {
		return m.GlobalPort
	}
	return 0
}

func (m *NatPoolStatus_NatBinding) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

// nat pool object
type NatPool struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           NatPoolSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         NatPoolStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *NatPool) Reset()                    { *m = NatPool{} }
func (m *NatPool) String() string            { return proto.CompactTextString(m) }
func (*NatPool) ProtoMessage()               {}
func (*NatPool) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{2} }

func (m *NatPool) GetSpec() NatPoolSpec {
	if m != nil {
		return m.Spec
	}
	return NatPoolSpec{}
}

func (m *NatPool) GetStatus() NatPoolStatus {
	if m != nil {
		return m.Status
	}
	return NatPoolStatus{}
}

// list of nat pools
type NatPoolList struct {
	NatPools []*NatPool `protobuf:"bytes,1,rep,name=NatPools" json:"NatPools,omitempty"`
}

func (m *NatPoolList) Reset()                    { *m = NatPoolList{} }
func (m *NatPoolList) String() string            { return proto.CompactTextString(m) }
func (*NatPoolList) ProtoMessage()               {}
func (*NatPoolList) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{3} }

func (m *NatPoolList) GetNatPools() []*NatPool {
	if m != nil {
		return m.NatPools
	}
	return nil
}

// nat pool watch event
type NatPoolEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	NatPool   NatPool       `protobuf:"bytes,2,opt,name=NatPool" json:"natpool,omitempty"`
}

func (m *NatPoolEvent) Reset()                    { *m = NatPoolEvent{} }
func (m *NatPoolEvent) String() string            { return proto.CompactTextString(m) }
func (*NatPoolEvent) ProtoMessage()               {}
func (*NatPoolEvent) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{4} }

func (m *NatPoolEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *NatPoolEvent) GetNatPool() NatPool {
	if m != nil {
		return m.NatPool
	}
	return NatPool{}
}

// nat binding object
type NatBindingSpec struct {
	NatPoolName string `protobuf:"bytes,1,opt,name=NatPoolName,proto3" json:"nat-pool,omitempty"`
	IPAddress   string `protobuf:"bytes,2,opt,name=IPAddress,proto3" json:"ip-address,omitempty"`
}

func (m *NatBindingSpec) Reset()                    { *m = NatBindingSpec{} }
func (m *NatBindingSpec) String() string            { return proto.CompactTextString(m) }
func (*NatBindingSpec) ProtoMessage()               {}
func (*NatBindingSpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{5} }

func (m *NatBindingSpec) GetNatPoolName() string {
	if m != nil {
		return m.NatPoolName
	}
	return ""
}

func (m *NatBindingSpec) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

type NatBindingStatus struct {
	NatBindingID uint64 `protobuf:"varint,1,opt,name=NatBindingID,proto3" json:"id,omitempty"`
	NatIP        string `protobuf:"bytes,2,opt,name=NatIP,proto3" json:"nat-ip,omitempty"`
}

func (m *NatBindingStatus) Reset()                    { *m = NatBindingStatus{} }
func (m *NatBindingStatus) String() string            { return proto.CompactTextString(m) }
func (*NatBindingStatus) ProtoMessage()               {}
func (*NatBindingStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{6} }

func (m *NatBindingStatus) GetNatBindingID() uint64 {
	if m != nil {
		return m.NatBindingID
	}
	return 0
}

func (m *NatBindingStatus) GetNatIP() string {
	if m != nil {
		return m.NatIP
	}
	return ""
}

type NatBinding struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           NatBindingSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         NatBindingStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *NatBinding) Reset()                    { *m = NatBinding{} }
func (m *NatBinding) String() string            { return proto.CompactTextString(m) }
func (*NatBinding) ProtoMessage()               {}
func (*NatBinding) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{7} }

func (m *NatBinding) GetSpec() NatBindingSpec {
	if m != nil {
		return m.Spec
	}
	return NatBindingSpec{}
}

func (m *NatBinding) GetStatus() NatBindingStatus {
	if m != nil {
		return m.Status
	}
	return NatBindingStatus{}
}

// list of nat bindings
type NatBindingList struct {
	NatBindings []*NatBinding `protobuf:"bytes,1,rep,name=NatBindings" json:"NatBindings,omitempty"`
}

func (m *NatBindingList) Reset()                    { *m = NatBindingList{} }
func (m *NatBindingList) String() string            { return proto.CompactTextString(m) }
func (*NatBindingList) ProtoMessage()               {}
func (*NatBindingList) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{8} }

func (m *NatBindingList) GetNatBindings() []*NatBinding {
	if m != nil {
		return m.NatBindings
	}
	return nil
}

type NatBindingEvent struct {
	EventType  api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	NatBinding NatBinding    `protobuf:"bytes,2,opt,name=NatBinding" json:"nat-binding,omitempty"`
}

func (m *NatBindingEvent) Reset()                    { *m = NatBindingEvent{} }
func (m *NatBindingEvent) String() string            { return proto.CompactTextString(m) }
func (*NatBindingEvent) ProtoMessage()               {}
func (*NatBindingEvent) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{9} }

func (m *NatBindingEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *NatBindingEvent) GetNatBinding() NatBinding {
	if m != nil {
		return m.NatBinding
	}
	return NatBinding{}
}

type MatchSelector struct {
	MatchType string `protobuf:"bytes,1,opt,name=MatchType,proto3" json:"match-type"`
	Match     string `protobuf:"bytes,2,opt,name=Match,proto3" json:"match"`
}

func (m *MatchSelector) Reset()                    { *m = MatchSelector{} }
func (m *MatchSelector) String() string            { return proto.CompactTextString(m) }
func (*MatchSelector) ProtoMessage()               {}
func (*MatchSelector) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{10} }

func (m *MatchSelector) GetMatchType() string {
	if m != nil {
		return m.MatchType
	}
	return ""
}

func (m *MatchSelector) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

// nat rule
type NatRule struct {
	// Nat Rule From match selector.
	Src *MatchSelector `protobuf:"bytes,1,opt,name=Src" json:"source,omitempty"`
	// Nat Rule To match selector.
	Dst *MatchSelector `protobuf:"bytes,2,opt,name=Dst" json:"destination,omitempty"`
	// IP Protocol
	Protocol string `protobuf:"bytes,3,opt,name=Protocol,proto3" json:"protocol,omitempty"`
	// From tcp/udp port. Can be a single port or a port range separated by a hyphen
	FromPort string `protobuf:"bytes,4,opt,name=FromPort,proto3" json:"from-port,omitempty"`
	// To tcp/udp port. Can be a single port or a port range separated by a hyphen
	ToPort string `protobuf:"bytes,5,opt,name=ToPort,proto3" json:"to-port,omitempty"`
	// NAT pool to use
	NatPool string `protobuf:"bytes,6,opt,name=NatPool,proto3" json:"nat-pool,omitempty"`
	// Nat action
	Action string `protobuf:"bytes,7,opt,name=Action,proto3" json:"action,omitempty"`
	ID     uint64 `protobuf:"varint,8,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *NatRule) Reset()                    { *m = NatRule{} }
func (m *NatRule) String() string            { return proto.CompactTextString(m) }
func (*NatRule) ProtoMessage()               {}
func (*NatRule) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{11} }

func (m *NatRule) GetSrc() *MatchSelector {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *NatRule) GetDst() *MatchSelector {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *NatRule) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *NatRule) GetFromPort() string {
	if m != nil {
		return m.FromPort
	}
	return ""
}

func (m *NatRule) GetToPort() string {
	if m != nil {
		return m.ToPort
	}
	return ""
}

func (m *NatRule) GetNatPool() string {
	if m != nil {
		return m.NatPool
	}
	return ""
}

func (m *NatRule) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *NatRule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type NatPolicySpec struct {
	Rules []NatRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *NatPolicySpec) Reset()                    { *m = NatPolicySpec{} }
func (m *NatPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*NatPolicySpec) ProtoMessage()               {}
func (*NatPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{12} }

func (m *NatPolicySpec) GetRules() []NatRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type NatPolicyStatus struct {
	NatPolicyID uint64 `protobuf:"varint,1,opt,name=NatPolicyID,proto3" json:"id,omitempty"`
}

func (m *NatPolicyStatus) Reset()                    { *m = NatPolicyStatus{} }
func (m *NatPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyStatus) ProtoMessage()               {}
func (*NatPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{13} }

func (m *NatPolicyStatus) GetNatPolicyID() uint64 {
	if m != nil {
		return m.NatPolicyID
	}
	return 0
}

// nat policy object
type NatPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           NatPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         NatPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *NatPolicy) Reset()                    { *m = NatPolicy{} }
func (m *NatPolicy) String() string            { return proto.CompactTextString(m) }
func (*NatPolicy) ProtoMessage()               {}
func (*NatPolicy) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{14} }

func (m *NatPolicy) GetSpec() NatPolicySpec {
	if m != nil {
		return m.Spec
	}
	return NatPolicySpec{}
}

func (m *NatPolicy) GetStatus() NatPolicyStatus {
	if m != nil {
		return m.Status
	}
	return NatPolicyStatus{}
}

// list of nat policies
type NatPolicyList struct {
	NatPolicies []*NatPolicy `protobuf:"bytes,1,rep,name=NatPolicies" json:"NatPolicies,omitempty"`
}

func (m *NatPolicyList) Reset()                    { *m = NatPolicyList{} }
func (m *NatPolicyList) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyList) ProtoMessage()               {}
func (*NatPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{15} }

func (m *NatPolicyList) GetNatPolicies() []*NatPolicy {
	if m != nil {
		return m.NatPolicies
	}
	return nil
}

// security group watch event
type NatPolicyEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	NatPolicy NatPolicy     `protobuf:"bytes,2,opt,name=NatPolicy" json:"nat-policy,omitempty"`
}

func (m *NatPolicyEvent) Reset()                    { *m = NatPolicyEvent{} }
func (m *NatPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*NatPolicyEvent) ProtoMessage()               {}
func (*NatPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorNat, []int{16} }

func (m *NatPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *NatPolicyEvent) GetNatPolicy() NatPolicy {
	if m != nil {
		return m.NatPolicy
	}
	return NatPolicy{}
}

func init() {
	proto.RegisterType((*NatPoolSpec)(nil), "netproto.NatPoolSpec")
	proto.RegisterType((*NatPoolStatus)(nil), "netproto.NatPoolStatus")
	proto.RegisterType((*NatPoolStatus_NatBinding)(nil), "netproto.NatPoolStatus.NatBinding")
	proto.RegisterType((*NatPool)(nil), "netproto.NatPool")
	proto.RegisterType((*NatPoolList)(nil), "netproto.NatPoolList")
	proto.RegisterType((*NatPoolEvent)(nil), "netproto.NatPoolEvent")
	proto.RegisterType((*NatBindingSpec)(nil), "netproto.NatBindingSpec")
	proto.RegisterType((*NatBindingStatus)(nil), "netproto.NatBindingStatus")
	proto.RegisterType((*NatBinding)(nil), "netproto.NatBinding")
	proto.RegisterType((*NatBindingList)(nil), "netproto.NatBindingList")
	proto.RegisterType((*NatBindingEvent)(nil), "netproto.NatBindingEvent")
	proto.RegisterType((*MatchSelector)(nil), "netproto.MatchSelector")
	proto.RegisterType((*NatRule)(nil), "netproto.NatRule")
	proto.RegisterType((*NatPolicySpec)(nil), "netproto.NatPolicySpec")
	proto.RegisterType((*NatPolicyStatus)(nil), "netproto.NatPolicyStatus")
	proto.RegisterType((*NatPolicy)(nil), "netproto.NatPolicy")
	proto.RegisterType((*NatPolicyList)(nil), "netproto.NatPolicyList")
	proto.RegisterType((*NatPolicyEvent)(nil), "netproto.NatPolicyEvent")
	proto.RegisterEnum("netproto.MatchSelector_Type", MatchSelector_Type_name, MatchSelector_Type_value)
	proto.RegisterEnum("netproto.NatRule_NatAction", NatRule_NatAction_name, NatRule_NatAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NatPoolApi service

type NatPoolApiClient interface {
	GetNatPool(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPool, error)
	ListNatPools(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPoolList, error)
	WatchNatPools(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatPoolApi_WatchNatPoolsClient, error)
}

type natPoolApiClient struct {
	cc *grpc.ClientConn
}

func NewNatPoolApiClient(cc *grpc.ClientConn) NatPoolApiClient {
	return &natPoolApiClient{cc}
}

func (c *natPoolApiClient) GetNatPool(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPool, error) {
	out := new(NatPool)
	err := grpc.Invoke(ctx, "/netproto.NatPoolApi/GetNatPool", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natPoolApiClient) ListNatPools(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPoolList, error) {
	out := new(NatPoolList)
	err := grpc.Invoke(ctx, "/netproto.NatPoolApi/ListNatPools", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natPoolApiClient) WatchNatPools(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatPoolApi_WatchNatPoolsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NatPoolApi_serviceDesc.Streams[0], c.cc, "/netproto.NatPoolApi/WatchNatPools", opts...)
	if err != nil {
		return nil, err
	}
	x := &natPoolApiWatchNatPoolsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NatPoolApi_WatchNatPoolsClient interface {
	Recv() (*NatPoolEvent, error)
	grpc.ClientStream
}

type natPoolApiWatchNatPoolsClient struct {
	grpc.ClientStream
}

func (x *natPoolApiWatchNatPoolsClient) Recv() (*NatPoolEvent, error) {
	m := new(NatPoolEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NatPoolApi service

type NatPoolApiServer interface {
	GetNatPool(context.Context, *api.ObjectMeta) (*NatPool, error)
	ListNatPools(context.Context, *api.ObjectMeta) (*NatPoolList, error)
	WatchNatPools(*api.ObjectMeta, NatPoolApi_WatchNatPoolsServer) error
}

func RegisterNatPoolApiServer(s *grpc.Server, srv NatPoolApiServer) {
	s.RegisterService(&_NatPoolApi_serviceDesc, srv)
}

func _NatPoolApi_GetNatPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatPoolApiServer).GetNatPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatPoolApi/GetNatPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatPoolApiServer).GetNatPool(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatPoolApi_ListNatPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatPoolApiServer).ListNatPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatPoolApi/ListNatPools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatPoolApiServer).ListNatPools(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatPoolApi_WatchNatPools_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NatPoolApiServer).WatchNatPools(m, &natPoolApiWatchNatPoolsServer{stream})
}

type NatPoolApi_WatchNatPoolsServer interface {
	Send(*NatPoolEvent) error
	grpc.ServerStream
}

type natPoolApiWatchNatPoolsServer struct {
	grpc.ServerStream
}

func (x *natPoolApiWatchNatPoolsServer) Send(m *NatPoolEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _NatPoolApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.NatPoolApi",
	HandlerType: (*NatPoolApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNatPool",
			Handler:    _NatPoolApi_GetNatPool_Handler,
		},
		{
			MethodName: "ListNatPools",
			Handler:    _NatPoolApi_ListNatPools_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchNatPools",
			Handler:       _NatPoolApi_WatchNatPools_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nat.proto",
}

// Client API for NatBindingApi service

type NatBindingApiClient interface {
	GetNatBinding(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatBinding, error)
	ListNatBindings(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatBindingList, error)
	WatchNatBindings(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatBindingApi_WatchNatBindingsClient, error)
}

type natBindingApiClient struct {
	cc *grpc.ClientConn
}

func NewNatBindingApiClient(cc *grpc.ClientConn) NatBindingApiClient {
	return &natBindingApiClient{cc}
}

func (c *natBindingApiClient) GetNatBinding(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatBinding, error) {
	out := new(NatBinding)
	err := grpc.Invoke(ctx, "/netproto.NatBindingApi/GetNatBinding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natBindingApiClient) ListNatBindings(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatBindingList, error) {
	out := new(NatBindingList)
	err := grpc.Invoke(ctx, "/netproto.NatBindingApi/ListNatBindings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natBindingApiClient) WatchNatBindings(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatBindingApi_WatchNatBindingsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NatBindingApi_serviceDesc.Streams[0], c.cc, "/netproto.NatBindingApi/WatchNatBindings", opts...)
	if err != nil {
		return nil, err
	}
	x := &natBindingApiWatchNatBindingsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NatBindingApi_WatchNatBindingsClient interface {
	Recv() (*NatBindingEvent, error)
	grpc.ClientStream
}

type natBindingApiWatchNatBindingsClient struct {
	grpc.ClientStream
}

func (x *natBindingApiWatchNatBindingsClient) Recv() (*NatBindingEvent, error) {
	m := new(NatBindingEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NatBindingApi service

type NatBindingApiServer interface {
	GetNatBinding(context.Context, *api.ObjectMeta) (*NatBinding, error)
	ListNatBindings(context.Context, *api.ObjectMeta) (*NatBindingList, error)
	WatchNatBindings(*api.ObjectMeta, NatBindingApi_WatchNatBindingsServer) error
}

func RegisterNatBindingApiServer(s *grpc.Server, srv NatBindingApiServer) {
	s.RegisterService(&_NatBindingApi_serviceDesc, srv)
}

func _NatBindingApi_GetNatBinding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatBindingApiServer).GetNatBinding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatBindingApi/GetNatBinding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatBindingApiServer).GetNatBinding(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatBindingApi_ListNatBindings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatBindingApiServer).ListNatBindings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatBindingApi/ListNatBindings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatBindingApiServer).ListNatBindings(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatBindingApi_WatchNatBindings_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NatBindingApiServer).WatchNatBindings(m, &natBindingApiWatchNatBindingsServer{stream})
}

type NatBindingApi_WatchNatBindingsServer interface {
	Send(*NatBindingEvent) error
	grpc.ServerStream
}

type natBindingApiWatchNatBindingsServer struct {
	grpc.ServerStream
}

func (x *natBindingApiWatchNatBindingsServer) Send(m *NatBindingEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _NatBindingApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.NatBindingApi",
	HandlerType: (*NatBindingApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNatBinding",
			Handler:    _NatBindingApi_GetNatBinding_Handler,
		},
		{
			MethodName: "ListNatBindings",
			Handler:    _NatBindingApi_ListNatBindings_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchNatBindings",
			Handler:       _NatBindingApi_WatchNatBindings_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nat.proto",
}

// Client API for NatPolicyApi service

type NatPolicyApiClient interface {
	GetNatPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPolicy, error)
	ListNatPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPolicyList, error)
	WatchNatPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatPolicyApi_WatchNatPoliciesClient, error)
}

type natPolicyApiClient struct {
	cc *grpc.ClientConn
}

func NewNatPolicyApiClient(cc *grpc.ClientConn) NatPolicyApiClient {
	return &natPolicyApiClient{cc}
}

func (c *natPolicyApiClient) GetNatPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPolicy, error) {
	out := new(NatPolicy)
	err := grpc.Invoke(ctx, "/netproto.NatPolicyApi/GetNatPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natPolicyApiClient) ListNatPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*NatPolicyList, error) {
	out := new(NatPolicyList)
	err := grpc.Invoke(ctx, "/netproto.NatPolicyApi/ListNatPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natPolicyApiClient) WatchNatPolicies(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (NatPolicyApi_WatchNatPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NatPolicyApi_serviceDesc.Streams[0], c.cc, "/netproto.NatPolicyApi/WatchNatPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &natPolicyApiWatchNatPoliciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NatPolicyApi_WatchNatPoliciesClient interface {
	Recv() (*NatPolicyEvent, error)
	grpc.ClientStream
}

type natPolicyApiWatchNatPoliciesClient struct {
	grpc.ClientStream
}

func (x *natPolicyApiWatchNatPoliciesClient) Recv() (*NatPolicyEvent, error) {
	m := new(NatPolicyEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NatPolicyApi service

type NatPolicyApiServer interface {
	GetNatPolicy(context.Context, *api.ObjectMeta) (*NatPolicy, error)
	ListNatPolicies(context.Context, *api.ObjectMeta) (*NatPolicyList, error)
	WatchNatPolicies(*api.ObjectMeta, NatPolicyApi_WatchNatPoliciesServer) error
}

func RegisterNatPolicyApiServer(s *grpc.Server, srv NatPolicyApiServer) {
	s.RegisterService(&_NatPolicyApi_serviceDesc, srv)
}

func _NatPolicyApi_GetNatPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatPolicyApiServer).GetNatPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatPolicyApi/GetNatPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatPolicyApiServer).GetNatPolicy(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatPolicyApi_ListNatPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatPolicyApiServer).ListNatPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.NatPolicyApi/ListNatPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatPolicyApiServer).ListNatPolicies(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatPolicyApi_WatchNatPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NatPolicyApiServer).WatchNatPolicies(m, &natPolicyApiWatchNatPoliciesServer{stream})
}

type NatPolicyApi_WatchNatPoliciesServer interface {
	Send(*NatPolicyEvent) error
	grpc.ServerStream
}

type natPolicyApiWatchNatPoliciesServer struct {
	grpc.ServerStream
}

func (x *natPolicyApiWatchNatPoliciesServer) Send(m *NatPolicyEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _NatPolicyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.NatPolicyApi",
	HandlerType: (*NatPolicyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNatPolicy",
			Handler:    _NatPolicyApi_GetNatPolicy_Handler,
		},
		{
			MethodName: "ListNatPolicies",
			Handler:    _NatPolicyApi_ListNatPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchNatPolicies",
			Handler:       _NatPolicyApi_WatchNatPolicies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nat.proto",
}

func (m *NatPoolSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPRange) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.IPRange)))
		i += copy(dAtA[i:], m.IPRange)
	}
	return i, nil
}

func (m *NatPoolStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NatPoolID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NatPoolID))
	}
	if len(m.NatBindings) > 0 {
		for _, msg := range m.NatBindings {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolStatus_NatBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolStatus_NatBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.LocalAddress)))
		i += copy(dAtA[i:], m.LocalAddress)
	}
	if m.LocalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.LocalPort))
	}
	if len(m.GlobalAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.GlobalAddress)))
		i += copy(dAtA[i:], m.GlobalAddress)
	}
	if m.GlobalPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.GlobalPort))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Protocol))
	}
	return i, nil
}

func (m *NatPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *NatPoolList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NatPools) > 0 {
		for _, msg := range m.NatPools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPoolEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPoolEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.NatPool.Size()))
	n5, err := m.NatPool.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *NatBindingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatBindingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NatPoolName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.NatPoolName)))
		i += copy(dAtA[i:], m.NatPoolName)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	return i, nil
}

func (m *NatBindingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatBindingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NatBindingID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NatBindingID))
	}
	if len(m.NatIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.NatIP)))
		i += copy(dAtA[i:], m.NatIP)
	}
	return i, nil
}

func (m *NatBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x22
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *NatBindingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatBindingList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NatBindings) > 0 {
		for _, msg := range m.NatBindings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatBindingEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatBindingEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.NatBinding.Size()))
	n10, err := m.NatBinding.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *MatchSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.MatchType)))
		i += copy(dAtA[i:], m.MatchType)
	}
	if len(m.Match) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.Match)))
		i += copy(dAtA[i:], m.Match)
	}
	return i, nil
}

func (m *NatRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Src != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Src.Size()))
		n11, err := m.Src.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Dst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.Dst.Size()))
		n12, err := m.Dst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.FromPort) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.FromPort)))
		i += copy(dAtA[i:], m.FromPort)
	}
	if len(m.ToPort) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.ToPort)))
		i += copy(dAtA[i:], m.ToPort)
	}
	if len(m.NatPool) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.NatPool)))
		i += copy(dAtA[i:], m.NatPool)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNat(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.ID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *NatPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NatPolicyID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.NatPolicyID))
	}
	return i, nil
}

func (m *NatPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.Status.Size()))
	n16, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *NatPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NatPolicies) > 0 {
		for _, msg := range m.NatPolicies {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNat(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintNat(dAtA, i, uint64(m.NatPolicy.Size()))
	n17, err := m.NatPolicy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	return i, nil
}

func encodeVarintNat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NatPoolSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPRange)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatPoolStatus) Size() (n int) {
	var l int
	_ = l
	if m.NatPoolID != 0 {
		n += 1 + sovNat(uint64(m.NatPoolID))
	}
	if len(m.NatBindings) > 0 {
		for _, e := range m.NatBindings {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolStatus_NatBinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	if m.LocalPort != 0 {
		n += 1 + sovNat(uint64(m.LocalPort))
	}
	l = len(m.GlobalAddress)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	if m.GlobalPort != 0 {
		n += 1 + sovNat(uint64(m.GlobalPort))
	}
	if m.Protocol != 0 {
		n += 1 + sovNat(uint64(m.Protocol))
	}
	return n
}

func (m *NatPool) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func (m *NatPoolList) Size() (n int) {
	var l int
	_ = l
	if len(m.NatPools) > 0 {
		for _, e := range m.NatPools {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPoolEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovNat(uint64(m.EventType))
	}
	l = m.NatPool.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func (m *NatBindingSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.NatPoolName)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatBindingStatus) Size() (n int) {
	var l int
	_ = l
	if m.NatBindingID != 0 {
		n += 1 + sovNat(uint64(m.NatBindingID))
	}
	l = len(m.NatIP)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatBinding) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func (m *NatBindingList) Size() (n int) {
	var l int
	_ = l
	if len(m.NatBindings) > 0 {
		for _, e := range m.NatBindings {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatBindingEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovNat(uint64(m.EventType))
	}
	l = m.NatBinding.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func (m *MatchSelector) Size() (n int) {
	var l int
	_ = l
	l = len(m.MatchType)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	return n
}

func (m *NatRule) Size() (n int) {
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.FromPort)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.ToPort)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.NatPool)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovNat(uint64(m.ID))
	}
	return n
}

func (m *NatPolicySpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.NatPolicyID != 0 {
		n += 1 + sovNat(uint64(m.NatPolicyID))
	}
	return n
}

func (m *NatPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovNat(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func (m *NatPolicyList) Size() (n int) {
	var l int
	_ = l
	if len(m.NatPolicies) > 0 {
		for _, e := range m.NatPolicies {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	return n
}

func (m *NatPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovNat(uint64(m.EventType))
	}
	l = m.NatPolicy.Size()
	n += 1 + l + sovNat(uint64(l))
	return n
}

func sovNat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNat(x uint64) (n int) {
	return sovNat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPoolSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPRange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPRange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPoolID", wireType)
			}
			m.NatPoolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatPoolID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatBindings = append(m.NatBindings, &NatPoolStatus_NatBinding{})
			if err := m.NatBindings[len(m.NatBindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolStatus_NatBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalPort", wireType)
			}
			m.GlobalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPools = append(m.NatPools, &NatPool{})
			if err := m.NatPools[len(m.NatPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPoolEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPoolEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPoolEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatBindingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBindingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBindingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatBindingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBindingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBindingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatBindingID", wireType)
			}
			m.NatBindingID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatBindingID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatBindingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBindingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBindingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatBindings = append(m.NatBindings, &NatBinding{})
			if err := m.NatBindings[len(m.NatBindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatBindingEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatBindingEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatBindingEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatBinding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NatBinding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &MatchSelector{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &MatchSelector{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, NatRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPolicyID", wireType)
			}
			m.NatPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatPolicyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NatPolicies = append(m.NatPolicies, &NatPolicy{})
			if err := m.NatPolicies[len(m.NatPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NatPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNat   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nat.proto", fileDescriptorNat) }

var fileDescriptorNat = []byte{
	// 1440 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x8f, 0xd3, 0x46,
	0x14, 0x8f, 0x9d, 0xec, 0x6e, 0xf2, 0x36, 0xd9, 0x0d, 0xc3, 0x02, 0x49, 0x4a, 0x37, 0xc8, 0x6a,
	0xab, 0x6d, 0x45, 0x12, 0x14, 0x0a, 0xe2, 0x00, 0xb4, 0x71, 0xb3, 0x4b, 0x53, 0x60, 0x49, 0x93,
	0x95, 0x7a, 0xf6, 0x3a, 0x43, 0x70, 0xe5, 0x78, 0x2c, 0x7b, 0x42, 0xbb, 0xaa, 0xb8, 0x14, 0x89,
	0xcf, 0xd0, 0x53, 0x7b, 0xe9, 0xa5, 0x48, 0xad, 0x5a, 0x2e, 0xed, 0x17, 0xa8, 0xc4, 0x91, 0x4f,
	0x10, 0x55, 0xf4, 0x96, 0x7e, 0x89, 0x6a, 0xc6, 0x63, 0x7b, 0x9c, 0x78, 0x81, 0x03, 0x48, 0xdc,
	0x66, 0x7e, 0x79, 0xef, 0xe7, 0x99, 0xdf, 0xfb, 0x33, 0x2f, 0x50, 0x70, 0x0c, 0xda, 0x74, 0x3d,
	0x42, 0x09, 0xca, 0x3b, 0x98, 0xf2, 0x55, 0xed, 0xec, 0x98, 0x90, 0xb1, 0x8d, 0x5b, 0x86, 0x6b,
	0xb5, 0x0c, 0xc7, 0x21, 0xd4, 0xa0, 0x16, 0x71, 0xfc, 0xc0, 0xae, 0xb6, 0x3b, 0xb6, 0xe8, 0xbd,
	0xe9, 0x61, 0xd3, 0x24, 0x93, 0x96, 0x8b, 0x1d, 0xdf, 0x70, 0x46, 0xa4, 0xe5, 0x7f, 0xd3, 0xba,
	0x8f, 0x1d, 0xcb, 0xc4, 0xad, 0x29, 0xb5, 0x6c, 0x9f, 0xb9, 0x8e, 0xb1, 0x23, 0x7b, 0xb7, 0x2c,
	0xc7, 0xb4, 0xa7, 0x23, 0x1c, 0xd2, 0x34, 0x24, 0x9a, 0x31, 0x19, 0x93, 0x16, 0x87, 0x0f, 0xa7,
	0x77, 0xf9, 0x8e, 0x6f, 0xf8, 0x4a, 0x98, 0xbf, 0x7f, 0xcc, 0x57, 0xd9, 0x19, 0x27, 0x98, 0x1a,
	0x81, 0x99, 0x76, 0x09, 0xd6, 0xf7, 0x0d, 0xda, 0x27, 0xc4, 0x1e, 0xba, 0xd8, 0x44, 0x1f, 0xc0,
	0x5a, 0xaf, 0x3f, 0x30, 0x9c, 0x31, 0xae, 0x28, 0xe7, 0x94, 0x9d, 0x82, 0x5e, 0x9c, 0xcf, 0xea,
	0x79, 0xcb, 0x6d, 0x78, 0x0c, 0x1b, 0x84, 0x3f, 0x6a, 0x7f, 0xa9, 0x50, 0x0a, 0xfd, 0xa8, 0x41,
	0xa7, 0x3e, 0x6a, 0x42, 0x41, 0x00, 0xbd, 0x2e, 0xf7, 0xcd, 0xe9, 0xe5, 0xf9, 0xac, 0x5e, 0xb4,
	0x46, 0xe7, 0xc9, 0xc4, 0xa2, 0x78, 0xe2, 0xd2, 0xa3, 0x41, 0x6c, 0x82, 0xba, 0xfc, 0xc3, 0xba,
	0xe5, 0x8c, 0x2c, 0x67, 0xec, 0x57, 0xd4, 0x73, 0xd9, 0x9d, 0xf5, 0xb6, 0xd6, 0x0c, 0x35, 0x6d,
	0x26, 0xd8, 0x9b, 0xb1, 0xe9, 0x40, 0x76, 0xab, 0xfd, 0xae, 0x00, 0xc4, 0x7b, 0xa4, 0x41, 0xf1,
	0x16, 0x31, 0x0d, 0xbb, 0x33, 0x1a, 0x79, 0xd8, 0xf7, 0x83, 0x3b, 0x0c, 0x12, 0x18, 0x3a, 0x0b,
	0x05, 0xbe, 0xef, 0x13, 0x8f, 0x56, 0xd4, 0x73, 0xca, 0x4e, 0x69, 0x10, 0x03, 0xe8, 0x3d, 0x28,
	0xdd, 0xb0, 0xc9, 0x61, 0x4c, 0x91, 0xe5, 0x14, 0x49, 0x10, 0x6d, 0x03, 0x04, 0x00, 0x27, 0xc9,
	0x71, 0x12, 0x09, 0x41, 0x35, 0xc8, 0xf7, 0xd9, 0x2d, 0x4c, 0x62, 0x57, 0x56, 0xf8, 0xaf, 0xd1,
	0x5e, 0xfb, 0x59, 0x85, 0x35, 0x71, 0x39, 0x74, 0x1d, 0xf2, 0x07, 0x47, 0x2e, 0xbe, 0x8d, 0xa9,
	0xc1, 0xcf, 0xba, 0xde, 0x2e, 0x35, 0x0d, 0xd7, 0x6a, 0x86, 0xa0, 0x7e, 0xf2, 0xe9, 0xac, 0x9e,
	0x79, 0x36, 0xab, 0x2b, 0xf3, 0x59, 0x7d, 0xed, 0xbc, 0xe5, 0xd8, 0x96, 0x83, 0x07, 0x91, 0x0f,
	0xba, 0x09, 0x70, 0xe7, 0xf0, 0x6b, 0x6c, 0x52, 0xce, 0xa0, 0x72, 0x86, 0x4d, 0xce, 0x10, 0xc3,
	0x7a, 0x4d, 0xe2, 0xd8, 0x60, 0xa1, 0x97, 0x02, 0x22, 0xb9, 0xa3, 0x0e, 0xe4, 0x58, 0x0e, 0xf0,
	0x1b, 0xaf, 0xb7, 0x4f, 0x2d, 0x87, 0xc2, 0xc5, 0xa6, 0x7e, 0x9a, 0x91, 0x31, 0x22, 0xdf, 0xc5,
	0xa6, 0x44, 0xc4, 0x5d, 0x51, 0x0f, 0x56, 0x83, 0x80, 0x71, 0x4d, 0xd6, 0xdb, 0x67, 0x8e, 0x89,
	0xa7, 0x5e, 0x11, 0x34, 0x65, 0x9f, 0xef, 0x25, 0x22, 0x41, 0xa0, 0x5d, 0x8d, 0x12, 0xf3, 0x96,
	0xe5, 0x53, 0xd4, 0x80, 0xbc, 0xd8, 0xb2, 0xa8, 0xb2, 0x5c, 0x39, 0xb1, 0xc4, 0x3d, 0x88, 0x4c,
	0xb4, 0x1f, 0x15, 0x28, 0x8a, 0xcd, 0xee, 0x7d, 0xec, 0x50, 0xb4, 0x07, 0x05, 0xbe, 0x60, 0xd2,
	0x71, 0xa9, 0x37, 0xda, 0x1b, 0x5c, 0xa8, 0x08, 0xd5, 0x2b, 0xf3, 0x59, 0x7d, 0x0b, 0xb3, 0x6d,
	0x83, 0x1e, 0xb9, 0x58, 0x4e, 0xdb, 0xc8, 0x08, 0xed, 0x45, 0xc1, 0x13, 0x72, 0x2f, 0x1f, 0x43,
	0xaf, 0x8a, 0xcb, 0x9d, 0x70, 0x0c, 0xea, 0x12, 0x62, 0x4b, 0x4c, 0xa1, 0xb3, 0xf6, 0xbd, 0x02,
	0x1b, 0x71, 0xe2, 0x72, 0xf1, 0xae, 0x44, 0x37, 0xde, 0x37, 0x26, 0x61, 0xfd, 0x9d, 0x9e, 0xcf,
	0xea, 0xc8, 0x31, 0x68, 0x63, 0x81, 0x48, 0x36, 0x45, 0x97, 0xa1, 0xd0, 0xeb, 0x87, 0x09, 0xab,
	0x72, 0x3f, 0x7e, 0x19, 0xcb, 0x6d, 0x18, 0x01, 0x2a, 0x5f, 0x26, 0x32, 0xd5, 0x28, 0x94, 0xa5,
	0x33, 0x04, 0x75, 0xfc, 0x31, 0x17, 0x4e, 0x60, 0x2f, 0x28, 0xe5, 0x84, 0x15, 0xfa, 0x08, 0x56,
	0xf6, 0x0d, 0xda, 0xeb, 0x8b, 0xaf, 0x6f, 0xb1, 0xd0, 0xb2, 0x53, 0x5b, 0xae, 0xe4, 0x12, 0x98,
	0x68, 0xbf, 0xaa, 0x89, 0x9a, 0x7d, 0xab, 0x6a, 0xa0, 0x9b, 0xa8, 0x81, 0x4a, 0x22, 0xb6, 0x52,
	0xac, 0x5e, 0x52, 0x06, 0xb7, 0x16, 0xca, 0xa0, 0x96, 0xca, 0xf3, 0xaa, 0x95, 0xf0, 0xb9, 0x9c,
	0x29, 0xbc, 0x18, 0x2e, 0x27, 0x7b, 0x67, 0x50, 0x0f, 0x5b, 0x69, 0x1f, 0x49, 0x74, 0x4b, 0xed,
	0x37, 0x05, 0x36, 0xe3, 0xfd, 0xeb, 0x2d, 0x8c, 0xa1, 0x1c, 0x54, 0x11, 0x86, 0xd4, 0x23, 0xe9,
	0xef, 0x8a, 0x1b, 0x9f, 0x62, 0x09, 0x72, 0x18, 0x80, 0x72, 0x38, 0x62, 0x53, 0xed, 0x6f, 0x05,
	0x4a, 0xb7, 0x0d, 0x6a, 0xde, 0x1b, 0x62, 0x1b, 0x9b, 0x94, 0x78, 0xe8, 0x26, 0x14, 0x38, 0x10,
	0x1d, 0xb7, 0xa0, 0x37, 0x1e, 0x3f, 0xaa, 0xbe, 0x33, 0xa4, 0xde, 0xae, 0x33, 0x9d, 0xec, 0x24,
	0xac, 0x79, 0x0e, 0x7d, 0x38, 0x9f, 0xd5, 0x61, 0xc2, 0x60, 0x7e, 0xfa, 0x41, 0xec, 0x8f, 0xea,
	0xb0, 0xc2, 0x37, 0x22, 0x6b, 0x0b, 0xf3, 0x59, 0x7d, 0x85, 0x5b, 0x0e, 0x02, 0x5c, 0xdb, 0x83,
	0x1c, 0x37, 0xcc, 0x43, 0x6e, 0xff, 0xce, 0xfe, 0x6e, 0x39, 0x83, 0x56, 0x41, 0xed, 0xf5, 0xcb,
	0x0a, 0x2a, 0x42, 0xbe, 0xd7, 0xef, 0x7b, 0xf8, 0xae, 0xf5, 0x6d, 0x59, 0x45, 0xeb, 0xd1, 0xb3,
	0x59, 0xce, 0xa2, 0x13, 0x50, 0x1a, 0x62, 0x73, 0xea, 0x59, 0xf4, 0xe8, 0x86, 0x47, 0xa6, 0x6e,
	0x39, 0xa7, 0xfd, 0x97, 0xe5, 0x6d, 0x63, 0x30, 0xb5, 0x31, 0xfa, 0x04, 0xb2, 0x43, 0xcf, 0x14,
	0xa9, 0x2e, 0x35, 0xc8, 0xc4, 0xc9, 0x83, 0x0a, 0xf2, 0xc9, 0xd4, 0x33, 0x65, 0xbd, 0x99, 0x27,
	0xea, 0x42, 0xb6, 0xeb, 0x53, 0x21, 0xf1, 0xb1, 0x04, 0x55, 0xa6, 0xf0, 0x08, 0xfb, 0xd4, 0x72,
	0xf8, 0x3c, 0x21, 0xb3, 0x74, 0x7d, 0x8a, 0xda, 0xd2, 0x13, 0x95, 0x8d, 0x5b, 0x8d, 0x2b, 0x30,
	0xc9, 0x3c, 0xb2, 0x43, 0x17, 0x21, 0xbf, 0xe7, 0x91, 0x49, 0xf4, 0xe8, 0x15, 0xf4, 0x33, 0xf3,
	0x59, 0xfd, 0xe4, 0x5d, 0x8f, 0x4c, 0x1a, 0x2e, 0xf1, 0xa8, 0xec, 0x14, 0x1a, 0xa2, 0x06, 0xac,
	0x1e, 0x10, 0xee, 0xb2, 0xc2, 0x5d, 0x4e, 0xb1, 0xce, 0x48, 0xc9, 0xa2, 0x83, 0x30, 0x42, 0x17,
	0xe2, 0x06, 0xbb, 0xfa, 0xc2, 0x0e, 0x18, 0x3d, 0xa2, 0x5f, 0xc0, 0x6a, 0xc7, 0x64, 0x57, 0xac,
	0xac, 0x71, 0x87, 0xf6, 0xe3, 0x47, 0xd5, 0x5a, 0x98, 0x0f, 0x42, 0x75, 0x96, 0x7f, 0x81, 0x11,
	0x4b, 0x87, 0xb2, 0x61, 0x2e, 0x48, 0x22, 0x18, 0xd0, 0x06, 0xa8, 0xbd, 0x6e, 0x25, 0xcf, 0x7a,
	0xde, 0x40, 0xed, 0x75, 0xb5, 0x8b, 0x7c, 0xaa, 0x11, 0x3f, 0xe6, 0x21, 0x37, 0xdc, 0xef, 0x1c,
	0x94, 0x33, 0x6c, 0xd5, 0x65, 0x2b, 0x85, 0x63, 0xfd, 0xce, 0x41, 0x59, 0xe5, 0x18, 0x5b, 0x65,
	0xb5, 0x2f, 0xc5, 0x6c, 0x64, 0x5b, 0xe6, 0x11, 0xef, 0x07, 0x9f, 0xc2, 0x8a, 0x37, 0xb5, 0x71,
	0xfa, 0xcb, 0xc5, 0x8e, 0xa7, 0x9f, 0x11, 0x35, 0xb1, 0xc9, 0xed, 0xe4, 0x9e, 0xc9, 0x01, 0x6d,
	0x97, 0x17, 0xae, 0xa0, 0x0c, 0x1a, 0x75, 0x5b, 0x3c, 0x17, 0x0c, 0x7a, 0x41, 0x9f, 0x96, 0x8d,
	0xb4, 0xc7, 0xaa, 0x98, 0xd2, 0xd8, 0xfe, 0xed, 0xea, 0xbc, 0x9f, 0x25, 0x3a, 0xef, 0xe2, 0xe0,
	0x10, 0x4a, 0xf9, 0x92, 0xc6, 0x7b, 0x73, 0xa1, 0xf1, 0x56, 0xd3, 0x68, 0x5e, 0xb5, 0xef, 0xee,
	0x49, 0x61, 0xe4, 0x6d, 0xf7, 0x52, 0xac, 0xb8, 0x15, 0x05, 0xf3, 0x64, 0xca, 0x27, 0x06, 0xb2,
	0x9d, 0xf6, 0x4b, 0xf0, 0xd4, 0x07, 0x3f, 0xbd, 0xde, 0xa6, 0x7b, 0x47, 0x0a, 0xa7, 0x08, 0x40,
	0xda, 0x79, 0xf4, 0xb3, 0xe2, 0xb2, 0x5b, 0x41, 0x1d, 0x31, 0x6c, 0x69, 0x2a, 0x67, 0x60, 0xfb,
	0xa7, 0xe0, 0x6d, 0x66, 0x75, 0xd5, 0x71, 0x2d, 0xd4, 0x06, 0xb8, 0x81, 0x69, 0x58, 0x68, 0x8b,
	0xb1, 0xad, 0x2d, 0xcf, 0x3e, 0x5a, 0x06, 0x5d, 0x81, 0x22, 0x53, 0x2b, 0x1c, 0xc5, 0x96, 0xbd,
	0x96, 0x27, 0x4b, 0x66, 0xaf, 0x65, 0xd0, 0x55, 0x28, 0x7d, 0xc5, 0x7a, 0xd8, 0xf1, 0xae, 0xa7,
	0x97, 0x5c, 0xb9, 0x16, 0x5a, 0xe6, 0x82, 0x52, 0xc3, 0x4f, 0x1e, 0x56, 0x8d, 0x78, 0xb4, 0xce,
	0xd9, 0x2c, 0x64, 0x39, 0x97, 0xf8, 0x14, 0x65, 0xdd, 0x29, 0x45, 0xab, 0x23, 0x6c, 0x63, 0x8a,
	0x6b, 0xd7, 0x5a, 0xdf, 0xc5, 0x8c, 0xcd, 0x03, 0xec, 0x18, 0x0e, 0x7d, 0x90, 0xc0, 0xd8, 0x4c,
	0x35, 0x74, 0x0d, 0x13, 0x2f, 0xc3, 0x0f, 0xda, 0x7f, 0x06, 0xff, 0x7c, 0xc4, 0x0b, 0xc5, 0x44,
	0xba, 0x02, 0xa5, 0x40, 0xa4, 0x70, 0xa2, 0x59, 0x3a, 0x76, 0xea, 0x3b, 0xa8, 0x65, 0xd0, 0x75,
	0xd8, 0x14, 0x52, 0x85, 0x4f, 0xf4, 0xb2, 0x6f, 0xea, 0x0c, 0x22, 0x04, 0xd3, 0xa1, 0x1c, 0x0a,
	0x76, 0x3c, 0x41, 0x35, 0x8d, 0x20, 0x96, 0xed, 0xde, 0x93, 0x87, 0xd5, 0x51, 0x62, 0x20, 0x7b,
	0x53, 0xca, 0xfd, 0xa1, 0x8a, 0x99, 0x9c, 0x65, 0x1a, 0x13, 0xee, 0x32, 0x14, 0xc3, 0xec, 0xe2,
	0xfd, 0x68, 0xe9, 0xe8, 0x69, 0xb9, 0xac, 0x65, 0xd0, 0xb5, 0x48, 0xb6, 0xb0, 0xc6, 0x96, 0x5d,
	0xd3, 0x1a, 0x88, 0x50, 0xad, 0x13, 0xab, 0x76, 0xbc, 0x7f, 0x25, 0xc5, 0x3f, 0x16, 0x6d, 0xfc,
	0xe4, 0x61, 0xd5, 0x94, 0x5b, 0xe9, 0x1b, 0xd2, 0x4c, 0x2f, 0x3f, 0x7d, 0xbe, 0xad, 0x3c, 0x7b,
	0xbe, 0xad, 0xfc, 0xf3, 0x7c, 0x5b, 0xf9, 0xe1, 0xdf, 0xed, 0x4c, 0x5f, 0x39, 0x5c, 0xe5, 0xc7,
	0xba, 0xf8, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xae, 0x80, 0x9c, 0x6d, 0x8b, 0x10, 0x00, 0x00,
}
