// {C} Copyright 2017 Pensando Systems Inc. All rights reserved.

syntax = "proto3";

// Trouble shooting: Mirroring APIs
package tsproto;

import "google/api/annotations.proto";
import public "github.com/pensando/sw/venice/utils/apigen/annotations/includes.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "github.com/pensando/sw/api/meta.proto";
import "github.com/pensando/sw/api/export.proto";
//========================================================================================
// Packet Mirroring
//========================================================================================
//-----------------------
//---- MirrorSessionSpec
//-----------------------
message MirrorSessionSpec {
    bool                    Enable          = 1 [(gogoproto.jsontag) = "enable"];
    // Original packets can be truncated when being mirrored to save bandwidth and storage
    // When mirrored packets are sent to Venice, default size is 128 (venice)??? or complete packet (erspan)?
    uint32                  PacketSize      = 2 [(gogoproto.jsontag) = "packet-size,omitempty"];

    MirrorStopConditions    StopConditions  = 3 [(gogoproto.nullable)=false, (gogoproto.jsontag) = "stop-condition,inline"];

    // Mirrored packet collectors
    repeated MirrorCollector Collectors     = 4 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "collectors,inline"];

    // Traffic Selection Rules - Matching pakcets are mirrored, based on packet filters and start/stop conditions
    repeated MatchRule      MatchRules      = 5 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "match-rules,inline"];

    // CaptureAt and PacketDirection for capturing
    // When Src and Dst is on the same NIC, only one mirror copy in each direction is made
    MirrorSrcDst        CaptureAt           = 6 [(gogoproto.jsontag) = "capture-at,omitempty", (venice.check) = "StrEnum(MirrorSrcDst)"];
    MirrorDir           PacketDir           = 7 [(gogoproto.jsontag) = "packet-direction,omitempty", (venice.check) = "StrEnum(MirrorDir)"];

    // Filter selected packets further - mirror only those packets that match atleast one of the PacketFilers
    enum MirrorPacketFilter {
        ALL_PKTS                = 0;
        ALL_DROPS               = 1;
        NETWORK_POLICY_DROP     = 2;
        FIREWALL_POLICY_DROP    = 3;
    }
    repeated string PacketFilters           = 8 [(gogoproto.jsontag) = "packet-filters,omitempty", (venice.check) = "StrEnum(MirrorSessionSpec.MirrorPacketFilter)"];
}

enum MirrorDir {
    BOTH        = 0;
    INGRESS     = 1;
    EGRESS      = 2;
}

// A MirrorSession will stop mirroring after this condition is met
message MirrorStopConditions {
    // Stop after capturing specified number of packets
    uint32          MaxPacketCount  = 1 [(gogoproto.jsontag) = "max-packets,omitempty"];
}

// Mirror collector - can be an external device (via ERSPAN) or Venice (internal packet capture)
message MirrorCollector {
    enum PacketCollectorType {
        VENICE  = 0;
        ERSPAN  = 1; // external collector via erspan
    }
    string              Type        = 1 [(gogoproto.jsontag) = "type,omitempty", (venice.check) = "StrEnum(MirrorCollector.PacketCollectorType)"];

    // When collector type is Venice, collector export information is not required
    api.ExportConfig    ExportCfg   = 2 [(gogoproto.nullable)=false, (gogoproto.jsontag) = "export-config,omitempty"];
}

// Traffic Selection Rules
// Traffic can be matched using EP names or IPv4/v6 addresses/ranges/prefixes or MAC addresses
message MatchSelector {
    // only one of the following match selector can be specified to select a packet from mirroring
    repeated string Endpoints       = 1 [(gogoproto.jsontag) = "endpoints,omitempty"];
    // Each IPAddress can be single address(10.1.1.1)/range(10.1.1.10-20)/subnet(10.1.0.0/16)
    repeated string IPAddresses     = 2 [(gogoproto.jsontag) = "ip-addresses,omitempty"];
    // List of MacAddresses - "aa:bb:cc:dd:ee:ff", "00:01:02:03:04:05"
    repeated string MACAddresses    = 3 [(gogoproto.jsontag) = "mac-addresses,omitempty"];
}

// Application/protocol selector
message AppProtoSelector {
    // ports - Includes protocol name and port Eg ["tcp/1234", "udp"]
    repeated string Ports   = 1 [(gogoproto.jsontag) = "ports,omitempty"];
    // Apps - E.g. ["Redis"]
    repeated string Apps    = 2 [(gogoproto.jsontag) = "applications,omitempty"];
}

// MatchRule : This is used to select packets that need to be monitored (mirrored)
message MatchRule {
    // Either Src or Dst or both must be specified, both cannot be *
    // Src = * when not specified
    // When Src is specified and resides on Pesnsando SmartNIC, matching pkts to/from src will be mirrored
    MatchSelector       Src         = 1 [(gogoproto.jsontag) = "source,omitempty"];
    // Dst = * when not specified
    // When Dst is specified and resides on Pesnsando SmartNIC, matching pkts to/from dst will be mirrored
    MatchSelector       Dst         = 2 [(gogoproto.jsontag) = "destination,omitempty"];;
    // App = * when not specified
    AppProtoSelector   AppProtoSel  = 3 [(gogoproto.jsontag) = "app-protocol-selectors,omitempty"];;
}


//-------------------------
//---- MirrorSessionStatus
//-------------------------
enum MirrorSessionState {
    INACTIVE    = 0;    // not applicable to any flow on this NIC
    RUNNING     = 1;    // active i.e. capturing packets
}

enum MirrorSrcDst {
    SRC_DST = 0;    // both src and dst are on the same SamrtNIC
    SRC     = 1;    // captured at src
    DST     = 2;    // captured at dst
}

message MirrorSessionStatus {
    string          State                = 4 [(gogoproto.jsontag) = "oper-state,inline", (venice.check) = "StrEnum(MirrorSessionState)"];
    uint32          SessionId            = 5 [(gogoproto.jsontag) = "session-id,inline"];
    MirrorSrcDst    CapturePoint         = 6 [(gogoproto.jsontag) = "capture-point,omitempty", (venice.check) = "StrEnum(MirrorSrcDst)"];

}

message MirrorSession {
    api.TypeMeta            T       = 1 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (gogoproto.jsontag) = ",inline"];
    api.ObjectMeta          O       = 2 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (gogoproto.jsontag) = "meta,omitempty"];
    MirrorSessionSpec       Spec    = 3 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "spec,inline"];
    MirrorSessionStatus     Status  = 4 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "status,omitempty"];
}

// mirror session crud event
message MirrorSessionEvent {
    api.EventType   EventType       = 1 [(gogoproto.jsontag) = "event-type,omitempty"];
    MirrorSession   MirrorSession   = 2 [(gogoproto.nullable)=false, (gogoproto.jsontag) = "mirror-session,omitempty"];
}

message MirrorSessionEventList {
    repeated MirrorSessionEvent mirrorSessionEvents = 1;
}

message MirrorSessionList {
    repeated MirrorSession      MirrorSessions = 1 [(gogoproto.jsontag) = "mirror-sessions,omitempty"];
}

message MirrorSessionStatusList {
    string                      SmartNIC   = 1 [(gogoproto.jsontag) = "smart-nic,inline)"];
    repeated MirrorSession      StatusList = 2 [(gogoproto.jsontag) = "status-list,omitempty"];
}

message PacketAckDummy {
}

// trouble shooting controller - mirror api
service MirrorSessionApi {
    // options for auto generating rest endpoints
    option(venice.naplesRestService) = {
        Object: "MirrorSession",
        Method: ["get", "list", "post", "put", "delete"],
        Pattern: "/{ObjectMeta.Tenant}/{ObjectMeta.Namespace}/{ObjectMeta.Name}"
    };
    rpc WatchMirrorSessions (api.ObjectMeta) returns (stream MirrorSessionEventList) {};
    // client side streaming to receive mirror session status on agent
    // XXX change it simple rpc status update once we settle down on packet streaming vs minio from naples
    rpc GetMirrorSessionsStatus (stream MirrorSessionStatusList) returns (PacketAckDummy) {};
}
