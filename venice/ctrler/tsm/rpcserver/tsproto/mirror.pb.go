// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mirror.proto

/*
	Package tsproto is a generated protocol buffer package.

	Trouble shooting: Mirroring APIs

	It is generated from these files:
		mirror.proto

	It has these top-level messages:
		MirrorSessionSpec
		MirrorStopConditions
		MirrorCollector
		MatchSelector
		AppProtoSelector
		MatchRule
		MirrorSession
		MirrorSessionEvent
		MirrorSessionEventList
		MirrorSessionList
*/
package tsproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import api1 "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MirrorDir int32

const (
	MirrorDir_BOTH    MirrorDir = 0
	MirrorDir_INGRESS MirrorDir = 1
	MirrorDir_EGRESS  MirrorDir = 2
)

var MirrorDir_name = map[int32]string{
	0: "BOTH",
	1: "INGRESS",
	2: "EGRESS",
}
var MirrorDir_value = map[string]int32{
	"BOTH":    0,
	"INGRESS": 1,
	"EGRESS":  2,
}

func (x MirrorDir) String() string {
	return proto.EnumName(MirrorDir_name, int32(x))
}
func (MirrorDir) EnumDescriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

type MirrorSrcDst int32

const (
	MirrorSrcDst_SRC_DST MirrorSrcDst = 0
	MirrorSrcDst_SRC     MirrorSrcDst = 1
	MirrorSrcDst_DST     MirrorSrcDst = 2
)

var MirrorSrcDst_name = map[int32]string{
	0: "SRC_DST",
	1: "SRC",
	2: "DST",
}
var MirrorSrcDst_value = map[string]int32{
	"SRC_DST": 0,
	"SRC":     1,
	"DST":     2,
}

func (x MirrorSrcDst) String() string {
	return proto.EnumName(MirrorSrcDst_name, int32(x))
}
func (MirrorSrcDst) EnumDescriptor() ([]byte, []int) { return fileDescriptorMirror, []int{1} }

// Filter selected packets further - mirror only those packets that match atleast one of the PacketFilers
type MirrorSessionSpec_MirrorPacketFilter int32

const (
	MirrorSessionSpec_ALL_PKTS             MirrorSessionSpec_MirrorPacketFilter = 0
	MirrorSessionSpec_ALL_DROPS            MirrorSessionSpec_MirrorPacketFilter = 1
	MirrorSessionSpec_NETWORK_POLICY_DROP  MirrorSessionSpec_MirrorPacketFilter = 2
	MirrorSessionSpec_FIREWALL_POLICY_DROP MirrorSessionSpec_MirrorPacketFilter = 3
)

var MirrorSessionSpec_MirrorPacketFilter_name = map[int32]string{
	0: "ALL_PKTS",
	1: "ALL_DROPS",
	2: "NETWORK_POLICY_DROP",
	3: "FIREWALL_POLICY_DROP",
}
var MirrorSessionSpec_MirrorPacketFilter_value = map[string]int32{
	"ALL_PKTS":             0,
	"ALL_DROPS":            1,
	"NETWORK_POLICY_DROP":  2,
	"FIREWALL_POLICY_DROP": 3,
}

func (x MirrorSessionSpec_MirrorPacketFilter) String() string {
	return proto.EnumName(MirrorSessionSpec_MirrorPacketFilter_name, int32(x))
}
func (MirrorSessionSpec_MirrorPacketFilter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMirror, []int{0, 0}
}

type MirrorCollector_PacketCollectorType int32

const (
	MirrorCollector_VENICE MirrorCollector_PacketCollectorType = 0
	MirrorCollector_ERSPAN MirrorCollector_PacketCollectorType = 1
)

var MirrorCollector_PacketCollectorType_name = map[int32]string{
	0: "VENICE",
	1: "ERSPAN",
}
var MirrorCollector_PacketCollectorType_value = map[string]int32{
	"VENICE": 0,
	"ERSPAN": 1,
}

func (x MirrorCollector_PacketCollectorType) String() string {
	return proto.EnumName(MirrorCollector_PacketCollectorType_name, int32(x))
}
func (MirrorCollector_PacketCollectorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMirror, []int{2, 0}
}

// ========================================================================================
// Packet Mirroring
// ========================================================================================
// -----------------------
// ---- MirrorSessionSpec
// -----------------------
type MirrorSessionSpec struct {
	Enable bool `protobuf:"varint,1,opt,name=Enable,proto3" json:"enable"`
	// Original packets can be truncated when being mirrored to save bandwidth and storage
	// When mirrored packets are sent to Venice, default size is 128 (venice)??? or complete packet (erspan)?
	PacketSize     uint32               `protobuf:"varint,2,opt,name=PacketSize,proto3" json:"packet-size,omitempty"`
	StopConditions MirrorStopConditions `protobuf:"bytes,3,opt,name=StopConditions" json:"stop-condition,inline"`
	// Mirrored packet collectors
	Collectors []MirrorCollector `protobuf:"bytes,4,rep,name=Collectors" json:"collectors,inline"`
	// Traffic Selection Rules - Matching pakcets are mirrored, based on packet filters and start/stop conditions
	MatchRules []MatchRule `protobuf:"bytes,5,rep,name=MatchRules" json:"match-rules,inline"`
	// CaptureAt and PacketDirection for capturing
	// When Src and Dst is on the same NIC, only one mirror copy in each direction is made
	CaptureAt     MirrorSrcDst `protobuf:"varint,6,opt,name=CaptureAt,proto3,enum=tsproto.MirrorSrcDst" json:"capture-at,omitempty"`
	PacketDir     MirrorDir    `protobuf:"varint,7,opt,name=PacketDir,proto3,enum=tsproto.MirrorDir" json:"packet-direction,omitempty"`
	PacketFilters []string     `protobuf:"bytes,8,rep,name=PacketFilters" json:"packet-filters,omitempty"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

func (m *MirrorSessionSpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *MirrorSessionSpec) GetPacketSize() uint32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *MirrorSessionSpec) GetStopConditions() MirrorStopConditions {
	if m != nil {
		return m.StopConditions
	}
	return MirrorStopConditions{}
}

func (m *MirrorSessionSpec) GetCollectors() []MirrorCollector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

func (m *MirrorSessionSpec) GetMatchRules() []MatchRule {
	if m != nil {
		return m.MatchRules
	}
	return nil
}

func (m *MirrorSessionSpec) GetCaptureAt() MirrorSrcDst {
	if m != nil {
		return m.CaptureAt
	}
	return MirrorSrcDst_SRC_DST
}

func (m *MirrorSessionSpec) GetPacketDir() MirrorDir {
	if m != nil {
		return m.PacketDir
	}
	return MirrorDir_BOTH
}

func (m *MirrorSessionSpec) GetPacketFilters() []string {
	if m != nil {
		return m.PacketFilters
	}
	return nil
}

// A MirrorSession will stop mirroring after this condition is met
type MirrorStopConditions struct {
	// Stop after capturing specified number of packets
	MaxPacketCount uint32 `protobuf:"varint,1,opt,name=MaxPacketCount,proto3" json:"max-packets,omitempty"`
}

func (m *MirrorStopConditions) Reset()                    { *m = MirrorStopConditions{} }
func (m *MirrorStopConditions) String() string            { return proto.CompactTextString(m) }
func (*MirrorStopConditions) ProtoMessage()               {}
func (*MirrorStopConditions) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{1} }

func (m *MirrorStopConditions) GetMaxPacketCount() uint32 {
	if m != nil {
		return m.MaxPacketCount
	}
	return 0
}

// Mirror collector - can be an external device (via ERSPAN) or Venice (internal packet capture)
type MirrorCollector struct {
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Collector export information for ERSPAN. Not required for VENICE collector
	ExportCfg   api1.ExportConfig `protobuf:"bytes,2,opt,name=ExportCfg" json:"export-config,omitempty"`
	PcapDirName string            `protobuf:"bytes,3,opt,name=PcapDirName,proto3" json:"pcap-dir-name"`
}

func (m *MirrorCollector) Reset()                    { *m = MirrorCollector{} }
func (m *MirrorCollector) String() string            { return proto.CompactTextString(m) }
func (*MirrorCollector) ProtoMessage()               {}
func (*MirrorCollector) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{2} }

func (m *MirrorCollector) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MirrorCollector) GetExportCfg() api1.ExportConfig {
	if m != nil {
		return m.ExportCfg
	}
	return api1.ExportConfig{}
}

func (m *MirrorCollector) GetPcapDirName() string {
	if m != nil {
		return m.PcapDirName
	}
	return ""
}

// Traffic Selection Rules
// Traffic can be matched using EP names or IPv4/v6 addresses/ranges/prefixes or MAC addresses
type MatchSelector struct {
	// only one of the following match selector can be specified to select a packet from mirroring
	Endpoints []string `protobuf:"bytes,1,rep,name=Endpoints" json:"endpoints,omitempty"`
	// Each IPAddress can be single address(10.1.1.1)/range(10.1.1.10-20)/subnet(10.1.0.0/16)
	IPAddresses []string `protobuf:"bytes,2,rep,name=IPAddresses" json:"ip-addresses,omitempty"`
	// List of MacAddresses - "aa:bb:cc:dd:ee:ff", "00:01:02:03:04:05"
	MACAddresses []string `protobuf:"bytes,3,rep,name=MACAddresses" json:"mac-addresses,omitempty"`
}

func (m *MatchSelector) Reset()                    { *m = MatchSelector{} }
func (m *MatchSelector) String() string            { return proto.CompactTextString(m) }
func (*MatchSelector) ProtoMessage()               {}
func (*MatchSelector) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{3} }

func (m *MatchSelector) GetEndpoints() []string {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *MatchSelector) GetIPAddresses() []string {
	if m != nil {
		return m.IPAddresses
	}
	return nil
}

func (m *MatchSelector) GetMACAddresses() []string {
	if m != nil {
		return m.MACAddresses
	}
	return nil
}

// Application/protocol selector
type AppProtoSelector struct {
	// ports - Includes protocol name and port Eg ["tcp/1234", "udp"]
	Ports []string `protobuf:"bytes,1,rep,name=Ports" json:"ports,omitempty"`
	// Apps - E.g. ["Redis"]
	Apps []string `protobuf:"bytes,2,rep,name=Apps" json:"applications,omitempty"`
}

func (m *AppProtoSelector) Reset()                    { *m = AppProtoSelector{} }
func (m *AppProtoSelector) String() string            { return proto.CompactTextString(m) }
func (*AppProtoSelector) ProtoMessage()               {}
func (*AppProtoSelector) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{4} }

func (m *AppProtoSelector) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *AppProtoSelector) GetApps() []string {
	if m != nil {
		return m.Apps
	}
	return nil
}

// MatchRule : This is used to select packets that need to be monitored (mirrored)
type MatchRule struct {
	// Either Src or Dst or both must be specified, both cannot be *
	// Src = * when not specified
	// When Src is specified and resides on Pesnsando SmartNIC, matching pkts to/from src will be mirrored
	Src *MatchSelector `protobuf:"bytes,1,opt,name=Src" json:"source,omitempty"`
	// Dst = * when not specified
	// When Dst is specified and resides on Pesnsando SmartNIC, matching pkts to/from dst will be mirrored
	Dst *MatchSelector `protobuf:"bytes,2,opt,name=Dst" json:"destination,omitempty"`
	// App = * when not specified
	AppProtoSel *AppProtoSelector `protobuf:"bytes,3,opt,name=AppProtoSel" json:"app-protocol-selectors,omitempty"`
}

func (m *MatchRule) Reset()                    { *m = MatchRule{} }
func (m *MatchRule) String() string            { return proto.CompactTextString(m) }
func (*MatchRule) ProtoMessage()               {}
func (*MatchRule) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{5} }

func (m *MatchRule) GetSrc() *MatchSelector {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *MatchRule) GetDst() *MatchSelector {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *MatchRule) GetAppProtoSel() *AppProtoSelector {
	if m != nil {
		return m.AppProtoSel
	}
	return nil
}

type MirrorSession struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           MirrorSessionSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,inline"`
}

func (m *MirrorSession) Reset()                    { *m = MirrorSession{} }
func (m *MirrorSession) String() string            { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()               {}
func (*MirrorSession) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{6} }

func (m *MirrorSession) GetSpec() MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return MirrorSessionSpec{}
}

// mirror session crud event
type MirrorSessionEvent struct {
	EventType     api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	MirrorSession MirrorSession `protobuf:"bytes,2,opt,name=MirrorSession" json:"mirror-session,omitempty"`
}

func (m *MirrorSessionEvent) Reset()                    { *m = MirrorSessionEvent{} }
func (m *MirrorSessionEvent) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEvent) ProtoMessage()               {}
func (*MirrorSessionEvent) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{7} }

func (m *MirrorSessionEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *MirrorSessionEvent) GetMirrorSession() MirrorSession {
	if m != nil {
		return m.MirrorSession
	}
	return MirrorSession{}
}

type MirrorSessionEventList struct {
	MirrorSessionEvents []*MirrorSessionEvent `protobuf:"bytes,1,rep,name=mirrorSessionEvents" json:"mirrorSessionEvents,omitempty"`
}

func (m *MirrorSessionEventList) Reset()                    { *m = MirrorSessionEventList{} }
func (m *MirrorSessionEventList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEventList) ProtoMessage()               {}
func (*MirrorSessionEventList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{8} }

func (m *MirrorSessionEventList) GetMirrorSessionEvents() []*MirrorSessionEvent {
	if m != nil {
		return m.MirrorSessionEvents
	}
	return nil
}

type MirrorSessionList struct {
	MirrorSessions []*MirrorSession `protobuf:"bytes,1,rep,name=MirrorSessions" json:"mirror-sessions,omitempty"`
}

func (m *MirrorSessionList) Reset()                    { *m = MirrorSessionList{} }
func (m *MirrorSessionList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionList) ProtoMessage()               {}
func (*MirrorSessionList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{9} }

func (m *MirrorSessionList) GetMirrorSessions() []*MirrorSession {
	if m != nil {
		return m.MirrorSessions
	}
	return nil
}

func init() {
	proto.RegisterType((*MirrorSessionSpec)(nil), "tsproto.MirrorSessionSpec")
	proto.RegisterType((*MirrorStopConditions)(nil), "tsproto.MirrorStopConditions")
	proto.RegisterType((*MirrorCollector)(nil), "tsproto.MirrorCollector")
	proto.RegisterType((*MatchSelector)(nil), "tsproto.MatchSelector")
	proto.RegisterType((*AppProtoSelector)(nil), "tsproto.AppProtoSelector")
	proto.RegisterType((*MatchRule)(nil), "tsproto.MatchRule")
	proto.RegisterType((*MirrorSession)(nil), "tsproto.MirrorSession")
	proto.RegisterType((*MirrorSessionEvent)(nil), "tsproto.MirrorSessionEvent")
	proto.RegisterType((*MirrorSessionEventList)(nil), "tsproto.MirrorSessionEventList")
	proto.RegisterType((*MirrorSessionList)(nil), "tsproto.MirrorSessionList")
	proto.RegisterEnum("tsproto.MirrorDir", MirrorDir_name, MirrorDir_value)
	proto.RegisterEnum("tsproto.MirrorSrcDst", MirrorSrcDst_name, MirrorSrcDst_value)
	proto.RegisterEnum("tsproto.MirrorSessionSpec_MirrorPacketFilter", MirrorSessionSpec_MirrorPacketFilter_name, MirrorSessionSpec_MirrorPacketFilter_value)
	proto.RegisterEnum("tsproto.MirrorCollector_PacketCollectorType", MirrorCollector_PacketCollectorType_name, MirrorCollector_PacketCollectorType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MirrorSessionApi service

type MirrorSessionApiClient interface {
	WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApi_WatchMirrorSessionsClient, error)
}

type mirrorSessionApiClient struct {
	cc *grpc.ClientConn
}

func NewMirrorSessionApiClient(cc *grpc.ClientConn) MirrorSessionApiClient {
	return &mirrorSessionApiClient{cc}
}

func (c *mirrorSessionApiClient) WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApi_WatchMirrorSessionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MirrorSessionApi_serviceDesc.Streams[0], c.cc, "/tsproto.MirrorSessionApi/WatchMirrorSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorSessionApiWatchMirrorSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MirrorSessionApi_WatchMirrorSessionsClient interface {
	Recv() (*MirrorSessionEventList, error)
	grpc.ClientStream
}

type mirrorSessionApiWatchMirrorSessionsClient struct {
	grpc.ClientStream
}

func (x *mirrorSessionApiWatchMirrorSessionsClient) Recv() (*MirrorSessionEventList, error) {
	m := new(MirrorSessionEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MirrorSessionApi service

type MirrorSessionApiServer interface {
	WatchMirrorSessions(*api.ObjectMeta, MirrorSessionApi_WatchMirrorSessionsServer) error
}

func RegisterMirrorSessionApiServer(s *grpc.Server, srv MirrorSessionApiServer) {
	s.RegisterService(&_MirrorSessionApi_serviceDesc, srv)
}

func _MirrorSessionApi_WatchMirrorSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorSessionApiServer).WatchMirrorSessions(m, &mirrorSessionApiWatchMirrorSessionsServer{stream})
}

type MirrorSessionApi_WatchMirrorSessionsServer interface {
	Send(*MirrorSessionEventList) error
	grpc.ServerStream
}

type mirrorSessionApiWatchMirrorSessionsServer struct {
	grpc.ServerStream
}

func (x *mirrorSessionApiWatchMirrorSessionsServer) Send(m *MirrorSessionEventList) error {
	return x.ServerStream.SendMsg(m)
}

var _MirrorSessionApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tsproto.MirrorSessionApi",
	HandlerType: (*MirrorSessionApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchMirrorSessions",
			Handler:       _MirrorSessionApi_WatchMirrorSessions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mirror.proto",
}

func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enable {
		dAtA[i] = 0x8
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PacketSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketSize))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.StopConditions.Size()))
	n1, err := m.StopConditions.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Collectors) > 0 {
		for _, msg := range m.Collectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchRules) > 0 {
		for _, msg := range m.MatchRules {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CaptureAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.CaptureAt))
	}
	if m.PacketDir != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketDir))
	}
	if len(m.PacketFilters) > 0 {
		for _, s := range m.PacketFilters {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MirrorStopConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorStopConditions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxPacketCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MaxPacketCount))
	}
	return i, nil
}

func (m *MirrorCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorCollector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ExportCfg.Size()))
	n2, err := m.ExportCfg.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.PcapDirName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.PcapDirName)))
		i += copy(dAtA[i:], m.PcapDirName)
	}
	return i, nil
}

func (m *MatchSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IPAddresses) > 0 {
		for _, s := range m.IPAddresses {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MACAddresses) > 0 {
		for _, s := range m.MACAddresses {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AppProtoSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppProtoSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MatchRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Src != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.Src.Size()))
		n3, err := m.Src.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Dst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.Dst.Size()))
		n4, err := m.Dst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.AppProtoSel != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.AppProtoSel.Size()))
		n5, err := m.AppProtoSel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *MirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *MirrorSessionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSession.Size()))
	n9, err := m.MirrorSession.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *MirrorSessionEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, msg := range m.MirrorSessionEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, msg := range m.MirrorSessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintMirror(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	if m.PacketSize != 0 {
		n += 1 + sovMirror(uint64(m.PacketSize))
	}
	l = m.StopConditions.Size()
	n += 1 + l + sovMirror(uint64(l))
	if len(m.Collectors) > 0 {
		for _, e := range m.Collectors {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.MatchRules) > 0 {
		for _, e := range m.MatchRules {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.CaptureAt != 0 {
		n += 1 + sovMirror(uint64(m.CaptureAt))
	}
	if m.PacketDir != 0 {
		n += 1 + sovMirror(uint64(m.PacketDir))
	}
	if len(m.PacketFilters) > 0 {
		for _, s := range m.PacketFilters {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorStopConditions) Size() (n int) {
	var l int
	_ = l
	if m.MaxPacketCount != 0 {
		n += 1 + sovMirror(uint64(m.MaxPacketCount))
	}
	return n
}

func (m *MirrorCollector) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = m.ExportCfg.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = len(m.PcapDirName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MatchSelector) Size() (n int) {
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.IPAddresses) > 0 {
		for _, s := range m.IPAddresses {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.MACAddresses) > 0 {
		for _, s := range m.MACAddresses {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *AppProtoSelector) Size() (n int) {
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			l = len(s)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MatchRule) Size() (n int) {
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.AppProtoSel != nil {
		l = m.AppProtoSel.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorSession) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *MirrorSessionEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovMirror(uint64(m.EventType))
	}
	l = m.MirrorSession.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *MirrorSessionEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, e := range m.MirrorSessionEvents {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, e := range m.MirrorSessions {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func sovMirror(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMirror(x uint64) (n int) {
	return sovMirror(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StopConditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectors = append(m.Collectors, MirrorCollector{})
			if err := m.Collectors[len(m.Collectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRules = append(m.MatchRules, MatchRule{})
			if err := m.MatchRules[len(m.MatchRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureAt", wireType)
			}
			m.CaptureAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptureAt |= (MirrorSrcDst(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketDir", wireType)
			}
			m.PacketDir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketDir |= (MirrorDir(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PacketFilters = append(m.PacketFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorStopConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorStopConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorStopConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPacketCount", wireType)
			}
			m.MaxPacketCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPacketCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportCfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExportCfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcapDirName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PcapDirName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddresses = append(m.IPAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddresses = append(m.MACAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppProtoSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppProtoSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppProtoSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &MatchSelector{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &MatchSelector{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProtoSel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppProtoSel == nil {
				m.AppProtoSel = &AppProtoSelector{}
			}
			if err := m.AppProtoSel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MirrorSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessionEvents = append(m.MirrorSessionEvents, &MirrorSessionEvent{})
			if err := m.MirrorSessionEvents[len(m.MirrorSessionEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessions = append(m.MirrorSessions, &MirrorSession{})
			if err := m.MirrorSessions[len(m.MirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMirror(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMirror
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMirror(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMirror = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMirror   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mirror.proto", fileDescriptorMirror) }

var fileDescriptorMirror = []byte{
	// 1346 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0x4f, 0x8f, 0xda, 0x46,
	0x14, 0xc7, 0x0b, 0x61, 0x97, 0x61, 0x97, 0xb0, 0xc3, 0x26, 0x31, 0xa4, 0x59, 0x23, 0xab, 0x55,
	0x49, 0x14, 0x43, 0x4a, 0xda, 0x43, 0xa4, 0xfe, 0x11, 0x06, 0xd2, 0xae, 0xb2, 0x2c, 0x08, 0xa3,
	0x44, 0x39, 0xb4, 0x91, 0xd7, 0xcc, 0x92, 0x69, 0x8d, 0x3d, 0xb2, 0x87, 0x34, 0x49, 0x95, 0x53,
	0xa5, 0xfd, 0x0c, 0xbd, 0xf5, 0x5a, 0xed, 0xb1, 0xe7, 0x5e, 0x7a, 0xa8, 0x94, 0x63, 0xfa, 0x05,
	0xac, 0x2a, 0xbd, 0x71, 0xed, 0x17, 0xa8, 0x66, 0x6c, 0xc3, 0xd8, 0xbb, 0xc9, 0xcd, 0xf3, 0xe6,
	0xfd, 0x7e, 0xbf, 0x37, 0x6f, 0xde, 0x7b, 0x63, 0xb0, 0x3d, 0xc7, 0x9e, 0xe7, 0x7a, 0x4d, 0xe2,
	0xb9, 0xd4, 0x85, 0x9b, 0xd4, 0xe7, 0x1f, 0xb5, 0x0f, 0x66, 0xae, 0x3b, 0xb3, 0x51, 0xcb, 0x24,
	0xb8, 0x65, 0x3a, 0x8e, 0x4b, 0x4d, 0x8a, 0x5d, 0xc7, 0x0f, 0xdd, 0x6a, 0xfd, 0x19, 0xa6, 0x4f,
	0x17, 0xc7, 0x4d, 0xcb, 0x9d, 0xb7, 0x08, 0x72, 0x7c, 0xd3, 0x99, 0xba, 0x2d, 0xff, 0xc7, 0xd6,
	0x33, 0xe4, 0x60, 0x0b, 0xb5, 0x16, 0x14, 0xdb, 0x3e, 0x83, 0xce, 0x90, 0x23, 0xa2, 0x5b, 0xd8,
	0xb1, 0xec, 0xc5, 0x14, 0xc5, 0x34, 0x9a, 0x40, 0x33, 0x73, 0x67, 0x6e, 0x8b, 0x9b, 0x8f, 0x17,
	0x27, 0x7c, 0xc5, 0x17, 0xfc, 0x2b, 0x72, 0xff, 0xe8, 0x1d, 0xaa, 0x2c, 0xc6, 0x39, 0xa2, 0x66,
	0xe4, 0xf6, 0xf1, 0x7b, 0xdc, 0xd0, 0x73, 0xe2, 0x7a, 0x34, 0x74, 0x54, 0x7f, 0xcb, 0x83, 0xdd,
	0x01, 0x3f, 0xbd, 0x81, 0x7c, 0x1f, 0xbb, 0x8e, 0x41, 0x90, 0x05, 0x55, 0x90, 0xef, 0x3b, 0xe6,
	0xb1, 0x8d, 0x64, 0xa9, 0x2e, 0x35, 0xb6, 0x74, 0xb0, 0x0c, 0x94, 0x3c, 0xe2, 0x96, 0x71, 0xb4,
	0x03, 0xef, 0x01, 0x30, 0x32, 0xad, 0x1f, 0x10, 0x35, 0xf0, 0x4b, 0x24, 0x6f, 0xd4, 0xa5, 0xc6,
	0x8e, 0x5e, 0x5d, 0x06, 0xca, 0x15, 0xc2, 0xad, 0x9a, 0x8f, 0x5f, 0xa2, 0xdb, 0xee, 0x1c, 0x53,
	0x34, 0x27, 0xf4, 0xc5, 0x58, 0x70, 0x86, 0x53, 0x50, 0x32, 0xa8, 0x4b, 0xba, 0xae, 0x33, 0xc5,
	0x3c, 0x29, 0x72, 0xb6, 0x2e, 0x35, 0x8a, 0xed, 0x1b, 0xcd, 0x28, 0xf5, 0xcd, 0x28, 0xa4, 0x84,
	0x93, 0x7e, 0xe3, 0x75, 0xa0, 0x64, 0x98, 0x82, 0x4f, 0x5d, 0xa2, 0x59, 0xf1, 0xc6, 0x6d, 0xec,
	0xd8, 0xd8, 0x41, 0xe3, 0x14, 0x27, 0x34, 0x00, 0xe8, 0xba, 0xb6, 0x8d, 0x2c, 0xea, 0x7a, 0xbe,
	0x9c, 0xab, 0x67, 0x1b, 0xc5, 0xb6, 0x9c, 0x52, 0x58, 0x39, 0xe8, 0xd5, 0x88, 0x7c, 0xd7, 0x5a,
	0x61, 0x62, 0x62, 0x81, 0x06, 0x1e, 0x01, 0x30, 0x30, 0xa9, 0xf5, 0x74, 0xbc, 0xb0, 0x91, 0x2f,
	0x5f, 0xe2, 0xa4, 0x70, 0x4d, 0x1a, 0x6f, 0xe9, 0xb5, 0x88, 0x0e, 0xce, 0x99, 0x49, 0xf3, 0x98,
	0xfb, 0x8a, 0x6f, 0xcd, 0x00, 0x4f, 0x40, 0xa1, 0x6b, 0x12, 0xba, 0xf0, 0x50, 0x87, 0xca, 0xf9,
	0xba, 0xd4, 0x28, 0xb5, 0xaf, 0xa4, 0xb3, 0xe0, 0x59, 0x3d, 0x9f, 0xea, 0x9f, 0x9c, 0x9d, 0x56,
	0xaf, 0x18, 0xd4, 0xeb, 0x3b, 0x8b, 0x79, 0x43, 0xdc, 0xb9, 0xb9, 0x0c, 0x94, 0x3d, 0x2b, 0x24,
	0xd1, 0x4c, 0x2a, 0xe4, 0x7c, 0x4d, 0xcd, 0x74, 0xc2, 0x0b, 0xe8, 0x61, 0x4f, 0xde, 0xe4, 0x3a,
	0x30, 0xa5, 0xd3, 0xc3, 0x9e, 0xfe, 0xe9, 0xd9, 0x69, 0x15, 0x26, 0x45, 0x7a, 0xd8, 0x63, 0x0a,
	0xb5, 0xe8, 0x5a, 0xa7, 0xd8, 0x43, 0x16, 0x4f, 0xbb, 0xa0, 0xb3, 0xa2, 0x86, 0x3e, 0xd8, 0x09,
	0x17, 0xf7, 0xb1, 0x4d, 0x91, 0xe7, 0xcb, 0x5b, 0xf5, 0x6c, 0xa3, 0xa0, 0x0f, 0xce, 0x4e, 0xab,
	0x5a, 0x2a, 0xf8, 0x75, 0xbd, 0x45, 0x01, 0x88, 0x40, 0x26, 0x29, 0x47, 0x92, 0x27, 0x21, 0x95,
	0x20, 0x98, 0xd4, 0x50, 0xa7, 0x00, 0x9e, 0x67, 0x80, 0xdb, 0x60, 0xab, 0x73, 0x78, 0xf8, 0x64,
	0xf4, 0x60, 0x62, 0x94, 0x33, 0x70, 0x07, 0x14, 0xd8, 0xaa, 0x37, 0x1e, 0x8e, 0x8c, 0xb2, 0x04,
	0xaf, 0x81, 0xca, 0x51, 0x7f, 0xf2, 0x68, 0x38, 0x7e, 0xf0, 0x64, 0x34, 0x3c, 0x3c, 0xe8, 0x3e,
	0xe6, 0x3b, 0xe5, 0x0d, 0x28, 0x83, 0xbd, 0xfb, 0x07, 0xe3, 0xfe, 0x23, 0x0e, 0x15, 0x76, 0xb2,
	0xea, 0x63, 0xb0, 0x77, 0x51, 0x59, 0xc2, 0x0e, 0x28, 0x0d, 0xcc, 0xe7, 0xa1, 0x74, 0xd7, 0x5d,
	0x38, 0x94, 0x37, 0x4d, 0xd4, 0x0c, 0x73, 0xf3, 0xb9, 0x16, 0x1e, 0x43, 0x8c, 0x3f, 0x05, 0x50,
	0x7f, 0xdd, 0x00, 0x97, 0x53, 0x05, 0x09, 0x1f, 0x82, 0xdc, 0xe4, 0x05, 0x09, 0x3b, 0xb0, 0xa0,
	0xeb, 0x67, 0xa7, 0xd5, 0xdb, 0xc9, 0x04, 0xae, 0x5c, 0x9b, 0x31, 0x55, 0xb4, 0x66, 0x30, 0x96,
	0xbf, 0x12, 0x7d, 0x41, 0xc4, 0x16, 0xe4, 0x7c, 0x70, 0x04, 0x0a, 0x7d, 0x3e, 0x01, 0xba, 0x27,
	0x33, 0xde, 0xb6, 0xc5, 0xf6, 0x6e, 0xd3, 0x24, 0xb8, 0x19, 0x59, 0x5d, 0xe7, 0x04, 0xcf, 0x74,
	0x25, 0xaa, 0xdf, 0x6b, 0xe1, 0xb4, 0x60, 0xdd, 0x76, 0x82, 0x67, 0xe2, 0x9d, 0xaf, 0x48, 0xe0,
	0x5d, 0x50, 0x1c, 0x59, 0x26, 0xe9, 0x61, 0xef, 0xc8, 0x9c, 0x23, 0xde, 0xcb, 0x05, 0x7d, 0x77,
	0x19, 0x28, 0x3b, 0xc4, 0x32, 0x09, 0xab, 0x18, 0xcd, 0x31, 0xe7, 0x68, 0x2c, 0x7a, 0xa9, 0x1a,
	0xa8, 0x5c, 0x10, 0x36, 0x04, 0x20, 0xff, 0xb0, 0x7f, 0x74, 0xd0, 0xed, 0x97, 0x33, 0xec, 0xbb,
	0x3f, 0x36, 0x46, 0x9d, 0xa3, 0xb2, 0xa4, 0xfe, 0x25, 0x81, 0x1d, 0xde, 0x36, 0x06, 0x8a, 0xf2,
	0xf3, 0x19, 0x28, 0xf4, 0x9d, 0x29, 0x71, 0xb1, 0x43, 0x7d, 0x59, 0xe2, 0x55, 0x76, 0x6d, 0x19,
	0x28, 0x15, 0x14, 0x1b, 0x13, 0xc1, 0xc6, 0x46, 0xf8, 0x39, 0x28, 0x1e, 0x8c, 0x3a, 0xd3, 0xa9,
	0x87, 0x7c, 0x1f, 0xf9, 0xf2, 0x06, 0x07, 0xd6, 0x96, 0x81, 0x72, 0x15, 0x13, 0xcd, 0x8c, 0xed,
	0x02, 0x56, 0x74, 0x87, 0x5f, 0x81, 0xed, 0x41, 0xa7, 0xbb, 0x86, 0x67, 0x39, 0xfc, 0x3a, 0x4b,
	0xd4, 0xdc, 0xb4, 0x2e, 0xc4, 0x27, 0x00, 0xea, 0x1c, 0x94, 0x3b, 0x84, 0x8c, 0x58, 0xdb, 0xad,
	0x4e, 0x72, 0x13, 0x5c, 0x1a, 0xb9, 0xde, 0xea, 0x14, 0x95, 0x65, 0xa0, 0x5c, 0x66, 0xb9, 0x15,
	0x59, 0x42, 0x0f, 0xd8, 0x04, 0xb9, 0x0e, 0x21, 0x89, 0xb0, 0x4d, 0x42, 0x6c, 0x6c, 0x85, 0x8f,
	0x8b, 0x78, 0xd9, 0xcc, 0x4f, 0xfd, 0x4f, 0x02, 0x85, 0xd5, 0xb4, 0x81, 0x5f, 0x82, 0xac, 0xe1,
	0x59, 0xbc, 0xa2, 0x8a, 0xed, 0xab, 0xc9, 0xa9, 0x15, 0x47, 0xa3, 0xef, 0x2d, 0x03, 0xa5, 0xec,
	0xbb, 0x0b, 0xcf, 0x12, 0x6b, 0x87, 0x01, 0x61, 0x17, 0x64, 0x7b, 0x3e, 0x8d, 0x8a, 0xe6, 0x5d,
	0x78, 0x5e, 0xf6, 0x53, 0xe4, 0x53, 0xec, 0x98, 0xa9, 0x39, 0xc1, 0xd0, 0xd0, 0x04, 0x45, 0x21,
	0x03, 0xd1, 0xe4, 0xaf, 0xae, 0xc8, 0xd2, 0xd9, 0xd1, 0x3f, 0x5c, 0x06, 0x4a, 0xdd, 0x24, 0x44,
	0xe3, 0xfb, 0x96, 0x6b, 0x6b, 0x3e, 0x8a, 0x07, 0xb4, 0x70, 0x4b, 0x02, 0x4e, 0xfd, 0x93, 0x15,
	0x8b, 0x38, 0x64, 0xe0, 0x1d, 0x20, 0x4d, 0xa2, 0x73, 0xef, 0xf0, 0x62, 0x67, 0xc5, 0x36, 0x40,
	0xd4, 0xd4, 0x2b, 0xac, 0xd0, 0xdf, 0x04, 0x8a, 0xb4, 0x0c, 0x94, 0xcd, 0x78, 0x42, 0x4b, 0x13,
	0x78, 0x0f, 0x48, 0xc3, 0xe8, 0xa4, 0x97, 0x39, 0x62, 0x78, 0xfc, 0x3d, 0xb2, 0x28, 0xc7, 0xd4,
	0x04, 0x4c, 0x89, 0xbd, 0xba, 0x42, 0x20, 0xd2, 0x10, 0x76, 0x41, 0x8e, 0x4d, 0xb5, 0xe8, 0x68,
	0xb5, 0xf4, 0x38, 0x5f, 0xcf, 0xbd, 0x50, 0x7c, 0x19, 0x28, 0x45, 0x9f, 0x20, 0x2b, 0x16, 0xe7,
	0x60, 0xf5, 0x0f, 0x29, 0x1e, 0x6a, 0x11, 0xa0, 0xff, 0x0c, 0x39, 0x14, 0xde, 0x07, 0x05, 0xfe,
	0xb1, 0x1a, 0x0d, 0xa5, 0x76, 0x29, 0xec, 0xde, 0xd8, 0xaa, 0xcb, 0xec, 0x3d, 0x40, 0x6c, 0xa9,
	0xa5, 0x06, 0xc0, 0x1a, 0x0a, 0xbf, 0x4b, 0x65, 0xe8, 0xfc, 0xa5, 0x8a, 0xbb, 0x7a, 0x3d, 0x0a,
	0x54, 0x0e, 0xff, 0x94, 0x34, 0x3f, 0xb4, 0x8b, 0x23, 0x39, 0x01, 0x50, 0x67, 0xe0, 0xea, 0xf9,
	0xe8, 0x0f, 0xb1, 0x4f, 0xe1, 0x00, 0x54, 0xe6, 0xe7, 0x76, 0xc2, 0xda, 0x2f, 0xb6, 0xaf, 0x5f,
	0xac, 0xcf, 0x7d, 0xc6, 0x17, 0xe1, 0x54, 0x2f, 0xf5, 0xff, 0xc2, 0x35, 0xbe, 0x05, 0xa5, 0x84,
	0x31, 0xa6, 0x7f, 0xd7, 0xf1, 0x6e, 0x2c, 0x03, 0xa5, 0x9a, 0x3c, 0x5a, 0x72, 0x5c, 0x27, 0xc8,
	0x6e, 0x35, 0x41, 0x61, 0xf5, 0x36, 0xc2, 0x2d, 0x90, 0xd3, 0x87, 0x93, 0x6f, 0xca, 0x19, 0x58,
	0x04, 0x9b, 0x07, 0x47, 0x5f, 0x8f, 0xfb, 0x06, 0x7b, 0x60, 0xd8, 0xf0, 0x0a, 0xbf, 0x37, 0x6e,
	0x69, 0x60, 0x5b, 0x7c, 0xb0, 0x99, 0xa3, 0x31, 0xee, 0x3e, 0xe9, 0x19, 0x93, 0x72, 0x06, 0x6e,
	0x82, 0xac, 0x31, 0xee, 0x96, 0x25, 0xf6, 0xc1, 0x2c, 0x1b, 0xed, 0xbf, 0x25, 0x50, 0x4e, 0x28,
	0x76, 0x08, 0x86, 0x0f, 0x40, 0xe5, 0x11, 0xeb, 0xb3, 0x64, 0x28, 0x30, 0x5d, 0x9b, 0x35, 0xe5,
	0x3d, 0x19, 0x64, 0xb9, 0x51, 0x33, 0x77, 0xa4, 0x1a, 0xf9, 0xfd, 0xe7, 0xaa, 0x9d, 0xee, 0x91,
	0xec, 0x0c, 0x51, 0x98, 0xb3, 0x59, 0xfe, 0x72, 0xc4, 0xf5, 0x29, 0xcc, 0x92, 0x05, 0x85, 0xf9,
	0x29, 0xb2, 0x11, 0x45, 0xb5, 0x2f, 0x5a, 0x3f, 0xad, 0x55, 0x9a, 0x13, 0xe4, 0x98, 0x0e, 0x7d,
	0x95, 0xb0, 0xb1, 0xb1, 0xee, 0x13, 0xd3, 0x42, 0xe7, 0xcd, 0xaf, 0xf4, 0xf2, 0xeb, 0xb7, 0xfb,
	0xd2, 0x9b, 0xb7, 0xfb, 0xd2, 0x3f, 0x6f, 0xf7, 0xa5, 0x5f, 0xfe, 0xdd, 0xcf, 0x8c, 0xa4, 0xe3,
	0x3c, 0x8f, 0xf3, 0xee, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x0a, 0x23, 0xfe, 0x2a, 0x7f, 0x0b,
	0x00, 0x00,
}
