// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: techsup_config.proto

/*
	Package techsupport is a generated protocol buffer package.

	It is generated from these files:
		techsup_config.proto

	It has these top-level messages:
		ActionItem
		TechSupportConfig
*/
package techsupport

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ActionItem_ActionMethod int32

const (
	ActionItem_ShellCmd    ActionItem_ActionMethod = 0
	ActionItem_DelphiObj   ActionItem_ActionMethod = 1
	ActionItem_RESTCall    ActionItem_ActionMethod = 2
	ActionItem_CollectFile ActionItem_ActionMethod = 3
)

var ActionItem_ActionMethod_name = map[int32]string{
	0: "ShellCmd",
	1: "DelphiObj",
	2: "RESTCall",
	3: "CollectFile",
}
var ActionItem_ActionMethod_value = map[string]int32{
	"ShellCmd":    0,
	"DelphiObj":   1,
	"RESTCall":    2,
	"CollectFile": 3,
}

func (x ActionItem_ActionMethod) String() string {
	return proto.EnumName(ActionItem_ActionMethod_name, int32(x))
}
func (ActionItem_ActionMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTechsupConfig, []int{0, 0}
}

type TechSupportConfig_RetentionPolicy int32

const (
	TechSupportConfig_DelOnExport TechSupportConfig_RetentionPolicy = 0
	TechSupportConfig_Manual      TechSupportConfig_RetentionPolicy = 1
)

var TechSupportConfig_RetentionPolicy_name = map[int32]string{
	0: "DelOnExport",
	1: "Manual",
}
var TechSupportConfig_RetentionPolicy_value = map[string]int32{
	"DelOnExport": 0,
	"Manual":      1,
}

func (x TechSupportConfig_RetentionPolicy) String() string {
	return proto.EnumName(TechSupportConfig_RetentionPolicy_name, int32(x))
}
func (TechSupportConfig_RetentionPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTechsupConfig, []int{1, 0}
}

// ActionItem defines a action to be performed for tech support
type ActionItem struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Method defines the kind of action to be taken for this entry
	Method ActionItem_ActionMethod `protobuf:"varint,2,opt,name=Method,proto3,enum=techsupport.ActionItem_ActionMethod" json:"Method,omitempty"`
	// Labels associated with this item. These labels are used to match against the selector specified
	//  in the tech support collection request.
	Labels []string `protobuf:"bytes,3,rep,name=Labels" json:"Labels,omitempty"`
	// Actions are selected for execution depending on the verbosity level specified in the techsupport
	//  collection request. This is the Minimum verbosity level at which this action will be selected
	MinVerbosity int32 `protobuf:"varint,4,opt,name=MinVerbosity,proto3" json:"MinVerbosity,omitempty"`
	// All actions are executed in parallel except if the Group parameter is not empty. In that case
	//  actions with the same Group specified are executed sequentially in the order they are specified.
	Group string `protobuf:"bytes,5,opt,name=Group,proto3" json:"Group,omitempty"`
	// Command to execute. This specifies the shell command to execute when method is ShellCmd, URI when
	//  method is RESTCall and unused for other methods.
	Command string `protobuf:"bytes,6,opt,name=Command,proto3" json:"Command,omitempty"`
	// Arguments needed to execute this action. The format of the arguments is specific to the method
	//  specified.
	Arguments []string `protobuf:"bytes,7,rep,name=Arguments" json:"Arguments,omitempty"`
	// Number of retries when action fails
	Retries int32 `protobuf:"varint,8,opt,name=Retries,proto3" json:"Retries,omitempty"`
	// Execution of the action will allow for Timeout interval specified. If the action does not
	//  complete within the specified interval then the action is deemed as failed. Value is specified
	//  as a duration string. Eg. 10s, 2m
	Timeout string `protobuf:"bytes,9,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	// Default is 0, but when a non-zero value is specified, this action will be repeated
	//  specified number of times.
	RepeatCnt int32 `protobuf:"varint,10,opt,name=RepeatCnt,proto3" json:"RepeatCnt,omitempty"`
	// This parameter is used in conjunction with the RepeatCnt parameter. This specifies the time interval
	//  between repeated executions of this action. Value is specified as a duration string. Eg. 10s, 2m
	RepeatIntvl string `protobuf:"bytes,11,opt,name=RepeatIntvl,proto3" json:"RepeatIntvl,omitempty"`
}

func (m *ActionItem) Reset()                    { *m = ActionItem{} }
func (m *ActionItem) String() string            { return proto.CompactTextString(m) }
func (*ActionItem) ProtoMessage()               {}
func (*ActionItem) Descriptor() ([]byte, []int) { return fileDescriptorTechsupConfig, []int{0} }

func (m *ActionItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActionItem) GetMethod() ActionItem_ActionMethod {
	if m != nil {
		return m.Method
	}
	return ActionItem_ShellCmd
}

func (m *ActionItem) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ActionItem) GetMinVerbosity() int32 {
	if m != nil {
		return m.MinVerbosity
	}
	return 0
}

func (m *ActionItem) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ActionItem) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *ActionItem) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *ActionItem) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *ActionItem) GetTimeout() string {
	if m != nil {
		return m.Timeout
	}
	return ""
}

func (m *ActionItem) GetRepeatCnt() int32 {
	if m != nil {
		return m.RepeatCnt
	}
	return 0
}

func (m *ActionItem) GetRepeatIntvl() string {
	if m != nil {
		return m.RepeatIntvl
	}
	return ""
}

type TechSupportConfig struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Filesystem root where all tech support collected files will be saved
	FileSystemRoot string `protobuf:"bytes,2,opt,name=FileSystemRoot,proto3" json:"FileSystemRoot,omitempty"`
	// REST URI to listen at. If empty REST Service is not started
	RESTUri string `protobuf:"bytes,4,opt,name=RESTUri,proto3" json:"RESTUri,omitempty"`
	// gRPC port to run the gRPC service. If empty gRPC service is not started
	GRPCPort       string                            `protobuf:"bytes,5,opt,name=GRPCPort,proto3" json:"GRPCPort,omitempty"`
	Retention      TechSupportConfig_RetentionPolicy `protobuf:"varint,6,opt,name=Retention,proto3,enum=techsupport.TechSupportConfig_RetentionPolicy" json:"Retention,omitempty"`
	DefaultTimeout string                            `protobuf:"bytes,7,opt,name=DefaultTimeout,proto3" json:"DefaultTimeout,omitempty"`
	DefaultRetries int32                             `protobuf:"varint,8,opt,name=DefaultRetries,proto3" json:"DefaultRetries,omitempty"`
	// PrepActions are actions for Prep phase
	PrepActions []*ActionItem `protobuf:"bytes,9,rep,name=PrepActions" json:"PrepActions,omitempty"`
	// CollectActions are actions for Collection phase
	CollectActions []*ActionItem `protobuf:"bytes,10,rep,name=CollectActions" json:"CollectActions,omitempty"`
	// ExportActions are actions for Export phase
	ExportActions []*ActionItem `protobuf:"bytes,11,rep,name=ExportActions" json:"ExportActions,omitempty"`
}

func (m *TechSupportConfig) Reset()                    { *m = TechSupportConfig{} }
func (m *TechSupportConfig) String() string            { return proto.CompactTextString(m) }
func (*TechSupportConfig) ProtoMessage()               {}
func (*TechSupportConfig) Descriptor() ([]byte, []int) { return fileDescriptorTechsupConfig, []int{1} }

func (m *TechSupportConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TechSupportConfig) GetFileSystemRoot() string {
	if m != nil {
		return m.FileSystemRoot
	}
	return ""
}

func (m *TechSupportConfig) GetRESTUri() string {
	if m != nil {
		return m.RESTUri
	}
	return ""
}

func (m *TechSupportConfig) GetGRPCPort() string {
	if m != nil {
		return m.GRPCPort
	}
	return ""
}

func (m *TechSupportConfig) GetRetention() TechSupportConfig_RetentionPolicy {
	if m != nil {
		return m.Retention
	}
	return TechSupportConfig_DelOnExport
}

func (m *TechSupportConfig) GetDefaultTimeout() string {
	if m != nil {
		return m.DefaultTimeout
	}
	return ""
}

func (m *TechSupportConfig) GetDefaultRetries() int32 {
	if m != nil {
		return m.DefaultRetries
	}
	return 0
}

func (m *TechSupportConfig) GetPrepActions() []*ActionItem {
	if m != nil {
		return m.PrepActions
	}
	return nil
}

func (m *TechSupportConfig) GetCollectActions() []*ActionItem {
	if m != nil {
		return m.CollectActions
	}
	return nil
}

func (m *TechSupportConfig) GetExportActions() []*ActionItem {
	if m != nil {
		return m.ExportActions
	}
	return nil
}

func init() {
	proto.RegisterType((*ActionItem)(nil), "techsupport.ActionItem")
	proto.RegisterType((*TechSupportConfig)(nil), "techsupport.TechSupportConfig")
	proto.RegisterEnum("techsupport.ActionItem_ActionMethod", ActionItem_ActionMethod_name, ActionItem_ActionMethod_value)
	proto.RegisterEnum("techsupport.TechSupportConfig_RetentionPolicy", TechSupportConfig_RetentionPolicy_name, TechSupportConfig_RetentionPolicy_value)
}
func (m *ActionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Method != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.Method))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.MinVerbosity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.MinVerbosity))
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if len(m.Command) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Retries != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.Retries))
	}
	if len(m.Timeout) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.Timeout)))
		i += copy(dAtA[i:], m.Timeout)
	}
	if m.RepeatCnt != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.RepeatCnt))
	}
	if len(m.RepeatIntvl) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.RepeatIntvl)))
		i += copy(dAtA[i:], m.RepeatIntvl)
	}
	return i, nil
}

func (m *TechSupportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.FileSystemRoot) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.FileSystemRoot)))
		i += copy(dAtA[i:], m.FileSystemRoot)
	}
	if len(m.RESTUri) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.RESTUri)))
		i += copy(dAtA[i:], m.RESTUri)
	}
	if len(m.GRPCPort) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.GRPCPort)))
		i += copy(dAtA[i:], m.GRPCPort)
	}
	if m.Retention != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.Retention))
	}
	if len(m.DefaultTimeout) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(len(m.DefaultTimeout)))
		i += copy(dAtA[i:], m.DefaultTimeout)
	}
	if m.DefaultRetries != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTechsupConfig(dAtA, i, uint64(m.DefaultRetries))
	}
	if len(m.PrepActions) > 0 {
		for _, msg := range m.PrepActions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTechsupConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CollectActions) > 0 {
		for _, msg := range m.CollectActions {
			dAtA[i] = 0x52
			i++
			i = encodeVarintTechsupConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExportActions) > 0 {
		for _, msg := range m.ExportActions {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTechsupConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTechsupConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ActionItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovTechsupConfig(uint64(m.Method))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovTechsupConfig(uint64(l))
		}
	}
	if m.MinVerbosity != 0 {
		n += 1 + sovTechsupConfig(uint64(m.MinVerbosity))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			l = len(s)
			n += 1 + l + sovTechsupConfig(uint64(l))
		}
	}
	if m.Retries != 0 {
		n += 1 + sovTechsupConfig(uint64(m.Retries))
	}
	l = len(m.Timeout)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	if m.RepeatCnt != 0 {
		n += 1 + sovTechsupConfig(uint64(m.RepeatCnt))
	}
	l = len(m.RepeatIntvl)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	return n
}

func (m *TechSupportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	l = len(m.FileSystemRoot)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	l = len(m.RESTUri)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	l = len(m.GRPCPort)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	if m.Retention != 0 {
		n += 1 + sovTechsupConfig(uint64(m.Retention))
	}
	l = len(m.DefaultTimeout)
	if l > 0 {
		n += 1 + l + sovTechsupConfig(uint64(l))
	}
	if m.DefaultRetries != 0 {
		n += 1 + sovTechsupConfig(uint64(m.DefaultRetries))
	}
	if len(m.PrepActions) > 0 {
		for _, e := range m.PrepActions {
			l = e.Size()
			n += 1 + l + sovTechsupConfig(uint64(l))
		}
	}
	if len(m.CollectActions) > 0 {
		for _, e := range m.CollectActions {
			l = e.Size()
			n += 1 + l + sovTechsupConfig(uint64(l))
		}
	}
	if len(m.ExportActions) > 0 {
		for _, e := range m.ExportActions {
			l = e.Size()
			n += 1 + l + sovTechsupConfig(uint64(l))
		}
	}
	return n
}

func sovTechsupConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTechsupConfig(x uint64) (n int) {
	return sovTechsupConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (ActionItem_ActionMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVerbosity", wireType)
			}
			m.MinVerbosity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVerbosity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatCnt", wireType)
			}
			m.RepeatCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepeatCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatIntvl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatIntvl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSystemRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSystemRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RESTUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RESTUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPCPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			m.Retention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retention |= (TechSupportConfig_RetentionPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRetries", wireType)
			}
			m.DefaultRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepActions = append(m.PrepActions, &ActionItem{})
			if err := m.PrepActions[len(m.PrepActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectActions = append(m.CollectActions, &ActionItem{})
			if err := m.CollectActions[len(m.CollectActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportActions = append(m.ExportActions, &ActionItem{})
			if err := m.ExportActions[len(m.ExportActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTechsupConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTechsupConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTechsupConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTechsupConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTechsupConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTechsupConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTechsupConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTechsupConfig   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("techsup_config.proto", fileDescriptorTechsupConfig) }

var fileDescriptorTechsupConfig = []byte{
	// 523 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xad, 0x9b, 0xa7, 0xaf, 0xd3, 0xd4, 0x8c, 0x2a, 0x18, 0x21, 0x14, 0x59, 0x11, 0x42, 0x59,
	0x79, 0x11, 0x56, 0x48, 0x20, 0x54, 0x9c, 0x50, 0x15, 0x35, 0x34, 0x9a, 0x04, 0xb6, 0xc8, 0x71,
	0x6e, 0x1b, 0xa3, 0xb1, 0xc7, 0xb2, 0xc7, 0x88, 0xfc, 0x04, 0xdf, 0xc1, 0xa7, 0xb0, 0xe4, 0x13,
	0x50, 0xbe, 0x04, 0xcd, 0xd8, 0x6e, 0x1e, 0xd0, 0xee, 0xe6, 0x9c, 0x39, 0xe7, 0xce, 0xf5, 0xb9,
	0xd7, 0x70, 0x26, 0x31, 0x58, 0x65, 0x79, 0xf2, 0x25, 0x10, 0xf1, 0x4d, 0x78, 0xeb, 0x26, 0xa9,
	0x90, 0x82, 0x58, 0x25, 0x9b, 0x88, 0x54, 0xf6, 0x7f, 0xd6, 0x00, 0xce, 0x03, 0x19, 0x8a, 0xf8,
	0x52, 0x62, 0x44, 0x08, 0xd4, 0x3f, 0xfa, 0x11, 0x52, 0xc3, 0x31, 0x06, 0x26, 0xd3, 0x67, 0xf2,
	0x1a, 0x9a, 0x13, 0x94, 0x2b, 0xb1, 0xa4, 0xc7, 0x8e, 0x31, 0xe8, 0x0e, 0x9f, 0xbb, 0x3b, 0x05,
	0xdc, 0xad, 0xb9, 0x3c, 0x16, 0x5a, 0x56, 0x7a, 0xc8, 0x63, 0x68, 0x5e, 0xf9, 0x0b, 0xe4, 0x19,
	0xad, 0x39, 0xb5, 0x81, 0xc9, 0x4a, 0x44, 0xfa, 0xd0, 0x99, 0x84, 0xf1, 0x67, 0x4c, 0x17, 0x22,
	0x0b, 0xe5, 0x9a, 0xd6, 0x1d, 0x63, 0xd0, 0x60, 0x7b, 0x1c, 0x39, 0x83, 0xc6, 0x45, 0x2a, 0xf2,
	0x84, 0x36, 0x74, 0x3b, 0x05, 0x20, 0x14, 0x5a, 0x9e, 0x88, 0x22, 0x3f, 0x5e, 0xd2, 0xa6, 0xe6,
	0x2b, 0x48, 0x9e, 0x81, 0x79, 0x9e, 0xde, 0xe6, 0x11, 0xc6, 0x32, 0xa3, 0x2d, 0xfd, 0xdc, 0x96,
	0x50, 0x3e, 0x86, 0x32, 0x0d, 0x31, 0xa3, 0x6d, 0xfd, 0x58, 0x05, 0xd5, 0xcd, 0x3c, 0x8c, 0x50,
	0xe4, 0x92, 0x9a, 0x45, 0xc5, 0x12, 0xaa, 0x8a, 0x0c, 0x13, 0xf4, 0xa5, 0x17, 0x4b, 0x0a, 0xda,
	0xb5, 0x25, 0x88, 0x03, 0x56, 0x01, 0x2e, 0x63, 0xf9, 0x8d, 0x53, 0x4b, 0x7b, 0x77, 0xa9, 0xfe,
	0x07, 0xe8, 0xec, 0xa6, 0x42, 0x3a, 0xd0, 0x9e, 0xad, 0x90, 0x73, 0x2f, 0x5a, 0xda, 0x47, 0xe4,
	0x04, 0xcc, 0x11, 0xf2, 0x64, 0x15, 0x5e, 0x2f, 0xbe, 0xda, 0x86, 0xba, 0x64, 0xe3, 0xd9, 0xdc,
	0xf3, 0x39, 0xb7, 0x8f, 0xc9, 0x29, 0x58, 0x9e, 0xe0, 0x1c, 0x03, 0xf9, 0x3e, 0xe4, 0x68, 0xd7,
	0xfa, 0x3f, 0xea, 0xf0, 0x68, 0x8e, 0xc1, 0x6a, 0x56, 0x24, 0xef, 0xe9, 0x99, 0xfe, 0x77, 0x62,
	0x2f, 0xa0, 0xab, 0x3c, 0xb3, 0x75, 0x26, 0x31, 0x62, 0x42, 0x48, 0x3d, 0x39, 0x93, 0x1d, 0xb0,
	0x3a, 0x91, 0xf1, 0x6c, 0xfe, 0x29, 0x0d, 0x75, 0xfc, 0x26, 0xab, 0x20, 0x79, 0x0a, 0xed, 0x0b,
	0x36, 0xf5, 0xa6, 0x22, 0x95, 0x65, 0xf8, 0x77, 0x98, 0x5c, 0xa9, 0x4c, 0x24, 0xc6, 0xea, 0xb3,
	0xf4, 0x04, 0xba, 0x43, 0x77, 0x6f, 0x25, 0xfe, 0x69, 0xd2, 0xbd, 0xd3, 0x4f, 0x05, 0x0f, 0x83,
	0x35, 0xdb, 0x16, 0x50, 0xbd, 0x8e, 0xf0, 0xc6, 0xcf, 0xb9, 0xac, 0x46, 0xd0, 0x2a, 0x7a, 0xdd,
	0x67, 0x77, 0x74, 0xfb, 0x43, 0x3c, 0x60, 0xc9, 0x2b, 0xb0, 0xa6, 0x29, 0x26, 0x45, 0xea, 0x19,
	0x35, 0x9d, 0xda, 0xc0, 0x1a, 0x3e, 0xb9, 0x67, 0x65, 0xd9, 0xae, 0x96, 0xbc, 0x85, 0x6e, 0x99,
	0x78, 0xe5, 0x86, 0x87, 0xdd, 0x07, 0x72, 0xf2, 0x06, 0x4e, 0xc6, 0xdf, 0x95, 0xa8, 0xf2, 0x5b,
	0x0f, 0xfb, 0xf7, 0xd5, 0x7d, 0x17, 0x4e, 0x0f, 0x82, 0x52, 0x4b, 0x30, 0x42, 0x7e, 0x1d, 0x17,
	0x42, 0xfb, 0x88, 0x00, 0x34, 0x27, 0x7e, 0x9c, 0xfb, 0xdc, 0x36, 0xde, 0x75, 0x7e, 0x6d, 0x7a,
	0xc6, 0xef, 0x4d, 0xcf, 0xf8, 0xb3, 0xe9, 0x19, 0x8b, 0xa6, 0xfe, 0xbb, 0x5f, 0xfe, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0x3f, 0xe2, 0xfe, 0xe5, 0xf5, 0x03, 0x00, 0x00,
}
