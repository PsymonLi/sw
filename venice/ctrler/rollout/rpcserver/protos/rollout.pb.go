// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rollout.proto

/*
	Package protos is a generated protocol buffer package.

	It is generated from these files:
		rollout.proto

	It has these top-level messages:
		SmartNICOpSpec
		SmartNICRolloutSpec
		SmartNICOpStatus
		SmartNICRolloutStatus
		SmartNICRollout
		SmartNICRolloutEvent
		SmartNICRolloutStatusUpdate
		VeniceOpSpec
		VeniceRolloutSpec
		VeniceOpStatus
		VeniceRolloutStatus
		VeniceRollout
		VeniceRolloutEvent
		VeniceRolloutStatusUpdate
		ServiceOpSpec
		ServiceRolloutSpec
		ServiceOpStatus
		ServiceRolloutStatus
		ServiceRollout
		ServiceRolloutEvent
		ServiceRolloutStatusUpdate
*/
package protos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import api1 "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SmartNICOp int32

const (
	SmartNICOp_SmartNICPreCheckForUpgOnNextHostReboot SmartNICOp = 0
	SmartNICOp_SmartNICPreCheckForDisruptive          SmartNICOp = 1
	SmartNICOp_SmartNICUpgOnNextHostReboot            SmartNICOp = 2
	SmartNICOp_SmartNICDisruptiveUpgrade              SmartNICOp = 3
)

var SmartNICOp_name = map[int32]string{
	0: "SmartNICPreCheckForUpgOnNextHostReboot",
	1: "SmartNICPreCheckForDisruptive",
	2: "SmartNICUpgOnNextHostReboot",
	3: "SmartNICDisruptiveUpgrade",
}
var SmartNICOp_value = map[string]int32{
	"SmartNICPreCheckForUpgOnNextHostReboot": 0,
	"SmartNICPreCheckForDisruptive":          1,
	"SmartNICUpgOnNextHostReboot":            2,
	"SmartNICDisruptiveUpgrade":              3,
}

func (x SmartNICOp) String() string {
	return proto.EnumName(SmartNICOp_name, int32(x))
}
func (SmartNICOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{0} }

type AllowedStatus int32

const (
	AllowedStatus_Success    AllowedStatus = 0
	AllowedStatus_Fail       AllowedStatus = 1
	AllowedStatus_InProgress AllowedStatus = 2
)

var AllowedStatus_name = map[int32]string{
	0: "Success",
	1: "Fail",
	2: "InProgress",
}
var AllowedStatus_value = map[string]int32{
	"Success":    0,
	"Fail":       1,
	"InProgress": 2,
}

func (x AllowedStatus) String() string {
	return proto.EnumName(AllowedStatus_name, int32(x))
}
func (AllowedStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1} }

type VeniceOp int32

const (
	VeniceOp_VenicePreCheck   VeniceOp = 0
	VeniceOp_VeniceRunVersion VeniceOp = 1
)

var VeniceOp_name = map[int32]string{
	0: "VenicePreCheck",
	1: "VeniceRunVersion",
}
var VeniceOp_value = map[string]int32{
	"VenicePreCheck":   0,
	"VeniceRunVersion": 1,
}

func (x VeniceOp) String() string {
	return proto.EnumName(VeniceOp_name, int32(x))
}
func (VeniceOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{2} }

// ========== ServiceRollout : Rollout of services in the cluster. This is a singleton object ======
type ServiceOp int32

const (
	ServiceOp_ServiceRunVersion ServiceOp = 0
)

var ServiceOp_name = map[int32]string{
	0: "ServiceRunVersion",
}
var ServiceOp_value = map[string]int32{
	"ServiceRunVersion": 0,
}

func (x ServiceOp) String() string {
	return proto.EnumName(ServiceOp_name, int32(x))
}
func (ServiceOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{3} }

type SmartNICOpSpec struct {
	Op      SmartNICOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.SmartNICOp" json:"op,omitempty"`
	Version string     `protobuf:"bytes,2,opt,name=Version,proto3" json:"ver,omitempty"`
}

func (m *SmartNICOpSpec) Reset()                    { *m = SmartNICOpSpec{} }
func (m *SmartNICOpSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICOpSpec) ProtoMessage()               {}
func (*SmartNICOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{0} }

func (m *SmartNICOpSpec) GetOp() SmartNICOp {
	if m != nil {
		return m.Op
	}
	return SmartNICOp_SmartNICPreCheckForUpgOnNextHostReboot
}

func (m *SmartNICOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type SmartNICRolloutSpec struct {
	Ops []*SmartNICOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"ops,omitempty"`
}

func (m *SmartNICRolloutSpec) Reset()                    { *m = SmartNICRolloutSpec{} }
func (m *SmartNICRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICRolloutSpec) ProtoMessage()               {}
func (*SmartNICRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1} }

func (m *SmartNICRolloutSpec) GetOps() []*SmartNICOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type SmartNICOpStatus struct {
	Op       SmartNICOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.SmartNICOp" json:"Op,omitempty"`
	Version  string     `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string     `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string     `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *SmartNICOpStatus) Reset()                    { *m = SmartNICOpStatus{} }
func (m *SmartNICOpStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICOpStatus) ProtoMessage()               {}
func (*SmartNICOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{2} }

func (m *SmartNICOpStatus) GetOp() SmartNICOp {
	if m != nil {
		return m.Op
	}
	return SmartNICOp_SmartNICPreCheckForUpgOnNextHostReboot
}

func (m *SmartNICOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SmartNICOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *SmartNICOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type SmartNICRolloutStatus struct {
	OpStatus []SmartNICOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *SmartNICRolloutStatus) Reset()                    { *m = SmartNICRolloutStatus{} }
func (m *SmartNICRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICRolloutStatus) ProtoMessage()               {}
func (*SmartNICRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{3} }

func (m *SmartNICRolloutStatus) GetOpStatus() []SmartNICOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type SmartNICRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           SmartNICRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *SmartNICRollout) Reset()                    { *m = SmartNICRollout{} }
func (m *SmartNICRollout) String() string            { return proto.CompactTextString(m) }
func (*SmartNICRollout) ProtoMessage()               {}
func (*SmartNICRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{4} }

func (m *SmartNICRollout) GetSpec() SmartNICRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICRolloutSpec{}
}

type SmartNICRolloutEvent struct {
	EventType       api.EventType   `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	SmartNICRollout SmartNICRollout `protobuf:"bytes,2,opt,name=SmartNICRollout" json:",omitempty"`
}

func (m *SmartNICRolloutEvent) Reset()                    { *m = SmartNICRolloutEvent{} }
func (m *SmartNICRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*SmartNICRolloutEvent) ProtoMessage()               {}
func (*SmartNICRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{5} }

func (m *SmartNICRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *SmartNICRolloutEvent) GetSmartNICRollout() SmartNICRollout {
	if m != nil {
		return m.SmartNICRollout
	}
	return SmartNICRollout{}
}

type SmartNICRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta        `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     SmartNICRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *SmartNICRolloutStatusUpdate) Reset()         { *m = SmartNICRolloutStatusUpdate{} }
func (m *SmartNICRolloutStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*SmartNICRolloutStatusUpdate) ProtoMessage()    {}
func (*SmartNICRolloutStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{6}
}

func (m *SmartNICRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *SmartNICRolloutStatusUpdate) GetStatus() SmartNICRolloutStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICRolloutStatus{}
}

type VeniceOpSpec struct {
	Op      VeniceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.VeniceOp" json:"Op,omitempty"`
	Version string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *VeniceOpSpec) Reset()                    { *m = VeniceOpSpec{} }
func (m *VeniceOpSpec) String() string            { return proto.CompactTextString(m) }
func (*VeniceOpSpec) ProtoMessage()               {}
func (*VeniceOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{7} }

func (m *VeniceOpSpec) GetOp() VeniceOp {
	if m != nil {
		return m.Op
	}
	return VeniceOp_VenicePreCheck
}

func (m *VeniceOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type VeniceRolloutSpec struct {
	Ops []*VeniceOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"Ops,omitempty"`
}

func (m *VeniceRolloutSpec) Reset()                    { *m = VeniceRolloutSpec{} }
func (m *VeniceRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutSpec) ProtoMessage()               {}
func (*VeniceRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{8} }

func (m *VeniceRolloutSpec) GetOps() []*VeniceOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type VeniceOpStatus struct {
	Op       VeniceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.VeniceOp" json:"Op,omitempty"`
	Version  string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string   `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string   `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *VeniceOpStatus) Reset()                    { *m = VeniceOpStatus{} }
func (m *VeniceOpStatus) String() string            { return proto.CompactTextString(m) }
func (*VeniceOpStatus) ProtoMessage()               {}
func (*VeniceOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{9} }

func (m *VeniceOpStatus) GetOp() VeniceOp {
	if m != nil {
		return m.Op
	}
	return VeniceOp_VenicePreCheck
}

func (m *VeniceOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VeniceOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *VeniceOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type VeniceRolloutStatus struct {
	OpStatus []VeniceOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *VeniceRolloutStatus) Reset()                    { *m = VeniceRolloutStatus{} }
func (m *VeniceRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutStatus) ProtoMessage()               {}
func (*VeniceRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{10} }

func (m *VeniceRolloutStatus) GetOpStatus() []VeniceOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type VeniceRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           VeniceRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *VeniceRollout) Reset()                    { *m = VeniceRollout{} }
func (m *VeniceRollout) String() string            { return proto.CompactTextString(m) }
func (*VeniceRollout) ProtoMessage()               {}
func (*VeniceRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{11} }

func (m *VeniceRollout) GetSpec() VeniceRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return VeniceRolloutSpec{}
}

type VeniceRolloutEvent struct {
	EventType     api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	VeniceRollout VeniceRollout `protobuf:"bytes,2,opt,name=VeniceRollout" json:",omitempty"`
}

func (m *VeniceRolloutEvent) Reset()                    { *m = VeniceRolloutEvent{} }
func (m *VeniceRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutEvent) ProtoMessage()               {}
func (*VeniceRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{12} }

func (m *VeniceRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *VeniceRolloutEvent) GetVeniceRollout() VeniceRollout {
	if m != nil {
		return m.VeniceRollout
	}
	return VeniceRollout{}
}

type VeniceRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta      `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     VeniceRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *VeniceRolloutStatusUpdate) Reset()         { *m = VeniceRolloutStatusUpdate{} }
func (m *VeniceRolloutStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*VeniceRolloutStatusUpdate) ProtoMessage()    {}
func (*VeniceRolloutStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{13}
}

func (m *VeniceRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *VeniceRolloutStatusUpdate) GetStatus() VeniceRolloutStatus {
	if m != nil {
		return m.Status
	}
	return VeniceRolloutStatus{}
}

type ServiceOpSpec struct {
	Op      ServiceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.ServiceOp" json:"Op,omitempty"`
	Version string    `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *ServiceOpSpec) Reset()                    { *m = ServiceOpSpec{} }
func (m *ServiceOpSpec) String() string            { return proto.CompactTextString(m) }
func (*ServiceOpSpec) ProtoMessage()               {}
func (*ServiceOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{14} }

func (m *ServiceOpSpec) GetOp() ServiceOp {
	if m != nil {
		return m.Op
	}
	return ServiceOp_ServiceRunVersion
}

func (m *ServiceOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ServiceRolloutSpec struct {
	Ops []*ServiceOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"Ops,omitempty"`
}

func (m *ServiceRolloutSpec) Reset()                    { *m = ServiceRolloutSpec{} }
func (m *ServiceRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutSpec) ProtoMessage()               {}
func (*ServiceRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{15} }

func (m *ServiceRolloutSpec) GetOps() []*ServiceOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type ServiceOpStatus struct {
	Op       ServiceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.ServiceOp" json:"Op,omitempty"`
	Version  string    `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string    `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string    `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *ServiceOpStatus) Reset()                    { *m = ServiceOpStatus{} }
func (m *ServiceOpStatus) String() string            { return proto.CompactTextString(m) }
func (*ServiceOpStatus) ProtoMessage()               {}
func (*ServiceOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{16} }

func (m *ServiceOpStatus) GetOp() ServiceOp {
	if m != nil {
		return m.Op
	}
	return ServiceOp_ServiceRunVersion
}

func (m *ServiceOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ServiceOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *ServiceOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ServiceRolloutStatus struct {
	OpStatus []ServiceOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *ServiceRolloutStatus) Reset()                    { *m = ServiceRolloutStatus{} }
func (m *ServiceRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutStatus) ProtoMessage()               {}
func (*ServiceRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{17} }

func (m *ServiceRolloutStatus) GetOpStatus() []ServiceOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type ServiceRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           ServiceRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *ServiceRollout) Reset()                    { *m = ServiceRollout{} }
func (m *ServiceRollout) String() string            { return proto.CompactTextString(m) }
func (*ServiceRollout) ProtoMessage()               {}
func (*ServiceRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{18} }

func (m *ServiceRollout) GetSpec() ServiceRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return ServiceRolloutSpec{}
}

type ServiceRolloutEvent struct {
	EventType      api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	ServiceRollout ServiceRollout `protobuf:"bytes,2,opt,name=ServiceRollout" json:",omitempty"`
}

func (m *ServiceRolloutEvent) Reset()                    { *m = ServiceRolloutEvent{} }
func (m *ServiceRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutEvent) ProtoMessage()               {}
func (*ServiceRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{19} }

func (m *ServiceRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *ServiceRolloutEvent) GetServiceRollout() ServiceRollout {
	if m != nil {
		return m.ServiceRollout
	}
	return ServiceRollout{}
}

type ServiceRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta       `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     ServiceRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *ServiceRolloutStatusUpdate) Reset()         { *m = ServiceRolloutStatusUpdate{} }
func (m *ServiceRolloutStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*ServiceRolloutStatusUpdate) ProtoMessage()    {}
func (*ServiceRolloutStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{20}
}

func (m *ServiceRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *ServiceRolloutStatusUpdate) GetStatus() ServiceRolloutStatus {
	if m != nil {
		return m.Status
	}
	return ServiceRolloutStatus{}
}

func init() {
	proto.RegisterType((*SmartNICOpSpec)(nil), "protos.SmartNICOpSpec")
	proto.RegisterType((*SmartNICRolloutSpec)(nil), "protos.SmartNICRolloutSpec")
	proto.RegisterType((*SmartNICOpStatus)(nil), "protos.SmartNICOpStatus")
	proto.RegisterType((*SmartNICRolloutStatus)(nil), "protos.SmartNICRolloutStatus")
	proto.RegisterType((*SmartNICRollout)(nil), "protos.SmartNICRollout")
	proto.RegisterType((*SmartNICRolloutEvent)(nil), "protos.SmartNICRolloutEvent")
	proto.RegisterType((*SmartNICRolloutStatusUpdate)(nil), "protos.SmartNICRolloutStatusUpdate")
	proto.RegisterType((*VeniceOpSpec)(nil), "protos.VeniceOpSpec")
	proto.RegisterType((*VeniceRolloutSpec)(nil), "protos.VeniceRolloutSpec")
	proto.RegisterType((*VeniceOpStatus)(nil), "protos.VeniceOpStatus")
	proto.RegisterType((*VeniceRolloutStatus)(nil), "protos.VeniceRolloutStatus")
	proto.RegisterType((*VeniceRollout)(nil), "protos.VeniceRollout")
	proto.RegisterType((*VeniceRolloutEvent)(nil), "protos.VeniceRolloutEvent")
	proto.RegisterType((*VeniceRolloutStatusUpdate)(nil), "protos.VeniceRolloutStatusUpdate")
	proto.RegisterType((*ServiceOpSpec)(nil), "protos.ServiceOpSpec")
	proto.RegisterType((*ServiceRolloutSpec)(nil), "protos.ServiceRolloutSpec")
	proto.RegisterType((*ServiceOpStatus)(nil), "protos.ServiceOpStatus")
	proto.RegisterType((*ServiceRolloutStatus)(nil), "protos.ServiceRolloutStatus")
	proto.RegisterType((*ServiceRollout)(nil), "protos.ServiceRollout")
	proto.RegisterType((*ServiceRolloutEvent)(nil), "protos.ServiceRolloutEvent")
	proto.RegisterType((*ServiceRolloutStatusUpdate)(nil), "protos.ServiceRolloutStatusUpdate")
	proto.RegisterEnum("protos.SmartNICOp", SmartNICOp_name, SmartNICOp_value)
	proto.RegisterEnum("protos.AllowedStatus", AllowedStatus_name, AllowedStatus_value)
	proto.RegisterEnum("protos.VeniceOp", VeniceOp_name, VeniceOp_value)
	proto.RegisterEnum("protos.ServiceOp", ServiceOp_name, ServiceOp_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SmartNICRolloutApi service

type SmartNICRolloutApiClient interface {
	WatchSmartNICRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (SmartNICRolloutApi_WatchSmartNICRolloutClient, error)
	UpdateSmartNICRolloutStatus(ctx context.Context, in *SmartNICRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type smartNICRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewSmartNICRolloutApiClient(cc *grpc.ClientConn) SmartNICRolloutApiClient {
	return &smartNICRolloutApiClient{cc}
}

func (c *smartNICRolloutApiClient) WatchSmartNICRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (SmartNICRolloutApi_WatchSmartNICRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SmartNICRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.SmartNICRolloutApi/WatchSmartNICRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &smartNICRolloutApiWatchSmartNICRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SmartNICRolloutApi_WatchSmartNICRolloutClient interface {
	Recv() (*SmartNICRolloutEvent, error)
	grpc.ClientStream
}

type smartNICRolloutApiWatchSmartNICRolloutClient struct {
	grpc.ClientStream
}

func (x *smartNICRolloutApiWatchSmartNICRolloutClient) Recv() (*SmartNICRolloutEvent, error) {
	m := new(SmartNICRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *smartNICRolloutApiClient) UpdateSmartNICRolloutStatus(ctx context.Context, in *SmartNICRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.SmartNICRolloutApi/UpdateSmartNICRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SmartNICRolloutApi service

type SmartNICRolloutApiServer interface {
	WatchSmartNICRollout(*api.ObjectMeta, SmartNICRolloutApi_WatchSmartNICRolloutServer) error
	UpdateSmartNICRolloutStatus(context.Context, *SmartNICRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterSmartNICRolloutApiServer(s *grpc.Server, srv SmartNICRolloutApiServer) {
	s.RegisterService(&_SmartNICRolloutApi_serviceDesc, srv)
}

func _SmartNICRolloutApi_WatchSmartNICRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SmartNICRolloutApiServer).WatchSmartNICRollout(m, &smartNICRolloutApiWatchSmartNICRolloutServer{stream})
}

type SmartNICRolloutApi_WatchSmartNICRolloutServer interface {
	Send(*SmartNICRolloutEvent) error
	grpc.ServerStream
}

type smartNICRolloutApiWatchSmartNICRolloutServer struct {
	grpc.ServerStream
}

func (x *smartNICRolloutApiWatchSmartNICRolloutServer) Send(m *SmartNICRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _SmartNICRolloutApi_UpdateSmartNICRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNICRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmartNICRolloutApiServer).UpdateSmartNICRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.SmartNICRolloutApi/UpdateSmartNICRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmartNICRolloutApiServer).UpdateSmartNICRolloutStatus(ctx, req.(*SmartNICRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _SmartNICRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.SmartNICRolloutApi",
	HandlerType: (*SmartNICRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSmartNICRolloutStatus",
			Handler:    _SmartNICRolloutApi_UpdateSmartNICRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSmartNICRollout",
			Handler:       _SmartNICRolloutApi_WatchSmartNICRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

// Client API for VeniceRolloutApi service

type VeniceRolloutApiClient interface {
	WatchVeniceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (VeniceRolloutApi_WatchVeniceRolloutClient, error)
	UpdateVeniceRolloutStatus(ctx context.Context, in *VeniceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type veniceRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewVeniceRolloutApiClient(cc *grpc.ClientConn) VeniceRolloutApiClient {
	return &veniceRolloutApiClient{cc}
}

func (c *veniceRolloutApiClient) WatchVeniceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (VeniceRolloutApi_WatchVeniceRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VeniceRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.VeniceRolloutApi/WatchVeniceRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &veniceRolloutApiWatchVeniceRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VeniceRolloutApi_WatchVeniceRolloutClient interface {
	Recv() (*VeniceRolloutEvent, error)
	grpc.ClientStream
}

type veniceRolloutApiWatchVeniceRolloutClient struct {
	grpc.ClientStream
}

func (x *veniceRolloutApiWatchVeniceRolloutClient) Recv() (*VeniceRolloutEvent, error) {
	m := new(VeniceRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *veniceRolloutApiClient) UpdateVeniceRolloutStatus(ctx context.Context, in *VeniceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.VeniceRolloutApi/UpdateVeniceRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VeniceRolloutApi service

type VeniceRolloutApiServer interface {
	WatchVeniceRollout(*api.ObjectMeta, VeniceRolloutApi_WatchVeniceRolloutServer) error
	UpdateVeniceRolloutStatus(context.Context, *VeniceRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterVeniceRolloutApiServer(s *grpc.Server, srv VeniceRolloutApiServer) {
	s.RegisterService(&_VeniceRolloutApi_serviceDesc, srv)
}

func _VeniceRolloutApi_WatchVeniceRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VeniceRolloutApiServer).WatchVeniceRollout(m, &veniceRolloutApiWatchVeniceRolloutServer{stream})
}

type VeniceRolloutApi_WatchVeniceRolloutServer interface {
	Send(*VeniceRolloutEvent) error
	grpc.ServerStream
}

type veniceRolloutApiWatchVeniceRolloutServer struct {
	grpc.ServerStream
}

func (x *veniceRolloutApiWatchVeniceRolloutServer) Send(m *VeniceRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _VeniceRolloutApi_UpdateVeniceRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VeniceRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VeniceRolloutApiServer).UpdateVeniceRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.VeniceRolloutApi/UpdateVeniceRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VeniceRolloutApiServer).UpdateVeniceRolloutStatus(ctx, req.(*VeniceRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _VeniceRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.VeniceRolloutApi",
	HandlerType: (*VeniceRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateVeniceRolloutStatus",
			Handler:    _VeniceRolloutApi_UpdateVeniceRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchVeniceRollout",
			Handler:       _VeniceRolloutApi_WatchVeniceRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

// Client API for ServiceRolloutApi service

type ServiceRolloutApiClient interface {
	WatchServiceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (ServiceRolloutApi_WatchServiceRolloutClient, error)
	UpdateServiceRolloutStatus(ctx context.Context, in *ServiceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type serviceRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewServiceRolloutApiClient(cc *grpc.ClientConn) ServiceRolloutApiClient {
	return &serviceRolloutApiClient{cc}
}

func (c *serviceRolloutApiClient) WatchServiceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (ServiceRolloutApi_WatchServiceRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServiceRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.ServiceRolloutApi/WatchServiceRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceRolloutApiWatchServiceRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServiceRolloutApi_WatchServiceRolloutClient interface {
	Recv() (*ServiceRolloutEvent, error)
	grpc.ClientStream
}

type serviceRolloutApiWatchServiceRolloutClient struct {
	grpc.ClientStream
}

func (x *serviceRolloutApiWatchServiceRolloutClient) Recv() (*ServiceRolloutEvent, error) {
	m := new(ServiceRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serviceRolloutApiClient) UpdateServiceRolloutStatus(ctx context.Context, in *ServiceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.ServiceRolloutApi/UpdateServiceRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServiceRolloutApi service

type ServiceRolloutApiServer interface {
	WatchServiceRollout(*api.ObjectMeta, ServiceRolloutApi_WatchServiceRolloutServer) error
	UpdateServiceRolloutStatus(context.Context, *ServiceRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterServiceRolloutApiServer(s *grpc.Server, srv ServiceRolloutApiServer) {
	s.RegisterService(&_ServiceRolloutApi_serviceDesc, srv)
}

func _ServiceRolloutApi_WatchServiceRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceRolloutApiServer).WatchServiceRollout(m, &serviceRolloutApiWatchServiceRolloutServer{stream})
}

type ServiceRolloutApi_WatchServiceRolloutServer interface {
	Send(*ServiceRolloutEvent) error
	grpc.ServerStream
}

type serviceRolloutApiWatchServiceRolloutServer struct {
	grpc.ServerStream
}

func (x *serviceRolloutApiWatchServiceRolloutServer) Send(m *ServiceRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _ServiceRolloutApi_UpdateServiceRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRolloutApiServer).UpdateServiceRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ServiceRolloutApi/UpdateServiceRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRolloutApiServer).UpdateServiceRolloutStatus(ctx, req.(*ServiceRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ServiceRolloutApi",
	HandlerType: (*ServiceRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateServiceRolloutStatus",
			Handler:    _ServiceRolloutApi_UpdateServiceRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchServiceRollout",
			Handler:       _ServiceRolloutApi_WatchServiceRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

func (m *SmartNICOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *SmartNICRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *SmartNICRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.SmartNICRollout.Size()))
	n4, err := m.SmartNICRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *SmartNICRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *VeniceOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *VeniceRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VeniceOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *VeniceRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VeniceRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n7, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n8, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n9, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *VeniceRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.VeniceRollout.Size()))
	n10, err := m.VeniceRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *VeniceRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *ServiceOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *ServiceRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ServiceRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *ServiceRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ServiceRollout.Size()))
	n16, err := m.ServiceRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *ServiceRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n17, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n18, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	return i, nil
}

func encodeVarintRollout(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SmartNICOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *SmartNICRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *SmartNICOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *SmartNICRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *SmartNICRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *SmartNICRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.SmartNICRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *SmartNICRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *VeniceRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *VeniceOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *VeniceRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *VeniceRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.VeniceRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *ServiceRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *ServiceOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *ServiceRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *ServiceRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.ServiceRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func sovRollout(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRollout(x uint64) (n int) {
	return sovRollout(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SmartNICOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (SmartNICOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, &SmartNICOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (SmartNICOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, SmartNICOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNICRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SmartNICRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (VeniceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, &VeniceOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (VeniceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, VeniceOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VeniceRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (ServiceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, &ServiceOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (ServiceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, ServiceOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRollout(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRollout
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRollout
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRollout(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRollout = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRollout   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rollout.proto", fileDescriptorRollout) }

var fileDescriptorRollout = []byte{
	// 1165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdd, 0x4e, 0x1b, 0x47,
	0x14, 0xf6, 0x98, 0x28, 0xc0, 0x01, 0x3b, 0x66, 0x30, 0xc4, 0x98, 0x1f, 0xc3, 0x56, 0x4d, 0x28,
	0x22, 0xb8, 0x72, 0xa3, 0xaa, 0x52, 0xd5, 0x56, 0x31, 0x05, 0x42, 0x0b, 0x18, 0x41, 0xa1, 0xd7,
	0xcb, 0x32, 0x5d, 0xb6, 0xb5, 0x77, 0x46, 0xbb, 0x63, 0x52, 0xd4, 0xfb, 0xbe, 0x44, 0x1f, 0xa0,
	0xea, 0x4f, 0x2e, 0x72, 0xd1, 0x77, 0xe0, 0xa2, 0xaa, 0x78, 0x02, 0x54, 0x51, 0x55, 0x95, 0x78,
	0x8a, 0x6a, 0x67, 0x76, 0xbd, 0xb3, 0xeb, 0xb1, 0x41, 0x0a, 0x52, 0x72, 0x85, 0x77, 0x7c, 0xce,
	0x37, 0xdf, 0xf9, 0xe6, 0x9c, 0x6f, 0x07, 0x43, 0xce, 0xa3, 0xcd, 0x26, 0x6d, 0xf3, 0x15, 0xe6,
	0x51, 0x4e, 0xf1, 0x7d, 0xf1, 0xc7, 0x2f, 0xcf, 0xd8, 0x94, 0xda, 0x4d, 0x52, 0x35, 0x99, 0x53,
	0x35, 0x5d, 0x97, 0x72, 0x93, 0x3b, 0xd4, 0xf5, 0x65, 0x54, 0x79, 0xcd, 0x76, 0xf8, 0x49, 0xfb,
	0x68, 0xc5, 0xa2, 0xad, 0x2a, 0x23, 0xae, 0x6f, 0xba, 0xc7, 0xb4, 0xea, 0xbf, 0xa8, 0x9e, 0x12,
	0xd7, 0xb1, 0x48, 0xb5, 0xcd, 0x9d, 0xa6, 0x1f, 0xa4, 0xda, 0xc4, 0x55, 0xb3, 0xab, 0x8e, 0x6b,
	0x35, 0xdb, 0xc7, 0x24, 0x82, 0x79, 0xa2, 0xc0, 0xd8, 0xd4, 0xa6, 0x55, 0xb1, 0x7c, 0xd4, 0xfe,
	0x46, 0x3c, 0x89, 0x07, 0xf1, 0x29, 0x0c, 0x7f, 0xb7, 0xc7, 0xae, 0x01, 0xc7, 0x16, 0xe1, 0x66,
	0x18, 0xf6, 0xb8, 0x4f, 0x98, 0x45, 0x5b, 0x2d, 0xea, 0xca, 0x40, 0xe3, 0x07, 0xc8, 0xef, 0xb7,
	0x4c, 0x8f, 0xef, 0x6c, 0xae, 0x36, 0xd8, 0x3e, 0x23, 0x16, 0xfe, 0x08, 0xb2, 0x0d, 0x56, 0x42,
	0xf3, 0x68, 0x31, 0x5f, 0xc3, 0x32, 0xca, 0x5f, 0x89, 0x63, 0xea, 0xc5, 0xf3, 0xcb, 0x0a, 0xba,
	0xbe, 0xac, 0x8c, 0x52, 0xb6, 0x4c, 0x5b, 0x0e, 0x27, 0x2d, 0xc6, 0xcf, 0xf6, 0xb2, 0x0d, 0x86,
	0xab, 0x30, 0x78, 0x48, 0x3c, 0xdf, 0xa1, 0x6e, 0x29, 0x3b, 0x8f, 0x16, 0x87, 0xeb, 0x13, 0x61,
	0x68, 0xee, 0x94, 0x78, 0x4a, 0x6c, 0x14, 0x65, 0x1c, 0xc2, 0x78, 0x04, 0xbc, 0x27, 0x4f, 0x40,
	0x30, 0xf8, 0x0c, 0x06, 0x1a, 0xcc, 0x2f, 0xa1, 0xf9, 0x81, 0xc5, 0x91, 0xda, 0x64, 0x37, 0x85,
	0x20, 0x28, 0xc6, 0xa6, 0xcc, 0x57, 0xb0, 0x83, 0x4c, 0xe3, 0x02, 0x41, 0x41, 0x09, 0xe7, 0x26,
	0x6f, 0xfb, 0xd8, 0xe8, 0x5f, 0x97, 0xa8, 0xa0, 0x94, 0xaa, 0xa0, 0x43, 0x15, 0xef, 0xc2, 0x50,
	0x84, 0x54, 0x1a, 0x10, 0xc5, 0x3d, 0xfd, 0xf5, 0xc7, 0xa9, 0xc9, 0x7d, 0xee, 0xad, 0xb9, 0xed,
	0xd6, 0xe2, 0xb3, 0x66, 0x93, 0xbe, 0x20, 0xc7, 0x32, 0xe0, 0xbd, 0x90, 0x1a, 0xa6, 0xcc, 0x17,
	0x0b, 0x0a, 0xbf, 0x0e, 0x0a, 0x5e, 0x86, 0xc1, 0x6d, 0xe2, 0xfb, 0xa6, 0x4d, 0x4a, 0xf7, 0x04,
	0x20, 0x0e, 0xd3, 0x40, 0x95, 0x2a, 0x0c, 0x31, 0x6c, 0x98, 0x48, 0x4b, 0x25, 0x61, 0x76, 0x14,
	0x62, 0x52, 0xb1, 0x92, 0x46, 0x31, 0xf1, 0x7d, 0xbd, 0x74, 0x7e, 0x59, 0xc9, 0x5c, 0x5f, 0x56,
	0x0a, 0xbd, 0x69, 0x19, 0xff, 0x21, 0x78, 0x90, 0xda, 0x09, 0x7f, 0x0a, 0x43, 0x5f, 0x9d, 0x31,
	0xb2, 0x4d, 0xb8, 0x29, 0x04, 0x1c, 0xa9, 0xe5, 0x56, 0x4c, 0xe6, 0xac, 0x44, 0x8b, 0xf5, 0xf1,
	0x00, 0xf8, 0x42, 0xd2, 0x1f, 0x5c, 0x76, 0xdc, 0xa6, 0xe3, 0x92, 0xbd, 0x4e, 0x0e, 0xfe, 0x12,
	0xa0, 0x71, 0xf4, 0x2d, 0xb1, 0xb8, 0x40, 0xc8, 0x0a, 0x84, 0x07, 0x02, 0x21, 0x5e, 0xae, 0x97,
	0x15, 0x8c, 0x7c, 0xd0, 0xca, 0x0a, 0x3d, 0x25, 0x1d, 0x6f, 0xc0, 0xbd, 0xa0, 0x01, 0xc4, 0x29,
	0x8c, 0xd4, 0xa6, 0xd3, 0xc5, 0x2a, 0x8d, 0x54, 0x9f, 0x0c, 0xeb, 0xcd, 0xfb, 0x8c, 0x58, 0x0a,
	0x9c, 0x00, 0x30, 0xfe, 0x40, 0x50, 0x4c, 0x65, 0xad, 0x9d, 0x12, 0x97, 0xe3, 0x75, 0x18, 0x16,
	0x1f, 0x02, 0xfe, 0x61, 0xc3, 0xe4, 0x05, 0xdb, 0xce, 0x6a, 0xbd, 0x74, 0x7d, 0x59, 0x29, 0x92,
	0xe0, 0xf1, 0x09, 0x3f, 0x63, 0x44, 0xc1, 0x8e, 0x53, 0xf1, 0x41, 0x97, 0x92, 0x61, 0xed, 0x0f,
	0x7b, 0x90, 0x16, 0x2d, 0x90, 0x49, 0xb5, 0x40, 0x1a, 0xc3, 0x78, 0x89, 0x60, 0x5a, 0xdb, 0x0b,
	0x07, 0xec, 0xd8, 0xe4, 0x04, 0xaf, 0x26, 0xd4, 0x46, 0x7a, 0xb5, 0x75, 0x3b, 0xa9, 0x2a, 0x6f,
	0xc2, 0xfd, 0xb0, 0xa9, 0x24, 0xe5, 0xd9, 0x5e, 0x3a, 0xcb, 0xce, 0xd2, 0xc1, 0x85, 0x00, 0xc6,
	0x17, 0x30, 0x7a, 0x28, 0x3c, 0x31, 0x34, 0x98, 0x79, 0x65, 0x10, 0x0b, 0x11, 0x6c, 0x14, 0xd1,
	0x7f, 0x0c, 0x8d, 0x8f, 0x61, 0x4c, 0x46, 0xaa, 0x7e, 0xf1, 0x48, 0xf5, 0x8b, 0x62, 0x1a, 0x31,
	0x08, 0x91, 0xb6, 0xf0, 0x27, 0x82, 0x7c, 0x67, 0x55, 0x4e, 0xcf, 0x6b, 0x70, 0x79, 0xe3, 0x96,
	0x60, 0xc1, 0x78, 0x52, 0x0b, 0x09, 0xb2, 0xd5, 0x65, 0x08, 0x93, 0x5d, 0x92, 0xdc, 0xde, 0x0e,
	0xfe, 0x41, 0x90, 0x4b, 0xec, 0xf2, 0x76, 0x99, 0xc1, 0x5a, 0xc2, 0x0c, 0xa6, 0x92, 0x85, 0xde,
	0xde, 0x0a, 0x5e, 0x22, 0xc0, 0x89, 0x9c, 0xbb, 0x35, 0x82, 0x46, 0x4a, 0xc3, 0xb0, 0xea, 0x09,
	0x2d, 0x5d, 0xed, 0x2c, 0x25, 0xf3, 0x8d, 0x5f, 0x10, 0x4c, 0x69, 0xce, 0xfe, 0x2e, 0x0d, 0x60,
	0x23, 0x65, 0x00, 0xd3, 0x7a, 0x6d, 0x6f, 0x1e, 0xff, 0x2d, 0xc8, 0xed, 0x13, 0xef, 0x34, 0x9e,
	0xff, 0x05, 0x65, 0xe6, 0xc6, 0x3a, 0xb6, 0x12, 0x85, 0xdc, 0x60, 0x00, 0x9f, 0x00, 0x0e, 0x43,
	0x55, 0x07, 0x78, 0xac, 0x3a, 0xc0, 0x44, 0x17, 0x66, 0x6c, 0x01, 0x7f, 0x05, 0x6f, 0xb7, 0xce,
	0xb2, 0x1c, 0x98, 0xd7, 0xe1, 0xf3, 0xc6, 0x4d, 0x80, 0x40, 0x31, 0xa5, 0x87, 0x44, 0xd9, 0xee,
	0x72, 0x81, 0x87, 0xdd, 0xb2, 0xdc, 0xde, 0x06, 0xfe, 0x45, 0x90, 0x4f, 0xee, 0xf3, 0x76, 0xf9,
	0xc0, 0x7a, 0xc2, 0x07, 0xca, 0xa9, 0x52, 0x6f, 0x6f, 0x04, 0xaf, 0x10, 0x8c, 0x27, 0x93, 0xee,
	0xd6, 0x09, 0xf6, 0xd2, 0x32, 0x86, 0x85, 0x4f, 0xea, 0x19, 0x6b, 0x07, 0x2b, 0x85, 0x60, 0xfc,
	0x86, 0xa0, 0xac, 0xeb, 0x81, 0xbb, 0x74, 0x83, 0xe7, 0x29, 0x37, 0x98, 0xe9, 0xa1, 0xf0, 0x8d,
	0x76, 0xb0, 0xf4, 0x13, 0x02, 0x88, 0x2f, 0xa6, 0x78, 0x09, 0x1e, 0x45, 0x4f, 0xbb, 0x1e, 0x59,
	0x3d, 0x21, 0xd6, 0x77, 0xeb, 0xd4, 0x3b, 0x60, 0x76, 0xc3, 0xdd, 0x21, 0xdf, 0xf3, 0xe7, 0xd4,
	0xe7, 0x7b, 0xe4, 0x88, 0x52, 0x5e, 0xc8, 0xe0, 0x05, 0x98, 0xd5, 0xc4, 0x7e, 0xee, 0xf8, 0x5e,
	0x9b, 0x71, 0xe7, 0x94, 0x14, 0x10, 0xae, 0xc4, 0x57, 0x23, 0x1d, 0x46, 0x16, 0xcf, 0xc2, 0x54,
	0x14, 0x10, 0x27, 0x1e, 0x30, 0xdb, 0x33, 0x8f, 0x49, 0x61, 0x60, 0xe9, 0x43, 0xc8, 0x25, 0x46,
	0x16, 0x8f, 0xc0, 0xe0, 0x7e, 0xdb, 0xb2, 0x88, 0xef, 0x17, 0x32, 0x78, 0x08, 0xee, 0xad, 0x9b,
	0x4e, 0xb3, 0x80, 0x70, 0x1e, 0x60, 0xd3, 0xdd, 0xf5, 0xa8, 0xed, 0x05, 0xdf, 0x64, 0x97, 0x9e,
	0xc2, 0x50, 0xf4, 0x72, 0xc5, 0x38, 0xba, 0x65, 0x44, 0x24, 0x0b, 0x19, 0x5c, 0x84, 0x42, 0xe8,
	0x9b, 0x6d, 0x37, 0xb4, 0x8e, 0x02, 0x5a, 0x32, 0x60, 0xb8, 0x33, 0x8c, 0x78, 0x02, 0xc6, 0x22,
	0x31, 0xe3, 0x98, 0x4c, 0xed, 0x15, 0x02, 0x9c, 0xba, 0x73, 0x3d, 0x63, 0x0e, 0xde, 0x84, 0xe2,
	0xd7, 0x26, 0xb7, 0x4e, 0xd2, 0x57, 0xf5, 0xf4, 0xc9, 0x96, 0x67, 0x7a, 0x5c, 0xdc, 0x44, 0x4f,
	0x1a, 0x99, 0xf7, 0x11, 0xde, 0x85, 0x69, 0xd9, 0x2a, 0xfa, 0x7f, 0x30, 0xde, 0xe9, 0x7b, 0xf3,
	0x93, 0x99, 0x65, 0x90, 0xc3, 0x10, 0x9c, 0xb4, 0x91, 0xa9, 0xfd, 0x8c, 0x3a, 0xe5, 0xc6, 0x8c,
	0xd7, 0x00, 0x0b, 0xc6, 0xc9, 0xdb, 0x44, 0x17, 0xdf, 0xb2, 0xf6, 0x3d, 0x13, 0xb3, 0xdd, 0x82,
	0x29, 0xb9, 0xa7, 0xee, 0xee, 0xb3, 0xd0, 0xe7, 0x25, 0xa5, 0x65, 0xfa, 0x3b, 0x8a, 0x55, 0x8f,
	0xa9, 0x6e, 0xc0, 0xb8, 0x14, 0x37, 0xe9, 0x78, 0x5d, 0x5c, 0xa7, 0xf5, 0x53, 0x10, 0x93, 0xdd,
	0x81, 0x72, 0x28, 0xad, 0xce, 0xa3, 0x8d, 0x7e, 0x43, 0xa4, 0xa3, 0x5b, 0x1f, 0x3d, 0xbf, 0x9a,
	0x43, 0x17, 0x57, 0x73, 0xe8, 0xef, 0xab, 0x39, 0xb4, 0x8b, 0x8e, 0xe4, 0x2f, 0x15, 0x1f, 0xfc,
	0x1f, 0x00, 0x00, 0xff, 0xff, 0xbc, 0x63, 0xb9, 0xad, 0xc1, 0x10, 0x00, 0x00,
}
