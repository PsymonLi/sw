// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rollout.proto

/*
	Package protos is a generated protocol buffer package.

	It is generated from these files:
		rollout.proto

	It has these top-level messages:
		DSCOpSpec
		DSCRolloutSpec
		DSCOpStatus
		DSCRolloutStatus
		DSCRollout
		DSCRolloutEvent
		DSCRolloutStatusUpdate
		VeniceOpSpec
		VeniceRolloutSpec
		VeniceOpStatus
		VeniceRolloutStatus
		VeniceRollout
		VeniceRolloutEvent
		VeniceRolloutStatusUpdate
		ServiceOpSpec
		ServiceRolloutSpec
		ServiceOpStatus
		ServiceRolloutStatus
		ServiceRollout
		ServiceRolloutEvent
		ServiceRolloutStatusUpdate
*/
package protos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import api1 "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DSCOp int32

const (
	DSCOp_DSCNoOp                           DSCOp = 0
	DSCOp_DSCPreCheckForUpgOnNextHostReboot DSCOp = 1
	DSCOp_DSCPreCheckForDisruptive          DSCOp = 2
	DSCOp_DSCUpgOnNextHostReboot            DSCOp = 3
	DSCOp_DSCDisruptiveUpgrade              DSCOp = 4
	DSCOp_DSCImageDownload                  DSCOp = 5
)

var DSCOp_name = map[int32]string{
	0: "DSCNoOp",
	1: "DSCPreCheckForUpgOnNextHostReboot",
	2: "DSCPreCheckForDisruptive",
	3: "DSCUpgOnNextHostReboot",
	4: "DSCDisruptiveUpgrade",
	5: "DSCImageDownload",
}
var DSCOp_value = map[string]int32{
	"DSCNoOp":                           0,
	"DSCPreCheckForUpgOnNextHostReboot": 1,
	"DSCPreCheckForDisruptive":          2,
	"DSCUpgOnNextHostReboot":            3,
	"DSCDisruptiveUpgrade":              4,
	"DSCImageDownload":                  5,
}

func (x DSCOp) String() string {
	return proto.EnumName(DSCOp_name, int32(x))
}
func (DSCOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{0} }

type AllowedStatus int32

const (
	AllowedStatus_Success    AllowedStatus = 0
	AllowedStatus_Fail       AllowedStatus = 1
	AllowedStatus_InProgress AllowedStatus = 2
)

var AllowedStatus_name = map[int32]string{
	0: "Success",
	1: "Fail",
	2: "InProgress",
}
var AllowedStatus_value = map[string]int32{
	"Success":    0,
	"Fail":       1,
	"InProgress": 2,
}

func (x AllowedStatus) String() string {
	return proto.EnumName(AllowedStatus_name, int32(x))
}
func (AllowedStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1} }

type VeniceOp int32

const (
	VeniceOp_VenicePreCheck   VeniceOp = 0
	VeniceOp_VeniceRunVersion VeniceOp = 1
)

var VeniceOp_name = map[int32]string{
	0: "VenicePreCheck",
	1: "VeniceRunVersion",
}
var VeniceOp_value = map[string]int32{
	"VenicePreCheck":   0,
	"VeniceRunVersion": 1,
}

func (x VeniceOp) String() string {
	return proto.EnumName(VeniceOp_name, int32(x))
}
func (VeniceOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{2} }

// ========== ServiceRollout : Rollout of services in the cluster. This is a singleton object ======
type ServiceOp int32

const (
	ServiceOp_ServiceRunVersion ServiceOp = 0
)

var ServiceOp_name = map[int32]string{
	0: "ServiceRunVersion",
}
var ServiceOp_value = map[string]int32{
	"ServiceRunVersion": 0,
}

func (x ServiceOp) String() string {
	return proto.EnumName(ServiceOp_name, int32(x))
}
func (ServiceOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{3} }

type DSCOpSpec struct {
	Op      DSCOp  `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.DSCOp" json:"op,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"ver,omitempty"`
}

func (m *DSCOpSpec) Reset()                    { *m = DSCOpSpec{} }
func (m *DSCOpSpec) String() string            { return proto.CompactTextString(m) }
func (*DSCOpSpec) ProtoMessage()               {}
func (*DSCOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{0} }

func (m *DSCOpSpec) GetOp() DSCOp {
	if m != nil {
		return m.Op
	}
	return DSCOp_DSCNoOp
}

func (m *DSCOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type DSCRolloutSpec struct {
	Ops []DSCOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"ops,omitempty"`
}

func (m *DSCRolloutSpec) Reset()                    { *m = DSCRolloutSpec{} }
func (m *DSCRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*DSCRolloutSpec) ProtoMessage()               {}
func (*DSCRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1} }

func (m *DSCRolloutSpec) GetOps() []DSCOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type DSCOpStatus struct {
	Op       DSCOp  `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.DSCOp" json:"Op,omitempty"`
	Version  string `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *DSCOpStatus) Reset()                    { *m = DSCOpStatus{} }
func (m *DSCOpStatus) String() string            { return proto.CompactTextString(m) }
func (*DSCOpStatus) ProtoMessage()               {}
func (*DSCOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{2} }

func (m *DSCOpStatus) GetOp() DSCOp {
	if m != nil {
		return m.Op
	}
	return DSCOp_DSCNoOp
}

func (m *DSCOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DSCOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *DSCOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DSCRolloutStatus struct {
	OpStatus []DSCOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *DSCRolloutStatus) Reset()                    { *m = DSCRolloutStatus{} }
func (m *DSCRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*DSCRolloutStatus) ProtoMessage()               {}
func (*DSCRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{3} }

func (m *DSCRolloutStatus) GetOpStatus() []DSCOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type DSCRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           DSCRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *DSCRollout) Reset()                    { *m = DSCRollout{} }
func (m *DSCRollout) String() string            { return proto.CompactTextString(m) }
func (*DSCRollout) ProtoMessage()               {}
func (*DSCRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{4} }

func (m *DSCRollout) GetSpec() DSCRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return DSCRolloutSpec{}
}

type DSCRolloutEvent struct {
	EventType  api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	DSCRollout DSCRollout    `protobuf:"bytes,2,opt,name=DSCRollout" json:",omitempty"`
}

func (m *DSCRolloutEvent) Reset()                    { *m = DSCRolloutEvent{} }
func (m *DSCRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*DSCRolloutEvent) ProtoMessage()               {}
func (*DSCRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{5} }

func (m *DSCRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *DSCRolloutEvent) GetDSCRollout() DSCRollout {
	if m != nil {
		return m.DSCRollout
	}
	return DSCRollout{}
}

type DSCRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta   `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     DSCRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *DSCRolloutStatusUpdate) Reset()                    { *m = DSCRolloutStatusUpdate{} }
func (m *DSCRolloutStatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*DSCRolloutStatusUpdate) ProtoMessage()               {}
func (*DSCRolloutStatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{6} }

func (m *DSCRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *DSCRolloutStatusUpdate) GetStatus() DSCRolloutStatus {
	if m != nil {
		return m.Status
	}
	return DSCRolloutStatus{}
}

type VeniceOpSpec struct {
	Op      VeniceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.VeniceOp" json:"Op,omitempty"`
	Version string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *VeniceOpSpec) Reset()                    { *m = VeniceOpSpec{} }
func (m *VeniceOpSpec) String() string            { return proto.CompactTextString(m) }
func (*VeniceOpSpec) ProtoMessage()               {}
func (*VeniceOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{7} }

func (m *VeniceOpSpec) GetOp() VeniceOp {
	if m != nil {
		return m.Op
	}
	return VeniceOp_VenicePreCheck
}

func (m *VeniceOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type VeniceRolloutSpec struct {
	Ops []VeniceOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"ops,omitempty"`
}

func (m *VeniceRolloutSpec) Reset()                    { *m = VeniceRolloutSpec{} }
func (m *VeniceRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutSpec) ProtoMessage()               {}
func (*VeniceRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{8} }

func (m *VeniceRolloutSpec) GetOps() []VeniceOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type VeniceOpStatus struct {
	Op       VeniceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.VeniceOp" json:"Op,omitempty"`
	Version  string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string   `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string   `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *VeniceOpStatus) Reset()                    { *m = VeniceOpStatus{} }
func (m *VeniceOpStatus) String() string            { return proto.CompactTextString(m) }
func (*VeniceOpStatus) ProtoMessage()               {}
func (*VeniceOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{9} }

func (m *VeniceOpStatus) GetOp() VeniceOp {
	if m != nil {
		return m.Op
	}
	return VeniceOp_VenicePreCheck
}

func (m *VeniceOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VeniceOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *VeniceOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type VeniceRolloutStatus struct {
	OpStatus []VeniceOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *VeniceRolloutStatus) Reset()                    { *m = VeniceRolloutStatus{} }
func (m *VeniceRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutStatus) ProtoMessage()               {}
func (*VeniceRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{10} }

func (m *VeniceRolloutStatus) GetOpStatus() []VeniceOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type VeniceRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           VeniceRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *VeniceRollout) Reset()                    { *m = VeniceRollout{} }
func (m *VeniceRollout) String() string            { return proto.CompactTextString(m) }
func (*VeniceRollout) ProtoMessage()               {}
func (*VeniceRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{11} }

func (m *VeniceRollout) GetSpec() VeniceRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return VeniceRolloutSpec{}
}

type VeniceRolloutEvent struct {
	EventType     api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	VeniceRollout VeniceRollout `protobuf:"bytes,2,opt,name=VeniceRollout" json:",omitempty"`
}

func (m *VeniceRolloutEvent) Reset()                    { *m = VeniceRolloutEvent{} }
func (m *VeniceRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*VeniceRolloutEvent) ProtoMessage()               {}
func (*VeniceRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{12} }

func (m *VeniceRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *VeniceRolloutEvent) GetVeniceRollout() VeniceRollout {
	if m != nil {
		return m.VeniceRollout
	}
	return VeniceRollout{}
}

type VeniceRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta      `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     VeniceRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *VeniceRolloutStatusUpdate) Reset()         { *m = VeniceRolloutStatusUpdate{} }
func (m *VeniceRolloutStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*VeniceRolloutStatusUpdate) ProtoMessage()    {}
func (*VeniceRolloutStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{13}
}

func (m *VeniceRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *VeniceRolloutStatusUpdate) GetStatus() VeniceRolloutStatus {
	if m != nil {
		return m.Status
	}
	return VeniceRolloutStatus{}
}

type ServiceOpSpec struct {
	Op      ServiceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.ServiceOp" json:"Op,omitempty"`
	Version string    `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *ServiceOpSpec) Reset()                    { *m = ServiceOpSpec{} }
func (m *ServiceOpSpec) String() string            { return proto.CompactTextString(m) }
func (*ServiceOpSpec) ProtoMessage()               {}
func (*ServiceOpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{14} }

func (m *ServiceOpSpec) GetOp() ServiceOp {
	if m != nil {
		return m.Op
	}
	return ServiceOp_ServiceRunVersion
}

func (m *ServiceOpSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ServiceRolloutSpec struct {
	Ops []ServiceOpSpec `protobuf:"bytes,1,rep,name=Ops" json:"ops,omitempty"`
}

func (m *ServiceRolloutSpec) Reset()                    { *m = ServiceRolloutSpec{} }
func (m *ServiceRolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutSpec) ProtoMessage()               {}
func (*ServiceRolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{15} }

func (m *ServiceRolloutSpec) GetOps() []ServiceOpSpec {
	if m != nil {
		return m.Ops
	}
	return nil
}

type ServiceOpStatus struct {
	Op       ServiceOp `protobuf:"varint,1,opt,name=Op,proto3,enum=protos.ServiceOp" json:"Op,omitempty"`
	Version  string    `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OpStatus string    `protobuf:"bytes,3,opt,name=OpStatus,proto3" json:"opstatus,omitempty"`
	Message  string    `protobuf:"bytes,4,opt,name=Message,proto3" json:",omitempty"`
}

func (m *ServiceOpStatus) Reset()                    { *m = ServiceOpStatus{} }
func (m *ServiceOpStatus) String() string            { return proto.CompactTextString(m) }
func (*ServiceOpStatus) ProtoMessage()               {}
func (*ServiceOpStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{16} }

func (m *ServiceOpStatus) GetOp() ServiceOp {
	if m != nil {
		return m.Op
	}
	return ServiceOp_ServiceRunVersion
}

func (m *ServiceOpStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ServiceOpStatus) GetOpStatus() string {
	if m != nil {
		return m.OpStatus
	}
	return ""
}

func (m *ServiceOpStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ServiceRolloutStatus struct {
	OpStatus []ServiceOpStatus `protobuf:"bytes,1,rep,name=OpStatus" json:"status,omitempty"`
}

func (m *ServiceRolloutStatus) Reset()                    { *m = ServiceRolloutStatus{} }
func (m *ServiceRolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutStatus) ProtoMessage()               {}
func (*ServiceRolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{17} }

func (m *ServiceRolloutStatus) GetOpStatus() []ServiceOpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

type ServiceRollout struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           ServiceRolloutSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
}

func (m *ServiceRollout) Reset()                    { *m = ServiceRollout{} }
func (m *ServiceRollout) String() string            { return proto.CompactTextString(m) }
func (*ServiceRollout) ProtoMessage()               {}
func (*ServiceRollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{18} }

func (m *ServiceRollout) GetSpec() ServiceRolloutSpec {
	if m != nil {
		return m.Spec
	}
	return ServiceRolloutSpec{}
}

type ServiceRolloutEvent struct {
	EventType      api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	ServiceRollout ServiceRollout `protobuf:"bytes,2,opt,name=ServiceRollout" json:",omitempty"`
}

func (m *ServiceRolloutEvent) Reset()                    { *m = ServiceRolloutEvent{} }
func (m *ServiceRolloutEvent) String() string            { return proto.CompactTextString(m) }
func (*ServiceRolloutEvent) ProtoMessage()               {}
func (*ServiceRolloutEvent) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{19} }

func (m *ServiceRolloutEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *ServiceRolloutEvent) GetServiceRollout() ServiceRollout {
	if m != nil {
		return m.ServiceRollout
	}
	return ServiceRollout{}
}

type ServiceRolloutStatusUpdate struct {
	ObjectMeta api.ObjectMeta       `protobuf:"bytes,1,opt,name=ObjectMeta" json:",omitempty"`
	Status     ServiceRolloutStatus `protobuf:"bytes,2,opt,name=Status" json:",omitempty"`
}

func (m *ServiceRolloutStatusUpdate) Reset()         { *m = ServiceRolloutStatusUpdate{} }
func (m *ServiceRolloutStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*ServiceRolloutStatusUpdate) ProtoMessage()    {}
func (*ServiceRolloutStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{20}
}

func (m *ServiceRolloutStatusUpdate) GetObjectMeta() api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return api.ObjectMeta{}
}

func (m *ServiceRolloutStatusUpdate) GetStatus() ServiceRolloutStatus {
	if m != nil {
		return m.Status
	}
	return ServiceRolloutStatus{}
}

func init() {
	proto.RegisterType((*DSCOpSpec)(nil), "protos.DSCOpSpec")
	proto.RegisterType((*DSCRolloutSpec)(nil), "protos.DSCRolloutSpec")
	proto.RegisterType((*DSCOpStatus)(nil), "protos.DSCOpStatus")
	proto.RegisterType((*DSCRolloutStatus)(nil), "protos.DSCRolloutStatus")
	proto.RegisterType((*DSCRollout)(nil), "protos.DSCRollout")
	proto.RegisterType((*DSCRolloutEvent)(nil), "protos.DSCRolloutEvent")
	proto.RegisterType((*DSCRolloutStatusUpdate)(nil), "protos.DSCRolloutStatusUpdate")
	proto.RegisterType((*VeniceOpSpec)(nil), "protos.VeniceOpSpec")
	proto.RegisterType((*VeniceRolloutSpec)(nil), "protos.VeniceRolloutSpec")
	proto.RegisterType((*VeniceOpStatus)(nil), "protos.VeniceOpStatus")
	proto.RegisterType((*VeniceRolloutStatus)(nil), "protos.VeniceRolloutStatus")
	proto.RegisterType((*VeniceRollout)(nil), "protos.VeniceRollout")
	proto.RegisterType((*VeniceRolloutEvent)(nil), "protos.VeniceRolloutEvent")
	proto.RegisterType((*VeniceRolloutStatusUpdate)(nil), "protos.VeniceRolloutStatusUpdate")
	proto.RegisterType((*ServiceOpSpec)(nil), "protos.ServiceOpSpec")
	proto.RegisterType((*ServiceRolloutSpec)(nil), "protos.ServiceRolloutSpec")
	proto.RegisterType((*ServiceOpStatus)(nil), "protos.ServiceOpStatus")
	proto.RegisterType((*ServiceRolloutStatus)(nil), "protos.ServiceRolloutStatus")
	proto.RegisterType((*ServiceRollout)(nil), "protos.ServiceRollout")
	proto.RegisterType((*ServiceRolloutEvent)(nil), "protos.ServiceRolloutEvent")
	proto.RegisterType((*ServiceRolloutStatusUpdate)(nil), "protos.ServiceRolloutStatusUpdate")
	proto.RegisterEnum("protos.DSCOp", DSCOp_name, DSCOp_value)
	proto.RegisterEnum("protos.AllowedStatus", AllowedStatus_name, AllowedStatus_value)
	proto.RegisterEnum("protos.VeniceOp", VeniceOp_name, VeniceOp_value)
	proto.RegisterEnum("protos.ServiceOp", ServiceOp_name, ServiceOp_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DSCRolloutApi service

type DSCRolloutApiClient interface {
	WatchDSCRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (DSCRolloutApi_WatchDSCRolloutClient, error)
	UpdateDSCRolloutStatus(ctx context.Context, in *DSCRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type dSCRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewDSCRolloutApiClient(cc *grpc.ClientConn) DSCRolloutApiClient {
	return &dSCRolloutApiClient{cc}
}

func (c *dSCRolloutApiClient) WatchDSCRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (DSCRolloutApi_WatchDSCRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DSCRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.DSCRolloutApi/WatchDSCRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &dSCRolloutApiWatchDSCRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DSCRolloutApi_WatchDSCRolloutClient interface {
	Recv() (*DSCRolloutEvent, error)
	grpc.ClientStream
}

type dSCRolloutApiWatchDSCRolloutClient struct {
	grpc.ClientStream
}

func (x *dSCRolloutApiWatchDSCRolloutClient) Recv() (*DSCRolloutEvent, error) {
	m := new(DSCRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dSCRolloutApiClient) UpdateDSCRolloutStatus(ctx context.Context, in *DSCRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.DSCRolloutApi/UpdateDSCRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DSCRolloutApi service

type DSCRolloutApiServer interface {
	WatchDSCRollout(*api.ObjectMeta, DSCRolloutApi_WatchDSCRolloutServer) error
	UpdateDSCRolloutStatus(context.Context, *DSCRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterDSCRolloutApiServer(s *grpc.Server, srv DSCRolloutApiServer) {
	s.RegisterService(&_DSCRolloutApi_serviceDesc, srv)
}

func _DSCRolloutApi_WatchDSCRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DSCRolloutApiServer).WatchDSCRollout(m, &dSCRolloutApiWatchDSCRolloutServer{stream})
}

type DSCRolloutApi_WatchDSCRolloutServer interface {
	Send(*DSCRolloutEvent) error
	grpc.ServerStream
}

type dSCRolloutApiWatchDSCRolloutServer struct {
	grpc.ServerStream
}

func (x *dSCRolloutApiWatchDSCRolloutServer) Send(m *DSCRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _DSCRolloutApi_UpdateDSCRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSCRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSCRolloutApiServer).UpdateDSCRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.DSCRolloutApi/UpdateDSCRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSCRolloutApiServer).UpdateDSCRolloutStatus(ctx, req.(*DSCRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _DSCRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.DSCRolloutApi",
	HandlerType: (*DSCRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateDSCRolloutStatus",
			Handler:    _DSCRolloutApi_UpdateDSCRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchDSCRollout",
			Handler:       _DSCRolloutApi_WatchDSCRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

// Client API for VeniceRolloutApi service

type VeniceRolloutApiClient interface {
	WatchVeniceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (VeniceRolloutApi_WatchVeniceRolloutClient, error)
	UpdateVeniceRolloutStatus(ctx context.Context, in *VeniceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type veniceRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewVeniceRolloutApiClient(cc *grpc.ClientConn) VeniceRolloutApiClient {
	return &veniceRolloutApiClient{cc}
}

func (c *veniceRolloutApiClient) WatchVeniceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (VeniceRolloutApi_WatchVeniceRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VeniceRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.VeniceRolloutApi/WatchVeniceRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &veniceRolloutApiWatchVeniceRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VeniceRolloutApi_WatchVeniceRolloutClient interface {
	Recv() (*VeniceRolloutEvent, error)
	grpc.ClientStream
}

type veniceRolloutApiWatchVeniceRolloutClient struct {
	grpc.ClientStream
}

func (x *veniceRolloutApiWatchVeniceRolloutClient) Recv() (*VeniceRolloutEvent, error) {
	m := new(VeniceRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *veniceRolloutApiClient) UpdateVeniceRolloutStatus(ctx context.Context, in *VeniceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.VeniceRolloutApi/UpdateVeniceRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VeniceRolloutApi service

type VeniceRolloutApiServer interface {
	WatchVeniceRollout(*api.ObjectMeta, VeniceRolloutApi_WatchVeniceRolloutServer) error
	UpdateVeniceRolloutStatus(context.Context, *VeniceRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterVeniceRolloutApiServer(s *grpc.Server, srv VeniceRolloutApiServer) {
	s.RegisterService(&_VeniceRolloutApi_serviceDesc, srv)
}

func _VeniceRolloutApi_WatchVeniceRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VeniceRolloutApiServer).WatchVeniceRollout(m, &veniceRolloutApiWatchVeniceRolloutServer{stream})
}

type VeniceRolloutApi_WatchVeniceRolloutServer interface {
	Send(*VeniceRolloutEvent) error
	grpc.ServerStream
}

type veniceRolloutApiWatchVeniceRolloutServer struct {
	grpc.ServerStream
}

func (x *veniceRolloutApiWatchVeniceRolloutServer) Send(m *VeniceRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _VeniceRolloutApi_UpdateVeniceRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VeniceRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VeniceRolloutApiServer).UpdateVeniceRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.VeniceRolloutApi/UpdateVeniceRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VeniceRolloutApiServer).UpdateVeniceRolloutStatus(ctx, req.(*VeniceRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _VeniceRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.VeniceRolloutApi",
	HandlerType: (*VeniceRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateVeniceRolloutStatus",
			Handler:    _VeniceRolloutApi_UpdateVeniceRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchVeniceRollout",
			Handler:       _VeniceRolloutApi_WatchVeniceRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

// Client API for ServiceRolloutApi service

type ServiceRolloutApiClient interface {
	WatchServiceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (ServiceRolloutApi_WatchServiceRolloutClient, error)
	UpdateServiceRolloutStatus(ctx context.Context, in *ServiceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error)
}

type serviceRolloutApiClient struct {
	cc *grpc.ClientConn
}

func NewServiceRolloutApiClient(cc *grpc.ClientConn) ServiceRolloutApiClient {
	return &serviceRolloutApiClient{cc}
}

func (c *serviceRolloutApiClient) WatchServiceRollout(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (ServiceRolloutApi_WatchServiceRolloutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServiceRolloutApi_serviceDesc.Streams[0], c.cc, "/protos.ServiceRolloutApi/WatchServiceRollout", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceRolloutApiWatchServiceRolloutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServiceRolloutApi_WatchServiceRolloutClient interface {
	Recv() (*ServiceRolloutEvent, error)
	grpc.ClientStream
}

type serviceRolloutApiWatchServiceRolloutClient struct {
	grpc.ClientStream
}

func (x *serviceRolloutApiWatchServiceRolloutClient) Recv() (*ServiceRolloutEvent, error) {
	m := new(ServiceRolloutEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serviceRolloutApiClient) UpdateServiceRolloutStatus(ctx context.Context, in *ServiceRolloutStatusUpdate, opts ...grpc.CallOption) (*api1.Empty, error) {
	out := new(api1.Empty)
	err := grpc.Invoke(ctx, "/protos.ServiceRolloutApi/UpdateServiceRolloutStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServiceRolloutApi service

type ServiceRolloutApiServer interface {
	WatchServiceRollout(*api.ObjectMeta, ServiceRolloutApi_WatchServiceRolloutServer) error
	UpdateServiceRolloutStatus(context.Context, *ServiceRolloutStatusUpdate) (*api1.Empty, error)
}

func RegisterServiceRolloutApiServer(s *grpc.Server, srv ServiceRolloutApiServer) {
	s.RegisterService(&_ServiceRolloutApi_serviceDesc, srv)
}

func _ServiceRolloutApi_WatchServiceRollout_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceRolloutApiServer).WatchServiceRollout(m, &serviceRolloutApiWatchServiceRolloutServer{stream})
}

type ServiceRolloutApi_WatchServiceRolloutServer interface {
	Send(*ServiceRolloutEvent) error
	grpc.ServerStream
}

type serviceRolloutApiWatchServiceRolloutServer struct {
	grpc.ServerStream
}

func (x *serviceRolloutApiWatchServiceRolloutServer) Send(m *ServiceRolloutEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _ServiceRolloutApi_UpdateServiceRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceRolloutStatusUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRolloutApiServer).UpdateServiceRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ServiceRolloutApi/UpdateServiceRolloutStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRolloutApiServer).UpdateServiceRolloutStatus(ctx, req.(*ServiceRolloutStatusUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceRolloutApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ServiceRolloutApi",
	HandlerType: (*ServiceRolloutApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateServiceRolloutStatus",
			Handler:    _ServiceRolloutApi_UpdateServiceRolloutStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchServiceRollout",
			Handler:       _ServiceRolloutApi_WatchServiceRollout_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rollout.proto",
}

func (m *DSCOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *DSCRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DSCOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *DSCRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DSCRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *DSCRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.DSCRollout.Size()))
	n4, err := m.DSCRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *DSCRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *VeniceOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *VeniceRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VeniceOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *VeniceRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VeniceRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n7, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n8, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n9, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *VeniceRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.VeniceRollout.Size()))
	n10, err := m.VeniceRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *VeniceRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VeniceRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *ServiceOpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *ServiceRolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, msg := range m.Ops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceOpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOpStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.Op))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.OpStatus) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OpStatus)))
		i += copy(dAtA[i:], m.OpStatus)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ServiceRolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, msg := range m.OpStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceRollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *ServiceRolloutEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ServiceRollout.Size()))
	n16, err := m.ServiceRollout.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *ServiceRolloutStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRolloutStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n17, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n18, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	return i, nil
}

func encodeVarintRollout(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DSCOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *DSCRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *DSCOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *DSCRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *DSCRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *DSCRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.DSCRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *DSCRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *VeniceRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *VeniceOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *VeniceRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *VeniceRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.VeniceRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *VeniceRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceOpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *ServiceRolloutSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *ServiceOpStatus) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRollout(uint64(m.Op))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.OpStatus)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *ServiceRolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.OpStatus) > 0 {
		for _, e := range m.OpStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	return n
}

func (m *ServiceRollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceRolloutEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRollout(uint64(m.EventType))
	}
	l = m.ServiceRollout.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *ServiceRolloutStatusUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func sovRollout(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRollout(x uint64) (n int) {
	return sovRollout(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DSCOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (DSCOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, DSCOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (DSCOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, DSCOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DSCRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (VeniceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, VeniceOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (VeniceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, VeniceOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeniceRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VeniceRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VeniceRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VeniceRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VeniceRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (ServiceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, ServiceOpSpec{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (ServiceOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpStatus = append(m.OpStatus, ServiceOpStatus{})
			if err := m.OpStatus[len(m.OpStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceRollout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceRollout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRolloutStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRolloutStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRolloutStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRollout(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRollout
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRollout
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRollout(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRollout = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRollout   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rollout.proto", fileDescriptorRollout) }

var fileDescriptorRollout = []byte{
	// 1186 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6e, 0xdb, 0x46,
	0x1b, 0xd5, 0xc8, 0x4e, 0x6c, 0x7f, 0x8e, 0x64, 0x66, 0x2c, 0x2b, 0xb4, 0xe2, 0xdf, 0x17, 0x02,
	0xc1, 0xef, 0x1a, 0x8e, 0x55, 0x28, 0x41, 0x17, 0x05, 0x9a, 0x22, 0x92, 0xac, 0xc4, 0xad, 0x6d,
	0x19, 0x52, 0x9c, 0xae, 0xba, 0xa0, 0xa9, 0x29, 0xcd, 0x56, 0xe2, 0x4c, 0xc9, 0x91, 0x5d, 0xbf,
	0x40, 0x9f, 0xa1, 0xdb, 0xa2, 0x28, 0x8a, 0xde, 0x16, 0x7d, 0x89, 0x22, 0x8b, 0xa2, 0xc8, 0x0b,
	0xd4, 0x28, 0x5c, 0x74, 0x93, 0xa7, 0x28, 0x38, 0x43, 0x89, 0x43, 0x8a, 0xbe, 0x00, 0x31, 0x90,
	0xac, 0x22, 0x0e, 0xcf, 0x77, 0xe6, 0xcc, 0x99, 0xf9, 0x0e, 0x27, 0x86, 0x9c, 0x47, 0xbb, 0x5d,
	0xda, 0xe7, 0x1b, 0xcc, 0xa3, 0x9c, 0xe2, 0x9b, 0xe2, 0x1f, 0xbf, 0xb4, 0x60, 0x53, 0x6a, 0x77,
	0x49, 0xd9, 0x64, 0x4e, 0xd9, 0x74, 0x5d, 0xca, 0x4d, 0xee, 0x50, 0xd7, 0x97, 0xa8, 0xd2, 0xa6,
	0xed, 0xf0, 0xc3, 0xfe, 0xc1, 0x86, 0x45, 0x7b, 0x65, 0x46, 0x5c, 0xdf, 0x74, 0x3b, 0xb4, 0xec,
	0x1f, 0x97, 0x8f, 0x88, 0xeb, 0x58, 0xa4, 0xdc, 0xe7, 0x4e, 0xd7, 0x0f, 0x4a, 0x6d, 0xe2, 0xaa,
	0xd5, 0x65, 0xc7, 0xb5, 0xba, 0xfd, 0x0e, 0x19, 0xd0, 0xdc, 0x57, 0x68, 0x6c, 0x6a, 0xd3, 0xb2,
	0x18, 0x3e, 0xe8, 0x7f, 0x26, 0x9e, 0xc4, 0x83, 0xf8, 0x15, 0xc2, 0xef, 0x9d, 0x33, 0x6b, 0xa0,
	0xb1, 0x47, 0xb8, 0x19, 0xc2, 0xfe, 0x7f, 0x01, 0xcc, 0xa2, 0xbd, 0x1e, 0x75, 0x25, 0xd0, 0xf8,
	0x12, 0xa6, 0xea, 0xed, 0x5a, 0x93, 0xb5, 0x19, 0xb1, 0xf0, 0x03, 0xc8, 0x36, 0x99, 0x8e, 0x96,
	0xd1, 0x6a, 0xbe, 0x92, 0x93, 0x00, 0x7f, 0x43, 0xbc, 0xae, 0x16, 0x5e, 0x9c, 0x2e, 0xa1, 0x57,
	0xa7, 0x4b, 0xb7, 0x28, 0x5b, 0xa7, 0x3d, 0x87, 0x93, 0x1e, 0xe3, 0x27, 0xad, 0x6c, 0x93, 0xe1,
	0x32, 0x4c, 0x3c, 0x27, 0x9e, 0xef, 0x50, 0x57, 0xcf, 0x2e, 0xa3, 0xd5, 0xa9, 0xea, 0x5c, 0x08,
	0xcd, 0x1d, 0x11, 0x4f, 0xc1, 0x0e, 0x50, 0xc6, 0x36, 0xe4, 0xeb, 0xed, 0x5a, 0x4b, 0x5a, 0x2e,
	0xe6, 0x7d, 0x1f, 0xc6, 0x9a, 0xcc, 0xd7, 0xd1, 0xf2, 0xd8, 0xea, 0x74, 0xe5, 0x76, 0x6c, 0xe2,
	0xe0, 0xbd, 0x60, 0xcc, 0x04, 0x8c, 0x94, 0xf9, 0x0a, 0x63, 0x50, 0x64, 0xfc, 0x8e, 0x60, 0x5a,
	0x22, 0xb9, 0xc9, 0xfb, 0x3e, 0xfe, 0xdf, 0xb9, 0x6b, 0x10, 0x6a, 0xf5, 0x84, 0xda, 0xa1, 0x2c,
	0xbc, 0x07, 0x93, 0x03, 0x12, 0x7d, 0x4c, 0x2c, 0xe4, 0xe1, 0x4f, 0x5f, 0xcf, 0x17, 0xdb, 0xdc,
	0xdb, 0x74, 0xfb, 0xbd, 0xd5, 0xc7, 0xdd, 0x2e, 0x3d, 0x26, 0x1d, 0x09, 0x78, 0x27, 0x5c, 0x22,
	0xa6, 0xcc, 0x17, 0x03, 0x8a, 0xaa, 0x21, 0x0b, 0x5e, 0x87, 0x89, 0x1d, 0xe2, 0xfb, 0xa6, 0x4d,
	0xf4, 0x71, 0x41, 0x88, 0xc3, 0x32, 0x50, 0x6d, 0x09, 0x21, 0xc6, 0xa7, 0xa0, 0x29, 0xb6, 0x48,
	0x86, 0x2d, 0x45, 0x93, 0x74, 0x67, 0x36, 0xee, 0x8e, 0x78, 0x55, 0xd5, 0x43, 0x7f, 0xb4, 0xf3,
	0xc5, 0x18, 0x7f, 0x21, 0x80, 0x88, 0x1f, 0x3f, 0x82, 0xc9, 0x67, 0x27, 0x8c, 0xec, 0x10, 0x6e,
	0x0a, 0xb3, 0xa6, 0x2b, 0xb9, 0x0d, 0x93, 0x39, 0x1b, 0x83, 0xc1, 0xea, 0x6c, 0xc0, 0xf9, 0x52,
	0xea, 0x9d, 0x58, 0x77, 0xdc, 0xae, 0xe3, 0x92, 0xd6, 0xb0, 0x06, 0x7f, 0x0c, 0xd0, 0x3c, 0xf8,
	0x9c, 0x58, 0x5c, 0x30, 0x64, 0x05, 0xc3, 0x8c, 0x60, 0x88, 0x86, 0xab, 0x25, 0x85, 0x23, 0x1f,
	0x9c, 0x4e, 0x45, 0x99, 0x52, 0x8e, 0xab, 0x30, 0x1e, 0xec, 0xb3, 0xb0, 0x7d, 0xba, 0x52, 0x54,
	0x96, 0xa8, 0x9c, 0x92, 0x6a, 0x31, 0x5c, 0x65, 0xde, 0x67, 0xc4, 0x52, 0x98, 0x44, 0xad, 0xf1,
	0x2d, 0x82, 0x99, 0xa8, 0x60, 0xf3, 0x88, 0xb8, 0x1c, 0x37, 0x60, 0x4a, 0xfc, 0x08, 0x54, 0x87,
	0x47, 0x22, 0x2f, 0x34, 0x0e, 0x47, 0xab, 0xfa, 0xab, 0xd3, 0xa5, 0x02, 0x09, 0x1e, 0xef, 0xf3,
	0x13, 0x46, 0x14, 0xda, 0xa8, 0x14, 0x37, 0x54, 0xeb, 0xc2, 0xc5, 0xe2, 0x51, 0x95, 0x62, 0x7f,
	0x33, 0x89, 0xfd, 0x55, 0x2a, 0x8d, 0xef, 0x10, 0x14, 0x93, 0x7b, 0xbc, 0xcf, 0x3a, 0x26, 0x27,
	0xb8, 0x16, 0xf3, 0x13, 0xa5, 0xfb, 0x99, 0xca, 0xaf, 0xf8, 0x58, 0x87, 0x9b, 0xe1, 0x61, 0x91,
	0x1a, 0xf5, 0x14, 0x27, 0xe5, 0x89, 0x49, 0x63, 0x0a, 0x6b, 0x8d, 0x8f, 0xe0, 0xd6, 0x73, 0x91,
	0x61, 0x61, 0x2a, 0x2c, 0x2b, 0x1d, 0xa5, 0x0d, 0x18, 0x07, 0x88, 0x8b, 0x9b, 0xca, 0x68, 0xc1,
	0x6d, 0x89, 0x54, 0xdb, 0xfd, 0x03, 0xb5, 0xdd, 0x0b, 0x49, 0xc6, 0x4b, 0x3b, 0xfe, 0x0f, 0x04,
	0xf9, 0x21, 0x58, 0xf6, 0xc9, 0x6b, 0x48, 0x7c, 0xe3, 0x7d, 0x6f, 0xc1, 0x6c, 0xdc, 0x22, 0x49,
	0xb2, 0x3d, 0xd2, 0xfa, 0xc5, 0x11, 0xa7, 0xae, 0xde, 0xfd, 0xff, 0x20, 0xc8, 0xc5, 0x66, 0x79,
	0xbb, 0x02, 0x60, 0x33, 0x16, 0x00, 0xf3, 0xf1, 0x85, 0x5e, 0x3d, 0x03, 0x7e, 0x45, 0x80, 0x63,
	0x35, 0xd7, 0x1b, 0x03, 0xcd, 0x84, 0x87, 0xe1, 0xaa, 0xe7, 0x52, 0xe5, 0xa6, 0xb6, 0x58, 0xbc,
	0xde, 0xf8, 0x11, 0xc1, 0x7c, 0xca, 0xde, 0x5f, 0x67, 0x24, 0x3c, 0x49, 0x44, 0xc2, 0xdd, 0x74,
	0x6f, 0x2f, 0x4f, 0x85, 0x6d, 0xc8, 0xb5, 0x89, 0x77, 0x14, 0xc5, 0xc2, 0x8a, 0xd2, 0x73, 0xc3,
	0x6f, 0xf6, 0x10, 0x72, 0x49, 0x2e, 0x3c, 0x03, 0x1c, 0x42, 0xd5, 0x60, 0x78, 0xa4, 0x06, 0xc3,
	0xdc, 0x08, 0xe7, 0xa5, 0xc9, 0xf0, 0x27, 0x82, 0x99, 0x08, 0x2d, 0xfb, 0xe8, 0x75, 0x64, 0xbe,
	0xf1, 0x6c, 0x20, 0x50, 0x48, 0xd8, 0x24, 0x59, 0x76, 0x46, 0xc2, 0xe1, 0xce, 0xa8, 0x5b, 0x57,
	0x4f, 0x87, 0x7f, 0x11, 0xe4, 0xe3, 0xf3, 0xbc, 0x5d, 0xf1, 0xd0, 0x88, 0xc5, 0x43, 0x29, 0xb1,
	0xd4, 0xab, 0xe7, 0xc3, 0x6f, 0x08, 0x66, 0xe3, 0x45, 0xd7, 0x1b, 0x10, 0xad, 0xa4, 0x8d, 0xe1,
	0xc2, 0x8b, 0xe9, 0x8a, 0x53, 0xfb, 0x2d, 0xc1, 0x60, 0xfc, 0x8c, 0xa0, 0x94, 0x76, 0x06, 0xae,
	0x33, 0x24, 0x9e, 0x26, 0x42, 0x62, 0xe1, 0x1c, 0x87, 0x2f, 0x4d, 0x89, 0xb5, 0xef, 0x11, 0xdc,
	0x10, 0x37, 0x53, 0x3c, 0x0d, 0x13, 0xf5, 0x76, 0x6d, 0x97, 0x36, 0x99, 0x96, 0xc1, 0xf7, 0x60,
	0xa5, 0xde, 0xae, 0xed, 0x79, 0xa4, 0x76, 0x48, 0xac, 0x2f, 0x1a, 0xd4, 0xdb, 0x67, 0x76, 0xd3,
	0xdd, 0x25, 0x5f, 0xf1, 0xa7, 0xd4, 0xe7, 0x2d, 0x72, 0x40, 0x29, 0xd7, 0x10, 0x5e, 0x00, 0x3d,
	0x0e, 0xab, 0x3b, 0xbe, 0xd7, 0x67, 0xdc, 0x39, 0x22, 0x5a, 0x16, 0x97, 0xc4, 0xe5, 0x29, 0xad,
	0x72, 0x0c, 0xeb, 0x50, 0xa8, 0xb7, 0x6b, 0x11, 0x7c, 0x9f, 0xd9, 0x9e, 0xd9, 0x21, 0xda, 0x38,
	0x2e, 0x88, 0x6b, 0xf5, 0x56, 0xcf, 0xb4, 0x49, 0x9d, 0x1e, 0xbb, 0x5d, 0x6a, 0x76, 0xb4, 0x1b,
	0x6b, 0xef, 0x41, 0x2e, 0xd6, 0xbc, 0x81, 0xdc, 0x76, 0xdf, 0xb2, 0x88, 0xef, 0x6b, 0x19, 0x3c,
	0x09, 0xe3, 0x0d, 0xd3, 0xe9, 0x6a, 0x08, 0xe7, 0x01, 0xb6, 0xdc, 0x3d, 0x8f, 0xda, 0x5e, 0xf0,
	0x26, 0xbb, 0xf6, 0x10, 0x26, 0x07, 0x5f, 0x5f, 0x8c, 0x07, 0xd7, 0x90, 0x81, 0x60, 0x2d, 0x13,
	0xcc, 0x16, 0x06, 0x6b, 0xdf, 0x0d, 0x43, 0x44, 0x43, 0x6b, 0x06, 0x4c, 0x0d, 0xdb, 0x12, 0xcf,
	0xc1, 0xed, 0x81, 0xad, 0x11, 0x26, 0x53, 0xf9, 0x06, 0x41, 0x2e, 0xba, 0xa6, 0x3d, 0x66, 0x0e,
	0xfe, 0x10, 0x66, 0x3e, 0x31, 0xb9, 0x75, 0xa8, 0xdc, 0xda, 0x93, 0x3b, 0x5b, 0xba, 0x33, 0x7a,
	0xc3, 0x13, 0xc7, 0xd1, 0xc8, 0xbc, 0x8b, 0x70, 0x03, 0x8a, 0xf2, 0x94, 0x8c, 0xfc, 0xbf, 0x62,
	0xf1, 0xbc, 0x8b, 0xa1, 0xc4, 0x97, 0x40, 0x9e, 0xfe, 0x60, 0x6b, 0x8d, 0x4c, 0xe5, 0x07, 0x34,
	0x5c, 0x55, 0xa4, 0x6e, 0x13, 0xb0, 0x50, 0x17, 0xbf, 0x55, 0x8c, 0x08, 0x2c, 0xa5, 0x7e, 0x6f,
	0x22, 0x8d, 0xdb, 0x30, 0x2f, 0xe7, 0x4c, 0xbb, 0x03, 0xad, 0x5c, 0xf0, 0xb1, 0x4a, 0x55, 0xfa,
	0x0b, 0x8a, 0xcc, 0x8d, 0xa4, 0x3e, 0x81, 0x59, 0x21, 0x35, 0x11, 0x71, 0x23, 0x5a, 0xef, 0xa6,
	0x1f, 0xfb, 0x48, 0xec, 0x2e, 0x94, 0xe4, 0xb4, 0xa9, 0xa1, 0x6c, 0x5c, 0xd4, 0x35, 0x69, 0x72,
	0xab, 0xb7, 0x5e, 0x9c, 0x2d, 0xa2, 0x97, 0x67, 0x8b, 0xe8, 0xef, 0xb3, 0x45, 0xb4, 0x87, 0x0e,
	0xe4, 0x1f, 0x1e, 0x1e, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x64, 0xd1, 0xf2, 0xd8, 0x90, 0x10,
	0x00, 0x00,
}
