// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: index.proto

/*
	Package protos is a generated protocol buffer package.

	It is generated from these files:
		index.proto

	It has these top-level messages:
		FlowRec
		Flows
		FlowIdSlice
		FlowIdMap
		FilePtr
		FlowPtr
		FlowPtrMap
		DestMapFlowPtr
		RawLogsShard
*/
package protos

import (
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// FlowRec represents a flow
type FlowRec struct {
	Sourcevrf  uint32 `protobuf:"varint,1,opt,name=sourcevrf,proto3" json:"sourcevrf,omitempty"`
	Destvrf    uint32 `protobuf:"varint,2,opt,name=destvrf,proto3" json:"destvrf,omitempty"`
	Sip        string `protobuf:"bytes,3,opt,name=sip,proto3" json:"sip,omitempty"`
	Dip        string `protobuf:"bytes,4,opt,name=dip,proto3" json:"dip,omitempty"`
	Sport      uint32 `protobuf:"varint,5,opt,name=sport,proto3" json:"sport,omitempty"`
	Dport      uint32 `protobuf:"varint,6,opt,name=dport,proto3" json:"dport,omitempty"`
	Ruleid     uint64 `protobuf:"varint,7,opt,name=ruleid,proto3" json:"ruleid,omitempty"`
	Sessionid  uint64 `protobuf:"varint,8,opt,name=sessionid,proto3" json:"sessionid,omitempty"`
	Flowaction string `protobuf:"bytes,9,opt,name=flowaction,proto3" json:"flowaction,omitempty"`
	Direction  string `protobuf:"bytes,10,opt,name=direction,proto3" json:"direction,omitempty"`
	Action     uint32 `protobuf:"varint,11,opt,name=action,proto3" json:"action,omitempty"`
	Ts         int64  `protobuf:"varint,12,opt,name=ts,proto3" json:"ts,omitempty"`
	Protocol   string `protobuf:"bytes,13,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Icmpid     uint32 `protobuf:"varint,14,opt,name=icmpid,proto3" json:"icmpid,omitempty"`
	Icmptype   uint32 `protobuf:"varint,15,opt,name=icmptype,proto3" json:"icmptype,omitempty"`
	Icmpcode   uint32 `protobuf:"varint,16,opt,name=icmpcode,proto3" json:"icmpcode,omitempty"`
	Iflowbytes uint64 `protobuf:"varint,17,opt,name=iflowbytes,proto3" json:"iflowbytes,omitempty"`
	Rflowbytes uint64 `protobuf:"varint,18,opt,name=rflowbytes,proto3" json:"rflowbytes,omitempty"`
	Appid      string `protobuf:"bytes,19,opt,name=appid,proto3" json:"appid,omitempty"`
	Alg        string `protobuf:"bytes,20,opt,name=alg,proto3" json:"alg,omitempty"`
	Id         string `protobuf:"bytes,21,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *FlowRec) Reset()                    { *m = FlowRec{} }
func (m *FlowRec) String() string            { return proto.CompactTextString(m) }
func (*FlowRec) ProtoMessage()               {}
func (*FlowRec) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{0} }

func (m *FlowRec) GetSourcevrf() uint32 {
	if m != nil {
		return m.Sourcevrf
	}
	return 0
}

func (m *FlowRec) GetDestvrf() uint32 {
	if m != nil {
		return m.Destvrf
	}
	return 0
}

func (m *FlowRec) GetSip() string {
	if m != nil {
		return m.Sip
	}
	return ""
}

func (m *FlowRec) GetDip() string {
	if m != nil {
		return m.Dip
	}
	return ""
}

func (m *FlowRec) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FlowRec) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

func (m *FlowRec) GetRuleid() uint64 {
	if m != nil {
		return m.Ruleid
	}
	return 0
}

func (m *FlowRec) GetSessionid() uint64 {
	if m != nil {
		return m.Sessionid
	}
	return 0
}

func (m *FlowRec) GetFlowaction() string {
	if m != nil {
		return m.Flowaction
	}
	return ""
}

func (m *FlowRec) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *FlowRec) GetAction() uint32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *FlowRec) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *FlowRec) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FlowRec) GetIcmpid() uint32 {
	if m != nil {
		return m.Icmpid
	}
	return 0
}

func (m *FlowRec) GetIcmptype() uint32 {
	if m != nil {
		return m.Icmptype
	}
	return 0
}

func (m *FlowRec) GetIcmpcode() uint32 {
	if m != nil {
		return m.Icmpcode
	}
	return 0
}

func (m *FlowRec) GetIflowbytes() uint64 {
	if m != nil {
		return m.Iflowbytes
	}
	return 0
}

func (m *FlowRec) GetRflowbytes() uint64 {
	if m != nil {
		return m.Rflowbytes
	}
	return 0
}

func (m *FlowRec) GetAppid() string {
	if m != nil {
		return m.Appid
	}
	return ""
}

func (m *FlowRec) GetAlg() string {
	if m != nil {
		return m.Alg
	}
	return ""
}

func (m *FlowRec) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Flows represents a slice of flow records
type Flows struct {
	Flows []*FlowRec `protobuf:"bytes,1,rep,name=flows" json:"flows,omitempty"`
}

func (m *Flows) Reset()                    { *m = Flows{} }
func (m *Flows) String() string            { return proto.CompactTextString(m) }
func (*Flows) ProtoMessage()               {}
func (*Flows) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{1} }

func (m *Flows) GetFlows() []*FlowRec {
	if m != nil {
		return m.Flows
	}
	return nil
}

// FlowIdSlice represents a slice of flow ids that point to flows in Flows slice
type FlowIdSlice struct {
	Flowids []uint32 `protobuf:"varint,1,rep,packed,name=flowids" json:"flowids,omitempty"`
}

func (m *FlowIdSlice) Reset()                    { *m = FlowIdSlice{} }
func (m *FlowIdSlice) String() string            { return proto.CompactTextString(m) }
func (*FlowIdSlice) ProtoMessage()               {}
func (*FlowIdSlice) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{2} }

func (m *FlowIdSlice) GetFlowids() []uint32 {
	if m != nil {
		return m.Flowids
	}
	return nil
}

// FlowIdMap represents a map of csvfile to flow ids
type FlowIdMap struct {
	// key = CSv file name
	// Value = ids of the flows within the csv file
	Flowids map[string]*FlowIdSlice `protobuf:"bytes,1,rep,name=flowids" json:"flowids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FlowIdMap) Reset()                    { *m = FlowIdMap{} }
func (m *FlowIdMap) String() string            { return proto.CompactTextString(m) }
func (*FlowIdMap) ProtoMessage()               {}
func (*FlowIdMap) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{3} }

func (m *FlowIdMap) GetFlowids() map[string]*FlowIdSlice {
	if m != nil {
		return m.Flowids
	}
	return nil
}

// FilePtr represents pointer to the chunk in a file where the FlowIdSlice is stored
type FilePtr struct {
	Offset int64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Size_  int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *FilePtr) Reset()                    { *m = FilePtr{} }
func (m *FilePtr) String() string            { return proto.CompactTextString(m) }
func (*FilePtr) ProtoMessage()               {}
func (*FilePtr) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{4} }

func (m *FilePtr) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FilePtr) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

// FlowPtr represents pointer to the chunk in the file where the flows are stored
type FlowPtr struct {
	Offset int64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Size_  int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *FlowPtr) Reset()                    { *m = FlowPtr{} }
func (m *FlowPtr) String() string            { return proto.CompactTextString(m) }
func (*FlowPtr) ProtoMessage()               {}
func (*FlowPtr) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{5} }

func (m *FlowPtr) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FlowPtr) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type FlowPtrMap struct {
	PreviousOffset int64      `protobuf:"varint,1,opt,name=previousOffset,proto3" json:"previousOffset,omitempty"`
	Flowptrs       []*FlowPtr `protobuf:"bytes,2,rep,name=flowptrs" json:"flowptrs,omitempty"`
}

func (m *FlowPtrMap) Reset()                    { *m = FlowPtrMap{} }
func (m *FlowPtrMap) String() string            { return proto.CompactTextString(m) }
func (*FlowPtrMap) ProtoMessage()               {}
func (*FlowPtrMap) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{6} }

func (m *FlowPtrMap) GetPreviousOffset() int64 {
	if m != nil {
		return m.PreviousOffset
	}
	return 0
}

func (m *FlowPtrMap) GetFlowptrs() []*FlowPtr {
	if m != nil {
		return m.Flowptrs
	}
	return nil
}

// DestMapFlowPtr represents the a substructure used in indexing SrcDest flows
// Its used in RawLogsShard structure
type DestMapFlowPtr struct {
	DestMapTemp map[uint32]FlowPtrMap `protobuf:"bytes,1,rep,name=destMapTemp" json:"destMapTemp" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	DestMap     map[uint32]FilePtr    `protobuf:"bytes,2,rep,name=destMap" json:"destMap" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DestMapFlowPtr) Reset()                    { *m = DestMapFlowPtr{} }
func (m *DestMapFlowPtr) String() string            { return proto.CompactTextString(m) }
func (*DestMapFlowPtr) ProtoMessage()               {}
func (*DestMapFlowPtr) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{7} }

func (m *DestMapFlowPtr) GetDestMapTemp() map[uint32]FlowPtrMap {
	if m != nil {
		return m.DestMapTemp
	}
	return nil
}

func (m *DestMapFlowPtr) GetDestMap() map[uint32]FilePtr {
	if m != nil {
		return m.DestMap
	}
	return nil
}

// RawLogsShard represents a sharded index of raw logs
type RawLogsShard struct {
	Startts      int64                     `protobuf:"varint,1,opt,name=startts,proto3" json:"startts,omitempty"`
	Endts        int64                     `protobuf:"varint,2,opt,name=endts,proto3" json:"endts,omitempty"`
	Id           uint32                    `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Datafilename string                    `protobuf:"bytes,4,opt,name=datafilename,proto3" json:"datafilename,omitempty"`
	Ipid         map[string]uint32         `protobuf:"bytes,5,rep,name=ipid" json:"ipid,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DestidxsTemp map[uint32]FlowPtrMap     `protobuf:"bytes,6,rep,name=destidxsTemp" json:"destidxsTemp" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Destidxs     map[uint32]FilePtr        `protobuf:"bytes,7,rep,name=destidxs" json:"destidxs" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Srcdestidxs  map[uint32]DestMapFlowPtr `protobuf:"bytes,8,rep,name=srcdestidxs" json:"srcdestidxs" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RawLogsShard) Reset()                    { *m = RawLogsShard{} }
func (m *RawLogsShard) String() string            { return proto.CompactTextString(m) }
func (*RawLogsShard) ProtoMessage()               {}
func (*RawLogsShard) Descriptor() ([]byte, []int) { return fileDescriptorIndex, []int{8} }

func (m *RawLogsShard) GetStartts() int64 {
	if m != nil {
		return m.Startts
	}
	return 0
}

func (m *RawLogsShard) GetEndts() int64 {
	if m != nil {
		return m.Endts
	}
	return 0
}

func (m *RawLogsShard) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RawLogsShard) GetDatafilename() string {
	if m != nil {
		return m.Datafilename
	}
	return ""
}

func (m *RawLogsShard) GetIpid() map[string]uint32 {
	if m != nil {
		return m.Ipid
	}
	return nil
}

func (m *RawLogsShard) GetDestidxsTemp() map[uint32]FlowPtrMap {
	if m != nil {
		return m.DestidxsTemp
	}
	return nil
}

func (m *RawLogsShard) GetDestidxs() map[uint32]FilePtr {
	if m != nil {
		return m.Destidxs
	}
	return nil
}

func (m *RawLogsShard) GetSrcdestidxs() map[uint32]DestMapFlowPtr {
	if m != nil {
		return m.Srcdestidxs
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowRec)(nil), "protos.FlowRec")
	proto.RegisterType((*Flows)(nil), "protos.Flows")
	proto.RegisterType((*FlowIdSlice)(nil), "protos.FlowIdSlice")
	proto.RegisterType((*FlowIdMap)(nil), "protos.FlowIdMap")
	proto.RegisterType((*FilePtr)(nil), "protos.FilePtr")
	proto.RegisterType((*FlowPtr)(nil), "protos.FlowPtr")
	proto.RegisterType((*FlowPtrMap)(nil), "protos.FlowPtrMap")
	proto.RegisterType((*DestMapFlowPtr)(nil), "protos.DestMapFlowPtr")
	proto.RegisterType((*RawLogsShard)(nil), "protos.RawLogsShard")
}
func (m *FlowRec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowRec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sourcevrf != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Sourcevrf))
	}
	if m.Destvrf != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Destvrf))
	}
	if len(m.Sip) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Sip)))
		i += copy(dAtA[i:], m.Sip)
	}
	if len(m.Dip) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Dip)))
		i += copy(dAtA[i:], m.Dip)
	}
	if m.Sport != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Sport))
	}
	if m.Dport != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Dport))
	}
	if m.Ruleid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Ruleid))
	}
	if m.Sessionid != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Sessionid))
	}
	if len(m.Flowaction) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Flowaction)))
		i += copy(dAtA[i:], m.Flowaction)
	}
	if len(m.Direction) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if m.Action != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Action))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Ts))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Icmpid != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Icmpid))
	}
	if m.Icmptype != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Icmptype))
	}
	if m.Icmpcode != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Icmpcode))
	}
	if m.Iflowbytes != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Iflowbytes))
	}
	if m.Rflowbytes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Rflowbytes))
	}
	if len(m.Appid) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Appid)))
		i += copy(dAtA[i:], m.Appid)
	}
	if len(m.Alg) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Alg)))
		i += copy(dAtA[i:], m.Alg)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *Flows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flows) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, msg := range m.Flows {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIndex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowIdSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowIdSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flowids) > 0 {
		dAtA2 := make([]byte, len(m.Flowids)*10)
		var j1 int
		for _, num := range m.Flowids {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintIndex(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *FlowIdMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowIdMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flowids) > 0 {
		for k, _ := range m.Flowids {
			dAtA[i] = 0xa
			i++
			v := m.Flowids[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovIndex(uint64(len(k))) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIndex(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintIndex(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *FilePtr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilePtr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Offset))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *FlowPtr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowPtr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Offset))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *FlowPtrMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowPtrMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PreviousOffset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.PreviousOffset))
	}
	if len(m.Flowptrs) > 0 {
		for _, msg := range m.Flowptrs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DestMapFlowPtr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestMapFlowPtr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestMapTemp) > 0 {
		for k, _ := range m.DestMapTemp {
			dAtA[i] = 0xa
			i++
			v := m.DestMapTemp[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + sovIndex(uint64(k)) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintIndex(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64((&v).Size()))
			n4, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n4
		}
	}
	if len(m.DestMap) > 0 {
		for k, _ := range m.DestMap {
			dAtA[i] = 0x12
			i++
			v := m.DestMap[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + sovIndex(uint64(k)) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintIndex(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64((&v).Size()))
			n5, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n5
		}
	}
	return i, nil
}

func (m *RawLogsShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawLogsShard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Startts != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Startts))
	}
	if m.Endts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Endts))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIndex(dAtA, i, uint64(m.Id))
	}
	if len(m.Datafilename) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIndex(dAtA, i, uint64(len(m.Datafilename)))
		i += copy(dAtA[i:], m.Datafilename)
	}
	if len(m.Ipid) > 0 {
		for k, _ := range m.Ipid {
			dAtA[i] = 0x2a
			i++
			v := m.Ipid[k]
			mapSize := 1 + len(k) + sovIndex(uint64(len(k))) + 1 + sovIndex(uint64(v))
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIndex(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintIndex(dAtA, i, uint64(v))
		}
	}
	if len(m.DestidxsTemp) > 0 {
		for k, _ := range m.DestidxsTemp {
			dAtA[i] = 0x32
			i++
			v := m.DestidxsTemp[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + sovIndex(uint64(k)) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintIndex(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64((&v).Size()))
			n6, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n6
		}
	}
	if len(m.Destidxs) > 0 {
		for k, _ := range m.Destidxs {
			dAtA[i] = 0x3a
			i++
			v := m.Destidxs[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + sovIndex(uint64(k)) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintIndex(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64((&v).Size()))
			n7, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n7
		}
	}
	if len(m.Srcdestidxs) > 0 {
		for k, _ := range m.Srcdestidxs {
			dAtA[i] = 0x42
			i++
			v := m.Srcdestidxs[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovIndex(uint64(msgSize))
			}
			mapSize := 1 + sovIndex(uint64(k)) + msgSize
			i = encodeVarintIndex(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintIndex(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintIndex(dAtA, i, uint64((&v).Size()))
			n8, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n8
		}
	}
	return i, nil
}

func encodeVarintIndex(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlowRec) Size() (n int) {
	var l int
	_ = l
	if m.Sourcevrf != 0 {
		n += 1 + sovIndex(uint64(m.Sourcevrf))
	}
	if m.Destvrf != 0 {
		n += 1 + sovIndex(uint64(m.Destvrf))
	}
	l = len(m.Sip)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	l = len(m.Dip)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	if m.Sport != 0 {
		n += 1 + sovIndex(uint64(m.Sport))
	}
	if m.Dport != 0 {
		n += 1 + sovIndex(uint64(m.Dport))
	}
	if m.Ruleid != 0 {
		n += 1 + sovIndex(uint64(m.Ruleid))
	}
	if m.Sessionid != 0 {
		n += 1 + sovIndex(uint64(m.Sessionid))
	}
	l = len(m.Flowaction)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovIndex(uint64(m.Action))
	}
	if m.Ts != 0 {
		n += 1 + sovIndex(uint64(m.Ts))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	if m.Icmpid != 0 {
		n += 1 + sovIndex(uint64(m.Icmpid))
	}
	if m.Icmptype != 0 {
		n += 1 + sovIndex(uint64(m.Icmptype))
	}
	if m.Icmpcode != 0 {
		n += 2 + sovIndex(uint64(m.Icmpcode))
	}
	if m.Iflowbytes != 0 {
		n += 2 + sovIndex(uint64(m.Iflowbytes))
	}
	if m.Rflowbytes != 0 {
		n += 2 + sovIndex(uint64(m.Rflowbytes))
	}
	l = len(m.Appid)
	if l > 0 {
		n += 2 + l + sovIndex(uint64(l))
	}
	l = len(m.Alg)
	if l > 0 {
		n += 2 + l + sovIndex(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 2 + l + sovIndex(uint64(l))
	}
	return n
}

func (m *Flows) Size() (n int) {
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.Size()
			n += 1 + l + sovIndex(uint64(l))
		}
	}
	return n
}

func (m *FlowIdSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.Flowids) > 0 {
		l = 0
		for _, e := range m.Flowids {
			l += sovIndex(uint64(e))
		}
		n += 1 + sovIndex(uint64(l)) + l
	}
	return n
}

func (m *FlowIdMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Flowids) > 0 {
		for k, v := range m.Flowids {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovIndex(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovIndex(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FilePtr) Size() (n int) {
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovIndex(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovIndex(uint64(m.Size_))
	}
	return n
}

func (m *FlowPtr) Size() (n int) {
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovIndex(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovIndex(uint64(m.Size_))
	}
	return n
}

func (m *FlowPtrMap) Size() (n int) {
	var l int
	_ = l
	if m.PreviousOffset != 0 {
		n += 1 + sovIndex(uint64(m.PreviousOffset))
	}
	if len(m.Flowptrs) > 0 {
		for _, e := range m.Flowptrs {
			l = e.Size()
			n += 1 + l + sovIndex(uint64(l))
		}
	}
	return n
}

func (m *DestMapFlowPtr) Size() (n int) {
	var l int
	_ = l
	if len(m.DestMapTemp) > 0 {
		for k, v := range m.DestMapTemp {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovIndex(uint64(k)) + 1 + l + sovIndex(uint64(l))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	if len(m.DestMap) > 0 {
		for k, v := range m.DestMap {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovIndex(uint64(k)) + 1 + l + sovIndex(uint64(l))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RawLogsShard) Size() (n int) {
	var l int
	_ = l
	if m.Startts != 0 {
		n += 1 + sovIndex(uint64(m.Startts))
	}
	if m.Endts != 0 {
		n += 1 + sovIndex(uint64(m.Endts))
	}
	if m.Id != 0 {
		n += 1 + sovIndex(uint64(m.Id))
	}
	l = len(m.Datafilename)
	if l > 0 {
		n += 1 + l + sovIndex(uint64(l))
	}
	if len(m.Ipid) > 0 {
		for k, v := range m.Ipid {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIndex(uint64(len(k))) + 1 + sovIndex(uint64(v))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	if len(m.DestidxsTemp) > 0 {
		for k, v := range m.DestidxsTemp {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovIndex(uint64(k)) + 1 + l + sovIndex(uint64(l))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	if len(m.Destidxs) > 0 {
		for k, v := range m.Destidxs {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovIndex(uint64(k)) + 1 + l + sovIndex(uint64(l))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	if len(m.Srcdestidxs) > 0 {
		for k, v := range m.Srcdestidxs {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovIndex(uint64(k)) + 1 + l + sovIndex(uint64(l))
			n += mapEntrySize + 1 + sovIndex(uint64(mapEntrySize))
		}
	}
	return n
}

func sovIndex(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIndex(x uint64) (n int) {
	return sovIndex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowRec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowRec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowRec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sourcevrf", wireType)
			}
			m.Sourcevrf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sourcevrf |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destvrf", wireType)
			}
			m.Destvrf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destvrf |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sport", wireType)
			}
			m.Sport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dport", wireType)
			}
			m.Dport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ruleid", wireType)
			}
			m.Ruleid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ruleid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessionid", wireType)
			}
			m.Sessionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sessionid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flowaction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flowaction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpid", wireType)
			}
			m.Icmpid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmptype", wireType)
			}
			m.Icmptype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmptype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpcode", wireType)
			}
			m.Icmpcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpcode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iflowbytes", wireType)
			}
			m.Iflowbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iflowbytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rflowbytes", wireType)
			}
			m.Rflowbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rflowbytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, &FlowRec{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowIdSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowIdSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowIdSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flowids = append(m.Flowids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIndex
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flowids = append(m.Flowids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flowids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowIdMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowIdMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowIdMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flowids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flowids == nil {
				m.Flowids = make(map[string]*FlowIdSlice)
			}
			var mapkey string
			var mapvalue *FlowIdSlice
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIndex
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FlowIdSlice{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Flowids[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilePtr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilePtr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilePtr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowPtr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowPtr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowPtr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowPtrMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowPtrMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowPtrMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousOffset", wireType)
			}
			m.PreviousOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flowptrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flowptrs = append(m.Flowptrs, &FlowPtr{})
			if err := m.Flowptrs[len(m.Flowptrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestMapFlowPtr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestMapFlowPtr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestMapFlowPtr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestMapTemp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestMapTemp == nil {
				m.DestMapTemp = make(map[uint32]FlowPtrMap)
			}
			var mapkey uint32
			mapvalue := &FlowPtrMap{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FlowPtrMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DestMapTemp[mapkey] = *mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestMap == nil {
				m.DestMap = make(map[uint32]FilePtr)
			}
			var mapkey uint32
			mapvalue := &FilePtr{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FilePtr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DestMap[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawLogsShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawLogsShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawLogsShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startts", wireType)
			}
			m.Startts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Startts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endts", wireType)
			}
			m.Endts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Endts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datafilename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datafilename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipid == nil {
				m.Ipid = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIndex
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ipid[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestidxsTemp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestidxsTemp == nil {
				m.DestidxsTemp = make(map[uint32]FlowPtrMap)
			}
			var mapkey uint32
			mapvalue := &FlowPtrMap{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FlowPtrMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DestidxsTemp[mapkey] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destidxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destidxs == nil {
				m.Destidxs = make(map[uint32]FilePtr)
			}
			var mapkey uint32
			mapvalue := &FilePtr{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FilePtr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Destidxs[mapkey] = *mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srcdestidxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Srcdestidxs == nil {
				m.Srcdestidxs = make(map[uint32]DestMapFlowPtr)
			}
			var mapkey uint32
			mapvalue := &DestMapFlowPtr{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndex
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthIndex
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DestMapFlowPtr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndex(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIndex
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Srcdestidxs[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIndex
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIndex
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIndex(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIndex = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndex   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("index.proto", fileDescriptorIndex) }

var fileDescriptorIndex = []byte{
	// 844 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0x66, 0xfd, 0x13, 0xdb, 0xc7, 0x76, 0x9a, 0x4e, 0x43, 0x35, 0xb2, 0x90, 0xb1, 0x8c, 0xd2,
	0x1a, 0x01, 0xae, 0x14, 0x84, 0xa8, 0xb8, 0x2c, 0xa1, 0x52, 0x45, 0xad, 0x44, 0x1b, 0xc4, 0xfd,
	0x66, 0x67, 0xec, 0x8e, 0xd8, 0x78, 0x46, 0x3b, 0xe3, 0xa4, 0xe1, 0x2d, 0xb8, 0xe1, 0x7d, 0xb8,
	0xa2, 0x97, 0x3c, 0x01, 0x42, 0x79, 0x12, 0x74, 0xce, 0xec, 0x7a, 0x67, 0x53, 0xab, 0x52, 0x95,
	0x2b, 0xcf, 0xf7, 0x9d, 0x73, 0xbe, 0x39, 0x7f, 0xb3, 0x32, 0xf4, 0xd5, 0x5a, 0xc8, 0xb7, 0x73,
	0x93, 0x6b, 0xa7, 0xd9, 0x1e, 0xfd, 0xd8, 0xd1, 0x37, 0x2b, 0xe5, 0xde, 0x6c, 0x2e, 0xe6, 0xa9,
	0xbe, 0x7c, 0xb6, 0xd2, 0x2b, 0xfd, 0x8c, 0xf8, 0x8b, 0xcd, 0x92, 0x10, 0x01, 0x3a, 0xf9, 0xb0,
	0xe9, 0x1f, 0x2d, 0xe8, 0xbc, 0xcc, 0xf4, 0x75, 0x2c, 0x53, 0xf6, 0x19, 0xf4, 0xac, 0xde, 0xe4,
	0xa9, 0xbc, 0xca, 0x97, 0x3c, 0x9a, 0x44, 0xb3, 0x61, 0x5c, 0x11, 0x8c, 0x43, 0x47, 0x48, 0xeb,
	0xd0, 0xd6, 0x20, 0x5b, 0x09, 0xd9, 0x01, 0x34, 0xad, 0x32, 0xbc, 0x39, 0x89, 0x66, 0xbd, 0x18,
	0x8f, 0xc8, 0x08, 0x65, 0x78, 0xcb, 0x33, 0x42, 0x19, 0x76, 0x08, 0x6d, 0x6b, 0x74, 0xee, 0x78,
	0x9b, 0x62, 0x3d, 0x40, 0x56, 0x10, 0xbb, 0xe7, 0x59, 0x02, 0xec, 0x31, 0xec, 0xe5, 0x9b, 0x4c,
	0x2a, 0xc1, 0x3b, 0x93, 0x68, 0xd6, 0x8a, 0x0b, 0x44, 0xf9, 0x49, 0x6b, 0x95, 0x5e, 0x2b, 0xc1,
	0xbb, 0x64, 0xaa, 0x08, 0x36, 0x06, 0x58, 0x66, 0xfa, 0x3a, 0x49, 0x9d, 0xd2, 0x6b, 0xde, 0xa3,
	0xab, 0x03, 0x06, 0xa3, 0x85, 0xca, 0xa5, 0x37, 0x03, 0x99, 0x2b, 0x02, 0xef, 0x2c, 0x22, 0xfb,
	0x94, 0x4a, 0x81, 0xd8, 0x3e, 0x34, 0x9c, 0xe5, 0x83, 0x49, 0x34, 0x6b, 0xc6, 0x0d, 0x67, 0xd9,
	0x08, 0xba, 0xd4, 0xb8, 0x54, 0x67, 0x7c, 0x48, 0x22, 0x5b, 0x8c, 0x1a, 0x2a, 0xbd, 0x34, 0x4a,
	0xf0, 0x7d, 0xaf, 0xe1, 0x11, 0xc6, 0xe0, 0xc9, 0xdd, 0x18, 0xc9, 0x1f, 0x90, 0x65, 0x8b, 0x4b,
	0x5b, 0xaa, 0x85, 0xe4, 0x07, 0x95, 0x0d, 0x31, 0x56, 0xa4, 0xb0, 0x80, 0x8b, 0x1b, 0x27, 0x2d,
	0x7f, 0x48, 0x05, 0x07, 0x0c, 0xda, 0xf3, 0xca, 0xce, 0xbc, 0xbd, 0x62, 0xb0, 0xbb, 0x89, 0xc1,
	0x74, 0x1e, 0x51, 0xa2, 0x1e, 0xe0, 0x6c, 0x92, 0x6c, 0xc5, 0x0f, 0xfd, 0x6c, 0x92, 0x6c, 0x85,
	0x35, 0x2a, 0xc1, 0x3f, 0x25, 0xa2, 0xa1, 0xc4, 0x74, 0x0e, 0x6d, 0x5c, 0x09, 0xcb, 0x8e, 0xa0,
	0x8d, 0x6a, 0x96, 0x47, 0x93, 0xe6, 0xac, 0x7f, 0xfc, 0xc0, 0xef, 0x8c, 0x9d, 0x17, 0x0b, 0x13,
	0x7b, 0xeb, 0xf4, 0x29, 0xf4, 0x91, 0x79, 0x25, 0xce, 0x33, 0x95, 0x4a, 0x5c, 0x14, 0xe4, 0x95,
	0xf0, 0x71, 0xc3, 0xb8, 0x84, 0xd3, 0x3f, 0x23, 0xe8, 0x79, 0xcf, 0x45, 0x62, 0xd8, 0xf3, 0xba,
	0x5f, 0xff, 0x78, 0x1c, 0xea, 0x93, 0x0f, 0x9d, 0x94, 0xb0, 0x3f, 0xad, 0x5d, 0x7e, 0xb3, 0xd5,
	0x19, 0x9d, 0xc2, 0x20, 0x34, 0x60, 0x49, 0xbf, 0xc9, 0x1b, 0x5a, 0xd9, 0x5e, 0x8c, 0x47, 0xf6,
	0x25, 0xb4, 0xaf, 0x92, 0x6c, 0x23, 0x69, 0x55, 0xfb, 0xc7, 0x8f, 0xea, 0xca, 0x94, 0x67, 0xec,
	0x3d, 0x7e, 0x68, 0x3c, 0x8f, 0xa6, 0xdf, 0x41, 0xe7, 0xa5, 0xca, 0xe4, 0x99, 0xcb, 0x71, 0x88,
	0x7a, 0xb9, 0xb4, 0xd2, 0x91, 0x5c, 0x33, 0x2e, 0x10, 0x63, 0xd0, 0xb2, 0xea, 0x77, 0x2f, 0xd8,
	0x8c, 0xe9, 0x4c, 0x61, 0x99, 0xbe, 0xfe, 0xd8, 0xb0, 0x04, 0xa0, 0x08, 0xc3, 0x36, 0x3c, 0x81,
	0x7d, 0x93, 0xcb, 0x2b, 0xa5, 0x37, 0xf6, 0x34, 0x54, 0xb8, 0xc3, 0xb2, 0xaf, 0xa0, 0x8b, 0xf5,
	0x1b, 0x97, 0x5b, 0xde, 0x78, 0x7f, 0x1e, 0x67, 0x2e, 0x8f, 0xb7, 0x0e, 0xd3, 0xbf, 0x1b, 0xb0,
	0x7f, 0x22, 0xad, 0x5b, 0x24, 0xa6, 0xcc, 0xf0, 0x14, 0xfa, 0xc2, 0x33, 0xbf, 0xc8, 0x4b, 0x53,
	0xb4, 0xfc, 0x69, 0x29, 0x51, 0x77, 0x2e, 0x21, 0x7a, 0x52, 0x8b, 0x5f, 0xb4, 0xde, 0xfd, 0xfb,
	0xf9, 0x27, 0x71, 0xa8, 0xc0, 0x7e, 0xf4, 0x1f, 0x84, 0x45, 0x62, 0x8a, 0x7c, 0xbe, 0xf8, 0xb0,
	0x58, 0x28, 0x54, 0x46, 0x8e, 0x62, 0x38, 0xb8, 0x7b, 0x57, 0x38, 0xce, 0xa1, 0x1f, 0xe7, 0xac,
	0x3e, 0x4e, 0x76, 0xa7, 0xf0, 0x45, 0x62, 0x82, 0x69, 0x8e, 0x7e, 0x86, 0x41, 0x78, 0xe5, 0x0e,
	0xbd, 0xa3, 0xba, 0x5e, 0xd5, 0x48, 0xbf, 0x04, 0xe1, 0x6a, 0xfc, 0xd5, 0x86, 0x41, 0x9c, 0x5c,
	0xbf, 0xd6, 0x2b, 0x7b, 0xfe, 0x26, 0xc9, 0x05, 0xae, 0xb7, 0x75, 0x49, 0xee, 0x9c, 0x2d, 0x06,
	0x55, 0x42, 0x7c, 0x6f, 0x72, 0x2d, 0x9c, 0x2d, 0x86, 0xed, 0x41, 0xf1, 0xba, 0x9a, 0x74, 0x79,
	0x43, 0x09, 0x36, 0x85, 0x81, 0x48, 0x5c, 0xb2, 0x54, 0x99, 0x5c, 0x27, 0x97, 0xb2, 0xf8, 0x48,
	0xd6, 0x38, 0x76, 0x0c, 0x2d, 0x85, 0x0f, 0xb7, 0x5d, 0x7f, 0x17, 0x61, 0x1e, 0xf3, 0x57, 0x46,
	0x09, 0xff, 0x2e, 0xc8, 0x97, 0x9d, 0xc1, 0x00, 0x9b, 0xaa, 0xc4, 0x5b, 0x4b, 0x03, 0xde, 0xa3,
	0xd8, 0x27, 0x3b, 0x63, 0x4f, 0x02, 0xc7, 0x70, 0x2c, 0x35, 0x05, 0x76, 0x02, 0xdd, 0x12, 0xf3,
	0x0e, 0xa9, 0x4d, 0x3f, 0xa8, 0x16, 0x2a, 0x6d, 0x23, 0xd9, 0x02, 0xfa, 0x36, 0x4f, 0xb7, 0x42,
	0x5d, 0x12, 0x3a, 0xda, 0x29, 0x74, 0x5e, 0xf9, 0xd5, 0xb6, 0x2e, 0x88, 0x1f, 0x7d, 0x0f, 0xbd,
	0x6d, 0xe5, 0x3b, 0x1e, 0xfe, 0x61, 0x38, 0xd9, 0x61, 0xb8, 0x15, 0xe7, 0xf0, 0xf0, 0xbd, 0xb2,
	0xef, 0xbd, 0x6a, 0xaf, 0x61, 0x58, 0xab, 0xfe, 0x5e, 0xbb, 0x36, 0xfa, 0x15, 0x0e, 0xee, 0xb6,
	0x60, 0x87, 0xe0, 0xd7, 0x75, 0xc1, 0xc7, 0xbb, 0x5f, 0x5d, 0xa0, 0xfb, 0x62, 0xf0, 0xee, 0x76,
	0x1c, 0xfd, 0x73, 0x3b, 0x8e, 0xfe, 0xbb, 0x1d, 0x47, 0x17, 0xfe, 0x9f, 0xc2, 0xb7, 0xff, 0x07,
	0x00, 0x00, 0xff, 0xff, 0xba, 0x78, 0xfb, 0x80, 0x3f, 0x08, 0x00, 0x00,
}
