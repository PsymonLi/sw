// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: {{.Name}}
*/
package ctkit {{$pkgname := .GoPkg.Name}}

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/bookstore"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
)

{{$pkg := . }}{{range .Services}}{{$svc := . }}{{$srvname := .Name}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}
{{$crudobjs := getSvcCrudObjects .}}{{range $crudobjs}}


// {{.}} is a wrapper object that implements additional functionality
type {{.}} struct {
	sync.Mutex
	{{$pkgname}}.{{.}}
	HandlerCtx interface{}   // additional state handlers can store
	ctrler     *ctrlerCtx    // reference back to the controller instance
}

func (obj *{{.}}) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("{{.}}_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.{{$srvname}}().{{.}}().UpdateStatus(context.Background(), &obj.{{.}})
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.{{$srvname}}().{{.}}().Create(context.Background(), &obj.{{.}})
	}

	return nil
}

// {{.}}Handler is the event handler for {{.}} object
type {{.}}Handler interface {
	On{{.}}Create(obj *{{.}}) error
	On{{.}}Update(oldObj *{{.}}, newObj *{{$pkgname}}.{{.}}) error
	On{{.}}Delete(obj *{{.}}) error
	Get{{.}}WatchOptions() *api.ListWatchOptions
	On{{.}}Reconnect()
}

// On{{.}}Create is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) On{{.}}Create(obj *{{.}}) error {
	log.Info("On{{.}}Create is not implemented")
	return nil
}

// On{{.}}Update is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) On{{.}}Update(oldObj *{{.}}, newObj *{{$pkgname}}.{{.}}) error {
	log.Info("On{{.}}Update is not implemented")
	return nil
}

// On{{.}}Delete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) On{{.}}Delete(obj *{{.}}) error {
	log.Info("On{{.}}Delete is not implemented")
	return nil
}

// Get{{.}}WatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) Get{{.}}WatchOptions() *api.ListWatchOptions {
	log.Info("Get{{.}}WatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// On{{.}}Reconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) On{{.}}Reconnect() {
	log.Info("On{{.}}Reconnect is not implemented")
	return
}


// handle{{.}}Event handles {{.}} events from watcher
func (ct *ctrlerCtx) handle{{.}}Event(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handle{{.}}EventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *{{$pkgname}}.{{.}}:
		eobj := evt.Object.(*{{$pkgname}}.{{.}})
		kind := "{{.}}"

		{{if hasTransformers $pkg .}}eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/) 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/) 
		{{else}} 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj){{end}}

		ctx := &{{ToLower .}}Ctx{event: evt.Type,
			 obj: &{{.}} { {{.}}: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err	
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on {{.}} watch channel", tp)
	}

	return nil
}

// handle{{.}}EventNoResolver handles {{.}} events from watcher
func (ct *ctrlerCtx) handle{{.}}EventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *{{$pkgname}}.{{.}}:
		eobj := evt.Object.(*{{$pkgname}}.{{.}})
		kind := "{{.}}"

		{{if hasTransformers $pkg .}}eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/) 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/) 
		{{else}} 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj){{end}}

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		{{ToLower .}}Handler := handler.({{.}}Handler)
		// handle based on event type
		ctrlCtx := &{{ToLower .}}Ctx{event: evt.Type, obj: &{{.}}{ {{.}}: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("{{.}}_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = {{ToLower .}}Handler.On{{.}}Create(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)	
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*{{ToLower .}}Ctx)
				ct.stats.Counter("{{.}}_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := {{$pkgname}}.{{.}}{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = {{ToLower .}}Handler.On{{.}}Update(ctrlCtx.obj, &p)
				ctrlCtx.obj.{{.}} = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &{{ToLower .}}Ctx{event: evt.Type, obj: &{{.}} { {{.}} : *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*{{.}})
			ct.stats.Counter("{{.}}_Deleted_Events").Inc()
			obj.Lock()
			err = {{ToLower .}}Handler.On{{.}}Delete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on {{.}} watch channel", tp)
	}

	return nil
}


type {{ToLower .}}Ctx struct {
	ctkitBaseCtx
    event      kvstore.WatchEventType
    obj   	   *{{.}}         //
 //   newObj     *{{$pkgname}}.{{.}} //update
	newObj 	*{{ToLower .}}Ctx  //update
}

func (ctx *{{ToLower .}}Ctx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *{{ToLower .}}Ctx) GetKey() string {
	return ctx.obj.MakeKey("{{$pkgname}}")
}


func (ctx *{{ToLower .}}Ctx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *{{ToLower .}}Ctx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *{{ToLower .}}Ctx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *{{ToLower .}}Ctx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*{{ToLower .}}Ctx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *{{ToLower .}}Ctx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *{{ToLower .}}Ctx)  Copy(obj apiintf.CtkitObject) {
	ctx.obj.{{.}} = obj.(*{{ToLower .}}Ctx).obj.{{.}}
}

func (ctx *{{ToLower .}}Ctx) Lock() {
	ctx.obj.Lock()
}

func (ctx *{{ToLower .}}Ctx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *{{ToLower .}}Ctx)  GetObjectMeta() *api.ObjectMeta {
       return ctx.obj.GetObjectMeta()
}

func (ctx *{{ToLower .}}Ctx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *{{ToLower .}}Ctx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "{{.}}"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	{{ToLower .}}Handler := handler.({{.}}Handler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = {{ToLower .}}Handler.On{{.}}Create(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("{{.}}_Updated_Events").Inc()
		ctx.obj.Lock()
		p := {{$pkgname}}.{{.}}{Spec: ctx.newObj.obj.Spec,
				 ObjectMeta: ctx.newObj.obj.ObjectMeta,
				 TypeMeta:   ctx.newObj.obj.TypeMeta,
				  Status: ctx.newObj.obj.Status}
		err = {{ToLower .}}Handler.On{{.}}Update(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = {{ToLower .}}Handler.On{{.}}Delete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handle{{.}}EventParallel handles {{.}} events from watcher
func (ct *ctrlerCtx) handle{{.}}EventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handle{{.}}EventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *{{$pkgname}}.{{.}}:
		eobj := evt.Object.(*{{$pkgname}}.{{.}})
		kind := "{{.}}"

		{{if hasTransformers $pkg .}}eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/) 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/) 
		{{else}} 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj){{end}}

		ctx := &{{ToLower .}}Ctx{event: evt.Type, obj: &{{.}} { {{ .}}: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on {{.}} watch channel", tp)
	}

	return nil
}

// handle{{.}}EventParallel handles {{.}} events from watcher
func (ct *ctrlerCtx) handle{{.}}EventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *{{$pkgname}}.{{.}}:
		eobj := evt.Object.(*{{$pkgname}}.{{.}})
		kind := "{{.}}"

		{{if hasTransformers $pkg .}}eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/) 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/) 
		{{else}} 
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj){{end}}

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		{{ToLower .}}Handler := handler.({{.}}Handler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*{{ToLower .}}Ctx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("{{.}}_Created_Events").Inc()
					eobj.Lock()
					err = {{ToLower .}}Handler.On{{.}}Create(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*{{ToLower .}}Ctx)
					obj := workCtx.obj
					ct.stats.Counter("{{.}}_Updated_Events").Inc()
					obj.Lock()
					p := {{$pkgname}}.{{.}}{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = {{ToLower .}}Handler.On{{.}}Update(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.{{.}} = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &{{ToLower .}}Ctx{event: evt.Type, obj: &{{.}} { {{.}}: *eobj, ctrler: ct}}
			ct.runFunction("{{.}}", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*{{ToLower .}}Ctx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*{{.}})
				ct.stats.Counter("{{.}}_Deleted_Events").Inc()
				obj.Lock()
				err = {{ToLower .}}Handler.On{{.}}Delete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &{{ToLower .}}Ctx{event: evt.Type, obj: &{{.}} { {{.}}: *eobj, ctrler: ct}}
			ct.runFunction("{{.}}", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on {{.}} watch channel", tp)
	}

	return nil
}


// diff{{.}} does a diff of {{.}} objects between local cache and API server
func (ct *ctrlerCtx) diff{{.}}(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.{{$srvname}}().{{.}}().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diff{{.}}(): {{.}}List returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*{{$pkgname}}.{{.}})
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.{{.}}().List(context.Background(), &opts)
	if err != nil {
		 ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diff{{.}}(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.{{.}},
			}
			ct.handle{{.}}Event(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diff{{.}}(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handle{{.}}Event(&evt)
	}
}

func (ct *ctrlerCtx) run{{.}}Watcher() {
	kind := "{{.}}"


	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	{{ToLower .}}Handler := handler.({{.}}Handler)

	opts := {{ToLower .}}Handler.Get{{.}}WatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "{{.}}Watcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diff{{.}}(apiclt)
			break
		}
		
		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("{{.}}_Watch").Inc()
		defer ct.stats.Counter("{{.}}_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("{{.}}_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// {{.}} object watcher
				wt, werr := apicl.{{$srvname}}().{{.}}().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second) 
				ct.diff{{.}}(apicl)
				{{ToLower .}}Handler.On{{.}}Reconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("{{.}}_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handle{{.}}EventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// Watch{{.}} starts watch on {{.}} object
func (ct *ctrlerCtx) Watch{{.}}(handler {{.}}Handler) error {
	kind := "{{.}}"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("{{.}} watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run {{.}} watcher in a go routine
	ct.run{{.}}Watcher()

	return nil
}

// StopWatch{{.}} stops watch on {{.}} object
func (ct *ctrlerCtx) StopWatch{{.}}(handler {{.}}Handler) error {
	kind := "{{.}}"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("{{.}} watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// {{.}}API returns
type {{.}}API interface {
	Create(obj *{{$pkgname}}.{{.}}) error
	SyncCreate(obj *{{$pkgname}}.{{.}}) error
	Update(obj *{{$pkgname}}.{{.}}) error
	SyncUpdate(obj *{{$pkgname}}.{{.}}) error
	Delete(obj *{{$pkgname}}.{{.}}) error
	Find(meta *api.ObjectMeta) (*{{.}}, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*{{.}}, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error)
	Watch(handler {{.}}Handler) error
	ClearCache(handler {{.}}Handler)
	StopWatch(handler {{.}}Handler) error {{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
  {{.Name}}(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)
  RegisterLocal{{.Name}}Handler(fn func(*{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error))
  Sync{{.Name}}(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)
  RegisterLocalSync{{.Name}}Handler(fn func(*{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)) {{end}}
}

// dummy struct that implements {{.}}API
type {{ToLower .}}API struct {
	ct *ctrlerCtx
	{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
  local{{.Name}}Handler func(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)
  localSync{{.Name}}Handler func(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {{end}}
}

// Create creates {{.}} object
func (api *{{ToLower .}}API) Create(obj *{{$pkgname}}.{{.}}) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.{{$srvname}}().{{.}}().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") { {{if ctrlerPromoteCreateToUpdate .}}
			_, err = apicl.{{$srvname}}().{{.}}().Update(context.Background(), obj) {{else}}
        	_, err = apicl.{{$srvname}}().{{.}}().UpdateStatus(context.Background(), obj) {{end}}

		}
		return err
	}

	api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates {{.}} object and updates the cache
func (api *{{ToLower .}}API) SyncCreate(obj *{{$pkgname}}.{{.}}) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.{{$srvname}}().{{.}}().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") { {{if ctrlerPromoteCreateToUpdate .}}
			newObj, writeErr = apicl.{{$srvname}}().{{.}}().Update(context.Background(), obj) {{else}}
			newObj, writeErr = apicl.{{$srvname}}().{{.}}().UpdateStatus(context.Background(), obj) {{end}}
			evtType = kvstore.Updated
		}
	}
	
	if writeErr == nil {
		api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on {{.}} object
func (api *{{ToLower .}}API) Update(obj *{{$pkgname}}.{{.}}) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.{{$srvname}}().{{.}}().Update(context.Background(), obj)
		return err
	}

	api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on {{.}} object and updates the cache
func (api *{{ToLower .}}API) SyncUpdate(obj *{{$pkgname}}.{{.}}) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.{{$srvname}}().{{.}}().Update(context.Background(), obj)
	}
	
	if writeErr == nil {
		api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes {{.}} object
func (api *{{ToLower .}}API) Delete(obj *{{$pkgname}}.{{.}}) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.{{$srvname}}().{{.}}().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *{{ToLower .}}API) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "{{$pkgname}}", "/", "{{getServiceKey "../generated/apiclient/svcmanifest.json" $pkgname $srvname . }}", "/" , tenant, "/", name)
	} 
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "{{$pkgname}}", "/", "{{getServiceKey "../generated/apiclient/svcmanifest.json" $pkgname $srvname . }}", "/", name)
}


// Find returns an object by meta
func (api *{{ToLower .}}API) Find(meta *api.ObjectMeta) (*{{.}}, error) {
	// find the object
	obj, err := api.ct.FindObject("{{.}}", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *{{.}}:
		hobj := obj.(*{{.}})
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all {{.}} objects
func (api *{{ToLower .}}API) List(ctx context.Context, opts *api.ListWatchOptions) ([]*{{.}}, error) {
	var objlist []*{{.}}
	objs, err := api.ct.List("{{.}}", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
			case *{{.}}:
				eobj := obj.(*{{.}})
				objlist = append(objlist, eobj)
			default:
				log.Fatalf("Got invalid object type %v while looking for {{.}}", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all {{.}} objects from apiserver
func (api *{{ToLower .}}API) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.{{$srvname}}().{{.}}().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*{{$pkgname}}.{{.}} 
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.{{.}})
	}
	return ret, nil
}

// Watch sets up a event handlers for {{.}} object
func (api *{{ToLower .}}API) Watch(handler {{.}}Handler) error {
	api.ct.startWorkerPool("{{.}}")
	return api.ct.Watch{{.}}(handler)
}

// StopWatch stop watch for Tenant {{.}} object
func (api *{{ToLower .}}API) StopWatch(handler {{.}}Handler) error {
	api.ct.Lock()
	api.ct.workPools["{{.}}"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatch{{.}}(handler)
}

// ClearCache removes all {{.}} objects in ctkit
func (api *{{ToLower .}}API) ClearCache(handler {{.}}Handler) {
	api.ct.delKind("{{.}}")
}

{{$actions := getSvcActionEndpoints $svc .}}{{$obj := . }}{{range $actions}}
// {{.Name}} is an API action
func (api *{{ToLower $obj}}API) {{.Name}}(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.{{$srvname}}().{{$obj}}().{{.Name}}(context.Background(), obj)
	}
	if api.local{{.Name}}Handler != nil {
		return api.local{{.Name}}Handler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// Sync{{.Name}} is an API action. Cache will be updated
func (api *{{ToLower $obj}}API) Sync{{.Name}}(obj *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.{{$srvname}}().{{$obj}}().{{.Name}}(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.{{$srvname}}().{{$obj}}().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handle{{$obj}}Event(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})	
		}
		return ret, err
	}
	if api.localSync{{.Name}}Handler != nil {
		return api.localSync{{.Name}}Handler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *{{ToLower $obj}}API) RegisterLocal{{.Name}}Handler(fn func(*{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)) {
	api.local{{.Name}}Handler = fn
}

func (api *{{ToLower $obj}}API) RegisterLocalSync{{.Name}}Handler(fn func(*{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error)) {
	api.localSync{{.Name}}Handler = fn
}

{{end}}
// {{.}} returns {{.}}API
func (ct *ctrlerCtx) {{.}}() {{.}}API {
	kind := "{{.}}"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &{{ToLower .}}API{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*{{ToLower .}}API)
}

{{end}}{{end}}{{end}}
