// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.


package ctkit 

{{$pkgs := (getSvcManifest "../generated/apiclient/svcmanifest.json")}}

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/diagnostics"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/api/labels"
	"github.com/pensando/sw/venice/utils"
	"github.com/pensando/sw/venice/utils/balancer"
	diag "github.com/pensando/sw/venice/utils/diagnostics"
	diagsvc "github.com/pensando/sw/venice/utils/diagnostics/service"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/objResolver"
	"github.com/pensando/sw/venice/utils/resolver"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
	"github.com/pensando/sw/venice/utils/tsdb"
)

const maxApisrvWriteRetry = 5

var (
	numberOfShardWorkers = 64
)

type apiServerObject interface {
	References(tenant string, path string, resp map[string]apiintf.ReferenceObj)
	GetObjectMeta() *api.ObjectMeta // returns the object meta
}

//wrapper to get references
func references(obj apiServerObject) map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	obj.References(obj.GetObjectMeta().Name, obj.GetObjectMeta().Namespace, resp)
	return resp
}

type ctkitBaseCtx struct {
	//resolveState resolveState //resolve state
	objResolver.ResolveCtx
	watchTs    int64
	references map[string]apiintf.ReferenceObj
}

func (ctBase *ctkitBaseCtx) SetWatchTs(ts int64) {
	ctBase.watchTs = ts
}

func (ctBase *ctkitBaseCtx) GetWatchTs() int64 {
	return ctBase.watchTs
}

// db of objects for a kind
type kindStore struct {
	sync.Mutex
	objects map[string]apiintf.CtkitObject
}

func (ct *ctrlerCtx) filterOutRefs(obj apiintf.CtkitObject) {

	refs := obj.References()
	for key, ref := range refs {
		if _, ok := ct.kinds[ref.RefKind]; !ok {
			delete(refs, key)
		}
	}
}

func (ks *kindStore) GetObject(key string) (apiintf.CtkitObject, error) {

	ks.Lock()
	defer ks.Unlock()

	obj, ok := ks.objects[key]
	if !ok {
		return nil, fmt.Errorf("Object %s not found", key)
	}

	return obj, nil
}

func (ct *ctrlerCtx) addObject(obj apiintf.CtkitObject) error {

       ks := ct.GetObjectStore(obj.GetKind())

       ct.stats.Counter(obj.GetKind() + "_Objects").Inc()

       ks.AddObject(obj)

       return nil
}

func (ct *ctrlerCtx) getObject(kind, key string) (apiintf.CtkitObject, error) {

       ks := ct.GetObjectStore(kind)


       existingObj, err := ks.GetObject(key)
       if err != nil {
               log.Errorf("Object {%+v} not found", key)
               return nil, errors.New("Object not found")
       }

       return existingObj, nil
}


func (ks *kindStore) AddObject(obj apiintf.CtkitObject) error {

	ks.Lock()
	defer ks.Unlock()

	ks.objects[obj.GetKey()] = obj

	return nil
}

func (ks *kindStore) DeleteObject(key string) error {

	ks.Lock()
	defer ks.Unlock()

	obj, ok := ks.objects[key]
	if !ok {
		return fmt.Errorf("Object %s not found", key)
	}

	delete(ks.objects, obj.GetKey())
	return nil
}

// dummy struc to implement the defaul reactors
type CtrlDefReactor struct {

}

type watchCancelEntry struct {
	cancelFn context.CancelFunc
	wg       sync.WaitGroup
}

type ctrlerCtx struct {
	sync.Mutex                                      // lock for the controller
	name        string                              // controller name
	rpcServer   *rpckit.RPCServer                   // grpc server
	apisrvURL   string                              // API server URL
	logger      log.Logger                          // logger
	resolver    resolver.Interface                  // name resolver
	stoped      bool                                // stop the watchers
	watchers    map[string]kvstore.Watcher          // watchers
	watchCancel map[string]*watchCancelEntry         // watcher cancel info
	handlers    map[string]interface{}              // event handlers
	waitGrp     sync.WaitGroup                      // wait group to wait on all go routines to exit
	kinds       map[string]*kindStore               // DB of all kinds
	workPools   map[string]*shardworkers.WorkerPool // Worker pool for each kind all kinds
	apicl       apiclient.Services                  // api client to write
	stats       tsdb.Obj                            // ctkit stats
	diagSvc     diag.Service
	objResolver *objResolver.ObjectResolver			// obj resolver for ctkit
	apiInfMap   map[string]interface{}              // Kind API Objects
}

// Controller is the main interface provided by controller instance
type Controller interface {
	FindObject(kind string, ometa *api.ObjectMeta) (runtime.Object, error)
	IsPending(kind string, ometa *api.ObjectMeta) (bool, error)
	ListObjects(kind string) []runtime.Object
	List(kind string, ctx context.Context, opts *api.ListWatchOptions) ([]runtime.Object, error)
	Stop() error                                                                     // stop the controller
	RegisterDiagnosticsHandler(rpcMethod, query string, handler diag.Handler) // registers diagnostics query handler
	AggWatch() AggWatchAPI
	
    {{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
    {{.}}() {{.}}API  // return {{.}} API interface {{end}}{{end}}{{end}}
}

type CtrlerSpec struct {
	Name                   string
	RpcServer              *rpckit.RPCServer
	ResolveObjects         bool
	NumberofWorkersPerKind int
	Resolver               resolver.Interface
	ApisrvURL              string
	Logger                 log.Logger
}

// NewController creates a new instance of controler
func NewController(spec CtrlerSpec) (Controller, CtrlDefReactor, error) {
	keyTags := map[string]string{"node": "venice", "module": spec.Name, "kind": "CtkitStats"}
	tsdbObj, err := tsdb.NewObj("CtkitStats", keyTags, nil, nil)

	defReactor := CtrlDefReactor{}

	if err != nil {
		log.Errorf("unable to create tsdb object, keys %+v", keyTags)
		return nil, defReactor, err
	}

	// create controller context
	ctrl := ctrlerCtx{
		name:        spec.Name,
		rpcServer:   spec.RpcServer,
		apisrvURL:   spec.ApisrvURL,
		logger:      spec.Logger.WithContext("submodule", spec.Name+"-Watcher"),
		resolver:    spec.Resolver,
		stoped:      false,
		watchers:    make(map[string]kvstore.Watcher),
		watchCancel: make(map[string]*watchCancelEntry),
		handlers:    make(map[string]interface{}),
		kinds:       make(map[string]*kindStore),
		workPools:   make(map[string]*shardworkers.WorkerPool),
		stats:       tsdbObj,
		diagSvc:     diagsvc.GetDiagnosticsService(spec.Name, utils.GetHostname(), diagnostics.ModuleStatus_Venice, spec.Logger),
		apiInfMap:   make(map[string]interface{}),
	}

	if spec.ResolveObjects {
		ctrl.objResolver = objResolver.NewObjectResolver(&ctrl)
	}

	if spec.RpcServer != nil {
		diag.RegisterService(spec.RpcServer.GrpcServer, ctrl.diagSvc)
	}

	if spec.NumberofWorkersPerKind != 0 {
		numberOfShardWorkers = spec.NumberofWorkersPerKind
	}

	return &ctrl, defReactor, nil
}

func (ct *ctrlerCtx) GetObjectStore(kind string) apiintf.ObjectStore {
	return ct.getKindStore(kind)
}

func (ct *ctrlerCtx) ResolvedRun(obj apiintf.CtkitObject) {
	ct.runJob(obj.GetKind(), obj)
}

func (ct *ctrlerCtx) runFunction(pool string, workObj shardworkers.WorkObj, work shardworkers.WorkFunc) error {
	if wp, ok := ct.workPools[pool]; ok {
		return wp.RunFunction(workObj, work)
	}
	return fmt.Errorf("No worker pool entry for %s", pool)
}


func (ct *ctrlerCtx) getKindStore(kind string) *kindStore {

	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ks = &kindStore{
			objects: make(map[string]apiintf.CtkitObject),
		}
		ct.kinds[kind] = ks
	}
	return ct.kinds[kind]
}

func (ct *ctrlerCtx) setKindStore(kind string) {

	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ks = &kindStore{
			objects: make(map[string]apiintf.CtkitObject),
		}
		ct.kinds[kind] = ks
	}
}

// Stop stops the controller
func (ct *ctrlerCtx) Stop() error {
	ct.stoped = true

	// stop all watchers
	for _, wt := range ct.watchers {
		wt.Stop()
	}

	//Stop worker pools
	for _, workerPool := range ct.workPools {
		workerPool.Stop()
	}

	// cancel all watchers
	for _, entry := range ct.watchCancel {
		entry.cancelFn()
	}

	// stop api client
	if ct.apicl != nil {
		ct.apicl.Close()
		ct.apicl = nil
	}
	
	// wait for all goroutines to exit
	ct.waitGrp.Wait()

	return nil
}

func (ct *ctrlerCtx) startWorkerPool(kind string) {
	ct.startWorkerPoolWithWorkers(kind, 0)
	return
}

func (ct *ctrlerCtx) startWorkerPoolWithWorkers(kind string, workers uint32) {
	if workers == 0 {
		workers = uint32(numberOfShardWorkers)
	}
	workerPool := shardworkers.NewWorkerPool(kind, workers)
	workerPool.Start()
	ct.Lock()
	ct.workPools[kind] = workerPool
	ct.Unlock()
	return
}

func (ct *ctrlerCtx) dumpWorkerStats() {
	ct.Lock()
	for _, workerPool := range ct.workPools {
		workerPool.DumpWorkerStats()
	}
	ct.Unlock()
}

func (ct *ctrlerCtx) apiClient() (apiclient.Services, error) {
	ct.Lock()
	apicl := ct.apicl
	ct.Unlock()
	if apicl != nil {
		return apicl, nil
	}

	for i := 0; i < 10; i++ {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err == nil {
			ct.Lock()
			ct.apicl = apicl
			ct.Unlock()
			return apicl, nil
		}

		log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Millisecond * 100)
	}

	return nil, fmt.Errorf("Error connecting to api client")
}

func (ct *ctrlerCtx) processAdd(obj apiintf.CtkitObject) error {
	return ct.objResolver.ProcessAdd(obj)
}

func (ct *ctrlerCtx) processDelete(obj apiintf.CtkitObject) error {
	return ct.objResolver.ProcessDelete(obj)
}

func (ct *ctrlerCtx) processUpdate(obj apiintf.CtkitObject) error {
	return ct.objResolver.ProcessUpdate(obj)
}

func (ct *ctrlerCtx) resolveObject(event kvstore.WatchEventType, workObj apiintf.CtkitObject) error {
	return ct.objResolver.Resolve(event, workObj)
}

func (ct *ctrlerCtx) runJob(pool string, workObj shardworkers.WorkObj) error {
	if wp, ok := ct.workPools[pool]; ok {
		return wp.RunJob(workObj)
	}
	return fmt.Errorf("No worker pool entry for %s", pool)
}

func (ct *ctrlerCtx) workerPoolIdle(pool string) bool {
       idle, _ := ct.workPools[pool].IsIdle()
       return idle
}

func (ct *ctrlerCtx) findObject(kind, key string) (runtime.Object, error) {
	ct.Lock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ct.Unlock()
		return nil, fmt.Errorf("Object %s/%s not found", kind, key)
	}

	ct.Unlock()
	ks.Lock()
	obj, ok := ks.objects[key]
	ks.Unlock()
	if !ok {
		return nil, fmt.Errorf("Object %s/%s not found", kind, key)
	}

	//dont try to find the object if unresolved.
	if ct.objResolver != nil && obj.IsAddUnResolved() {
		return nil, fmt.Errorf("Object %s/%s in unresolved", kind, key)
	}

	return obj.RuntimeObject(), nil
}

func (ct *ctrlerCtx) sweepObjects(kind string, watchTS time.Time) {
	ct.Lock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ct.Unlock()
		return
	}

	ct.Unlock()
	sweepObjs := []workerObject{}
	ks.Lock()

	for _, obj := range ks.objects {
		if obj.IsInternal() {
			continue
		}
		if obj.GetWatchTs() != watchTS.Unix() {
			switch kind {
			{{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
	    	case "{{.}}":
				ev := kvstore.WatchEvent{Type: kvstore.Deleted, Object: &(obj.RuntimeObject().(*{{.}}).{{.}})}
				sweepObjs = append(sweepObjs, workerObject{ev: &ev, workFunc: ct.handle{{.}}EventParallel}){{end}}{{end}}{{end}}
			}
		}
	}
	ks.Unlock()

	for _, work := range sweepObjs {
		work.workFunc(work.ev)
	}

}

func (ct *ctrlerCtx) isPending(kind, key string) (bool, error) {
       ct.Lock()

       ks, ok := ct.kinds[kind]
       if !ok {
               ct.Unlock()
               return false, fmt.Errorf("Object %s/%s not found", kind, key)
       }

       ct.Unlock()
       ks.Lock()
       obj, ok := ks.objects[key]
       ks.Unlock()
       if !ok {
               return false, fmt.Errorf("Object %s/%s not found", kind, key)
       }

       return !obj.IsResolved(), nil
}

// FindObject finds an object by key
func (ct *ctrlerCtx) FindObject(kind string, ometa *api.ObjectMeta) (runtime.Object, error) {

	key := ""
	switch kind {
    	{{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
	    case "{{.}}":
			obj := {{ToLower .}}API{}
			key = obj.getFullKey(ometa.Tenant, ometa.Name) {{end}}{{end}}{{end}}
		default:
			return nil, errors.New("Kind not found")

	}
	return ct.findObject(kind, key)
}
// IsPending finds object by key
func (ct *ctrlerCtx) IsPending(kind string, ometa *api.ObjectMeta) (bool, error) {

	key := ""
	switch kind {
    	{{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
	    case "{{.}}":
			obj := {{ToLower .}}API{}
			key = obj.getFullKey(ometa.Tenant, ometa.Name) {{end}}{{end}}{{end}}
		default:
			return false, errors.New("Kind not found")

	}
	return ct.isPending(kind, key)
}

// ListObjects returns a list of object of a kind
func (ct *ctrlerCtx) ListObjects(kind string) []runtime.Object {
	ct.Lock()

	ks, ok := ct.kinds[kind]
	ct.Unlock()
	if !ok {
		return []runtime.Object{}
	}
	ks.Lock()
	defer ks.Unlock()
	var objlist []runtime.Object
	for _, obj := range ks.objects {
		objlist = append(objlist, obj.RuntimeObject())
	}

	return objlist
}

// List returns a list of object of a kind
func (ct *ctrlerCtx) List(kind string, ctx context.Context, opts *api.ListWatchOptions) ([]runtime.Object, error) {
	ct.Lock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ct.Unlock()
		return []runtime.Object{}, fmt.Errorf("Kind %v not found in local cache.", kind)
	}

	ct.Unlock()
	labelMap, err := labels.ConvertSelectorToLabelsMap(opts.LabelSelector)
	if err != nil {
		return nil, err
	}

	ks.Lock()
	defer ks.Unlock()
	var objlist []runtime.Object
	for _, obj := range ks.objects {
		meta, err := runtime.GetObjectMeta(obj)
		if err != nil {
			return nil, err
		}

		toAdd := true
		for k, v := range labels.Set(labelMap) {
			if meta.Labels[k] != v {
				toAdd = false
				break
			}
		}

		if toAdd {
			objlist = append(objlist, obj.RuntimeObject())
		}
	}

	return objlist, nil
}
func (ct *ctrlerCtx) delObject(kind, key string) error {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		return fmt.Errorf("Object %s/%s not found", kind, key)
	}

	ks.Lock()
	_, ok = ks.objects[key]
	if !ok {
		ks.Unlock()
		return fmt.Errorf("Object %s/%s not found", kind, key)
	}

	ct.stats.Counter(kind + "_Objects").Dec()

	// delete the object
	delete(ks.objects, key)
	ks.Unlock()

	return nil
}

func (ct *ctrlerCtx) delKind(kind string) error {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		return fmt.Errorf("kind %s not found", kind)
	}

	ks.Lock()
	ct.stats.Counter(kind + "_Objects").Set(0)
	ks.objects = make(map[string]apiintf.CtkitObject)
	ks.Unlock()

	return nil
}

// RegisterDiagnosticsHandler registers a diagnostics query handler if RPC server is enabled. This should be called before grpc server is started
func (ct *ctrlerCtx) RegisterDiagnosticsHandler(rpcMethod, query string, handler diag.Handler) {
	if ct.diagSvc != nil {
		if err := ct.diagSvc.RegisterHandler(rpcMethod, query, handler); err != nil {
			ct.logger.ErrorLog("method", "RegisterDiagnosticsHandler", "msg", fmt.Sprintf("failed to register handler for rpc method [%s], query [%s]", rpcMethod, query), "error", err)
			// TODO throw an event
		}
	}
}


// dummy struct that implements Aggwatch
type aggwatchAPI struct {
       ct *ctrlerCtx
}

type AggWatchReactor interface {
       //Callback from ctkit whenever resync is complete
       ResyncComplete()
	   ///Callback from no events are being recived and change for reacotr to reconcile or do fixup
	   PeriodicReconcile()
}

const (
       aggWatckKind = "agg-watch"
)

type AggWatchAPI interface {
       Start(reactor AggWatchReactor, kinds []AggKind) error
}

type AggKind struct {
	Group   string
	Kind    string
	Reactor interface{}
	Workers uint32
}

type workerFunc func(evt *kvstore.WatchEvent) error

type workerObject struct {
	workFunc workerFunc
	ev       *kvstore.WatchEvent
}

const (
	workerQueueSize = 32768
	reconcileCode   = 255
)


func (agg *aggwatchAPI) runLoop(wopts *api.AggWatchOptions, reactor AggWatchReactor) error {

    if agg.ct.resolver == nil {
        reactor.ResyncComplete()
        return nil
    }
    waitForWorkerPoolIdle := func() {

            for true {
                    done := true
                    for _, kind := range wopts.WatchOptions {
                            if !agg.ct.workerPoolIdle(kind.Kind) {
                                    log.Infof("Waiting pool %v still running", kind)
                                    done = false
                                    break
                            }
                    }
                    if done {
                            return
                    }
                    log.Infof("Waiting for worker pools to be idle.")
                    time.Sleep(1 * time.Second)
            }
    }

	workerPoolIdle := func() bool {
		for _, kind := range wopts.WatchOptions {
			if !agg.ct.workerPoolIdle(kind.Kind) {
				return false
			}
		}
		return true
	}
	
	sweepObjects := func(watchTS time.Time) {
		for _, kind := range wopts.WatchOptions {
			log.Infof("Doing sweep of object %v", kind)
			agg.ct.sweepObjects(kind.Kind, watchTS)
		}
	}

	evWorker := func(watchTS time.Time, workChannel chan workerObject, done chan error) {

		defer close(done)
		log.Infof("Started agg ev worker")
		defer log.Infof("agg ev worker done")
		for true {
			select {
			case work, ok := <-workChannel:
				if !ok {
					return
				}
				switch work.ev.Type {
				case kvstore.WatcherControl:
					if work.ev.Control.Code == reconcileCode {
						waitForWorkerPoolIdle()
						reactor.PeriodicReconcile()
					} else {
						//wait for current objects to be processed
						waitForWorkerPoolIdle()
						//Sweep objects which are not removed
						sweepObjects(watchTS)
						waitForWorkerPoolIdle()
						reactor.ResyncComplete()
					}

				default:
					work.workFunc(work.ev)
				}

			}
		}
	}


	ctx, cancel := context.WithCancel(context.Background())

	agg.ct.Lock()
	agg.ct.watchCancel[aggWatckKind] = &watchCancelEntry{
		cancelFn: cancel,
	}
	agg.ct.Unlock()

	ct := agg.ct
	logger := ct.logger.WithContext("submodule", "AggWatcher")
	log.Infof("Starting agg watch loop")
	var watchTS time.Time
	for {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s] : %v \n", ct.apisrvURL, err)
			time.Sleep(time.Second)
			continue
		}

		log.Infof("Connecting with options %#v", wopts)
		watcher, err := apiclt.AggWatchV1().Watch(ctx, wopts)
		if err != nil {
			logger.Warnf("Failed to start aggwatch [%s] : %v \n", ct.apisrvURL, err)
			time.Sleep(time.Second)
			continue
		}

		if wopts.ResourceVersion == "" {
			watchTS = time.Now()
		}
		log.Infof("Started agg watch loop")

		evWorkChannel := make(chan workerObject, workerQueueSize)
		evWorkerDone := make(chan error)
		go evWorker(watchTS, evWorkChannel, evWorkerDone)
		periodicReconcile := time.NewTicker(time.Second * 10)
	watchLoop:
		for {
			select {
			case <-ctx.Done():
				log.Infof("Stopped agg watch loop")
				break watchLoop
			case <-periodicReconcile.C:
				//Call reconcile when idle
				if len(evWorkChannel) == 0 && workerPoolIdle() {
					evWorkChannel <- workerObject{ev: &kvstore.WatchEvent{Type: kvstore.WatcherControl,
						Control: &kvstore.WatchControl{
							Code: reconcileCode,
						}}}
				}
			case ev, ok := <-watcher.EventChan():
				if ok {
					ev.WatchTS = watchTS.Unix()
					switch ev.Type {
					case kvstore.Created, kvstore.Updated, kvstore.Deleted:
						switch ev.Object.GetObjectKind() {
    					{{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
	    				case "{{.}}":
							wopts.ResourceVersion = ev.Object.(*{{$pkgname}}.{{.}}).GetResourceVersion()
							evWorkChannel <- workerObject{ev: ev, workFunc: ct.handle{{.}}EventParallel} {{end}}{{end}}{{end}}
						}
					case kvstore.WatcherError:
						log.Infof("Received watcher error, resetting resource version")
						wopts.ResourceVersion = ""
						break watchLoop
					case kvstore.WatcherControl:
						evWorkChannel <- workerObject{ev: ev}
					default:
						log.Errorf("Invalid Event received %#v", ev)
					}
				} else {
					log.Infof("Channel closed, breaking watch loop")
					break watchLoop
				}

			}
		}
		close(evWorkChannel)
		<-evWorkerDone
		apiclt.Close()
		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting Agg API server watcher")
			return nil
		}

	}

}

func (agg *aggwatchAPI) Start(reactor AggWatchReactor, kinds []AggKind) error {

	wopts := api.AggWatchOptions{}
	for _, kind := range kinds {
		switch kind.Kind {
    	{{range $key, $value := $pkgs}}{{$pkgname := $key}}{{range $k, $v := $value.Svcs}}  {{range $v.Messages}} 
	    case "{{.}}":
			if reactor, ok := kind.Reactor.({{.}}Handler); !ok {
				return fmt.Errorf("%v reactor not implemented", "{{.}}")
			} else {
				wopts.WatchOptions = append(wopts.WatchOptions,
					api.KindWatchOptions{Kind: kind.Kind, Group: kind.Group, Options: *reactor.Get{{.}}WatchOptions()})
			} {{end}}{{end}}{{end}}

		default:
			return fmt.Errorf("Kind %v not found", kind.Kind)
		}
		agg.ct.startWorkerPoolWithWorkers(kind.Kind, kind.Workers)
		log.Infof("Ctkit handler registration for agg reactor for %v(%v) %p %T", kind.Kind, kind.Group, kind.Reactor, kind.Reactor)
		agg.ct.handlers[kind.Kind] = kind.Reactor
		agg.ct.setKindStore(kind.Kind)
	}

	go agg.runLoop(&wopts, reactor)
	return nil
}

//AggWatch returns handler for agg watch
func (ct *ctrlerCtx) AggWatch() AggWatchAPI {
	kind := aggWatckKind
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &aggwatchAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*aggwatchAPI)
}
