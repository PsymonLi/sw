// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}} {{$file := .}}
*/
package {{.GoPkg.Name}}{{$validators := getValidatorManifest .}}{{$defaults := getDefaulterManifest .}}{{$storageTransformers := getStorageTransformersManifest .}}

import (
	"context"
	fmt "fmt"
	"errors"

	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/api/generated/events"
	{{if $validators.Fmap}}
	validators "github.com/pensando/sw/venice/utils/apigen/validators"{{end}}
	{{if $storageTransformers.Fmap}}"github.com/pensando/sw/venice/utils/transformers/storage"{{end}}
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/runtime"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient
{{if $validators.Fmap}}
var _ validators.DummyVar
var validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(string, interface{})error)
{{end}}
{{if $storageTransformers.Fmap}}
var storageTransformersMap{{getFileName .Name}} = make(map[string][]func(ctx context.Context, i interface{}, toStorage bool) error) {{end}}
{{range .Messages}}{{if (len (getDbKey .)) ne 0}}{{$sep := ", "}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}}) MakeKey(prefix string) string {
	return fmt.Sprint(globals.ConfigRootPrefix, "/", prefix, "/", {{range $index, $value := (getDbKey .)}}{{if ($index) ne 0}}{{$sep}}{{end}}{{if strEq $value.Type "prefix"}}"{{$value.Val}}"{{else}}m.{{$value.Val}}{{end}}{{$sep := ", "}}{{end}})
}

func (m *{{.Name}})  MakeURI(cat, ver, prefix string) string { {{$uri := getMsgURIKey . ""}}{{if $uri.Ref}}
  in := m{{end}}
	return fmt.Sprint("/", cat, "/", prefix, "/", ver, {{$uri.Str}})
}{{end}}{{end}}

{{range .Messages}}{{if isListHelper .}}{{$type := getListType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
}

func (m *{{.Name}})  MakeURI(ver, prefix string) string { {{$uri := getMsgURIKey . ""}}{{if $uri.Ref}}
  in := m{{end}}
	return fmt.Sprint("/", globals.ConfigURIPrefix, "/", prefix, "/", ver, {{$uri.Str}})
}{{end}} {{end}}
{{range .Messages}}{{if isWatchHelper .}}{{$type := getWatchType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}
// Clone clones the object into into or creates one of into is nil
func (m *{{getStr 0}}) Clone(into interface{}) (interface{}, error) {
	var out *{{getStr 0}}
	var ok bool
	if into == nil {
		out = &{{getStr 0}}{}
	} else {
		out, ok = into.(*{{getStr 0}})
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *{{getStr 0}}) Defaults(ver string) bool { {{if isSpecStatusMessage .}}
	m.Kind = "{{.Name}}" {{if isTenanted .}}
	m.Tenant, m.Namespace = "default", "default" {{else}}
	m.Tenant, m.Namespace = "", "" {{end}}{{end}}{{with index $defaults.Map (getStr 0)}}{{if eq (len .Fields) 0}}
	return false {{else}}
	var ret bool {{range $fldk, $defval := .Fields}}{{if $defval.Nested}}{{if $defval.Repeated}}
	for k := range m.{{$fldk}} { {{if $defval.Pointer}}
		if m.{{$fldk}}[k] != nil {
			i := m.{{$fldk}}[k]
			ret = i.Defaults(ver) || ret
		}{{else}}
		i := m.{{$fldk}}[k]
		ret = i.Defaults(ver) || ret {{end}}
	}{{else}}{{if $defval.Pointer}}
	if m.{{$fldk}} != nil {
		ret = m.{{$fldk}}.Defaults(ver) || ret
	}{{else}}
	ret = m.{{$fldk}}.Defaults(ver) || ret{{end}}{{end}}{{end}}{{end}}{{if eq (len .Versions) 0}}{{else}}
	ret = true
	switch ver { {{range $ver, $verdef := .Versions}}{{if eq $ver "all"}}
	default: {{else}}
	case "{{$ver}}": {{end}}{{range $fldk, $def := $verdef}}{{/*<0>*/}}{{if $def.Repeated}}{{/*<1>*/}}
	for k := range m.{{$fldk}} { {{if $def.Pointer}}{{/*<2>*/}}
		if m.{{$fldk}}[k] != nil {
			*m.{{$fldk}}[k] = {{$def.Val}}
		} {{else}}
		m.{{$fldk}}[k] = {{$def.Val}}{{end}}{{/*<2>*/}}
	}{{else}}{{if $def.Pointer}}{{/*<3>*/}}
	if m.{{$fldk}} != nil {
		m.{{$fldk}} = {{$def.Val}}
	}{{else}}
	m.{{$fldk}} = {{$def.Val}}{{end}}{{/*<3>*/}}{{end}}{{/*<1>*/}}{{end}}{{/*<0>*/}}
	{{end}} }{{/*<lenVer!=0>*/}}{{end}}{{/*<rangeVersion>*/}}
	return ret{{end}}
} {{end}}{{end}}
{{end}}
// Validators
{{range .Messages}}{{/*<0-1>*/}}{{if isMapEntry .}}{{/*<0>*/}}{{else}}{{/*<0>*/}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{/*<x>*/}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{/*<x>*/}}{{$msg := .}}{{$msgname := (getStr 0)}}
func (m *{{$msgname}}) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error {{if isSpecStatusMessage $msg}}
	{
	dlmtr := "."	
	if path == "" {
		dlmtr = ""
	}
	ret = m.ObjectMeta.Validate(ver, path + dlmtr + "ObjectMeta", ignoreStatus)
	}{{if isTenanted $msg}}{{else}}
	if m.Tenant != "" {
		ret = append(ret, errors.New("Tenant not allowed for {{$msgname}}"))
	}{{end}}{{end}}{{with (index $validators.Map $msgname)}}{{/*<1>*/}}{{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{/*<2>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<3>*/}}{{if $fldv.Repeated}}{{/*<4>*/}}
	for k, v := range m.{{$fldk}} {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%s{{$fldk}}[%v]", path, dlmtr, k)
		 if errs := v.Validate(ver, npath, ignoreStatus); errs != nil {
			 ret = append(ret, errs...)
		 }
	} {{else}}{{/*<4>*/}}{{if isSpecStatusMessage $msg}}{{/*<5>*/}}{{if strEq $fldk "Status"}}{{/*<6>*/}}
	if !ignoreStatus {
		{{if $fldv.Pointer}}{{/*<7>*/}}if  m.{{$fldk}} != nil {
				{{end}}{{/*<7>*/}}
				dlmtr := "."
				if path == "" {
					dlmtr = ""
				}
				npath := path + dlmtr + "{{$fldk}}"
				if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus); errs != nil {
				ret = append(ret, errs...)
			}{{if $fldv.Pointer}}{{/*<8>*/}}
		}{{end}}{{/*<8>*/}}
	}{{else}}{{/*<7>*/}}
	{{if $fldv.Pointer}}{{/*<9>*/}}if m.{{$fldk}} != nil { {{end}}{{/*<9>*/}}
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "{{$fldk}}"
		if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus); errs != nil {
			ret = append(ret, errs...)
		}{{if $fldv.Pointer}}{{/*<10>*/}}
	}{{end}}{{/*<10>*/}}{{end}}{{/*<6>*/}}{{else}}{{/*<5>*/}}
	{{if $fldv.Pointer}}{{/*<11>*/}}if  m.{{$fldk}} != nil { {{end}}{{/*<11>*/}}
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "{{$fldk}}"
			if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus); errs != nil {
			ret = append(ret, errs...)
		}{{if $fldv.Pointer}}{{/*<12>*/}}
	}{{end}}{{/*<12>*/}}{{end}}{{/*<5>*/}}{{end}}{{/*<4>*/}}{{else}}{{/*<3>*/}}{{$_:= (saveBool true 0)}}{{end}}{{/*<3>*/}}{{end}}{{/*<2>*/}}{{if getBool 0}}{{/*<13>*/}}
	if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} {{end}}{{/*<13>*/}}{{end}}{{/*<1>*/}}
	return ret
}
{{end}}{{/*<0>*/}}{{end}}{{/*<0-1>*/}}

// Transformers
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{$msg := .}}{{$msgname := (getStr 0)}}{{with (index $storageTransformers.Map $msgname)}}{{if .HasTransformers}}
func (m *{{$msgname}}) ApplyStorageTransformer(ctx context.Context, toStorage bool) error { {{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{if $fldv.Repeated}}
	for i, v := range m.{{$fldk}} {
		 c := *v
		 if err := c.ApplyStorageTransformer(ctx, toStorage); err != nil {
			 return err
		 }
		 m.{{$fldk}}[i] = &c
	} {{else}}{{if isSpecStatusMessage $msg}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{else}}
	{{if $fldv.Pointer}}
	if m.{{$fldk}} == nil {
		return nil
	}{{end}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if vs, ok := storageTransformersMap{{getFileName $file.Name}}["{{$msgname}}"]; ok {
		for _, v := range vs {
			if err := v(ctx, m, toStorage); err != nil {
				return err
			}
		}
	} {{end}}
	return nil
}

{{if isSpecStatusMessage $msg}}
type storage{{$msgname}}Transformer struct {}
var Storage{{$msgname}}Transformer storage{{$msgname}}Transformer

func (st *storage{{$msgname}}Transformer) TransformFromStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, false)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (st *storage{{$msgname}}Transformer) TransformToStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, true)
	if err != nil {
		return nil, err
	}
	return r, nil
}
{{end}}{{end}}{{end}}{{end}}{{end}}

func init() {
	scheme := runtime.GetDefaultScheme()
	scheme.AddKnownTypes({{range  .Messages}}{{if (len (getDbKey .)) ne 0}}
		&{{.Name}}{},{{end}}{{end}}
	)
{{if $validators.Fmap}}{{/*<1>*/}}
	validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(string, interface{})error){{range .Messages}}{{/*<2>*/}}{{$msgName := .Name}}{{with (index $validators.Map (derefStr .Name))}}{{/*<3>*/}}
	{{$_ := saveBool true 1}}{{range $fldk, $fldv := .Fields}}{{/*<4>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<5>*/}}{{else}}{{/*<5>*/}}{{if getBool 1}}{{/*<6>*/}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"] = make(map[string][]func(string, interface{})error){{$_ := saveBool false 1}}{{end}}{{/*<6>*/}}{{end}}{{/*<5>*/}}{{end}}{{/*<4>*/}}{{range $fldk, $fldv := .Fields}}{{/*<7>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<8>*/}}{{else}}{{/*<8>*/}}
	{{range $fldv.Validators}}{{/*<9>*/}}{{if eq 0 (len .Args)}}{{/*<10>*/}}{{$fnname := .Fn}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(path string, i interface{}) error {
		m := i.(*{{$msgName}}){{if $fldv.Repeated}}{{/*<9.1>*/}}
		for k, v := range m.{{$fldk}} {
			if !validators.{{$fnname}}(v) {
				return fmt.Errorf("%v[%v] validation failed", path + "." + "{{$fldk}}", k)
			}
		}
		{{else}}{{/*<9.1>*/}}
		if !validators.{{.Fn}}(m.{{$fldk}}) {
			return fmt.Errorf("%v validation failed", path + "." + "{{$fldk}}")
		}{{end}}{{/*<9.1>*/}}
		return nil
	})
		{{else}}{{/*<10>*/}} validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(path string, i interface{}) error {
		m := i.(*{{$msgName}})
		{{if (strEq .Fn "StrEnum")}}{{/*<11>*/}}{{$enummap := (getEnumStrMap $file .Args)}}{{if $fldv.Repeated}}{{/*<12>*/}}
		for k, v := range m.{{$fldk}} {
			if _, ok := {{$enummap}}[v]; !ok {
				return fmt.Errorf("%v[%v] did not match allowed strings", path + "." + "{{$fldk}}", k)
			}
		}{{else}}{{/*<12>*/}}
		if _, ok := {{$enummap}}[m.{{$fldk}}]; !ok {
			return errors.New("{{$msgName}}.{{$fldk}} did not match allowed strings")
		}{{end}}{{/*<12>*/}}{{else}}{{/*<11>*/}}args := make([]string, 0) {{$fnname := .Fn}}
		{{range .Args}}{{/*<13>*/}}args = append(args, "{{.}}")
		{{end}}{{/*<13>*/}}{{if $fldv.Repeated}}{{/*<14>*/}}
		for _, v := range m.{{$fldk}} {
			if !validators.{{$fnname}}(v, args) {
				return fmt.Errorf("%v failed validation", path + "." + "{{$fldk}}")
			}
		}{{else}}{{/*<14>*/}}
		if !validators.{{$fnname}}(m.{{$fldk}}, args) {
			return fmt.Errorf("%v failed validation", path + "." + "{{$fldk}}")
		}{{end}}{{/*<14>*/}}{{end}}{{/*<11>*/}}
		return nil
	})
	{{end}}{{/*<10>*/}}{{end}}{{/*<9>*/}}{{end}}{{/*<8>*/}}{{end}}{{/*<7>*/}}{{end}}{{/*<3>*/}}{{end}}{{/*<2>*/}}
{{end}}{{/*<1>*/}}

{{if $storageTransformers.Fmap}}
	{{range .Messages}}{{$msgName := .Name}}{{with (index $storageTransformers.Map (derefStr .Name))}}
	{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{else}}
	{{range $fldv.Transformers}}{{if eq 0 (len .Args)}}
	{
	{{$msgName}}{{$fldk}}Tx, err := storage.New{{.Fn}}ValueTransformer()
	if err != nil {
		log.Fatalf("Error instantiating {{.Fn}}StorageTransformer: %v", err)
	}
	storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"] = append(storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"],
	func(ctx context.Context, i interface{}, toStorage bool) error {
		var data []byte
		var err error
		m := i.(*{{$msgName}})
		{{if $fldv.Repeated}}
		slice := make([]{{$fldv.TypeCast}}, 0)
		for _, v := range m.{{$fldk}} {
			if toStorage {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(v))
			} else {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(v))
			}
			if err != nil {
				return err
			}
			if data != nil {
				slice = append(slice, {{$fldv.TypeCast}}(data))
			}
		}
		m.{{$fldk}} = slice
		{{else}}
		if toStorage {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(m.{{$fldk}}))
		} else {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(m.{{$fldk}}))
		}
		m.{{$fldk}} = {{$fldv.TypeCast}}(data)
		{{end}}
		return err
	})
	}
	{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
{{end}}
}
