// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}} {{$file := .}}
*/
package {{.GoPkg.Name}}{{$validators := getValidatorManifest .}}{{$defaults := getDefaulterManifest .}}

import (
	fmt "fmt"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	{{if $validators.Fmap}}
	validators "github.com/pensando/sw/venice/utils/apigen/validators" {{end}}
	"github.com/pensando/sw/venice/globals"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient
{{if $validators.Fmap}}
var _ validators.DummyVar
var funcMap{{getFileName .Name}} = make(map[string]map[string][]func(interface{})bool)
{{end}}
{{range .Messages}}{{if (len (getDbKey .)) ne 0}}{{$sep := ", "}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}}) MakeKey(prefix string) string {
	return fmt.Sprint(globals.RootPrefix, "/", prefix, "/", {{range $index, $value := (getDbKey .)}}{{if ($index) ne 0}}{{$sep}}{{end}}{{if strEq $value.Type "prefix"}}"{{$value.Val}}"{{else}}m.{{$value.Val}}{{end}}{{$sep := ", "}}{{end}})
}{{end}}{{end}}

{{range .Messages}}{{if isListHelper .}}{{$type := getListType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isWatchHelper .}}{{$type := getWatchType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isNestedMessage .}}{{else}}
// Clone clones the object into into or creates one of into is nil
func (m *{{.Name}}) Clone(into interface{}) (interface{}, error) {
	var out *{{.Name}}
	var ok bool
	if into == nil {
		out = &{{.Name}}{}
	} else {
		out, ok = into.(*{{.Name}})
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *{{.Name}}) Defaults(ver string) bool { {{with index $defaults.Map (derefStr .Name)}}{{if eq (len .Fields) 0}}
	return false {{else}}
	var ret bool {{range $fldk, $defval := .Fields}}{{if $defval.Nested}}{{if $defval.Repeated}}
	for k := range m.{{$fldk}} { {{if $defval.Pointer}}
		if m.{{$fldk}}[k] != nil {
			ret = ret || m.{{$fldk}}[k].Defaults(ver)
		}{{else}}
		ret = ret || m.{{$fldk}}[k].Defaults(ver) {{end}}
	}{{else}}{{if $defval.Pointer}}
	for m.{{$fldk}} != nil {
		ret = ret || m.{{$fldk}}.Defaults(ver)
	}{{else}}
	ret = ret || m.{{$fldk}}.Defaults(ver){{end}}{{end}}{{end}}{{end}}{{if eq (len .Versions) 0}}{{else}}
	ret = true
	switch ver { {{range $ver, $verdef := .Versions}}{{if eq $ver "all"}}
	default: {{else}}
	case "{{$ver}}": {{end}}{{range $fldk, $def := $verdef}}{{/*<0>*/}}{{if $def.Repeated}}{{/*<1>*/}}
	for k := range m.{{$fldk}} { {{if $def.Pointer}}{{/*<2>*/}}
		if m.{{$fldk}}[k] != nil {
			*m.{{$fldk}}[k] = {{$def.Val}}
		} {{else}}
		m.{{$fldk}}[k] = {{$def.Val}}{{end}}{{/*<2>*/}}
	}{{else}}{{if $def.Pointer}}{{/*<3>*/}}
	if m.{{$fldk}} != nil {
		m.{{$fldk}} = {{$def.Val}}
	}{{else}}
	m.{{$fldk}} = {{$def.Val}}{{end}}{{/*<3>*/}}{{end}}{{/*<1>*/}}{{end}}{{/*<0>*/}}
	{{end}} }{{/*<lenVer!=0>*/}}{{end}}{{/*<rangeVersion>*/}}
	return ret{{end}}
} {{end}}{{end}}
{{end}}
// Validators
{{range .Messages}}{{if isNestedMessage .}}{{else}}{{$msg := .}}{{$msgname := .Name}}
func (m *{{.Name}}) Validate(ver string, ignoreStatus bool) bool { {{with (index $validators.Map (derefStr .Name))}}{{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{if $fldv.Repeated}}
	for _, v := range m.{{$fldk}} {
		 if !v.Validate(ver, ignoreStatus) {
			 return false
		 }
	} {{else}}{{if isSpecStatusMessage $msg}}{{if strEq $fldk "Status"}}
	if !ignoreStatus {
		if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
			return false
		}
	}{{else}}
	if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
		return false
	}{{end}}{{else}}
	if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
		return false
	}{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if vs, ok := funcMap{{getFileName $file.Name}}["{{$msgname}}"][ver]; ok {
		for _, v := range vs {
			if !v(m) {
				return false
			}
		}
	} else if vs, ok := funcMap{{getFileName $file.Name}}["{{$msgname}}"]["all"]; ok {
		for _, v := range vs {
			if !v(m) {
				return false
			}
		}
	} {{end}}{{end}}
	return true
}
{{end}}{{end}}


func init() { {{if $validators.Fmap}}
	funcMap{{getFileName .Name}} = make(map[string]map[string][]func(interface{})bool){{range .Messages}}{{$msgName := .Name}}{{with (index $validators.Map (derefStr .Name))}}
	{{$_ := saveBool true 1}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{else}}{{if getBool 1}}
	funcMap{{getFileName $file.Name}}["{{$msgName}}"] = make(map[string][]func(interface{})bool){{$_ := saveBool false 1}}{{end}}{{end}}{{end}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{else}}
	{{range $fldv.Validators}}{{if eq 0 (len .Args)}}
	funcMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(funcMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(i interface{}) bool {
		m := i.(*{{$msgName}})
		if !validators.{{.Fn}}(m.{{$fldk}}) {
			return false
		}
		return true
	})
		{{else}} funcMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(funcMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(i interface{}) bool {
		m := i.(*{{$msgName}})
		{{if (strEq .Fn "StrEnum")}}{{$enummap := (getEnumStrMap $file .Args)}}{{if $fldv.Repeated}}
		for _, v := range m.{{$fldk}} {
			if _, ok := {{$enummap}}[v]; !ok {
				return false
			}
		}{{else}}
		if _, ok := {{$enummap}}[m.{{$fldk}}]; !ok {
			return false
		}{{end}}{{else}}args := make([]string, 0) {{$fnname := .Fn}}
		{{range .Args}}args = append(args, "{{.}}")
		{{end}}{{if $fldv.Repeated}}
		for _, v := range m.{{$fldk}} {
			if !validators.{{$fnname}}(v, args) {
				return false
			}
		}{{else}}
		if !validators.{{$fnname}}(m.{{$fldk}}, args) {
			return false
		}{{end}}{{end}}
		return true
	})
	{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
}
