// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}} {{$file := .}}
*/
package {{.GoPkg.Name}}{{$validators := getValidatorManifest .}}{{$defaults := getDefaulterManifest .}}{{$storageTransformers := getStorageTransformersManifest .}}

import (
	"context"
	fmt "fmt"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	{{if $validators.Fmap}}
	validators "github.com/pensando/sw/venice/utils/apigen/validators"{{end}}
	{{if $storageTransformers.Fmap}}"github.com/pensando/sw/venice/utils/transformers/storage"{{end}}
	"github.com/pensando/sw/venice/globals"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient
{{if $validators.Fmap}}
var _ validators.DummyVar
var validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(interface{})bool)
{{end}}
{{if $storageTransformers.Fmap}}
var storageTransformersMap{{getFileName .Name}} = make(map[string][]func(ctx context.Context, i interface{}, toStorage bool) error) {{end}}
{{range .Messages}}{{if (len (getDbKey .)) ne 0}}{{$sep := ", "}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}}) MakeKey(prefix string) string {
	return fmt.Sprint(globals.RootPrefix, "/", prefix, "/", {{range $index, $value := (getDbKey .)}}{{if ($index) ne 0}}{{$sep}}{{end}}{{if strEq $value.Type "prefix"}}"{{$value.Val}}"{{else}}m.{{$value.Val}}{{end}}{{$sep := ", "}}{{end}})
}{{end}}{{end}}

{{range .Messages}}{{if isListHelper .}}{{$type := getListType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isWatchHelper .}}{{$type := getWatchType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}
// Clone clones the object into into or creates one of into is nil
func (m *{{getStr 0}}) Clone(into interface{}) (interface{}, error) {
	var out *{{getStr 0}}
	var ok bool
	if into == nil {
		out = &{{getStr 0}}{}
	} else {
		out, ok = into.(*{{getStr 0}})
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *{{getStr 0}}) Defaults(ver string) bool { {{with index $defaults.Map (getStr 0)}}{{if eq (len .Fields) 0}}
	return false {{else}}
	var ret bool {{range $fldk, $defval := .Fields}}{{if $defval.Nested}}{{if $defval.Repeated}}
	for k := range m.{{$fldk}} { {{if $defval.Pointer}}
		if m.{{$fldk}}[k] != nil {
			ret = ret || m.{{$fldk}}[k].Defaults(ver)
		}{{else}}
		ret = ret || m.{{$fldk}}[k].Defaults(ver) {{end}}
	}{{else}}{{if $defval.Pointer}}
	if m.{{$fldk}} != nil {
		ret = ret || m.{{$fldk}}.Defaults(ver)
	}{{else}}
	ret = ret || m.{{$fldk}}.Defaults(ver){{end}}{{end}}{{end}}{{end}}{{if eq (len .Versions) 0}}{{else}}
	ret = true
	switch ver { {{range $ver, $verdef := .Versions}}{{if eq $ver "all"}}
	default: {{else}}
	case "{{$ver}}": {{end}}{{range $fldk, $def := $verdef}}{{/*<0>*/}}{{if $def.Repeated}}{{/*<1>*/}}
	for k := range m.{{$fldk}} { {{if $def.Pointer}}{{/*<2>*/}}
		if m.{{$fldk}}[k] != nil {
			*m.{{$fldk}}[k] = {{$def.Val}}
		} {{else}}
		m.{{$fldk}}[k] = {{$def.Val}}{{end}}{{/*<2>*/}}
	}{{else}}{{if $def.Pointer}}{{/*<3>*/}}
	if m.{{$fldk}} != nil {
		m.{{$fldk}} = {{$def.Val}}
	}{{else}}
	m.{{$fldk}} = {{$def.Val}}{{end}}{{/*<3>*/}}{{end}}{{/*<1>*/}}{{end}}{{/*<0>*/}}
	{{end}} }{{/*<lenVer!=0>*/}}{{end}}{{/*<rangeVersion>*/}}
	return ret{{end}}
} {{end}}{{end}}
{{end}}
// Validators
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{$msg := .}}{{$msgname := (getStr 0)}}
func (m *{{$msgname}}) Validate(ver string, ignoreStatus bool) bool { {{with (index $validators.Map $msgname)}}{{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{if $fldv.Repeated}}
	for _, v := range m.{{$fldk}} {
		 if !v.Validate(ver, ignoreStatus) {
			 return false
		 }
	} {{else}}{{if isSpecStatusMessage $msg}}{{if strEq $fldk "Status"}}
	if !ignoreStatus {
		if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
			return false
		}
	}{{else}}
	if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
		return false
	}{{end}}{{else}}
	if {{if $fldv.Pointer}} m.{{$fldk}} != nil && {{end}}!m.{{$fldk}}.Validate(ver, ignoreStatus) {
		return false
	}{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"][ver]; ok {
		for _, v := range vs {
			if !v(m) {
				return false
			}
		}
	} else if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"]["all"]; ok {
		for _, v := range vs {
			if !v(m) {
				return false
			}
		}
	} {{end}}{{end}}
	return true
}
{{end}}{{end}}

{{if $storageTransformers.Fmap}}
// Transformers

{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{$msg := .}}{{$msgname := (getStr 0)}}{{with (index $storageTransformers.Map $msgname)}}{{if .HasTransformers}}
func (m *{{$msgname}}) ApplyStorageTransformer(ctx context.Context, toStorage bool) error { {{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{if $fldv.Repeated}}
	for i, v := range m.{{$fldk}} {
		 c := *v
		 if err := c.ApplyStorageTransformer(ctx, toStorage); err != nil {
			 return err
		 }
		 m.{{$fldk}}[i] = &c
	} {{else}}{{if isSpecStatusMessage $msg}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{else}}
	{{if $fldv.Pointer}}
	if m.{{$fldk}} == nil {
		return nil
	}{{end}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if vs, ok := storageTransformersMap{{getFileName $file.Name}}["{{$msgname}}"]; ok {
		for _, v := range vs {
			if err := v(ctx, m, toStorage); err != nil {
				return err
			}
		}
	} {{end}}
	return nil
}

{{if isSpecStatusMessage $msg}}
type storage{{$msgname}}Transformer struct {}
var Storage{{$msgname}}Transformer storage{{$msgname}}Transformer

func (st *storage{{$msgname}}Transformer) TransformFromStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, false)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (st *storage{{$msgname}}Transformer) TransformToStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, true)
	if err != nil {
		return nil, err
	}
	return r, nil
}
{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}

func init() {
	scheme := runtime.GetDefaultScheme()
	scheme.AddKnownTypes({{range  .Messages}}{{if (len (getDbKey .)) ne 0}}
		&{{.Name}}{},{{end}}{{end}}
	)
{{if $validators.Fmap}}
	validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(interface{})bool){{range .Messages}}{{$msgName := .Name}}{{with (index $validators.Map (derefStr .Name))}}
	{{$_ := saveBool true 1}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{else}}{{if getBool 1}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"] = make(map[string][]func(interface{})bool){{$_ := saveBool false 1}}{{end}}{{end}}{{end}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Validators)}}{{else}}
	{{range $fldv.Validators}}{{if eq 0 (len .Args)}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(i interface{}) bool {
		m := i.(*{{$msgName}})
		if !validators.{{.Fn}}(m.{{$fldk}}) {
			return false
		}
		return true
	})
		{{else}} validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(i interface{}) bool {
		m := i.(*{{$msgName}})
		{{if (strEq .Fn "StrEnum")}}{{$enummap := (getEnumStrMap $file .Args)}}{{if $fldv.Repeated}}
		for _, v := range m.{{$fldk}} {
			if _, ok := {{$enummap}}[v]; !ok {
				return false
			}
		}{{else}}
		if _, ok := {{$enummap}}[m.{{$fldk}}]; !ok {
			return false
		}{{end}}{{else}}args := make([]string, 0) {{$fnname := .Fn}}
		{{range .Args}}args = append(args, "{{.}}")
		{{end}}{{if $fldv.Repeated}}
		for _, v := range m.{{$fldk}} {
			if !validators.{{$fnname}}(v, args) {
				return false
			}
		}{{else}}
		if !validators.{{$fnname}}(m.{{$fldk}}, args) {
			return false
		}{{end}}{{end}}
		return true
	})
	{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
{{end}}

{{if $storageTransformers.Fmap}}
	{{range .Messages}}{{$msgName := .Name}}{{with (index $storageTransformers.Map (derefStr .Name))}}
	{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{else}}
	{{range $fldv.Transformers}}{{if eq 0 (len .Args)}}
	{
	{{$msgName}}{{$fldk}}Tx, err := storage.New{{.Fn}}ValueTransformer()
	if err != nil {
		log.Fatalf("Error instantiating {{.Fn}}StorageTransformer: %v", err)
	}
	storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"] = append(storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"],
	func(ctx context.Context, i interface{}, toStorage bool) error {
		var data []byte
		var err error
		m := i.(*{{$msgName}})
		{{if $fldv.Repeated}}
		slice := make([]{{$fldv.TypeCast}}, 0)
		for _, v := range m.{{$fldk}} {
			if toStorage {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(v))
			} else {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(v))
			}
			if err != nil {
				return err
			}
			if data != nil {
				slice = append(slice, {{$fldv.TypeCast}}(data))
			}
		}
		m.{{$fldk}} = slice
		{{else}}
		if toStorage {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(m.{{$fldk}}))
		} else {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(m.{{$fldk}}))
		}
		m.{{$fldk}} = {{$fldv.TypeCast}}(data)
		{{end}}
		return err
	})
	}
	{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
{{end}}
}
