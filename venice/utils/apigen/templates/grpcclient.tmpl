// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	{{.GoPkg.Name}} "{{.GoPkg.RelPath}}/generated/{{.GoPkg.Name}}"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
	"github.com/pensando/sw/venice/utils/kvstore"
	api "github.com/pensando/sw/api"
	apiserver "github.com/pensando/sw/venice/apiserver"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
)


// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface


{{$pkgname := .GoPkg.Name}}{{range .Services}}{{$srvname := .Name}}
// New{{$srvname}} sets up a new client for {{$srvname}}
func New{{$srvname}}(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.Service{{$srvname}}Client {
 {{range .Methods}}{{$params := (getMethodParams .)}}{{if (strEq $params.Oper "WatchOper")}}{{else}}
	var l{{.Name}}Endpoint endpoint.Endpoint
	{
		l{{.Name}}Endpoint = grpctransport.NewClient(
			conn,
			"{{$pkgname}}.{{$srvname}}",
			"{{.Name}}",
			{{$pkgname}}.EncodeGrpcReq{{.RequestType.Name}},
			{{$pkgname}}.DecodeGrpcResp{{.ResponseType.Name}},
			&{{getOutputType $pkgname . true}}{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
        l{{.Name}}Endpoint = trace.ClientEndPoint("{{$srvname}}:{{.Name}}")(l{{.Name}}Endpoint)
	} {{end}}{{end}}
	return {{$pkgname}}.Endpoints{{$srvname}}Client{
		Client: {{$pkgname}}.New{{$srvname}}Client(conn),
	{{range .Methods}}{{$params := (getMethodParams .)}}{{if (strEq $params.Oper "WatchOper")}}{{else}}
		{{.Name}}Endpoint:  l{{.Name}}Endpoint,{{end}} {{end}}
	}
}

// New{{$srvname}}Backend creates an instrumented client with middleware
func New{{$srvname}}Backend(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.Service{{$srvname}}Client {
	cl := New{{$srvname}}(conn, logger)
	cl = {{$pkgname}}.Logging{{$srvname}}MiddlewareClient(logger)(cl)
	return cl
}
{{end}}

{{range .Services}}{{$svc := .}}{{$srvname := .Name}}{{$version := getExtension "venice.apiVersion" .}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}{{$crudop := .}}
type grpcObj{{$srvname}}{{.}} struct {
	logger log.Logger
	client {{$pkgname}}.Service{{$srvname}}Client
}

func (a *grpcObj{{$srvname}}{{.}}) Create(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoAdd{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) Update(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoUpdate{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) Get(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoGet{{.}}(nctx, &in)
}

func (a *grpcObj{{$srvname}}{{.}}) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoDelete{{.}}(nctx, &in)
}

func (a *grpcObj{{$srvname}}{{.}}) List(ctx context.Context, options *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	r, err := a.client.AutoList{{.}}(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObj{{$srvname}}{{.}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "WatchOper")
	nctx := addVersion(ctx, "{{$version}}")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatch{{.}}(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.({{$pkgname}}.{{$srvname}}_AutoWatch{{.}}Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}
{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
func (a *grpcObj{{$srvname}}{{$crudop}}) {{.Name}}(ctx context.Context, in *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "{{.Name}}")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.{{.Name}}(nctx, in)
}
{{end}}

func (a *grpcObj{{$srvname}}{{.}}) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObj{{$srvname}}{{.}} struct {
	endpoints {{$pkgname}}.Endpoints{{$srvname}}RestClient
	instance string
}

func (a *restObj{{$srvname}}{{.}}) Create(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAdd{{.}}(ctx, in)
}

func (a *restObj{{$srvname}}{{.}}) Update(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdate{{.}}(ctx, in)
}

func (a *restObj{{$srvname}}{{.}}) Get(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGet{{.}}(ctx, &in)
}

func (a *restObj{{$srvname}}{{.}}) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDelete{{.}}(ctx, &in)
}

func (a *restObj{{$srvname}}{{.}}) List(ctx context.Context, options *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoList{{.}}(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObj{{$srvname}}{{.}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObj{{$srvname}}{{.}}) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
		case apiserver.CreateOper:
		{{if isRestMethod $svc "AutoAdd" .}} return true {{else}} return false {{end}}
		case apiserver.UpdateOper:
		{{if isRestMethod $svc "AutoUpdate" .}} return true {{else}} return false {{end}}
		case apiserver.GetOper:
		{{if isRestMethod $svc "AutoGet" .}} return true {{else}} return false {{end}}
		case apiserver.DeleteOper:
		{{if isRestMethod $svc "AutoDelete" .}} return true {{else}} return false {{end}}
		case apiserver.ListOper:
		{{if isRestMethod $svc "AutoList" .}} return true {{else}} return false {{end}}
		case apiserver.WatchOper:
		{{if isRestMethod $svc "AutoWatch" .}} return true {{else}} return false {{end}}
		default:
		return false
	}
}
{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
func (a *restObj{{$srvname}}{{$crudop}}) {{.Name}}(ctx context.Context, in *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.{{.Name}}{{$crudop}}(ctx, in)
}{{end}}
{{end}}{{end}}{{end}}

{{range .Services}}{{$srvname := .Name}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}
type crudClient{{$srvname}} struct {
	{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
	grpc{{.}} {{$pkgname}}.{{$srvname}}{{.}}Interface{{end}}
}

// NewGrpcCrudClient{{$srvname}} creates a GRPC client for the service
func NewGrpcCrudClient{{$srvname}}(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.{{$srvname}}Interface {
	client := New{{$srvname}}Backend(conn, logger)
	return &crudClient{{$srvname}}{
		{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
		grpc{{.}}: &grpcObj{{$srvname}}{{.}}{ client: client, logger: logger },{{end}}
	}
}
{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
func (a *crudClient{{$srvname}}) {{title .}}() {{$pkgname}}.{{$srvname}}{{.}}Interface {
	return a.grpc{{.}}
}
{{end}}

type crudRestClient{{$srvname}} struct {
	{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
	rest{{.}} {{$pkgname}}.{{$srvname}}{{.}}Interface{{end}}
}

// NewRestCrudClient{{$srvname}} creates a REST client for the service.
func NewRestCrudClient{{$srvname}}(url string) {{$pkgname}}.{{$srvname}}Interface {
	endpoints, err := {{$pkgname}}.Make{{$srvname}}RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClient{{$srvname}}{
		{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
		rest{{.}}: &restObj{{$srvname}}{{.}}{ endpoints: endpoints, instance: url},{{end}}
	}
}
{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
func (a *crudRestClient{{$srvname}}) {{title .}}() {{$pkgname}}.{{$srvname}}{{.}}Interface {
	return a.rest{{.}}
}
{{end}}

{{end}}{{end}}
