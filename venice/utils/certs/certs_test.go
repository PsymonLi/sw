package certs

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"io/ioutil"
	"log"
	"net/rpc"
	"os"
	"reflect"
	"strings"
	"testing"
)

const (
	numRsaBits = 4096
	days       = 365
)

func testSaveAndReadPrivateKey(privateKey crypto.PrivateKey, t *testing.T) {
	tmpfile, err := ioutil.TempFile("", "cert_test")
	if err != nil {
		log.Fatal(err)
	}
	tmpfileName := tmpfile.Name()
	defer os.Remove(tmpfileName)

	err = SavePrivateKey(tmpfileName, privateKey)
	if err != nil {
		t.Fatalf("SavePrivateKey fail. err: %s", err.Error())
	}

	readPrivateKey, err := ReadPrivateKey(tmpfileName)
	if err != nil {
		t.Fatalf("ReadPrivateKey fail. err: %s", err.Error())
	}
	if !reflect.DeepEqual(privateKey, readPrivateKey) {
		t.Fatalf("ReadPrivateKey is not same as expected PrivateKey")
	}
}

func TestSaveAndReadRsaPrivateKey(t *testing.T) {
	privateKey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadPrivateKey(privateKey, t)
}

func TestSaveAndReadEcPrivateKey(t *testing.T) {
	privateKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadPrivateKey(privateKey, t)
}

func testSaveAndReadCertificate(privateKey crypto.PrivateKey, t *testing.T) {
	tmpfile, err := ioutil.TempFile("", "cert_test")
	if err != nil {
		log.Fatal(err)
	}
	tmpfileName := tmpfile.Name()
	defer os.Remove(tmpfileName)

	cert, err := SelfSign(days, privateKey)
	if err != nil {
		log.Fatal(err)
	}

	err = SaveCertificate(tmpfileName, cert)
	if err != nil {
		t.Fatalf("SaveCertificate fail. err: %s", err.Error())
	}
	err = SaveCertificate("/tmp", cert)
	if err == nil {
		t.Fatalf("SaveCertificate succeeded writing to invalid filename.")
	}

	readCert, err := ReadCertificates(tmpfileName)
	if err != nil {
		t.Fatalf("ReadCertificate fail. err: %s", err.Error())
	}
	if !cert.Equal(readCert[0]) {
		t.Fatalf("read cert is not same as expected cert")
	}
}

func TestSaveAndReadRsaCertificate(t *testing.T) {
	privateKey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadCertificate(privateKey, t)
}

func TestSaveAndReadEcCertificate(t *testing.T) {
	privateKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadCertificate(privateKey, t)
}

func testSaveAndReadCSR(privateKey crypto.PrivateKey, t *testing.T) {
	tmpfile, err := ioutil.TempFile("", "cert_test")
	if err != nil {
		log.Fatal(err)
	}
	tmpfileName := tmpfile.Name()
	defer os.Remove(tmpfileName)

	certSignReq, err := CreateCSR(privateKey, nil, nil)
	if err != nil {
		log.Fatal(err)
	}
	SaveCSR(tmpfileName, certSignReq)

	readcsr, err := ReadCSR(tmpfileName)
	if err != nil {
		t.Fatalf("ReadCSR fail. err: %s", err.Error())
	}

	if !reflect.DeepEqual(readcsr, certSignReq) {
		t.Fatalf("read CSR is not same as expected cert")
	}
}

func TestSaveAndReadRsaCSR(t *testing.T) {
	privateKey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadCSR(privateKey, t)
}

func TestSaveAndReadEcCSR(t *testing.T) {
	privateKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	testSaveAndReadCSR(privateKey, t)
}

// Check that we can properly read a private key file generated by OpenSSL
// OpenSSL puts key parameters both in the key block itself and in a separate "EC PARAMETERS" block
func TestReadOpenSSLGeneratedEcKey(t *testing.T) {
	tmpFile, err := ioutil.TempFile("", "cert_test")
	if err != nil {
		log.Fatal(err)
	}
	tmpFileName := tmpFile.Name()
	defer os.Remove(tmpFileName)

	keyParamBlock := `
-----BEGIN EC PARAMETERS-----
BgUrgQQAIw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MIHcAgEBBEIBw19j4zd8aEMsCqBsGfrLT93ywnovsOEmTGkHnNZxQ+9U3HZvYEZA
QMUobxlj891ioExvRwm7aY7r6Hjnb+lCkLqgBwYFK4EEACOhgYkDgYYABADqG0/0
cp2+HjmqafBSgYonsrGboMHkLfT2J7YdGKZCCyebJMoDf6JBZxwcOKJ9mFj6wUy/
x0bxRsNd/YdNH9uiQwBt7vHGUb1uyEniyoFPyoVQqn6mqdp2nY21OwkHcMQ6U6C1
Uqvhc8wvGrVwYLlrIcGNcnZxEglGXJXTFwxQWSMuQQ==
-----END EC PRIVATE KEY-----
`
	_, err = tmpFile.WriteString(keyParamBlock)
	if err != nil {
		t.Fatalf("Error writing to temp file %v: %v", tmpFileName, err)
	}

	tmpFile.Sync()

	privateKey, err := ReadPrivateKey(tmpFileName)
	if err != nil {
		t.Fatalf("Error reading EC private key from file %v: %v", tmpFileName, err)
	}

	// compare against the key that we can parse directly out of the
	// "EC PRIVATE KEY" block
	_, keyBlock := pem.Decode([]byte(keyParamBlock))
	key, _ := pem.Decode(keyBlock)
	privateKeyRef, err := x509.ParseECPrivateKey(key.Bytes)
	if err != nil || !reflect.DeepEqual(privateKey, privateKeyRef) {
		t.Fatalf("Private key does not match")
	}

	// Try reverse as well, as it seems to be legal
	revKeyParamBlock := `
-----BEGIN EC PRIVATE KEY-----
MIHcAgEBBEIBw19j4zd8aEMsCqBsGfrLT93ywnovsOEmTGkHnNZxQ+9U3HZvYEZA
QMUobxlj891ioExvRwm7aY7r6Hjnb+lCkLqgBwYFK4EEACOhgYkDgYYABADqG0/0
cp2+HjmqafBSgYonsrGboMHkLfT2J7YdGKZCCyebJMoDf6JBZxwcOKJ9mFj6wUy/
x0bxRsNd/YdNH9uiQwBt7vHGUb1uyEniyoFPyoVQqn6mqdp2nY21OwkHcMQ6U6C1
Uqvhc8wvGrVwYLlrIcGNcnZxEglGXJXTFwxQWSMuQQ==
-----END EC PRIVATE KEY-----
-----BEGIN EC PARAMETERS-----
BgUrgQQAIw==
-----END EC PARAMETERS-----
`
	// rewind to beginning of file
	tmpFile.Seek(0, 0)
	_, err = tmpFile.WriteString(revKeyParamBlock)
	if err != nil {
		t.Fatalf("Error writing to temp file %v: %v", tmpFileName, err)
	}
	tmpFile.Sync()

	privateKey, err = ReadPrivateKey(tmpFileName)
	if err != nil {
		t.Fatalf("Error reading EC private key from file %v: %v", tmpFileName, err)
	}
	if !reflect.DeepEqual(privateKey, privateKeyRef) {
		t.Fatalf("Private key does not match")
	}
}

func TestCertificateValidationRoutines(t *testing.T) {
	// RSA keys
	rsaPrivateKey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}
	rsaPrivateKey2, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	// ECDSA keys
	ecdsaPrivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}
	ecdsaPrivateKey2, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}

	keys := [][]crypto.PrivateKey{
		{rsaPrivateKey, rsaPrivateKey2},
		{ecdsaPrivateKey, ecdsaPrivateKey2}}

	for i := 0; i < len(keys); i++ {
		privateKey := keys[i][0]
		altPrivateKey := keys[i][1]

		cert, err := SelfSign(days, privateKey)
		if err != nil {
			log.Fatal(err)
		}
		if !IsSelfSigned(cert) {
			t.Fatalf("Failed to detect self-signed certificate")
		}
		valid, err := ValidateKeyCertificatePair(privateKey, cert)
		if !valid || err != nil {
			t.Fatalf("Certificate failed key validation, error: %v", err)
		}
		// this is expected to fail
		valid, err = ValidateKeyCertificatePair(altPrivateKey, cert)
		if valid || err != nil {
			t.Fatalf("Certificate did not fail key validation, error: %v", err)
		}
	}
}

type Arith int
type Args struct {
	A, B int
}

type Reply struct {
	C int
}

func (t *Arith) Add(args Args, reply *Reply) error {
	reply.C = args.A + args.B
	return nil
}

func startServer(t *testing.T, serverCertFile, serverPrivKeyFile, caCertFile string) string {
	rpc.Register(new(Arith))

	cert, err := tls.LoadX509KeyPair(serverCertFile, serverPrivKeyFile)
	if err != nil {
		log.Fatalf("server: loadkeys: %s", err)
	}

	bytes, err := ioutil.ReadFile(caCertFile)
	if err != nil {
		log.Fatal(err)
	}
	block, _ := pem.Decode(bytes)
	ca, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		log.Fatal(err)
	}
	certPool := x509.NewCertPool()
	certPool.AddCert(ca)
	config := tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    certPool,

		// not needed for pure  servers. But if we are clients also, we will need this.
		RootCAs: certPool,
	}
	config.Rand = rand.Reader

	service, _ := os.Hostname()
	service = service + ":0" // any available address
	listener, err := tls.Listen("tcp", service, &config)
	if err != nil {
		log.Fatalf("server: listen: %s", err)
	}
	serverAddr := listener.Addr().String()
	log.Println("Test RPC server listening on", serverAddr)
	go rpc.Accept(listener)
	return serverAddr
}

func generateKeysAndCerts(t *testing.T, caCertFile, serverCertFile, serverPrivKeyFile, clientCertFile, clientPrivKeyFile string) {
	days := 365
	numRsaBits := 2048
	caprivatekey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatalf("GenerateKey fail. err: %s", err.Error())
	}
	cacert, err := SelfSign(days, caprivatekey)
	if err != nil {
		t.Fatal(err)
	}
	SaveCertificate(caCertFile, cacert)

	srvprivatekey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatal(err)
	}
	SavePrivateKey(serverPrivKeyFile, srvprivatekey)
	csr, err := CreateCSR(srvprivatekey, nil, nil)
	if err != nil {
		t.Fatal(err)
	}
	srvcert, err := SignCSRwithCA(days, csr, cacert, caprivatekey)
	if err != nil {
		t.Fatal(err)
	}
	SaveCertificate(serverCertFile, srvcert)

	clientprivatekey, err := rsa.GenerateKey(rand.Reader, numRsaBits)
	if err != nil {
		t.Fatal(err)
	}
	SavePrivateKey(clientPrivKeyFile, clientprivatekey)
	csr, err = CreateCSR(clientprivatekey, nil, nil)
	if err != nil {
		t.Fatal(err)
	}
	clientcert, err := SignCSRwithCA(days, csr, cacert, caprivatekey)
	if err != nil {
		t.Fatal(err)
	}
	SaveCertificate(clientCertFile, clientcert)
}

func TestRPC(t *testing.T) {
	F, err := ioutil.TempFile("", "serverCertFile")
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	serverCertFile := F.Name()
	defer os.Remove(serverCertFile)
	F, err = ioutil.TempFile("", "serverPrivKeyFile")
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	serverPrivKeyFile := F.Name()
	defer os.Remove(serverPrivKeyFile)
	F, err = ioutil.TempFile("", "caCertFile")
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	caCertFile := F.Name()
	defer os.Remove(caCertFile)
	F, err = ioutil.TempFile("", "clientCertFile")
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	clientCertFile := F.Name()
	defer os.Remove(clientCertFile)
	F, err = ioutil.TempFile("", "clientPrivKeyFile")
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	clientPrivKeyFile := F.Name()
	defer os.Remove(clientPrivKeyFile)

	generateKeysAndCerts(t, caCertFile, serverCertFile, serverPrivKeyFile, clientCertFile, clientPrivKeyFile)
	serverAddr := startServer(t, serverCertFile, serverPrivKeyFile, caCertFile)

	// start client with the IPaddress:port and connect to server with RPC request
	startClientAndDoRPC(t, serverAddr, clientCertFile, clientPrivKeyFile, caCertFile)

	serverPort := strings.Split(serverAddr, ":")[1]
	hostname, _ := os.Hostname()
	serverAddrWithName := hostname + ":" + serverPort
	// start client with the hostname:port and connect to server with RPC request
	startClientAndDoRPC(t, serverAddrWithName, clientCertFile, clientPrivKeyFile, caCertFile)
}

func startClientAndDoRPC(t *testing.T, addr string, clientCertFile, clientPrivKeyFile, caCertFile string) {
	cert, err := tls.LoadX509KeyPair(clientCertFile, clientPrivKeyFile)
	if err != nil {
		t.Fatalf("client: loadkeys: %s", err)
	}
	bytes, err := ioutil.ReadFile(caCertFile)
	if err != nil {
		t.Fatal(err)
	}
	block, _ := pem.Decode(bytes)
	ca, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		t.Fatal(err)
	}

	certPool := x509.NewCertPool()
	certPool.AddCert(ca)
	config := tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      certPool,

		// not needed for pure  clients. But if we are server also, then we will need this.
		ClientAuth: tls.RequireAndVerifyClientCert,
		ClientCAs:  certPool,
	}

	conn, err := tls.Dial("tcp", addr, &config)
	if err != nil {
		t.Fatalf("client: dial: %s while connecting to server: %s", err, addr)
	}
	defer conn.Close()
	log.Println("client: Dial: ", addr, " connected to: ", conn.RemoteAddr())
	rpcClient := rpc.NewClient(conn)

	args := &Args{7, 8}
	reply := new(Reply)
	err = rpcClient.Call("Arith.Add", args, reply)
	if err != nil {
		t.Errorf("Add: expected no error but got string %q", err.Error())
	}
	if reply.C != args.A+args.B {
		t.Errorf("Add: expected %d got %d", reply.C, args.A+args.B)
	}
}
