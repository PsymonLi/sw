// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: diskupdate.proto

/*
	Package protos is a generated protocol buffer package.

	It is generated from these files:
		diskupdate.proto

	It has these top-level messages:
		DiskUpdateStatus
		DiskUpdateSpec
		DiskUpdate
*/
package protos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import api "github.com/pensando/sw/api"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// DiskUpdateStatus represents operational parameters of the disk
type DiskUpdateStatus struct {
	// NodeID is the ID of the corresponding venice node
	NodeID string `protobuf:"bytes,1,opt,name=NodeID,json=nodeID,proto3" json:"node"`
	// Path is the path of the subfolder on the disk (example: fwlogs.fwlogs)
	Path string `protobuf:"bytes,2,opt,name=Path,json=path,proto3" json:"path"`
	// Size is the total size of the disk partition
	Size_ uint64 `protobuf:"varint,3,opt,name=Size,json=size,proto3" json:"size"`
	// UsedByNamespace is the size used by the namepace on the disk
	UsedByNamespace uint64 `protobuf:"varint,4,opt,name=UsedByNamespace,json=usedByNamespace,proto3" json:"usedbynamespace"`
}

func (m *DiskUpdateStatus) Reset()                    { *m = DiskUpdateStatus{} }
func (m *DiskUpdateStatus) String() string            { return proto.CompactTextString(m) }
func (*DiskUpdateStatus) ProtoMessage()               {}
func (*DiskUpdateStatus) Descriptor() ([]byte, []int) { return fileDescriptorDiskupdate, []int{0} }

func (m *DiskUpdateStatus) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *DiskUpdateStatus) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DiskUpdateStatus) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DiskUpdateStatus) GetUsedByNamespace() uint64 {
	if m != nil {
		return m.UsedByNamespace
	}
	return 0
}

// DiskUpdateSpec represents the config parameters of the disk
type DiskUpdateSpec struct {
}

func (m *DiskUpdateSpec) Reset()                    { *m = DiskUpdateSpec{} }
func (m *DiskUpdateSpec) String() string            { return proto.CompactTextString(m) }
func (*DiskUpdateSpec) ProtoMessage()               {}
func (*DiskUpdateSpec) Descriptor() ([]byte, []int) { return fileDescriptorDiskupdate, []int{1} }

// DiskUpdate represents the disk update message going from Vos to its consumers like Spyglass
type DiskUpdate struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,json=t,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=o,embedded=O" json:"meta,inline"`
	Spec           DiskUpdateSpec   `protobuf:"bytes,3,opt,name=Spec,json=spec" json:"spec"`
	Status         DiskUpdateStatus `protobuf:"bytes,4,opt,name=Status,json=status" json:"status"`
}

func (m *DiskUpdate) Reset()                    { *m = DiskUpdate{} }
func (m *DiskUpdate) String() string            { return proto.CompactTextString(m) }
func (*DiskUpdate) ProtoMessage()               {}
func (*DiskUpdate) Descriptor() ([]byte, []int) { return fileDescriptorDiskupdate, []int{2} }

func (m *DiskUpdate) GetSpec() DiskUpdateSpec {
	if m != nil {
		return m.Spec
	}
	return DiskUpdateSpec{}
}

func (m *DiskUpdate) GetStatus() DiskUpdateStatus {
	if m != nil {
		return m.Status
	}
	return DiskUpdateStatus{}
}

func init() {
	proto.RegisterType((*DiskUpdateStatus)(nil), "protos.DiskUpdateStatus")
	proto.RegisterType((*DiskUpdateSpec)(nil), "protos.DiskUpdateSpec")
	proto.RegisterType((*DiskUpdate)(nil), "protos.DiskUpdate")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ObjstoreInternalService service

type ObjstoreInternalServiceClient interface {
	WatchDiskThresholdUpdates(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (ObjstoreInternalService_WatchDiskThresholdUpdatesClient, error)
}

type objstoreInternalServiceClient struct {
	cc *grpc.ClientConn
}

func NewObjstoreInternalServiceClient(cc *grpc.ClientConn) ObjstoreInternalServiceClient {
	return &objstoreInternalServiceClient{cc}
}

func (c *objstoreInternalServiceClient) WatchDiskThresholdUpdates(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (ObjstoreInternalService_WatchDiskThresholdUpdatesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjstoreInternalService_serviceDesc.Streams[0], c.cc, "/protos.ObjstoreInternalService/WatchDiskThresholdUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &objstoreInternalServiceWatchDiskThresholdUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjstoreInternalService_WatchDiskThresholdUpdatesClient interface {
	Recv() (*DiskUpdate, error)
	grpc.ClientStream
}

type objstoreInternalServiceWatchDiskThresholdUpdatesClient struct {
	grpc.ClientStream
}

func (x *objstoreInternalServiceWatchDiskThresholdUpdatesClient) Recv() (*DiskUpdate, error) {
	m := new(DiskUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ObjstoreInternalService service

type ObjstoreInternalServiceServer interface {
	WatchDiskThresholdUpdates(*api.ListWatchOptions, ObjstoreInternalService_WatchDiskThresholdUpdatesServer) error
}

func RegisterObjstoreInternalServiceServer(s *grpc.Server, srv ObjstoreInternalServiceServer) {
	s.RegisterService(&_ObjstoreInternalService_serviceDesc, srv)
}

func _ObjstoreInternalService_WatchDiskThresholdUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjstoreInternalServiceServer).WatchDiskThresholdUpdates(m, &objstoreInternalServiceWatchDiskThresholdUpdatesServer{stream})
}

type ObjstoreInternalService_WatchDiskThresholdUpdatesServer interface {
	Send(*DiskUpdate) error
	grpc.ServerStream
}

type objstoreInternalServiceWatchDiskThresholdUpdatesServer struct {
	grpc.ServerStream
}

func (x *objstoreInternalServiceWatchDiskThresholdUpdatesServer) Send(m *DiskUpdate) error {
	return x.ServerStream.SendMsg(m)
}

var _ObjstoreInternalService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ObjstoreInternalService",
	HandlerType: (*ObjstoreInternalServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchDiskThresholdUpdates",
			Handler:       _ObjstoreInternalService_WatchDiskThresholdUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "diskupdate.proto",
}

func (m *DiskUpdateStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskUpdateStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiskupdate(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiskupdate(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDiskupdate(dAtA, i, uint64(m.Size_))
	}
	if m.UsedByNamespace != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDiskupdate(dAtA, i, uint64(m.UsedByNamespace))
	}
	return i, nil
}

func (m *DiskUpdateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskUpdateSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DiskUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDiskupdate(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintDiskupdate(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDiskupdate(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintDiskupdate(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func encodeVarintDiskupdate(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DiskUpdateStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovDiskupdate(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovDiskupdate(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovDiskupdate(uint64(m.Size_))
	}
	if m.UsedByNamespace != 0 {
		n += 1 + sovDiskupdate(uint64(m.UsedByNamespace))
	}
	return n
}

func (m *DiskUpdateSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DiskUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovDiskupdate(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovDiskupdate(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovDiskupdate(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovDiskupdate(uint64(l))
	return n
}

func sovDiskupdate(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDiskupdate(x uint64) (n int) {
	return sovDiskupdate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DiskUpdateStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiskupdate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskUpdateStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskUpdateStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedByNamespace", wireType)
			}
			m.UsedByNamespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedByNamespace |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiskupdate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiskupdate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskUpdateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiskupdate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskUpdateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskUpdateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDiskupdate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiskupdate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiskupdate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiskupdate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiskupdate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiskupdate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDiskupdate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDiskupdate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiskupdate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDiskupdate
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDiskupdate
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDiskupdate(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDiskupdate = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDiskupdate   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("diskupdate.proto", fileDescriptorDiskupdate) }

var fileDescriptorDiskupdate = []byte{
	// 517 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xed, 0x96, 0x28, 0xc0, 0xa6, 0xb4, 0xd1, 0x56, 0x50, 0x27, 0xaa, 0x92, 0x28, 0x12, 0x52,
	0x0f, 0x10, 0x97, 0x20, 0x21, 0x2e, 0x48, 0xc8, 0x2a, 0x87, 0x22, 0x68, 0x2a, 0x27, 0x15, 0xe7,
	0xb5, 0x3d, 0xd8, 0xdb, 0x3a, 0xbb, 0xab, 0xec, 0x3a, 0x28, 0xbd, 0x70, 0xc8, 0x1f, 0x70, 0xe4,
	0xc8, 0x0f, 0xf0, 0x1b, 0x3d, 0xf6, 0x0b, 0x22, 0x94, 0x63, 0x8e, 0x7c, 0x01, 0xf2, 0x38, 0xa5,
	0x46, 0xc0, 0x65, 0xd7, 0x33, 0xf3, 0xde, 0xf8, 0xbd, 0x27, 0x9b, 0xd6, 0x23, 0x61, 0x2e, 0x32,
	0x1d, 0x71, 0x0b, 0x3d, 0x3d, 0x51, 0x56, 0xb1, 0x2a, 0x5e, 0xa6, 0xb9, 0x1f, 0x2b, 0x15, 0xa7,
	0xe0, 0x72, 0x2d, 0x5c, 0x2e, 0xa5, 0xb2, 0xdc, 0x0a, 0x25, 0x4d, 0x81, 0x6a, 0xbe, 0x89, 0x85,
	0x4d, 0xb2, 0xa0, 0x17, 0xaa, 0xb1, 0xab, 0x41, 0x1a, 0x2e, 0x23, 0xe5, 0x9a, 0x4f, 0xee, 0x14,
	0xa4, 0x08, 0xc1, 0xcd, 0xac, 0x48, 0x4d, 0x4e, 0x8d, 0x41, 0x96, 0xd9, 0xae, 0x90, 0x61, 0x9a,
	0x45, 0x70, 0xb3, 0xe6, 0xf1, 0x7f, 0xd6, 0xe4, 0x2f, 0x1d, 0x83, 0xe5, 0x6b, 0xd8, 0xd3, 0x12,
	0x2c, 0x56, 0xb1, 0x72, 0xb1, 0x1d, 0x64, 0x1f, 0xb1, 0xc2, 0x02, 0x9f, 0x0a, 0x78, 0xf7, 0x3b,
	0xa1, 0xf5, 0x23, 0x61, 0x2e, 0xce, 0xd0, 0xd7, 0xd0, 0x72, 0x9b, 0x19, 0xd6, 0xa1, 0xd5, 0x13,
	0x15, 0xc1, 0xf1, 0x91, 0x43, 0x3a, 0xe4, 0xe0, 0xbe, 0x77, 0x6f, 0xb5, 0x68, 0x57, 0xa4, 0x8a,
	0xc0, 0xaf, 0x4a, 0xec, 0xb3, 0x7d, 0x5a, 0x39, 0xe5, 0x36, 0x71, 0x36, 0x6f, 0xe7, 0x9a, 0xdb,
	0xc4, 0xc7, 0x33, 0x9f, 0x0e, 0xc5, 0x25, 0x38, 0x77, 0x3a, 0xe4, 0xa0, 0x52, 0x4c, 0x8d, 0xb8,
	0x04, 0x1f, 0x4f, 0xf6, 0x8a, 0xee, 0x9c, 0x19, 0x88, 0xbc, 0xd9, 0x09, 0x1f, 0x83, 0xd1, 0x3c,
	0x04, 0xa7, 0x82, 0xc0, 0xdd, 0xd5, 0xa2, 0xbd, 0x93, 0x19, 0x88, 0x82, 0x99, 0xbc, 0x19, 0xf9,
	0xd8, 0x28, 0x61, 0xbb, 0x75, 0xba, 0x5d, 0x12, 0xac, 0x21, 0xec, 0xfe, 0x24, 0x94, 0xde, 0xb6,
	0xd8, 0x21, 0x25, 0x23, 0x14, 0x5e, 0xeb, 0x3f, 0xe8, 0x71, 0x2d, 0x7a, 0xa3, 0x99, 0x86, 0xf7,
	0x60, 0xb9, 0xb7, 0x7b, 0xb5, 0x68, 0x6f, 0x5c, 0x2f, 0xda, 0x64, 0xb5, 0x68, 0xdf, 0x7d, 0x22,
	0x64, 0x2a, 0x24, 0xf8, 0xc4, 0xb2, 0x17, 0x94, 0x0c, 0xd0, 0x4a, 0xad, 0xbf, 0x83, 0x8c, 0x41,
	0x70, 0x0e, 0xa1, 0x45, 0xce, 0x5e, 0x89, 0x53, 0xcb, 0x73, 0xfe, 0xcd, 0x53, 0xec, 0x25, 0xad,
	0xe4, 0x02, 0xd0, 0x67, 0xad, 0xff, 0xa8, 0x88, 0xd4, 0xf4, 0xfe, 0x94, 0xe7, 0x6d, 0xe5, 0x1b,
	0x30, 0x03, 0x0d, 0xa1, 0x8f, 0x27, 0x7b, 0x4d, 0xab, 0x45, 0xd6, 0x68, 0xbd, 0xd6, 0x77, 0xfe,
	0xc1, 0xc5, 0xb9, 0xb7, 0xbd, 0x66, 0x57, 0x0d, 0xd6, 0xfe, 0xfa, 0xee, 0x7f, 0xa6, 0x7b, 0x83,
	0xe0, 0xdc, 0x58, 0x35, 0x81, 0x63, 0x69, 0x61, 0x22, 0x79, 0x3a, 0x84, 0xc9, 0x54, 0x84, 0xc0,
	0xde, 0xd2, 0xc6, 0x07, 0x6e, 0xc3, 0x24, 0xdf, 0x35, 0x4a, 0x26, 0x60, 0x12, 0x95, 0x46, 0xc5,
	0x52, 0xc3, 0x1e, 0xa2, 0xc1, 0x77, 0xc2, 0x58, 0xc4, 0x0c, 0x34, 0x7e, 0x6c, 0x4d, 0xf6, 0xb7,
	0x80, 0xee, 0xc6, 0x21, 0x69, 0x3a, 0x5f, 0xe6, 0x8d, 0xcd, 0xe9, 0xb3, 0xaf, 0xf3, 0xc6, 0xc6,
	0xb7, 0x79, 0xa3, 0x14, 0xb3, 0xb7, 0x75, 0xb5, 0x6c, 0x91, 0xeb, 0x65, 0x8b, 0xfc, 0x58, 0xb6,
	0xc8, 0x29, 0x09, 0x8a, 0x9f, 0xe1, 0xf9, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xc0, 0xf7,
	0x7f, 0x27, 0x03, 0x00, 0x00,
}
