// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: module.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		module.proto
		service.proto

	It has these top-level messages:
		ModuleSpec
		ModuleStatus
		Module
		ModuleList
		ServiceInstance
		Service
		ServiceList
*/
package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import api "github.com/pensando/sw/api"
import api1 "github.com/pensando/sw/api"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ModuleType contains the type of module.
type ModuleSpec_ModuleType int32

const (
	// Singleton module type runs at the leader node.
	ModuleSpec_Singleton ModuleSpec_ModuleType = 0
	// DaemonSet module type runs on all controller nodes.
	ModuleSpec_DaemonSet ModuleSpec_ModuleType = 1
	// ReplicaSet module type runs NumCopies number of instances.
	ModuleSpec_ReplicaSet ModuleSpec_ModuleType = 2
)

var ModuleSpec_ModuleType_name = map[int32]string{
	0: "Singleton",
	1: "DaemonSet",
	2: "ReplicaSet",
}
var ModuleSpec_ModuleType_value = map[string]int32{
	"Singleton":  0,
	"DaemonSet":  1,
	"ReplicaSet": 2,
}

func (x ModuleSpec_ModuleType) String() string {
	return proto.EnumName(ModuleSpec_ModuleType_name, int32(x))
}
func (ModuleSpec_ModuleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorModule, []int{0, 0}
}

// ModuleSpec contains the configuration for a module that runs in a Venice cluster.
// Each module can consist of multiple processes (or submodules) that are scheduled
// together. Each submodule can support one or more services. Each service runs at
// a port.
type ModuleSpec struct {
	// Type contains the type of the module.
	Type ModuleSpec_ModuleType `protobuf:"varint,1,opt,name=Type,proto3,enum=types.ModuleSpec_ModuleType" json:"Type,omitempty"`
	// NumCopies identifies the number of instances to run, for example with
	// ReplicaSet.
	NumCopies uint32 `protobuf:"varint,2,opt,name=NumCopies,proto3" json:"NumCopies,omitempty"`
	// Submodules contains the list of submodules for this module.
	Submodules []*ModuleSpec_Submodule `protobuf:"bytes,3,rep,name=Submodules" json:"Submodules,omitempty"`
	// Volumes contains the list of volumes for this module.
	Volumes []*ModuleSpec_Volume `protobuf:"bytes,4,rep,name=Volumes" json:"Volumes,omitempty"`
}

func (m *ModuleSpec) Reset()                    { *m = ModuleSpec{} }
func (m *ModuleSpec) String() string            { return proto.CompactTextString(m) }
func (*ModuleSpec) ProtoMessage()               {}
func (*ModuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{0} }

func (m *ModuleSpec) GetType() ModuleSpec_ModuleType {
	if m != nil {
		return m.Type
	}
	return ModuleSpec_Singleton
}

func (m *ModuleSpec) GetNumCopies() uint32 {
	if m != nil {
		return m.NumCopies
	}
	return 0
}

func (m *ModuleSpec) GetSubmodules() []*ModuleSpec_Submodule {
	if m != nil {
		return m.Submodules
	}
	return nil
}

func (m *ModuleSpec) GetVolumes() []*ModuleSpec_Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

// Submodule contains the information about a single process in a module.
type ModuleSpec_Submodule struct {
	// Name identifies the submodule.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Image identifies the image used to run this submodule.
	Image string `protobuf:"bytes,2,opt,name=Image,proto3" json:"Image,omitempty"`
	// Services contain the list of services supported by the submodule.
	Services []*ModuleSpec_Submodule_Service `protobuf:"bytes,3,rep,name=Services" json:"Services,omitempty"`
	// Privileged specifies whether this is a privileged submodule.
	Privileged bool `protobuf:"varint,4,opt,name=Privileged,proto3" json:"Privileged,omitempty"`
}

func (m *ModuleSpec_Submodule) Reset()                    { *m = ModuleSpec_Submodule{} }
func (m *ModuleSpec_Submodule) String() string            { return proto.CompactTextString(m) }
func (*ModuleSpec_Submodule) ProtoMessage()               {}
func (*ModuleSpec_Submodule) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{0, 0} }

func (m *ModuleSpec_Submodule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModuleSpec_Submodule) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ModuleSpec_Submodule) GetServices() []*ModuleSpec_Submodule_Service {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *ModuleSpec_Submodule) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

// Service defines the attributes of a service supported by this module.
type ModuleSpec_Submodule_Service struct {
	// Name specifies the name of the service.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Port specifies the port where the service runs.
	Port uint32 `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *ModuleSpec_Submodule_Service) Reset()         { *m = ModuleSpec_Submodule_Service{} }
func (m *ModuleSpec_Submodule_Service) String() string { return proto.CompactTextString(m) }
func (*ModuleSpec_Submodule_Service) ProtoMessage()    {}
func (*ModuleSpec_Submodule_Service) Descriptor() ([]byte, []int) {
	return fileDescriptorModule, []int{0, 0, 0}
}

func (m *ModuleSpec_Submodule_Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModuleSpec_Submodule_Service) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Volume defines the storage for a module. Currently, it only supports
// local storage.
type ModuleSpec_Volume struct {
	// Name contains the name of the volume.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// HostPath contains the host directory/file being mounted.
	HostPath string `protobuf:"bytes,2,opt,name=HostPath,proto3" json:"HostPath,omitempty"`
	// MountPath contains the directory/file name of the mounted path.
	MountPath string `protobuf:"bytes,3,opt,name=MountPath,proto3" json:"MountPath,omitempty"`
}

func (m *ModuleSpec_Volume) Reset()                    { *m = ModuleSpec_Volume{} }
func (m *ModuleSpec_Volume) String() string            { return proto.CompactTextString(m) }
func (*ModuleSpec_Volume) ProtoMessage()               {}
func (*ModuleSpec_Volume) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{0, 1} }

func (m *ModuleSpec_Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModuleSpec_Volume) GetHostPath() string {
	if m != nil {
		return m.HostPath
	}
	return ""
}

func (m *ModuleSpec_Volume) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

type ModuleStatus struct {
	// Nodes contains the hosts where the module instances are running.
	Nodes []string `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
}

func (m *ModuleStatus) Reset()                    { *m = ModuleStatus{} }
func (m *ModuleStatus) String() string            { return proto.CompactTextString(m) }
func (*ModuleStatus) ProtoMessage()               {}
func (*ModuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{1} }

func (m *ModuleStatus) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// Module represents a module running in a Venice cluster.
type Module struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the module.
	Spec *ModuleSpec `protobuf:"bytes,3,opt,name=Spec" json:"Spec,omitempty"`
	// Status contains the current state of the module.
	Status *ModuleStatus `protobuf:"bytes,4,opt,name=Status" json:"Status,omitempty"`
}

func (m *Module) Reset()                    { *m = Module{} }
func (m *Module) String() string            { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()               {}
func (*Module) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{2} }

func (m *Module) GetSpec() *ModuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Module) GetStatus() *ModuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ModuleList contains list of Modules.
type ModuleList struct {
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ListMeta `protobuf:"bytes,2,opt,name=L,embedded=L" json:"meta,omitempty"`
	// Items contains list of Modules.
	Items []*Module `protobuf:"bytes,3,rep,name=Items" json:"Items,omitempty"`
}

func (m *ModuleList) Reset()                    { *m = ModuleList{} }
func (m *ModuleList) String() string            { return proto.CompactTextString(m) }
func (*ModuleList) ProtoMessage()               {}
func (*ModuleList) Descriptor() ([]byte, []int) { return fileDescriptorModule, []int{3} }

func (m *ModuleList) GetItems() []*Module {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterType((*ModuleSpec)(nil), "types.ModuleSpec")
	proto.RegisterType((*ModuleSpec_Submodule)(nil), "types.ModuleSpec.Submodule")
	proto.RegisterType((*ModuleSpec_Submodule_Service)(nil), "types.ModuleSpec.Submodule.Service")
	proto.RegisterType((*ModuleSpec_Volume)(nil), "types.ModuleSpec.Volume")
	proto.RegisterType((*ModuleStatus)(nil), "types.ModuleStatus")
	proto.RegisterType((*Module)(nil), "types.Module")
	proto.RegisterType((*ModuleList)(nil), "types.ModuleList")
	proto.RegisterEnum("types.ModuleSpec_ModuleType", ModuleSpec_ModuleType_name, ModuleSpec_ModuleType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ModuleAPI service

type ModuleAPIClient interface {
	// List all Modules
	ListModules(ctx context.Context, in *api1.Empty, opts ...grpc.CallOption) (*ModuleList, error)
	// Get a Module
	GetModule(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Module, error)
}

type moduleAPIClient struct {
	cc *grpc.ClientConn
}

func NewModuleAPIClient(cc *grpc.ClientConn) ModuleAPIClient {
	return &moduleAPIClient{cc}
}

func (c *moduleAPIClient) ListModules(ctx context.Context, in *api1.Empty, opts ...grpc.CallOption) (*ModuleList, error) {
	out := new(ModuleList)
	err := grpc.Invoke(ctx, "/types.ModuleAPI/ListModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleAPIClient) GetModule(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Module, error) {
	out := new(Module)
	err := grpc.Invoke(ctx, "/types.ModuleAPI/GetModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ModuleAPI service

type ModuleAPIServer interface {
	// List all Modules
	ListModules(context.Context, *api1.Empty) (*ModuleList, error)
	// Get a Module
	GetModule(context.Context, *api.ObjectMeta) (*Module, error)
}

func RegisterModuleAPIServer(s *grpc.Server, srv ModuleAPIServer) {
	s.RegisterService(&_ModuleAPI_serviceDesc, srv)
}

func _ModuleAPI_ListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleAPIServer).ListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.ModuleAPI/ListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleAPIServer).ListModules(ctx, req.(*api1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleAPI_GetModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleAPIServer).GetModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.ModuleAPI/GetModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleAPIServer).GetModule(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

var _ModuleAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.ModuleAPI",
	HandlerType: (*ModuleAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListModules",
			Handler:    _ModuleAPI_ListModules_Handler,
		},
		{
			MethodName: "GetModule",
			Handler:    _ModuleAPI_GetModule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "module.proto",
}

func (m *ModuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModule(dAtA, i, uint64(m.Type))
	}
	if m.NumCopies != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModule(dAtA, i, uint64(m.NumCopies))
	}
	if len(m.Submodules) > 0 {
		for _, msg := range m.Submodules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintModule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ModuleSpec_Submodule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSpec_Submodule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Privileged {
		dAtA[i] = 0x20
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModuleSpec_Submodule_Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSpec_Submodule_Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModule(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *ModuleSpec_Volume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSpec_Volume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.HostPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.HostPath)))
		i += copy(dAtA[i:], m.HostPath)
	}
	if len(m.MountPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModule(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	return i, nil
}

func (m *ModuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, s := range m.Nodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintModule(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintModule(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModule(dAtA, i, uint64(m.Spec.Size()))
		n3, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModule(dAtA, i, uint64(m.Status.Size()))
		n4, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ModuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintModule(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintModule(dAtA, i, uint64(m.ListMeta.Size()))
	n6, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Module(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Module(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintModule(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ModuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovModule(uint64(m.Type))
	}
	if m.NumCopies != 0 {
		n += 1 + sovModule(uint64(m.NumCopies))
	}
	if len(m.Submodules) > 0 {
		for _, e := range m.Submodules {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	return n
}

func (m *ModuleSpec_Submodule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	if m.Privileged {
		n += 2
	}
	return n
}

func (m *ModuleSpec_Submodule_Service) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovModule(uint64(m.Port))
	}
	return n
}

func (m *ModuleSpec_Volume) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	l = len(m.HostPath)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	return n
}

func (m *ModuleStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, s := range m.Nodes {
			l = len(s)
			n += 1 + l + sovModule(uint64(l))
		}
	}
	return n
}

func (m *Module) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovModule(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovModule(uint64(l))
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovModule(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovModule(uint64(l))
	}
	return n
}

func (m *ModuleList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovModule(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovModule(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	return n
}

func sovModule(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModule(x uint64) (n int) {
	return sovModule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ModuleSpec_ModuleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCopies", wireType)
			}
			m.NumCopies = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCopies |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submodules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submodules = append(m.Submodules, &ModuleSpec_Submodule{})
			if err := m.Submodules[len(m.Submodules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &ModuleSpec_Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSpec_Submodule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submodule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submodule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &ModuleSpec_Submodule_Service{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSpec_Submodule_Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSpec_Volume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ModuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ModuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Module{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModule
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModule
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModule(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModule = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModule   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("module.proto", fileDescriptorModule) }

var fileDescriptorModule = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xdf, 0x4e, 0x13, 0x41,
	0x14, 0xc6, 0x3b, 0x74, 0x29, 0xf4, 0x94, 0x22, 0x0e, 0x5e, 0x6c, 0x56, 0x52, 0x9a, 0x45, 0x62,
	0x13, 0x61, 0x8b, 0xeb, 0x85, 0x51, 0x2f, 0x8c, 0xa8, 0x51, 0x12, 0xfe, 0x34, 0x53, 0xc2, 0xfd,
	0xb6, 0x1d, 0xcb, 0x90, 0xce, 0xce, 0xa6, 0x3b, 0x8b, 0xe1, 0x4d, 0xbc, 0xf0, 0x15, 0x7c, 0x0f,
	0xb8, 0xe3, 0x09, 0x88, 0xc1, 0x3b, 0x9f, 0xc2, 0xcc, 0x99, 0x6d, 0x69, 0x85, 0x60, 0xe2, 0xdd,
	0x9c, 0x39, 0xbf, 0x73, 0xe6, 0xfb, 0xce, 0xe9, 0x16, 0x16, 0xa4, 0xea, 0x65, 0x03, 0x1e, 0x24,
	0x43, 0xa5, 0x15, 0x9d, 0xd5, 0x67, 0x09, 0x4f, 0xbd, 0xf5, 0xbe, 0xd0, 0xc7, 0x59, 0x27, 0xe8,
	0x2a, 0xd9, 0x4c, 0x78, 0x9c, 0x46, 0x71, 0x4f, 0x35, 0xd3, 0xaf, 0xcd, 0x28, 0x11, 0x4d, 0xc9,
	0x75, 0x64, 0x69, 0xef, 0xe9, 0x3d, 0x58, 0x57, 0x49, 0xa9, 0xe2, 0x1c, 0xdc, 0x9c, 0x00, 0xfb,
	0xaa, 0xaf, 0x9a, 0x78, 0xdd, 0xc9, 0xbe, 0x60, 0x84, 0x01, 0x9e, 0x2c, 0xee, 0xff, 0x70, 0x00,
	0xf6, 0x50, 0x56, 0x3b, 0xe1, 0x5d, 0xba, 0x05, 0xce, 0xe1, 0x59, 0xc2, 0x5d, 0x52, 0x27, 0x8d,
	0xc5, 0x70, 0x25, 0x40, 0x8d, 0xc1, 0x0d, 0x90, 0x1f, 0x0d, 0xc3, 0x90, 0xa4, 0x2b, 0x50, 0xde,
	0xcf, 0xe4, 0x7b, 0x95, 0x08, 0x9e, 0xba, 0x33, 0x75, 0xd2, 0xa8, 0xb2, 0x9b, 0x0b, 0xfa, 0x06,
	0xa0, 0x9d, 0x75, 0xac, 0xef, 0xd4, 0x2d, 0xd6, 0x8b, 0x8d, 0x4a, 0xf8, 0xf8, 0x76, 0xd7, 0x31,
	0xc3, 0x26, 0x70, 0x1a, 0xc2, 0xdc, 0x91, 0x1a, 0x64, 0x92, 0xa7, 0xae, 0x83, 0x95, 0xee, 0xed,
	0x4a, 0x0b, 0xb0, 0x11, 0xe8, 0x5d, 0x10, 0x28, 0x8f, 0x5b, 0x50, 0x0a, 0xce, 0x7e, 0x24, 0xad,
	0x9d, 0x32, 0xc3, 0x33, 0x7d, 0x04, 0xb3, 0x3b, 0x32, 0xea, 0x73, 0x14, 0x5b, 0x66, 0x36, 0xa0,
	0x6f, 0x61, 0xbe, 0xcd, 0x87, 0xa7, 0xa2, 0x3b, 0x96, 0xb9, 0x76, 0x8f, 0xcc, 0x20, 0x67, 0xd9,
	0xb8, 0x88, 0xd6, 0x00, 0x5a, 0x43, 0x71, 0x2a, 0x06, 0xbc, 0xcf, 0x7b, 0xae, 0x53, 0x27, 0x8d,
	0x79, 0x36, 0x71, 0xe3, 0x3d, 0x87, 0xb9, 0x9c, 0xbd, 0x53, 0x15, 0x05, 0xa7, 0xa5, 0x86, 0x3a,
	0x9f, 0x20, 0x9e, 0xbd, 0x23, 0x28, 0x59, 0x5b, 0x77, 0x56, 0x78, 0x30, 0xff, 0x59, 0xa5, 0xba,
	0x15, 0xe9, 0xe3, 0xdc, 0xca, 0x38, 0x36, 0x4b, 0xd9, 0x53, 0x59, 0x6c, 0x93, 0x45, 0x4c, 0xde,
	0x5c, 0xf8, 0xaf, 0x47, 0x2b, 0xc7, 0x05, 0x56, 0xa1, 0xdc, 0x16, 0x71, 0x7f, 0xc0, 0xb5, 0x8a,
	0x97, 0x0a, 0x26, 0xfc, 0x10, 0x71, 0xa9, 0xe2, 0x36, 0xd7, 0x4b, 0x84, 0x2e, 0x02, 0x30, 0x9e,
	0x0c, 0x44, 0x37, 0x32, 0xf1, 0x8c, 0xff, 0x04, 0x16, 0xf2, 0x81, 0xe8, 0x48, 0x67, 0xa9, 0x99,
	0xe6, 0xbe, 0xea, 0xf1, 0xd4, 0x25, 0xf5, 0xa2, 0x99, 0x26, 0x06, 0xfe, 0x05, 0x81, 0x92, 0xc5,
	0xe8, 0x16, 0x90, 0x43, 0xd4, 0x5d, 0x09, 0xab, 0x41, 0x94, 0x88, 0xc0, 0x3c, 0xba, 0xc7, 0x75,
	0xb4, 0xbd, 0x7c, 0x7e, 0xb5, 0x5a, 0xb8, 0xbc, 0x5a, 0x25, 0xbf, 0xaf, 0x56, 0xe7, 0x36, 0x44,
	0x3c, 0x10, 0x31, 0x67, 0xe4, 0x90, 0xbe, 0x02, 0x72, 0x80, 0x8e, 0x2a, 0xe1, 0x03, 0xac, 0x38,
	0xe8, 0x9c, 0xf0, 0xae, 0xc6, 0x1a, 0x6f, 0xa2, 0x66, 0xd1, 0x7c, 0x1e, 0x1b, 0x4a, 0x0a, 0xcd,
	0x65, 0xa2, 0xcf, 0x18, 0x39, 0xa0, 0xeb, 0xe0, 0x98, 0x45, 0xa1, 0xe5, 0x4a, 0xf8, 0xf0, 0xd6,
	0x06, 0x19, 0xa6, 0xe9, 0x33, 0x28, 0x59, 0xf9, 0xb8, 0xa7, 0x4a, 0xb8, 0x3c, 0x0d, 0x62, 0x8a,
	0xe5, 0x88, 0xff, 0x9d, 0x8c, 0xc6, 0xb5, 0x2b, 0x52, 0xfd, 0x1f, 0x7e, 0x5e, 0x02, 0xd9, 0xcd,
	0xfd, 0xd8, 0x0a, 0xd3, 0xe7, 0xdf, 0x6e, 0x76, 0xe9, 0x1a, 0xcc, 0xee, 0x68, 0x2e, 0x47, 0x3f,
	0xc8, 0xea, 0x94, 0x4a, 0x66, 0x73, 0xe1, 0x89, 0x59, 0xb5, 0xb9, 0x78, 0xd7, 0xda, 0xa1, 0x01,
	0x54, 0xb0, 0x79, 0xfe, 0x01, 0x01, 0x3e, 0xf7, 0xd1, 0xf4, 0xf3, 0xa6, 0x87, 0x61, 0x28, 0xbf,
	0x40, 0x37, 0xa1, 0xfc, 0x89, 0xe7, 0x38, 0xfd, 0x7b, 0xd8, 0xde, 0xf4, 0x83, 0x7e, 0x61, 0x7b,
	0xe9, 0xfc, 0xba, 0x46, 0x2e, 0xaf, 0x6b, 0xe4, 0xe7, 0x75, 0x8d, 0x7c, 0xfb, 0x55, 0x2b, 0x74,
	0x4a, 0xf8, 0x2f, 0xf2, 0xe2, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x86, 0x1d, 0x16, 0x42, 0xdb,
	0x04, 0x00, 0x00,
}
